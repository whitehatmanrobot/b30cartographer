0x00, 0x14, 0xff, 0x22, 0x08, 0x41, 0x10, 0x3c, 0x7e, 0x00, 0x42, 0x00, 0x7e, 0x7e, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x12, 0x7e, 0x16, 0x00, 0x10, 0x26, 0x10, 0xc1, 0x00, 0x00 },
{ 0xd6, 0xc6, 0x04, 0x08, 0x14, 0x14, 0x17, 0x14, 0x14, 0x22, 0x7f, 0xa2, 0x00, 0x5d, 0x24, 0x80, 0x24, 0x80, 0x3f, 0xbf, 0x24, 0x89, 0x2e, 0x89, 0x35, 0x89, 0x24, 0x8b, 0x20, 0x88, 0x3f, 0x88, 0x00, 0x00 },
{ 0xd6, 0xc7, 0x08, 0x01, 0x0b, 0xc1, 0x09, 0x01, 0x11, 0x09, 0x11, 0xc9, 0x32, 0x49, 0x32, 0x49, 0x52, 0x49, 0x55, 0x49, 0x10, 0x89, 0x10, 0x89, 0x10, 0x81, 0x11, 0x01, 0x11, 0x01, 0x12, 0x07, 0x00, 0x00 },
{ 0xd6, 0xc8, 0x20, 0x50, 0x11, 0xfc, 0x09, 0x54, 0x01, 0xfc, 0x41, 0x54, 0x21, 0xfc, 0x10, 0x00, 0x07, 0xff, 0x00, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x21, 0xfc, 0x20, 0x88, 0x40, 0x88, 0x47, 0xff, 0x00, 0x00 },
{ 0xd6, 0xc9, 0x00, 0x28, 0x3c, 0xfe, 0x00, 0xaa, 0x00, 0xfe, 0x7e, 0xaa, 0x08, 0xfe, 0x08, 0x00, 0x2a, 0xff, 0x2a, 0x00, 0x2a, 0x7e, 0x2a, 0x42, 0x2a, 0x7e, 0x08, 0x24, 0x08, 0x24, 0x08, 0xff, 0x00, 0x00 },
{ 0xd6, 0xca, 0x00, 0x14, 0x7f, 0x14, 0x14, 0x7f, 0x14, 0x55, 0x7f, 0x7f, 0x55, 0x55, 0x55, 0x7f, 0x55, 0x00, 0x67, 0x7f, 0x41, 0x00, 0x41, 0x7f, 0x7f, 0x41, 0x41, 0x7f, 0x41, 0x22, 0x7f, 0x7f, 0x00, 0x00 },
{ 0xd6, 0xcb, 0x08, 0x10, 0x7f, 0x10, 0x08, 0x7e, 0x3e, 0x12, 0x00, 0xff, 0x3e, 0x12, 0x00, 0x12, 0x7f, 0x7e, 0x08, 0x99, 0x2a, 0x5a, 0x2a, 0x34, 0x2a, 0x54, 0x08, 0x92, 0x08, 0x11, 0x38, 0x70, 0x00, 0x00 },
{ 0xd6, 0xcc, 0x08, 0x10, 0x29, 0x52, 0x4a, 0x94, 0x14, 0x28, 0x62, 0xc6, 0x00, 0x00, 0x7f, 0xfe, 0x40, 0x02, 0x41, 0x02, 0x01, 0x00, 0x3f, 0xf8, 0x01, 0x08, 0x02, 0x08, 0x0c, 0x08, 0x30, 0x30, 0x00, 0x00 },
{ 0xd6, 0xcd, 0x04, 0x00, 0x08, 0xfc, 0x7f, 0x44, 0x12, 0x44, 0x62, 0x28, 0x14, 0x28, 0x0c, 0x10, 0x12, 0x2c, 0x61, 0xc3, 0x00, 0x00, 0x25, 0x04, 0x24, 0x82, 0x24, 0x51, 0x44, 0x10, 0x03, 0xf0, 0x00, 0x00 },
{ 0xd6, 0xce, 0x11, 0x04, 0x15, 0x55, 0x15, 0x96, 0x79, 0x04, 0x12, 0x8a, 0x14, 0x51, 0x17, 0xff, 0x1c, 0x01, 0x74, 0x41, 0x13, 0xfc, 0x10, 0x44, 0x10, 0x44, 0x10, 0x84, 0x11, 0x04, 0x32, 0x18, 0x00, 0x00 },
{ 0xd6, 0xcf, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x7f, 0xff, 0x12, 0x21, 0x12, 0xfc, 0x12, 0x21, 0x1e, 0xff, 0x72, 0x92, 0x12, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x12, 0xaa, 0x14, 0xaa, 0x65, 0xff, 0x00, 0x00 },
{ 0xd6, 0xd0, 0x10, 0x00, 0x10, 0x78, 0x10, 0x90, 0x7d, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x38, 0x92, 0x38, 0xfe, 0x35, 0x4a, 0x56, 0x25, 0x50, 0xfe, 0x50, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xd6, 0xd1, 0x40, 0x08, 0x27, 0xc8, 0x04, 0x5f, 0x04, 0x71, 0x44, 0x52, 0x27, 0xca, 0x01, 0x04, 0x01, 0x0a, 0x05, 0x31, 0x15, 0xc0, 0x15, 0x1f, 0x25, 0x11, 0x25, 0x11, 0x45, 0xd1, 0x4e, 0x1f, 0x00, 0x00 },
{ 0xd6, 0xd2, 0x20, 0x40, 0x10, 0x7e, 0x08, 0x40, 0x03, 0xff, 0x42, 0x41, 0x23, 0xf8, 0x12, 0x42, 0x02, 0xfe, 0x02, 0xa4, 0x12, 0xfc, 0x12, 0xa4, 0x25, 0xfe, 0x25, 0x52, 0x49, 0x52, 0x43, 0xff, 0x00, 0x00 },
{ 0xd6, 0xd3, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x57, 0xff, 0x5a, 0x21, 0x52, 0xfc, 0x52, 0x21, 0x12, 0xff, 0x12, 0x92, 0x12, 0xfe, 0x2a, 0x92, 0x26, 0xfe, 0x22, 0xaa, 0x44, 0xaa, 0x45, 0xff, 0x00, 0x00 },
{ 0xd6, 0xd4, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x1f, 0xff, 0x10, 0x81, 0x17, 0xf8, 0x10, 0x82, 0x13, 0xfe, 0x12, 0x44, 0x13, 0xfc, 0x12, 0x44, 0x27, 0xfe, 0x24, 0x92, 0x44, 0x92, 0x5f, 0xff, 0x00, 0x00 },
{ 0xd6, 0xd5, 0x01, 0x02, 0x01, 0x02, 0x1f, 0xf4, 0x01, 0x08, 0x01, 0x10, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x80, 0x03, 0x06, 0x06, 0x38, 0x1b, 0xc0, 0x62, 0x00, 0x02, 0x01, 0x02, 0x01, 0x01, 0xff, 0x00, 0x00 },
{ 0xd6, 0xd6, 0x04, 0x20, 0x7f, 0xff, 0x05, 0x20, 0x01, 0xf8, 0x01, 0x00, 0x3f, 0xfe, 0x21, 0x02, 0x2f, 0xf2, 0x21, 0x08, 0x27, 0xf8, 0x24, 0x88, 0x2f, 0xfc, 0x29, 0x24, 0x49, 0x24, 0x5f, 0xfe, 0x00, 0x00 },
{ 0xd6, 0xd7, 0x00, 0x80, 0x00, 0xfe, 0x00, 0x80, 0x1f, 0xff, 0x10, 0x81, 0x17, 0xfa, 0x10, 0x82, 0x13, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x17, 0xff, 0x20, 0x41, 0x21, 0x81, 0x4e, 0x0e, 0x00, 0x00 },
{ 0xd6, 0xd8, 0x00, 0x20, 0x3e, 0x20, 0x22, 0x7e, 0x22, 0x42, 0x22, 0xa4, 0x3e, 0x24, 0x08, 0x18, 0x08, 0x18, 0x28, 0x24, 0x2e, 0xc3, 0x28, 0x7e, 0x28, 0x42, 0x28, 0x42, 0x2e, 0x42, 0x78, 0x7e, 0x00, 0x00 },
{ 0xd6, 0xd9, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x7e, 0x08, 0x42, 0x3e, 0xa4, 0x2a, 0x18, 0x3e, 0x18, 0x2a, 0x24, 0x3e, 0xc3, 0x08, 0x7e, 0x08, 0x42, 0x7f, 0x42, 0x08, 0x42, 0x08, 0x42, 0x08, 0x7e, 0x00, 0x00 },
{ 0xd6, 0xda, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x10, 0x3e, 0x3e, 0x22, 0xc4, 0x3e, 0x38, 0x09, 0xc7, 0x2e, 0x7e, 0x28, 0x42, 0x2e, 0x42, 0x78, 0x7e, 0x00, 0x00 },
{ 0xd6, 0xdb, 0x04, 0x00, 0x0f, 0xe0, 0x10, 0x40, 0x3f, 0xfc, 0x50, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x22, 0x22, 0x41, 0x11, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xd6, 0xdc, 0x00, 0x10, 0x3e, 0x3e, 0x22, 0xc4, 0x3e, 0x38, 0x09, 0xc7, 0x2e, 0x7e, 0x28, 0x42, 0x2f, 0x42, 0x7f, 0xfe, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x00, 0x0f, 0xff, 0x24, 0x91, 0x42, 0x4b, 0x00, 0x00 },
{ 0xd6, 0xdd, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfe, 0x14, 0x8a, 0x13, 0x72, 0x18, 0xca, 0x14, 0xc6, 0x13, 0x32, 0x14, 0x8a, 0x10, 0x42, 0x1f, 0xfe, 0x10, 0x02, 0x00, 0x00 },
{ 0xd6, 0xde, 0x00, 0x20, 0x7c, 0x3e, 0x10, 0x42, 0x10, 0x44, 0x10, 0xfc, 0x20, 0x08, 0x3c, 0x08, 0x25, 0xff, 0x64, 0x10, 0x24, 0x90, 0x24, 0x5a, 0x24, 0x54, 0x3c, 0x94, 0x01, 0x13, 0x00, 0x70, 0x00, 0x00 },
{ 0xd6, 0xdf, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x42, 0x7c, 0x44, 0x04, 0xfc, 0x08, 0x08, 0x08, 0x08, 0x11, 0xff, 0x38, 0x10, 0x54, 0x92, 0x10, 0x5c, 0x10, 0x14, 0x10, 0xd2, 0x13, 0x11, 0x10, 0x30, 0x00, 0x00 },
{ 0xd6, 0xe0, 0x10, 0x20, 0x10, 0x3e, 0x24, 0x42, 0x44, 0x44, 0x28, 0xfc, 0x10, 0x08, 0x10, 0x08, 0x25, 0xff, 0x7c, 0x10, 0x10, 0x92, 0x54, 0x5c, 0x54, 0x34, 0x50, 0x52, 0x11, 0x91, 0x10, 0x30, 0x00, 0x00 },
{ 0xd6, 0xe1, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x00, 0x07, 0xf8, 0x08, 0x10, 0x1f, 0xf0, 0x00, 0x20, 0x7f, 0xff, 0x00, 0x88, 0x09, 0xd0, 0x06, 0xa0, 0x04, 0x98, 0x18, 0x86, 0x03, 0x00, 0x00, 0x00 },
{ 0xd6, 0xe2, 0x18, 0x20, 0x24, 0x3e, 0x40, 0x42, 0x00, 0x44, 0x7c, 0xfc, 0x10, 0x08, 0x10, 0x08, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x9a, 0x54, 0x7c, 0x34, 0x54, 0x11, 0x92, 0x18, 0x11, 0x60, 0x30, 0x00, 0x00 },
{ 0xd6, 0xe3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x20, 0x22, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x24, 0x20, 0x24, 0x20, 0x27, 0xa6, 0x44, 0x38, 0x45, 0xa1, 0x5e, 0x1f, 0x00, 0x00 },
{ 0xd6, 0xe4, 0x08, 0x08, 0x7f, 0x7f, 0x1c, 0x1c, 0x2a, 0x2a, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x24, 0x20, 0x27, 0xa7, 0x44, 0x38, 0x45, 0xa1, 0x5e, 0x1f, 0x00, 0x00 },
{ 0xd6, 0xe5, 0x00, 0x10, 0x3c, 0x28, 0x00, 0x44, 0x7e, 0x82, 0x01, 0x7d, 0x3c, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0xaa, 0x00, 0xaa, 0x3c, 0xfe, 0x24, 0xaa, 0x24, 0xaa, 0x24, 0xaa, 0x3c, 0x86, 0x00, 0x00 },
{ 0xd6, 0xe6, 0x08, 0x40, 0x3e, 0x7e, 0x14, 0x40, 0x7f, 0x7e, 0x00, 0x02, 0x3e, 0x7e, 0x22, 0x40, 0x3e, 0x7c, 0x22, 0x41, 0x22, 0x41, 0x2e, 0x3f, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd6, 0xe7, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xd6, 0xe8, 0x00, 0x88, 0x3c, 0x88, 0x25, 0xef, 0x25, 0x48, 0x25, 0x4e, 0x3f, 0xe2, 0x24, 0x0e, 0x25, 0xe8, 0x25, 0x2e, 0x3d, 0xe8, 0x25, 0x2e, 0x25, 0xe8, 0x25, 0x2e, 0x45, 0x29, 0x4d, 0x67, 0x00, 0x00 },
{ 0xd6, 0xe9, 0x21, 0x08, 0x11, 0x0f, 0x0f, 0xe8, 0x04, 0x4f, 0x42, 0x81, 0x2f, 0xef, 0x00, 0x08, 0x07, 0xcf, 0x04, 0x48, 0x17, 0xcf, 0x14, 0x48, 0x27, 0xcf, 0x24, 0x48, 0x44, 0x49, 0x44, 0xcf, 0x00, 0x00 },
{ 0xd6, 0xea, 0x00, 0x88, 0x00, 0x8f, 0x7b, 0xe8, 0x11, 0x4f, 0x11, 0x41, 0x13, 0xef, 0x78, 0x08, 0x13, 0xef, 0x12, 0x28, 0x13, 0xef, 0x12, 0x28, 0x1b, 0xef, 0x62, 0x28, 0x02, 0x29, 0x02, 0x67, 0x00, 0x00 },
{ 0xd6, 0xeb, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x44, 0x24, 0x3f, 0xbe, 0x12, 0x20, 0x7f, 0xbe, 0x00, 0x02, 0x3f, 0x3e, 0x21, 0x20, 0x3f, 0x3e, 0x21, 0x20, 0x3f, 0x3d, 0x21, 0x21, 0x27, 0x1f, 0x00, 0x00 },
{ 0xd6, 0xec, 0x08, 0x20, 0x7f, 0xbf, 0x12, 0x20, 0x7f, 0xbe, 0x21, 0x02, 0x3f, 0x3e, 0x21, 0x21, 0x21, 0x3f, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x0f, 0x7f, 0xf8, 0x00, 0x08, 0x00, 0x00 },
{ 0xd6, 0xed, 0x08, 0x00, 0x09, 0xfc, 0x09, 0x24, 0x11, 0xfc, 0x11, 0x24, 0x31, 0x24, 0x31, 0xfc, 0x50, 0x00, 0x57, 0xdf, 0x15, 0x55, 0x15, 0x55, 0x17, 0xdf, 0x15, 0x55, 0x15, 0x55, 0x17, 0xdf, 0x00, 0x00 },
{ 0xd6, 0xee, 0x41, 0x00, 0x21, 0x1f, 0x2f, 0xe5, 0x01, 0x09, 0x07, 0xd3, 0x45, 0x40, 0x25, 0x5f, 0x25, 0x51, 0x07, 0xdf, 0x01, 0x11, 0x13, 0x1f, 0x15, 0x91, 0x15, 0x5f, 0x29, 0x0a, 0x61, 0x31, 0x00, 0x00 },
{ 0xd6, 0xef, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x81, 0x08, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xd6, 0xf0, 0x00, 0x00, 0x3f, 0xfe, 0x02, 0x00, 0x04, 0x00, 0x1f, 0xf8, 0x64, 0x08, 0x07, 0xf8, 0x00, 0x00, 0x7f, 0x7f, 0x08, 0x10, 0x10, 0x20, 0x3f, 0x7e, 0x51, 0xa2, 0x11, 0x22, 0x1f, 0x3e, 0x00, 0x00 },
{ 0xd6, 0xf1, 0x00, 0x20, 0x3c, 0x20, 0x24, 0x7e, 0x24, 0x42, 0x3c, 0xa4, 0x25, 0x24, 0x24, 0x18, 0x3c, 0x18, 0x24, 0x64, 0x25, 0x83, 0x24, 0x7e, 0x3c, 0x42, 0x00, 0x42, 0x24, 0x42, 0x42, 0x7e, 0x00, 0x00 },
{ 0xd6, 0xf2, 0x00, 0x80, 0x7f, 0xff, 0x10, 0x84, 0x29, 0xca, 0x46, 0xb1, 0x18, 0x8c, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xd6, 0xf3, 0x08, 0x00, 0x08, 0xff, 0x7f, 0x11, 0x08, 0x21, 0x7f, 0x47, 0x49, 0x80, 0x49, 0x7e, 0x49, 0x42, 0x7f, 0x7e, 0x08, 0x42, 0x1c, 0x7e, 0x1a, 0x42, 0x28, 0x7e, 0x48, 0x24, 0x08, 0xc3, 0x00, 0x00 },
{ 0xd6, 0xf4, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x40, 0x81, 0x1e, 0xbc, 0x00, 0x80, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xd6, 0xf5, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x04, 0x00, 0x08, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xd6, 0xf6, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x50, 0x12, 0x8a, 0x31, 0x04, 0x33, 0xfe, 0x55, 0x05, 0x51, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x10, 0x20, 0x11, 0x24, 0x11, 0x22, 0x12, 0x62, 0x00, 0x00 },
{ 0xd6, 0xf7, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5f, 0xfd, 0x02, 0x20, 0x14, 0x14, 0x0f, 0xf8, 0x14, 0x14, 0x67, 0xf3, 0x04, 0x10, 0x07, 0xf0, 0x08, 0x8c, 0x30, 0x82, 0x03, 0x80, 0x00, 0x00 },
{ 0xd6, 0xf8, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0xbe, 0x24, 0x92, 0x29, 0xa6, 0x22, 0x8a, 0x24, 0x52, 0x20, 0xa0, 0x23, 0x18, 0x2c, 0x07, 0x20, 0x60, 0x47, 0x8c, 0x40, 0x30, 0x47, 0xc0, 0x00, 0x00 },
{ 0xd6, 0xf9, 0x08, 0x04, 0x08, 0x44, 0x4a, 0x24, 0x2c, 0x14, 0x08, 0x04, 0x7e, 0x44, 0x08, 0x24, 0x18, 0x14, 0x1c, 0x07, 0x2a, 0x1c, 0x28, 0xe4, 0x48, 0x04, 0x48, 0x04, 0x08, 0x04, 0x08, 0x04, 0x00, 0x00 },
{ 0xd6, 0xfa, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x54, 0x50, 0x59, 0x8a, 0x51, 0x04, 0x53, 0xfe, 0x15, 0x05, 0x11, 0xfc, 0x11, 0x04, 0x29, 0xfc, 0x24, 0x20, 0x21, 0x24, 0x42, 0x22, 0x44, 0x61, 0x00, 0x00 },
{ 0xd6, 0xfb, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x57, 0xff, 0x30, 0x50, 0x12, 0x8a, 0x11, 0xfc, 0x33, 0x06, 0x55, 0xfd, 0x11, 0x04, 0x11, 0xfc, 0x21, 0x26, 0x26, 0x21, 0x40, 0x60, 0x00, 0x00 },
{ 0xd6, 0xfc, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x50, 0x4a, 0x8a, 0x79, 0x04, 0x4b, 0xfe, 0x4d, 0x05, 0x49, 0xfc, 0x79, 0x04, 0x49, 0xfc, 0x48, 0xa8, 0x49, 0x24, 0x7a, 0x22, 0x00, 0x60, 0x00, 0x00 },
{ 0xd6, 0xfd, 0x00, 0x40, 0x7d, 0x9e, 0x25, 0x12, 0x25, 0x52, 0x3d, 0x52, 0x25, 0x52, 0x25, 0x52, 0x3d, 0x52, 0x25, 0x52, 0x25, 0x52, 0x25, 0xd2, 0x3e, 0x56, 0x64, 0x90, 0x04, 0x90, 0x05, 0x10, 0x00, 0x00 },
{ 0xd6, 0xfe, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x3f, 0x7e, 0x09, 0x12, 0x33, 0x66, 0x05, 0x0a, 0x38, 0xd2, 0x03, 0x30, 0x0c, 0xcc, 0x77, 0x13, 0x00, 0x60, 0x0f, 0x8c, 0x00, 0x30, 0x0f, 0xc0, 0x00, 0x00 },
{ 0xd7, 0xa1, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x40, 0x48, 0x22, 0x85, 0x11, 0xfe, 0x02, 0x85, 0x00, 0xfc, 0x70, 0x84, 0x10, 0xfc, 0x10, 0xa4, 0x13, 0x22, 0x10, 0x60, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xd7, 0xa2, 0x40, 0x02, 0x5e, 0xfa, 0x44, 0x22, 0x5e, 0xfa, 0x44, 0x22, 0x5e, 0xfa, 0x40, 0x02, 0x41, 0x02, 0x5f, 0xfa, 0x41, 0x02, 0x4f, 0xf2, 0x49, 0x12, 0x49, 0x12, 0x49, 0x32, 0x41, 0x06, 0x00, 0x00 },
{ 0xd7, 0xa3, 0x08, 0x20, 0x7f, 0xbf, 0x21, 0x20, 0x12, 0x3e, 0x7f, 0x82, 0x00, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x21, 0x21, 0x21, 0x21, 0x27, 0x1f, 0x00, 0x00 },
{ 0xd7, 0xa4, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0x7e, 0x29, 0x52, 0x3f, 0x7e, 0x29, 0x52, 0x3f, 0x7e, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd7, 0xa5, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x7f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x04, 0x10, 0x0e, 0x20, 0x01, 0xf0, 0x3e, 0x0e, 0x00, 0x00 },
{ 0xd7, 0xa6, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x12, 0x48, 0x1f, 0xfe, 0x12, 0x48, 0x13, 0xf8, 0x12, 0x48, 0x12, 0x48, 0x13, 0xf8, 0x20, 0x40, 0x2f, 0xfe, 0x23, 0x98, 0x40, 0x70, 0x47, 0x8e, 0x00, 0x00 },
{ 0xd7, 0xa7, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x7b, 0xff, 0x10, 0x92, 0x10, 0xfe, 0x38, 0x10, 0x38, 0xfe, 0x34, 0x92, 0x54, 0xfe, 0x50, 0x20, 0x53, 0xff, 0x10, 0xc4, 0x10, 0x78, 0x11, 0x86, 0x00, 0x00 },
{ 0xd7, 0xa8, 0x20, 0x0e, 0x13, 0xf0, 0x02, 0x00, 0x03, 0xfe, 0x42, 0x02, 0x22, 0x02, 0x03, 0xfe, 0x02, 0x14, 0x02, 0x12, 0x13, 0xff, 0x12, 0x10, 0x22, 0x28, 0x24, 0x28, 0x44, 0x44, 0x49, 0x83, 0x00, 0x00 },
{ 0xd7, 0xa9, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x01, 0x02, 0x01, 0x43, 0xff, 0x22, 0x00, 0x13, 0xff, 0x02, 0x10, 0x02, 0x10, 0x12, 0xff, 0x12, 0x91, 0x22, 0xd5, 0x24, 0x91, 0x44, 0xd5, 0x48, 0x93, 0x00, 0x00 },
{ 0xd7, 0xaa, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x24, 0x57, 0xff, 0x31, 0x24, 0x11, 0xfc, 0x11, 0x24, 0x31, 0x24, 0x51, 0xfc, 0x10, 0x44, 0x17, 0xff, 0x10, 0x88, 0x21, 0x90, 0x20, 0x78, 0x47, 0x86, 0x00, 0x00 },
{ 0xd7, 0xab, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x01, 0x00, 0x0a, 0x20, 0x04, 0x44, 0x02, 0x9e, 0x7f, 0xe1, 0x00, 0x81, 0x08, 0x8c, 0x30, 0x82, 0x00, 0x80, 0x00, 0x00 },
{ 0xd7, 0xac, 0x10, 0x10, 0x10, 0xfe, 0x24, 0x92, 0x45, 0xff, 0x28, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x24, 0x92, 0x7c, 0xfe, 0x14, 0x20, 0x51, 0xff, 0x54, 0x44, 0x54, 0xc8, 0x10, 0x38, 0x11, 0xc6, 0x00, 0x00 },
{ 0xd7, 0xad, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x1f, 0xfc, 0x10, 0x84, 0x7f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x04, 0x10, 0x1e, 0x20, 0x01, 0xf0, 0x3e, 0x0c, 0x00, 0x00 },
{ 0xd7, 0xae, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x7d, 0xff, 0x04, 0x92, 0x08, 0xfe, 0x08, 0x10, 0x10, 0xfe, 0x34, 0x92, 0x58, 0xfe, 0x14, 0x20, 0x13, 0xff, 0x10, 0xc4, 0x10, 0x38, 0x13, 0xc6, 0x00, 0x00 },
{ 0xd7, 0xaf, 0x08, 0x10, 0x14, 0xfe, 0x22, 0x92, 0x41, 0xff, 0x3e, 0x92, 0x08, 0xfe, 0x08, 0x92, 0x7e, 0xfe, 0x08, 0x20, 0x4a, 0x20, 0x2b, 0xff, 0x28, 0x84, 0x08, 0x48, 0x0e, 0x38, 0x71, 0xc7, 0x00, 0x00 },
{ 0xd7, 0xb0, 0x79, 0xff, 0x48, 0x10, 0x48, 0x10, 0x52, 0x10, 0x52, 0xfe, 0x62, 0x92, 0x52, 0x92, 0x52, 0xaa, 0x4a, 0xaa, 0x4a, 0xc6, 0x4a, 0x82, 0x72, 0x82, 0x42, 0x8e, 0x42, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xd7, 0xb1, 0x08, 0x01, 0x33, 0xc1, 0x21, 0x49, 0x29, 0x49, 0x2a, 0x49, 0x74, 0xc9, 0x0a, 0x09, 0x11, 0x09, 0x60, 0x89, 0x1f, 0x09, 0x04, 0x09, 0x3f, 0x81, 0x25, 0x01, 0x17, 0xc1, 0x7c, 0x07, 0x00, 0x00 },
{ 0xd7, 0xb2, 0x10, 0x40, 0x10, 0x40, 0x10, 0xfe, 0x7d, 0x20, 0x10, 0x20, 0x10, 0xfe, 0x10, 0x28, 0x1c, 0x4c, 0x14, 0xf2, 0x14, 0x00, 0x14, 0xa4, 0x24, 0xa4, 0x24, 0xa5, 0x25, 0x25, 0x59, 0x27, 0x00, 0x00 },
{ 0xd7, 0xb3, 0x10, 0x20, 0x10, 0x40, 0x11, 0x8f, 0x7d, 0x29, 0x11, 0x29, 0x11, 0x29, 0x39, 0x29, 0x39, 0x29, 0x35, 0x29, 0x55, 0xe9, 0x53, 0x49, 0x50, 0x4b, 0x10, 0x88, 0x11, 0x08, 0x12, 0x08, 0x00, 0x00 },
{ 0xd7, 0xb4, 0x10, 0x60, 0x11, 0x9f, 0x11, 0x09, 0x7d, 0x49, 0x11, 0x29, 0x11, 0x51, 0x39, 0xa6, 0x38, 0x00, 0x34, 0xfe, 0x54, 0x92, 0x50, 0x92, 0x50, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x10, 0xfe, 0x00, 0x00 },
{ 0xd7, 0xb5, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x40, 0x40, 0x84, 0x20, 0x9e, 0x13, 0xe1, 0x00, 0x01, 0x01, 0x24, 0x11, 0x24, 0x11, 0x24, 0x21, 0x24, 0x22, 0x25, 0x42, 0x25, 0x44, 0x27, 0x00, 0x00 },
{ 0xd7, 0xb6, 0x20, 0xc0, 0x13, 0x1f, 0x0a, 0x09, 0x02, 0x89, 0x42, 0x51, 0x23, 0xd1, 0x16, 0x26, 0x00, 0x00, 0x03, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x23, 0xfe, 0x22, 0x22, 0x42, 0x22, 0x43, 0xfe, 0x00, 0x00 },
{ 0xd7, 0xb7, 0x21, 0x01, 0x16, 0xf1, 0x04, 0x55, 0x05, 0x55, 0x4e, 0xb5, 0x20, 0x85, 0x11, 0x45, 0x02, 0x25, 0x04, 0x15, 0x13, 0xe5, 0x10, 0x85, 0x27, 0xf1, 0x20, 0xa1, 0x42, 0xf1, 0x47, 0x83, 0x00, 0x00 },
{ 0xd7, 0xb8, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xff, 0x10, 0x44, 0x10, 0x42, 0x10, 0x9d, 0x13, 0xe1, 0x78, 0x00, 0x11, 0x24, 0x11, 0x24, 0x11, 0x24, 0x19, 0x24, 0x72, 0x25, 0x02, 0x25, 0x04, 0x27, 0x00, 0x00 },
{ 0xd7, 0xb9, 0x00, 0x40, 0x7b, 0x9f, 0x12, 0x09, 0x12, 0x89, 0x12, 0x49, 0x12, 0xd1, 0x7b, 0x56, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x22, 0x1d, 0x22, 0x71, 0xfe, 0x01, 0x22, 0x01, 0x22, 0x01, 0xfe, 0x00, 0x00 },
{ 0xd7, 0xba, 0x03, 0x00, 0x3c, 0x7f, 0x20, 0x11, 0x22, 0x11, 0x21, 0x21, 0x27, 0x21, 0x39, 0x46, 0x60, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xd7, 0xbb, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0xc0, 0x53, 0x3e, 0x32, 0x0a, 0x12, 0x8a, 0x12, 0xd2, 0x33, 0x24, 0x50, 0x00, 0x13, 0xfe, 0x12, 0x22, 0x23, 0xfe, 0x22, 0x22, 0x43, 0xfe, 0x00, 0x00 },
{ 0xd7, 0xbc, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x44, 0x10, 0x42, 0x20, 0x8d, 0x3d, 0xf1, 0x24, 0x00, 0x64, 0x54, 0x24, 0x54, 0x24, 0x54, 0x24, 0x54, 0x3c, 0x95, 0x00, 0x95, 0x01, 0x17, 0x00, 0x00 },
{ 0xd7, 0xbd, 0x00, 0x00, 0x3d, 0xef, 0x00, 0x63, 0x7d, 0xad, 0x00, 0x63, 0x3d, 0xad, 0x00, 0x63, 0x3c, 0x18, 0x00, 0xe4, 0x00, 0x13, 0x3c, 0xe4, 0x24, 0x19, 0x24, 0xe2, 0x24, 0x0c, 0x3c, 0xf0, 0x00, 0x00 },
{ 0xd7, 0xbe, 0x08, 0x00, 0x49, 0x7f, 0x2a, 0x08, 0x08, 0x10, 0x7f, 0x7e, 0x1c, 0x42, 0x2a, 0x7e, 0x49, 0x42, 0x02, 0x7e, 0x0a, 0x42, 0x7f, 0x42, 0x08, 0x7e, 0x14, 0x00, 0x22, 0x26, 0x40, 0xc1, 0x00, 0x00 },
{ 0xd7, 0xbf, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x00, 0x00 },
{ 0xd7, 0xc0, 0x00, 0x08, 0x7b, 0xca, 0x29, 0x49, 0x5a, 0xc8, 0x29, 0x4f, 0x4a, 0x78, 0x04, 0x0a, 0x1b, 0x0a, 0x62, 0xcc, 0x0c, 0x0c, 0x71, 0x08, 0x06, 0x09, 0x38, 0x95, 0x03, 0x23, 0x3c, 0x41, 0x00, 0x00 },
{ 0xd7, 0xc1, 0x00, 0x20, 0x7c, 0x20, 0x45, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x53, 0xff, 0x48, 0x88, 0x48, 0x89, 0x45, 0x0f, 0x44, 0x20, 0x58, 0x20, 0x41, 0xfe, 0x40, 0x20, 0x40, 0x20, 0x43, 0xff, 0x00, 0x00 },
{ 0xd7, 0xc2, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x6f, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x5c, 0x00, 0x00 },
{ 0xd7, 0xc3, 0x08, 0x20, 0x08, 0x50, 0x09, 0x8c, 0x16, 0x03, 0x11, 0xfc, 0x30, 0x00, 0x30, 0x00, 0x53, 0xfe, 0x52, 0x52, 0x12, 0x52, 0x13, 0xfe, 0x12, 0x52, 0x12, 0x52, 0x12, 0x52, 0x12, 0x56, 0x00, 0x00 },
{ 0xd7, 0xc4, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x03, 0x60, 0x0c, 0x18, 0x77, 0xf7, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x4c, 0x00, 0x00 },
{ 0xd7, 0xc5, 0x20, 0x20, 0x10, 0x50, 0x08, 0x88, 0x01, 0x04, 0x42, 0xfa, 0x24, 0x01, 0x10, 0x00, 0x03, 0xfe, 0x02, 0x52, 0x12, 0x52, 0x13, 0xfe, 0x22, 0x52, 0x22, 0x52, 0x42, 0x52, 0x42, 0x56, 0x00, 0x00 },
{ 0xd7, 0xc6, 0x10, 0x20, 0x10, 0x30, 0x24, 0x48, 0x44, 0x84, 0x29, 0x02, 0x12, 0xfd, 0x10, 0x00, 0x25, 0xfe, 0x7d, 0x52, 0x15, 0x52, 0x51, 0xfe, 0x55, 0x52, 0x55, 0x52, 0x11, 0x52, 0x11, 0x06, 0x00, 0x00 },
{ 0xd7, 0xc7, 0x10, 0x10, 0x10, 0x28, 0x7e, 0x44, 0x10, 0x82, 0x11, 0x7d, 0x7e, 0x00, 0x52, 0x00, 0x7e, 0xfe, 0x52, 0xaa, 0x7e, 0xaa, 0x10, 0xfe, 0x7e, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0x86, 0x00, 0x00 },
{ 0xd7, 0xc8, 0x08, 0x20, 0x08, 0x20, 0x11, 0xfe, 0x20, 0x22, 0x4b, 0xff, 0x08, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x30, 0x20, 0x51, 0xfe, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xd7, 0xc9, 0x10, 0x00, 0x13, 0xff, 0x18, 0x50, 0x54, 0x50, 0x57, 0xfe, 0x52, 0x52, 0x52, 0x52, 0x13, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x10, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0x20, 0x00, 0x00 },
{ 0xd7, 0xca, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xd7, 0xcb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x22, 0x04, 0x14, 0x48, 0x02, 0x80, 0x19, 0x18, 0x22, 0x24, 0x47, 0xe2, 0x00, 0xa0, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xd7, 0xcc, 0x00, 0x80, 0x78, 0xfe, 0x49, 0x44, 0x4a, 0x48, 0x50, 0x30, 0x50, 0xcc, 0x63, 0x03, 0x50, 0xfc, 0x50, 0x00, 0x49, 0x10, 0x49, 0xff, 0x5a, 0x10, 0x44, 0xfe, 0x40, 0x10, 0x43, 0xff, 0x00, 0x00 },
{ 0xd7, 0xcd, 0x12, 0x10, 0x12, 0x10, 0x7f, 0x90, 0x12, 0x10, 0x1e, 0x7f, 0x08, 0x11, 0x3f, 0x11, 0x29, 0x11, 0x29, 0x11, 0x3f, 0x21, 0x08, 0x21, 0x7f, 0x21, 0x08, 0x41, 0x08, 0x41, 0x08, 0x8e, 0x00, 0x00 },
{ 0xd7, 0xce, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0xff, 0x22, 0x11, 0x3e, 0x11, 0x22, 0x11, 0x22, 0x11, 0x22, 0x11, 0x3e, 0x11, 0x22, 0x21, 0x22, 0x21, 0x22, 0x21, 0x42, 0x41, 0x4e, 0x86, 0x00, 0x00 },
{ 0xd7, 0xcf, 0x00, 0x40, 0x47, 0xfe, 0x20, 0x00, 0x13, 0xfc, 0x02, 0x94, 0x02, 0xf4, 0x02, 0x04, 0x03, 0xfc, 0x00, 0x08, 0x13, 0xf0, 0x10, 0x40, 0x2f, 0xff, 0x21, 0x50, 0x42, 0x4c, 0x4c, 0x43, 0x00, 0x00 },
{ 0xd7, 0xd0, 0x00, 0x20, 0x23, 0xfe, 0x10, 0x20, 0x07, 0xff, 0x00, 0x90, 0x00, 0x91, 0x09, 0x4f, 0x0a, 0x40, 0x10, 0xfc, 0x10, 0xc4, 0x21, 0x44, 0x22, 0x28, 0x40, 0x10, 0x00, 0x6c, 0x03, 0x83, 0x00, 0x00 },
{ 0xd7, 0xd1, 0x10, 0x00, 0x11, 0xff, 0x11, 0x29, 0x7d, 0x29, 0x11, 0xff, 0x10, 0x20, 0x38, 0x20, 0x39, 0xff, 0x34, 0x40, 0x54, 0x40, 0x50, 0x7e, 0x50, 0x82, 0x10, 0x82, 0x11, 0x02, 0x12, 0x1c, 0x00, 0x00 },
{ 0xd7, 0xd2, 0x0c, 0x10, 0x70, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x48, 0x10, 0x49, 0x18, 0xaf, 0x39, 0x20, 0x34, 0x7c, 0x54, 0xc4, 0x51, 0x44, 0x50, 0x28, 0x10, 0x10, 0x10, 0x6c, 0x13, 0x83, 0x00, 0x00 },
{ 0xd7, 0xd3, 0x10, 0x10, 0x10, 0x10, 0x24, 0xfe, 0x44, 0x10, 0x29, 0xff, 0x10, 0x48, 0x10, 0x49, 0x24, 0x8f, 0x7d, 0x20, 0x10, 0x7c, 0x54, 0xc4, 0x55, 0x28, 0x50, 0x10, 0x10, 0x6c, 0x11, 0x83, 0x00, 0x00 },
{ 0xd7, 0xd4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x21, 0x0c, 0x3f, 0x31, 0x00, 0x03, 0xf0, 0x0e, 0x10, 0x31, 0x20, 0x00, 0xc0, 0x07, 0x38, 0x78, 0x07, 0x00, 0x00 },
{ 0xd7, 0xd5, 0x00, 0x20, 0x7d, 0xfe, 0x44, 0x20, 0x4b, 0xff, 0x48, 0x88, 0x50, 0x89, 0x49, 0x4f, 0x48, 0x40, 0x44, 0xfc, 0x44, 0x84, 0x59, 0x44, 0x42, 0x28, 0x40, 0x10, 0x40, 0x6c, 0x43, 0x83, 0x00, 0x00 },
{ 0xd7, 0xd6, 0x08, 0x00, 0x0b, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x33, 0xfe, 0x32, 0x22, 0x52, 0x22, 0x53, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xd7, 0xd7, 0x03, 0x01, 0x3c, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x7f, 0x91, 0x04, 0x11, 0x0e, 0x11, 0x0d, 0x11, 0x14, 0x91, 0x24, 0x11, 0x44, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x07, 0x00, 0x00 },
{ 0xd7, 0xd8, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x20, 0x20, 0x20, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xd7, 0xd9, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x1f, 0xfe, 0x00, 0x80, 0x08, 0x80, 0x05, 0x00, 0x03, 0x00, 0x0c, 0xe0, 0x70, 0x1f, 0x00, 0x00 },
{ 0xd7, 0xda, 0x00, 0x61, 0x03, 0x81, 0x78, 0x89, 0x48, 0x89, 0x4f, 0xe9, 0x48, 0x89, 0x49, 0x89, 0x49, 0xc9, 0x49, 0xa9, 0x7a, 0xa9, 0x02, 0x89, 0x04, 0x81, 0x00, 0x81, 0x00, 0x81, 0x00, 0x86, 0x00, 0x00 },
{ 0xd7, 0xdb, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x01, 0x3f, 0xff, 0x22, 0x40, 0x24, 0xff, 0x29, 0x42, 0x22, 0x7e, 0x22, 0x42, 0x24, 0x7e, 0x2c, 0x10, 0x34, 0x3e, 0x44, 0xe2, 0x44, 0x1c, 0x44, 0xe3, 0x00, 0x00 },
{ 0xd7, 0xdc, 0x10, 0x62, 0x13, 0x82, 0x18, 0x8a, 0x54, 0x8a, 0x53, 0xea, 0x50, 0x8a, 0x51, 0x8a, 0x11, 0xca, 0x11, 0xaa, 0x12, 0x8a, 0x12, 0x8a, 0x14, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xd7, 0xdd, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x03, 0x0f, 0xf0, 0x00, 0x20, 0x00, 0xc0, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xd7, 0xde, 0x03, 0x02, 0x3c, 0x22, 0x04, 0x22, 0x7f, 0x22, 0x0c, 0x22, 0x16, 0x02, 0x25, 0x02, 0x44, 0x0e, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xd7, 0xdf, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x22, 0x02, 0x22, 0x43, 0xfe, 0x22, 0x22, 0x12, 0x22, 0x03, 0xfe, 0x00, 0x20, 0x10, 0x20, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xd7, 0xe0, 0x06, 0x02, 0x38, 0x02, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x22, 0x1c, 0x22, 0x2a, 0x02, 0x48, 0x8e, 0x04, 0x80, 0x0f, 0xfc, 0x10, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xd7, 0xe1, 0x04, 0x00, 0x45, 0xfe, 0x29, 0x22, 0x11, 0x22, 0x31, 0xfe, 0x51, 0x22, 0x09, 0x22, 0x09, 0xfe, 0x18, 0x20, 0x28, 0x20, 0x49, 0xfe, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x63, 0xff, 0x00, 0x00 },
{ 0xd7, 0xe2, 0x00, 0x00, 0x01, 0xfe, 0x7d, 0x22, 0x11, 0x22, 0x11, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x7d, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x1d, 0xfe, 0x70, 0x20, 0x00, 0x20, 0x03, 0xff, 0x00, 0x00 },
{ 0xd7, 0xe3, 0x00, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x10, 0xaa, 0x10, 0x92, 0x10, 0xaa, 0x7c, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x11, 0x21, 0x11, 0x29, 0x1d, 0x4d, 0x71, 0x75, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00 },
{ 0xd7, 0xe4, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x06, 0x30, 0x18, 0x0c, 0x20, 0x02, 0x00, 0x00 },
{ 0xd7, 0xe5, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0xc2, 0x37, 0x12, 0x11, 0x12, 0x17, 0xd2, 0x31, 0x12, 0x53, 0x92, 0x13, 0x52, 0x15, 0x52, 0x29, 0x02, 0x21, 0x02, 0x41, 0x0e, 0x00, 0x00 },
{ 0xd7, 0xe6, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x80, 0x04, 0x12, 0x7f, 0xa4, 0x2a, 0xff, 0x24, 0xa4, 0x2a, 0xa4, 0x3f, 0xbf, 0x04, 0x24, 0x3f, 0xbf, 0x2a, 0xa4, 0x2e, 0xa4, 0x21, 0xbf, 0x00, 0x00 },
{ 0xd7, 0xe7, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x10, 0x48, 0x18, 0x90, 0x55, 0xfe, 0x56, 0x90, 0x50, 0xfe, 0x10, 0x90, 0x10, 0xfe, 0x10, 0x90, 0x10, 0x90, 0x10, 0xfe, 0x00, 0x00 },
{ 0xd7, 0xe8, 0x00, 0x80, 0x3f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x0f, 0xfc, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x40, 0x3d, 0xdc, 0x24, 0x94, 0x3d, 0xd4, 0x24, 0xbc, 0x3d, 0xd4, 0x44, 0x95, 0x4c, 0xa7, 0x00, 0x00 },
{ 0xd7, 0xe9, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x03, 0x02, 0x3c, 0x12, 0x04, 0x12, 0x04, 0x12, 0x7f, 0x92, 0x0c, 0x12, 0x0e, 0x12, 0x15, 0x12, 0x24, 0x82, 0x44, 0x02, 0x04, 0x0e, 0x00, 0x00 },
{ 0xd7, 0xea, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x44, 0x7c, 0x28, 0x05, 0xd8, 0x3e, 0x07, 0x00, 0x00 },
{ 0xd7, 0xeb, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x92, 0x7c, 0x92, 0x04, 0xfe, 0x08, 0x92, 0x08, 0x92, 0x10, 0xfe, 0x34, 0x10, 0x58, 0x10, 0x14, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xd7, 0xec, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd7, 0xed, 0x08, 0x10, 0x3e, 0x3f, 0x08, 0x52, 0x7f, 0x0c, 0x1c, 0x33, 0x2a, 0x00, 0x5f, 0xff, 0x12, 0x44, 0x13, 0xfc, 0x12, 0x44, 0x13, 0xfc, 0x10, 0x40, 0x23, 0xfc, 0x20, 0x40, 0x4f, 0xff, 0x00, 0x00 },
{ 0xd7, 0xee, 0x08, 0x12, 0x08, 0x12, 0x7f, 0x24, 0x00, 0x3f, 0x55, 0x64, 0x49, 0xa4, 0x55, 0x24, 0x7f, 0x3f, 0x08, 0x24, 0x7f, 0x24, 0x49, 0x3f, 0x55, 0x24, 0x5d, 0x24, 0x41, 0x24, 0x47, 0x3f, 0x00, 0x00 },
{ 0xd7, 0xef, 0x10, 0x00, 0x1c, 0xfe, 0x24, 0x92, 0x28, 0x92, 0x7e, 0xfe, 0x2a, 0x92, 0x2a, 0x92, 0x3e, 0xfe, 0x2a, 0x10, 0x2a, 0x10, 0x3e, 0xfe, 0x00, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xd7, 0xf0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x04, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xd7, 0xf1, 0x21, 0x24, 0x10, 0xa4, 0x10, 0xa8, 0x43, 0xfe, 0x28, 0x70, 0x29, 0xac, 0x0a, 0x23, 0x01, 0x02, 0x01, 0xff, 0x12, 0x2a, 0x15, 0x4a, 0x20, 0xca, 0x20, 0x9f, 0x41, 0x02, 0x46, 0x02, 0x00, 0x00 },
{ 0xd7, 0xf2, 0x11, 0x22, 0x10, 0xa4, 0x10, 0x20, 0x53, 0xff, 0x54, 0x70, 0x58, 0xa8, 0x53, 0x26, 0x10, 0x82, 0x10, 0xff, 0x11, 0x2a, 0x2a, 0x4a, 0x25, 0x4a, 0x20, 0x9f, 0x41, 0x02, 0x42, 0x02, 0x00, 0x00 },
{ 0xd7, 0xf3, 0x01, 0x24, 0x00, 0xa4, 0x7c, 0xa8, 0x11, 0xfe, 0x10, 0x70, 0x10, 0xa8, 0x7d, 0x24, 0x10, 0x82, 0x10, 0xff, 0x11, 0x2a, 0x1e, 0xaa, 0x70, 0x4a, 0x00, 0x5f, 0x00, 0x82, 0x03, 0x02, 0x00, 0x00 },
{ 0xd7, 0xf4, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x44, 0x42, 0x4f, 0xf2, 0x54, 0x82, 0x47, 0xe2, 0x44, 0x82, 0x47, 0xf2, 0x40, 0x0e, 0x00, 0x00 },
{ 0xd7, 0xf5, 0x00, 0x44, 0x3d, 0xff, 0x24, 0x44, 0x25, 0xef, 0x25, 0x29, 0x3d, 0xef, 0x09, 0x29, 0x09, 0xef, 0x29, 0x51, 0x2d, 0x7d, 0x29, 0xd1, 0x29, 0x7d, 0x29, 0x51, 0x2d, 0x7d, 0x71, 0x03, 0x00, 0x00 },
{ 0xd7, 0xf6, 0x7c, 0x92, 0x44, 0x54, 0x48, 0x10, 0x49, 0xff, 0x50, 0x38, 0x48, 0x54, 0x49, 0x93, 0x44, 0x82, 0x44, 0xff, 0x45, 0x2a, 0x59, 0xaa, 0x42, 0x4a, 0x40, 0x5f, 0x40, 0x82, 0x41, 0x02, 0x00, 0x00 },
{ 0xd7, 0xf7, 0x10, 0x92, 0x1c, 0x54, 0x24, 0x10, 0x29, 0xff, 0x7e, 0x38, 0x2a, 0x54, 0x2b, 0x93, 0x3e, 0x10, 0x2a, 0x82, 0x2a, 0xff, 0x3f, 0x2a, 0x00, 0xaa, 0x2a, 0x5f, 0x2a, 0x82, 0x41, 0x02, 0x00, 0x00 },
{ 0xd7, 0xf8, 0x04, 0x49, 0x04, 0x2a, 0x3f, 0x88, 0x2a, 0x7f, 0x2a, 0x1c, 0x3f, 0xaa, 0x2a, 0xc9, 0x3f, 0xa2, 0x20, 0x3a, 0x2a, 0x2f, 0x2f, 0x6a, 0x2a, 0x52, 0x4e, 0x9f, 0x5b, 0xa2, 0x40, 0x42, 0x00, 0x00 },
{ 0xd7, 0xf9, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x7e, 0xfe, 0x08, 0x10, 0x18, 0x38, 0x1c, 0x38, 0x2c, 0x54, 0x2a, 0x54, 0x48, 0x92, 0x49, 0x11, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xd7, 0xfa, 0x21, 0x08, 0x11, 0x08, 0x09, 0x08, 0x07, 0xbe, 0x41, 0x08, 0x21, 0x08, 0x13, 0x9c, 0x03, 0x5c, 0x05, 0x2a, 0x15, 0x2a, 0x19, 0x49, 0x21, 0x08, 0x21, 0x08, 0x41, 0x08, 0x41, 0x08, 0x00, 0x00 },
{ 0xd7, 0xfb, 0x00, 0x84, 0x00, 0x84, 0x7c, 0x84, 0x13, 0xdf, 0x10, 0x84, 0x10, 0x84, 0x11, 0xce, 0x7d, 0xae, 0x11, 0x95, 0x12, 0x95, 0x12, 0xa4, 0x1c, 0x84, 0x70, 0x84, 0x00, 0x84, 0x00, 0x84, 0x00, 0x00 },
{ 0xd7, 0xfc, 0x00, 0x40, 0x7e, 0x40, 0x48, 0xff, 0x48, 0x80, 0x49, 0x00, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x00, 0x48, 0xef, 0x48, 0xa9, 0x48, 0xa9, 0x7e, 0xa9, 0x00, 0xef, 0x00, 0x00 },
{ 0xd7, 0xfd, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x00, 0x00, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x1c, 0x1c, 0x2a, 0x2a, 0x49, 0x49, 0x08, 0x08, 0x00, 0x00 },
{ 0xd7, 0xfe, 0x00, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x10, 0xfe, 0x10, 0x00, 0x20, 0x00, 0x3c, 0x84, 0x64, 0x84, 0x24, 0x48, 0x24, 0x48, 0x24, 0x48, 0x24, 0x10, 0x3c, 0x10, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xd8, 0xa1, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x20, 0x00, 0x20, 0x00, 0x40, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd8, 0xa2, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x08, 0x08, 0x08, 0x04, 0x08, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd8, 0xa3, 0x08, 0x10, 0x08, 0x10, 0x4a, 0x10, 0x2c, 0xfe, 0x08, 0x00, 0x7e, 0x02, 0x08, 0x82, 0x18, 0x82, 0x1c, 0x44, 0x2a, 0x44, 0x28, 0x44, 0x48, 0x44, 0x48, 0x08, 0x08, 0x08, 0x09, 0xff, 0x00, 0x00 },
{ 0xd8, 0xa4, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x08, 0x2f, 0xbe, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xab, 0x23, 0xf0, 0x20, 0x40, 0x27, 0xfe, 0x20, 0x40, 0x4f, 0xff, 0x40, 0x40, 0x41, 0xc0, 0x00, 0x00 },
{ 0xd8, 0xa5, 0x00, 0x00, 0x01, 0xfe, 0x7d, 0x10, 0x11, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x7d, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x11, 0xff, 0x10, 0x01, 0x1c, 0x09, 0x72, 0xa5, 0x02, 0x51, 0x04, 0x06, 0x00, 0x00 },
{ 0xd8, 0xa6, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x51, 0x08, 0x31, 0x08, 0x17, 0xdf, 0x11, 0x08, 0x35, 0x2a, 0x55, 0x2a, 0x15, 0x2a, 0x15, 0x2a, 0x29, 0x2b, 0x29, 0x48, 0x41, 0x08, 0x00, 0x00 },
{ 0xd8, 0xa7, 0x00, 0x00, 0x7c, 0xff, 0x10, 0x90, 0x10, 0x90, 0x10, 0xfe, 0x20, 0x90, 0x3c, 0xfe, 0x24, 0x90, 0x64, 0x90, 0x24, 0xff, 0x24, 0x01, 0x24, 0x05, 0x3d, 0x55, 0x01, 0x51, 0x02, 0x0e, 0x00, 0x00 },
{ 0xd8, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x08, 0x2f, 0xbe, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xaa, 0x2f, 0xff, 0x20, 0x80, 0x21, 0x00, 0x27, 0xfe, 0x5a, 0x02, 0x42, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xa9, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x80, 0x10, 0x80, 0x1f, 0xfe, 0x10, 0x80, 0x1f, 0xfe, 0x10, 0x80, 0x10, 0x80, 0x1f, 0xff, 0x00, 0x01, 0x24, 0x91, 0x22, 0x49, 0x40, 0x02, 0x00, 0x0c, 0x00, 0x00 },
{ 0xd8, 0xaa, 0x00, 0x40, 0x3f, 0xff, 0x22, 0x08, 0x2f, 0xbe, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xaa, 0x27, 0xfc, 0x24, 0x44, 0x27, 0xfc, 0x24, 0x44, 0x27, 0xfc, 0x41, 0x49, 0x46, 0x55, 0x58, 0x7f, 0x00, 0x00 },
{ 0xd8, 0xab, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x22, 0x08, 0x22, 0x08, 0x2f, 0xbe, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0x2a, 0x52, 0x49, 0x42, 0x08, 0x42, 0x08, 0x00, 0x00 },
{ 0xd8, 0xac, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x30, 0x38, 0x0e, 0x00, 0x00 },
{ 0xd8, 0xad, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x88, 0x1f, 0xfc, 0x68, 0x8b, 0x08, 0xb8, 0x00, 0x80, 0x00, 0x00 },
{ 0xd8, 0xae, 0x20, 0x88, 0x17, 0xff, 0x08, 0x88, 0x00, 0x00, 0x43, 0xfe, 0x22, 0x02, 0x13, 0xfe, 0x02, 0x02, 0x03, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x20, 0x20, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xd8, 0xaf, 0x00, 0x44, 0x3d, 0xff, 0x24, 0x44, 0x24, 0x00, 0x24, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x10, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x44, 0x6c, 0x4d, 0x83, 0x00, 0x00 },
{ 0xd8, 0xb0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xd8, 0xb1, 0x21, 0x08, 0x16, 0x08, 0x01, 0x7e, 0x45, 0xa2, 0x23, 0x3e, 0x04, 0xa2, 0x01, 0xbe, 0x06, 0x54, 0x70, 0xd4, 0x11, 0x54, 0x16, 0x55, 0x10, 0xa5, 0x13, 0x43, 0x28, 0x00, 0x47, 0xff, 0x00, 0x00 },
{ 0xd8, 0xb2, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x04, 0x08, 0x04, 0x10, 0x08, 0x20, 0x08, 0x40, 0x70, 0x00, 0x00 },
{ 0xd8, 0xb3, 0x00, 0x02, 0x3f, 0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x82, 0x3f, 0xfe, 0x20, 0x80, 0x20, 0x80, 0x20, 0x80, 0x20, 0x80, 0x20, 0x80, 0x20, 0x80, 0x20, 0xff, 0x00, 0x00 },
{ 0xd8, 0xb4, 0x10, 0x20, 0x10, 0x20, 0x10, 0x7c, 0x7c, 0x44, 0x24, 0x88, 0x25, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x44, 0x92, 0x68, 0xfe, 0x58, 0x28, 0x08, 0x48, 0x14, 0x49, 0x22, 0x89, 0x41, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xb5, 0x11, 0xc4, 0x64, 0x19, 0x29, 0xea, 0x10, 0x04, 0x25, 0xc9, 0x7c, 0x1f, 0x11, 0xc4, 0x55, 0x55, 0x55, 0x55, 0x51, 0xd4, 0x10, 0x04, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xb6, 0x11, 0xc8, 0x64, 0x12, 0x29, 0xcc, 0x14, 0x09, 0x7d, 0xdf, 0x10, 0x04, 0x55, 0xd5, 0x55, 0x55, 0x1f, 0xfc, 0x00, 0x04, 0x1f, 0xfc, 0x10, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x00, 0x3c, 0x00, 0x00 },
{ 0xd8, 0xb7, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x58, 0xfe, 0x54, 0x82, 0x55, 0xff, 0x51, 0x29, 0x11, 0x29, 0x11, 0xff, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x42, 0x10, 0x24, 0x10, 0x38, 0x13, 0xc7, 0x00, 0x00 },
{ 0xd8, 0xb8, 0x10, 0x40, 0x10, 0xf0, 0x11, 0x10, 0x7e, 0x20, 0x11, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x1d, 0x22, 0x71, 0xfe, 0x10, 0x48, 0x10, 0x48, 0x10, 0x88, 0x10, 0x89, 0x11, 0x09, 0x36, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xb9, 0x00, 0x40, 0x78, 0xf0, 0x49, 0x10, 0x4a, 0x20, 0x49, 0xfe, 0x49, 0x22, 0x79, 0x22, 0x49, 0x22, 0x49, 0xfe, 0x48, 0x28, 0x48, 0x48, 0x48, 0x48, 0x78, 0x89, 0x01, 0x09, 0x06, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xba, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x1f, 0xfc, 0x04, 0x08, 0x02, 0x10, 0x01, 0xe0, 0x7e, 0x1f, 0x00, 0x00 },
{ 0xd8, 0xbb, 0x20, 0x88, 0x10, 0x88, 0x0b, 0xff, 0x00, 0x88, 0x40, 0xf8, 0x20, 0x20, 0x13, 0xff, 0x02, 0x21, 0x03, 0xad, 0x12, 0xa5, 0x12, 0xa5, 0x23, 0x6b, 0x22, 0x21, 0x42, 0x21, 0x42, 0x27, 0x00, 0x00 },
{ 0xd8, 0xbc, 0x20, 0x00, 0x11, 0xfe, 0x09, 0x02, 0x01, 0xfe, 0x41, 0x02, 0x23, 0xff, 0x12, 0x49, 0x02, 0x49, 0x03, 0xff, 0x10, 0x00, 0x13, 0xfe, 0x20, 0x84, 0x20, 0x48, 0x40, 0x30, 0x43, 0xcf, 0x00, 0x00 },
{ 0xd8, 0xbd, 0x22, 0x72, 0x15, 0x05, 0x02, 0x72, 0x05, 0x05, 0x47, 0x77, 0x22, 0x02, 0x17, 0x75, 0x05, 0x55, 0x03, 0xfe, 0x10, 0x02, 0x13, 0xfe, 0x22, 0x00, 0x27, 0xff, 0x44, 0x01, 0x40, 0x1e, 0x00, 0x00 },
{ 0xd8, 0xbe, 0x00, 0x88, 0x78, 0x88, 0x4b, 0xff, 0x48, 0x88, 0x48, 0x88, 0x78, 0xf8, 0x48, 0x20, 0x4b, 0xff, 0x7a, 0x21, 0x4b, 0xad, 0x4a, 0xa5, 0x4a, 0xad, 0x7b, 0x73, 0x02, 0x21, 0x02, 0x27, 0x00, 0x00 },
{ 0xd8, 0xbf, 0x04, 0x20, 0x7f, 0xfe, 0x04, 0x20, 0x00, 0x00, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x01, 0x00, 0x7f, 0xfe, 0x41, 0x22, 0x41, 0xf2, 0x5e, 0x12, 0x40, 0x0e, 0x00, 0x00 },
{ 0xd8, 0xc0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x0f, 0xf8, 0x04, 0x10, 0x03, 0xe0, 0x3c, 0x1f, 0x00, 0x00 },
{ 0xd8, 0xc1, 0x10, 0x84, 0x21, 0xc8, 0x48, 0x12, 0x31, 0xcc, 0x24, 0x09, 0x7d, 0xdf, 0x11, 0x44, 0x55, 0x55, 0x55, 0xd5, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xfb, 0x00, 0x00 },
{ 0xd8, 0xc2, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x3c, 0x08, 0x24, 0x3e, 0x48, 0x2a, 0xfe, 0x3e, 0x52, 0x2a, 0x52, 0x3e, 0x52, 0x08, 0x7e, 0x08, 0x28, 0x7f, 0x28, 0x08, 0x49, 0x08, 0x89, 0x09, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xc3, 0x08, 0x00, 0x14, 0x7e, 0x22, 0x42, 0x5d, 0x7e, 0x00, 0x42, 0x3e, 0xff, 0x22, 0xa9, 0x3e, 0xa9, 0x22, 0xff, 0x3e, 0x00, 0x20, 0x7e, 0x3e, 0x22, 0x20, 0x14, 0x3e, 0x1c, 0x20, 0xe3, 0x00, 0x00 },
{ 0xd8, 0xc4, 0x10, 0x00, 0x1c, 0x7e, 0x24, 0x42, 0x28, 0x7e, 0x7e, 0x42, 0x2a, 0xff, 0x2a, 0xa9, 0x3e, 0xa9, 0x2a, 0xff, 0x2a, 0x00, 0x3e, 0x7e, 0x00, 0x22, 0x55, 0x14, 0x55, 0x1c, 0x54, 0xe3, 0x00, 0x00 },
{ 0xd8, 0xc5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x3f, 0x44, 0x21, 0x58, 0x21, 0x62, 0x21, 0x42, 0x3f, 0x3e, 0x00, 0x00 },
{ 0xd8, 0xc6, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x7b, 0xff, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x18, 0x20, 0x70, 0x70, 0x10, 0xa8, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x14, 0x21, 0x30, 0x20, 0x00, 0x00 },
{ 0xd8, 0xc7, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0xc0, 0x02, 0xa0, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xd8, 0xc8, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x07, 0xff, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x03, 0xfe, 0x00, 0x70, 0x10, 0xa8, 0x10, 0xa8, 0x21, 0x24, 0x22, 0x22, 0x44, 0x21, 0x40, 0x20, 0x00, 0x00 },
{ 0xd8, 0xc9, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x02, 0xa0, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x30, 0x86, 0x00, 0x80, 0x00, 0x00 },
{ 0xd8, 0xca, 0x10, 0x50, 0x11, 0xfe, 0x10, 0x50, 0x7d, 0xfe, 0x05, 0x52, 0x09, 0xfe, 0x08, 0x04, 0x10, 0x12, 0x35, 0xff, 0x59, 0x10, 0x15, 0x12, 0x11, 0xcc, 0x12, 0x09, 0x12, 0x35, 0x14, 0xc3, 0x00, 0x00 },
{ 0xd8, 0xcb, 0x28, 0x10, 0x28, 0x10, 0x7c, 0x10, 0x29, 0xff, 0x38, 0x10, 0x10, 0x10, 0x7c, 0xfe, 0x54, 0x10, 0x54, 0x38, 0x7c, 0x38, 0x10, 0x54, 0x7c, 0x54, 0x10, 0x92, 0x11, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xd8, 0xcc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xcd, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x00, 0x08, 0x00, 0x07, 0xfc, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x08, 0x04, 0x10, 0x0b, 0xa0, 0x00, 0x70, 0x03, 0x8c, 0x3c, 0x02, 0x00, 0x00 },
{ 0xd8, 0xce, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xd8, 0xcf, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x5b, 0xff, 0x54, 0x80, 0x54, 0x80, 0x50, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x7e, 0x00, 0x00 },
{ 0xd8, 0xd0, 0x08, 0x00, 0x08, 0x3f, 0x7f, 0xa1, 0x20, 0x3f, 0x20, 0x21, 0x20, 0x3f, 0x1f, 0x41, 0x00, 0x8e, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd8, 0xd1, 0x10, 0x00, 0x11, 0xff, 0x25, 0x01, 0x45, 0x45, 0x29, 0x29, 0x11, 0x7d, 0x11, 0x11, 0x25, 0x11, 0x7d, 0x7d, 0x11, 0x21, 0x55, 0x21, 0x55, 0x3d, 0x51, 0x01, 0x11, 0x01, 0x11, 0x07, 0x00, 0x00 },
{ 0xd8, 0xd2, 0x00, 0x00, 0x7f, 0xfe, 0x40, 0x02, 0x44, 0x22, 0x42, 0x42, 0x5f, 0xfa, 0x41, 0x02, 0x41, 0x02, 0x5f, 0xfa, 0x48, 0x02, 0x48, 0x02, 0x48, 0x02, 0x47, 0xe2, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xd8, 0xd3, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xfe, 0x04, 0x20, 0x04, 0x20, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xd8, 0xd4, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x20, 0x10, 0x10, 0x10, 0x00, 0x10, 0x43, 0xff, 0x20, 0x80, 0x08, 0x80, 0x08, 0x80, 0x10, 0x80, 0x10, 0x80, 0x20, 0x80, 0x40, 0x7e, 0x00, 0x00 },
{ 0xd8, 0xd5, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x62, 0x23, 0x02, 0x20, 0x1f, 0xfc, 0x02, 0x20, 0x04, 0x20, 0x18, 0x20, 0x00, 0x00 },
{ 0xd8, 0xd6, 0x10, 0x00, 0x10, 0x00, 0x7d, 0xfe, 0x11, 0x02, 0x7d, 0x8a, 0x55, 0x52, 0x7d, 0xfe, 0x55, 0x22, 0x7d, 0xfe, 0x11, 0x42, 0x11, 0x42, 0x7d, 0x3a, 0x11, 0x02, 0x11, 0x02, 0x11, 0x0c, 0x00, 0x00 },
{ 0xd8, 0xd7, 0x04, 0x00, 0x04, 0x1f, 0x04, 0x11, 0x7f, 0xd2, 0x10, 0x12, 0x10, 0x14, 0x10, 0x12, 0x10, 0x12, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x16, 0x0f, 0x90, 0x00, 0x10, 0x00, 0x00 },
{ 0xd8, 0xd8, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x7d, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x1d, 0xfe, 0x70, 0x20, 0x00, 0x20, 0x00, 0x20, 0x03, 0xff, 0x00, 0x00 },
{ 0xd8, 0xd9, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x44, 0x38, 0x68, 0x54, 0x58, 0x54, 0x08, 0x92, 0x15, 0x12, 0x22, 0x11, 0x40, 0x10, 0x00, 0x00 },
{ 0xd8, 0xda, 0x10, 0x44, 0x10, 0x44, 0x11, 0xff, 0x7c, 0x44, 0x24, 0x7c, 0x24, 0x44, 0x24, 0x44, 0x24, 0x7c, 0x44, 0x10, 0x69, 0xff, 0x58, 0x38, 0x08, 0x54, 0x14, 0x92, 0x23, 0x11, 0x40, 0x10, 0x00, 0x00 },
{ 0xd8, 0xdb, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x44, 0x11, 0x24, 0x10, 0x24, 0xfe, 0x3c, 0x10, 0x04, 0x10, 0x05, 0xff, 0x7c, 0x38, 0x24, 0x54, 0x24, 0x92, 0x25, 0x11, 0x44, 0x10, 0x04, 0x30, 0x00, 0x00 },
{ 0xd8, 0xdc, 0x00, 0x20, 0x78, 0x20, 0x48, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x70, 0x48, 0xa8, 0x48, 0xa8, 0x79, 0x24, 0x06, 0x23, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xd8, 0xdd, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7c, 0xff, 0x10, 0x84, 0x10, 0x84, 0x39, 0x44, 0x38, 0x44, 0x34, 0x44, 0x54, 0x28, 0x50, 0x28, 0x50, 0x10, 0x10, 0x28, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xd8, 0xde, 0x10, 0x80, 0x10, 0x80, 0x11, 0xff, 0x7d, 0x00, 0x12, 0x00, 0x12, 0xfe, 0x38, 0x92, 0x38, 0x92, 0x35, 0xff, 0x54, 0x92, 0x50, 0x92, 0x50, 0x92, 0x11, 0xff, 0x11, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xd8, 0xdf, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x20, 0x00, 0x07, 0xfc, 0x04, 0x44, 0x04, 0x44, 0x7f, 0xff, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x1f, 0xff, 0x10, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xd8, 0xe0, 0x10, 0x88, 0x10, 0x88, 0x13, 0xff, 0x54, 0x88, 0x58, 0xf8, 0x50, 0x88, 0x50, 0x88, 0x10, 0xf8, 0x10, 0x20, 0x13, 0xff, 0x28, 0x70, 0x24, 0xa8, 0x21, 0x24, 0x46, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xd8, 0xe1, 0x00, 0x00, 0x3f, 0xff, 0x22, 0x21, 0x3f, 0xff, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xff, 0x24, 0x91, 0x22, 0x49, 0x40, 0x06, 0x00, 0x00 },
{ 0xd8, 0xe2, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x78, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xe3, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xd8, 0xe4, 0x20, 0x88, 0x13, 0xfe, 0x00, 0x88, 0x41, 0xfc, 0x21, 0x24, 0x01, 0xfc, 0x01, 0x24, 0x01, 0xfc, 0x70, 0x20, 0x13, 0xfe, 0x12, 0x2a, 0x12, 0xf2, 0x12, 0x0e, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xd8, 0xe5, 0x04, 0x08, 0x08, 0x08, 0x3f, 0x3e, 0x29, 0x08, 0x29, 0x08, 0x3f, 0x7f, 0x29, 0x08, 0x29, 0x1c, 0x3f, 0x2a, 0x14, 0xc9, 0x14, 0x88, 0x15, 0x48, 0x25, 0xc1, 0x24, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xd8, 0xe6, 0x00, 0x07, 0x3c, 0xf8, 0x24, 0x80, 0x24, 0x80, 0x24, 0x83, 0x3c, 0xbc, 0x24, 0xa8, 0x24, 0xa9, 0x24, 0xaa, 0x3c, 0xa4, 0x24, 0xa4, 0x24, 0xa4, 0x25, 0x22, 0x45, 0x22, 0x4d, 0x21, 0x00, 0x00 },
{ 0xd8, 0xe7, 0x0d, 0xff, 0x70, 0x10, 0x0a, 0x10, 0x24, 0x20, 0x18, 0xfe, 0x68, 0x82, 0x08, 0x82, 0x14, 0x82, 0x64, 0x82, 0x0c, 0xfe, 0x14, 0x82, 0x64, 0x82, 0x04, 0x82, 0x04, 0x82, 0x18, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xe8, 0x7d, 0xff, 0x44, 0x10, 0x44, 0x10, 0x48, 0x20, 0x48, 0xfe, 0x50, 0x82, 0x48, 0x82, 0x48, 0x82, 0x44, 0x82, 0x44, 0xfe, 0x44, 0x82, 0x58, 0x82, 0x40, 0x82, 0x40, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xe9, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x04, 0x48, 0x1f, 0xfc, 0x68, 0x43, 0x0f, 0xfe, 0x00, 0x02, 0x24, 0x92, 0x42, 0x4e, 0x00, 0x00 },
{ 0xd8, 0xea, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x88, 0x08, 0x88, 0x15, 0xd6, 0x62, 0xa1, 0x04, 0x90, 0x19, 0x0c, 0x63, 0xf3, 0x04, 0x10, 0x1b, 0x20, 0x00, 0xc0, 0x03, 0x30, 0x3c, 0x0c, 0x00, 0x00 },
{ 0xd8, 0xeb, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd8, 0xec, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x7e, 0xfe, 0x40, 0x90, 0x40, 0x90, 0x40, 0xff, 0x40, 0x90, 0x40, 0x90, 0x40, 0x88, 0x3c, 0x89, 0x00, 0x85, 0x00, 0xe5, 0x03, 0x83, 0x00, 0x00 },
{ 0xd8, 0xed, 0x04, 0x00, 0x44, 0xfe, 0x28, 0x04, 0x10, 0x18, 0x30, 0x10, 0x51, 0xff, 0x08, 0x10, 0x08, 0x10, 0x18, 0x30, 0x28, 0x00, 0x48, 0xfe, 0x08, 0xaa, 0x08, 0xaa, 0x08, 0xaa, 0x31, 0xff, 0x00, 0x00 },
{ 0xd8, 0xee, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xd8, 0xef, 0x00, 0x00, 0x3e, 0x7e, 0x22, 0x42, 0x22, 0x7e, 0x3e, 0x42, 0x22, 0x7e, 0x22, 0x42, 0x3e, 0x82, 0x01, 0x0e, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd8, 0xf0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x3e, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x3e, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x22, 0x3f, 0x3e, 0x41, 0x00, 0x41, 0x00, 0x81, 0x01, 0x0f, 0x00, 0x00 },
{ 0xd8, 0xf1, 0x00, 0x00, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x48, 0x09, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x00, 0x7f, 0xfe, 0x08, 0x88, 0x17, 0xf4, 0x64, 0x93, 0x04, 0xb0, 0x00, 0x80, 0x00, 0x00 },
{ 0xd8, 0xf2, 0x04, 0x3c, 0x07, 0xc0, 0x08, 0x88, 0x08, 0x44, 0x10, 0x22, 0x2f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf9, 0x02, 0x21, 0x0c, 0x21, 0x70, 0x1f, 0x00, 0x00 },
{ 0xd8, 0xf3, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xe0, 0x10, 0x20, 0x30, 0x40, 0x5f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x40, 0x02, 0x40, 0x04, 0x41, 0x18, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xd8, 0xf4, 0x3f, 0xfe, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x02, 0x3f, 0xfe, 0x04, 0x20, 0x08, 0x40, 0x1f, 0xf8, 0x68, 0x88, 0x08, 0x88, 0x0f, 0xf8, 0x01, 0x40, 0x02, 0x42, 0x0c, 0x42, 0x70, 0x3e, 0x00, 0x00 },
{ 0xd8, 0xf5, 0x08, 0x10, 0x08, 0x10, 0x1e, 0x10, 0x12, 0x10, 0x24, 0x7e, 0x7f, 0x92, 0x24, 0x92, 0x24, 0x92, 0x24, 0x92, 0x3f, 0x92, 0x0a, 0x22, 0x12, 0x22, 0x12, 0x4c, 0x22, 0x01, 0x41, 0xff, 0x00, 0x00 },
{ 0xd8, 0xf6, 0x10, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x7c, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x38, 0xfe, 0x38, 0x10, 0x34, 0x10, 0x55, 0xff, 0x51, 0x11, 0x51, 0x11, 0x11, 0x11, 0x11, 0x13, 0x10, 0x10, 0x00, 0x00 },
{ 0xd8, 0xf7, 0x20, 0x00, 0x13, 0xff, 0x08, 0x20, 0x00, 0x20, 0x41, 0x20, 0x21, 0x3e, 0x11, 0x22, 0x01, 0x22, 0x01, 0x22, 0x11, 0xfe, 0x10, 0x02, 0x20, 0x02, 0x20, 0x02, 0x40, 0x04, 0x40, 0x38, 0x00, 0x00 },
{ 0xd8, 0xf8, 0x00, 0x00, 0x7b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x4a, 0x20, 0x7a, 0x3e, 0x4a, 0x22, 0x4a, 0x22, 0x7b, 0xfe, 0x48, 0x02, 0x48, 0x02, 0x48, 0x02, 0x78, 0x04, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xd8, 0xf9, 0x00, 0x00, 0x7c, 0xff, 0x44, 0x81, 0x44, 0x81, 0x44, 0xff, 0x7c, 0x88, 0x44, 0x88, 0x44, 0x88, 0x7c, 0xff, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x7c, 0x85, 0x00, 0xb5, 0x03, 0xc3, 0x00, 0x00 },
{ 0xd8, 0xfa, 0x10, 0x10, 0x10, 0x20, 0x24, 0xfe, 0x44, 0x82, 0x28, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x24, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x55, 0x11, 0x55, 0x11, 0x51, 0x11, 0x11, 0x13, 0x10, 0x10, 0x00, 0x00 },
{ 0xd8, 0xfb, 0x10, 0x00, 0x11, 0xff, 0x24, 0x10, 0x44, 0x10, 0x28, 0x20, 0x11, 0xff, 0x11, 0x29, 0x25, 0x29, 0x7d, 0x39, 0x11, 0x29, 0x55, 0x29, 0x55, 0x39, 0x51, 0x29, 0x11, 0x29, 0x11, 0xff, 0x00, 0x00 },
{ 0xd8, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x23, 0xe2, 0x22, 0x22, 0x22, 0x22, 0x23, 0xe2, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xd8, 0xfd, 0x08, 0x00, 0x08, 0x7f, 0x3e, 0x08, 0x08, 0x10, 0x3e, 0x7f, 0x08, 0x55, 0x7f, 0x5d, 0x08, 0x55, 0x1e, 0x5d, 0x12, 0x55, 0x32, 0x55, 0x4c, 0x7f, 0x06, 0x00, 0x19, 0x80, 0x60, 0x7f, 0x00, 0x00 },
{ 0xd8, 0xfe, 0x20, 0x10, 0x10, 0x14, 0x00, 0x12, 0x07, 0xff, 0x44, 0x10, 0x24, 0x10, 0x17, 0xf0, 0x04, 0x89, 0x04, 0xa9, 0x16, 0xca, 0x14, 0x8a, 0x25, 0x44, 0x29, 0x4d, 0x4a, 0x35, 0x49, 0xc3, 0x00, 0x00 },
{ 0xd9, 0xa1, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x1f, 0xfe, 0x11, 0x22, 0x1f, 0xfe, 0x00, 0x48, 0x00, 0x44, 0x1f, 0xff, 0x10, 0x40, 0x14, 0x22, 0x12, 0x24, 0x20, 0x19, 0x20, 0xe9, 0x4f, 0x07, 0x00, 0x00 },
{ 0xd9, 0xa2, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0c, 0x1c, 0x70, 0x03, 0x00, 0x00 },
{ 0xd9, 0xa3, 0x00, 0x80, 0x01, 0x00, 0x03, 0xfc, 0x04, 0x04, 0x18, 0x08, 0x66, 0x10, 0x01, 0x60, 0x01, 0x80, 0x06, 0x00, 0x1f, 0xfe, 0x64, 0x02, 0x04, 0x02, 0x04, 0x02, 0x04, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xa4, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x7e, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x3e, 0x4e, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00 },
{ 0xd9, 0xa5, 0x00, 0x00, 0x00, 0x7e, 0x7c, 0x42, 0x44, 0x42, 0x44, 0x42, 0x44, 0x7e, 0x7c, 0x42, 0x44, 0x42, 0x44, 0x42, 0x44, 0x7e, 0x7c, 0x42, 0x00, 0x82, 0x00, 0x82, 0x01, 0x02, 0x02, 0x0e, 0x00, 0x00 },
{ 0xd9, 0xa6, 0x00, 0x00, 0x03, 0xff, 0x7a, 0x01, 0x4a, 0xfd, 0x48, 0x84, 0x48, 0xfc, 0x78, 0x84, 0x48, 0xfc, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x78, 0x00, 0x00, 0x88, 0x01, 0x04, 0x02, 0x02, 0x00, 0x00 },
{ 0xd9, 0xa7, 0x10, 0x20, 0x10, 0x30, 0x10, 0x48, 0x7c, 0x84, 0x13, 0x03, 0x10, 0x7c, 0x38, 0x00, 0x35, 0xef, 0x35, 0x29, 0x51, 0x29, 0x51, 0x29, 0x11, 0xe9, 0x10, 0x0a, 0x10, 0x08, 0x10, 0x08, 0x00, 0x00 },
{ 0xd9, 0xa8, 0x23, 0xff, 0x12, 0x01, 0x0a, 0x01, 0x02, 0xfd, 0x40, 0x84, 0x20, 0x84, 0x10, 0xfc, 0x00, 0x84, 0x00, 0x84, 0x10, 0xfc, 0x10, 0x20, 0x27, 0xff, 0x20, 0x00, 0x40, 0x84, 0x43, 0x03, 0x00, 0x00 },
{ 0xd9, 0xa9, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xd9, 0xaa, 0x00, 0x00, 0x7b, 0xff, 0x4a, 0x01, 0x4a, 0xfd, 0x4a, 0x85, 0x78, 0x84, 0x48, 0xfc, 0x48, 0x84, 0x78, 0x84, 0x48, 0xfc, 0x48, 0x20, 0x4b, 0xff, 0x78, 0x00, 0x00, 0xcc, 0x03, 0x02, 0x00, 0x00 },
{ 0xd9, 0xab, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x02, 0x00, 0x07, 0xf0, 0x08, 0x10, 0x10, 0x20, 0x64, 0x40, 0x02, 0x80, 0x03, 0x00, 0x1f, 0xfc, 0x68, 0x04, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xd9, 0xac, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0c, 0x38, 0x70, 0x06, 0x00, 0x00 },
{ 0xd9, 0xad, 0x10, 0x00, 0x11, 0xff, 0x11, 0x01, 0x7d, 0x7d, 0x55, 0x45, 0x54, 0x7c, 0x54, 0x44, 0x54, 0x44, 0x54, 0x7c, 0x7c, 0x10, 0x11, 0xff, 0x14, 0x00, 0x14, 0x4c, 0x1a, 0x82, 0x63, 0x01, 0x00, 0x00 },
{ 0xd9, 0xae, 0x00, 0x10, 0x7e, 0x10, 0x10, 0x3e, 0x10, 0x22, 0x7e, 0x64, 0x52, 0x94, 0x52, 0x08, 0x52, 0x10, 0x6e, 0x3e, 0x42, 0x62, 0x42, 0xa2, 0x7e, 0x22, 0x42, 0x22, 0x42, 0x22, 0x7e, 0x3e, 0x00, 0x00 },
{ 0xd9, 0xaf, 0x08, 0x10, 0x14, 0x10, 0x22, 0x3e, 0x40, 0x22, 0x3e, 0x44, 0x08, 0xa4, 0x08, 0x18, 0x7e, 0x10, 0x08, 0x3f, 0x4a, 0x61, 0x2a, 0xa1, 0x28, 0x21, 0x08, 0x21, 0x0e, 0x21, 0x70, 0x3f, 0x00, 0x00 },
{ 0xd9, 0xb0, 0x00, 0x20, 0x00, 0x40, 0x01, 0xfc, 0x79, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x00, 0x49, 0xfe, 0x49, 0x00, 0x49, 0xff, 0x78, 0x01, 0x02, 0xa9, 0x02, 0xa9, 0x04, 0x06, 0x00, 0x00 },
{ 0xd9, 0xb1, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x7d, 0xfc, 0x04, 0x24, 0x08, 0x24, 0x08, 0x24, 0x10, 0x24, 0x35, 0xff, 0x58, 0x20, 0x14, 0x50, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x12, 0x03, 0x00, 0x00 },
{ 0xd9, 0xb2, 0x08, 0x80, 0x08, 0x80, 0x09, 0xff, 0x11, 0x00, 0x12, 0x00, 0x30, 0xfe, 0x30, 0xa2, 0x50, 0x92, 0x53, 0xff, 0x10, 0x82, 0x10, 0xa2, 0x10, 0x92, 0x11, 0xff, 0x11, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xd9, 0xb3, 0x3f, 0xfc, 0x20, 0x04, 0x2f, 0xf4, 0x20, 0x04, 0x2f, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00 },
{ 0xd9, 0xb4, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x88, 0x1b, 0xf4, 0x61, 0x13, 0x06, 0x10, 0x18, 0x60, 0x00, 0x00 },
{ 0xd9, 0xb5, 0x10, 0x00, 0x10, 0xfc, 0x10, 0x84, 0x7c, 0xa4, 0x24, 0x94, 0x24, 0x84, 0x27, 0xff, 0x24, 0x84, 0x44, 0xa4, 0x68, 0x94, 0x58, 0x84, 0x08, 0x84, 0x15, 0xff, 0x21, 0x04, 0x40, 0x18, 0x00, 0x00 },
{ 0xd9, 0xb6, 0x10, 0x00, 0x10, 0x7f, 0x10, 0x41, 0x7e, 0x7f, 0x52, 0x41, 0x52, 0x7f, 0x52, 0x00, 0x52, 0x00, 0x52, 0x7f, 0x52, 0x41, 0x56, 0x7f, 0x10, 0x41, 0x10, 0x7f, 0x10, 0x41, 0x10, 0x7f, 0x00, 0x00 },
{ 0xd9, 0xb7, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x19, 0x0c, 0x69, 0x4b, 0x09, 0x24, 0x13, 0x24, 0x00, 0x00 },
{ 0xd9, 0xb8, 0x10, 0x44, 0x11, 0xff, 0x10, 0x44, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x1c, 0xfe, 0x70, 0x10, 0x10, 0x10, 0x11, 0xff, 0x10, 0x28, 0x10, 0x28, 0x10, 0x44, 0x31, 0x83, 0x00, 0x00 },
{ 0xd9, 0xb9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x04, 0x70, 0x1b, 0x8c, 0x67, 0xf3, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00 },
{ 0xd9, 0xba, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x01, 0x00, 0x7f, 0xff, 0x0f, 0xf8, 0x18, 0x0c, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xd9, 0xbb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x07, 0xf0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xd9, 0xbc, 0x10, 0x44, 0x11, 0xff, 0x10, 0x44, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x38, 0x82, 0x34, 0xfe, 0x34, 0x10, 0x50, 0x10, 0x51, 0xff, 0x10, 0x28, 0x10, 0x28, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xd9, 0xbd, 0x1f, 0xfc, 0x10, 0x04, 0x11, 0x04, 0x10, 0x84, 0x10, 0x44, 0x10, 0x04, 0x7f, 0xff, 0x20, 0x04, 0x22, 0x04, 0x21, 0x04, 0x20, 0x84, 0x20, 0x04, 0x7f, 0xfe, 0x40, 0x08, 0x00, 0x70, 0x00, 0x00 },
{ 0xd9, 0xbe, 0x00, 0x3c, 0x3f, 0xc0, 0x01, 0x00, 0x01, 0x00, 0x01, 0xfe, 0x3f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xff, 0x7f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0xff, 0x00, 0x00 },
{ 0xd9, 0xbf, 0x02, 0x00, 0x02, 0x10, 0x04, 0x08, 0x08, 0x74, 0x7f, 0x82, 0x00, 0x02, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfc, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xd9, 0xc0, 0x08, 0x10, 0x08, 0x10, 0x28, 0x10, 0x28, 0x10, 0x3e, 0x10, 0x48, 0xfe, 0x48, 0x10, 0x08, 0x10, 0x0a, 0x10, 0x1c, 0x10, 0x68, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x09, 0xff, 0x00, 0x00 },
{ 0xd9, 0xc1, 0x00, 0x00, 0x01, 0xff, 0x7d, 0x01, 0x11, 0x7d, 0x11, 0x01, 0x11, 0x7d, 0x7d, 0x01, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xc2, 0x00, 0x40, 0x78, 0x88, 0x48, 0x84, 0x49, 0x3a, 0x4b, 0xc2, 0x78, 0x20, 0x49, 0x20, 0x4b, 0xfe, 0x7a, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x78, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xd9, 0xc3, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x7f, 0xff, 0x00, 0xc1, 0x01, 0x42, 0x02, 0x44, 0x04, 0x40, 0x18, 0x40, 0x60, 0x40, 0x00, 0x40, 0x01, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xc4, 0x08, 0x06, 0x08, 0x78, 0x7f, 0x10, 0x08, 0x10, 0x3e, 0x1e, 0x08, 0x70, 0x7f, 0x10, 0x08, 0x10, 0x1c, 0x1f, 0x1c, 0xf0, 0x2a, 0x10, 0x2a, 0x10, 0x48, 0x11, 0x08, 0x11, 0x08, 0x0f, 0x00, 0x00 },
{ 0xd9, 0xc5, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x01, 0x78, 0x1f, 0x80, 0x01, 0x00, 0x01, 0xfc, 0x3f, 0x00, 0x01, 0x02, 0x01, 0x02, 0x00, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xc6, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x08, 0x01, 0x30, 0x00, 0xc0, 0x7f, 0xff, 0x00, 0xc1, 0x01, 0x42, 0x02, 0x44, 0x0c, 0x40, 0x30, 0x40, 0x01, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xc7, 0x00, 0x44, 0x3c, 0x44, 0x01, 0xff, 0x7e, 0x44, 0x00, 0x7c, 0x3c, 0x44, 0x00, 0x7c, 0x3c, 0x10, 0x00, 0x10, 0x01, 0xff, 0x3c, 0x38, 0x24, 0x54, 0x24, 0x92, 0x25, 0x11, 0x3c, 0x10, 0x00, 0x00 },
{ 0xd9, 0xc8, 0x00, 0x24, 0x3c, 0xff, 0x00, 0x24, 0x7e, 0x00, 0x00, 0x7e, 0x3c, 0x42, 0x00, 0x7e, 0x3c, 0x42, 0x00, 0x7e, 0x00, 0x10, 0x3c, 0xff, 0x24, 0x10, 0x24, 0x28, 0x24, 0x44, 0x3c, 0x83, 0x00, 0x00 },
{ 0xd9, 0xc9, 0x08, 0x10, 0x10, 0x20, 0x6a, 0xfe, 0x04, 0x82, 0x28, 0x82, 0x10, 0xfe, 0x68, 0x82, 0x08, 0x82, 0x14, 0xfe, 0x64, 0x28, 0x0c, 0x28, 0x14, 0x48, 0x64, 0x49, 0x04, 0x89, 0x1b, 0x0f, 0x00, 0x00 },
{ 0xd9, 0xca, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0xc0, 0x02, 0xa0, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x20, 0x82, 0x40, 0x81, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xd9, 0xcb, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x20, 0x47, 0xff, 0x20, 0x20, 0x10, 0x70, 0x00, 0x70, 0x00, 0xa8, 0x10, 0xa8, 0x11, 0x24, 0x22, 0x22, 0x24, 0x21, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xd9, 0xcc, 0x08, 0x40, 0x08, 0x40, 0x28, 0x40, 0x28, 0xff, 0x3e, 0xc4, 0x49, 0x44, 0x4a, 0x44, 0x08, 0x44, 0x08, 0x28, 0x0e, 0x28, 0x78, 0x10, 0x08, 0x28, 0x08, 0x44, 0x09, 0x82, 0x0a, 0x01, 0x00, 0x00 },
{ 0xd9, 0xcd, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00 },
{ 0xd9, 0xce, 0x00, 0x20, 0x78, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x7b, 0xff, 0x48, 0x90, 0x48, 0x91, 0x49, 0x0f, 0x7a, 0x20, 0x48, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x78, 0x20, 0x03, 0xff, 0x00, 0x00 },
{ 0xd9, 0xcf, 0x0c, 0x10, 0x70, 0x20, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x82, 0x18, 0xfe, 0x38, 0x92, 0x35, 0x15, 0x54, 0x38, 0x51, 0xc2, 0x50, 0x0c, 0x11, 0xf1, 0x10, 0x06, 0x11, 0xf8, 0x00, 0x00 },
{ 0xd9, 0xd0, 0x00, 0x10, 0x3f, 0x10, 0x0a, 0x3f, 0x7f, 0x52, 0x0d, 0x0c, 0x74, 0x33, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x00, 0x0f, 0xff, 0x24, 0x91, 0x42, 0x46, 0x00, 0x00 },
{ 0xd9, 0xd1, 0x00, 0x20, 0x7f, 0x20, 0x08, 0x3f, 0x08, 0x21, 0x1e, 0x41, 0x12, 0x41, 0x12, 0x8e, 0x22, 0x00, 0x34, 0xfe, 0x4c, 0x42, 0x08, 0x44, 0x08, 0x28, 0x10, 0x10, 0x20, 0x6c, 0x43, 0x83, 0x00, 0x00 },
{ 0xd9, 0xd2, 0x20, 0x40, 0x10, 0x7e, 0x08, 0x82, 0x00, 0x82, 0x41, 0x02, 0x22, 0x1c, 0x10, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x10, 0x82, 0x10, 0x84, 0x20, 0x48, 0x20, 0x30, 0x40, 0xcc, 0x47, 0x03, 0x00, 0x00 },
{ 0xd9, 0xd3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0x41, 0x01, 0x43, 0xf9, 0x0c, 0x10, 0x33, 0x20, 0x00, 0xc0, 0x03, 0x00, 0x3c, 0x00, 0x00, 0x00 },
{ 0xd9, 0xd4, 0x00, 0x48, 0x3d, 0xfe, 0x24, 0x48, 0x25, 0xfe, 0x25, 0x02, 0x3c, 0x78, 0x24, 0x00, 0x25, 0xfe, 0x24, 0x48, 0x3d, 0xa9, 0x24, 0x76, 0x25, 0x94, 0x24, 0x72, 0x45, 0x91, 0x4c, 0x60, 0x00, 0x00 },
{ 0xd9, 0xd5, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0xfe, 0x20, 0x02, 0x2f, 0xfa, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x90, 0x06, 0x52, 0x38, 0xd4, 0x07, 0x28, 0x38, 0xe8, 0x07, 0x24, 0x38, 0xc3, 0x00, 0x00 },
{ 0xd9, 0xd6, 0x01, 0x80, 0x1e, 0x1f, 0x10, 0x11, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x17, 0x11, 0x19, 0x11, 0x62, 0x17, 0x02, 0x10, 0x0c, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xd9, 0xd7, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x18, 0x8c, 0x67, 0xf3, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xd8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x54, 0x24, 0x52, 0x24, 0x52, 0x24, 0x91, 0x24, 0x91, 0x45, 0x10, 0x68, 0x32, 0x58, 0x02, 0x08, 0x04, 0x14, 0x08, 0x22, 0x30, 0x41, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xd9, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x00, 0x2f, 0x9f, 0x22, 0x11, 0x2f, 0x95, 0x28, 0x93, 0x2f, 0x91, 0x28, 0x95, 0x2f, 0x93, 0x22, 0x11, 0x5f, 0xa1, 0x42, 0x21, 0x42, 0x47, 0x00, 0x00 },
{ 0xd9, 0xda, 0x10, 0x44, 0x10, 0x44, 0x11, 0xff, 0x7c, 0x44, 0x10, 0x44, 0x10, 0x00, 0x11, 0xff, 0x1d, 0x11, 0x71, 0x11, 0x11, 0x11, 0x11, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x31, 0xff, 0x00, 0x00 },
{ 0xd9, 0xdb, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x07, 0x00, 0x38, 0x3f, 0x21, 0x21, 0x21, 0x21, 0x2f, 0x21, 0x71, 0x27, 0x02, 0x20, 0x04, 0x20, 0x00, 0x00 },
{ 0xd9, 0xdc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xd9, 0xdd, 0x20, 0x08, 0x17, 0x88, 0x04, 0x88, 0x04, 0x88, 0x44, 0xaa, 0x27, 0xaa, 0x14, 0xa9, 0x04, 0xc9, 0x07, 0xc8, 0x14, 0x89, 0x14, 0x9a, 0x24, 0x84, 0x27, 0x88, 0x40, 0x30, 0x40, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xde, 0x04, 0x88, 0x44, 0x88, 0x2b, 0xff, 0x10, 0x88, 0x30, 0x88, 0x50, 0x00, 0x09, 0xfe, 0x09, 0x22, 0x19, 0x22, 0x29, 0x22, 0x49, 0xfe, 0x09, 0x22, 0x09, 0x22, 0x09, 0x22, 0x31, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xdf, 0x10, 0x10, 0x10, 0x10, 0x7e, 0x10, 0x00, 0x54, 0x44, 0x52, 0x44, 0x91, 0x24, 0x91, 0x29, 0x10, 0x28, 0x12, 0x28, 0x72, 0x0e, 0x04, 0x78, 0x04, 0x00, 0x08, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xfe, 0x04, 0x20, 0x04, 0x20, 0x00, 0x00, 0x3f, 0xfc, 0x21, 0x04, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x21, 0x04, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xd9, 0xe1, 0x18, 0x44, 0x24, 0x44, 0x41, 0xff, 0x00, 0x44, 0x7c, 0x44, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x92, 0x10, 0x92, 0x10, 0x92, 0x54, 0xfe, 0x34, 0x92, 0x10, 0x92, 0x18, 0x92, 0x60, 0xfe, 0x00, 0x00 },
{ 0xd9, 0xe2, 0x00, 0x20, 0x7e, 0x20, 0x02, 0x7f, 0x24, 0x62, 0x18, 0xa2, 0x08, 0x14, 0x7f, 0x08, 0x09, 0x34, 0x1a, 0xc3, 0x18, 0x10, 0x28, 0xff, 0x28, 0x11, 0x48, 0x11, 0x08, 0x21, 0x18, 0xc6, 0x00, 0x00 },
{ 0xd9, 0xe3, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x14, 0x94, 0x14, 0x94, 0x22, 0xa2, 0x22, 0xa2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd9, 0xe4, 0x11, 0x00, 0x11, 0x00, 0x13, 0xff, 0x5b, 0x54, 0x55, 0x54, 0x55, 0x54, 0x53, 0xff, 0x11, 0x54, 0x11, 0x54, 0x11, 0x54, 0x17, 0xff, 0x10, 0x00, 0x12, 0x92, 0x12, 0x49, 0x14, 0x49, 0x00, 0x00 },
{ 0xd9, 0xe5, 0x10, 0x04, 0x13, 0xc4, 0x11, 0x44, 0x7c, 0x9f, 0x13, 0xe4, 0x38, 0xae, 0x35, 0x8e, 0x52, 0x95, 0x54, 0xa5, 0x11, 0x84, 0x00, 0x00, 0x04, 0x80, 0x24, 0x42, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xd9, 0xe6, 0x00, 0x44, 0x00, 0x42, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x40, 0x10, 0x42, 0x10, 0x22, 0x10, 0x24, 0x10, 0x18, 0x10, 0x10, 0x10, 0x28, 0x20, 0x49, 0x21, 0x85, 0x46, 0x03, 0x00, 0x00 },
{ 0xd9, 0xe7, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x7d, 0x44, 0x11, 0x24, 0x11, 0x04, 0x17, 0xff, 0x19, 0x04, 0x71, 0x44, 0x11, 0x24, 0x11, 0x04, 0x11, 0x04, 0x13, 0xff, 0x12, 0x04, 0x30, 0x18, 0x00, 0x00 },
{ 0xd9, 0xe8, 0x10, 0x40, 0x10, 0x40, 0x10, 0x80, 0x7c, 0xff, 0x11, 0xaa, 0x12, 0xaa, 0x10, 0xaa, 0x1d, 0xff, 0x70, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x11, 0xff, 0x10, 0x00, 0x11, 0x52, 0x32, 0x29, 0x00, 0x00 },
{ 0xd9, 0xe9, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x01, 0x00, 0x01, 0x40, 0x01, 0x40, 0x02, 0x40, 0x02, 0x40, 0x04, 0x41, 0x18, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xd9, 0xea, 0x10, 0x04, 0x13, 0xe4, 0x10, 0x24, 0x7c, 0x5f, 0x11, 0x84, 0x10, 0x84, 0x3b, 0xee, 0x38, 0xae, 0x34, 0xce, 0x55, 0x95, 0x51, 0x95, 0x52, 0x95, 0x14, 0x84, 0x10, 0x84, 0x11, 0x84, 0x00, 0x00 },
{ 0xd9, 0xeb, 0x00, 0x14, 0x1f, 0x92, 0x00, 0x10, 0x00, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x13, 0xc8, 0x12, 0x08, 0x12, 0x08, 0x12, 0x68, 0x17, 0x85, 0x78, 0x05, 0x00, 0x03, 0x00, 0x00 },
{ 0xd9, 0xec, 0x0f, 0xfc, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x7f, 0xff, 0x11, 0x08, 0x11, 0x08, 0x11, 0x08, 0x11, 0x08, 0x11, 0x08, 0x3f, 0xfe, 0x20, 0x10, 0x00, 0x10, 0x00, 0x60, 0x00, 0x00 },
{ 0xd9, 0xed, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x29, 0x24, 0x49, 0x24, 0x09, 0x24, 0x3f, 0xff, 0x09, 0x24, 0x09, 0x24, 0x09, 0x24, 0x3f, 0xff, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xd9, 0xee, 0x00, 0x08, 0x01, 0xea, 0x7c, 0x09, 0x10, 0x08, 0x13, 0xff, 0x10, 0x08, 0x7c, 0x48, 0x10, 0x48, 0x11, 0x48, 0x11, 0x78, 0x1d, 0x49, 0x71, 0x45, 0x01, 0x75, 0x03, 0xc3, 0x01, 0x01, 0x00, 0x00 },
{ 0xd9, 0xef, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x20, 0x00, 0x7c, 0x3e, 0x44, 0x2a, 0x44, 0x2a, 0x88, 0x2a, 0x08, 0x3e, 0x08, 0x2a, 0x14, 0x2a, 0x14, 0x2a, 0x24, 0x3e, 0x42, 0x00, 0x82, 0x03, 0x01, 0x00, 0x00 },
{ 0xd9, 0xf0, 0x11, 0xef, 0x10, 0xa5, 0x25, 0x29, 0x44, 0x63, 0x29, 0xad, 0x10, 0x31, 0x10, 0x48, 0x25, 0x86, 0x7e, 0x31, 0x14, 0xc4, 0x50, 0x19, 0x54, 0xe2, 0x54, 0x0c, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xd9, 0xf1, 0x10, 0x00, 0x3f, 0xfe, 0x52, 0x48, 0x12, 0x48, 0x7f, 0xff, 0x12, 0x48, 0x12, 0x48, 0x3f, 0xfe, 0x08, 0x08, 0x1f, 0x7e, 0x21, 0x48, 0x52, 0x48, 0x0c, 0xff, 0x18, 0x08, 0x60, 0x08, 0x00, 0x00 },
{ 0xd9, 0xf2, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x94, 0x00, 0x82, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x42, 0x10, 0x24, 0x10, 0x28, 0x10, 0x30, 0x20, 0x49, 0x21, 0x85, 0x46, 0x03, 0x00, 0x00 },
{ 0xd9, 0xf3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x00, 0x1f, 0xfe, 0x29, 0x24, 0x09, 0x24, 0x7f, 0xff, 0x09, 0x24, 0x09, 0x24, 0x3f, 0xff, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xd9, 0xf4, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x10, 0x7e, 0x10, 0x00, 0x92, 0x3c, 0x92, 0x00, 0x92, 0x3c, 0x92, 0x01, 0x55, 0x01, 0x55, 0x3d, 0x55, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3d, 0xff, 0x00, 0x00 },
{ 0xd9, 0xf5, 0x03, 0x00, 0x3c, 0x7f, 0x20, 0x11, 0x22, 0x11, 0x2f, 0x21, 0x71, 0x46, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x04, 0x08, 0x38, 0x07, 0x00, 0x00 },
{ 0xd9, 0xf6, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0xa0, 0x3f, 0x3f, 0x0a, 0x64, 0x04, 0x18, 0x7f, 0x67, 0x0d, 0x10, 0x14, 0xfe, 0x24, 0x12, 0x44, 0x22, 0x0c, 0xcc, 0x00, 0x00 },
{ 0xd9, 0xf7, 0x02, 0x10, 0x3b, 0x7e, 0x02, 0x42, 0x02, 0x7e, 0x7f, 0x42, 0x0a, 0x7e, 0x0a, 0x40, 0x2a, 0x7f, 0x2d, 0x40, 0x29, 0x7f, 0x29, 0x01, 0x29, 0x55, 0x2d, 0x55, 0x71, 0x41, 0x00, 0x86, 0x00, 0x00 },
{ 0xd9, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x14, 0x94, 0x12, 0xa4, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x24, 0x22, 0x42, 0x91, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xd9, 0xf9, 0x00, 0x08, 0x7f, 0x0a, 0x49, 0x09, 0x6b, 0x08, 0x5d, 0x08, 0x49, 0x7f, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x14, 0x08, 0x14, 0x7f, 0x24, 0x00, 0x22, 0x55, 0x42, 0x54, 0x81, 0x00, 0x00 },
{ 0xd9, 0xfa, 0x0b, 0xde, 0x0a, 0x52, 0x13, 0xde, 0x12, 0x52, 0x32, 0x52, 0x33, 0xde, 0x52, 0x02, 0x52, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x0e, 0x00, 0x00 },
{ 0xd9, 0xfb, 0x10, 0x01, 0x10, 0x01, 0x1f, 0xc9, 0x25, 0x49, 0x25, 0x49, 0x29, 0x49, 0x49, 0x49, 0x0a, 0x49, 0x12, 0x49, 0x12, 0x49, 0x24, 0x49, 0x44, 0x41, 0x08, 0x41, 0x10, 0x41, 0x03, 0x87, 0x00, 0x00 },
{ 0xd9, 0xfc, 0x00, 0x80, 0x78, 0x80, 0x48, 0xff, 0x49, 0x29, 0x49, 0x29, 0x4a, 0x29, 0x48, 0x49, 0x48, 0x51, 0x48, 0x91, 0x48, 0x91, 0x79, 0x21, 0x02, 0x21, 0x00, 0x42, 0x00, 0x82, 0x01, 0x1c, 0x00, 0x00 },
{ 0xd9, 0xfd, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x40, 0x02, 0x47, 0xe2, 0x44, 0x22, 0x44, 0x22, 0x44, 0x22, 0x47, 0xe2, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xd9, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04, 0x10, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xda, 0xa1, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xff, 0x40, 0x84, 0x20, 0x84, 0x10, 0x84, 0x00, 0x48, 0x00, 0x48, 0x10, 0x50, 0x10, 0x30, 0x20, 0x20, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xda, 0xa2, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x06, 0x30, 0x78, 0x8f, 0x01, 0x00, 0x06, 0x20, 0x02, 0x44, 0x01, 0x82, 0x7f, 0xfd, 0x00, 0x81, 0x08, 0x8c, 0x30, 0x82, 0x00, 0x00 },
{ 0xda, 0xa3, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x44, 0x82, 0x28, 0x82, 0x10, 0x82, 0x10, 0x44, 0x24, 0x44, 0x7c, 0x48, 0x10, 0x28, 0x54, 0x30, 0x54, 0x30, 0x50, 0x48, 0x10, 0x84, 0x13, 0x03, 0x00, 0x00 },
{ 0xda, 0xa4, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x5f, 0xfa, 0x44, 0x22, 0x47, 0xe2, 0x44, 0x22, 0x47, 0xe2, 0x44, 0x22, 0x44, 0xfa, 0x5f, 0x22, 0x40, 0x2e, 0x00, 0x00 },
{ 0xda, 0xa5, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x54, 0x44, 0x54, 0x44, 0x54, 0x44, 0x54, 0x44, 0x54, 0x28, 0x7c, 0x28, 0x10, 0x10, 0x14, 0x10, 0x14, 0x28, 0x1a, 0x44, 0x62, 0x82, 0x00, 0x00 },
{ 0xda, 0xa6, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xda, 0xa7, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x4e, 0xb9, 0x00, 0x00, 0x0e, 0x38, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x0c, 0x18, 0x03, 0x60, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x00, 0x00 },
{ 0xda, 0xa8, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x12, 0x22, 0x22, 0x22, 0x42, 0x22, 0x04, 0x22, 0x04, 0x42, 0x08, 0x42, 0x10, 0x82, 0x20, 0x84, 0x01, 0x04, 0x02, 0x04, 0x04, 0x38, 0x00, 0x00 },
{ 0xda, 0xa9, 0x20, 0x80, 0x10, 0x80, 0x09, 0x00, 0x01, 0xfe, 0x42, 0x4a, 0x24, 0x4a, 0x10, 0x92, 0x00, 0x92, 0x01, 0x22, 0x16, 0x22, 0x10, 0x42, 0x20, 0x82, 0x21, 0x02, 0x46, 0x04, 0x40, 0x18, 0x00, 0x00 },
{ 0xda, 0xaa, 0x08, 0x40, 0x28, 0x40, 0x28, 0x40, 0x3e, 0xff, 0x48, 0xa5, 0x49, 0x25, 0x08, 0x45, 0x08, 0x49, 0x0e, 0x89, 0x79, 0x11, 0x08, 0x11, 0x08, 0x21, 0x08, 0x42, 0x08, 0x82, 0x08, 0x1c, 0x00, 0x00 },
{ 0xda, 0xab, 0x00, 0x20, 0x00, 0x20, 0x78, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x70, 0x48, 0xa8, 0x48, 0xa8, 0x79, 0x24, 0x02, 0x22, 0x04, 0x21, 0x00, 0x20, 0x00, 0x00 },
{ 0xda, 0xac, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x22, 0x7d, 0x22, 0x25, 0xfe, 0x25, 0x00, 0x25, 0x7e, 0x25, 0x42, 0x45, 0x42, 0x69, 0x7e, 0x59, 0x42, 0x0d, 0x7e, 0x12, 0x42, 0x22, 0x42, 0x44, 0x7e, 0x00, 0x00 },
{ 0xda, 0xad, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x38, 0x23, 0xc0, 0x20, 0x7c, 0x27, 0xc0, 0x20, 0x40, 0x20, 0x7f, 0x2f, 0xc0, 0x40, 0x41, 0x40, 0x41, 0x40, 0x3f, 0x00, 0x00 },
{ 0xda, 0xae, 0x10, 0x00, 0x11, 0xff, 0x11, 0x11, 0x55, 0x11, 0x55, 0xff, 0x55, 0x00, 0x55, 0x7e, 0x55, 0x42, 0x55, 0x42, 0x55, 0x7e, 0x7d, 0x42, 0x02, 0x7e, 0x02, 0x42, 0x04, 0x42, 0x08, 0x7e, 0x00, 0x00 },
{ 0xda, 0xaf, 0x00, 0x00, 0x7b, 0xff, 0x08, 0xa4, 0x09, 0x22, 0x0b, 0xff, 0x3a, 0x22, 0x23, 0x76, 0x22, 0xaa, 0x23, 0x76, 0x7a, 0x22, 0x4b, 0x76, 0x0a, 0xaa, 0x0b, 0x76, 0x0a, 0x22, 0x32, 0x26, 0x00, 0x00 },
{ 0xda, 0xb0, 0x11, 0x08, 0x15, 0x48, 0x25, 0x48, 0x25, 0x5f, 0x4f, 0xd2, 0x08, 0x12, 0x17, 0xea, 0x10, 0x0a, 0x33, 0x8a, 0x52, 0x8a, 0x12, 0xa4, 0x14, 0xac, 0x14, 0xea, 0x18, 0x12, 0x10, 0x21, 0x00, 0x00 },
{ 0xda, 0xb1, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xda, 0xb2, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0x02, 0x11, 0xfe, 0x11, 0x0c, 0x39, 0x70, 0x39, 0x10, 0x35, 0x1e, 0x55, 0x70, 0x51, 0x10, 0x51, 0x1f, 0x12, 0xf0, 0x12, 0x11, 0x14, 0x0f, 0x00, 0x00 },
{ 0xda, 0xb3, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x12, 0x7d, 0x12, 0x11, 0xfe, 0x11, 0x00, 0x39, 0x00, 0x35, 0x7e, 0x35, 0x42, 0x51, 0x7e, 0x51, 0x42, 0x11, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x14, 0x7e, 0x00, 0x00 },
{ 0xda, 0xb4, 0x41, 0x04, 0x20, 0x84, 0x10, 0x88, 0x07, 0xff, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x20, 0x07, 0xff, 0x00, 0x20, 0x10, 0x20, 0x17, 0xff, 0x20, 0x50, 0x20, 0x88, 0x41, 0x04, 0x46, 0x03, 0x00, 0x00 },
{ 0xda, 0xb5, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x22, 0x02, 0x22, 0x43, 0xfe, 0x22, 0x00, 0x12, 0x00, 0x02, 0xfc, 0x02, 0x84, 0x12, 0xfc, 0x12, 0x84, 0x22, 0xfc, 0x24, 0x84, 0x44, 0x84, 0x48, 0xfc, 0x00, 0x00 },
{ 0xda, 0xb6, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x41, 0x10, 0x41, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x17, 0xfe, 0x14, 0x02, 0x17, 0xfe, 0x24, 0x02, 0x27, 0xfe, 0x24, 0x02, 0x44, 0x02, 0x47, 0xfe, 0x00, 0x00 },
{ 0xda, 0xb7, 0x00, 0x80, 0x10, 0x84, 0x08, 0x84, 0x08, 0x88, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x60, 0x83, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xda, 0xb8, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xda, 0xb9, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x10, 0x88, 0x12, 0xa8, 0x22, 0xa8, 0x4b, 0xef, 0x10, 0x12, 0x13, 0xd2, 0x30, 0x2a, 0x53, 0xca, 0x12, 0x44, 0x12, 0x64, 0x12, 0x4a, 0x14, 0x11, 0x00, 0x00 },
{ 0xda, 0xba, 0x00, 0x08, 0x3d, 0x08, 0x00, 0xaa, 0x7e, 0x2c, 0x01, 0x08, 0x3c, 0xbf, 0x00, 0x08, 0x3d, 0x9c, 0x00, 0x9c, 0x00, 0xaa, 0x3c, 0xaa, 0x24, 0xc9, 0x24, 0x88, 0x25, 0x40, 0x3e, 0x3f, 0x00, 0x00 },
{ 0xda, 0xbb, 0x20, 0x20, 0x12, 0x22, 0x09, 0x22, 0x41, 0x24, 0x20, 0x20, 0x13, 0xfe, 0x00, 0x20, 0x00, 0x70, 0x70, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x10, 0x20, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xda, 0xbc, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x08, 0x2f, 0xbf, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xaa, 0x32, 0x4b, 0x20, 0x90, 0x27, 0x9f, 0x20, 0x90, 0x27, 0x9e, 0x40, 0x90, 0x4f, 0x9f, 0x41, 0x10, 0x00, 0x00 },
{ 0xda, 0xbd, 0x11, 0x08, 0x15, 0x48, 0x27, 0xc8, 0x40, 0x10, 0x17, 0xdf, 0x10, 0x32, 0x27, 0xd2, 0x25, 0x52, 0x67, 0xca, 0x21, 0x0a, 0x27, 0xc4, 0x21, 0x04, 0x2f, 0xea, 0x25, 0x4a, 0x28, 0x11, 0x00, 0x00 },
{ 0xda, 0xbe, 0x10, 0x06, 0x10, 0xf8, 0x10, 0x88, 0x10, 0x88, 0x54, 0x88, 0x54, 0x88, 0x54, 0xff, 0x54, 0x88, 0x54, 0x88, 0x54, 0x88, 0x54, 0x84, 0x54, 0x85, 0x7c, 0xb5, 0x01, 0xc3, 0x00, 0x01, 0x00, 0x00 },
{ 0xda, 0xbf, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x40, 0x02, 0x40, 0x82, 0x42, 0x42, 0x4a, 0x12, 0x4a, 0x0a, 0x52, 0x22, 0x41, 0xe2, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xda, 0xc0, 0x00, 0x10, 0x3f, 0x10, 0x21, 0x3f, 0x3f, 0x22, 0x24, 0x62, 0x3f, 0x92, 0x24, 0x14, 0x24, 0x88, 0x3a, 0x94, 0x61, 0xa3, 0x00, 0x00, 0x04, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xda, 0xc1, 0x11, 0xef, 0x11, 0x29, 0x11, 0xef, 0x59, 0x29, 0x55, 0xef, 0x55, 0x01, 0x51, 0x11, 0x11, 0x7d, 0x11, 0x09, 0x11, 0x29, 0x11, 0x11, 0x11, 0x29, 0x11, 0x45, 0x11, 0x01, 0x11, 0x03, 0x00, 0x00 },
{ 0xda, 0xc2, 0x10, 0x10, 0x10, 0x10, 0x3f, 0x90, 0x20, 0x3f, 0x40, 0x22, 0x1f, 0x42, 0x15, 0xa2, 0x15, 0x22, 0x7f, 0xa4, 0x29, 0x14, 0x29, 0x14, 0x29, 0x08, 0x7f, 0x94, 0x41, 0x22, 0x06, 0x41, 0x00, 0x00 },
{ 0xda, 0xc3, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xda, 0xc4, 0x00, 0x20, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x84, 0x48, 0x84, 0x78, 0x84, 0x48, 0x88, 0x48, 0x48, 0x48, 0x50, 0x48, 0x30, 0x78, 0x20, 0x00, 0x50, 0x00, 0x8c, 0x03, 0x03, 0x00, 0x00 },
{ 0xda, 0xc5, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x1f, 0xfe, 0x10, 0x40, 0x10, 0x20, 0x10, 0x20, 0x11, 0x91, 0x1e, 0x09, 0x70, 0x07, 0x00, 0x00 },
{ 0xda, 0xc6, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x02, 0x02, 0x42, 0x02, 0x23, 0xfe, 0x12, 0x20, 0x02, 0x20, 0x03, 0xff, 0x12, 0x10, 0x12, 0x10, 0x22, 0x08, 0x22, 0x09, 0x42, 0xe5, 0x4f, 0x03, 0x00, 0x00 },
{ 0xda, 0xc7, 0x00, 0x20, 0x00, 0x20, 0x7c, 0x20, 0x13, 0xff, 0x10, 0x84, 0x10, 0x84, 0x7c, 0x84, 0x10, 0x48, 0x10, 0x48, 0x10, 0x50, 0x1c, 0x30, 0x70, 0x30, 0x00, 0x48, 0x00, 0x84, 0x03, 0x03, 0x00, 0x00 },
{ 0xda, 0xc8, 0x01, 0xfe, 0x7d, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x7d, 0x10, 0x11, 0xff, 0x11, 0x10, 0x11, 0x10, 0x11, 0x08, 0x1d, 0x09, 0x71, 0x09, 0x01, 0xe5, 0x07, 0x03, 0x00, 0x00 },
{ 0xda, 0xc9, 0x10, 0xfe, 0x10, 0x82, 0x24, 0xfe, 0x44, 0x90, 0x28, 0xff, 0x10, 0x88, 0x10, 0xe5, 0x25, 0x83, 0x7c, 0x00, 0x14, 0xfe, 0x50, 0x82, 0x54, 0xfe, 0x54, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xda, 0xca, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x41, 0x02, 0x5f, 0xf2, 0x44, 0x42, 0x44, 0x42, 0x42, 0x82, 0x41, 0x02, 0x46, 0xc2, 0x58, 0x32, 0x40, 0x0e, 0x00, 0x00 },
{ 0xda, 0xcb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x42, 0x49, 0x12, 0x12, 0x12, 0x61, 0x23, 0x89, 0x0e, 0x08, 0x71, 0xf8, 0x00, 0x00, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xda, 0xcc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x01, 0x54, 0xa5, 0x14, 0x42, 0x24, 0x89, 0x03, 0xf8, 0x7c, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0xfe, 0x7f, 0x81, 0x00, 0x00 },
{ 0xda, 0xcd, 0x00, 0x10, 0x3c, 0x0a, 0x00, 0x22, 0x7e, 0xa4, 0x00, 0xaa, 0x3d, 0x31, 0x00, 0x65, 0x3d, 0xa4, 0x00, 0x1c, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0xaa, 0x24, 0xaa, 0x24, 0xaa, 0x3d, 0xff, 0x00, 0x00 },
{ 0xda, 0xce, 0x08, 0x02, 0x0f, 0x82, 0x11, 0x12, 0x3f, 0x12, 0x02, 0x12, 0x02, 0x12, 0x7f, 0xd2, 0x04, 0x12, 0x44, 0x92, 0x25, 0x12, 0x0e, 0x12, 0x15, 0x02, 0x64, 0xc2, 0x04, 0x02, 0x18, 0x0c, 0x00, 0x00 },
{ 0xda, 0xcf, 0x10, 0x24, 0x10, 0x22, 0x17, 0xff, 0x10, 0x20, 0x13, 0xfe, 0x7a, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x08, 0x17, 0xff, 0x10, 0x08, 0x11, 0x08, 0x10, 0x88, 0x10, 0x38, 0x00, 0x00 },
{ 0xda, 0xd0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x7c, 0xff, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x1c, 0x81, 0x70, 0xff, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x30, 0xff, 0x00, 0x00 },
{ 0xda, 0xd1, 0x10, 0x24, 0x10, 0x22, 0x13, 0xff, 0x7c, 0x20, 0x11, 0xfe, 0x11, 0x22, 0x11, 0xfe, 0x1d, 0x22, 0x71, 0xfe, 0x11, 0x22, 0x10, 0x04, 0x13, 0xff, 0x10, 0x84, 0x10, 0x44, 0x30, 0x1c, 0x00, 0x00 },
{ 0xda, 0xd2, 0x10, 0x50, 0x12, 0x52, 0x11, 0x54, 0x7f, 0xff, 0x10, 0x88, 0x10, 0x50, 0x1b, 0xfe, 0x10, 0x20, 0x73, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x50, 0x11, 0x8c, 0x36, 0x03, 0x00, 0x00 },
{ 0xda, 0xd3, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7c, 0x40, 0x10, 0x40, 0x10, 0x40, 0x38, 0x70, 0x38, 0x48, 0x34, 0x44, 0x54, 0x42, 0x50, 0x40, 0x50, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x00, 0x00 },
{ 0xda, 0xd4, 0x12, 0x52, 0x11, 0x54, 0x10, 0x50, 0x7b, 0xff, 0x10, 0x88, 0x10, 0x50, 0x33, 0xfe, 0x38, 0x20, 0x35, 0xfc, 0x50, 0x20, 0x53, 0xff, 0x50, 0x50, 0x10, 0x88, 0x11, 0x04, 0x16, 0x03, 0x00, 0x00 },
{ 0xda, 0xd5, 0x20, 0x20, 0x10, 0x20, 0x08, 0x40, 0x01, 0xfe, 0x41, 0x02, 0x21, 0x02, 0x11, 0x02, 0x01, 0x02, 0x01, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xda, 0xd6, 0x00, 0x10, 0x00, 0x20, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x7c, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x1c, 0x82, 0x70, 0x82, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xda, 0xd7, 0x00, 0x50, 0x01, 0x52, 0x7c, 0xd4, 0x10, 0x50, 0x13, 0xff, 0x10, 0x84, 0x7c, 0x48, 0x11, 0xfe, 0x10, 0x20, 0x10, 0xfc, 0x10, 0x20, 0x1d, 0xff, 0x70, 0x50, 0x00, 0x8c, 0x03, 0x03, 0x00, 0x00 },
{ 0xda, 0xd8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x20, 0x10, 0x10, 0x20, 0x00, 0xff, 0x40, 0x81, 0x24, 0x81, 0x04, 0x81, 0x08, 0xff, 0x08, 0x81, 0x10, 0x81, 0x10, 0x81, 0x20, 0xff, 0x00, 0x00 },
{ 0xda, 0xd9, 0x08, 0x08, 0x08, 0x08, 0x4a, 0x10, 0x2c, 0xff, 0x08, 0x81, 0x7e, 0x81, 0x08, 0x81, 0x18, 0x81, 0x1c, 0xff, 0x2a, 0x81, 0x28, 0x81, 0x48, 0x81, 0x48, 0x81, 0x08, 0x81, 0x08, 0xff, 0x00, 0x00 },
{ 0xda, 0xda, 0x10, 0x24, 0x10, 0x22, 0x25, 0xff, 0x44, 0x20, 0x29, 0xfe, 0x11, 0x22, 0x11, 0xfe, 0x25, 0x22, 0x7d, 0xfe, 0x10, 0x04, 0x55, 0xff, 0x54, 0x04, 0x50, 0x84, 0x10, 0x44, 0x10, 0x1c, 0x00, 0x00 },
{ 0xda, 0xdb, 0x00, 0x14, 0x3c, 0x12, 0x25, 0xff, 0x24, 0x10, 0x24, 0xfe, 0x3c, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x24, 0xfe, 0x3c, 0x92, 0x24, 0x04, 0x25, 0xff, 0x24, 0x44, 0x44, 0x24, 0x4c, 0x0c, 0x00, 0x00 },
{ 0xda, 0xdc, 0x08, 0x08, 0x10, 0x08, 0x3e, 0x10, 0x22, 0x7f, 0x2a, 0x41, 0x2a, 0x41, 0x22, 0x41, 0x27, 0x41, 0x7a, 0x7f, 0x2a, 0x41, 0x2a, 0x41, 0x2a, 0x41, 0x22, 0x41, 0x42, 0x41, 0x46, 0x7f, 0x00, 0x00 },
{ 0xda, 0xdd, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x12, 0x23, 0xff, 0x10, 0x20, 0x03, 0xfe, 0x42, 0x22, 0x23, 0xfe, 0x02, 0x22, 0x13, 0xfe, 0x10, 0x08, 0x27, 0xff, 0x21, 0x08, 0x40, 0x88, 0x40, 0x38, 0x00, 0x00 },
{ 0xda, 0xde, 0x20, 0x20, 0x10, 0x40, 0x09, 0xfe, 0x41, 0x02, 0x21, 0x02, 0x11, 0x02, 0x01, 0xfe, 0x01, 0x02, 0x71, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xda, 0xdf, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x08, 0x00, 0x0f, 0xfc, 0x10, 0x04, 0x2f, 0xc4, 0x48, 0x44, 0x0f, 0xd9, 0x08, 0x01, 0x07, 0xff, 0x00, 0x00 },
{ 0xda, 0xe0, 0x00, 0x01, 0x3f, 0x32, 0x24, 0x0c, 0x3f, 0x12, 0x24, 0x61, 0x3f, 0x00, 0x24, 0x22, 0x24, 0x22, 0x3f, 0x22, 0x01, 0x14, 0x55, 0x14, 0x55, 0x08, 0x42, 0x14, 0x02, 0x22, 0x0c, 0x41, 0x00, 0x00 },
{ 0xda, 0xe1, 0x08, 0x20, 0x08, 0xa8, 0x09, 0x24, 0x12, 0x22, 0x10, 0x20, 0x33, 0xfe, 0x30, 0x20, 0x50, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xda, 0xe2, 0x00, 0x80, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xda, 0xe3, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x10, 0x88, 0x10, 0x88, 0x10, 0x50, 0x10, 0x20, 0x20, 0x50, 0x21, 0x8c, 0x4e, 0x03, 0x00, 0x00 },
{ 0xda, 0xe4, 0x10, 0x00, 0x34, 0xff, 0x52, 0x80, 0x52, 0x80, 0x10, 0x80, 0x7e, 0xfe, 0x10, 0xa2, 0x10, 0xa2, 0x1e, 0xa2, 0x70, 0x94, 0x10, 0x94, 0x10, 0x88, 0x21, 0x14, 0x21, 0x22, 0x42, 0x41, 0x00, 0x00 },
{ 0xda, 0xe5, 0x10, 0x20, 0x10, 0x20, 0x10, 0xa8, 0x7d, 0x24, 0x12, 0x22, 0x10, 0x20, 0x13, 0xfe, 0x1c, 0x20, 0x70, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x70, 0x20, 0x00, 0x00 },
{ 0xda, 0xe6, 0x21, 0x00, 0x22, 0x1c, 0x27, 0xd4, 0x74, 0x54, 0x25, 0x54, 0x25, 0x55, 0x25, 0x67, 0x34, 0x40, 0x65, 0xfe, 0x2f, 0x52, 0x25, 0x52, 0x25, 0x54, 0x25, 0x48, 0x28, 0x54, 0x68, 0xe2, 0x00, 0x00 },
{ 0xda, 0xe7, 0x11, 0x44, 0x7c, 0x9f, 0x11, 0x44, 0x38, 0x8e, 0x55, 0x55, 0x12, 0x04, 0x7f, 0xff, 0x04, 0x10, 0x1b, 0xec, 0x60, 0x83, 0x0f, 0xf8, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xda, 0xe8, 0x01, 0x00, 0x7d, 0x3e, 0x11, 0x08, 0x17, 0xc8, 0x10, 0x88, 0x10, 0x88, 0x7c, 0x88, 0x12, 0xbe, 0x11, 0x08, 0x11, 0x88, 0x1d, 0x48, 0x72, 0x48, 0x02, 0x08, 0x04, 0x08, 0x08, 0x7f, 0x00, 0x00 },
{ 0xda, 0xe9, 0x08, 0x00, 0x3e, 0x3c, 0x22, 0x25, 0x2a, 0x47, 0x22, 0x00, 0x7f, 0x7e, 0x2a, 0x24, 0x2a, 0x18, 0x46, 0x67, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xda, 0xea, 0x20, 0x20, 0x10, 0xa4, 0x09, 0x22, 0x02, 0x21, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x20, 0x00, 0x20, 0x00, 0x20, 0x17, 0xff, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xda, 0xeb, 0x20, 0x0e, 0x13, 0xf0, 0x09, 0x24, 0x00, 0xa8, 0x47, 0xff, 0x20, 0x70, 0x10, 0xa8, 0x01, 0x24, 0x06, 0x03, 0x13, 0xfe, 0x12, 0x22, 0x23, 0xfe, 0x22, 0x22, 0x42, 0x22, 0x43, 0xfe, 0x00, 0x00 },
{ 0xda, 0xec, 0x00, 0x80, 0x7c, 0xbf, 0x10, 0x88, 0x10, 0x88, 0x12, 0x88, 0x12, 0x88, 0x7a, 0x88, 0x12, 0xbe, 0x14, 0x88, 0x14, 0x88, 0x1c, 0x88, 0x70, 0x88, 0x01, 0x08, 0x01, 0x08, 0x02, 0x7f, 0x00, 0x00 },
{ 0xda, 0xed, 0x00, 0x10, 0x7c, 0x54, 0x54, 0x92, 0x55, 0x11, 0x54, 0x10, 0x54, 0xfe, 0x7c, 0x10, 0x54, 0x10, 0x54, 0x10, 0x55, 0xff, 0x54, 0x10, 0x54, 0x10, 0x7c, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xda, 0xee, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x00, 0x52, 0x3c, 0x37, 0xa4, 0x14, 0xa5, 0x16, 0xc7, 0x34, 0x80, 0x57, 0xbe, 0x14, 0xa2, 0x16, 0x94, 0x24, 0x88, 0x28, 0x94, 0x49, 0xe3, 0x00, 0x00 },
{ 0xda, 0xef, 0x10, 0x00, 0x3e, 0x3c, 0x22, 0x25, 0x2a, 0x27, 0x22, 0x40, 0x7f, 0x7e, 0x2a, 0x22, 0x2a, 0x14, 0x4a, 0x18, 0x46, 0x67, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x24, 0x12, 0x24, 0x7f, 0xff, 0x00, 0x00 },
{ 0xda, 0xf0, 0x00, 0x00, 0x78, 0xdc, 0x48, 0x84, 0x48, 0x84, 0x79, 0x02, 0x4a, 0x01, 0x48, 0x00, 0x79, 0xfc, 0x48, 0x24, 0x48, 0x24, 0x48, 0x24, 0x78, 0x44, 0x00, 0x44, 0x00, 0x84, 0x01, 0x18, 0x00, 0x00 },
{ 0xda, 0xf1, 0x10, 0x00, 0x3e, 0x7c, 0x2a, 0x45, 0x22, 0x47, 0x7e, 0xbc, 0x2a, 0x24, 0x2a, 0x18, 0x46, 0xe7, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x00, 0x0f, 0xfc, 0x14, 0x04, 0x64, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xda, 0xf2, 0x00, 0x0e, 0x01, 0xf0, 0x7c, 0x92, 0x10, 0x54, 0x11, 0xff, 0x20, 0x38, 0x3c, 0x54, 0x64, 0x92, 0x25, 0x11, 0x24, 0xfe, 0x24, 0x92, 0x24, 0xfe, 0x3c, 0x92, 0x00, 0x92, 0x00, 0xfe, 0x00, 0x00 },
{ 0xda, 0xf3, 0x11, 0x44, 0x10, 0x84, 0x7d, 0x5f, 0x11, 0x44, 0x38, 0x8e, 0x55, 0x55, 0x10, 0x84, 0x7f, 0xff, 0x02, 0x20, 0x04, 0x10, 0x1f, 0xfc, 0x62, 0x03, 0x0f, 0xf8, 0x34, 0x08, 0x07, 0xf8, 0x00, 0x00 },
{ 0xda, 0xf4, 0x10, 0x10, 0x10, 0x92, 0x24, 0x92, 0x45, 0x11, 0x29, 0x11, 0x10, 0x10, 0x10, 0xfe, 0x24, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x54, 0x10, 0x54, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xda, 0xf5, 0x08, 0x00, 0x10, 0x3c, 0x3e, 0x24, 0x22, 0x25, 0x2a, 0x45, 0x2a, 0x87, 0x22, 0x00, 0x27, 0x7e, 0x7a, 0x22, 0x2a, 0x22, 0x2a, 0x14, 0x2a, 0x14, 0x22, 0x08, 0x42, 0x34, 0x46, 0xc3, 0x00, 0x00 },
{ 0xda, 0xf6, 0x10, 0x06, 0x10, 0xf8, 0x10, 0x12, 0x7c, 0x92, 0x54, 0x54, 0x55, 0xff, 0x54, 0x54, 0x54, 0x92, 0x55, 0x11, 0x7c, 0xfe, 0x10, 0x92, 0x14, 0xfe, 0x14, 0x92, 0x1a, 0x92, 0x62, 0xfe, 0x00, 0x00 },
{ 0xda, 0xf7, 0x20, 0x07, 0x10, 0xf8, 0x08, 0x80, 0x40, 0x80, 0x20, 0xfe, 0x10, 0xa2, 0x00, 0xa2, 0x00, 0x94, 0x79, 0x14, 0x09, 0x08, 0x09, 0x14, 0x0a, 0x22, 0x08, 0xc1, 0x16, 0x00, 0x61, 0xff, 0x00, 0x00 },
{ 0xda, 0xf8, 0x1c, 0x00, 0x04, 0xff, 0x24, 0x08, 0x22, 0x10, 0x22, 0x7e, 0x41, 0x42, 0x00, 0x7e, 0x7e, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x12, 0x7e, 0x22, 0x00, 0x22, 0x26, 0x4c, 0xc1, 0x00, 0x00 },
{ 0xda, 0xf9, 0x08, 0x00, 0x14, 0x07, 0x22, 0xf8, 0x5c, 0x80, 0x00, 0x80, 0x3e, 0xfe, 0x22, 0xa2, 0x3e, 0xa2, 0x22, 0x94, 0x3e, 0x94, 0x20, 0x88, 0x3e, 0x88, 0x20, 0x94, 0x3f, 0x22, 0x21, 0x41, 0x00, 0x00 },
{ 0xda, 0xfa, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x10, 0x08, 0x7f, 0x08, 0x11, 0x7f, 0x11, 0x41, 0x11, 0x3e, 0x11, 0x04, 0x11, 0x08, 0x21, 0x0f, 0x21, 0x78, 0x21, 0x08, 0x41, 0x08, 0x41, 0x18, 0x8e, 0x00, 0x00 },
{ 0xda, 0xfb, 0x10, 0x48, 0x10, 0x44, 0x10, 0x40, 0x7d, 0xff, 0x10, 0x40, 0x10, 0x40, 0x10, 0x42, 0x1c, 0x62, 0x70, 0xa2, 0x10, 0x94, 0x10, 0x94, 0x11, 0x08, 0x11, 0x14, 0x12, 0x22, 0x34, 0xc1, 0x00, 0x00 },
{ 0xda, 0xfc, 0x17, 0xa8, 0x10, 0x92, 0x11, 0x0c, 0x7a, 0x04, 0x17, 0xba, 0x10, 0xa9, 0x10, 0xaa, 0x1b, 0xae, 0x72, 0x40, 0x14, 0x3c, 0x17, 0xa4, 0x14, 0xa4, 0x10, 0x98, 0x10, 0x98, 0x33, 0x66, 0x00, 0x00 },
{ 0xda, 0xfd, 0x21, 0x08, 0x11, 0x08, 0x07, 0xe8, 0x01, 0x08, 0x47, 0xdf, 0x24, 0x49, 0x14, 0x49, 0x03, 0x89, 0x00, 0x89, 0x11, 0x11, 0x11, 0xd1, 0x27, 0x11, 0x21, 0x21, 0x41, 0x21, 0x43, 0x4e, 0x00, 0x00 },
{ 0xda, 0xfe, 0x23, 0xa8, 0x10, 0x92, 0x09, 0x0c, 0x02, 0x04, 0x4f, 0xbb, 0x28, 0xa8, 0x18, 0xaa, 0x03, 0xae, 0x02, 0x40, 0x14, 0x3c, 0x17, 0xa4, 0x20, 0xa4, 0x20, 0x98, 0x40, 0x98, 0x43, 0x66, 0x00, 0x00 },
{ 0xdb, 0xa1, 0x00, 0x00, 0x3f, 0x50, 0x01, 0x22, 0x16, 0x14, 0x08, 0x0c, 0x1e, 0x73, 0x62, 0x50, 0x02, 0x52, 0x1e, 0x9e, 0x10, 0x00, 0x3e, 0xfc, 0x22, 0x44, 0x02, 0x28, 0x02, 0x38, 0x1c, 0xc6, 0x00, 0x00 },
{ 0xdb, 0xa2, 0x00, 0x24, 0x3e, 0x22, 0x22, 0x20, 0x22, 0xff, 0x22, 0x20, 0x3e, 0x20, 0x08, 0x22, 0x08, 0x22, 0x28, 0x52, 0x2e, 0x54, 0x28, 0x94, 0x28, 0x88, 0x29, 0x14, 0x2e, 0x22, 0x70, 0xc1, 0x00, 0x00 },
{ 0xdb, 0xa3, 0x00, 0x08, 0x7d, 0xe8, 0x10, 0x2a, 0x11, 0x44, 0x7c, 0x85, 0x55, 0x02, 0x55, 0xdd, 0x54, 0x54, 0x6d, 0xd5, 0x45, 0x13, 0x45, 0xfe, 0x7c, 0x52, 0x44, 0x4c, 0x44, 0x4c, 0x7d, 0xb3, 0x00, 0x00 },
{ 0xdb, 0xa4, 0x18, 0x10, 0x24, 0x10, 0x40, 0x10, 0x01, 0xff, 0x7c, 0x10, 0x10, 0x38, 0x10, 0x38, 0x7c, 0x54, 0x10, 0x54, 0x10, 0x92, 0x54, 0x92, 0x35, 0x7d, 0x10, 0x10, 0x18, 0x10, 0x60, 0x10, 0x00, 0x00 },
{ 0xdb, 0xa5, 0x1f, 0x02, 0x10, 0x0c, 0x1f, 0x31, 0x10, 0x06, 0x7f, 0xb9, 0x11, 0x06, 0x3e, 0xb8, 0x01, 0x08, 0x7f, 0xff, 0x02, 0x00, 0x05, 0x08, 0x18, 0x90, 0x60, 0x60, 0x03, 0x98, 0x1c, 0x07, 0x00, 0x00 },
{ 0xdb, 0xa6, 0x04, 0x10, 0x08, 0x14, 0x3f, 0x12, 0x29, 0x7f, 0x29, 0x10, 0x3f, 0x12, 0x29, 0x12, 0x29, 0x12, 0x3f, 0x2a, 0x14, 0x24, 0x16, 0x44, 0x15, 0x4a, 0x27, 0x91, 0x24, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xdb, 0xa7, 0x09, 0x08, 0x09, 0x08, 0x11, 0x08, 0x17, 0xdf, 0x32, 0x12, 0x32, 0x22, 0x53, 0xd2, 0x12, 0x52, 0x12, 0x52, 0x12, 0x54, 0x12, 0x4c, 0x12, 0x4c, 0x12, 0x4a, 0x14, 0x52, 0x15, 0xa1, 0x00, 0x00 },
{ 0xdb, 0xa8, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x84, 0x10, 0x48, 0x33, 0xff, 0x32, 0x01, 0x50, 0x20, 0x53, 0xff, 0x10, 0x40, 0x10, 0x7e, 0x10, 0x82, 0x10, 0x82, 0x11, 0x02, 0x12, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xa9, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7c, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x7e, 0x10, 0x42, 0x10, 0x42, 0x1c, 0x82, 0x70, 0x82, 0x01, 0x04, 0x02, 0x04, 0x04, 0x18, 0x00, 0x00 },
{ 0xdb, 0xaa, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x3e, 0x44, 0x22, 0x68, 0x22, 0x58, 0x42, 0x08, 0x42, 0x14, 0x84, 0x22, 0x84, 0x41, 0x38, 0x00, 0x00 },
{ 0xdb, 0xab, 0x08, 0x00, 0x08, 0x80, 0x08, 0x42, 0x7f, 0xff, 0x08, 0x08, 0x08, 0x10, 0x0c, 0x64, 0x14, 0x08, 0x14, 0x30, 0x14, 0xc4, 0x14, 0x08, 0x24, 0x30, 0x25, 0xc1, 0x24, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xdb, 0xac, 0x08, 0x04, 0x3f, 0x04, 0x08, 0x7f, 0x7f, 0x84, 0x08, 0x24, 0x3f, 0x14, 0x08, 0x04, 0x0f, 0x1c, 0x78, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x9c, 0x00, 0x80, 0x00, 0x00 },
{ 0xdb, 0xad, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x23, 0xff, 0x48, 0x40, 0x08, 0x40, 0x10, 0x40, 0x10, 0x7e, 0x30, 0x42, 0x50, 0x82, 0x10, 0x82, 0x10, 0x82, 0x11, 0x04, 0x11, 0x04, 0x12, 0x38, 0x00, 0x00 },
{ 0xdb, 0xae, 0x00, 0x1f, 0x1f, 0xe0, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x40, 0x10, 0x40, 0x1f, 0xff, 0x10, 0x80, 0x10, 0xfe, 0x21, 0x02, 0x22, 0x02, 0x4c, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xaf, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x7f, 0x10, 0x44, 0x10, 0xc4, 0x1e, 0x44, 0x12, 0x44, 0x12, 0x24, 0x12, 0x28, 0x12, 0x28, 0x22, 0x10, 0x22, 0x28, 0x22, 0x44, 0x4d, 0x83, 0x00, 0x00 },
{ 0xdb, 0xb0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xfc, 0x02, 0x04, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 0x08, 0x60, 0x70, 0x00, 0x00 },
{ 0xdb, 0xb1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x40, 0x01, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x01, 0x00, 0x03, 0xfc, 0x04, 0x04, 0x08, 0x04, 0x30, 0x38, 0x00, 0x00 },
{ 0xdb, 0xb2, 0x00, 0x20, 0x7c, 0x20, 0x44, 0x20, 0x47, 0xff, 0x44, 0x40, 0x44, 0x40, 0x7c, 0x40, 0x44, 0x7e, 0x44, 0x42, 0x44, 0x42, 0x44, 0x42, 0x7c, 0x82, 0x00, 0x82, 0x01, 0x04, 0x06, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb3, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x20, 0x10, 0x20, 0x38, 0x20, 0x38, 0x3e, 0x34, 0x22, 0x54, 0x22, 0x50, 0x42, 0x50, 0x42, 0x10, 0x82, 0x10, 0x82, 0x11, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb4, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x44, 0x10, 0x28, 0x11, 0xff, 0x39, 0x01, 0x38, 0x10, 0x35, 0xff, 0x54, 0x20, 0x50, 0x20, 0x50, 0x7e, 0x10, 0x42, 0x10, 0x82, 0x11, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb5, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x01, 0x04, 0x40, 0x88, 0x27, 0xff, 0x14, 0x01, 0x00, 0x20, 0x07, 0xff, 0x10, 0x80, 0x10, 0xfc, 0x20, 0x84, 0x21, 0x04, 0x42, 0x04, 0x4c, 0x18, 0x00, 0x00 },
{ 0xdb, 0xb6, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x42, 0x10, 0x24, 0x21, 0xff, 0x3d, 0x01, 0x25, 0x11, 0x64, 0x10, 0x25, 0xff, 0x24, 0x20, 0x24, 0x3e, 0x3c, 0x42, 0x00, 0x82, 0x03, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb7, 0x10, 0x20, 0x10, 0x20, 0x24, 0x20, 0x47, 0xff, 0x28, 0x40, 0x10, 0x40, 0x10, 0x40, 0x24, 0x7e, 0x7c, 0x42, 0x10, 0x42, 0x54, 0x82, 0x54, 0x82, 0x50, 0x82, 0x11, 0x02, 0x12, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb8, 0x00, 0x20, 0x3c, 0x20, 0x24, 0x20, 0x25, 0xff, 0x24, 0x40, 0x3c, 0x40, 0x24, 0x40, 0x24, 0x7e, 0x24, 0x42, 0x3c, 0x42, 0x24, 0x42, 0x24, 0x42, 0x24, 0x82, 0x44, 0x82, 0x4d, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xb9, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x42, 0x24, 0x24, 0x3d, 0xff, 0x25, 0x01, 0x24, 0x10, 0x25, 0xff, 0x3c, 0x20, 0x24, 0x3e, 0x24, 0x22, 0x24, 0x42, 0x44, 0x82, 0x4d, 0x0c, 0x00, 0x00 },
{ 0xdb, 0xba, 0x08, 0x10, 0x10, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x2a, 0x20, 0x2a, 0x20, 0x22, 0x20, 0x27, 0x3e, 0x7a, 0x22, 0x2a, 0x22, 0x2a, 0x22, 0x2a, 0x42, 0x22, 0x42, 0x42, 0x42, 0x46, 0x8c, 0x00, 0x00 },
{ 0xdb, 0xbb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x90, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x01, 0x00, 0x01, 0xfc, 0x01, 0x04, 0x02, 0x04, 0x02, 0x04, 0x04, 0x08, 0x08, 0x08, 0x30, 0x70, 0x00, 0x00 },
{ 0xdb, 0xbc, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x01, 0x00, 0x3f, 0xfc, 0x08, 0x20, 0x04, 0x40, 0x7f, 0xfe, 0x41, 0x02, 0x3f, 0xf8, 0x02, 0x00, 0x03, 0xf8, 0x04, 0x08, 0x18, 0x10, 0x60, 0x60, 0x00, 0x00 },
{ 0xdb, 0xbd, 0x10, 0x10, 0x10, 0x10, 0x10, 0x17, 0x7d, 0xf8, 0x54, 0x10, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x54, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x14, 0x10, 0x14, 0x10, 0x1a, 0x10, 0x62, 0x10, 0x00, 0x00 },
{ 0xdb, 0xbe, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x7e, 0xff, 0x00, 0x20, 0x3e, 0x20, 0x00, 0x3e, 0x3e, 0x22, 0x00, 0x22, 0x00, 0x22, 0x3e, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x82, 0x3f, 0x0c, 0x00, 0x00 },
{ 0xdb, 0xbf, 0x00, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x7c, 0x44, 0x00, 0x28, 0x3d, 0xff, 0x01, 0x01, 0x3d, 0x11, 0x00, 0x10, 0x01, 0xff, 0x3c, 0x20, 0x24, 0x3e, 0x24, 0x22, 0x24, 0x42, 0x3d, 0x8c, 0x00, 0x00 },
{ 0xdb, 0xc0, 0x08, 0x00, 0x08, 0x3f, 0x7f, 0x21, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x24, 0x08, 0x22, 0x08, 0x22, 0x08, 0x21, 0x7f, 0x21, 0x08, 0x21, 0x10, 0x26, 0x10, 0x20, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xdb, 0xc1, 0x00, 0x20, 0x7c, 0x20, 0x44, 0x20, 0x4b, 0xff, 0x48, 0x40, 0x50, 0x40, 0x48, 0x40, 0x48, 0x7e, 0x44, 0x42, 0x44, 0x82, 0x44, 0x82, 0x58, 0x82, 0x41, 0x02, 0x41, 0x02, 0x42, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xc2, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x10, 0x1f, 0xfe, 0x14, 0x50, 0x12, 0x9e, 0x1f, 0xc2, 0x10, 0x1e, 0x17, 0xd0, 0x14, 0x5e, 0x17, 0xd0, 0x24, 0x5e, 0x27, 0xd1, 0x44, 0x51, 0x45, 0x8f, 0x00, 0x00 },
{ 0xdb, 0xc3, 0x08, 0x20, 0x08, 0x20, 0x09, 0xfe, 0x10, 0x00, 0x10, 0x84, 0x30, 0x48, 0x33, 0xff, 0x50, 0x00, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xc4, 0x08, 0x90, 0x08, 0x90, 0x10, 0x90, 0x17, 0x9f, 0x30, 0x90, 0x30, 0x90, 0x53, 0x9e, 0x10, 0x90, 0x10, 0x90, 0x11, 0x90, 0x16, 0x9f, 0x10, 0x90, 0x11, 0x10, 0x11, 0x10, 0x12, 0x10, 0x00, 0x00 },
{ 0xdb, 0xc5, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x7e, 0x21, 0x02, 0x26, 0x02, 0x38, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x0e, 0x20, 0x72, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x1f, 0x00, 0x00 },
{ 0xdb, 0xc6, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x00, 0x7c, 0x84, 0x10, 0x48, 0x13, 0xff, 0x10, 0x00, 0x10, 0x00, 0x11, 0xfe, 0x1d, 0x02, 0x71, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xc7, 0x08, 0x90, 0x08, 0x90, 0x17, 0x9f, 0x20, 0x90, 0x48, 0x90, 0x08, 0x90, 0x17, 0x9e, 0x10, 0x90, 0x30, 0x90, 0x51, 0x90, 0x16, 0x9f, 0x11, 0x10, 0x11, 0x10, 0x12, 0x10, 0x14, 0x10, 0x00, 0x00 },
{ 0xdb, 0xc8, 0x06, 0x00, 0x79, 0xff, 0x08, 0x10, 0x08, 0x10, 0x08, 0xfe, 0x7e, 0x10, 0x08, 0x10, 0x08, 0xfe, 0x08, 0x10, 0x0e, 0x10, 0x79, 0xff, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x00, 0x00 },
{ 0xdb, 0xc9, 0x10, 0x48, 0x10, 0x48, 0x13, 0xcf, 0x78, 0x48, 0x10, 0x48, 0x13, 0xcf, 0x10, 0x48, 0x18, 0x48, 0x70, 0x48, 0x11, 0xcf, 0x16, 0x48, 0x10, 0x88, 0x10, 0x88, 0x11, 0x08, 0x32, 0x08, 0x00, 0x00 },
{ 0xdb, 0xca, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x20, 0x10, 0x30, 0x38, 0x54, 0x38, 0x52, 0x34, 0x91, 0x55, 0x11, 0x50, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xdb, 0xcb, 0x20, 0x80, 0x13, 0x3e, 0x09, 0x08, 0x01, 0x08, 0x41, 0x3e, 0x27, 0xc8, 0x11, 0x08, 0x01, 0x3e, 0x01, 0xc8, 0x17, 0x08, 0x11, 0x3f, 0x21, 0x08, 0x22, 0x08, 0x42, 0x08, 0x44, 0x08, 0x00, 0x00 },
{ 0xdb, 0xcc, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x54, 0x84, 0x58, 0x84, 0x50, 0x48, 0x50, 0x48, 0x13, 0xff, 0x10, 0x00, 0x10, 0x00, 0x28, 0xfc, 0x24, 0x84, 0x20, 0x84, 0x40, 0x84, 0x40, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xcd, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x80, 0x01, 0xb0, 0x06, 0x8c, 0x18, 0x82, 0x60, 0x81, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdb, 0xce, 0x02, 0x20, 0x02, 0x23, 0x7e, 0x3c, 0x02, 0x20, 0x0e, 0x21, 0x72, 0x1f, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xdb, 0xcf, 0x00, 0x00, 0x3d, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x24, 0x20, 0x3c, 0x20, 0x24, 0x68, 0x24, 0x64, 0x24, 0xa2, 0x3d, 0x22, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x44, 0x00, 0x4d, 0xff, 0x00, 0x00 },
{ 0xdb, 0xd0, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x7e, 0x3f, 0x04, 0x20, 0x18, 0xa0, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x40, 0x0c, 0x24, 0x74, 0x18, 0x07, 0x8c, 0x3c, 0x03, 0x00, 0x00 },
{ 0xdb, 0xd1, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x1e, 0x3c, 0x02, 0x20, 0x1e, 0x3e, 0x64, 0xa0, 0x09, 0x40, 0x32, 0x22, 0x0c, 0x14, 0x72, 0x08, 0x03, 0xc4, 0x0c, 0x03, 0x00, 0x00 },
{ 0xdb, 0xd2, 0x10, 0x50, 0x10, 0x53, 0x13, 0xdc, 0x7c, 0x51, 0x08, 0xd1, 0x0b, 0x4f, 0x10, 0x00, 0x14, 0xfe, 0x38, 0x82, 0x54, 0xfe, 0x14, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8c, 0x00, 0x00 },
{ 0xdb, 0xd3, 0x00, 0x10, 0x3c, 0x10, 0x24, 0xfe, 0x24, 0x44, 0x3c, 0x24, 0x24, 0x28, 0x25, 0xff, 0x3c, 0x00, 0x24, 0x00, 0x24, 0xfe, 0x3c, 0x82, 0x00, 0x82, 0x24, 0x82, 0x22, 0x82, 0x42, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xd4, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x7e, 0x3f, 0x04, 0xa0, 0x7f, 0xff, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x00 },
{ 0xdb, 0xd5, 0x00, 0x00, 0x7f, 0x3e, 0x14, 0x02, 0x14, 0x02, 0x7f, 0x02, 0x55, 0x02, 0x55, 0x3e, 0x55, 0x20, 0x67, 0x20, 0x41, 0x20, 0x41, 0x20, 0x7f, 0x20, 0x41, 0x21, 0x41, 0x21, 0x7f, 0x1f, 0x00, 0x00 },
{ 0xdb, 0xd6, 0x00, 0x20, 0x7c, 0x20, 0x45, 0xfe, 0x48, 0x84, 0x48, 0x44, 0x50, 0x48, 0x4b, 0xff, 0x48, 0x00, 0x44, 0x00, 0x45, 0xfe, 0x45, 0x02, 0x59, 0x02, 0x41, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xd7, 0x08, 0x10, 0x08, 0x10, 0x08, 0x20, 0x11, 0xfe, 0x11, 0x02, 0x31, 0x02, 0x31, 0x02, 0x51, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xd8, 0x08, 0x00, 0x0b, 0xff, 0x10, 0x20, 0x10, 0x20, 0x30, 0x40, 0x31, 0xfe, 0x51, 0x02, 0x51, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xd9, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xdb, 0xda, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x7c, 0xff, 0x10, 0x81, 0x10, 0x81, 0x38, 0x81, 0x38, 0x81, 0x34, 0xff, 0x54, 0x81, 0x50, 0x81, 0x50, 0x81, 0x10, 0x81, 0x10, 0x81, 0x10, 0xff, 0x00, 0x00 },
{ 0xdb, 0xdb, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x7c, 0x20, 0x10, 0x40, 0x11, 0xfe, 0x39, 0x02, 0x39, 0x02, 0x35, 0x02, 0x55, 0xfe, 0x51, 0x02, 0x51, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xdc, 0x00, 0x80, 0x01, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xdd, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xde, 0x10, 0x10, 0x20, 0x20, 0x7c, 0xfe, 0x44, 0x92, 0x44, 0x92, 0x44, 0xfe, 0x7c, 0x92, 0x44, 0x92, 0x44, 0xfe, 0x44, 0x52, 0x7c, 0x55, 0x00, 0x97, 0x00, 0x90, 0x01, 0x11, 0x06, 0x0f, 0x00, 0x00 },
{ 0xdb, 0xdf, 0x10, 0x06, 0x11, 0xf8, 0x10, 0x92, 0x7c, 0x54, 0x55, 0xff, 0x54, 0x38, 0x54, 0x54, 0x55, 0x93, 0x54, 0xfe, 0x54, 0x92, 0x54, 0x92, 0x5c, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x10, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xe0, 0x11, 0x44, 0x10, 0x84, 0x7d, 0x5f, 0x10, 0x04, 0x39, 0x4e, 0x34, 0x8e, 0x51, 0x55, 0x12, 0x04, 0x10, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xdb, 0xe1, 0x10, 0x00, 0x11, 0xff, 0x12, 0x10, 0x54, 0x20, 0x58, 0xfe, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x28, 0x82, 0x24, 0xfe, 0x20, 0x00, 0x40, 0x46, 0x41, 0x81, 0x00, 0x00 },
{ 0xdb, 0xe2, 0x10, 0x1c, 0x11, 0xe0, 0x10, 0x20, 0x55, 0x24, 0x58, 0xa8, 0x53, 0xff, 0x50, 0xa8, 0x11, 0x24, 0x12, 0x02, 0x15, 0xfd, 0x29, 0x24, 0x25, 0xfc, 0x21, 0x24, 0x41, 0x24, 0x41, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xe3, 0x00, 0x1e, 0x3f, 0xe0, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xe4, 0x00, 0x06, 0x7d, 0xf8, 0x10, 0x92, 0x10, 0x54, 0x11, 0xff, 0x20, 0x38, 0x3c, 0x54, 0x25, 0x93, 0x64, 0x10, 0x24, 0xfe, 0x24, 0x92, 0x24, 0xfe, 0x3c, 0x92, 0x20, 0x92, 0x00, 0xfe, 0x00, 0x00 },
{ 0xdb, 0xe5, 0x10, 0x10, 0x3f, 0x90, 0x40, 0x3f, 0x1f, 0x62, 0x15, 0x22, 0x7f, 0xd4, 0x25, 0x08, 0x3f, 0x94, 0x01, 0x63, 0x0a, 0x24, 0x04, 0x42, 0x7f, 0xfd, 0x00, 0x80, 0x0c, 0x9c, 0x70, 0x83, 0x00, 0x00 },
{ 0xdb, 0xe6, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x1e, 0x3f, 0xe4, 0x08, 0x88, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x0c, 0x6f, 0xfb, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xdb, 0xe7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x20, 0x0e, 0x13, 0xf0, 0x01, 0x24, 0x40, 0xa8, 0x27, 0xff, 0x00, 0xa8, 0x11, 0x24, 0x13, 0xfe, 0x25, 0x25, 0x21, 0xfc, 0x41, 0x24, 0x41, 0xfc, 0x00, 0x00 },
{ 0xdb, 0xe8, 0x06, 0x00, 0x38, 0xf8, 0x4a, 0x0a, 0x28, 0x6c, 0x7e, 0xaa, 0x08, 0xa8, 0x1c, 0xa5, 0x2a, 0xa3, 0x49, 0xf8, 0x3e, 0xaa, 0x2a, 0xac, 0x3e, 0xaa, 0x2a, 0xa8, 0x2b, 0x25, 0x3e, 0x23, 0x00, 0x00 },
{ 0xdb, 0xe9, 0x08, 0x48, 0x08, 0x44, 0x08, 0x40, 0x10, 0x5f, 0x17, 0xe0, 0x30, 0x40, 0x30, 0x44, 0x50, 0x44, 0x10, 0x28, 0x10, 0x28, 0x10, 0x10, 0x10, 0x30, 0x10, 0x49, 0x11, 0x85, 0x16, 0x03, 0x00, 0x00 },
{ 0xdb, 0xea, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x48, 0x08, 0x44, 0x10, 0x7f, 0x17, 0xc0, 0x30, 0x44, 0x50, 0x24, 0x10, 0x28, 0x10, 0x10, 0x10, 0x29, 0x10, 0xc5, 0x13, 0x03, 0x00, 0x00 },
{ 0xdb, 0xeb, 0x00, 0x00, 0x3f, 0xff, 0x22, 0x21, 0x22, 0x21, 0x3f, 0xff, 0x00, 0x00, 0x3f, 0x01, 0x00, 0x11, 0x7f, 0x91, 0x00, 0x11, 0x3f, 0x11, 0x00, 0x11, 0x3f, 0x01, 0x21, 0x01, 0x3f, 0x07, 0x00, 0x00 },
{ 0xdb, 0xec, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x44, 0xa2, 0x48, 0x82, 0x5b, 0xf2, 0x68, 0x82, 0x48, 0xa2, 0x48, 0xc2, 0x4b, 0x52, 0x48, 0x32, 0x40, 0x06, 0x00, 0x00 },
{ 0xdb, 0xed, 0x00, 0x00, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x09, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x10, 0x10, 0x10, 0x10, 0x11, 0x10, 0x11, 0x20, 0x11, 0x40, 0x0f, 0x00, 0x00 },
{ 0xdb, 0xee, 0x10, 0x00, 0x10, 0xf8, 0x10, 0x88, 0x7c, 0x88, 0x54, 0x88, 0x54, 0x88, 0x54, 0xc8, 0x54, 0xa8, 0x54, 0xa8, 0x54, 0x88, 0x5c, 0x88, 0x10, 0x89, 0x11, 0x09, 0x11, 0x09, 0x12, 0x0f, 0x00, 0x00 },
{ 0xdb, 0xef, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x7e, 0x08, 0x10, 0x1c, 0x38, 0x2a, 0x54, 0x48, 0x93, 0x08, 0x10, 0x00, 0x00, 0x07, 0xe0, 0x04, 0x20, 0x05, 0x20, 0x08, 0xa1, 0x10, 0xa1, 0x60, 0x1f, 0x00, 0x00 },
{ 0xdb, 0xf0, 0x20, 0x00, 0x11, 0xfe, 0x09, 0x02, 0x01, 0x02, 0x41, 0x02, 0x21, 0x02, 0x11, 0x02, 0x01, 0x02, 0x01, 0x02, 0x11, 0x0e, 0x11, 0x00, 0x21, 0x00, 0x21, 0x01, 0x41, 0x01, 0x40, 0xff, 0x00, 0x00 },
{ 0xdb, 0xf1, 0x20, 0x00, 0x11, 0xf8, 0x09, 0x08, 0x01, 0x08, 0x41, 0x08, 0x21, 0x08, 0x11, 0x48, 0x01, 0x28, 0x01, 0x28, 0x11, 0x08, 0x11, 0x08, 0x22, 0x08, 0x22, 0x09, 0x44, 0x09, 0x48, 0x0f, 0x00, 0x00 },
{ 0xdb, 0xf2, 0x20, 0x0e, 0x11, 0xf0, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x02, 0x00, 0x04, 0x00, 0x04, 0x10, 0x08, 0x11, 0x10, 0x21, 0x20, 0x22, 0xc0, 0x42, 0x60, 0x44, 0x1f, 0x00, 0x00 },
{ 0xdb, 0xf3, 0x04, 0x00, 0x44, 0xfe, 0x28, 0x82, 0x10, 0x82, 0x30, 0x82, 0x50, 0x82, 0x08, 0x82, 0x08, 0x82, 0x18, 0x8e, 0x28, 0x80, 0x48, 0x80, 0x08, 0x80, 0x08, 0x81, 0x08, 0x81, 0x30, 0x7f, 0x00, 0x00 },
{ 0xdb, 0xf4, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x48, 0x84, 0x7f, 0x00, 0x08, 0x3e, 0x3f, 0x22, 0x29, 0x22, 0x3f, 0x22, 0x29, 0x2e, 0x3f, 0x20, 0x08, 0x20, 0x7f, 0x21, 0x08, 0x21, 0x08, 0x1f, 0x00, 0x00 },
{ 0xdb, 0xf5, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x20, 0x20, 0x00, 0x10, 0xfe, 0x00, 0x82, 0x40, 0x82, 0x20, 0x82, 0x04, 0x9c, 0x08, 0x80, 0x10, 0x81, 0x20, 0x81, 0x40, 0x7f, 0x00, 0x00 },
{ 0xdb, 0xf6, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xfe, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x00, 0x40, 0x10, 0x40, 0x10, 0x84, 0x20, 0x82, 0x21, 0x0e, 0x41, 0x71, 0x47, 0x81, 0x00, 0x00 },
{ 0xdb, 0xf7, 0x00, 0x88, 0x00, 0x48, 0x7c, 0x08, 0x10, 0x3e, 0x11, 0x08, 0x10, 0x88, 0x7c, 0x08, 0x10, 0x7f, 0x10, 0x08, 0x10, 0x88, 0x10, 0x92, 0x1d, 0x12, 0x71, 0x2d, 0x02, 0x71, 0x02, 0x01, 0x00, 0x00 },
{ 0xdb, 0xf8, 0x08, 0x04, 0x0b, 0xc4, 0x12, 0x5f, 0x12, 0x40, 0x32, 0x51, 0x33, 0xc9, 0x52, 0x0a, 0x12, 0x1f, 0x13, 0xc4, 0x16, 0x44, 0x16, 0x5f, 0x1a, 0x44, 0x12, 0x44, 0x13, 0xc4, 0x10, 0x04, 0x00, 0x00 },
{ 0xdb, 0xf9, 0x00, 0x10, 0x3e, 0xfe, 0x22, 0x44, 0x3e, 0x48, 0x20, 0xfe, 0x3e, 0x10, 0x52, 0xfe, 0x52, 0x10, 0x1e, 0x10, 0x00, 0x00, 0x3f, 0xfe, 0x01, 0x02, 0x02, 0x02, 0x0c, 0x04, 0x30, 0x38, 0x00, 0x00 },
{ 0xdb, 0xfa, 0x00, 0x08, 0x3f, 0x08, 0x21, 0x7f, 0x21, 0x22, 0x3f, 0x14, 0x20, 0x7f, 0x3f, 0x08, 0x51, 0x08, 0x51, 0x3e, 0x1f, 0x08, 0x00, 0x88, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdb, 0xfb, 0x3f, 0x08, 0x21, 0x7f, 0x3f, 0x22, 0x20, 0x14, 0x3f, 0x7f, 0x51, 0x08, 0x5f, 0x3e, 0x00, 0x08, 0x0f, 0xf0, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xdb, 0xfc, 0x00, 0x08, 0x3f, 0x7f, 0x21, 0x22, 0x3f, 0x14, 0x20, 0x7f, 0x3f, 0x08, 0x51, 0x7f, 0x5f, 0x08, 0x00, 0x88, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xdb, 0xfd, 0x00, 0x10, 0x3f, 0x7e, 0x21, 0x24, 0x3f, 0x28, 0x20, 0x7e, 0x3f, 0x10, 0x51, 0x7e, 0x5f, 0x10, 0x00, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x90, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdb, 0xfe, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x04, 0x33, 0xdf, 0x12, 0x51, 0x12, 0x4a, 0x33, 0xdf, 0x52, 0x04, 0x12, 0x04, 0x17, 0xdf, 0x26, 0x44, 0x2a, 0x44, 0x43, 0xc4, 0x00, 0x00 },
{ 0xdc, 0xa1, 0x00, 0x08, 0x7f, 0x10, 0x08, 0x7f, 0x3e, 0x41, 0x08, 0x7f, 0x0f, 0x41, 0x78, 0x7f, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x1f, 0xfe, 0x64, 0x02, 0x04, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xdc, 0xa2, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0x08, 0x21, 0x7f, 0x3f, 0x14, 0x20, 0x7f, 0x3f, 0x08, 0x51, 0x7f, 0x5f, 0x08, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xdc, 0xa3, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x4f, 0x22, 0x49, 0xfa, 0x4f, 0x52, 0x48, 0xfa, 0x4f, 0x22, 0x4d, 0xfa, 0x55, 0x22, 0x47, 0x22, 0x40, 0x0e, 0x00, 0x00 },
{ 0xdc, 0xa4, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x3f, 0x08, 0x21, 0x7f, 0x3f, 0x22, 0x20, 0x14, 0x3f, 0x7f, 0x31, 0x08, 0x51, 0x3e, 0x51, 0x08, 0x1f, 0x08, 0x00, 0x00 },
{ 0xdc, 0xa5, 0x08, 0x00, 0x0b, 0xff, 0x08, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x32, 0x22, 0x33, 0xfe, 0x52, 0x22, 0x13, 0xfe, 0x10, 0x20, 0x12, 0x20, 0x11, 0x40, 0x10, 0xc0, 0x10, 0xb8, 0x13, 0x07, 0x00, 0x00 },
{ 0xdc, 0xa6, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x00, 0x98, 0x00, 0x84, 0x00, 0x82, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdc, 0xa7, 0x02, 0x00, 0x02, 0x20, 0x04, 0x10, 0x08, 0xf8, 0x7f, 0x04, 0x00, 0x04, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xfe, 0x04, 0x20, 0x04, 0x20, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x60, 0x20, 0x00, 0x00 },
{ 0xdc, 0xa8, 0x20, 0x08, 0x49, 0xd2, 0x30, 0x0c, 0x25, 0xe9, 0x7c, 0x1f, 0x11, 0xc4, 0x55, 0x55, 0x55, 0x55, 0x11, 0xc4, 0x04, 0x00, 0x1f, 0xfe, 0x62, 0x10, 0x01, 0x20, 0x01, 0xe0, 0x7e, 0x1f, 0x00, 0x00 },
{ 0xdc, 0xa9, 0x10, 0x44, 0x10, 0x44, 0x7c, 0x5f, 0x25, 0x49, 0x25, 0x4a, 0x29, 0x4a, 0x7d, 0x5f, 0x11, 0x44, 0x12, 0x44, 0x1a, 0x44, 0x70, 0x9f, 0x10, 0x84, 0x21, 0x04, 0x21, 0x04, 0x42, 0x04, 0x00, 0x00 },
{ 0xdc, 0xaa, 0x10, 0x04, 0x13, 0xc4, 0x78, 0x1f, 0x2f, 0xea, 0x28, 0x0a, 0x2b, 0xca, 0x78, 0x1f, 0x13, 0xc4, 0x10, 0x04, 0x1c, 0x04, 0x73, 0xdf, 0x12, 0x44, 0x22, 0x44, 0x22, 0x44, 0x43, 0xc4, 0x00, 0x00 },
{ 0xdc, 0xab, 0x20, 0x20, 0x11, 0xfc, 0x01, 0x04, 0x41, 0xfc, 0x21, 0x04, 0x03, 0xfe, 0x02, 0x52, 0x01, 0x9e, 0x70, 0x20, 0x11, 0xfc, 0x10, 0x40, 0x10, 0x7c, 0x10, 0x84, 0x2d, 0x08, 0x43, 0xff, 0x00, 0x00 },
{ 0xdc, 0xac, 0x00, 0x01, 0x3f, 0x91, 0x20, 0x91, 0x20, 0x91, 0x20, 0x91, 0x3f, 0x91, 0x08, 0x11, 0x08, 0x11, 0x0f, 0x91, 0x08, 0x91, 0x08, 0x81, 0x10, 0x81, 0x10, 0x81, 0x20, 0x81, 0x43, 0x07, 0x00, 0x00 },
{ 0xdc, 0xad, 0x2a, 0x10, 0x49, 0x10, 0x7f, 0x3f, 0x49, 0x62, 0x5d, 0x14, 0x6b, 0x1c, 0x49, 0x63, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdc, 0xae, 0x2a, 0x10, 0x49, 0x10, 0x7f, 0x3f, 0x49, 0x62, 0x5d, 0x14, 0x6b, 0x0c, 0x4f, 0xf3, 0x10, 0x40, 0x7f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x24, 0x88, 0x22, 0x44, 0x00, 0x00 },
{ 0xdc, 0xaf, 0x15, 0x10, 0x24, 0x90, 0x7f, 0xbf, 0x24, 0xd2, 0x2d, 0x8c, 0x24, 0xb3, 0x1f, 0xf8, 0x12, 0x48, 0x3e, 0x7c, 0x22, 0x44, 0x3e, 0x7c, 0x22, 0x44, 0x3e, 0x7d, 0x02, 0x41, 0x01, 0xff, 0x00, 0x00 },
{ 0xdc, 0xb0, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0xc2, 0x21, 0x22, 0x22, 0x12, 0x2c, 0x0a, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x0e, 0x00, 0x00 },
{ 0xdc, 0xb1, 0x0c, 0x48, 0x08, 0x48, 0x10, 0x90, 0x13, 0xfe, 0x30, 0x90, 0x50, 0x90, 0x10, 0x90, 0x10, 0xd0, 0x17, 0xbf, 0x10, 0x90, 0x10, 0x90, 0x11, 0x10, 0x11, 0x10, 0x12, 0x10, 0x14, 0x10, 0x00, 0x00 },
{ 0xdc, 0xb2, 0x00, 0x38, 0x0f, 0xc0, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x7f, 0xff, 0x00, 0x00, 0x04, 0x18, 0x18, 0x06, 0x60, 0x01, 0x00, 0x00 },
{ 0xdc, 0xb3, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x11, 0x08, 0x10, 0x90, 0x13, 0xfc, 0x10, 0x90, 0x10, 0xd0, 0x27, 0xbe, 0x20, 0x90, 0x21, 0x10, 0x42, 0x10, 0x44, 0x10, 0x00, 0x00 },
{ 0xdc, 0xb4, 0x02, 0x10, 0x02, 0x10, 0x04, 0x20, 0x3f, 0xfe, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xdc, 0xb5, 0x00, 0x00, 0x03, 0xff, 0x78, 0x10, 0x48, 0x10, 0x48, 0x10, 0x49, 0xff, 0x79, 0x11, 0x49, 0x29, 0x49, 0x25, 0x49, 0x45, 0x49, 0x45, 0x79, 0x81, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x00, 0x00 },
{ 0xdc, 0xb6, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x11, 0x44, 0x12, 0x24, 0x14, 0x24, 0x10, 0x18, 0x00, 0x00 },
{ 0xdc, 0xb7, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x7c, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x39, 0x22, 0x39, 0x52, 0x35, 0x4a, 0x55, 0x8a, 0x51, 0x02, 0x51, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0x0e, 0x00, 0x00 },
{ 0xdc, 0xb8, 0x10, 0x38, 0x10, 0xe0, 0x10, 0x20, 0x7d, 0xff, 0x10, 0x20, 0x11, 0xfc, 0x38, 0x24, 0x37, 0xff, 0x34, 0x24, 0x51, 0xfc, 0x50, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0x20, 0x00, 0x00 },
{ 0xdc, 0xb9, 0x10, 0x00, 0x17, 0xff, 0x10, 0x20, 0x54, 0x20, 0x59, 0xfe, 0x51, 0x22, 0x51, 0x22, 0x11, 0x22, 0x11, 0x52, 0x11, 0x4a, 0x29, 0x8a, 0x25, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0x0e, 0x00, 0x00 },
{ 0xdc, 0xba, 0x12, 0xff, 0x12, 0x40, 0x24, 0x40, 0x7f, 0x40, 0x22, 0x7c, 0x22, 0x44, 0x22, 0x44, 0x2a, 0x64, 0x37, 0x54, 0x62, 0x54, 0x22, 0x44, 0x22, 0x44, 0x22, 0x45, 0x22, 0x5d, 0x42, 0xe6, 0x00, 0x00 },
{ 0xdc, 0xbb, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x00, 0x33, 0xff, 0x10, 0x20, 0x10, 0x20, 0x33, 0xff, 0x52, 0x21, 0x12, 0x51, 0x12, 0x49, 0x22, 0x89, 0x22, 0x01, 0x42, 0x0f, 0x00, 0x00 },
{ 0xdc, 0xbc, 0x00, 0x3c, 0x0f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xdc, 0xbd, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x00, 0x00, 0x02, 0x02, 0x22, 0x42, 0x22, 0x42, 0x12, 0x42, 0x14, 0x24, 0x14, 0x24, 0x04, 0x24, 0x0f, 0x08, 0x70, 0x08, 0x00, 0xff, 0x00, 0x00 },
{ 0xdc, 0xbe, 0x10, 0x22, 0x10, 0x22, 0x7e, 0x44, 0x10, 0xef, 0x7e, 0x44, 0x52, 0x44, 0x7e, 0x54, 0x52, 0x64, 0x7e, 0xcf, 0x10, 0x44, 0x10, 0x44, 0x7e, 0x44, 0x10, 0x84, 0x10, 0x84, 0x11, 0x04, 0x00, 0x00 },
{ 0xdc, 0xbf, 0x08, 0x22, 0x14, 0x22, 0x22, 0x44, 0x5c, 0xef, 0x00, 0x44, 0x3e, 0x44, 0x22, 0x44, 0x3e, 0x64, 0x22, 0xcf, 0x3e, 0x44, 0x20, 0x44, 0x3e, 0x44, 0x20, 0x84, 0x3e, 0x84, 0x21, 0x04, 0x00, 0x00 },
{ 0xdc, 0xc0, 0x00, 0x12, 0x3e, 0x12, 0x28, 0x24, 0x3e, 0xff, 0x28, 0x24, 0x3e, 0x24, 0x28, 0x24, 0x28, 0xff, 0x3f, 0x24, 0x01, 0x24, 0x55, 0x24, 0x55, 0x24, 0x41, 0x44, 0x02, 0x44, 0x1c, 0x84, 0x00, 0x00 },
{ 0xdc, 0xc1, 0x08, 0x00, 0x09, 0xfe, 0x09, 0x02, 0x11, 0x02, 0x11, 0x02, 0x31, 0xfe, 0x30, 0x20, 0x50, 0x20, 0x53, 0xff, 0x10, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xdc, 0xc2, 0x08, 0x00, 0x09, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x31, 0xfc, 0x50, 0x20, 0x17, 0xff, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0xa0, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdc, 0xc3, 0x08, 0x00, 0x08, 0x7f, 0x3e, 0x41, 0x08, 0x41, 0x08, 0x41, 0x7f, 0x46, 0x22, 0x40, 0x14, 0x7f, 0x7f, 0x51, 0x08, 0x52, 0x08, 0x4a, 0x3e, 0x4c, 0x08, 0x4c, 0x08, 0x52, 0x08, 0x61, 0x00, 0x00 },
{ 0xdc, 0xc4, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x21, 0x5f, 0x7d, 0x04, 0x90, 0x1e, 0x7e, 0x04, 0x94, 0x3f, 0xfc, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x07, 0xf0, 0x3c, 0x1e, 0x00, 0x00 },
{ 0xdc, 0xc5, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x12, 0x24, 0x0a, 0x28, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xdc, 0xc6, 0x00, 0x80, 0x00, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x84, 0x10, 0x84, 0x63, 0x88, 0x00, 0x08, 0x00, 0x10, 0x00, 0x60, 0x0f, 0x80, 0x00, 0x00 },
{ 0xdc, 0xc7, 0x20, 0x88, 0x10, 0x8a, 0x08, 0x89, 0x01, 0x08, 0x41, 0x7f, 0x23, 0x08, 0x13, 0x08, 0x05, 0x08, 0x01, 0x08, 0x11, 0x14, 0x11, 0x14, 0x21, 0x14, 0x21, 0x22, 0x41, 0x22, 0x41, 0x41, 0x00, 0x00 },
{ 0xdc, 0xc8, 0x20, 0x80, 0x10, 0xbe, 0x08, 0xa2, 0x01, 0x22, 0x41, 0x22, 0x23, 0x3e, 0x13, 0x08, 0x05, 0x08, 0x01, 0x7f, 0x11, 0x08, 0x11, 0x1c, 0x21, 0x2a, 0x21, 0x49, 0x41, 0x08, 0x41, 0x08, 0x00, 0x00 },
{ 0xdc, 0xc9, 0x20, 0x88, 0x10, 0x50, 0x0b, 0xfe, 0x00, 0x50, 0x41, 0x54, 0x20, 0xd8, 0x17, 0xff, 0x00, 0x00, 0x01, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x21, 0xfc, 0x21, 0x04, 0x41, 0x04, 0x41, 0xfc, 0x00, 0x00 },
{ 0xdc, 0xca, 0x00, 0x40, 0x7c, 0x40, 0x10, 0x7e, 0x10, 0x90, 0x10, 0x90, 0x11, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x92, 0x1c, 0x92, 0x70, 0x92, 0x00, 0x92, 0x00, 0xfe, 0x00, 0x00 },
{ 0xdc, 0xcb, 0x00, 0x88, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x00 },
{ 0xdc, 0xcc, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xdc, 0xcd, 0x10, 0x14, 0x10, 0x12, 0x10, 0xff, 0x7c, 0x10, 0x04, 0x10, 0x08, 0xff, 0x08, 0x91, 0x12, 0xff, 0x3c, 0x91, 0x54, 0x91, 0x12, 0xff, 0x10, 0x91, 0x10, 0x91, 0x10, 0x91, 0x10, 0x97, 0x00, 0x00 },
{ 0xdc, 0xce, 0x10, 0x40, 0x10, 0x5e, 0x10, 0x52, 0x7c, 0x92, 0x04, 0x92, 0x09, 0x9e, 0x09, 0x88, 0x12, 0x88, 0x34, 0xbf, 0x58, 0x88, 0x14, 0x9c, 0x10, 0xaa, 0x10, 0xc9, 0x10, 0x88, 0x10, 0x88, 0x00, 0x00 },
{ 0xdc, 0xcf, 0x00, 0x42, 0x3c, 0x24, 0x00, 0xff, 0x7e, 0x24, 0x00, 0xa5, 0x3c, 0x66, 0x00, 0xff, 0x3c, 0x00, 0x00, 0x7e, 0x00, 0x42, 0x3c, 0x42, 0x24, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x3c, 0x7e, 0x00, 0x00 },
{ 0xdc, 0xd0, 0x10, 0x14, 0x10, 0x12, 0x7e, 0xff, 0x10, 0x10, 0x10, 0x10, 0x7e, 0xff, 0x52, 0x91, 0x7e, 0xff, 0x52, 0x91, 0x7e, 0x91, 0x10, 0xff, 0x7e, 0x91, 0x10, 0x91, 0x10, 0x91, 0x10, 0x97, 0x00, 0x00 },
{ 0xdc, 0xd1, 0x08, 0x20, 0x08, 0x24, 0x08, 0x22, 0x10, 0x20, 0x17, 0xff, 0x30, 0x20, 0x30, 0x20, 0x50, 0x50, 0x10, 0x50, 0x10, 0x50, 0x10, 0x88, 0x10, 0x88, 0x11, 0x04, 0x12, 0x02, 0x14, 0x01, 0x00, 0x00 },
{ 0xdc, 0xd2, 0x08, 0x50, 0x0a, 0x52, 0x11, 0x54, 0x17, 0xff, 0x30, 0x88, 0x30, 0x50, 0x53, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x17, 0xff, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x16, 0x03, 0x00, 0x00 },
{ 0xdc, 0xd3, 0x08, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x2f, 0xe2, 0x40, 0x02, 0x0f, 0xc2, 0x08, 0x42, 0x0f, 0xc2, 0x00, 0x02, 0x1f, 0xe2, 0x12, 0x22, 0x1f, 0xe2, 0x12, 0x22, 0x1f, 0xe2, 0x00, 0x0c, 0x00, 0x00 },
{ 0xdc, 0xd4, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0x80, 0x02, 0x60, 0x02, 0x10, 0x02, 0x08, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00 },
{ 0xdc, 0xd5, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x41, 0x01, 0x04, 0x88, 0x24, 0x44, 0x24, 0x42, 0x24, 0x0a, 0x44, 0x08, 0x44, 0x08, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00 },
{ 0xdc, 0xd6, 0x08, 0x80, 0x09, 0xff, 0x11, 0x00, 0x22, 0xfe, 0x48, 0x82, 0x08, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x30, 0x20, 0x50, 0x7e, 0x10, 0xc2, 0x13, 0x24, 0x10, 0x18, 0x10, 0x6c, 0x13, 0x83, 0x00, 0x00 },
{ 0xdc, 0xd7, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x24, 0x8e, 0x3c, 0x80, 0x24, 0x80, 0x24, 0xfe, 0x24, 0xa2, 0x3c, 0xa2, 0x24, 0x94, 0x24, 0x94, 0x25, 0x08, 0x45, 0x14, 0x4d, 0x63, 0x00, 0x00 },
{ 0xdc, 0xd8, 0x00, 0x00, 0x3e, 0xff, 0x00, 0x00, 0x00, 0x7e, 0x7f, 0x42, 0x08, 0x42, 0x08, 0x7e, 0x2a, 0x00, 0x2a, 0xff, 0x2a, 0x91, 0x2a, 0x91, 0x4a, 0xff, 0x48, 0x91, 0x08, 0x91, 0x08, 0xff, 0x00, 0x00 },
{ 0xdc, 0xd9, 0x00, 0x40, 0x3c, 0xff, 0x25, 0x00, 0x24, 0xfe, 0x24, 0x82, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x20, 0x3c, 0x7e, 0x24, 0xc2, 0x25, 0x24, 0x24, 0x18, 0x44, 0x64, 0x4d, 0x83, 0x00, 0x00 },
{ 0xdc, 0xda, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x08, 0x24, 0x08, 0x22, 0x10, 0x20, 0x13, 0xff, 0x30, 0x20, 0x50, 0x50, 0x10, 0x50, 0x10, 0x88, 0x10, 0x88, 0x11, 0x04, 0x16, 0x03, 0x00, 0x00 },
{ 0xdc, 0xdb, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x10, 0x00, 0x1f, 0xfe, 0x20, 0x02, 0x3f, 0xf2, 0x44, 0x42, 0x1f, 0xf2, 0x11, 0x12, 0x1f, 0xf2, 0x11, 0x12, 0x1f, 0xf4, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00 },
{ 0xdc, 0xdc, 0x10, 0x80, 0x11, 0xff, 0x11, 0x00, 0x7e, 0xfe, 0x04, 0x82, 0x08, 0xfe, 0x08, 0x82, 0x10, 0xfe, 0x34, 0x20, 0x58, 0x7e, 0x14, 0xc2, 0x13, 0x24, 0x10, 0x18, 0x10, 0x64, 0x13, 0x83, 0x00, 0x00 },
{ 0xdc, 0xdd, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x10, 0x80, 0x21, 0xff, 0x4a, 0x84, 0x10, 0xfc, 0x30, 0x84, 0x51, 0xfc, 0x12, 0x88, 0x10, 0x70, 0x13, 0x8f, 0x00, 0x00 },
{ 0xdc, 0xde, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x7f, 0x08, 0x40, 0x3e, 0xbe, 0x2a, 0x22, 0x3e, 0x3e, 0x2a, 0x22, 0x3e, 0x3e, 0x08, 0x10, 0x08, 0x3e, 0x7e, 0x62, 0x08, 0x94, 0x08, 0x18, 0x08, 0xe7, 0x00, 0x00 },
{ 0xdc, 0xdf, 0x08, 0x00, 0x08, 0x7f, 0x7f, 0x00, 0x08, 0x3e, 0x3e, 0x22, 0x2a, 0x22, 0x3e, 0x3e, 0x2a, 0x00, 0x3e, 0x7f, 0x08, 0x49, 0x08, 0x49, 0x7f, 0x7f, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x00, 0x00 },
{ 0xdc, 0xe0, 0x06, 0x20, 0x38, 0x7f, 0x08, 0x80, 0x7e, 0x7e, 0x08, 0x42, 0x1c, 0x7e, 0x2a, 0x42, 0x48, 0x7e, 0x3e, 0x20, 0x22, 0x3e, 0x22, 0x42, 0x3e, 0xa4, 0x22, 0x18, 0x22, 0x24, 0x3e, 0xc3, 0x00, 0x00 },
{ 0xdc, 0xe1, 0x10, 0x40, 0x1c, 0x7f, 0x24, 0x80, 0x29, 0x7e, 0x7e, 0x42, 0x2a, 0x7e, 0x2a, 0x42, 0x3e, 0x7e, 0x2a, 0x10, 0x2a, 0x20, 0x3e, 0x7e, 0x00, 0xa2, 0x2a, 0x14, 0x2a, 0x1c, 0x40, 0xe3, 0x00, 0x00 },
{ 0xdc, 0xe2, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0xc0, 0x02, 0xa0, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x67, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdc, 0xe3, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x3f, 0xec, 0x01, 0x80, 0x06, 0x04, 0x18, 0x04, 0x20, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdc, 0xe4, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x30, 0x50, 0x30, 0x88, 0x57, 0xff, 0x51, 0x04, 0x12, 0x22, 0x15, 0xfd, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xdc, 0xe5, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x00, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x88, 0x17, 0xf4, 0x60, 0x83, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdc, 0xe6, 0x08, 0x04, 0x08, 0x04, 0x3e, 0x04, 0x08, 0xff, 0x08, 0x04, 0x08, 0x04, 0x7f, 0x04, 0x00, 0x44, 0x08, 0x24, 0x08, 0x14, 0x3e, 0x04, 0x08, 0x04, 0x08, 0x04, 0x0f, 0x04, 0x78, 0x1c, 0x00, 0x00 },
{ 0xdc, 0xe7, 0x00, 0x80, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x00, 0x07, 0xe0, 0x3a, 0x20, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x87, 0x0f, 0xf8, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x00 },
{ 0xdc, 0xe8, 0x10, 0x20, 0x10, 0x3c, 0x10, 0x44, 0x54, 0xc8, 0x55, 0x30, 0x54, 0x6c, 0x55, 0x83, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x7d, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xdc, 0xe9, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x78, 0x20, 0x11, 0xfc, 0x10, 0x50, 0x10, 0x88, 0x1f, 0xff, 0x71, 0x04, 0x12, 0x22, 0x14, 0xf9, 0x10, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xdc, 0xea, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x7c, 0x20, 0x11, 0xfc, 0x10, 0x50, 0x3b, 0xff, 0x34, 0x88, 0x31, 0x24, 0x56, 0xfb, 0x50, 0x20, 0x51, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xdc, 0xeb, 0x10, 0x20, 0x10, 0x7c, 0x12, 0x88, 0x55, 0x50, 0x58, 0x20, 0x50, 0x50, 0x50, 0x8c, 0x13, 0x23, 0x10, 0xfc, 0x10, 0x20, 0x28, 0xfc, 0x24, 0x20, 0x21, 0xfe, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xdc, 0xec, 0x12, 0x10, 0x11, 0x1e, 0x10, 0x22, 0x14, 0x14, 0x5a, 0x0c, 0x51, 0x73, 0x50, 0x08, 0x10, 0x3e, 0x13, 0x88, 0x10, 0xbe, 0x28, 0x88, 0x24, 0xff, 0x24, 0x88, 0x41, 0x40, 0x02, 0x3f, 0x00, 0x00 },
{ 0xdc, 0xed, 0x00, 0x20, 0x7c, 0x7c, 0x10, 0xc4, 0x11, 0x48, 0x10, 0x30, 0x10, 0x30, 0x7c, 0xcc, 0x13, 0x13, 0x10, 0xfc, 0x10, 0x10, 0x10, 0xfe, 0x1c, 0x10, 0x71, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xdc, 0xee, 0x11, 0x10, 0x10, 0x9e, 0x24, 0x22, 0x44, 0x54, 0x29, 0x0c, 0x10, 0xb3, 0x10, 0x08, 0x25, 0xbe, 0x7c, 0x88, 0x10, 0xbe, 0x54, 0x88, 0x54, 0xff, 0x50, 0x88, 0x11, 0x60, 0x12, 0x1f, 0x00, 0x00 },
{ 0xdc, 0xef, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x20, 0x40, 0x10, 0xf8, 0x43, 0x88, 0x20, 0x70, 0x01, 0x98, 0x06, 0x26, 0x71, 0xfc, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xdc, 0xf0, 0x10, 0x20, 0x10, 0x20, 0x10, 0x7c, 0x7c, 0xc4, 0x55, 0x28, 0x54, 0x10, 0x54, 0x6c, 0x55, 0x93, 0x54, 0xfe, 0x7c, 0x10, 0x10, 0xfe, 0x14, 0x10, 0x15, 0xff, 0x1a, 0x10, 0x62, 0x10, 0x00, 0x00 },
{ 0xdc, 0xf1, 0x20, 0x80, 0x10, 0xf8, 0x09, 0x88, 0x42, 0x50, 0x20, 0x70, 0x11, 0x8c, 0x06, 0x23, 0x01, 0xfc, 0x70, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xdc, 0xf2, 0x08, 0x20, 0x14, 0x7c, 0x22, 0x44, 0x40, 0xa8, 0x3e, 0x10, 0x08, 0x2c, 0x08, 0xc3, 0x7e, 0x10, 0x08, 0xfe, 0x4a, 0x10, 0x2a, 0xfe, 0x28, 0x10, 0x09, 0xff, 0x0e, 0x10, 0x70, 0x10, 0x00, 0x00 },
{ 0xdc, 0xf3, 0x3f, 0xf8, 0x20, 0x08, 0x2f, 0xe8, 0x22, 0x08, 0x2f, 0xc8, 0x28, 0x48, 0x2f, 0xc8, 0x28, 0x48, 0x2f, 0xe8, 0x28, 0x08, 0x2f, 0xf4, 0x40, 0x15, 0x55, 0x55, 0x55, 0x13, 0x40, 0x61, 0x00, 0x00 },
{ 0xdc, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x80, 0x01, 0xa0, 0x02, 0x90, 0x04, 0x88, 0x08, 0x84, 0x30, 0x82, 0x40, 0x82, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
{ 0xdc, 0xf5, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x13, 0xff, 0x10, 0x04, 0x30, 0x04, 0x30, 0x04, 0x51, 0x04, 0x10, 0x84, 0x10, 0x44, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xdc, 0xf6, 0x08, 0x10, 0x08, 0x10, 0x0b, 0xff, 0x12, 0x00, 0x12, 0x24, 0x32, 0x24, 0x32, 0x44, 0x52, 0x5f, 0x52, 0xc4, 0x13, 0x44, 0x12, 0x54, 0x12, 0x4c, 0x12, 0x44, 0x14, 0x44, 0x14, 0x4c, 0x00, 0x00 },
{ 0xdc, 0xf7, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x20, 0x11, 0xfe, 0x31, 0x22, 0x31, 0xfe, 0x51, 0x22, 0x51, 0xfe, 0x11, 0x22, 0x11, 0x2a, 0x10, 0x08, 0x13, 0xff, 0x10, 0x08, 0x11, 0x08, 0x10, 0x98, 0x00, 0x00 },
{ 0xdc, 0xf8, 0x04, 0x01, 0x04, 0x09, 0x7f, 0xc9, 0x20, 0x89, 0x10, 0x89, 0x11, 0x09, 0x7f, 0xc9, 0x00, 0x09, 0x00, 0x09, 0x3f, 0x89, 0x20, 0x89, 0x20, 0x81, 0x20, 0x81, 0x20, 0x81, 0x3f, 0x87, 0x00, 0x00 },
{ 0xdc, 0xf9, 0x00, 0x01, 0x7f, 0xc1, 0x00, 0x09, 0x3f, 0x89, 0x20, 0x89, 0x20, 0x89, 0x3f, 0x89, 0x00, 0x09, 0x7f, 0xc9, 0x44, 0x49, 0x44, 0x49, 0x7f, 0xc1, 0x44, 0x41, 0x44, 0x41, 0x7f, 0xc7, 0x00, 0x00 },
{ 0xdc, 0xfa, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x80, 0x01, 0xb0, 0x06, 0x8c, 0x18, 0x82, 0x60, 0x81, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdc, 0xfb, 0x00, 0x44, 0x00, 0x44, 0x78, 0x84, 0x48, 0x84, 0x49, 0xbf, 0x49, 0x84, 0x4a, 0x84, 0x4a, 0xa4, 0x48, 0x94, 0x48, 0x94, 0x78, 0x84, 0x00, 0x84, 0x00, 0x84, 0x00, 0x84, 0x00, 0x9c, 0x00, 0x00 },
{ 0xdc, 0xfc, 0x10, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x80, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x1c, 0x10, 0x71, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xdc, 0xfd, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xdc, 0xfe, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x02, 0x7d, 0xff, 0x24, 0x02, 0x24, 0xfe, 0x24, 0x00, 0x25, 0xff, 0x45, 0x11, 0x68, 0xfe, 0x58, 0x92, 0x08, 0x92, 0x14, 0x96, 0x22, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xdd, 0xa1, 0x00, 0x3c, 0x1f, 0xc0, 0x11, 0x04, 0x20, 0x82, 0x20, 0x81, 0x40, 0x01, 0x0f, 0xf0, 0x00, 0x20, 0x00, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xdd, 0xa2, 0x18, 0x06, 0x63, 0xd8, 0x42, 0x52, 0x4a, 0x55, 0x4a, 0x65, 0x5b, 0x40, 0x6a, 0xc0, 0x4a, 0x7e, 0x4a, 0x44, 0x5a, 0x48, 0x6a, 0x7f, 0x12, 0xc8, 0x12, 0x08, 0x22, 0x08, 0x42, 0x18, 0x00, 0x00 },
{ 0xdd, 0xa3, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdd, 0xa4, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x21, 0x04, 0x21, 0x04, 0x22, 0x04, 0x22, 0xff, 0x26, 0x04, 0x26, 0x44, 0x2a, 0x24, 0x22, 0x24, 0x42, 0x04, 0x42, 0x04, 0x42, 0x1c, 0x00, 0x00 },
{ 0xdd, 0xa5, 0x10, 0x80, 0x10, 0xff, 0x21, 0x00, 0x4a, 0xfe, 0x08, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x30, 0xfe, 0x50, 0x20, 0x10, 0x7e, 0x10, 0xc4, 0x13, 0x28, 0x10, 0x10, 0x10, 0x6c, 0x13, 0x83, 0x00, 0x00 },
{ 0xdd, 0xa6, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x28, 0x10, 0x28, 0x10, 0x28, 0x10, 0x44, 0x10, 0x44, 0x10, 0x82, 0x31, 0x01, 0x00, 0x00 },
{ 0xdd, 0xa7, 0x0a, 0x10, 0x7f, 0x90, 0x08, 0x10, 0x3f, 0x3f, 0x29, 0x22, 0x3f, 0x62, 0x29, 0xa2, 0x3f, 0x12, 0x08, 0x14, 0x7f, 0x94, 0x10, 0x08, 0x1f, 0x0c, 0x11, 0x14, 0x21, 0x22, 0x46, 0x41, 0x00, 0x00 },
{ 0xdd, 0xa8, 0x04, 0x10, 0x18, 0x0c, 0x63, 0x33, 0x00, 0xc0, 0x07, 0x38, 0x78, 0x07, 0x00, 0x70, 0x1f, 0x80, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x40, 0x20, 0x40, 0x20, 0x40, 0x40, 0x40, 0x00, 0x00 },
{ 0xdd, 0xa9, 0x20, 0x00, 0x10, 0x8e, 0x08, 0xf4, 0x01, 0x22, 0x41, 0x21, 0x22, 0x00, 0x10, 0xfe, 0x00, 0x04, 0x00, 0x18, 0x10, 0x10, 0x13, 0xff, 0x20, 0x10, 0x20, 0x10, 0x40, 0x10, 0x40, 0x60, 0x00, 0x00 },
{ 0xdd, 0xaa, 0x20, 0x50, 0x10, 0x48, 0x07, 0xff, 0x00, 0x40, 0x43, 0xfc, 0x22, 0x44, 0x13, 0xfc, 0x02, 0x44, 0x03, 0xfc, 0x12, 0x44, 0x10, 0x08, 0x27, 0xff, 0x21, 0x08, 0x40, 0x88, 0x40, 0x38, 0x00, 0x00 },
{ 0xdd, 0xab, 0x00, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x60, 0x03, 0x04, 0x10, 0x0c, 0x10, 0x12, 0x20, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xdd, 0xac, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x00, 0x08, 0x04, 0x10, 0x04, 0x13, 0xff, 0x30, 0x04, 0x30, 0x04, 0x50, 0x84, 0x10, 0x44, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xdd, 0xad, 0x10, 0x40, 0x1f, 0x7e, 0x24, 0x88, 0x43, 0xff, 0x10, 0x20, 0x09, 0xfe, 0x41, 0x22, 0x21, 0xfe, 0x01, 0x22, 0x09, 0xfe, 0x08, 0x04, 0x13, 0xff, 0x10, 0x84, 0x20, 0x44, 0x40, 0x1c, 0x00, 0x00 },
{ 0xdd, 0xae, 0x08, 0x00, 0x08, 0x00, 0x10, 0x00, 0x1f, 0xfc, 0x21, 0x00, 0x41, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x21, 0x04, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xdd, 0xaf, 0x00, 0x40, 0x3f, 0xff, 0x21, 0x04, 0x22, 0xff, 0x26, 0x44, 0x2a, 0x24, 0x22, 0x0c, 0x20, 0x40, 0x2f, 0xfe, 0x28, 0xc2, 0x2b, 0x32, 0x28, 0xca, 0x4b, 0x32, 0x48, 0x0a, 0x48, 0x06, 0x00, 0x00 },
{ 0xdd, 0xb0, 0x00, 0x08, 0x3c, 0x08, 0x24, 0xff, 0x24, 0x80, 0x24, 0x92, 0x3c, 0x92, 0x24, 0xa2, 0x24, 0xaf, 0x24, 0xe2, 0x3c, 0xaa, 0x24, 0xa6, 0x24, 0xa2, 0x24, 0xa2, 0x45, 0x22, 0x4d, 0x2e, 0x00, 0x00 },
{ 0xdd, 0xb1, 0x00, 0xfc, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x81, 0x2f, 0xfa, 0x20, 0x82, 0x2f, 0xfe, 0x28, 0x42, 0x2f, 0xfe, 0x24, 0x04, 0x27, 0xfc, 0x24, 0x04, 0x47, 0xfc, 0x44, 0x04, 0x44, 0x1c, 0x00, 0x00 },
{ 0xdd, 0xb2, 0x08, 0x00, 0x10, 0x06, 0x3e, 0x78, 0x22, 0x92, 0x2a, 0x89, 0x2b, 0x01, 0x22, 0x7e, 0x27, 0x02, 0x7a, 0x0c, 0x2a, 0x08, 0x2a, 0xff, 0x2a, 0x08, 0x22, 0x08, 0x42, 0x08, 0x46, 0x38, 0x00, 0x00 },
{ 0xdd, 0xb3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xdd, 0xb4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x3c, 0x0f, 0xd0, 0x09, 0x08, 0x10, 0x84, 0x2f, 0xf8, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x7f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00 },
{ 0xdd, 0xb5, 0x00, 0x20, 0x3e, 0x20, 0x00, 0x20, 0x7f, 0x20, 0x00, 0x20, 0x3e, 0x38, 0x00, 0x24, 0x3e, 0x22, 0x00, 0x21, 0x00, 0x20, 0x3e, 0x20, 0x22, 0x20, 0x22, 0x20, 0x22, 0x20, 0x3e, 0x20, 0x00, 0x00 },
{ 0xdd, 0xb6, 0x04, 0x00, 0x07, 0xe0, 0x08, 0x20, 0x10, 0x40, 0x7f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x10, 0x78, 0x0f, 0x00, 0x00 },
{ 0xdd, 0xb7, 0x00, 0x08, 0x3c, 0x0a, 0x25, 0xe9, 0x24, 0x08, 0x24, 0x08, 0x3d, 0xff, 0x24, 0x48, 0x24, 0x48, 0x3c, 0x48, 0x25, 0x74, 0x25, 0x44, 0x25, 0x45, 0x3d, 0x75, 0x2b, 0x83, 0x44, 0x01, 0x00, 0x00 },
{ 0xdd, 0xb8, 0x00, 0x14, 0x3c, 0x12, 0x25, 0xff, 0x24, 0x10, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0xfe, 0x3c, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x24, 0x04, 0x3d, 0xff, 0x00, 0x44, 0x24, 0x24, 0x42, 0x0c, 0x00, 0x00 },
{ 0xdd, 0xb9, 0x08, 0x20, 0x08, 0x20, 0x3e, 0x20, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x20, 0x08, 0x38, 0x08, 0x24, 0x28, 0x22, 0x2f, 0x20, 0x28, 0x20, 0x38, 0x20, 0x28, 0x20, 0x46, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xdd, 0xba, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0xfe, 0x22, 0x10, 0x3e, 0x10, 0x08, 0x10, 0x09, 0xff, 0x28, 0x10, 0x2e, 0x28, 0x28, 0x28, 0x28, 0x44, 0x28, 0x44, 0x2e, 0x82, 0x71, 0x01, 0x00, 0x00 },
{ 0xdd, 0xbb, 0x08, 0x00, 0x08, 0x3f, 0x7f, 0xa1, 0x21, 0x22, 0x11, 0x22, 0x12, 0x24, 0x7f, 0xa2, 0x00, 0x22, 0x00, 0x21, 0x3f, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x2e, 0x21, 0x20, 0x3f, 0x20, 0x00, 0x00 },
{ 0xdd, 0xbc, 0x02, 0x20, 0x0c, 0x18, 0x72, 0x27, 0x01, 0x40, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x07, 0xf0, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdd, 0xbd, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdd, 0xbe, 0x00, 0x44, 0x7c, 0x44, 0x44, 0x84, 0x48, 0x84, 0x49, 0xbf, 0x51, 0x84, 0x4a, 0x84, 0x48, 0x84, 0x44, 0xa4, 0x44, 0x94, 0x44, 0x84, 0x58, 0x84, 0x40, 0x84, 0x40, 0x84, 0x40, 0x9c, 0x00, 0x00 },
{ 0xdd, 0xbf, 0x00, 0x24, 0x3e, 0x24, 0x28, 0x44, 0x3e, 0x44, 0x28, 0xbf, 0x3f, 0x84, 0x28, 0x84, 0x28, 0xa4, 0x3e, 0x94, 0x02, 0x94, 0x56, 0x84, 0x56, 0x84, 0x42, 0x84, 0x02, 0x84, 0x0c, 0x98, 0x00, 0x00 },
{ 0xdd, 0xc0, 0x02, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xfe, 0x10, 0x00, 0x1f, 0xfe, 0x29, 0x22, 0x44, 0x92, 0x07, 0xec, 0x04, 0x20, 0x04, 0x21, 0x08, 0x21, 0x70, 0x1f, 0x00, 0x00 },
{ 0xdd, 0xc1, 0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x04, 0x42, 0x7c, 0x4c, 0x04, 0x70, 0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x1c, 0x40, 0x64, 0x41, 0x04, 0x41, 0x04, 0x7f, 0x04, 0x00, 0x00, 0x00 },
{ 0xdd, 0xc2, 0x01, 0xe0, 0x04, 0x20, 0x04, 0x10, 0x08, 0x10, 0x08, 0x08, 0x10, 0x04, 0x20, 0x02, 0x4f, 0xf9, 0x01, 0x08, 0x01, 0x08, 0x02, 0x08, 0x02, 0x08, 0x04, 0x08, 0x08, 0x08, 0x30, 0x70, 0x00, 0x00 },
{ 0xdd, 0xc3, 0x00, 0x38, 0x00, 0x08, 0x78, 0x48, 0x48, 0x84, 0x48, 0x84, 0x49, 0x02, 0x4a, 0x01, 0x49, 0xfc, 0x48, 0x44, 0x48, 0x44, 0x78, 0x44, 0x00, 0x84, 0x00, 0x84, 0x01, 0x04, 0x06, 0x38, 0x00, 0x00 },
{ 0xdd, 0xc4, 0x00, 0x20, 0x03, 0xff, 0x78, 0x20, 0x48, 0xa4, 0x4b, 0xff, 0x48, 0x84, 0x49, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x79, 0x02, 0x01, 0xfe, 0x00, 0x84, 0x03, 0x03, 0x00, 0x00 },
{ 0xdd, 0xc5, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x10, 0xa4, 0x7b, 0xff, 0x10, 0x84, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x1d, 0xfe, 0x71, 0x02, 0x01, 0xfe, 0x00, 0x84, 0x03, 0x03, 0x00, 0x00 },
{ 0xdd, 0xc6, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x88, 0x18, 0x84, 0x67, 0xf3, 0x00, 0x80, 0x04, 0x90, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xdd, 0xc7, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x1a, 0x4c, 0x67, 0xfb, 0x08, 0x80, 0x1f, 0xf8, 0x68, 0x80, 0x0f, 0xf8, 0x08, 0x80, 0x1f, 0xfe, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdd, 0xc8, 0x01, 0xe0, 0x04, 0x20, 0x04, 0x10, 0x08, 0x08, 0x17, 0xfc, 0x61, 0x0b, 0x02, 0x08, 0x04, 0x08, 0x18, 0x70, 0x00, 0x00, 0x04, 0x80, 0x04, 0x40, 0x24, 0x12, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xdd, 0xc9, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x58, 0xa4, 0x57, 0xff, 0x54, 0x84, 0x51, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x84, 0x13, 0x03, 0x00, 0x00 },
{ 0xdd, 0xca, 0x10, 0x38, 0x10, 0x88, 0x10, 0x88, 0x7c, 0x84, 0x11, 0x04, 0x11, 0x02, 0x12, 0x02, 0x1d, 0xfd, 0x70, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x84, 0x10, 0x84, 0x11, 0x04, 0x32, 0x18, 0x00, 0x00 },
{ 0xdd, 0xcb, 0x00, 0x38, 0x78, 0x88, 0x48, 0x88, 0x48, 0x84, 0x49, 0x04, 0x79, 0x02, 0x4a, 0x01, 0x49, 0xfc, 0x48, 0x44, 0x48, 0x44, 0x78, 0x44, 0x00, 0x84, 0x00, 0x84, 0x01, 0x04, 0x02, 0x18, 0x00, 0x00 },
{ 0xdd, 0xcc, 0x20, 0x38, 0x10, 0x88, 0x08, 0x88, 0x01, 0x04, 0x41, 0x04, 0x22, 0x02, 0x14, 0x01, 0x03, 0xfc, 0x00, 0x84, 0x10, 0x84, 0x10, 0x84, 0x21, 0x04, 0x21, 0x04, 0x42, 0x04, 0x44, 0x38, 0x00, 0x00 },
{ 0xdd, 0xcd, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x18, 0x1c, 0x2c, 0x2a, 0x4a, 0x49, 0x08, 0x08, 0x00, 0x80, 0x08, 0x82, 0x10, 0x84, 0x21, 0x48, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xdd, 0xce, 0x01, 0xf0, 0x04, 0x10, 0x04, 0x10, 0x08, 0x08, 0x17, 0xfc, 0x61, 0x0b, 0x01, 0x08, 0x06, 0x08, 0x18, 0x70, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdd, 0xcf, 0x08, 0x1c, 0x08, 0x44, 0x4a, 0x44, 0x2c, 0x44, 0x08, 0x82, 0x7e, 0x82, 0x09, 0x01, 0x18, 0xfc, 0x1c, 0x24, 0x2a, 0x24, 0x28, 0x24, 0x48, 0x44, 0x48, 0x44, 0x08, 0x84, 0x09, 0x18, 0x00, 0x00 },
{ 0xdd, 0xd0, 0x04, 0x90, 0x7f, 0xff, 0x04, 0x90, 0x18, 0x0c, 0x6f, 0xfb, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xdd, 0xd1, 0x10, 0x38, 0x10, 0x88, 0x24, 0x88, 0x45, 0x04, 0x29, 0x04, 0x12, 0x02, 0x10, 0x01, 0x25, 0xfc, 0x7c, 0x44, 0x10, 0x44, 0x54, 0x44, 0x54, 0x84, 0x50, 0x84, 0x11, 0x04, 0x12, 0x18, 0x00, 0x00 },
{ 0xdd, 0xd2, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x01, 0xe0, 0x04, 0x20, 0x04, 0x10, 0x08, 0x08, 0x17, 0xf4, 0x61, 0x13, 0x01, 0x10, 0x02, 0x10, 0x04, 0x10, 0x18, 0xe0, 0x00, 0x00 },
{ 0xdd, 0xd3, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x90, 0x04, 0x90, 0x7f, 0xff, 0x04, 0x10, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xdd, 0xd4, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x00, 0x00, 0x04, 0xf0, 0x18, 0x0c, 0x67, 0xfb, 0x01, 0x08, 0x01, 0x08, 0x06, 0x08, 0x18, 0x70, 0x00, 0x00 },
{ 0xdd, 0xd5, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x00, 0x80, 0x01, 0x80, 0x02, 0xa0, 0x04, 0x98, 0x08, 0x84, 0x10, 0x82, 0x60, 0x81, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdd, 0xd6, 0x08, 0x90, 0x08, 0x90, 0x13, 0xfe, 0x10, 0x92, 0x30, 0x92, 0x33, 0xfe, 0x52, 0x90, 0x54, 0x90, 0x17, 0xff, 0x14, 0x91, 0x10, 0x91, 0x11, 0x11, 0x11, 0x16, 0x12, 0x10, 0x14, 0x10, 0x00, 0x00 },
{ 0xdd, 0xd7, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xfe, 0x02, 0x22, 0x02, 0x22, 0x3f, 0xfe, 0x22, 0x20, 0x22, 0x20, 0x7f, 0xff, 0x42, 0x21, 0x04, 0x21, 0x04, 0x21, 0x08, 0x2e, 0x10, 0x20, 0x60, 0x20, 0x00, 0x00 },
{ 0xdd, 0xd8, 0x08, 0x90, 0x08, 0x90, 0x10, 0x90, 0x23, 0xfe, 0x48, 0x92, 0x08, 0x92, 0x13, 0xfe, 0x12, 0x90, 0x32, 0x90, 0x57, 0xff, 0x14, 0x91, 0x10, 0x91, 0x11, 0x16, 0x11, 0x10, 0x12, 0x10, 0x00, 0x00 },
{ 0xdd, 0xd9, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x7d, 0xfe, 0x10, 0x4a, 0x10, 0x4a, 0x11, 0xfe, 0x1d, 0x48, 0x71, 0x48, 0x13, 0xff, 0x12, 0x49, 0x10, 0x49, 0x10, 0x8e, 0x10, 0x88, 0x31, 0x08, 0x00, 0x00 },
{ 0xdd, 0xda, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x3e, 0x22, 0x42, 0x22, 0x42, 0x46, 0x86, 0x00, 0x00 },
{ 0xdd, 0xdb, 0x00, 0x00, 0x1f, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x21, 0x21, 0x21, 0x21, 0x47, 0x47, 0x00, 0x00 },
{ 0xdd, 0xdc, 0x10, 0x00, 0x11, 0xef, 0x11, 0x29, 0x7d, 0x29, 0x11, 0x29, 0x11, 0xef, 0x39, 0x29, 0x39, 0x29, 0x35, 0x29, 0x55, 0xef, 0x51, 0x29, 0x51, 0x29, 0x11, 0x29, 0x12, 0x29, 0x12, 0x73, 0x00, 0x00 },
{ 0xdd, 0xdd, 0x00, 0x00, 0x7d, 0xef, 0x11, 0x29, 0x11, 0x29, 0x11, 0x29, 0x21, 0xef, 0x3d, 0x29, 0x25, 0x29, 0x65, 0x29, 0x25, 0xef, 0x25, 0x29, 0x25, 0x29, 0x3d, 0x29, 0x02, 0x29, 0x02, 0x73, 0x00, 0x00 },
{ 0xdd, 0xde, 0x10, 0x10, 0x11, 0x11, 0x25, 0x11, 0x45, 0xff, 0x28, 0x00, 0x11, 0xef, 0x11, 0x29, 0x25, 0x29, 0x7d, 0xef, 0x15, 0x29, 0x51, 0x29, 0x55, 0xef, 0x55, 0x29, 0x12, 0x29, 0x12, 0x73, 0x00, 0x00 },
{ 0xdd, 0xdf, 0x00, 0x08, 0x3b, 0xbe, 0x2a, 0xa2, 0x2a, 0xbe, 0x2a, 0xa2, 0x3b, 0xbe, 0x2a, 0xa0, 0x2a, 0xbf, 0x2a, 0xa0, 0x3b, 0xbf, 0x2a, 0x81, 0x2a, 0xa9, 0x2a, 0xa9, 0x4a, 0x81, 0x5d, 0x8e, 0x00, 0x00 },
{ 0xdd, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x01, 0x80, 0x02, 0x98, 0x04, 0x84, 0x18, 0x82, 0x60, 0x81, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xdd, 0xe1, 0x08, 0x84, 0x08, 0x84, 0x0b, 0xff, 0x10, 0x84, 0x10, 0x84, 0x33, 0xff, 0x32, 0x00, 0x52, 0xfe, 0x52, 0x92, 0x12, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x14, 0x92, 0x14, 0x92, 0x14, 0x96, 0x00, 0x00 },
{ 0xdd, 0xe2, 0x08, 0x00, 0x08, 0x00, 0x08, 0x04, 0x08, 0x08, 0x08, 0x30, 0x08, 0xc0, 0x0f, 0x00, 0x78, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x07, 0xff, 0x00, 0x00 },
{ 0xdd, 0xe3, 0x7f, 0xfe, 0x40, 0x00, 0x41, 0x20, 0x41, 0x20, 0x4f, 0x3c, 0x41, 0x20, 0x41, 0x20, 0x4f, 0x3c, 0x41, 0x20, 0x47, 0x20, 0x59, 0x3e, 0x42, 0x20, 0x4c, 0x20, 0x40, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdd, 0xe4, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x04, 0x20, 0x08, 0x20, 0x7f, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xdd, 0xe5, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x02, 0x7c, 0x02, 0x24, 0x02, 0x24, 0x02, 0x24, 0x02, 0x24, 0xfe, 0x44, 0x80, 0x68, 0x80, 0x58, 0x80, 0x08, 0x80, 0x14, 0x81, 0x22, 0x81, 0x40, 0x7f, 0x00, 0x00 },
{ 0xdd, 0xe6, 0x10, 0x20, 0x10, 0x40, 0x11, 0xfe, 0x7d, 0x22, 0x25, 0x22, 0x25, 0xfe, 0x25, 0x22, 0x25, 0x22, 0x45, 0xfe, 0x68, 0x48, 0x58, 0x88, 0x0b, 0xff, 0x14, 0x08, 0x22, 0x08, 0x40, 0x08, 0x00, 0x00 },
{ 0xdd, 0xe7, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x24, 0x20, 0x24, 0x22, 0x24, 0x24, 0x27, 0xb8, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x44, 0x22, 0x47, 0xa2, 0x5c, 0x1e, 0x00, 0x00 },
{ 0xdd, 0xe8, 0x02, 0x20, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x0e, 0x20, 0x72, 0x3f, 0x04, 0x20, 0x18, 0xa0, 0x00, 0x40, 0x24, 0x12, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xdd, 0xe9, 0x08, 0x88, 0x0b, 0xfe, 0x10, 0x88, 0x17, 0xff, 0x32, 0x92, 0x52, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x14, 0x92, 0x14, 0x96, 0x00, 0x00, 0x24, 0x80, 0x24, 0x4a, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xdd, 0xea, 0x00, 0x1f, 0x3f, 0xe0, 0x20, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x90, 0x2f, 0x9f, 0x20, 0x90, 0x27, 0x9e, 0x20, 0x90, 0x23, 0x9f, 0x4c, 0x90, 0x41, 0x10, 0x46, 0x10, 0x00, 0x00 },
{ 0xdd, 0xeb, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x7d, 0x10, 0x11, 0x11, 0x11, 0x12, 0x11, 0xdc, 0x1d, 0x10, 0x71, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x11, 0x11, 0xd1, 0x37, 0x0f, 0x00, 0x00 },
{ 0xdd, 0xec, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x7c, 0x3f, 0x04, 0x20, 0x18, 0xa0, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xdd, 0xed, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x7d, 0x10, 0x11, 0x11, 0x11, 0xd6, 0x39, 0x18, 0x39, 0x10, 0x35, 0x10, 0x55, 0x10, 0x51, 0x10, 0x51, 0x10, 0x11, 0x11, 0x11, 0xd1, 0x17, 0x0f, 0x00, 0x00 },
{ 0xdd, 0xee, 0x10, 0x00, 0x13, 0xff, 0x12, 0x00, 0x7e, 0x28, 0x12, 0xee, 0x12, 0x28, 0x32, 0x28, 0x3a, 0xee, 0x36, 0x28, 0x52, 0x68, 0x52, 0xae, 0x52, 0x48, 0x12, 0x88, 0x12, 0x00, 0x13, 0xff, 0x00, 0x00 },
{ 0xdd, 0xef, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x21, 0x1f, 0x26, 0x10, 0x38, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0x21, 0x1c, 0x21, 0x70, 0x1f, 0x00, 0x00 },
{ 0xdd, 0xf0, 0x10, 0x40, 0x10, 0x46, 0x1f, 0x78, 0x10, 0x40, 0x10, 0x41, 0x13, 0x41, 0x1c, 0x7e, 0x71, 0x00, 0x00, 0x88, 0x04, 0x90, 0x24, 0x20, 0x24, 0xc2, 0x47, 0x09, 0x0c, 0x09, 0x73, 0xf0, 0x00, 0x00 },
{ 0xdd, 0xf1, 0x01, 0x10, 0x01, 0x10, 0x7d, 0x10, 0x55, 0x10, 0x55, 0x10, 0x55, 0x13, 0x7d, 0xdc, 0x55, 0x10, 0x55, 0x10, 0x55, 0x10, 0x55, 0x10, 0x7d, 0x11, 0x01, 0x11, 0x01, 0xd1, 0x07, 0x0f, 0x00, 0x00 },
{ 0xdd, 0xf2, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x10, 0x40, 0x10, 0x42, 0x1f, 0x4c, 0x10, 0x70, 0x10, 0x41, 0x1f, 0x41, 0x70, 0x3f, 0x00, 0x00 },
{ 0xdd, 0xf3, 0x20, 0x90, 0x10, 0x90, 0x07, 0xfe, 0x00, 0x92, 0x40, 0x92, 0x23, 0xfe, 0x12, 0x90, 0x02, 0x90, 0x07, 0xff, 0x14, 0x91, 0x10, 0x91, 0x20, 0x91, 0x21, 0x16, 0x41, 0x10, 0x42, 0x10, 0x00, 0x00 },
{ 0xdd, 0xf4, 0x20, 0x40, 0x10, 0x22, 0x08, 0x12, 0x00, 0x44, 0x40, 0x44, 0x20, 0x48, 0x12, 0x48, 0x02, 0x52, 0x02, 0x51, 0x12, 0x61, 0x14, 0x41, 0x24, 0xc0, 0x21, 0x42, 0x42, 0x42, 0x4c, 0x3e, 0x00, 0x00 },
{ 0xdd, 0xf5, 0x00, 0x00, 0x7f, 0x7f, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x0f, 0x08, 0x78, 0x7f, 0x00, 0x00, 0x10, 0x40, 0x10, 0x42, 0x1f, 0x4c, 0x10, 0x70, 0x10, 0x41, 0x17, 0x41, 0x78, 0x3f, 0x00, 0x00 },
{ 0xdd, 0xf6, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x50, 0x40, 0x33, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x32, 0x22, 0x53, 0xfe, 0x10, 0x90, 0x11, 0x10, 0x27, 0xff, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xdd, 0xf7, 0x00, 0x88, 0x7c, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x20, 0x89, 0x3c, 0xea, 0x24, 0x8c, 0x64, 0x88, 0x24, 0x88, 0x24, 0x88, 0x24, 0x88, 0x3c, 0x89, 0x00, 0xe9, 0x03, 0x8f, 0x00, 0x00 },
{ 0xdd, 0xf8, 0x00, 0x10, 0x7c, 0x20, 0x10, 0xff, 0x10, 0x91, 0x10, 0x91, 0x20, 0xff, 0x20, 0x91, 0x3c, 0x91, 0x64, 0xff, 0x24, 0x24, 0x24, 0x44, 0x25, 0xff, 0x24, 0x04, 0x3c, 0x04, 0x00, 0x04, 0x00, 0x00 },
{ 0xdd, 0xf9, 0x0c, 0x88, 0x70, 0x88, 0x10, 0x88, 0x10, 0x88, 0x7c, 0x89, 0x10, 0xea, 0x10, 0x8c, 0x38, 0x88, 0x34, 0x88, 0x50, 0x88, 0x50, 0x88, 0x10, 0x88, 0x10, 0xa9, 0x10, 0xc9, 0x13, 0x07, 0x00, 0x00 },
{ 0xdd, 0xfa, 0x0c, 0x40, 0x70, 0x22, 0x10, 0x12, 0x10, 0x42, 0x7c, 0x44, 0x11, 0x44, 0x11, 0x4a, 0x39, 0x4a, 0x35, 0x51, 0x32, 0x51, 0x52, 0x60, 0x50, 0x40, 0x10, 0xc2, 0x13, 0x42, 0x10, 0x3e, 0x00, 0x00 },
{ 0xdd, 0xfb, 0x08, 0x88, 0x48, 0x88, 0x2a, 0x88, 0x2c, 0x88, 0x08, 0x88, 0x7e, 0x89, 0x08, 0xee, 0x18, 0x88, 0x1c, 0x88, 0x2a, 0x88, 0x28, 0x88, 0x48, 0x88, 0x08, 0x89, 0x08, 0xe9, 0x09, 0x87, 0x00, 0x00 },
{ 0xdd, 0xfc, 0x10, 0x48, 0x10, 0x48, 0x25, 0xcf, 0x44, 0x48, 0x28, 0x48, 0x10, 0x48, 0x11, 0xcf, 0x24, 0x48, 0x7c, 0x48, 0x10, 0x48, 0x55, 0xcf, 0x54, 0x48, 0x50, 0x88, 0x10, 0x88, 0x11, 0x08, 0x00, 0x00 },
{ 0xdd, 0xfd, 0x02, 0x40, 0x3e, 0x7e, 0x02, 0x40, 0x1e, 0x7c, 0x02, 0x40, 0x7e, 0x7f, 0x04, 0x40, 0x38, 0x40, 0x00, 0x00, 0x3f, 0x7e, 0x09, 0x12, 0x33, 0x66, 0x05, 0x0a, 0x39, 0x72, 0x03, 0x06, 0x00, 0x00 },
{ 0xdd, 0xfe, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x24, 0x92, 0x3c, 0x92, 0x24, 0x92, 0x24, 0xfe, 0x24, 0x80, 0x3c, 0x80, 0x24, 0x80, 0x24, 0x80, 0x24, 0x81, 0x44, 0x81, 0x4c, 0x7f, 0x00, 0x00 },
{ 0xde, 0xa1, 0x00, 0x10, 0x3c, 0x20, 0x24, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x24, 0xfe, 0x3c, 0x20, 0x24, 0x44, 0x24, 0x04, 0x25, 0xff, 0x44, 0x04, 0x4c, 0x04, 0x00, 0x00 },
{ 0xde, 0xa2, 0x3f, 0x08, 0x21, 0x7f, 0x3f, 0x22, 0x20, 0x14, 0x3f, 0x7f, 0x31, 0x08, 0x5f, 0x3e, 0x40, 0x08, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x1c, 0x00, 0x00 },
{ 0xde, 0xa3, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x02, 0x20, 0x7c, 0x3f, 0x04, 0x20, 0x08, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xde, 0xa4, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x7e, 0x3f, 0x04, 0x20, 0x08, 0xa0, 0x30, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0xfe, 0x7f, 0x81, 0x00, 0x00 },
{ 0xde, 0xa5, 0x10, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x7c, 0x92, 0x04, 0xfe, 0x08, 0x92, 0x08, 0x92, 0x10, 0xfe, 0x34, 0x28, 0x58, 0x48, 0x14, 0x08, 0x13, 0xff, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x00, 0x00 },
{ 0xde, 0xa6, 0x00, 0x48, 0x3c, 0x48, 0x00, 0x48, 0x7d, 0xcf, 0x00, 0x48, 0x3c, 0x48, 0x01, 0xcf, 0x3c, 0x48, 0x00, 0xc8, 0x03, 0x4f, 0x3c, 0x48, 0x24, 0x48, 0x24, 0x88, 0x24, 0x88, 0x3d, 0x08, 0x00, 0x00 },
{ 0xde, 0xa7, 0x3f, 0x08, 0x21, 0x3e, 0x3f, 0x14, 0x20, 0x14, 0x2f, 0x7f, 0x29, 0x08, 0x4f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xde, 0xa8, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x22, 0x3f, 0xfe, 0x24, 0x20, 0x7f, 0xff, 0x48, 0x21, 0x1f, 0xff, 0x68, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x38, 0x07, 0x00, 0x00 },
{ 0xde, 0xa9, 0x00, 0x00, 0x3f, 0x9f, 0x20, 0x91, 0x20, 0x92, 0x3f, 0x92, 0x04, 0x14, 0x7f, 0xd2, 0x00, 0x12, 0x3f, 0x91, 0x20, 0x91, 0x2e, 0x91, 0x2a, 0x91, 0x2e, 0x96, 0x20, 0x90, 0x3f, 0x90, 0x00, 0x00 },
{ 0xde, 0xaa, 0x02, 0x20, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x03, 0x20, 0x0e, 0x20, 0x72, 0x3f, 0x04, 0x20, 0x04, 0x20, 0x08, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xde, 0xab, 0x00, 0x00, 0x7f, 0xf2, 0x00, 0x14, 0x06, 0x90, 0x78, 0x8a, 0x08, 0x89, 0x08, 0x85, 0x08, 0x83, 0x7f, 0xf0, 0x08, 0x92, 0x08, 0x94, 0x10, 0x8a, 0x10, 0x89, 0x20, 0x85, 0x40, 0x83, 0x00, 0x00 },
{ 0xde, 0xac, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xde, 0xad, 0x01, 0x00, 0x01, 0x3f, 0x71, 0x04, 0x55, 0xc8, 0x55, 0x1e, 0x55, 0x12, 0x5f, 0xd2, 0x51, 0x1e, 0x55, 0x12, 0x75, 0x5e, 0x01, 0x52, 0x03, 0x92, 0x00, 0x9e, 0x01, 0x12, 0x06, 0x61, 0x00, 0x00 },
{ 0xde, 0xae, 0x10, 0x10, 0x11, 0xff, 0x11, 0x01, 0x7d, 0x7d, 0x24, 0x54, 0x24, 0x98, 0x24, 0xfe, 0x24, 0x82, 0x47, 0xfe, 0x68, 0x82, 0x58, 0xfe, 0x08, 0x82, 0x14, 0xfe, 0x20, 0x44, 0x41, 0x83, 0x00, 0x00 },
{ 0xde, 0xaf, 0x10, 0x80, 0x10, 0x81, 0x10, 0x82, 0x7b, 0xe4, 0x10, 0x98, 0x10, 0x80, 0x39, 0xc1, 0x35, 0xa2, 0x31, 0x84, 0x52, 0x98, 0x52, 0x80, 0x52, 0x81, 0x10, 0x82, 0x10, 0x8c, 0x10, 0xb0, 0x00, 0x00 },
{ 0xde, 0xb0, 0x10, 0x08, 0x11, 0xea, 0x10, 0x09, 0x7c, 0x08, 0x0b, 0xff, 0x08, 0x48, 0x48, 0x48, 0x29, 0x48, 0x11, 0x74, 0x19, 0x44, 0x15, 0x44, 0x25, 0x45, 0x21, 0x75, 0x47, 0x83, 0x00, 0x01, 0x00, 0x00 },
{ 0xde, 0xb1, 0x10, 0x20, 0x13, 0xff, 0x12, 0x01, 0x7a, 0xfd, 0x10, 0xa8, 0x11, 0x30, 0x30, 0xfe, 0x3b, 0x02, 0x35, 0xfe, 0x51, 0x02, 0x51, 0xfe, 0x51, 0x02, 0x11, 0xfe, 0x10, 0x84, 0x13, 0x03, 0x00, 0x00 },
{ 0xde, 0xb2, 0x00, 0x10, 0x7d, 0xff, 0x11, 0x01, 0x10, 0xfe, 0x1c, 0x92, 0x25, 0x14, 0x24, 0x7e, 0x24, 0x82, 0x59, 0xfe, 0x48, 0x82, 0x08, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x20, 0x44, 0x41, 0x83, 0x00, 0x00 },
{ 0xde, 0xb3, 0x20, 0x0c, 0x11, 0xf0, 0x09, 0x00, 0x01, 0x00, 0x41, 0xfe, 0x21, 0x08, 0x11, 0x08, 0x01, 0x08, 0x01, 0x08, 0x17, 0xff, 0x10, 0x00, 0x21, 0x08, 0x21, 0x04, 0x42, 0x02, 0x44, 0x02, 0x00, 0x00 },
{ 0xde, 0xb4, 0x20, 0x20, 0x17, 0xff, 0x04, 0x01, 0x05, 0xfd, 0x41, 0x24, 0x22, 0x28, 0x11, 0xfc, 0x07, 0x04, 0x01, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x21, 0x04, 0x21, 0xfc, 0x40, 0x8c, 0x47, 0x03, 0x00, 0x00 },
{ 0xde, 0xb5, 0x21, 0x00, 0x11, 0x3f, 0x05, 0xc4, 0x05, 0x08, 0x45, 0x1e, 0x2f, 0xd2, 0x01, 0x12, 0x05, 0x1e, 0x05, 0x52, 0x19, 0x3e, 0x13, 0x12, 0x20, 0x52, 0x20, 0x9e, 0x41, 0x12, 0x4e, 0x61, 0x00, 0x00 },
{ 0xde, 0xb6, 0x08, 0x40, 0x28, 0x40, 0x28, 0x40, 0x28, 0x40, 0x3e, 0x42, 0x48, 0x4c, 0x48, 0x70, 0x08, 0x40, 0x0e, 0x40, 0x78, 0x40, 0x08, 0x40, 0x08, 0x41, 0x08, 0x41, 0x08, 0x41, 0x08, 0x3f, 0x00, 0x00 },
{ 0xde, 0xb7, 0x01, 0x10, 0x7d, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x13, 0x7d, 0xdc, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x1d, 0x11, 0x71, 0x11, 0x01, 0xd1, 0x07, 0x0f, 0x00, 0x00, 0x00, 0x00 },
{ 0xde, 0xb8, 0x04, 0xf0, 0x08, 0x08, 0x17, 0xf4, 0x61, 0x13, 0x02, 0x30, 0x0c, 0x00, 0x3f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x04, 0x08, 0x38, 0x07, 0x00, 0x00 },
{ 0xde, 0xb9, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x04, 0x90, 0x19, 0xa8, 0x07, 0xf8, 0x18, 0x08, 0x7f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xde, 0xba, 0x08, 0x00, 0x08, 0xff, 0x08, 0x10, 0x2e, 0x7e, 0x28, 0x42, 0x28, 0x42, 0x7f, 0x7e, 0x08, 0x42, 0x08, 0x7e, 0x4a, 0x42, 0x5a, 0x42, 0x04, 0x7e, 0x04, 0x00, 0x18, 0x66, 0x61, 0x81, 0x00, 0x00 },
{ 0xde, 0xbb, 0x00, 0x00, 0x23, 0xfe, 0x12, 0x20, 0x03, 0xfc, 0x02, 0x20, 0x03, 0xfc, 0x0a, 0x20, 0x13, 0xfe, 0x20, 0x02, 0x42, 0xaa, 0x04, 0xa2, 0x00, 0x8c, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xde, 0xbc, 0x00, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 0x81, 0x00, 0xc2, 0x7e, 0xcc, 0x02, 0xb0, 0x04, 0xa0, 0x04, 0x90, 0x08, 0x90, 0x08, 0x88, 0x10, 0x84, 0x20, 0x82, 0x40, 0x81, 0x03, 0x80, 0x00, 0x00 },
{ 0xde, 0xbd, 0x00, 0x10, 0x7e, 0x10, 0x24, 0xfe, 0x24, 0x92, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x3c, 0xfe, 0x24, 0x00, 0x24, 0xff, 0x24, 0x20, 0x3c, 0x3e, 0x64, 0x42, 0x04, 0x02, 0x04, 0x1c, 0x00, 0x00 },
{ 0xde, 0xbe, 0x00, 0x10, 0x3e, 0x10, 0x28, 0xfe, 0x3e, 0x92, 0x28, 0xfe, 0x3e, 0x92, 0x28, 0xfe, 0x28, 0x00, 0x3e, 0xff, 0x02, 0x20, 0x52, 0x7e, 0x52, 0x42, 0x44, 0x02, 0x04, 0x02, 0x18, 0x3c, 0x00, 0x00 },
{ 0xde, 0xbf, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xff, 0x11, 0x00, 0x21, 0x00, 0x21, 0x00, 0x41, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00 },
{ 0xde, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xde, 0xc1, 0x04, 0x20, 0x24, 0x21, 0x24, 0x26, 0x27, 0xb8, 0x24, 0x20, 0x24, 0x21, 0x25, 0xa1, 0x2e, 0x1f, 0x70, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xde, 0xc2, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x10, 0x20, 0x30, 0x20, 0x37, 0xff, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00 },
{ 0xde, 0xc3, 0x08, 0x00, 0x0b, 0xff, 0x10, 0x01, 0x10, 0x01, 0x33, 0xf9, 0x30, 0x01, 0x50, 0x01, 0x11, 0xf1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xf1, 0x10, 0x01, 0x10, 0x01, 0x10, 0x07, 0x00, 0x00 },
{ 0xde, 0xc4, 0x08, 0x00, 0x09, 0x02, 0x11, 0x02, 0x11, 0x22, 0x31, 0x22, 0x31, 0x12, 0x51, 0x12, 0x11, 0x02, 0x11, 0x02, 0x11, 0x04, 0x11, 0x64, 0x11, 0x8a, 0x16, 0x12, 0x10, 0x61, 0x11, 0x81, 0x00, 0x00 },
{ 0xde, 0xc5, 0x08, 0x20, 0x08, 0x20, 0x13, 0xff, 0x10, 0x20, 0x30, 0x20, 0x33, 0xfe, 0x52, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x11, 0x20, 0x10, 0xa0, 0x10, 0x40, 0x10, 0xa0, 0x11, 0x18, 0x16, 0x07, 0x00, 0x00 },
{ 0xde, 0xc6, 0x08, 0x80, 0x08, 0x88, 0x09, 0x04, 0x11, 0x1e, 0x17, 0xe2, 0x31, 0x00, 0x31, 0x00, 0x53, 0xfe, 0x52, 0x20, 0x14, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x50, 0x11, 0x8c, 0x16, 0x03, 0x00, 0x00 },
{ 0xde, 0xc7, 0x08, 0x10, 0x08, 0x10, 0x0b, 0xff, 0x12, 0x49, 0x11, 0xfe, 0x30, 0x48, 0x31, 0xfe, 0x50, 0x48, 0x13, 0xff, 0x10, 0x48, 0x10, 0xa4, 0x13, 0x23, 0x10, 0xf8, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00 },
{ 0xde, 0xc8, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x10, 0x80, 0x09, 0x00, 0x05, 0x00, 0x02, 0x00, 0x05, 0x80, 0x18, 0x70, 0x60, 0x0f, 0x00, 0x00 },
{ 0xde, 0xc9, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x02, 0x00, 0x02, 0x7f, 0xf2, 0x00, 0x02, 0x00, 0x02, 0x1f, 0xc2, 0x10, 0x42, 0x10, 0x42, 0x10, 0x42, 0x1f, 0xc2, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x00 },
{ 0xde, 0xca, 0x00, 0x40, 0x00, 0x42, 0x78, 0x9f, 0x4b, 0xe9, 0x48, 0x48, 0x48, 0x89, 0x4b, 0x2f, 0x48, 0x20, 0x48, 0x7c, 0x48, 0xc4, 0x7b, 0x44, 0x00, 0x28, 0x00, 0x30, 0x00, 0xcc, 0x07, 0x03, 0x00, 0x00 },
{ 0xde, 0xcb, 0x00, 0x00, 0x7f, 0x7f, 0x41, 0x01, 0x41, 0x01, 0x7f, 0x7d, 0x00, 0x01, 0x7f, 0x01, 0x55, 0x39, 0x55, 0x29, 0x7f, 0x29, 0x55, 0x29, 0x55, 0x39, 0x55, 0x01, 0x55, 0x01, 0x43, 0x07, 0x00, 0x00 },
{ 0xde, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x4a, 0x24, 0x4a, 0x24, 0x3a, 0x28, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
{ 0xde, 0xcd, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xde, 0xce, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x19, 0x0c, 0x67, 0xcb, 0x01, 0x10, 0x3f, 0xff, 0x00, 0xa0, 0x03, 0x10, 0x0f, 0xfc, 0x74, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xde, 0xcf, 0x20, 0x10, 0x10, 0x94, 0x41, 0x12, 0x22, 0x11, 0x08, 0x72, 0x10, 0x0c, 0x20, 0x70, 0x47, 0x80, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x10, 0xe0, 0x03, 0x98, 0x7c, 0x06, 0x00, 0x00 },
{ 0xde, 0xd0, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x43, 0x01, 0x1c, 0x78, 0x10, 0x08, 0x1e, 0x78, 0x10, 0x08, 0x1f, 0xf8, 0x02, 0x00, 0x07, 0xfe, 0x18, 0x02, 0x60, 0x12, 0x12, 0x42, 0x22, 0x5c, 0x00, 0x00 },
{ 0xde, 0xd1, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x10, 0x00, 0x10, 0x3f, 0xfe, 0x00, 0x10, 0x08, 0x10, 0x04, 0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xde, 0xd2, 0x04, 0x02, 0x08, 0x02, 0x1f, 0x02, 0x11, 0x7f, 0x1f, 0x02, 0x11, 0x02, 0x1f, 0x02, 0x11, 0x22, 0x17, 0x92, 0x79, 0x12, 0x03, 0x02, 0x05, 0x02, 0x19, 0x02, 0x61, 0x02, 0x07, 0x0e, 0x00, 0x00 },
{ 0xde, 0xd3, 0x00, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xde, 0xd4, 0x10, 0x00, 0x21, 0xff, 0x7c, 0x10, 0x44, 0x10, 0x44, 0xfe, 0x44, 0x92, 0x7c, 0x92, 0x40, 0x92, 0x40, 0x92, 0x7c, 0x92, 0x44, 0x92, 0x44, 0x92, 0x44, 0x96, 0x7c, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xde, 0xd5, 0x08, 0x20, 0x09, 0x20, 0x11, 0x3e, 0x21, 0x20, 0x49, 0x20, 0x09, 0x20, 0x17, 0xff, 0x10, 0x20, 0x31, 0x20, 0x51, 0x20, 0x11, 0x3e, 0x11, 0x20, 0x12, 0xa0, 0x12, 0x60, 0x14, 0x1f, 0x00, 0x00 },
{ 0xde, 0xd6, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xde, 0xd7, 0x10, 0x10, 0x10, 0x28, 0x10, 0x44, 0x7d, 0x83, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x10, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x30, 0xfe, 0x00, 0x00 },
{ 0xde, 0xd8, 0x08, 0x04, 0x14, 0x04, 0x22, 0x24, 0x41, 0x14, 0x3e, 0x04, 0x08, 0x44, 0x08, 0x24, 0x7f, 0x04, 0x08, 0x05, 0x08, 0x0e, 0x2a, 0x74, 0x29, 0x04, 0x49, 0x04, 0x08, 0x04, 0x18, 0x04, 0x00, 0x00 },
{ 0xde, 0xd9, 0x22, 0x03, 0x22, 0x3c, 0x7f, 0x20, 0x22, 0x20, 0x22, 0x20, 0x3e, 0x3f, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x22, 0x7f, 0x22, 0x22, 0x42, 0x21, 0x42, 0x40, 0x82, 0x00, 0x00 },
{ 0xde, 0xda, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x52, 0x7e, 0x52, 0x12, 0x52, 0x12, 0x52, 0x3a, 0x56, 0x36, 0x96, 0x36, 0x96, 0x53, 0x0e, 0x52, 0x02, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x10, 0x00, 0x00, 0x00 },
{ 0xde, 0xdb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x7f, 0xff, 0x00, 0x00 },
{ 0xde, 0xdc, 0x10, 0x40, 0x10, 0x48, 0x10, 0x84, 0x7d, 0xfa, 0x10, 0x91, 0x10, 0x90, 0x39, 0x11, 0x36, 0x9f, 0x34, 0x80, 0x51, 0xf8, 0x51, 0x08, 0x52, 0x90, 0x10, 0x60, 0x11, 0x98, 0x16, 0x07, 0x00, 0x00 },
{ 0xde, 0xdd, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x1f, 0x21, 0x11, 0x26, 0x21, 0x38, 0x32, 0x20, 0x4a, 0x20, 0x04, 0x20, 0x08, 0x20, 0x10, 0x21, 0x20, 0x21, 0x40, 0x1f, 0x00, 0x00 },
{ 0xde, 0xde, 0x20, 0x10, 0x10, 0x10, 0x08, 0x94, 0x00, 0x92, 0x41, 0x11, 0x21, 0x11, 0x12, 0x10, 0x00, 0x10, 0x00, 0x71, 0x10, 0x02, 0x10, 0x04, 0x20, 0x08, 0x20, 0x30, 0x40, 0xc0, 0x47, 0x00, 0x00, 0x00 },
{ 0xde, 0xdf, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x49, 0x02, 0x49, 0x42, 0x49, 0x22, 0x49, 0x12, 0x49, 0x02, 0x49, 0x02, 0x89, 0x12, 0x8f, 0x13, 0x01, 0x22, 0x01, 0x22, 0x01, 0x42, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xde, 0xe0, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x70, 0x40, 0xa8, 0x21, 0x24, 0x16, 0x23, 0x00, 0x00, 0x01, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x21, 0x04, 0x21, 0xfc, 0x40, 0x00, 0x47, 0xff, 0x00, 0x00 },
{ 0xde, 0xe1, 0x20, 0x20, 0x13, 0xff, 0x0a, 0x01, 0x02, 0x41, 0x41, 0x9e, 0x21, 0x02, 0x11, 0xde, 0x01, 0x02, 0x01, 0xfe, 0x10, 0x80, 0x11, 0xff, 0x26, 0x01, 0x21, 0x55, 0x41, 0x51, 0x42, 0x06, 0x00, 0x00 },
{ 0xde, 0xe2, 0x04, 0x80, 0x45, 0x1f, 0x2b, 0xc4, 0x12, 0x44, 0x32, 0x5f, 0x52, 0x55, 0x0b, 0xd5, 0x0a, 0x15, 0x1a, 0x15, 0x2b, 0xd5, 0x4a, 0x55, 0x0a, 0x55, 0x0a, 0x57, 0x0b, 0xc4, 0x30, 0x04, 0x00, 0x00 },
{ 0xde, 0xe3, 0x00, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x54, 0x10, 0x52, 0x20, 0x91, 0x3c, 0x91, 0x25, 0x10, 0x64, 0x12, 0x24, 0x32, 0x24, 0x04, 0x24, 0x08, 0x3c, 0x10, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00 },
{ 0xde, 0xe4, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x08, 0xfe, 0x08, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x4a, 0x10, 0x48, 0x10, 0x08, 0x10, 0x09, 0xff, 0x00, 0x00 },
{ 0xde, 0xe5, 0x00, 0x00, 0x3e, 0x7e, 0x00, 0x42, 0x00, 0x42, 0x7f, 0x42, 0x08, 0x42, 0x08, 0x42, 0x2a, 0x7e, 0x2a, 0x40, 0x2a, 0x40, 0x2a, 0x40, 0x4a, 0x40, 0x48, 0x41, 0x08, 0x41, 0x08, 0x3f, 0x00, 0x00 },
{ 0xde, 0xe6, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x02, 0x00, 0x02, 0x7e, 0xfa, 0x08, 0x02, 0x08, 0x02, 0x2a, 0x72, 0x2a, 0x52, 0x2a, 0x52, 0x2a, 0x52, 0x4a, 0x72, 0x48, 0x02, 0x08, 0x02, 0x08, 0x0e, 0x00, 0x00 },
{ 0xde, 0xe7, 0x0c, 0x20, 0x70, 0x20, 0x10, 0x20, 0x10, 0x20, 0x7c, 0x40, 0x10, 0x40, 0x18, 0x40, 0x38, 0x40, 0x34, 0x88, 0x54, 0x84, 0x50, 0x84, 0x51, 0x02, 0x11, 0x3e, 0x17, 0xc1, 0x10, 0x01, 0x00, 0x00 },
{ 0xde, 0xe8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x4a, 0x84, 0x10, 0x00, 0x3e, 0xff, 0x22, 0x10, 0x22, 0x10, 0x3e, 0xfe, 0x20, 0x92, 0x20, 0x92, 0x3e, 0x92, 0x22, 0x92, 0x22, 0x96, 0x3e, 0x10, 0x00, 0x00 },
{ 0xde, 0xe9, 0x10, 0x10, 0x10, 0x10, 0x24, 0x10, 0x44, 0x92, 0x28, 0x92, 0x10, 0x91, 0x11, 0x11, 0x25, 0x10, 0x7c, 0x12, 0x10, 0x72, 0x54, 0x04, 0x54, 0x08, 0x50, 0x10, 0x10, 0x60, 0x11, 0x80, 0x00, 0x00 },
{ 0xde, 0xea, 0x08, 0x08, 0x08, 0x08, 0x52, 0x52, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x12, 0x12, 0x7f, 0x7f, 0x09, 0x09, 0x08, 0x08, 0x2a, 0x2a, 0x29, 0x2a, 0x49, 0x49, 0x48, 0x49, 0x08, 0x08, 0x00, 0x00 },
{ 0xde, 0xeb, 0x00, 0x10, 0x3f, 0x10, 0x20, 0x7e, 0x3e, 0x12, 0x20, 0xff, 0x3e, 0x12, 0x20, 0x12, 0x20, 0x7e, 0x7f, 0x10, 0x10, 0xfe, 0x18, 0x10, 0x24, 0x10, 0x2e, 0xff, 0x72, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xde, 0xec, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xde, 0xed, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x20, 0x20, 0x10, 0x20, 0x01, 0x24, 0x41, 0x22, 0x2a, 0x21, 0x0a, 0x25, 0x10, 0xe4, 0x10, 0x08, 0x20, 0x10, 0x20, 0x60, 0x47, 0x80, 0x00, 0x00 },
{ 0xde, 0xee, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x44, 0x0c, 0x28, 0x74, 0x10, 0x05, 0xcc, 0x3e, 0x03, 0x00, 0x00 },
{ 0xde, 0xef, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x55, 0x01, 0x55, 0x01, 0x54, 0x40, 0x54, 0x42, 0x54, 0x4c, 0x7c, 0x70, 0x10, 0x40, 0x14, 0x40, 0x14, 0x41, 0x1a, 0x41, 0x62, 0x3f, 0x00, 0x00 },
{ 0xde, 0xf0, 0x10, 0x20, 0x08, 0xa4, 0x41, 0x22, 0x22, 0x21, 0x00, 0xe4, 0x08, 0x08, 0x10, 0x30, 0x23, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x06, 0x44, 0x1c, 0x28, 0x64, 0x10, 0x05, 0xcc, 0x3e, 0x03, 0x00, 0x00 },
{ 0xde, 0xf1, 0x00, 0x20, 0x3e, 0x20, 0x00, 0x40, 0x7f, 0x7f, 0x00, 0x90, 0x3e, 0x10, 0x00, 0x10, 0x3e, 0x1e, 0x00, 0x10, 0x00, 0x10, 0x3e, 0x1e, 0x22, 0x10, 0x22, 0x10, 0x22, 0x10, 0x3e, 0x10, 0x00, 0x00 },
{ 0xde, 0xf2, 0x00, 0x00, 0x3e, 0xff, 0x00, 0x01, 0x7f, 0x01, 0x00, 0xfd, 0x3e, 0x01, 0x00, 0x01, 0x3e, 0x79, 0x00, 0x49, 0x00, 0x49, 0x3e, 0x49, 0x22, 0x79, 0x22, 0x01, 0x22, 0x01, 0x3e, 0x07, 0x00, 0x00 },
{ 0xde, 0xf3, 0x00, 0x42, 0x38, 0x82, 0x01, 0xe2, 0x7d, 0x22, 0x01, 0xef, 0x39, 0x22, 0x01, 0x22, 0x39, 0xe2, 0x01, 0x2a, 0x01, 0x66, 0x3b, 0xa2, 0x28, 0x62, 0x28, 0xa2, 0x2b, 0x22, 0x38, 0x66, 0x00, 0x00 },
{ 0xde, 0xf4, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x82, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x20, 0x24, 0x40, 0x24, 0xff, 0x25, 0x25, 0x3c, 0x49, 0x00, 0x91, 0x24, 0x22, 0x42, 0x0c, 0x00, 0x00 },
{ 0xde, 0xf5, 0x04, 0x10, 0x04, 0x10, 0x3f, 0x9f, 0x04, 0x22, 0x04, 0x22, 0x7f, 0xa2, 0x0a, 0x52, 0x0a, 0x12, 0x2a, 0x94, 0x2a, 0x94, 0x4a, 0x88, 0x4a, 0x08, 0x12, 0x14, 0x12, 0x22, 0x26, 0x41, 0x00, 0x00 },
{ 0xde, 0xf6, 0x3f, 0x08, 0x2a, 0x08, 0x45, 0x7f, 0x3e, 0x22, 0x12, 0x22, 0x0c, 0x14, 0x7f, 0x14, 0x49, 0x7f, 0x55, 0x08, 0x5d, 0x08, 0x41, 0x3e, 0x5d, 0x08, 0x55, 0x08, 0x4d, 0x08, 0x53, 0x08, 0x00, 0x00 },
{ 0xde, 0xf7, 0x00, 0x00, 0x7f, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x22, 0x22, 0x22, 0x22, 0x7f, 0x24, 0x02, 0x22, 0x06, 0x22, 0x0a, 0x21, 0x12, 0x21, 0x22, 0x21, 0x42, 0x2e, 0x02, 0x20, 0x0e, 0x20, 0x00, 0x00 },
{ 0xde, 0xf8, 0x08, 0x00, 0x0c, 0xfe, 0x12, 0x02, 0x1d, 0x02, 0x21, 0x72, 0x3e, 0x02, 0x62, 0x02, 0x3e, 0x72, 0x22, 0x52, 0x3e, 0x52, 0x20, 0x72, 0x3e, 0x02, 0x20, 0x02, 0x3e, 0x02, 0x20, 0x1e, 0x00, 0x00 },
{ 0xde, 0xf9, 0x00, 0x00, 0x3e, 0xfe, 0x28, 0xaa, 0x3e, 0xaa, 0x28, 0xaa, 0x3e, 0xaa, 0x28, 0xaa, 0x28, 0xaa, 0x3e, 0xae, 0x02, 0xc2, 0x52, 0x82, 0x52, 0x82, 0x44, 0x82, 0x04, 0x82, 0x18, 0xfe, 0x00, 0x00 },
{ 0xde, 0xfa, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x24, 0x22, 0x27, 0xbc, 0x44, 0x21, 0x5f, 0x9f, 0x11, 0x02, 0x7f, 0x7f, 0x03, 0x22, 0x0d, 0x12, 0x73, 0x06, 0x00, 0x00 },
{ 0xde, 0xfb, 0x04, 0x02, 0x15, 0x12, 0x24, 0x92, 0x44, 0x52, 0x3f, 0x92, 0x20, 0x92, 0x20, 0x92, 0x3f, 0x92, 0x20, 0x92, 0x20, 0x92, 0x3f, 0x92, 0x20, 0x92, 0x20, 0x82, 0x20, 0x82, 0x23, 0x8c, 0x00, 0x00 },
{ 0xde, 0xfc, 0x08, 0x20, 0x3f, 0x20, 0x29, 0x20, 0x7f, 0xfe, 0x29, 0x62, 0x3f, 0xa2, 0x08, 0x24, 0x3f, 0x14, 0x29, 0x14, 0x3f, 0x08, 0x04, 0x08, 0x7f, 0x94, 0x12, 0x14, 0x0c, 0x22, 0x73, 0xc1, 0x00, 0x00 },
{ 0xde, 0xfd, 0x20, 0x80, 0x11, 0x1f, 0x0a, 0x11, 0x7f, 0xd1, 0x04, 0x11, 0x24, 0x9f, 0x24, 0x91, 0x24, 0x91, 0x24, 0x91, 0x3f, 0x9f, 0x04, 0x11, 0x08, 0x21, 0x08, 0x21, 0x10, 0x41, 0x20, 0x87, 0x00, 0x00 },
{ 0xde, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x01, 0x42, 0x21, 0x0c, 0x48, 0x02, 0xbc, 0x7f, 0xc2, 0x00, 0x80, 0x04, 0x90, 0x04, 0x88, 0x08, 0x84, 0x10, 0x84, 0x00, 0x00 },
{ 0xdf, 0xa1, 0x00, 0x80, 0x03, 0x60, 0x0c, 0x18, 0x70, 0x87, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xdf, 0xa2, 0x00, 0x02, 0x3f, 0x82, 0x2a, 0x92, 0x2a, 0x92, 0x2a, 0x92, 0x2a, 0x92, 0x2a, 0x92, 0x7f, 0xd2, 0x2a, 0x92, 0x2a, 0x92, 0x2a, 0x92, 0x2a, 0x82, 0x2a, 0x82, 0x2a, 0x82, 0x21, 0x8c, 0x00, 0x00 },
{ 0xdf, 0xa3, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00 },
{ 0xdf, 0xa4, 0x12, 0x10, 0x12, 0x10, 0x7f, 0xa0, 0x12, 0x3f, 0x12, 0x62, 0x7f, 0xa2, 0x00, 0x22, 0x3f, 0x22, 0x21, 0x14, 0x3f, 0x14, 0x21, 0x08, 0x3f, 0x14, 0x21, 0x14, 0x21, 0x22, 0x27, 0x41, 0x00, 0x00 },
{ 0xdf, 0xa5, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x20, 0x42, 0x22, 0x22, 0x22, 0x12, 0x22, 0x02, 0x22, 0x02, 0x22, 0x12, 0x22, 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x42, 0x22, 0x43, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xa6, 0x00, 0x00, 0x00, 0xfe, 0x7c, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x7d, 0xff, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x1c, 0xaa, 0x70, 0xaa, 0x00, 0xaa, 0x00, 0x86, 0x00, 0x00 },
{ 0xdf, 0xa7, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x02, 0x08, 0x01, 0x10, 0x1f, 0xff, 0x10, 0x00, 0x11, 0x20, 0x11, 0xfe, 0x12, 0x20, 0x14, 0x20, 0x11, 0xfc, 0x20, 0x20, 0x20, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xdf, 0xa8, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x20, 0x30, 0x20, 0x10, 0x20, 0x12, 0x22, 0x32, 0x22, 0x52, 0x22, 0x12, 0x22, 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x43, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xa9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x4f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x10, 0x18, 0x10, 0x00, 0x00 },
{ 0xdf, 0xaa, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x08, 0x08, 0x2a, 0x2a, 0x29, 0x29, 0x49, 0x49, 0x48, 0x49, 0x08, 0x08, 0x18, 0x18, 0x00, 0x00 },
{ 0xdf, 0xab, 0x00, 0x10, 0x7f, 0x14, 0x14, 0x22, 0x14, 0xfd, 0x7f, 0x28, 0x55, 0x49, 0x55, 0x8f, 0x55, 0x20, 0x67, 0x3e, 0x41, 0x42, 0x41, 0xa4, 0x7f, 0x18, 0x41, 0x18, 0x41, 0x24, 0x7f, 0xc3, 0x00, 0x00 },
{ 0xdf, 0xac, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x12, 0x10, 0x7f, 0x9f, 0x12, 0x22, 0x7f, 0xa2, 0x21, 0x54, 0x3f, 0x0c, 0x21, 0x08, 0x3f, 0x14, 0x23, 0x63, 0x00, 0x00 },
{ 0xdf, 0xad, 0x20, 0x10, 0x10, 0x92, 0x40, 0x91, 0x29, 0x11, 0x0a, 0x64, 0x10, 0x08, 0x10, 0x30, 0x10, 0xc0, 0x3f, 0xf0, 0x00, 0xe0, 0x07, 0x00, 0x18, 0x04, 0x20, 0x04, 0x20, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xae, 0x12, 0x44, 0x12, 0x44, 0x17, 0xe4, 0x7a, 0x48, 0x12, 0x4f, 0x17, 0xf2, 0x10, 0x12, 0x1b, 0xca, 0x72, 0x4a, 0x13, 0xca, 0x12, 0x44, 0x13, 0xc4, 0x12, 0x4a, 0x12, 0x4a, 0x32, 0xd1, 0x00, 0x00 },
{ 0xdf, 0xaf, 0x01, 0x00, 0x32, 0x3c, 0x0c, 0x24, 0x0a, 0x25, 0x11, 0x25, 0x64, 0x47, 0x0a, 0x80, 0x7e, 0xfe, 0x08, 0x42, 0x1c, 0x42, 0x1a, 0x24, 0x29, 0x18, 0x48, 0x18, 0x08, 0x24, 0x08, 0xc3, 0x00, 0x00 },
{ 0xdf, 0xb0, 0x08, 0x10, 0x1f, 0x10, 0x22, 0x3f, 0x44, 0x22, 0x3f, 0x62, 0x01, 0x14, 0x7f, 0xd4, 0x01, 0x08, 0x3f, 0x14, 0x01, 0x63, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xdf, 0xb1, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x10, 0x3d, 0xff, 0x24, 0x42, 0x24, 0x24, 0x29, 0xff, 0x29, 0x00, 0x25, 0x48, 0x25, 0x7f, 0x25, 0x48, 0x39, 0xbe, 0x22, 0x08, 0x22, 0x7f, 0x00, 0x00 },
{ 0xdf, 0xb2, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xdf, 0xb3, 0x01, 0x00, 0x02, 0x08, 0x04, 0x7c, 0x3f, 0x84, 0x08, 0x08, 0x12, 0x12, 0x7e, 0xff, 0x01, 0x21, 0x06, 0x50, 0x19, 0x8c, 0x66, 0x23, 0x00, 0xc8, 0x0f, 0x10, 0x00, 0x60, 0x0f, 0x80, 0x00, 0x00 },
{ 0xdf, 0xb4, 0x10, 0x04, 0x10, 0x08, 0x10, 0x10, 0x7c, 0x20, 0x10, 0xc2, 0x10, 0x04, 0x38, 0x08, 0x38, 0x10, 0x54, 0x20, 0x54, 0xc1, 0x50, 0x02, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xdf, 0xb5, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x02, 0xa0, 0x0c, 0x98, 0x30, 0x86, 0x00, 0x80, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x1c, 0x1c, 0x2a, 0x2a, 0x48, 0x49, 0x08, 0x08, 0x00, 0x00 },
{ 0xdf, 0xb6, 0x20, 0x48, 0x10, 0x84, 0x0b, 0xfa, 0x01, 0x08, 0x42, 0x52, 0x27, 0xbd, 0x10, 0x60, 0x00, 0x90, 0x03, 0x2c, 0x14, 0xc3, 0x13, 0x18, 0x20, 0x62, 0x23, 0x8c, 0x40, 0x30, 0x41, 0xc0, 0x00, 0x00 },
{ 0xdf, 0xb7, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x07, 0xe2, 0x04, 0x22, 0x04, 0x1e, 0x18, 0x00, 0x6f, 0xf0, 0x02, 0x10, 0x01, 0x20, 0x00, 0xc0, 0x07, 0x38, 0x38, 0x07, 0x00, 0x00 },
{ 0xdf, 0xb8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x01, 0x20, 0x17, 0xd0, 0x10, 0x48, 0x24, 0xd2, 0x7d, 0x3e, 0x06, 0x51, 0x19, 0x8c, 0x66, 0x23, 0x00, 0xc8, 0x07, 0x10, 0x00, 0x60, 0x0f, 0x80, 0x00, 0x00 },
{ 0xdf, 0xb9, 0x10, 0x02, 0x10, 0x04, 0x10, 0x08, 0x7c, 0x30, 0x04, 0xc0, 0x08, 0x02, 0x08, 0x04, 0x10, 0x08, 0x34, 0x30, 0x58, 0xc1, 0x14, 0x02, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xdf, 0xba, 0x10, 0x1e, 0x13, 0xe0, 0x10, 0x20, 0x7f, 0xff, 0x10, 0xa0, 0x13, 0x2e, 0x12, 0x22, 0x1a, 0x22, 0x73, 0xae, 0x12, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xdf, 0xbb, 0x20, 0x20, 0x10, 0x20, 0x09, 0x20, 0x01, 0x3e, 0x41, 0x20, 0x21, 0x20, 0x17, 0xff, 0x00, 0x00, 0x01, 0x04, 0x11, 0x04, 0x15, 0xd7, 0x25, 0x14, 0x25, 0x14, 0x45, 0xd4, 0x4f, 0x3f, 0x00, 0x00 },
{ 0xdf, 0xbc, 0x10, 0x00, 0x18, 0xfe, 0x14, 0x84, 0x20, 0x88, 0x3c, 0x88, 0x50, 0x90, 0x10, 0x9e, 0x7c, 0xc2, 0x10, 0xc2, 0x55, 0x24, 0x59, 0x24, 0x51, 0x18, 0x1e, 0x18, 0x72, 0x24, 0x04, 0xc3, 0x00, 0x00 },
{ 0xdf, 0xbd, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x7d, 0x14, 0x01, 0xe4, 0x05, 0x44, 0x45, 0x44, 0x25, 0xf4, 0x25, 0x54, 0x29, 0x54, 0x29, 0xf4, 0x09, 0x45, 0x0e, 0x55, 0x72, 0x7b, 0x05, 0x89, 0x00, 0x00 },
{ 0xdf, 0xbe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xdf, 0xbf, 0x08, 0x80, 0x08, 0xff, 0x11, 0x00, 0x12, 0xfc, 0x30, 0x84, 0x30, 0xfc, 0x50, 0x84, 0x13, 0xff, 0x10, 0x40, 0x10, 0xff, 0x11, 0x25, 0x12, 0x49, 0x10, 0x91, 0x11, 0x21, 0x10, 0x46, 0x00, 0x00 },
{ 0xdf, 0xc0, 0x08, 0x40, 0x08, 0x7c, 0x10, 0xc8, 0x11, 0x10, 0x33, 0xff, 0x31, 0x11, 0x51, 0x11, 0x11, 0xff, 0x10, 0x71, 0x13, 0x9a, 0x10, 0x6c, 0x13, 0x9c, 0x10, 0x6a, 0x13, 0x89, 0x10, 0x30, 0x00, 0x00 },
{ 0xdf, 0xc1, 0x09, 0x22, 0x08, 0xa4, 0x13, 0xff, 0x12, 0x85, 0x30, 0xfc, 0x30, 0x00, 0x51, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x48, 0x13, 0x87, 0x00, 0x00 },
{ 0xdf, 0xc2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x04, 0x10, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x24, 0x3e, 0x28, 0x02, 0x27, 0xf2, 0x24, 0x12, 0x24, 0x12, 0x27, 0xf2, 0x20, 0x0e, 0x00, 0x00 },
{ 0xdf, 0xc3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1e, 0xbc, 0x12, 0xa4, 0x1e, 0xbc, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x80, 0x08, 0x44, 0x08, 0x48, 0x08, 0x30, 0x0b, 0x98, 0x3c, 0x07, 0x00, 0x00 },
{ 0xdf, 0xc4, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x44, 0x11, 0x07, 0xf0, 0x10, 0x0c, 0x1f, 0xf1, 0x10, 0x01, 0x0f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xc5, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x7d, 0xff, 0x25, 0x11, 0x24, 0xd6, 0x24, 0x10, 0x24, 0x40, 0x44, 0x4f, 0x69, 0xe9, 0x58, 0x4f, 0x08, 0xe9, 0x15, 0x4f, 0x22, 0x49, 0x40, 0x4f, 0x00, 0x00 },
{ 0xdf, 0xc6, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x47, 0xf1, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x47, 0xf1, 0x40, 0x01, 0x40, 0x01, 0x40, 0x07, 0x00, 0x00 },
{ 0xdf, 0xc7, 0x10, 0x20, 0x10, 0x20, 0x10, 0x3e, 0x54, 0x20, 0x54, 0x20, 0x55, 0xff, 0x54, 0x00, 0x54, 0x00, 0x55, 0xff, 0x54, 0x20, 0x54, 0x38, 0x7c, 0x24, 0x00, 0x22, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xdf, 0xc8, 0x10, 0x84, 0x08, 0x88, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x48, 0x09, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x9c, 0x00, 0x80, 0x00, 0x00 },
{ 0xdf, 0xc9, 0x00, 0x40, 0x00, 0x40, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x40, 0x20, 0x40, 0x20, 0x40, 0x2f, 0xfe, 0x20, 0xe0, 0x21, 0x50, 0x21, 0x50, 0x22, 0x48, 0x44, 0x44, 0x48, 0x42, 0x40, 0x40, 0x00, 0x00 },
{ 0xdf, 0xca, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x11, 0x04, 0x10, 0x88, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xdf, 0xcb, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x22, 0x00, 0x22, 0x3e, 0x2f, 0xa2, 0x22, 0x22, 0x26, 0x3e, 0x27, 0x22, 0x2a, 0xa2, 0x2a, 0x3e, 0x32, 0x22, 0x42, 0x22, 0x42, 0x3e, 0x00, 0x00 },
{ 0xdf, 0xcc, 0x08, 0x00, 0x08, 0x7f, 0x7f, 0x41, 0x08, 0x7f, 0x1c, 0x41, 0x1a, 0x7f, 0x29, 0x41, 0x48, 0x41, 0x08, 0x7f, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xdf, 0xcd, 0x0f, 0xf0, 0x02, 0x10, 0x01, 0xe0, 0x0e, 0x18, 0x00, 0x00, 0x3e, 0x7c, 0x12, 0x24, 0x0c, 0x18, 0x33, 0x66, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xdf, 0xce, 0x10, 0x40, 0x10, 0x78, 0x10, 0x90, 0x7d, 0xff, 0x13, 0x11, 0x11, 0x11, 0x39, 0xff, 0x38, 0x20, 0x34, 0xd1, 0x57, 0x3a, 0x50, 0xcc, 0x53, 0x1c, 0x10, 0x6a, 0x13, 0x89, 0x10, 0x30, 0x00, 0x00 },
{ 0xdf, 0xcf, 0x21, 0x00, 0x11, 0x1f, 0x09, 0x11, 0x07, 0xd1, 0x41, 0x11, 0x21, 0x1f, 0x13, 0x91, 0x03, 0x91, 0x03, 0x51, 0x15, 0x5f, 0x15, 0x11, 0x25, 0x11, 0x21, 0x11, 0x41, 0x11, 0x41, 0x1f, 0x00, 0x00 },
{ 0xdf, 0xd0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x14, 0x94, 0x08, 0x88, 0x14, 0x94, 0x20, 0xa0, 0x14, 0x94, 0x08, 0x88, 0x15, 0x54, 0x21, 0x60, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xdf, 0xd1, 0x04, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x3c, 0x10, 0x04, 0x38, 0x04, 0x38, 0x7c, 0x54, 0x14, 0x54, 0x14, 0x92, 0x24, 0x92, 0x25, 0x11, 0x44, 0x10, 0x04, 0x10, 0x00, 0x00 },
{ 0xdf, 0xd2, 0x04, 0x10, 0x24, 0x14, 0x24, 0x12, 0x24, 0x11, 0x24, 0x10, 0x3d, 0xff, 0x24, 0x10, 0x04, 0x10, 0x7c, 0x28, 0x24, 0x28, 0x24, 0x28, 0x24, 0x44, 0x24, 0x44, 0x44, 0x82, 0x45, 0x01, 0x00, 0x00 },
{ 0xdf, 0xd3, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x38, 0x82, 0x38, 0x82, 0x34, 0x82, 0x54, 0xfe, 0x50, 0x82, 0x50, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xd4, 0x00, 0x82, 0x3e, 0x44, 0x00, 0x28, 0x01, 0xff, 0x7f, 0x10, 0x08, 0x10, 0x08, 0xfe, 0x2a, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x2b, 0xff, 0x4a, 0x10, 0x48, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xdf, 0xd5, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x00, 0x08, 0x7f, 0x7f, 0x41, 0x08, 0x41, 0x1c, 0x7f, 0x1a, 0x41, 0x2a, 0x41, 0x48, 0x7f, 0x08, 0x41, 0x08, 0x41, 0x08, 0x7f, 0x00, 0x00 },
{ 0xdf, 0xd6, 0x44, 0x00, 0x25, 0xde, 0x08, 0x42, 0x7c, 0xc6, 0x11, 0x4a, 0x12, 0x52, 0x7c, 0x42, 0x10, 0x42, 0x10, 0xc6, 0x1d, 0x4a, 0x72, 0x52, 0x14, 0x42, 0x20, 0x42, 0x20, 0x42, 0x41, 0xce, 0x00, 0x00 },
{ 0xdf, 0xd7, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x42, 0x0c, 0x2c, 0x74, 0x10, 0x04, 0xcc, 0x3f, 0x03, 0x00, 0x00 },
{ 0xdf, 0xd8, 0x10, 0x40, 0x1c, 0x7f, 0x24, 0x80, 0x29, 0x7e, 0x7e, 0x42, 0x2a, 0x7e, 0x2a, 0x42, 0x3e, 0x7e, 0x2a, 0x00, 0x2b, 0xff, 0x3e, 0x40, 0x22, 0xff, 0x23, 0x25, 0x42, 0xc9, 0x46, 0x36, 0x00, 0x00 },
{ 0xdf, 0xd9, 0x00, 0x82, 0x3c, 0x44, 0x00, 0x08, 0x7d, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xfe, 0x3c, 0x10, 0x00, 0x10, 0x00, 0x10, 0x3d, 0xff, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xdf, 0xda, 0x02, 0x00, 0x07, 0xf0, 0x18, 0x20, 0x7f, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x1f, 0xfe, 0x00, 0x80, 0x07, 0x44, 0x38, 0xe8, 0x07, 0x30, 0x38, 0xe8, 0x07, 0x24, 0x78, 0x23, 0x01, 0xc0, 0x00, 0x00 },
{ 0xdf, 0xdb, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x44, 0x11, 0x47, 0xf1, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x10, 0x78, 0x0f, 0x00, 0x00 },
{ 0xdf, 0xdc, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x08, 0x00, 0x7f, 0x7f, 0x08, 0x41, 0x1c, 0x7f, 0x1a, 0x41, 0x29, 0x7f, 0x48, 0x41, 0x08, 0x7f, 0x00, 0x00 },
{ 0xdf, 0xdd, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x02, 0x20, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x88, 0x10, 0x84, 0x67, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xde, 0x00, 0x00, 0x7f, 0xff, 0x10, 0x84, 0x20, 0x82, 0x7f, 0xff, 0x20, 0x82, 0x2a, 0xaa, 0x24, 0x92, 0x2a, 0xae, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdf, 0xdf, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x02, 0x20, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x08, 0x08, 0x1f, 0xfc, 0x68, 0x0b, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xdf, 0xe0, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x88, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x17, 0xf4, 0x14, 0x14, 0x17, 0xf4, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xe1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x4f, 0xf9, 0x02, 0x20, 0x0f, 0xf8, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x90, 0x18, 0x8c, 0x67, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xe2, 0x0c, 0x20, 0x73, 0xff, 0x10, 0xa4, 0x10, 0xa4, 0x7d, 0x6a, 0x10, 0x20, 0x13, 0xff, 0x38, 0x00, 0x35, 0xfe, 0x51, 0x02, 0x51, 0x7a, 0x11, 0x4a, 0x11, 0x7a, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xe3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x01, 0x4a, 0x21, 0x04, 0x48, 0x02, 0x84, 0x01, 0x7a, 0x7f, 0x82, 0x04, 0x98, 0x08, 0x84, 0x30, 0x82, 0x00, 0x80, 0x00, 0x00 },
{ 0xdf, 0xe4, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xc0, 0x10, 0x40, 0x60, 0x80, 0x3f, 0xfc, 0x21, 0x04, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x20, 0x00, 0x20, 0x00, 0x20, 0x02, 0x20, 0x02, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xe5, 0x08, 0x10, 0x28, 0x90, 0x28, 0x90, 0x28, 0xfe, 0x7e, 0x90, 0x49, 0x10, 0x49, 0x10, 0x08, 0x10, 0x0e, 0xfe, 0x78, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x09, 0xff, 0x00, 0x00 },
{ 0xdf, 0xe6, 0x00, 0x80, 0x10, 0x80, 0x10, 0x80, 0x1f, 0xfe, 0x20, 0x80, 0x20, 0x80, 0x40, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdf, 0xe7, 0x08, 0x00, 0x28, 0xff, 0x28, 0x91, 0x28, 0x91, 0x3e, 0xff, 0x48, 0x91, 0x48, 0x91, 0x08, 0xff, 0x3e, 0x10, 0x08, 0x10, 0x08, 0xff, 0x08, 0x11, 0x0e, 0x21, 0x78, 0x41, 0x01, 0x86, 0x00, 0x00 },
{ 0xdf, 0xe8, 0x00, 0x80, 0x08, 0x84, 0x08, 0x82, 0x10, 0x89, 0x23, 0x91, 0x00, 0x60, 0x01, 0x80, 0x0f, 0xfc, 0x74, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xe9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfe, 0x20, 0x80, 0x40, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdf, 0xea, 0x3f, 0x7e, 0x29, 0x02, 0x3f, 0x14, 0x29, 0x08, 0x3f, 0x7f, 0x08, 0x09, 0x3f, 0x0a, 0x08, 0x08, 0x0f, 0x08, 0x78, 0x98, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdf, 0xeb, 0x13, 0xfe, 0x10, 0x24, 0x11, 0x20, 0x11, 0x3c, 0x7d, 0x20, 0x12, 0xa0, 0x14, 0x7f, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x1d, 0xfc, 0x71, 0x04, 0x01, 0xfc, 0x01, 0x04, 0x01, 0x1c, 0x00, 0x00 },
{ 0xdf, 0xec, 0x10, 0xa0, 0x11, 0x26, 0x11, 0x32, 0x55, 0x22, 0x55, 0xa6, 0x55, 0x3a, 0x55, 0x0a, 0x55, 0xae, 0x55, 0x2a, 0x55, 0x2a, 0x57, 0xff, 0x7c, 0x00, 0x00, 0x48, 0x00, 0x84, 0x03, 0x02, 0x00, 0x00 },
{ 0xdf, 0xed, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x04, 0x10, 0xc8, 0x10, 0x30, 0x10, 0x08, 0x17, 0xff, 0x10, 0x21, 0x10, 0x22, 0x20, 0x20, 0x20, 0x20, 0x40, 0xe0, 0x00, 0x00 },
{ 0xdf, 0xee, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x11, 0x10, 0x11, 0x10, 0x1f, 0xff, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0xf0, 0x10, 0x00, 0x24, 0x92, 0x24, 0x49, 0x48, 0x49, 0x00, 0x00 },
{ 0xdf, 0xef, 0x08, 0x20, 0x08, 0x50, 0x10, 0x88, 0x21, 0x04, 0x4a, 0x02, 0x08, 0xfd, 0x10, 0x20, 0x10, 0x20, 0x33, 0xfe, 0x50, 0x20, 0x11, 0x24, 0x11, 0x22, 0x12, 0x21, 0x14, 0x21, 0x10, 0xe0, 0x00, 0x00 },
{ 0xdf, 0xf0, 0x08, 0x00, 0x08, 0x00, 0x7f, 0xbf, 0x11, 0x21, 0x11, 0x21, 0x32, 0x21, 0x2a, 0x21, 0x06, 0x3f, 0x19, 0x00, 0x60, 0x00, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xdf, 0xf1, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x04, 0x7c, 0x48, 0x10, 0x30, 0x10, 0x10, 0x13, 0xff, 0x1c, 0x11, 0x70, 0x12, 0x10, 0x14, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0x70, 0x00, 0x00 },
{ 0xdf, 0xf2, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x7d, 0xfe, 0x10, 0x22, 0x13, 0xff, 0x10, 0x22, 0x1d, 0xfe, 0x70, 0x40, 0x13, 0xff, 0x10, 0x84, 0x11, 0xc8, 0x10, 0x38, 0x10, 0x64, 0x33, 0x82, 0x00, 0x00 },
{ 0xdf, 0xf3, 0x04, 0x08, 0x06, 0x08, 0x09, 0x0f, 0x10, 0x88, 0x20, 0x08, 0x5f, 0x08, 0x04, 0x7e, 0x04, 0x22, 0x7f, 0xa2, 0x04, 0x14, 0x15, 0x14, 0x15, 0x08, 0x24, 0x94, 0x24, 0xa2, 0x0c, 0xc1, 0x00, 0x00 },
{ 0xdf, 0xf4, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xfa, 0x01, 0x04, 0x0f, 0xe8, 0x01, 0x10, 0x7f, 0xff, 0x00, 0x90, 0x07, 0xfc, 0x1c, 0x04, 0x67, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xf5, 0x00, 0x00, 0x01, 0xff, 0x79, 0x29, 0x49, 0x29, 0x49, 0xff, 0x48, 0x21, 0x49, 0xfa, 0x78, 0x24, 0x4b, 0xff, 0x48, 0x24, 0x48, 0x7f, 0x48, 0xc1, 0x7b, 0x7f, 0x00, 0x41, 0x00, 0x7f, 0x00, 0x00 },
{ 0xdf, 0xf6, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xdf, 0xf7, 0x10, 0x00, 0x13, 0xff, 0x10, 0x50, 0x7c, 0x50, 0x10, 0x50, 0x11, 0xfe, 0x39, 0x52, 0x39, 0x52, 0x35, 0x52, 0x55, 0x52, 0x51, 0x9e, 0x51, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xdf, 0xf8, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x7d, 0xfe, 0x10, 0x22, 0x13, 0xff, 0x38, 0x22, 0x39, 0xfe, 0x34, 0x40, 0x57, 0xff, 0x50, 0x84, 0x51, 0xc8, 0x10, 0x38, 0x10, 0x66, 0x13, 0x81, 0x00, 0x00 },
{ 0xdf, 0xf9, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x01, 0x1f, 0xff, 0x10, 0x20, 0x17, 0xaf, 0x10, 0x20, 0x17, 0xaf, 0x10, 0x00, 0x11, 0x20, 0x13, 0xfe, 0x14, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xdf, 0xfa, 0x00, 0x10, 0x01, 0x11, 0x7d, 0x11, 0x11, 0xff, 0x10, 0x00, 0x10, 0x00, 0x11, 0xff, 0x7c, 0x10, 0x10, 0x20, 0x11, 0xff, 0x11, 0x29, 0x1d, 0x29, 0x71, 0x29, 0x01, 0x29, 0x01, 0x2b, 0x00, 0x00 },
{ 0xdf, 0xfb, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0x88, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xdf, 0xfc, 0x08, 0x00, 0x08, 0x3e, 0x7f, 0x22, 0x11, 0x22, 0x32, 0x22, 0x0c, 0x22, 0x12, 0x3e, 0x61, 0x00, 0x0a, 0x20, 0x04, 0x44, 0x02, 0x82, 0x7f, 0xfd, 0x00, 0x81, 0x08, 0x8c, 0x30, 0x82, 0x00, 0x00 },
{ 0xdf, 0xfd, 0x08, 0x20, 0x08, 0x22, 0x10, 0xfa, 0x54, 0x24, 0x24, 0x28, 0x29, 0xff, 0x10, 0x28, 0x24, 0x44, 0x7c, 0xfe, 0x13, 0x42, 0x54, 0x42, 0x54, 0x7e, 0x54, 0x42, 0x50, 0x42, 0x10, 0x7e, 0x00, 0x00 },
{ 0xdf, 0xfe, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x01, 0x04, 0x1f, 0xe8, 0x01, 0x10, 0x7f, 0xff, 0x01, 0xa0, 0x06, 0x10, 0x1f, 0xf8, 0x64, 0x08, 0x07, 0xf8, 0x04, 0x08, 0x07, 0xf8, 0x00, 0x00 },
{ 0xe0, 0xa1, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x82, 0x08, 0xf4, 0x08, 0x80, 0x14, 0x80, 0x23, 0xfe, 0x40, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xe0, 0xa2, 0x08, 0x00, 0x14, 0x7e, 0x22, 0x02, 0x41, 0x24, 0x3e, 0x18, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x09, 0x08, 0x0a, 0x08, 0x08, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x38, 0x00, 0x00 },
{ 0xe0, 0xa3, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xfe, 0x11, 0x22, 0x1f, 0xfe, 0x01, 0x04, 0x0f, 0xe8, 0x01, 0x10, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0xfc, 0x74, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xa4, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x3f, 0xfe, 0x22, 0x42, 0x22, 0x46, 0x22, 0x46, 0x24, 0x46, 0x24, 0x3e, 0x28, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xa5, 0x10, 0x0e, 0x7e, 0x70, 0x10, 0x40, 0x1e, 0x7f, 0x70, 0x44, 0x10, 0x84, 0x37, 0xe4, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xa6, 0x21, 0x03, 0x11, 0x1c, 0x01, 0x10, 0x47, 0xd0, 0x21, 0x10, 0x01, 0x1f, 0x01, 0x12, 0x71, 0xd2, 0x17, 0x12, 0x11, 0x12, 0x11, 0x22, 0x11, 0x22, 0x13, 0x42, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe0, 0xa7, 0x18, 0x08, 0x25, 0xc8, 0x41, 0x48, 0x01, 0x48, 0x7d, 0x5f, 0x11, 0xc9, 0x11, 0x49, 0x7d, 0x49, 0x11, 0x49, 0x11, 0xc9, 0x55, 0x49, 0x35, 0x49, 0x11, 0xf1, 0x1b, 0x11, 0x60, 0x26, 0x00, 0x00 },
{ 0xe0, 0xa8, 0x00, 0x3c, 0x1f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x03, 0x60, 0x0c, 0x18, 0x70, 0x87, 0x0c, 0xc8, 0x02, 0xb0, 0x0c, 0x8c, 0x70, 0x83, 0x01, 0x80, 0x00, 0x00 },
{ 0xe0, 0xa9, 0x07, 0x00, 0x38, 0x7e, 0x20, 0x02, 0x3f, 0x7e, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00, 0x14, 0xa4, 0x12, 0x94, 0x10, 0x84, 0x14, 0xa4, 0x12, 0x95, 0x10, 0x85, 0x1c, 0xf3, 0x73, 0x81, 0x00, 0x00 },
{ 0xe0, 0xaa, 0x01, 0x00, 0x01, 0x00, 0x03, 0xfe, 0x02, 0x02, 0x04, 0x02, 0x0a, 0x04, 0x11, 0x04, 0x60, 0x88, 0x00, 0x48, 0x00, 0x30, 0x00, 0x20, 0x00, 0x40, 0x01, 0x80, 0x06, 0x00, 0x38, 0x00, 0x00, 0x00 },
{ 0xe0, 0xab, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x3c, 0x9e, 0x10, 0x88, 0x3c, 0x9e, 0x24, 0x92, 0x3c, 0x9e, 0x25, 0x52, 0x3d, 0x5e, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe0, 0xac, 0x00, 0x80, 0x3f, 0xff, 0x21, 0x10, 0x21, 0x10, 0x3f, 0xff, 0x21, 0x10, 0x21, 0x10, 0x21, 0xf0, 0x20, 0x40, 0x27, 0xfc, 0x24, 0x44, 0x24, 0x44, 0x44, 0x44, 0x44, 0x5c, 0x40, 0x40, 0x00, 0x00 },
{ 0xe0, 0xad, 0x10, 0x44, 0x10, 0x44, 0x11, 0xff, 0x58, 0x44, 0x54, 0x44, 0x55, 0xff, 0x50, 0x00, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xae, 0x04, 0x10, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xe0, 0xaf, 0x08, 0x06, 0x08, 0x78, 0x7f, 0x40, 0x08, 0x7f, 0x1c, 0x48, 0x1a, 0x48, 0x28, 0x88, 0x49, 0x08, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xb0, 0x10, 0x07, 0x10, 0xf8, 0x10, 0x80, 0x7c, 0x80, 0x10, 0x80, 0x10, 0xff, 0x38, 0x84, 0x38, 0x84, 0x34, 0x84, 0x54, 0x84, 0x50, 0x84, 0x50, 0x84, 0x11, 0x04, 0x11, 0x04, 0x12, 0x04, 0x00, 0x00 },
{ 0xe0, 0xb1, 0x20, 0x40, 0x10, 0x40, 0x08, 0x40, 0x00, 0xfe, 0x40, 0x82, 0x21, 0x02, 0x11, 0x02, 0x02, 0x84, 0x04, 0x44, 0x10, 0x28, 0x10, 0x18, 0x20, 0x10, 0x20, 0x20, 0x40, 0xc0, 0x43, 0x00, 0x00, 0x00 },
{ 0xe0, 0xb2, 0x21, 0x03, 0x11, 0x1c, 0x01, 0x10, 0x07, 0xd0, 0x41, 0x10, 0x21, 0x1f, 0x13, 0x92, 0x03, 0x92, 0x03, 0x52, 0x15, 0x52, 0x15, 0x12, 0x25, 0x12, 0x21, 0x22, 0x41, 0x22, 0x41, 0x42, 0x00, 0x00 },
{ 0xe0, 0xb3, 0x20, 0x40, 0x13, 0x9e, 0x0a, 0x02, 0x03, 0xde, 0x42, 0x02, 0x22, 0x02, 0x13, 0xfe, 0x00, 0x40, 0x00, 0x80, 0x11, 0xff, 0x16, 0x01, 0x20, 0x09, 0x22, 0xa5, 0x44, 0xa1, 0x40, 0x06, 0x00, 0x00 },
{ 0xe0, 0xb4, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x17, 0xfe, 0x24, 0x02, 0x44, 0x02, 0x04, 0x02, 0x04, 0x02, 0x04, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xb5, 0x00, 0x10, 0x7c, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x10, 0x10, 0x20, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x64, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x00, 0x00, 0xcc, 0x03, 0x03, 0x00, 0x00 },
{ 0xe0, 0xb6, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x80, 0x1f, 0xfe, 0x11, 0x10, 0x1f, 0xfe, 0x11, 0x10, 0x11, 0xf0, 0x10, 0x40, 0x17, 0xfe, 0x24, 0x42, 0x24, 0x42, 0x44, 0x4e, 0x00, 0x40, 0x00, 0x00 },
{ 0xe0, 0xb7, 0x06, 0x00, 0x78, 0xff, 0x08, 0xa9, 0x4a, 0xff, 0x2c, 0x10, 0x08, 0x7e, 0x7e, 0x10, 0x08, 0xff, 0x18, 0x44, 0x1c, 0x28, 0x2a, 0xff, 0x28, 0x10, 0x48, 0x7e, 0x48, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xe0, 0xb8, 0x18, 0x00, 0x24, 0xfe, 0x40, 0x82, 0x00, 0xfe, 0x7c, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x7c, 0x40, 0x10, 0x7f, 0x10, 0xa9, 0x55, 0x29, 0x34, 0x49, 0x10, 0x92, 0x19, 0x22, 0x60, 0x4c, 0x00, 0x00 },
{ 0xe0, 0xb9, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x31, 0x11, 0x31, 0x11, 0x51, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x00, 0x00 },
{ 0xe0, 0xba, 0x08, 0x00, 0x0f, 0xff, 0x10, 0x50, 0x13, 0xfe, 0x32, 0x52, 0x32, 0x52, 0x53, 0xfe, 0x50, 0x80, 0x17, 0xff, 0x11, 0x04, 0x12, 0xfa, 0x14, 0x89, 0x10, 0x98, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xbb, 0x00, 0x80, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xe0, 0xbc, 0x08, 0x08, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xbd, 0x10, 0x00, 0x11, 0xef, 0x11, 0x29, 0x7d, 0x29, 0x25, 0xef, 0x24, 0x00, 0x24, 0xfe, 0x24, 0x92, 0x44, 0xfe, 0x68, 0x92, 0x58, 0xfe, 0x0c, 0x10, 0x13, 0xff, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xe0, 0xbe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe0, 0xbf, 0x00, 0x1f, 0x1f, 0xe0, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xbf, 0x12, 0x85, 0x14, 0x89, 0x19, 0xb3, 0x22, 0x85, 0x2c, 0x99, 0x41, 0x83, 0x00, 0x00 },
{ 0xe0, 0xc0, 0x11, 0x10, 0x0a, 0x10, 0x7f, 0xd0, 0x04, 0x3f, 0x3f, 0xa2, 0x04, 0x52, 0x7f, 0xd2, 0x24, 0x94, 0x15, 0x14, 0x7f, 0xc8, 0x00, 0x08, 0x3f, 0x94, 0x20, 0x94, 0x20, 0xa2, 0x3f, 0xc1, 0x00, 0x00 },
{ 0xe0, 0xc1, 0x10, 0x20, 0x10, 0x20, 0x10, 0x40, 0x7e, 0x7f, 0x10, 0x80, 0x10, 0x00, 0x1e, 0x7e, 0x12, 0x12, 0x12, 0x14, 0x12, 0x50, 0x12, 0x5e, 0x12, 0x50, 0x22, 0x50, 0x22, 0xb0, 0x4d, 0x0f, 0x00, 0x00 },
{ 0xe0, 0xc2, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x02, 0x01, 0x42, 0xfd, 0x20, 0x00, 0x10, 0xfc, 0x00, 0x84, 0x00, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x20, 0xfc, 0x20, 0x00, 0x43, 0xff, 0x40, 0x00, 0x00, 0x00 },
{ 0xe0, 0xc3, 0x10, 0x0e, 0x11, 0xf0, 0x11, 0x00, 0x55, 0xfe, 0x59, 0x02, 0x51, 0xfe, 0x51, 0x00, 0x11, 0x77, 0x11, 0x33, 0x11, 0x55, 0x29, 0x11, 0x25, 0x33, 0x22, 0x55, 0x42, 0x11, 0x44, 0x33, 0x00, 0x00 },
{ 0xe0, 0xc4, 0x00, 0x40, 0x7c, 0x40, 0x10, 0xff, 0x10, 0x80, 0x11, 0x00, 0x10, 0xff, 0x7c, 0x11, 0x10, 0x11, 0x10, 0x10, 0x10, 0x9e, 0x1c, 0x90, 0x70, 0x90, 0x01, 0x50, 0x01, 0x30, 0x02, 0x0f, 0x00, 0x00 },
{ 0xe0, 0xc5, 0x00, 0x20, 0x7c, 0x20, 0x13, 0xff, 0x12, 0x01, 0x12, 0xfd, 0x10, 0x00, 0x7c, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x1c, 0x84, 0x70, 0xfc, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xe0, 0xc6, 0x01, 0x20, 0x79, 0x20, 0x21, 0x3f, 0x27, 0xc1, 0x22, 0x00, 0x22, 0x3f, 0x7b, 0x89, 0x22, 0x88, 0x22, 0x88, 0x22, 0xae, 0x3a, 0xa8, 0x62, 0xa8, 0x02, 0xa8, 0x04, 0xd8, 0x05, 0x07, 0x00, 0x00 },
{ 0xe0, 0xc7, 0x00, 0x10, 0x01, 0xff, 0x7d, 0x01, 0x11, 0x7d, 0x10, 0x00, 0x10, 0x44, 0x7c, 0x92, 0x10, 0x28, 0x10, 0x7c, 0x11, 0xc7, 0x1c, 0x7c, 0x70, 0x44, 0x00, 0x7c, 0x00, 0x44, 0x00, 0x7c, 0x00, 0x00 },
{ 0xe0, 0xc8, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x53, 0x91, 0x35, 0x0a, 0x17, 0xdf, 0x15, 0x44, 0x37, 0xdf, 0x55, 0x44, 0x15, 0x44, 0x17, 0xdf, 0x20, 0x04, 0x2a, 0xa4, 0x4a, 0xa4, 0x00, 0x00 },
{ 0xe0, 0xc9, 0x00, 0x00, 0x7d, 0xef, 0x01, 0x29, 0x01, 0xef, 0x7c, 0x00, 0x10, 0xfe, 0x10, 0x92, 0x54, 0xfe, 0x54, 0x92, 0x54, 0xfe, 0x54, 0x10, 0x51, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe0, 0xca, 0x10, 0x10, 0x10, 0x20, 0x24, 0xfe, 0x44, 0x82, 0x28, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x24, 0x10, 0x7c, 0x19, 0x11, 0xda, 0x54, 0x54, 0x54, 0x54, 0x50, 0x92, 0x13, 0x11, 0x10, 0x30, 0x00, 0x00 },
{ 0xe0, 0xcb, 0x10, 0x82, 0x10, 0x44, 0x25, 0xff, 0x44, 0x10, 0x28, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x24, 0x92, 0x7c, 0x54, 0x11, 0xff, 0x54, 0x00, 0x54, 0xfe, 0x50, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xcc, 0x08, 0x08, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x40, 0x10, 0x40, 0x08, 0xff, 0x41, 0x21, 0x22, 0x22, 0x08, 0x50, 0x10, 0x8c, 0x63, 0x03, 0x00, 0x00 },
{ 0xe0, 0xcd, 0x00, 0x10, 0x3c, 0x20, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x10, 0x24, 0x11, 0x3d, 0xda, 0x24, 0x54, 0x24, 0x54, 0x24, 0x92, 0x45, 0x11, 0x4c, 0x30, 0x00, 0x00 },
{ 0xe0, 0xce, 0x00, 0x82, 0x3c, 0x44, 0x25, 0xff, 0x24, 0x10, 0x24, 0xfe, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x92, 0x24, 0x54, 0x3d, 0xff, 0x24, 0x00, 0x24, 0xfe, 0x24, 0x82, 0x44, 0x82, 0x4c, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xcf, 0x08, 0x1c, 0x10, 0x44, 0x3e, 0x44, 0x22, 0x44, 0x2a, 0x82, 0x2a, 0x82, 0x23, 0x01, 0x26, 0x00, 0x7a, 0x7e, 0x2a, 0x42, 0x2a, 0x42, 0x2a, 0x42, 0x22, 0x42, 0x42, 0x42, 0x46, 0x7e, 0x00, 0x00 },
{ 0xe0, 0xd0, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x10, 0x22, 0x1e, 0x14, 0x24, 0x7f, 0x7f, 0x08, 0x29, 0x08, 0x3f, 0x3e, 0x29, 0x08, 0x3f, 0x08, 0x00, 0x7f, 0x00, 0x08, 0x2a, 0x88, 0x4a, 0x88, 0x00, 0x00 },
{ 0xe0, 0xd1, 0x00, 0x00, 0x11, 0xef, 0x11, 0x29, 0x11, 0xef, 0x7c, 0x00, 0x54, 0xfe, 0x54, 0x92, 0x54, 0xfe, 0x7c, 0x92, 0x10, 0xfe, 0x14, 0x10, 0x1f, 0xff, 0x72, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe0, 0xd2, 0x00, 0x10, 0x3c, 0x50, 0x00, 0x50, 0x00, 0xfe, 0x7e, 0x90, 0x01, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x3c, 0x48, 0x00, 0x48, 0x3c, 0x48, 0x24, 0x49, 0x24, 0x89, 0x24, 0x89, 0x3d, 0x07, 0x00, 0x00 },
{ 0xe0, 0xd3, 0x00, 0x10, 0x3e, 0x50, 0x22, 0x50, 0x22, 0x7e, 0x22, 0x90, 0x3e, 0x90, 0x08, 0x10, 0x09, 0xff, 0x28, 0x48, 0x2e, 0x48, 0x28, 0x48, 0x28, 0x48, 0x28, 0x89, 0x2e, 0x89, 0x71, 0x07, 0x00, 0x00 },
{ 0xe0, 0xd4, 0x20, 0x00, 0x13, 0xde, 0x0a, 0x52, 0x43, 0xde, 0x22, 0x10, 0x12, 0x52, 0x01, 0xce, 0x00, 0x88, 0x73, 0xfe, 0x10, 0x88, 0x13, 0xfe, 0x10, 0x88, 0x13, 0x06, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe0, 0xd5, 0x18, 0x10, 0x24, 0x50, 0x40, 0x50, 0x00, 0xfe, 0x7c, 0x90, 0x11, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x48, 0x10, 0x48, 0x54, 0x48, 0x34, 0x48, 0x10, 0x89, 0x1c, 0x89, 0x71, 0x07, 0x00, 0x00 },
{ 0xe0, 0xd6, 0x18, 0x82, 0x14, 0x44, 0x25, 0xff, 0x20, 0x10, 0x7c, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x92, 0x10, 0x54, 0x55, 0xff, 0x54, 0x00, 0x50, 0xfe, 0x1c, 0x82, 0x70, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xd7, 0x10, 0x82, 0x18, 0x44, 0x25, 0xff, 0x38, 0x10, 0x40, 0xfe, 0x7c, 0x10, 0x45, 0xff, 0x7c, 0x92, 0x44, 0x54, 0x7d, 0xff, 0x40, 0x00, 0x7c, 0xfe, 0x40, 0x82, 0x7c, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xd8, 0x10, 0x42, 0x1c, 0x22, 0x24, 0x24, 0x28, 0xff, 0x7e, 0x08, 0x2a, 0x08, 0x2a, 0x7e, 0x3e, 0x08, 0x2a, 0x08, 0x2a, 0x08, 0x3e, 0xff, 0x00, 0x08, 0x2a, 0x08, 0x2a, 0x08, 0x40, 0x08, 0x00, 0x00 },
{ 0xe0, 0xd9, 0x01, 0x00, 0x01, 0xf8, 0x01, 0x00, 0x0f, 0xf0, 0x08, 0x10, 0x09, 0xf0, 0x09, 0x10, 0x3f, 0xfc, 0x20, 0x04, 0x27, 0xc4, 0x24, 0x44, 0x24, 0x44, 0x27, 0xc4, 0x20, 0x04, 0x20, 0x18, 0x00, 0x00 },
{ 0xe0, 0xda, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x01, 0x1f, 0xff, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x22, 0x02, 0x22, 0x02, 0x42, 0x0e, 0x00, 0x00 },
{ 0xe0, 0xdb, 0x10, 0x80, 0x10, 0x9f, 0x13, 0xe9, 0x7c, 0x89, 0x13, 0xe9, 0x10, 0x89, 0x30, 0xd1, 0x3b, 0xa6, 0x34, 0x80, 0x50, 0x20, 0x53, 0xff, 0x50, 0x20, 0x10, 0x50, 0x10, 0x8c, 0x13, 0x03, 0x00, 0x00 },
{ 0xe0, 0xdc, 0x20, 0x00, 0x11, 0x24, 0x09, 0x24, 0x01, 0x24, 0x41, 0x24, 0x27, 0xff, 0x11, 0x24, 0x01, 0x24, 0x01, 0x24, 0x11, 0x24, 0x11, 0x24, 0x21, 0x3c, 0x21, 0x00, 0x41, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe0, 0xdd, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x02, 0x22, 0x42, 0x22, 0x23, 0xfe, 0x12, 0x22, 0x02, 0x22, 0x03, 0xfe, 0x10, 0x20, 0x10, 0x22, 0x20, 0x14, 0x20, 0x19, 0x40, 0xe5, 0x47, 0x03, 0x00, 0x00 },
{ 0xe0, 0xde, 0x21, 0x24, 0x11, 0x24, 0x0f, 0xff, 0x01, 0x24, 0x41, 0x3c, 0x21, 0x00, 0x11, 0xff, 0x00, 0x20, 0x00, 0x20, 0x17, 0xff, 0x10, 0x70, 0x20, 0xa8, 0x23, 0x24, 0x4c, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xe0, 0xdf, 0x00, 0x7c, 0x3f, 0x80, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00 },
{ 0xe0, 0xe0, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x08, 0x10, 0x10, 0x10, 0x3e, 0xfe, 0x22, 0x44, 0x22, 0x24, 0x3e, 0xff, 0x20, 0x10, 0x3e, 0x10, 0x22, 0xfe, 0x22, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe0, 0xe1, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x10, 0x3e, 0x10, 0x08, 0x7c, 0x7f, 0x14, 0x22, 0x54, 0x49, 0x25, 0x3e, 0x53, 0x08, 0x01, 0x0e, 0xc4, 0x71, 0x28, 0x0e, 0x10, 0x72, 0xcc, 0x0f, 0x03, 0x00, 0x00 },
{ 0xe0, 0xe2, 0x00, 0x00, 0x3c, 0x78, 0x00, 0x48, 0x00, 0x49, 0x7e, 0x49, 0x00, 0x8f, 0x3d, 0x00, 0x01, 0xfe, 0x3c, 0x42, 0x00, 0x44, 0x3c, 0x24, 0x24, 0x28, 0x24, 0x10, 0x24, 0x6c, 0x3d, 0x83, 0x00, 0x00 },
{ 0xe0, 0xe3, 0x00, 0x1c, 0x3c, 0x44, 0x00, 0x44, 0x00, 0x82, 0x7f, 0xff, 0x00, 0x82, 0x3c, 0x82, 0x00, 0x82, 0x3c, 0xfe, 0x00, 0x28, 0x3c, 0x28, 0x24, 0x49, 0x24, 0x49, 0x24, 0x89, 0x3d, 0x07, 0x00, 0x00 },
{ 0xe0, 0xe4, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x00, 0x80, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x04, 0x7f, 0xff, 0x00, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xe5, 0x08, 0x00, 0x7f, 0x7f, 0x08, 0x11, 0x3e, 0x21, 0x08, 0x46, 0x7f, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x25, 0x52, 0x3f, 0xfe, 0x22, 0x22, 0x25, 0x52, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xe0, 0xe6, 0x04, 0x02, 0x04, 0x82, 0x15, 0x22, 0x14, 0x22, 0x0a, 0x22, 0x09, 0x22, 0x11, 0x22, 0x24, 0x22, 0x04, 0xa2, 0x15, 0x22, 0x14, 0x22, 0x0a, 0x02, 0x09, 0x02, 0x10, 0x82, 0x20, 0x8c, 0x00, 0x00 },
{ 0xe0, 0xe7, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x04, 0x01, 0xfc, 0x41, 0x04, 0x21, 0xfc, 0x11, 0x10, 0x02, 0x20, 0x03, 0xfe, 0x76, 0x20, 0x13, 0xfc, 0x12, 0x20, 0x13, 0xfe, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe0, 0xe8, 0x01, 0x48, 0x7d, 0x4a, 0x12, 0xa9, 0x12, 0xa8, 0x17, 0xff, 0x39, 0x48, 0x2b, 0x68, 0x29, 0x4a, 0x6b, 0x6a, 0x59, 0x4a, 0x13, 0x6c, 0x11, 0x44, 0x21, 0xed, 0x27, 0x13, 0x40, 0x21, 0x00, 0x00 },
{ 0xe0, 0xe9, 0x11, 0x48, 0x11, 0x4a, 0x22, 0xa9, 0x42, 0xa8, 0x2f, 0xff, 0x11, 0x48, 0x13, 0x6a, 0x29, 0x4a, 0x7b, 0x6a, 0x11, 0x4a, 0x57, 0x64, 0x55, 0x45, 0x51, 0xed, 0x17, 0x13, 0x10, 0x21, 0x00, 0x00 },
{ 0xe0, 0xea, 0x10, 0x40, 0x10, 0x7c, 0x10, 0x88, 0x7d, 0xff, 0x57, 0x28, 0x55, 0x4f, 0x55, 0x00, 0x55, 0xff, 0x55, 0x00, 0x7d, 0x7e, 0x11, 0x00, 0x15, 0x7e, 0x15, 0x42, 0x1a, 0x42, 0x62, 0x7e, 0x00, 0x00 },
{ 0xe0, 0xeb, 0x00, 0x20, 0x3c, 0x3c, 0x24, 0x44, 0x24, 0xff, 0x3d, 0xa8, 0x24, 0xaf, 0x24, 0xc0, 0x3c, 0xbe, 0x24, 0x80, 0x24, 0xff, 0x24, 0x80, 0x3c, 0xbe, 0x01, 0x22, 0x29, 0x22, 0x46, 0x3e, 0x00, 0x00 },
{ 0xe0, 0xec, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x41, 0x02, 0x42, 0x82, 0x44, 0x42, 0x58, 0x32, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe0, 0xed, 0x7c, 0x20, 0x44, 0x20, 0x47, 0xff, 0x48, 0x20, 0x4b, 0x2c, 0x51, 0x24, 0x49, 0x24, 0x4a, 0xaa, 0x46, 0xb1, 0x44, 0x50, 0x44, 0x48, 0x58, 0x88, 0x41, 0x04, 0x42, 0x02, 0x44, 0x01, 0x00, 0x00 },
{ 0xe0, 0xee, 0x13, 0xfe, 0x10, 0x88, 0x10, 0xf8, 0x7c, 0x88, 0x10, 0xf8, 0x10, 0x8e, 0x13, 0xf8, 0x18, 0x08, 0x77, 0xff, 0x12, 0x52, 0x13, 0xde, 0x12, 0x52, 0x12, 0xd7, 0x17, 0x5a, 0x30, 0x42, 0x00, 0x00 },
{ 0xe0, 0xef, 0x20, 0x20, 0x10, 0x20, 0x09, 0x3e, 0x01, 0x20, 0x41, 0x20, 0x27, 0xff, 0x10, 0x20, 0x01, 0x20, 0x01, 0x22, 0x12, 0x22, 0x14, 0x24, 0x20, 0x64, 0x20, 0x08, 0x40, 0x30, 0x43, 0xc0, 0x00, 0x00 },
{ 0xe0, 0xf0, 0x10, 0x04, 0x15, 0xc5, 0x58, 0x16, 0x51, 0xd4, 0x10, 0x04, 0x29, 0xca, 0x25, 0x4a, 0x45, 0xd1, 0x00, 0x00, 0x3f, 0xfc, 0x04, 0x08, 0x03, 0x30, 0x00, 0xc0, 0x07, 0x38, 0x78, 0x07, 0x00, 0x00 },
{ 0xe0, 0xf1, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x11, 0x10, 0x11, 0x10, 0x7f, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xe0, 0xf2, 0x10, 0x08, 0x10, 0x0a, 0x10, 0x09, 0x11, 0xff, 0x7d, 0x08, 0x11, 0x08, 0x11, 0xe9, 0x11, 0x29, 0x11, 0x29, 0x11, 0x2a, 0x1d, 0x2a, 0x71, 0x64, 0x02, 0x0c, 0x02, 0x15, 0x04, 0x63, 0x00, 0x00 },
{ 0xe0, 0xf3, 0x10, 0x10, 0x10, 0x90, 0x10, 0x90, 0x7d, 0x10, 0x25, 0xff, 0x26, 0x10, 0x24, 0x10, 0x24, 0x10, 0x44, 0xfe, 0x68, 0x10, 0x58, 0x10, 0x08, 0x10, 0x14, 0x10, 0x23, 0xff, 0x41, 0x00, 0x00, 0x00 },
{ 0xe0, 0xf4, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x91, 0x00, 0x88, 0x3f, 0xfe, 0x20, 0x88, 0x20, 0x48, 0x3e, 0x50, 0x22, 0x50, 0x22, 0x20, 0x2c, 0x52, 0x41, 0x8a, 0x46, 0x06, 0x00, 0x00 },
{ 0xe0, 0xf5, 0x10, 0x10, 0x10, 0x90, 0x10, 0x90, 0x59, 0xff, 0x56, 0x10, 0x54, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xe0, 0xf6, 0x10, 0x00, 0x11, 0xfc, 0x19, 0x04, 0x55, 0xfc, 0x55, 0x04, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x00, 0x11, 0x20, 0x11, 0xfe, 0x12, 0x20, 0x15, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xe0, 0xf7, 0x00, 0x44, 0x00, 0x42, 0x3f, 0xff, 0x20, 0x40, 0x20, 0x40, 0x20, 0x42, 0x3e, 0x42, 0x22, 0x24, 0x22, 0x24, 0x22, 0x28, 0x22, 0x10, 0x2c, 0x29, 0x40, 0x45, 0x41, 0x83, 0x46, 0x01, 0x00, 0x00 },
{ 0xe0, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x10, 0x80, 0x3f, 0xfe, 0x20, 0x80, 0x40, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe0, 0xf9, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x50, 0x00, 0x48, 0x3f, 0xfe, 0x20, 0x40, 0x3f, 0x24, 0x22, 0x28, 0x22, 0x11, 0x4c, 0x6d, 0x41, 0x83, 0x00, 0x00 },
{ 0xe0, 0xfa, 0x04, 0x00, 0x45, 0xfe, 0x29, 0x02, 0x11, 0xfe, 0x31, 0x02, 0x51, 0xfe, 0x08, 0x90, 0x08, 0x90, 0x19, 0xff, 0x29, 0x10, 0x4a, 0x10, 0x08, 0xfe, 0x08, 0x10, 0x08, 0x10, 0x33, 0xff, 0x00, 0x00 },
{ 0xe0, 0xfb, 0x00, 0x08, 0x7c, 0x0a, 0x10, 0x09, 0x11, 0xff, 0x11, 0x08, 0x11, 0x08, 0x7d, 0x09, 0x11, 0xe9, 0x11, 0x29, 0x11, 0x2a, 0x1d, 0x2a, 0x71, 0x65, 0x02, 0x0d, 0x02, 0x15, 0x04, 0x63, 0x00, 0x00 },
{ 0xe0, 0xfc, 0x00, 0x48, 0x00, 0x44, 0x3f, 0xff, 0x20, 0x40, 0x20, 0x44, 0x3e, 0x28, 0x22, 0x10, 0x22, 0x31, 0x2c, 0xcd, 0x43, 0x03, 0x40, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe0, 0xfd, 0x00, 0x80, 0x04, 0x84, 0x08, 0x82, 0x10, 0x99, 0x23, 0x91, 0x00, 0x60, 0x01, 0x80, 0x0f, 0xfc, 0x74, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xe0, 0xfe, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x40, 0x00, 0x50, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x40, 0x1f, 0x24, 0x11, 0x28, 0x11, 0x11, 0x26, 0x29, 0x20, 0xc5, 0x43, 0x03, 0x00, 0x00 },
{ 0xe1, 0xa1, 0x00, 0x00, 0x7f, 0x80, 0x21, 0x3f, 0x3f, 0x21, 0x21, 0x21, 0x2f, 0x21, 0x71, 0x3f, 0x01, 0x00, 0x00, 0x78, 0x1f, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe1, 0xa2, 0x08, 0x00, 0x7f, 0xbc, 0x08, 0x25, 0x3f, 0x47, 0x00, 0x7c, 0x3f, 0x24, 0x29, 0x18, 0x3f, 0xe7, 0x20, 0x00, 0x5f, 0xfe, 0x04, 0x08, 0x07, 0xf8, 0x04, 0x0f, 0x3f, 0xf8, 0x00, 0x08, 0x00, 0x00 },
{ 0xe1, 0xa3, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x10, 0x24, 0x90, 0x3c, 0xfe, 0x25, 0x10, 0x24, 0xfe, 0x24, 0x10, 0x44, 0x10, 0x4d, 0xff, 0x00, 0x00 },
{ 0xe1, 0xa4, 0x00, 0x0a, 0x3c, 0x09, 0x00, 0x08, 0x7d, 0xff, 0x01, 0x08, 0x3d, 0x08, 0x01, 0xe9, 0x3d, 0x29, 0x01, 0x2a, 0x01, 0x2a, 0x3d, 0x24, 0x25, 0x6d, 0x25, 0x15, 0x25, 0x23, 0x3e, 0x41, 0x00, 0x00 },
{ 0xe1, 0xa5, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x7c, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x54, 0x90, 0x6c, 0xfe, 0x45, 0x10, 0x44, 0x10, 0x7c, 0xfe, 0x44, 0x10, 0x44, 0x10, 0x7d, 0xff, 0x00, 0x00 },
{ 0xe1, 0xa6, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x7f, 0xff, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xa7, 0x08, 0x10, 0x3e, 0x10, 0x08, 0x7c, 0x7f, 0x14, 0x24, 0x54, 0x47, 0x25, 0x08, 0x35, 0x3e, 0x53, 0x08, 0x81, 0x7e, 0x00, 0x01, 0x00, 0x3f, 0xfe, 0x02, 0x02, 0x0c, 0x02, 0x70, 0x1c, 0x00, 0x00 },
{ 0xe1, 0xa8, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x7f, 0xff, 0x00, 0x24, 0x3f, 0xff, 0x20, 0x20, 0x2f, 0x92, 0x22, 0x12, 0x2a, 0x94, 0x2a, 0x4c, 0x32, 0x59, 0x46, 0x25, 0x40, 0xc3, 0x00, 0x00 },
{ 0xe1, 0xa9, 0x20, 0x20, 0x11, 0x20, 0x09, 0x20, 0x03, 0xfe, 0x42, 0x20, 0x24, 0x20, 0x10, 0x20, 0x07, 0xff, 0x00, 0x88, 0x10, 0x88, 0x10, 0x88, 0x21, 0x08, 0x21, 0x09, 0x42, 0x09, 0x44, 0x0f, 0x00, 0x00 },
{ 0xe1, 0xaa, 0x0c, 0x1c, 0x70, 0x44, 0x10, 0x82, 0x13, 0x01, 0x7c, 0xfe, 0x10, 0x82, 0x18, 0x82, 0x38, 0x82, 0x34, 0xfe, 0x54, 0x28, 0x50, 0x28, 0x50, 0x49, 0x10, 0x49, 0x10, 0x89, 0x13, 0x07, 0x00, 0x00 },
{ 0xe1, 0xab, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x08, 0x88, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x08, 0xf8, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xac, 0x08, 0x00, 0x08, 0x7f, 0x52, 0x49, 0x22, 0x49, 0x14, 0x49, 0x08, 0x49, 0x12, 0x49, 0x7f, 0x7f, 0x09, 0x49, 0x08, 0x49, 0x2a, 0x49, 0x29, 0x49, 0x49, 0x49, 0x48, 0x7f, 0x08, 0x00, 0x00, 0x00 },
{ 0xe1, 0xad, 0x00, 0x5c, 0x3c, 0x44, 0x00, 0x82, 0x01, 0x01, 0x7e, 0xfe, 0x00, 0x82, 0x3c, 0x82, 0x00, 0x82, 0x3c, 0xfe, 0x00, 0x28, 0x00, 0x28, 0x3c, 0x49, 0x24, 0x49, 0x24, 0x89, 0x3f, 0x07, 0x00, 0x00 },
{ 0xe1, 0xae, 0x08, 0x88, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x08, 0xf8, 0x08, 0x00, 0x1f, 0xfe, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x18, 0x38, 0x06, 0x00, 0x00 },
{ 0xe1, 0xaf, 0x00, 0x00, 0x3f, 0xfe, 0x01, 0x02, 0x01, 0x02, 0x02, 0x02, 0x04, 0x02, 0x08, 0x04, 0x30, 0x18, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe1, 0xb0, 0x00, 0x20, 0x7b, 0xfc, 0x48, 0x24, 0x4f, 0xff, 0x48, 0x24, 0x4b, 0xfc, 0x48, 0x20, 0x4a, 0xaa, 0x4b, 0xae, 0x4a, 0x22, 0x7b, 0xfe, 0x02, 0x22, 0x07, 0xae, 0x04, 0xaa, 0x08, 0xaa, 0x00, 0x00 },
{ 0xe1, 0xb1, 0x21, 0x00, 0x12, 0x1f, 0x7f, 0xd1, 0x04, 0x1f, 0x24, 0x91, 0x24, 0x9f, 0x24, 0x91, 0x3f, 0xa1, 0x08, 0x21, 0x10, 0x47, 0x60, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe1, 0xb2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x42, 0xa1, 0x04, 0x90, 0x08, 0x88, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xe1, 0xb3, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x10, 0x84, 0x10, 0x84, 0x10, 0x82, 0x10, 0x82, 0x20, 0x82, 0x20, 0x81, 0x20, 0x81, 0x40, 0x81, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe1, 0xb4, 0x00, 0x80, 0x00, 0x80, 0x08, 0x88, 0x08, 0x84, 0x10, 0x82, 0x10, 0x81, 0x20, 0x81, 0x40, 0x84, 0x00, 0x84, 0x03, 0x88, 0x00, 0x10, 0x00, 0x20, 0x00, 0xc0, 0x07, 0x00, 0x38, 0x00, 0x00, 0x00 },
{ 0xe1, 0xb5, 0x08, 0x84, 0x11, 0x08, 0x11, 0x08, 0x08, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x06, 0xb0, 0x38, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xe1, 0xb6, 0x07, 0x06, 0x38, 0x78, 0x20, 0x40, 0x20, 0x40, 0x3f, 0x40, 0x21, 0x7f, 0x21, 0x44, 0x21, 0x44, 0x3f, 0x44, 0x20, 0x44, 0x20, 0x44, 0x20, 0x44, 0x20, 0x84, 0x40, 0x84, 0x41, 0x04, 0x00, 0x00 },
{ 0xe1, 0xb7, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x02, 0x7c, 0xfe, 0x10, 0x02, 0x10, 0xfe, 0x10, 0x00, 0x1d, 0xff, 0x71, 0x11, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x10, 0x96, 0x30, 0x10, 0x00, 0x00 },
{ 0xe1, 0xb8, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x52, 0x7c, 0x54, 0x11, 0x28, 0x11, 0x10, 0x10, 0x6c, 0x1d, 0x93, 0x70, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x10, 0xfe, 0x10, 0x11, 0x10, 0x1f, 0x61, 0xf1, 0x00, 0x00 },
{ 0xe1, 0xb9, 0x00, 0x00, 0x01, 0xff, 0x7c, 0x21, 0x44, 0x21, 0x44, 0x41, 0x44, 0x41, 0x7c, 0x81, 0x45, 0x06, 0x44, 0x00, 0x44, 0xff, 0x44, 0x81, 0x7c, 0x81, 0x00, 0x81, 0x00, 0x81, 0x00, 0xff, 0x00, 0x00 },
{ 0xe1, 0xba, 0x10, 0x40, 0x10, 0x40, 0x13, 0xfe, 0x7c, 0x80, 0x10, 0x88, 0x11, 0x34, 0x3b, 0xc2, 0x38, 0x00, 0x36, 0x48, 0x52, 0x48, 0x52, 0x48, 0x52, 0x48, 0x12, 0x49, 0x14, 0x49, 0x14, 0x4f, 0x00, 0x00 },
{ 0xe1, 0xbb, 0x20, 0x00, 0x13, 0xff, 0x08, 0x41, 0x00, 0x41, 0x40, 0x81, 0x20, 0x81, 0x11, 0x01, 0x02, 0x06, 0x00, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xbc, 0x20, 0x20, 0x10, 0xa8, 0x09, 0x24, 0x02, 0x22, 0x43, 0xfe, 0x22, 0x02, 0x12, 0x02, 0x03, 0xfe, 0x02, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x22, 0x02, 0x22, 0x02, 0x42, 0x02, 0x42, 0x0e, 0x00, 0x00 },
{ 0xe1, 0xbd, 0x22, 0x20, 0x11, 0x2f, 0x09, 0x49, 0x00, 0x89, 0x43, 0xe9, 0x20, 0x8f, 0x12, 0xa9, 0x02, 0xa9, 0x02, 0xa9, 0x12, 0xaf, 0x13, 0xe9, 0x20, 0x89, 0x21, 0x11, 0x41, 0x11, 0x42, 0x23, 0x00, 0x00 },
{ 0xe1, 0xbe, 0x21, 0x10, 0x17, 0xfe, 0x09, 0x50, 0x03, 0xfc, 0x40, 0x44, 0x27, 0xff, 0x10, 0x44, 0x03, 0xfc, 0x05, 0x52, 0x15, 0x52, 0x17, 0xfe, 0x24, 0x42, 0x27, 0x5e, 0x45, 0x52, 0x49, 0x52, 0x00, 0x00 },
{ 0xe1, 0xbf, 0x10, 0x00, 0x11, 0xfe, 0x14, 0x22, 0x14, 0x22, 0x58, 0x42, 0x50, 0x42, 0x50, 0x84, 0x11, 0x18, 0x10, 0x00, 0x11, 0xfe, 0x19, 0x02, 0x25, 0x02, 0x25, 0x02, 0x21, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xc0, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x57, 0xff, 0x58, 0x84, 0x53, 0xdf, 0x50, 0x84, 0x10, 0xe4, 0x13, 0x9f, 0x10, 0x00, 0x2b, 0xff, 0x24, 0x90, 0x20, 0x91, 0x41, 0x11, 0x46, 0x0f, 0x00, 0x00 },
{ 0xe1, 0xc1, 0x00, 0x08, 0x7f, 0x88, 0x08, 0x28, 0x3f, 0x3f, 0x29, 0x48, 0x3f, 0x48, 0x29, 0x08, 0x29, 0x3e, 0x3f, 0x08, 0x08, 0x08, 0x28, 0x08, 0x18, 0xff, 0x0c, 0x00, 0x13, 0x00, 0x60, 0xff, 0x00, 0x00 },
{ 0xe1, 0xc2, 0x00, 0x20, 0x7e, 0x20, 0x05, 0xfe, 0x08, 0x40, 0x10, 0x48, 0x50, 0x9c, 0x51, 0xe2, 0x5c, 0x00, 0x51, 0x24, 0x51, 0x24, 0x51, 0x24, 0x51, 0x25, 0x5d, 0x25, 0x72, 0x25, 0x04, 0x23, 0x00, 0x00 },
{ 0xe1, 0xc3, 0x00, 0x10, 0x7e, 0x10, 0x05, 0xff, 0x08, 0x10, 0x08, 0xfe, 0x28, 0x92, 0x28, 0x92, 0x2e, 0x92, 0x28, 0xfe, 0x28, 0x10, 0x28, 0x38, 0x2e, 0x54, 0x39, 0x93, 0x60, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe1, 0xc4, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x50, 0x00, 0x37, 0xfc, 0x12, 0x48, 0x15, 0xb0, 0x12, 0xf0, 0x37, 0x4e, 0x57, 0xfc, 0x54, 0x44, 0x17, 0xfc, 0x20, 0x44, 0x20, 0x7e, 0x47, 0xc1, 0x00, 0x00 },
{ 0xe1, 0xc5, 0x10, 0x20, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x44, 0x42, 0x82, 0x00, 0x7c, 0x1f, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x30, 0x06, 0x00, 0x00 },
{ 0xe1, 0xc6, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x10, 0x40, 0x10, 0xff, 0x21, 0x44, 0x24, 0x38, 0x65, 0xc7, 0x24, 0x10, 0x25, 0xff, 0x24, 0x38, 0x24, 0x54, 0x25, 0x93, 0x20, 0x10, 0x00, 0x00 },
{ 0xe1, 0xc7, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x5f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x3f, 0xfc, 0x24, 0x92, 0x24, 0x92, 0x3f, 0xfe, 0x20, 0x82, 0x3c, 0x9e, 0x24, 0x92, 0x44, 0x92, 0x00, 0x00 },
{ 0xe1, 0xc8, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x09, 0x10, 0x06, 0x24, 0x01, 0x46, 0x3f, 0xf9, 0x00, 0x80, 0x04, 0x98, 0x08, 0x84, 0x30, 0x82, 0x00, 0x00 },
{ 0xe1, 0xc9, 0x10, 0x00, 0x11, 0xff, 0x24, 0x21, 0x44, 0x21, 0x28, 0x41, 0x10, 0x41, 0x10, 0x81, 0x25, 0x0e, 0x7c, 0x00, 0x10, 0xff, 0x54, 0x81, 0x54, 0x81, 0x50, 0x81, 0x10, 0x81, 0x10, 0xff, 0x00, 0x00 },
{ 0xe1, 0xca, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x10, 0x3e, 0x10, 0x02, 0xfe, 0x04, 0x20, 0x08, 0x4c, 0x28, 0xf2, 0x2f, 0x00, 0x28, 0x54, 0x28, 0x54, 0x2b, 0x54, 0x3c, 0x95, 0x61, 0x17, 0x00, 0x00 },
{ 0xe1, 0xcb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x12, 0xa2, 0x12, 0xa2, 0x1f, 0xfe, 0x10, 0x82, 0x1e, 0xbe, 0x22, 0xa2, 0x42, 0xa2, 0x00, 0x00 },
{ 0xe1, 0xcc, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x10, 0x00, 0x1e, 0x0e, 0x12, 0x38, 0x24, 0x08, 0x7f, 0xff, 0x24, 0x9c, 0x3f, 0x9c, 0x24, 0xaa, 0x3f, 0xaa, 0x00, 0x09, 0x2a, 0x88, 0x4a, 0x48, 0x00, 0x00 },
{ 0xe1, 0xcd, 0x00, 0x06, 0x3c, 0x18, 0x00, 0xe0, 0x7e, 0x80, 0x00, 0x80, 0x3c, 0xff, 0x00, 0x88, 0x3c, 0x88, 0x00, 0x88, 0x00, 0xb8, 0x3c, 0x8e, 0x24, 0x89, 0x25, 0x08, 0x25, 0x08, 0x3d, 0x08, 0x00, 0x00 },
{ 0xe1, 0xce, 0x20, 0x20, 0x11, 0x24, 0x02, 0x22, 0x45, 0xfd, 0x21, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x01, 0x04, 0x71, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0x1c, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe1, 0xcf, 0x22, 0x20, 0x11, 0x2f, 0x08, 0x49, 0x43, 0xe9, 0x20, 0x8f, 0x10, 0x89, 0x02, 0xa9, 0x02, 0xaf, 0x72, 0xa9, 0x13, 0xe9, 0x10, 0x89, 0x11, 0x11, 0x12, 0x13, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe1, 0xd0, 0x00, 0x00, 0x7f, 0x9f, 0x08, 0x91, 0x08, 0x92, 0x10, 0x92, 0x10, 0x94, 0x20, 0x92, 0x43, 0x12, 0x00, 0x11, 0x3f, 0x91, 0x20, 0x91, 0x20, 0x91, 0x20, 0x96, 0x20, 0x90, 0x3f, 0x90, 0x00, 0x00 },
{ 0xe1, 0xd1, 0x18, 0x10, 0x24, 0x92, 0x40, 0x91, 0x01, 0x11, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x54, 0xfe, 0x34, 0x82, 0x10, 0x82, 0x18, 0x82, 0x60, 0x8e, 0x00, 0x00 },
{ 0xe1, 0xd2, 0x08, 0x00, 0x08, 0x7f, 0x7f, 0x11, 0x22, 0x11, 0x14, 0x21, 0x7f, 0x21, 0x00, 0x46, 0x00, 0x00, 0x3e, 0x7f, 0x22, 0x41, 0x22, 0x41, 0x3e, 0x41, 0x22, 0x41, 0x22, 0x41, 0x3e, 0x7f, 0x00, 0x00 },
{ 0xe1, 0xd3, 0x00, 0x00, 0x3e, 0xfe, 0x28, 0x2a, 0x3e, 0x22, 0x28, 0x94, 0x3e, 0x48, 0x28, 0x34, 0x29, 0xd3, 0x3e, 0x7e, 0x02, 0x52, 0x52, 0x52, 0x52, 0x7e, 0x44, 0x14, 0x04, 0x16, 0x18, 0xf9, 0x00, 0x00 },
{ 0xe1, 0xd4, 0x08, 0x88, 0x09, 0x04, 0x12, 0x02, 0x10, 0x20, 0x30, 0x50, 0x30, 0x88, 0x51, 0x04, 0x16, 0x03, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xe1, 0xd5, 0x3f, 0xfc, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x80, 0x2e, 0xb8, 0x20, 0x00, 0x2f, 0xfc, 0x29, 0x24, 0x2f, 0xfc, 0x24, 0x00, 0x2f, 0xfe, 0x54, 0x92, 0x47, 0xf2, 0x40, 0xa2, 0x0f, 0xdc, 0x00, 0x00 },
{ 0xe1, 0xd6, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe1, 0xd7, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x00, 0x20, 0x41, 0xfc, 0x21, 0x24, 0x11, 0x24, 0x01, 0x24, 0x01, 0xfc, 0x10, 0x70, 0x10, 0x70, 0x20, 0xa8, 0x21, 0x24, 0x46, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xe1, 0xd8, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe1, 0xd9, 0x10, 0x20, 0x13, 0xff, 0x24, 0x20, 0x45, 0xfe, 0x29, 0x52, 0x11, 0x9e, 0x11, 0x02, 0x25, 0xfe, 0x7c, 0x84, 0x14, 0xfc, 0x50, 0x84, 0x54, 0xfc, 0x54, 0x84, 0x10, 0xfc, 0x13, 0x87, 0x00, 0x00 },
{ 0xe1, 0xda, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x92, 0x7e, 0xfe, 0x00, 0x92, 0x3c, 0xfe, 0x00, 0x28, 0x3c, 0x49, 0x01, 0xaf, 0x00, 0x20, 0x3c, 0x7e, 0x25, 0xc2, 0x24, 0x24, 0x24, 0x3c, 0x3d, 0xc3, 0x00, 0x00 },
{ 0xe1, 0xdb, 0x00, 0x10, 0x3d, 0xff, 0x24, 0x10, 0x24, 0xfe, 0x3c, 0x00, 0x25, 0xff, 0x25, 0x29, 0x3d, 0x29, 0x25, 0xff, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x82, 0x00, 0xfe, 0x28, 0x44, 0x45, 0x83, 0x00, 0x00 },
{ 0xe1, 0xdc, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x40, 0x20, 0x21, 0xfc, 0x11, 0x24, 0x01, 0x24, 0x01, 0xfc, 0x70, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe1, 0xdd, 0x00, 0x0c, 0x7f, 0x70, 0x02, 0x10, 0x04, 0x24, 0x08, 0xa4, 0x08, 0x48, 0x0a, 0x32, 0x0c, 0x22, 0x19, 0xff, 0x68, 0x11, 0x08, 0x54, 0x08, 0x52, 0x08, 0x91, 0x09, 0x11, 0x38, 0x10, 0x00, 0x00 },
{ 0xe1, 0xde, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x20, 0x20, 0x21, 0x21, 0x1f, 0x1f, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00, 0x0c, 0x1c, 0x30, 0x02, 0x00, 0x00 },
{ 0xe1, 0xdf, 0x10, 0x00, 0x10, 0xff, 0x10, 0x81, 0x7c, 0xff, 0x10, 0x00, 0x10, 0xff, 0x10, 0x81, 0x1c, 0xff, 0x70, 0x81, 0x10, 0xff, 0x10, 0x81, 0x10, 0xff, 0x10, 0x00, 0x10, 0x46, 0x31, 0x81, 0x00, 0x00 },
{ 0xe1, 0xe0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x0e, 0x7e, 0xf0, 0x03, 0x10, 0x04, 0x24, 0x08, 0xc8, 0x0e, 0x32, 0x78, 0x1f, 0x09, 0xf1, 0x08, 0x10, 0x08, 0x94, 0x38, 0x92, 0x11, 0x12, 0x00, 0x00 },
{ 0xe1, 0xe1, 0x20, 0x02, 0x13, 0xbc, 0x08, 0x88, 0x40, 0x88, 0x21, 0x32, 0x11, 0x14, 0x01, 0x08, 0x71, 0x92, 0x17, 0x7d, 0x11, 0x08, 0x11, 0x2a, 0x11, 0x49, 0x13, 0x08, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe1, 0xe2, 0x00, 0x20, 0x00, 0x50, 0x40, 0x88, 0x21, 0x74, 0x16, 0x03, 0x00, 0xf8, 0x00, 0x88, 0x10, 0xf8, 0x10, 0x88, 0x10, 0xf8, 0x20, 0xa2, 0x20, 0x94, 0x20, 0xa8, 0x40, 0xc4, 0x41, 0x83, 0x00, 0x00 },
{ 0xe1, 0xe3, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x21, 0x02, 0x16, 0x24, 0x02, 0x40, 0x11, 0x84, 0x21, 0x22, 0x47, 0xd1, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe1, 0xe4, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x81, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe1, 0xe5, 0x10, 0x20, 0x10, 0x20, 0x1b, 0xff, 0x54, 0x20, 0x54, 0x20, 0x51, 0xfe, 0x51, 0x22, 0x11, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0x20, 0x00, 0x00 },
{ 0xe1, 0xe6, 0x10, 0x1c, 0x10, 0x44, 0x10, 0x44, 0x7c, 0x44, 0x10, 0x84, 0x10, 0x82, 0x38, 0x82, 0x39, 0x21, 0x35, 0x21, 0x54, 0x40, 0x50, 0x48, 0x50, 0x44, 0x10, 0x84, 0x10, 0x9a, 0x11, 0xe2, 0x00, 0x00 },
{ 0xe1, 0xe7, 0x21, 0x0c, 0x11, 0x04, 0x01, 0x14, 0x07, 0xd4, 0x41, 0x12, 0x21, 0x12, 0x13, 0x22, 0x03, 0xa9, 0x03, 0x89, 0x15, 0x48, 0x15, 0x54, 0x25, 0x14, 0x21, 0x22, 0x41, 0x2f, 0x41, 0x71, 0x00, 0x00 },
{ 0xe1, 0xe8, 0x00, 0x1c, 0x3c, 0x44, 0x00, 0x44, 0x00, 0x42, 0x7e, 0x82, 0x00, 0x82, 0x3c, 0x91, 0x01, 0x11, 0x3c, 0x10, 0x00, 0x20, 0x3c, 0x24, 0x24, 0x22, 0x24, 0x42, 0x24, 0x5d, 0x3d, 0xe1, 0x00, 0x00 },
{ 0xe1, 0xe9, 0x00, 0x00, 0x3c, 0xfc, 0x00, 0x04, 0x7e, 0x28, 0x00, 0x10, 0x3c, 0xfe, 0x00, 0x92, 0x3c, 0x92, 0x00, 0xfe, 0x00, 0x92, 0x3c, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x3c, 0x96, 0x00, 0x00 },
{ 0xe1, 0xea, 0x20, 0x3c, 0x11, 0x04, 0x09, 0x04, 0x42, 0x02, 0x25, 0xfd, 0x10, 0x20, 0x00, 0x20, 0x03, 0xfe, 0x70, 0x20, 0x10, 0x50, 0x10, 0x48, 0x10, 0x84, 0x13, 0x02, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe1, 0xeb, 0x0c, 0x00, 0x24, 0x7f, 0x24, 0x08, 0x24, 0x10, 0x22, 0x3e, 0x42, 0x22, 0x49, 0x3e, 0x49, 0x22, 0x10, 0x3e, 0x14, 0x22, 0x12, 0x22, 0x27, 0x3e, 0x39, 0x00, 0x60, 0x14, 0x00, 0x63, 0x00, 0x00 },
{ 0xe1, 0xec, 0x00, 0x01, 0x3f, 0xc1, 0x20, 0x49, 0x20, 0x49, 0x3f, 0xc9, 0x22, 0x09, 0x22, 0x09, 0x2f, 0xc9, 0x2a, 0x49, 0x2a, 0x49, 0x2a, 0x49, 0x2a, 0x49, 0x4a, 0xc1, 0x42, 0x01, 0x42, 0x07, 0x00, 0x00 },
{ 0xe1, 0xed, 0x02, 0x00, 0x34, 0x78, 0x0c, 0x48, 0x12, 0x49, 0x24, 0x49, 0x4a, 0x4f, 0x08, 0x80, 0x7e, 0xfe, 0x08, 0x44, 0x1c, 0x44, 0x1a, 0x28, 0x2a, 0x10, 0x48, 0x28, 0x08, 0xc4, 0x0b, 0x03, 0x00, 0x00 },
{ 0xe1, 0xee, 0x27, 0xdf, 0x10, 0x00, 0x0f, 0xdf, 0x04, 0x51, 0x45, 0x55, 0x20, 0x20, 0x17, 0xff, 0x04, 0x90, 0x07, 0xfe, 0x14, 0x92, 0x17, 0xfe, 0x25, 0x13, 0x29, 0xdc, 0x49, 0x11, 0x4b, 0xdf, 0x00, 0x00 },
{ 0xe1, 0xef, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x44, 0x10, 0x44, 0x20, 0xaa, 0x3c, 0xaa, 0x25, 0x11, 0x64, 0x00, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x3c, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe1, 0xf0, 0x08, 0x10, 0x14, 0x92, 0x22, 0x54, 0x40, 0xfe, 0x3e, 0x82, 0x08, 0x82, 0x08, 0xfe, 0x7e, 0x82, 0x08, 0x82, 0x4a, 0xfe, 0x2a, 0x82, 0x28, 0x82, 0x08, 0xfe, 0x0e, 0x44, 0x71, 0x83, 0x00, 0x00 },
{ 0xe1, 0xf1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x42, 0x0c, 0x24, 0x74, 0x28, 0x04, 0x10, 0x07, 0xcc, 0x3c, 0x03, 0x00, 0x00 },
{ 0xe1, 0xf2, 0x08, 0x02, 0x14, 0x02, 0x12, 0x22, 0x21, 0x22, 0x21, 0x22, 0x5e, 0x22, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x22, 0x49, 0x22, 0x2a, 0x02, 0x28, 0x02, 0x0f, 0x02, 0x78, 0x0e, 0x00, 0x00 },
{ 0xe1, 0xf3, 0x08, 0x40, 0x08, 0x40, 0x10, 0x7f, 0x10, 0xc4, 0x35, 0x28, 0x34, 0x10, 0x54, 0x6c, 0x15, 0x83, 0x14, 0x08, 0x14, 0x30, 0x14, 0xc4, 0x14, 0x18, 0x14, 0xe2, 0x10, 0x1c, 0x11, 0xe0, 0x00, 0x00 },
{ 0xe1, 0xf4, 0x00, 0x1e, 0x3f, 0xe2, 0x08, 0x84, 0x04, 0x48, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x1f, 0xf8, 0x04, 0x08, 0x02, 0x10, 0x01, 0x20, 0x00, 0xc0, 0x03, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xe1, 0xf5, 0x01, 0x10, 0x01, 0x10, 0x77, 0xd0, 0x51, 0x10, 0x51, 0x3f, 0x57, 0xe9, 0x55, 0x4a, 0x55, 0x48, 0x57, 0xdc, 0x53, 0x14, 0x73, 0x94, 0x05, 0x54, 0x09, 0x22, 0x11, 0x22, 0x01, 0x41, 0x00, 0x00 },
{ 0xe1, 0xf6, 0x7f, 0xfe, 0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x41, 0x02, 0x41, 0x02, 0x42, 0x82, 0x42, 0x82, 0x44, 0x42, 0x44, 0x42, 0x48, 0x22, 0x50, 0x12, 0x40, 0x02, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xf7, 0x00, 0x3c, 0x3f, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x88, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe1, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x01, 0x0f, 0xf1, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x04, 0x3e, 0xff, 0x22, 0x44, 0x3e, 0x24, 0x00, 0x0c, 0x00, 0x00 },
{ 0xe1, 0xf9, 0x10, 0xa0, 0x11, 0x2e, 0x11, 0x22, 0x7d, 0xae, 0x25, 0x22, 0x25, 0x22, 0x25, 0xfe, 0x24, 0x20, 0x44, 0x20, 0x69, 0xfe, 0x58, 0x84, 0x0c, 0x48, 0x12, 0x30, 0x20, 0xcc, 0x43, 0x03, 0x00, 0x00 },
{ 0xe1, 0xfa, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x11, 0x40, 0x11, 0x00, 0x10, 0x7f, 0xff, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x04, 0x10, 0x02, 0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xe1, 0xfb, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x54, 0xfe, 0x54, 0x92, 0x54, 0x92, 0x54, 0x92, 0x54, 0x92, 0x54, 0xfe, 0x54, 0x92, 0x54, 0x92, 0x7c, 0x92, 0x00, 0x92, 0x00, 0xfe, 0x00, 0x00 },
{ 0xe1, 0xfc, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xe1, 0xfd, 0x10, 0x10, 0x20, 0x10, 0x7c, 0x10, 0x44, 0xfe, 0x44, 0x92, 0x44, 0x92, 0x7c, 0x92, 0x40, 0x92, 0x40, 0x92, 0x7c, 0x92, 0x44, 0x92, 0x44, 0x96, 0x44, 0x10, 0x7c, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe1, 0xfe, 0x06, 0x08, 0x38, 0x08, 0x08, 0x29, 0x7f, 0x2a, 0x08, 0x4c, 0x1c, 0x48, 0x2a, 0x14, 0x49, 0x14, 0x08, 0x22, 0x08, 0x41, 0x00, 0x00, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xe2, 0xa1, 0x00, 0x48, 0x00, 0x44, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x44, 0x14, 0x44, 0x12, 0x44, 0x12, 0x28, 0x10, 0x28, 0x10, 0x10, 0x20, 0x30, 0x20, 0x49, 0x21, 0x85, 0x46, 0x03, 0x00, 0x00 },
{ 0xe2, 0xa2, 0x00, 0x0c, 0x00, 0xf0, 0x3f, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe2, 0xa3, 0x10, 0x0f, 0x13, 0xf1, 0x11, 0x22, 0x7c, 0x94, 0x13, 0xff, 0x12, 0x01, 0x12, 0x01, 0x1d, 0xfc, 0x70, 0x84, 0x10, 0x84, 0x10, 0x48, 0x10, 0x30, 0x10, 0x30, 0x10, 0xcc, 0x33, 0x03, 0x00, 0x00 },
{ 0xe2, 0xa4, 0x10, 0xa0, 0x13, 0x2e, 0x12, 0x22, 0x7f, 0xae, 0x12, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x1c, 0x20, 0x70, 0x20, 0x13, 0xfc, 0x10, 0x84, 0x10, 0x48, 0x10, 0x30, 0x10, 0xcc, 0x33, 0x03, 0x00, 0x00 },
{ 0xe2, 0xa5, 0x04, 0x40, 0x04, 0x40, 0x24, 0x40, 0x24, 0xff, 0x24, 0xc4, 0x25, 0x44, 0x25, 0x44, 0x26, 0x44, 0x2c, 0x44, 0x34, 0x28, 0x64, 0x28, 0x04, 0x10, 0x04, 0x28, 0x04, 0x44, 0x05, 0x83, 0x00, 0x00 },
{ 0xe2, 0xa6, 0x04, 0x10, 0x3f, 0x90, 0x24, 0x90, 0x7f, 0xdf, 0x24, 0xa2, 0x3f, 0xa2, 0x04, 0x62, 0x3f, 0x92, 0x24, 0x94, 0x3f, 0x94, 0x04, 0x08, 0x7f, 0xc8, 0x11, 0x14, 0x1e, 0x22, 0x71, 0x41, 0x00, 0x00 },
{ 0xe2, 0xa7, 0x10, 0x82, 0x10, 0x82, 0x13, 0xe2, 0x7c, 0x82, 0x10, 0x8f, 0x13, 0xe2, 0x38, 0x02, 0x3b, 0xe2, 0x36, 0x2a, 0x52, 0x26, 0x53, 0xe2, 0x50, 0x02, 0x11, 0x22, 0x11, 0x72, 0x17, 0x86, 0x00, 0x00 },
{ 0xe2, 0xa8, 0x00, 0x10, 0x7e, 0x50, 0x10, 0x50, 0x10, 0xfe, 0x3f, 0x90, 0x22, 0x10, 0x22, 0x10, 0x42, 0xff, 0x14, 0x38, 0x0c, 0x38, 0x04, 0x54, 0x08, 0x54, 0x08, 0x92, 0x11, 0x11, 0x20, 0x10, 0x00, 0x00 },
{ 0xe2, 0xa9, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xc1, 0x7e, 0xc2, 0x02, 0xc4, 0x04, 0xa8, 0x04, 0xb0, 0x08, 0x90, 0x08, 0x88, 0x10, 0x84, 0x20, 0x82, 0x40, 0x81, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe2, 0xaa, 0x20, 0x20, 0x11, 0x20, 0x09, 0x20, 0x03, 0xfe, 0x42, 0x20, 0x24, 0x20, 0x10, 0x20, 0x07, 0xff, 0x00, 0x20, 0x10, 0x70, 0x10, 0xa8, 0x21, 0x24, 0x22, 0x22, 0x44, 0x21, 0x40, 0x20, 0x00, 0x00 },
{ 0xe2, 0xab, 0x41, 0x08, 0x21, 0x08, 0x17, 0xc8, 0x01, 0x0f, 0x41, 0x0a, 0x27, 0xd2, 0x15, 0x5a, 0x05, 0x6a, 0x07, 0xca, 0x11, 0x04, 0x13, 0x84, 0x23, 0x4c, 0x25, 0x4a, 0x49, 0x12, 0x41, 0x21, 0x00, 0x00 },
{ 0xe2, 0xac, 0x10, 0x1c, 0x12, 0x04, 0x11, 0x24, 0x54, 0x42, 0x58, 0xbd, 0x52, 0x10, 0x51, 0x32, 0x10, 0x5c, 0x17, 0x2c, 0x11, 0x5a, 0x29, 0x29, 0x25, 0x48, 0x21, 0x10, 0x42, 0xc0, 0x44, 0x3f, 0x00, 0x00 },
{ 0xe2, 0xad, 0x04, 0x10, 0x44, 0x10, 0x29, 0xff, 0x11, 0x01, 0x31, 0x01, 0x50, 0x04, 0x08, 0x04, 0x09, 0xff, 0x18, 0x04, 0x28, 0x04, 0x48, 0x44, 0x08, 0x24, 0x08, 0x04, 0x08, 0x04, 0x30, 0x1c, 0x00, 0x00 },
{ 0xe2, 0xae, 0x00, 0x08, 0x7b, 0xc8, 0x4a, 0x4a, 0x7b, 0xc9, 0x00, 0x08, 0x3f, 0xbf, 0x24, 0x88, 0x3f, 0x88, 0x24, 0x88, 0x3f, 0x94, 0x00, 0x14, 0x7f, 0xd4, 0x20, 0xa2, 0x20, 0xa2, 0x3f, 0xc1, 0x00, 0x00 },
{ 0xe2, 0xaf, 0x00, 0x1e, 0x7d, 0xf0, 0x10, 0x10, 0x13, 0xff, 0x10, 0x38, 0x10, 0x54, 0x7c, 0x92, 0x13, 0x01, 0x10, 0xfc, 0x10, 0x24, 0x10, 0x27, 0x1c, 0x41, 0x70, 0x41, 0x00, 0x81, 0x03, 0x0e, 0x00, 0x00 },
{ 0xe2, 0xb0, 0x00, 0x1c, 0x7a, 0x44, 0x21, 0x42, 0x20, 0xbe, 0x21, 0x11, 0x22, 0x28, 0x79, 0x4d, 0x20, 0x16, 0x27, 0x64, 0x21, 0x0e, 0x39, 0x15, 0x61, 0x64, 0x01, 0x18, 0x02, 0x80, 0x04, 0x7f, 0x00, 0x00 },
{ 0xe2, 0xb1, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x40, 0x56, 0x5c, 0x34, 0x44, 0x17, 0x5c, 0x14, 0x44, 0x37, 0xfc, 0x50, 0x40, 0x57, 0xfc, 0x12, 0x08, 0x21, 0xb0, 0x20, 0xe0, 0x4f, 0x1e, 0x00, 0x00 },
{ 0xe2, 0xb2, 0x00, 0x1e, 0x79, 0xe0, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x78, 0xa4, 0x48, 0xa4, 0x4b, 0xff, 0x78, 0xa4, 0x48, 0xa4, 0x4b, 0xff, 0x48, 0x20, 0x78, 0x20, 0x00, 0x20, 0x03, 0xff, 0x00, 0x00 },
{ 0xe2, 0xb3, 0x00, 0x78, 0x1f, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x03, 0x1f, 0xf0, 0x02, 0x20, 0x02, 0x3e, 0x04, 0x42, 0x04, 0x04, 0x08, 0x04, 0x30, 0x78, 0x00, 0x00 },
{ 0xe2, 0xb4, 0x0c, 0x20, 0x73, 0xff, 0x10, 0x20, 0x11, 0xfe, 0x7d, 0x22, 0x11, 0xfe, 0x11, 0x22, 0x39, 0xfe, 0x34, 0x24, 0x50, 0x3e, 0x51, 0xe1, 0x10, 0x24, 0x12, 0x92, 0x12, 0x85, 0x14, 0x7c, 0x00, 0x00 },
{ 0xe2, 0xb5, 0x00, 0x00, 0x3f, 0x7e, 0x24, 0x22, 0x3f, 0x22, 0x21, 0x14, 0x3f, 0x14, 0x24, 0x08, 0x24, 0x14, 0x3f, 0x63, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe2, 0xb6, 0x08, 0x10, 0x4a, 0x10, 0x2a, 0xff, 0x2c, 0x00, 0x08, 0x44, 0x7e, 0x44, 0x08, 0xaa, 0x19, 0x11, 0x1c, 0x00, 0x2a, 0x10, 0x29, 0xff, 0x48, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xe2, 0xb7, 0x10, 0x0e, 0x10, 0xf0, 0x24, 0x84, 0x44, 0x92, 0x29, 0x09, 0x10, 0x00, 0x10, 0x20, 0x24, 0x20, 0x7d, 0xff, 0x14, 0x44, 0x50, 0x84, 0x54, 0xe8, 0x54, 0x18, 0x10, 0x64, 0x11, 0x82, 0x00, 0x00 },
{ 0xe2, 0xb8, 0x10, 0x07, 0x11, 0xfa, 0x25, 0x22, 0x44, 0x94, 0x29, 0xff, 0x11, 0x01, 0x11, 0x01, 0x24, 0xfc, 0x7c, 0x44, 0x10, 0x44, 0x54, 0x28, 0x54, 0x10, 0x50, 0x28, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xe2, 0xb9, 0x10, 0x10, 0x10, 0xfe, 0x24, 0x12, 0x47, 0xff, 0x28, 0x12, 0x10, 0xfe, 0x10, 0x10, 0x25, 0x55, 0x7d, 0xd7, 0x11, 0x11, 0x55, 0xff, 0x55, 0x11, 0x51, 0xd7, 0x11, 0x55, 0x12, 0x55, 0x00, 0x00 },
{ 0xe2, 0xba, 0x04, 0x20, 0x02, 0x40, 0x7f, 0xfe, 0x01, 0x00, 0x3f, 0xfc, 0x01, 0x00, 0x7f, 0xfe, 0x08, 0x00, 0x0f, 0xf0, 0x09, 0x10, 0x11, 0x10, 0x1f, 0xfe, 0x22, 0x10, 0x42, 0x10, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xe2, 0xbb, 0x08, 0x40, 0x08, 0x40, 0x10, 0xff, 0x14, 0x84, 0x35, 0x48, 0x34, 0x30, 0x54, 0x6c, 0x55, 0x83, 0x14, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x10, 0x46, 0x00, 0x00 },
{ 0xe2, 0xbc, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfc, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe2, 0xbd, 0x02, 0x20, 0x7f, 0xff, 0x02, 0xa0, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x48, 0x02, 0x52, 0x04, 0x5e, 0x18, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xe2, 0xbe, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x08, 0x40, 0x08, 0xfe, 0x15, 0x48, 0x34, 0x30, 0x54, 0x6c, 0x15, 0x83, 0x14, 0x30, 0x14, 0xc4, 0x14, 0x18, 0x14, 0xe2, 0x10, 0x0c, 0x11, 0xf0, 0x00, 0x00 },
{ 0xe2, 0xbf, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x3f, 0x10, 0x29, 0x10, 0x7f, 0x9f, 0x29, 0x22, 0x3f, 0x22, 0x29, 0x62, 0x3f, 0x14, 0x08, 0x14, 0x7f, 0xc8, 0x31, 0x14, 0x0e, 0x22, 0x31, 0x41, 0x00, 0x00 },
{ 0xe2, 0xc0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0xff, 0x04, 0x91, 0x08, 0x91, 0x08, 0x91, 0x10, 0x91, 0x34, 0xff, 0x58, 0x91, 0x14, 0x91, 0x10, 0x91, 0x10, 0x91, 0x10, 0x91, 0x10, 0xff, 0x00, 0x00 },
{ 0xe2, 0xc1, 0x00, 0x44, 0x3c, 0x44, 0x00, 0x88, 0x7e, 0xff, 0x01, 0x88, 0x3e, 0x88, 0x00, 0xfe, 0x3c, 0x88, 0x00, 0x88, 0x00, 0x88, 0x3c, 0xfe, 0x24, 0x88, 0x24, 0x88, 0x24, 0x88, 0x3c, 0xff, 0x00, 0x00 },
{ 0xe2, 0xc2, 0x24, 0x24, 0x7f, 0x7f, 0x24, 0x24, 0x3f, 0x3f, 0x24, 0x24, 0x3f, 0x3f, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe2, 0xc3, 0x10, 0x10, 0x10, 0x28, 0x7c, 0x44, 0x10, 0x82, 0x7d, 0x7d, 0x54, 0x00, 0x7c, 0xf5, 0x54, 0x95, 0x7c, 0xd5, 0x10, 0xba, 0x10, 0x9a, 0x7c, 0xda, 0x10, 0xb5, 0x10, 0x95, 0x10, 0xb5, 0x00, 0x00 },
{ 0xe2, 0xc4, 0x20, 0xbc, 0x10, 0x84, 0x09, 0x02, 0x42, 0xfd, 0x20, 0x40, 0x10, 0xe2, 0x03, 0x24, 0x00, 0xd8, 0x73, 0x38, 0x10, 0x54, 0x10, 0x92, 0x13, 0x11, 0x10, 0x60, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe2, 0xc5, 0x20, 0x20, 0x13, 0xff, 0x0a, 0x51, 0x01, 0x9e, 0x40, 0x84, 0x20, 0x48, 0x13, 0xff, 0x00, 0xd1, 0x03, 0x2a, 0x70, 0xdc, 0x13, 0x2a, 0x10, 0xc9, 0x13, 0x30, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe2, 0xc6, 0x00, 0x41, 0x7c, 0x49, 0x10, 0x49, 0x10, 0x49, 0x7c, 0x49, 0x55, 0x6d, 0x55, 0x6d, 0x55, 0x5b, 0x6e, 0x5b, 0x44, 0x49, 0x44, 0x49, 0x7c, 0x49, 0x44, 0x89, 0x44, 0x89, 0x7d, 0x01, 0x00, 0x00 },
{ 0xe2, 0xc7, 0x08, 0x10, 0x14, 0x50, 0x22, 0x50, 0x40, 0x7e, 0x3e, 0x90, 0x09, 0x10, 0x08, 0x10, 0x7e, 0xff, 0x08, 0x10, 0x4a, 0x38, 0x2a, 0x54, 0x28, 0x54, 0x08, 0x92, 0x0f, 0x11, 0x70, 0x10, 0x00, 0x00 },
{ 0xe2, 0xc8, 0x18, 0x0e, 0x24, 0xf0, 0x40, 0x10, 0x01, 0xff, 0x7c, 0x38, 0x10, 0x54, 0x11, 0x93, 0x7c, 0x00, 0x11, 0xf8, 0x10, 0x48, 0x54, 0x5e, 0x34, 0x92, 0x10, 0x82, 0x19, 0x02, 0x62, 0x0c, 0x00, 0x00 },
{ 0xe2, 0xc9, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x40, 0x50, 0xfe, 0x51, 0x10, 0x4a, 0xff, 0x48, 0x00, 0x48, 0xfe, 0x48, 0x82, 0x48, 0xfe, 0x70, 0x82, 0x40, 0xfe, 0x40, 0x82, 0x40, 0x8e, 0x00, 0x00 },
{ 0xe2, 0xca, 0x7a, 0x1c, 0x49, 0x44, 0x48, 0x44, 0x50, 0x82, 0x55, 0x7d, 0x62, 0x20, 0x50, 0xd2, 0x50, 0x2c, 0x48, 0xd8, 0x4e, 0x2c, 0x72, 0xca, 0x42, 0x09, 0x42, 0x30, 0x45, 0x00, 0x48, 0xff, 0x00, 0x00 },
{ 0xe2, 0xcb, 0x02, 0x10, 0x79, 0x7f, 0x48, 0x20, 0x50, 0x7e, 0x50, 0x88, 0x62, 0x3f, 0x51, 0x22, 0x50, 0x3e, 0x48, 0x22, 0x4b, 0x3e, 0x49, 0x22, 0x71, 0x22, 0x41, 0x26, 0x42, 0x80, 0x44, 0x7f, 0x00, 0x00 },
{ 0xe2, 0xcc, 0x00, 0x24, 0x3e, 0x24, 0x22, 0x48, 0x22, 0x7f, 0x3e, 0xc8, 0x08, 0x48, 0x08, 0x48, 0x7f, 0x7e, 0x49, 0x48, 0x49, 0x48, 0x7f, 0x7e, 0x0a, 0x48, 0x09, 0x48, 0x0f, 0x48, 0x79, 0x7f, 0x00, 0x00 },
{ 0xe2, 0xcd, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x20, 0x0e, 0x00, 0x00 },
{ 0xe2, 0xce, 0x08, 0x00, 0x09, 0xff, 0x10, 0x10, 0x20, 0x20, 0x48, 0xfe, 0x08, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x24, 0xfe, 0x44, 0x82, 0x08, 0x82, 0x08, 0xfe, 0x10, 0x00, 0x20, 0x46, 0x41, 0x81, 0x00, 0x00 },
{ 0xe2, 0xcf, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe2, 0xd0, 0x00, 0x10, 0x3d, 0x7e, 0x24, 0x90, 0x2c, 0x3e, 0x24, 0x48, 0x7f, 0x3e, 0x42, 0x80, 0x3c, 0x3e, 0x24, 0x22, 0x3d, 0xbe, 0x24, 0xa2, 0x3c, 0xbe, 0x24, 0xa2, 0x24, 0xc0, 0x2d, 0x3f, 0x00, 0x00 },
{ 0xe2, 0xd1, 0x1f, 0x06, 0x10, 0x38, 0x7f, 0x83, 0x08, 0x3c, 0x13, 0x03, 0x7c, 0xbc, 0x00, 0x00, 0x05, 0xff, 0x18, 0x20, 0x62, 0xfe, 0x0c, 0x82, 0x70, 0xfe, 0x02, 0x82, 0x0c, 0xfe, 0x71, 0x83, 0x00, 0x00 },
{ 0xe2, 0xd2, 0x08, 0x00, 0x08, 0x7e, 0x08, 0x22, 0x0f, 0x22, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x14, 0x08, 0x14, 0x08, 0x14, 0x2a, 0x08, 0x2a, 0x08, 0x49, 0x14, 0x49, 0x24, 0x08, 0x42, 0x18, 0x81, 0x00, 0x00 },
{ 0xe2, 0xd3, 0x08, 0x20, 0x7f, 0x20, 0x00, 0x20, 0x3e, 0xfc, 0x22, 0x24, 0x3e, 0xa4, 0x00, 0x64, 0x3e, 0x25, 0x04, 0x55, 0x7e, 0x57, 0x08, 0x80, 0x18, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe2, 0xd4, 0x00, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x2f, 0xf4, 0x21, 0x04, 0x21, 0x04, 0x23, 0xe4, 0x22, 0x24, 0x24, 0x24, 0x2a, 0x44, 0x21, 0x45, 0x40, 0x85, 0x43, 0x03, 0x4c, 0x01, 0x00, 0x00 },
{ 0xe2, 0xd5, 0x08, 0x20, 0x7f, 0x20, 0x00, 0x20, 0x3e, 0xfc, 0x22, 0x24, 0x3e, 0x24, 0x00, 0xa4, 0x7e, 0x44, 0x04, 0x24, 0x08, 0x54, 0x0f, 0x44, 0x78, 0x44, 0x08, 0x85, 0x08, 0x85, 0x19, 0x03, 0x00, 0x00 },
{ 0xe2, 0xd6, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x01, 0x09, 0xfe, 0x10, 0x20, 0x10, 0x40, 0x31, 0xfe, 0x51, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xe2, 0xd7, 0x21, 0x00, 0x11, 0x3f, 0x09, 0x11, 0x01, 0xd1, 0x41, 0x11, 0x21, 0x11, 0x17, 0xd1, 0x01, 0x0a, 0x01, 0x0a, 0x15, 0x4a, 0x15, 0x24, 0x25, 0x2a, 0x29, 0x0a, 0x41, 0x11, 0x43, 0x21, 0x00, 0x00 },
{ 0xe2, 0xd8, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x22, 0x07, 0xff, 0x40, 0x22, 0x23, 0xfe, 0x10, 0x20, 0x02, 0xaa, 0x03, 0xae, 0x12, 0x22, 0x13, 0xfe, 0x22, 0x22, 0x23, 0xae, 0x44, 0xaa, 0x44, 0xaa, 0x00, 0x00 },
{ 0xe2, 0xd9, 0x08, 0x20, 0x7f, 0x20, 0x00, 0x20, 0x3e, 0xfc, 0x22, 0x24, 0x3e, 0xa4, 0x00, 0x64, 0x3e, 0x24, 0x04, 0x55, 0x7e, 0x55, 0x08, 0x87, 0x19, 0x00, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xe2, 0xda, 0x01, 0x00, 0x79, 0x00, 0x21, 0x3f, 0x21, 0xd1, 0x21, 0x11, 0x27, 0xd1, 0x79, 0x0a, 0x21, 0x0a, 0x25, 0x4a, 0x25, 0x24, 0x3d, 0x24, 0x65, 0x2a, 0x01, 0x0a, 0x01, 0x11, 0x06, 0x20, 0x00, 0x00 },
{ 0xe2, 0xdb, 0x00, 0x10, 0x00, 0xfe, 0x7c, 0x10, 0x10, 0x7c, 0x10, 0x00, 0x11, 0xff, 0x7c, 0x01, 0x10, 0x7c, 0x10, 0x10, 0x11, 0xff, 0x1c, 0x02, 0x71, 0xdf, 0x01, 0x42, 0x01, 0xd2, 0x00, 0x06, 0x00, 0x00 },
{ 0xe2, 0xdc, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x12, 0xa4, 0x1e, 0xbc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x3e, 0xbc, 0x22, 0xa4, 0x42, 0xa4, 0x00, 0x00 },
{ 0xe2, 0xdd, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0a, 0x20, 0x08, 0x00, 0x0f, 0x7e, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x24, 0x2a, 0x14, 0x29, 0x08, 0x49, 0x18, 0x48, 0x24, 0x18, 0xc3, 0x00, 0x00 },
{ 0xe2, 0xde, 0x20, 0x00, 0x10, 0x92, 0x08, 0x92, 0x40, 0x92, 0x21, 0x24, 0x11, 0x24, 0x02, 0x48, 0x01, 0x24, 0x71, 0x24, 0x10, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe2, 0xdf, 0x09, 0x00, 0x09, 0x00, 0x11, 0xfe, 0x22, 0x02, 0x48, 0x02, 0x0b, 0xe2, 0x12, 0x22, 0x12, 0x22, 0x33, 0xe2, 0x52, 0x22, 0x12, 0x22, 0x13, 0xe2, 0x10, 0x04, 0x10, 0x04, 0x10, 0x38, 0x00, 0x00 },
{ 0xe2, 0xe0, 0x08, 0x07, 0x0b, 0xf8, 0x12, 0x10, 0x22, 0x10, 0x4b, 0xff, 0x0a, 0x10, 0x12, 0x10, 0x12, 0xfe, 0x32, 0x82, 0x52, 0xfe, 0x12, 0x82, 0x12, 0xfe, 0x14, 0x82, 0x14, 0x82, 0x14, 0xfe, 0x00, 0x00 },
{ 0xe2, 0xe1, 0x11, 0x00, 0x11, 0x00, 0x13, 0xfe, 0x5a, 0x02, 0x54, 0x02, 0x55, 0xf2, 0x51, 0x12, 0x11, 0x12, 0x11, 0xf2, 0x11, 0x12, 0x11, 0x12, 0x11, 0xf2, 0x10, 0x04, 0x10, 0x04, 0x10, 0x38, 0x00, 0x00 },
{ 0xe2, 0xe2, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xff, 0x10, 0x01, 0x20, 0x01, 0x27, 0xe1, 0x44, 0x21, 0x04, 0x21, 0x07, 0xe1, 0x04, 0x21, 0x04, 0x21, 0x07, 0xe1, 0x00, 0x02, 0x00, 0x02, 0x00, 0x1c, 0x00, 0x00 },
{ 0xe2, 0xe3, 0x10, 0x40, 0x10, 0x40, 0x10, 0xfe, 0x7c, 0x82, 0x11, 0x02, 0x12, 0xf2, 0x38, 0x92, 0x34, 0x92, 0x34, 0xf2, 0x50, 0x92, 0x50, 0x92, 0x10, 0xf2, 0x10, 0x02, 0x10, 0x02, 0x10, 0x0c, 0x00, 0x00 },
{ 0xe2, 0xe4, 0x10, 0x0f, 0x11, 0xf0, 0x11, 0x10, 0x7d, 0x10, 0x11, 0xff, 0x11, 0x10, 0x39, 0x10, 0x39, 0x7e, 0x35, 0x42, 0x55, 0x7e, 0x51, 0x42, 0x51, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x12, 0x7e, 0x00, 0x00 },
{ 0xe2, 0xe5, 0x10, 0x87, 0x10, 0xfc, 0x11, 0x22, 0x7e, 0x12, 0x13, 0xff, 0x12, 0x01, 0x3a, 0x81, 0x34, 0xe2, 0x35, 0x3f, 0x51, 0xaa, 0x52, 0x4a, 0x10, 0x5f, 0x10, 0x82, 0x11, 0x02, 0x12, 0x02, 0x00, 0x00 },
{ 0xe2, 0xe6, 0x00, 0x40, 0x7e, 0x40, 0x10, 0xff, 0x10, 0x81, 0x11, 0x01, 0x3e, 0x79, 0x22, 0x49, 0x42, 0x49, 0x44, 0x79, 0x14, 0x49, 0x08, 0x49, 0x08, 0x79, 0x10, 0x01, 0x20, 0x02, 0x40, 0x0c, 0x00, 0x00 },
{ 0xe2, 0xe7, 0x20, 0x80, 0x10, 0x80, 0x09, 0x00, 0x01, 0xff, 0x42, 0x01, 0x24, 0x01, 0x11, 0xf1, 0x01, 0x11, 0x01, 0x11, 0x11, 0xf1, 0x11, 0x11, 0x21, 0x11, 0x21, 0xf1, 0x40, 0x02, 0x40, 0x0c, 0x00, 0x00 },
{ 0xe2, 0xe8, 0x20, 0x20, 0x17, 0xff, 0x08, 0x00, 0x01, 0xfc, 0x41, 0x04, 0x21, 0xfc, 0x10, 0x00, 0x03, 0xfe, 0x00, 0x04, 0x10, 0x38, 0x10, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x40, 0xe0, 0x00, 0x00 },
{ 0xe2, 0xe9, 0x00, 0x80, 0x7c, 0x80, 0x11, 0xff, 0x11, 0x01, 0x12, 0x01, 0x10, 0xf9, 0x7c, 0x89, 0x10, 0x89, 0x10, 0xf9, 0x10, 0x89, 0x10, 0x89, 0x1c, 0xf9, 0x70, 0x01, 0x00, 0x02, 0x00, 0x1c, 0x00, 0x00 },
{ 0xe2, 0xea, 0x00, 0x1f, 0x1f, 0xe0, 0x10, 0x20, 0x10, 0x20, 0x1f, 0xff, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x22, 0x02, 0x22, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xe2, 0xeb, 0x00, 0x07, 0x7b, 0xfa, 0x49, 0x22, 0x48, 0x94, 0x4b, 0xff, 0x7a, 0x01, 0x4a, 0x81, 0x48, 0xe2, 0x49, 0x3f, 0x79, 0x2a, 0x4a, 0xca, 0x48, 0x5f, 0x48, 0x82, 0x79, 0x02, 0x02, 0x02, 0x00, 0x00 },
{ 0xe2, 0xec, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x20, 0x02, 0x4f, 0xc2, 0x08, 0x42, 0x0f, 0xc2, 0x08, 0x42, 0x0f, 0xc2, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00 },
{ 0xe2, 0xed, 0x10, 0x10, 0x10, 0x10, 0x24, 0x1f, 0x45, 0xf0, 0x28, 0x10, 0x10, 0x92, 0x10, 0x92, 0x24, 0x92, 0x7c, 0x92, 0x10, 0xfe, 0x54, 0x10, 0x54, 0x10, 0x50, 0x11, 0x10, 0x11, 0x10, 0x0f, 0x00, 0x00 },
{ 0xe2, 0xee, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x00, 0x17, 0xf8, 0x10, 0x00, 0x1f, 0xff, 0x24, 0x24, 0x24, 0x18, 0x5f, 0xff, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x1c, 0x00, 0x00 },
{ 0xe2, 0xef, 0x00, 0x1e, 0x3f, 0xe0, 0x08, 0x84, 0x04, 0x48, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x09, 0x0f, 0x08, 0x11, 0xfe, 0x11, 0x48, 0x2a, 0x48, 0x46, 0xff, 0x04, 0x08, 0x18, 0x08, 0x60, 0x08, 0x00, 0x00 },
{ 0xe2, 0xf0, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x20, 0x02, 0x2f, 0xc2, 0x48, 0x42, 0x0f, 0xc2, 0x08, 0x42, 0x08, 0x42, 0x0f, 0xc4, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xe2, 0xf1, 0x02, 0x20, 0x7f, 0xff, 0x02, 0xa0, 0x3f, 0xfe, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x02, 0x04, 0x3f, 0xfa, 0x00, 0x10, 0x7f, 0xff, 0x08, 0x10, 0x04, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xe2, 0xf2, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x18, 0x3f, 0xe4, 0x09, 0x08, 0x04, 0x90, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x11, 0x1e, 0xfc, 0x62, 0x50, 0x0b, 0xfe, 0x0c, 0x10, 0x70, 0x10, 0x00, 0x00 },
{ 0xe2, 0xf3, 0x00, 0x40, 0x3c, 0x40, 0x00, 0xff, 0x7e, 0x81, 0x01, 0x01, 0x3c, 0x79, 0x00, 0x49, 0x3c, 0x49, 0x00, 0x79, 0x00, 0x49, 0x3c, 0x49, 0x24, 0x79, 0x24, 0x01, 0x24, 0x01, 0x3c, 0x06, 0x00, 0x00 },
{ 0xe2, 0xf4, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xff, 0x7e, 0x00, 0x00, 0x7e, 0x3c, 0x42, 0x00, 0x7e, 0x3c, 0x00, 0x00, 0x7e, 0x00, 0x04, 0x3c, 0x18, 0x24, 0xff, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x70, 0x00, 0x00 },
{ 0xe2, 0xf5, 0x00, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x82, 0x54, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x6c, 0xfe, 0x44, 0x04, 0x44, 0x18, 0x7d, 0xff, 0x44, 0x10, 0x44, 0x10, 0x7c, 0x70, 0x00, 0x00 },
{ 0xe2, 0xf6, 0x08, 0x10, 0x14, 0x10, 0x13, 0xff, 0x22, 0x00, 0x20, 0x7c, 0x5e, 0x44, 0x08, 0x7c, 0x08, 0x00, 0x7e, 0xfe, 0x08, 0x04, 0x4a, 0x18, 0x2a, 0xfe, 0x28, 0x10, 0x0e, 0x10, 0x78, 0x70, 0x00, 0x00 },
{ 0xe2, 0xf7, 0x22, 0x00, 0x22, 0x7f, 0x2a, 0x08, 0x2a, 0x10, 0x2a, 0x7f, 0x2a, 0x41, 0x2a, 0x7f, 0x2a, 0x41, 0x2a, 0x7f, 0x2a, 0x41, 0x2a, 0x41, 0x2a, 0x7f, 0x22, 0x00, 0x42, 0x26, 0x42, 0xc1, 0x00, 0x00 },
{ 0xe2, 0xf8, 0x00, 0x41, 0x3f, 0x41, 0x24, 0x49, 0x3f, 0x49, 0x24, 0x49, 0x3f, 0x49, 0x24, 0x49, 0x24, 0x49, 0x3f, 0x49, 0x01, 0x49, 0x55, 0x49, 0x55, 0x49, 0x42, 0x49, 0x02, 0x81, 0x0c, 0x81, 0x00, 0x00 },
{ 0xe2, 0xf9, 0x00, 0x48, 0x00, 0x44, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x44, 0x10, 0x44, 0x1f, 0x24, 0x10, 0x28, 0x10, 0x28, 0x10, 0x10, 0x20, 0x30, 0x20, 0x49, 0x21, 0x85, 0x46, 0x03, 0x00, 0x00 },
{ 0xe2, 0xfa, 0x08, 0x80, 0x08, 0xa7, 0x10, 0x90, 0x20, 0x80, 0x4b, 0xe0, 0x08, 0x80, 0x10, 0x8f, 0x12, 0xa2, 0x32, 0xa2, 0x52, 0xa2, 0x12, 0xa2, 0x12, 0xa2, 0x12, 0x9a, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xe2, 0xfb, 0x20, 0x24, 0x10, 0x22, 0x08, 0x20, 0x43, 0xff, 0x20, 0x20, 0x10, 0x20, 0x00, 0xa8, 0x00, 0xa8, 0x70, 0xa8, 0x11, 0x28, 0x11, 0x28, 0x12, 0x26, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe2, 0xfc, 0x18, 0x20, 0x14, 0x28, 0x24, 0x24, 0x20, 0x20, 0x7d, 0xfe, 0x10, 0x20, 0x10, 0xa8, 0x7c, 0xa8, 0x10, 0xa8, 0x54, 0xaa, 0x54, 0xaa, 0x51, 0x2a, 0x1d, 0x26, 0x72, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xe2, 0xfd, 0x00, 0x80, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x8c, 0x30, 0x82, 0x03, 0x80, 0x00, 0x00 },
{ 0xe2, 0xfe, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x08, 0x18, 0x08, 0x48, 0x7e, 0x44, 0x08, 0x84, 0x19, 0x22, 0x1c, 0x20, 0x2a, 0x44, 0x28, 0x44, 0x48, 0x9a, 0x09, 0xe2, 0x00, 0x00 },
{ 0xe3, 0xa1, 0x00, 0x80, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x24, 0x12, 0x27, 0xf2, 0x20, 0x02, 0x20, 0x0e, 0x00, 0x00 },
{ 0xe3, 0xa2, 0x00, 0x00, 0x7e, 0xfe, 0x08, 0x10, 0x7e, 0xfe, 0x08, 0x10, 0x08, 0x10, 0x7e, 0xfe, 0x00, 0x00, 0x01, 0x10, 0x04, 0x90, 0x24, 0x22, 0x24, 0xc2, 0x45, 0x09, 0x0e, 0x09, 0x73, 0xf8, 0x00, 0x00 },
{ 0xe3, 0xa3, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x38, 0x24, 0x54, 0x3d, 0x93, 0x24, 0x28, 0x24, 0x44, 0x25, 0x93, 0x3c, 0x92, 0x24, 0x54, 0x24, 0x10, 0x24, 0x56, 0x45, 0x91, 0x4c, 0x30, 0x00, 0x00 },
{ 0xe3, 0xa4, 0x00, 0x00, 0x3f, 0xf8, 0x01, 0x08, 0x01, 0x08, 0x1f, 0xe9, 0x02, 0x05, 0x04, 0x03, 0x18, 0x10, 0x68, 0x10, 0x3f, 0x7e, 0x29, 0x52, 0x3f, 0x7e, 0x09, 0x12, 0x0e, 0x9d, 0x70, 0x61, 0x00, 0x00 },
{ 0xe3, 0xa5, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x02, 0x23, 0xfe, 0x11, 0x08, 0x06, 0x52, 0x02, 0x94, 0x11, 0x08, 0x12, 0x52, 0x27, 0xbd, 0x20, 0x00, 0x42, 0x92, 0x44, 0x49, 0x00, 0x00 },
{ 0xe3, 0xa6, 0x10, 0x10, 0x10, 0x28, 0x10, 0x44, 0x7c, 0x82, 0x11, 0x01, 0x10, 0x00, 0x10, 0x7c, 0x1c, 0x00, 0x70, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x30, 0xfe, 0x00, 0x00 },
{ 0xe3, 0xa7, 0x00, 0x00, 0x7f, 0x7f, 0x09, 0x09, 0x13, 0x13, 0x65, 0x65, 0x19, 0x19, 0x03, 0x03, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe3, 0xa8, 0x10, 0x00, 0x11, 0xef, 0x10, 0xa5, 0x7d, 0x6b, 0x04, 0xa5, 0x09, 0x29, 0x08, 0x21, 0x10, 0x10, 0x34, 0x20, 0x58, 0xfe, 0x14, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe3, 0xa9, 0x08, 0x40, 0x7f, 0x7f, 0x22, 0x40, 0x7f, 0x7e, 0x22, 0x02, 0x3e, 0x7e, 0x22, 0x40, 0x3e, 0x41, 0x22, 0x3f, 0x26, 0x80, 0x7f, 0xff, 0x02, 0x40, 0x1c, 0x24, 0x65, 0x98, 0x1e, 0x07, 0x00, 0x00 },
{ 0xe3, 0xaa, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x10, 0x00, 0x20, 0x00, 0xc0, 0x00, 0x91, 0x3c, 0x92, 0x04, 0x94, 0x08, 0x88, 0x08, 0x88, 0x10, 0x84, 0x20, 0x82, 0x43, 0x81, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe3, 0xab, 0x00, 0x3c, 0x1f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x04, 0x90, 0x7c, 0x93, 0x04, 0x9c, 0x04, 0x90, 0x1c, 0x91, 0x65, 0xcf, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x00 },
{ 0xe3, 0xac, 0x09, 0x3c, 0x09, 0x04, 0x0a, 0x02, 0x17, 0xff, 0x12, 0x22, 0x32, 0xaa, 0x32, 0x72, 0x53, 0xfe, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xe3, 0xad, 0x00, 0x54, 0x3c, 0x92, 0x25, 0x11, 0x25, 0xff, 0x34, 0x28, 0x2c, 0x28, 0x25, 0xff, 0x24, 0x44, 0x34, 0x92, 0x2d, 0x11, 0x24, 0xfe, 0x24, 0x22, 0x24, 0x22, 0x44, 0x42, 0x4c, 0x8c, 0x00, 0x00 },
{ 0xe3, 0xae, 0x01, 0x10, 0x06, 0x10, 0x1c, 0x10, 0x64, 0x10, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x20, 0x10, 0x00, 0x00 },
{ 0xe3, 0xaf, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0xd1, 0x7c, 0x92, 0x05, 0xd4, 0x08, 0x98, 0x08, 0x88, 0x0b, 0xe8, 0x10, 0x84, 0x10, 0x84, 0x27, 0xf2, 0x40, 0x81, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe3, 0xb0, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x03, 0x00, 0x0c, 0x10, 0x34, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xe3, 0xb1, 0x10, 0x00, 0x11, 0xff, 0x25, 0x29, 0x45, 0xef, 0x28, 0x28, 0x10, 0xaf, 0x11, 0x29, 0x25, 0x29, 0x7d, 0xef, 0x15, 0x29, 0x51, 0x29, 0x55, 0xef, 0x54, 0x28, 0x10, 0x29, 0x10, 0x1f, 0x00, 0x00 },
{ 0xe3, 0xb2, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x52, 0x7d, 0xde, 0x54, 0x50, 0x54, 0xd0, 0x55, 0x5e, 0x55, 0x52, 0x55, 0xde, 0x7d, 0x52, 0x11, 0x52, 0x15, 0xde, 0x14, 0x51, 0x1a, 0x51, 0x62, 0x3f, 0x00, 0x00 },
{ 0xe3, 0xb3, 0x7c, 0x24, 0x45, 0xc4, 0x44, 0x44, 0x48, 0x44, 0x4b, 0xff, 0x50, 0x44, 0x48, 0x84, 0x48, 0x84, 0x45, 0x04, 0x44, 0x20, 0x44, 0x20, 0x59, 0xfe, 0x40, 0x20, 0x40, 0x20, 0x43, 0xff, 0x00, 0x00 },
{ 0xe3, 0xb4, 0x08, 0x20, 0x08, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x30, 0x20, 0x37, 0xff, 0x50, 0x08, 0x10, 0x08, 0x17, 0xff, 0x10, 0x08, 0x11, 0x08, 0x10, 0x88, 0x10, 0x08, 0x10, 0x08, 0x10, 0x38, 0x00, 0x00 },
{ 0xe3, 0xb5, 0x00, 0x10, 0x3f, 0x90, 0x20, 0x90, 0x3f, 0x91, 0x20, 0x92, 0x3f, 0x9c, 0x00, 0x10, 0x7f, 0xd0, 0x04, 0x10, 0x24, 0x11, 0x27, 0x91, 0x34, 0x0f, 0x2c, 0x00, 0x46, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe3, 0xb6, 0x02, 0x43, 0x77, 0xec, 0x52, 0x48, 0x52, 0x48, 0x53, 0xc8, 0x52, 0x4f, 0x52, 0x4a, 0x53, 0xca, 0x52, 0x4a, 0x52, 0x4a, 0x77, 0xea, 0x00, 0x12, 0x02, 0x52, 0x02, 0x22, 0x04, 0x42, 0x00, 0x00 },
{ 0xe3, 0xb7, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x7c, 0x24, 0x24, 0x42, 0x24, 0x5d, 0x25, 0xe1, 0x24, 0x00, 0x44, 0x00, 0x68, 0xff, 0x58, 0x81, 0x08, 0x81, 0x14, 0x81, 0x22, 0x81, 0x40, 0xff, 0x00, 0x00 },
{ 0xe3, 0xb8, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x7e, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x24, 0xfe, 0x44, 0x00, 0x68, 0x20, 0x58, 0x12, 0x09, 0x51, 0x15, 0x41, 0x21, 0x42, 0x42, 0x3e, 0x00, 0x00 },
{ 0xe3, 0xb9, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00, 0x00 },
{ 0xe3, 0xba, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x00, 0x24, 0x44, 0x22, 0x44, 0x22, 0x48, 0x2f, 0xfe, 0x20, 0xe0, 0x21, 0x50, 0x62, 0x48, 0x4c, 0x46, 0x50, 0x41, 0x00, 0x00 },
{ 0xe3, 0xbb, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x12, 0x10, 0x13, 0x93, 0x14, 0x9c, 0x16, 0x90, 0x29, 0x11, 0x22, 0x11, 0x4c, 0x0f, 0x00, 0x00 },
{ 0xe3, 0xbc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x98, 0x00, 0x80, 0x00, 0x00 },
{ 0xe3, 0xbd, 0x02, 0x14, 0x34, 0x12, 0x0c, 0x10, 0x12, 0x10, 0x61, 0xff, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x10, 0x08, 0xe8, 0x1c, 0x48, 0x1a, 0x48, 0x28, 0x45, 0x48, 0x75, 0x09, 0x83, 0x08, 0x01, 0x00, 0x00 },
{ 0xe3, 0xbe, 0x10, 0x20, 0x10, 0x20, 0x19, 0xfe, 0x54, 0x20, 0x54, 0x20, 0x50, 0x20, 0x51, 0xff, 0x10, 0x08, 0x10, 0x08, 0x13, 0xff, 0x10, 0x08, 0x11, 0x08, 0x10, 0x88, 0x10, 0x08, 0x10, 0x38, 0x00, 0x00 },
{ 0xe3, 0xbf, 0x08, 0x40, 0x08, 0x40, 0x7f, 0x7f, 0x10, 0x80, 0x11, 0x08, 0x10, 0x08, 0x1e, 0x4b, 0x12, 0x5d, 0x12, 0xe9, 0x12, 0x49, 0x12, 0x49, 0x12, 0x4b, 0x22, 0x40, 0x22, 0x41, 0x4c, 0x3f, 0x00, 0x00 },
{ 0xe3, 0xc0, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x14, 0x80, 0x23, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xe3, 0xc1, 0x00, 0x20, 0x00, 0x20, 0x79, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x08, 0x78, 0x08, 0x4b, 0xff, 0x48, 0x08, 0x49, 0x08, 0x48, 0x88, 0x78, 0x08, 0x00, 0x08, 0x00, 0x38, 0x00, 0x00 },
{ 0xe3, 0xc2, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x92, 0x38, 0x92, 0x34, 0x92, 0x34, 0x92, 0x50, 0xfe, 0x50, 0x92, 0x11, 0x12, 0x11, 0x12, 0x12, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe3, 0xc3, 0x04, 0x20, 0x24, 0x23, 0x27, 0xbc, 0x24, 0x20, 0x24, 0x21, 0x27, 0xa1, 0x78, 0x1f, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe3, 0xc4, 0x04, 0x10, 0x44, 0x10, 0x29, 0xff, 0x10, 0x10, 0x30, 0xfe, 0x50, 0x10, 0x09, 0xff, 0x08, 0x00, 0x18, 0xfe, 0x28, 0x92, 0x48, 0x92, 0x08, 0xfe, 0x08, 0x82, 0x08, 0x82, 0x30, 0x8e, 0x00, 0x00 },
{ 0xe3, 0xc5, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfc, 0x10, 0x80, 0x20, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe3, 0xc6, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x08, 0x88, 0x08, 0x84, 0x10, 0x82, 0x20, 0x81, 0x40, 0x81, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe3, 0xc7, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x22, 0x7c, 0x66, 0x10, 0xaa, 0x11, 0x32, 0x7c, 0x22, 0x24, 0x66, 0x24, 0xaa, 0x25, 0x32, 0x28, 0x22, 0x18, 0x66, 0x18, 0x00, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe3, 0xc8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x00, 0x10, 0x3c, 0xfe, 0x24, 0x10, 0x25, 0xff, 0x24, 0x04, 0x3c, 0x04, 0x25, 0xff, 0x24, 0x44, 0x24, 0x24, 0x3c, 0x04, 0x00, 0x1c, 0x00, 0x00 },
{ 0xe3, 0xc9, 0x04, 0x20, 0x7f, 0xff, 0x04, 0xa0, 0x1f, 0xe8, 0x00, 0x90, 0x7f, 0xff, 0x00, 0x80, 0x07, 0x38, 0x7b, 0xc0, 0x02, 0x02, 0x1f, 0xfe, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe3, 0xca, 0x00, 0x00, 0x7c, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x7e, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x54, 0x82, 0x54, 0x82, 0x54, 0xfe, 0x54, 0x48, 0x54, 0x48, 0x10, 0x49, 0x10, 0x89, 0x13, 0x0f, 0x00, 0x00 },
{ 0xe3, 0xcb, 0x00, 0x08, 0x3c, 0x0a, 0x00, 0x09, 0x7e, 0x08, 0x01, 0xff, 0x3c, 0x08, 0x00, 0x08, 0x3c, 0xe8, 0x00, 0x48, 0x00, 0x44, 0x3c, 0x44, 0x24, 0x45, 0x24, 0x75, 0x25, 0xc3, 0x3c, 0x01, 0x00, 0x00 },
{ 0xe3, 0xcc, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xfe, 0x7e, 0x10, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x04, 0x3c, 0x04, 0x01, 0xff, 0x00, 0x04, 0x3c, 0x84, 0x24, 0x44, 0x24, 0x04, 0x24, 0x04, 0x3c, 0x1c, 0x00, 0x00 },
{ 0xe3, 0xcd, 0x00, 0x1c, 0x3c, 0x44, 0x00, 0x44, 0x7e, 0x82, 0x00, 0xfe, 0x3d, 0x21, 0x00, 0x7c, 0x3c, 0x44, 0x00, 0x04, 0x00, 0x18, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0xaa, 0x24, 0xaa, 0x3d, 0xff, 0x00, 0x00 },
{ 0xe3, 0xce, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x20, 0x02, 0x20, 0x0d, 0x22, 0x70, 0xa4, 0x01, 0x98, 0x06, 0x50, 0x18, 0x50, 0x60, 0xc8, 0x03, 0x48, 0x0c, 0x44, 0x70, 0x43, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00 },
{ 0xe3, 0xcf, 0x0c, 0x04, 0x70, 0x04, 0x0a, 0x04, 0x24, 0x04, 0x18, 0xff, 0x68, 0x0c, 0x08, 0x0c, 0x14, 0x14, 0x64, 0x14, 0x0c, 0x24, 0x14, 0x44, 0x64, 0x84, 0x04, 0x04, 0x04, 0x04, 0x18, 0x1c, 0x00, 0x00 },
{ 0xe3, 0xd0, 0x10, 0x10, 0x10, 0x10, 0x13, 0xff, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x7e, 0x12, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x7e, 0x1e, 0x42, 0x72, 0x7e, 0x02, 0x00, 0x02, 0x00, 0x01, 0xff, 0x00, 0x00 },
{ 0xe3, 0xd1, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0xf8, 0x08, 0x80, 0x16, 0x80, 0x61, 0xff, 0x00, 0x00 },
{ 0xe3, 0xd2, 0x00, 0x24, 0x00, 0x22, 0x7f, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x3f, 0xa0, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x08, 0x04, 0xc9, 0x07, 0x05, 0x78, 0x03, 0x00, 0x01, 0x00, 0x00 },
{ 0xe3, 0xd3, 0x00, 0x80, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x04, 0x42, 0x24, 0x11, 0x24, 0x11, 0x43, 0xf0, 0x00, 0x00 },
{ 0xe3, 0xd4, 0x10, 0x0a, 0x10, 0x09, 0x10, 0x08, 0x7d, 0xff, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1d, 0xe8, 0x70, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x85, 0x10, 0xe5, 0x13, 0x83, 0x30, 0x01, 0x00, 0x00 },
{ 0xe3, 0xd5, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x7e, 0x39, 0x42, 0x39, 0x7e, 0x35, 0x42, 0x55, 0x7e, 0x51, 0x42, 0x51, 0x7e, 0x11, 0x00, 0x11, 0x00, 0x11, 0xff, 0x00, 0x00 },
{ 0xe3, 0xd6, 0x00, 0x08, 0x7f, 0x08, 0x10, 0xff, 0x10, 0x08, 0x1e, 0x08, 0x12, 0xbe, 0x22, 0xa2, 0x32, 0xbe, 0x4c, 0xa2, 0x04, 0xbe, 0x08, 0xa2, 0x08, 0xbe, 0x10, 0x80, 0x20, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xe3, 0xd7, 0x21, 0xfc, 0x11, 0x04, 0x09, 0xfc, 0x01, 0x04, 0x41, 0xfc, 0x21, 0x04, 0x10, 0x00, 0x07, 0xff, 0x00, 0x20, 0x09, 0x20, 0x09, 0x3e, 0x11, 0x20, 0x11, 0x20, 0x22, 0xa0, 0x44, 0x7f, 0x00, 0x00 },
{ 0xe3, 0xd8, 0x10, 0x10, 0x10, 0x20, 0x12, 0xfe, 0x54, 0x82, 0x58, 0xfe, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x28, 0x50, 0x25, 0x4a, 0x21, 0x41, 0x42, 0x45, 0x40, 0x3c, 0x00, 0x00 },
{ 0xe3, 0xd9, 0x08, 0x10, 0x1f, 0x3f, 0x68, 0xc8, 0x04, 0x84, 0x03, 0x60, 0x0d, 0xd8, 0x70, 0x07, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xfa, 0x08, 0x44, 0x09, 0xb8, 0x3e, 0x07, 0x00, 0x00 },
{ 0xe3, 0xda, 0x08, 0x08, 0x14, 0x08, 0x22, 0x08, 0x5d, 0x08, 0x00, 0x7f, 0x3e, 0x49, 0x22, 0x49, 0x3e, 0x49, 0x22, 0x49, 0x3e, 0x7f, 0x20, 0x08, 0x3e, 0x0a, 0x20, 0x09, 0x3e, 0x0f, 0x20, 0xf9, 0x00, 0x00 },
{ 0xe3, 0xdb, 0x00, 0x88, 0x38, 0x88, 0x03, 0xea, 0x7d, 0x49, 0x01, 0x48, 0x3b, 0xff, 0x00, 0x08, 0x38, 0x09, 0x03, 0xc9, 0x02, 0x4a, 0x3b, 0xca, 0x2a, 0x44, 0x2b, 0xcd, 0x28, 0x13, 0x38, 0x21, 0x00, 0x00 },
{ 0xe3, 0xdc, 0x08, 0x08, 0x08, 0x0a, 0x7f, 0x09, 0x08, 0x08, 0x3e, 0xff, 0x2a, 0x08, 0x3e, 0x08, 0x2a, 0xe8, 0x3e, 0x48, 0x08, 0x44, 0x08, 0x44, 0x7f, 0x45, 0x08, 0x75, 0x09, 0xc3, 0x08, 0x01, 0x00, 0x00 },
{ 0xe3, 0xdd, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x63, 0xe3, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xfa, 0x08, 0x44, 0x08, 0x28, 0x0f, 0x98, 0x78, 0x07, 0x00, 0x00 },
{ 0xe3, 0xde, 0x08, 0x20, 0x14, 0x20, 0x22, 0x7f, 0x4d, 0x48, 0x00, 0x88, 0x3e, 0x08, 0x22, 0x7f, 0x3e, 0x49, 0x22, 0x49, 0x3e, 0x49, 0x20, 0x49, 0x3e, 0x49, 0x20, 0x4b, 0x3e, 0x08, 0x20, 0x08, 0x00, 0x00 },
{ 0xe3, 0xdf, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x11, 0xff, 0x31, 0x11, 0x31, 0x11, 0x51, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe3, 0xe0, 0x08, 0x10, 0x08, 0x90, 0x08, 0x90, 0x11, 0xfe, 0x11, 0x10, 0x32, 0x10, 0x30, 0x10, 0x53, 0xff, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x10, 0x49, 0x10, 0x89, 0x10, 0x89, 0x11, 0x07, 0x00, 0x00 },
{ 0xe3, 0xe1, 0x08, 0x00, 0x09, 0xfe, 0x10, 0x00, 0x13, 0xff, 0x30, 0x00, 0x31, 0xfe, 0x50, 0x00, 0x11, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xe3, 0xe2, 0x00, 0x20, 0x00, 0x20, 0x79, 0xfe, 0x49, 0x22, 0x49, 0x22, 0x49, 0x22, 0x49, 0xfe, 0x49, 0x22, 0x49, 0x22, 0x49, 0x22, 0x79, 0xfe, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe3, 0xe3, 0x10, 0x00, 0x10, 0xff, 0x10, 0x80, 0x7c, 0x80, 0x24, 0xfe, 0x24, 0x80, 0x24, 0xff, 0x24, 0xa8, 0x44, 0xa9, 0x68, 0xaa, 0x58, 0xa4, 0x08, 0xa4, 0x15, 0x22, 0x23, 0x3a, 0x42, 0xe1, 0x00, 0x00 },
{ 0xe3, 0xe4, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x1f, 0xfc, 0x10, 0x00, 0x17, 0xf8, 0x10, 0x00, 0x1f, 0xfe, 0x12, 0x20, 0x12, 0x22, 0x22, 0x14, 0x22, 0xe8, 0x4f, 0x07, 0x00, 0x00 },
{ 0xe3, 0xe5, 0x10, 0x8c, 0x10, 0xf0, 0x18, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x50, 0x7c, 0x52, 0x44, 0x12, 0x7c, 0x12, 0x44, 0x12, 0x7c, 0x12, 0x44, 0x12, 0x44, 0x13, 0xff, 0x10, 0x48, 0x11, 0x86, 0x00, 0x00 },
{ 0xe3, 0xe6, 0x08, 0x03, 0x08, 0x7c, 0x7f, 0x40, 0x22, 0x40, 0x14, 0x40, 0x7f, 0x7f, 0x00, 0x44, 0x08, 0x44, 0x7f, 0x44, 0x08, 0x44, 0x18, 0x44, 0x1c, 0x44, 0x2a, 0x84, 0x48, 0x84, 0x08, 0x84, 0x00, 0x00 },
{ 0xe3, 0xe7, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x17, 0xfc, 0x10, 0x00, 0x1f, 0xff, 0x22, 0x44, 0x23, 0xb8, 0x4e, 0x07, 0x00, 0x00 },
{ 0xe3, 0xe8, 0x10, 0x20, 0x11, 0xfe, 0x14, 0x22, 0x5b, 0xff, 0x50, 0x22, 0x51, 0xfe, 0x50, 0x20, 0x13, 0xff, 0x11, 0x52, 0x12, 0x29, 0x28, 0x00, 0x27, 0xfe, 0x22, 0x52, 0x42, 0x52, 0x47, 0xff, 0x00, 0x00 },
{ 0xe3, 0xe9, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfc, 0x41, 0x04, 0x41, 0x04, 0x7f, 0xfc, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0xfc, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00 },
{ 0xe3, 0xea, 0x00, 0x08, 0x3e, 0x08, 0x00, 0x08, 0x00, 0x7f, 0x7f, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x2a, 0x49, 0x2a, 0x49, 0x2a, 0x49, 0x2a, 0x7f, 0x4a, 0x08, 0x48, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00 },
{ 0xe3, 0xeb, 0x10, 0x10, 0x10, 0x10, 0x24, 0xff, 0x44, 0x91, 0x28, 0x91, 0x10, 0xff, 0x10, 0x91, 0x24, 0x91, 0x7c, 0x91, 0x10, 0xff, 0x54, 0x10, 0x54, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe3, 0xec, 0x7f, 0x7e, 0x48, 0x22, 0x7f, 0x22, 0x41, 0x14, 0x7f, 0x08, 0x48, 0x14, 0x7f, 0x63, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xe3, 0xed, 0x00, 0x00, 0x7f, 0xfc, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x7f, 0xf8, 0x40, 0x08, 0x40, 0x08, 0x40, 0x08, 0x7f, 0xf8, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x7f, 0xfc, 0x00, 0x00 },
{ 0xe3, 0xee, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe3, 0xef, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x03, 0x7f, 0x7c, 0x22, 0x40, 0x14, 0x40, 0x7f, 0x7f, 0x08, 0x44, 0x7f, 0x44, 0x08, 0x44, 0x1c, 0x44, 0x2a, 0x84, 0x48, 0x84, 0x09, 0x04, 0x00, 0x00 },
{ 0xe3, 0xf0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x0f, 0xf8, 0x00, 0x88, 0x3f, 0xfe, 0x00, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x1f, 0xfe, 0x22, 0x48, 0x4f, 0xf8, 0x09, 0x48, 0x09, 0x48, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xe3, 0xf1, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x00, 0x17, 0xfc, 0x10, 0x00, 0x1f, 0xff, 0x14, 0x24, 0x25, 0x98, 0x2e, 0x0c, 0x40, 0x83, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x3f, 0xfa, 0x00, 0x00 },
{ 0xe3, 0xf2, 0x00, 0x00, 0x3d, 0xfc, 0x00, 0x44, 0x7e, 0x44, 0x00, 0x44, 0x3c, 0x44, 0x00, 0x7c, 0x3d, 0xc4, 0x00, 0x44, 0x00, 0x44, 0x3c, 0x44, 0x24, 0x45, 0x24, 0x85, 0x24, 0x83, 0x3d, 0x01, 0x00, 0x00 },
{ 0xe3, 0xf3, 0x00, 0x80, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x09, 0x08, 0x0a, 0x09, 0xfc, 0x7e, 0x18, 0x00, 0x68, 0x01, 0x88, 0x0e, 0x08, 0x70, 0x38, 0x00, 0x00 },
{ 0xe3, 0xf4, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x08, 0x04, 0x08, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe3, 0xf5, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x17, 0xfc, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x12, 0x20, 0x12, 0x22, 0x12, 0x24, 0x12, 0x18, 0x22, 0x08, 0x23, 0xc4, 0x4e, 0x03, 0x00, 0x00 },
{ 0xe3, 0xf6, 0x20, 0x00, 0x13, 0xf8, 0x08, 0x08, 0x40, 0x88, 0x20, 0x88, 0x10, 0xa8, 0x00, 0xc8, 0x01, 0x88, 0x72, 0x88, 0x10, 0x85, 0x10, 0x85, 0x10, 0x83, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe3, 0xf7, 0x00, 0x80, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfe, 0x10, 0x80, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe3, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x1f, 0xfc, 0x01, 0x08, 0x02, 0x3c, 0x3f, 0xc2, 0x00, 0x82, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe3, 0xf9, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xe3, 0xfa, 0x00, 0x3e, 0x3f, 0xc0, 0x00, 0x80, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x04, 0x42, 0x24, 0x01, 0x24, 0x11, 0x43, 0xf0, 0x00, 0x00 },
{ 0xe3, 0xfb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x19, 0x5f, 0xe1, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x04, 0x90, 0x18, 0x8c, 0x7f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe3, 0xfc, 0x1f, 0xfc, 0x00, 0x04, 0x7f, 0xff, 0x00, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0x7f, 0x08, 0x41, 0x0f, 0x7f, 0x78, 0x08, 0x00, 0x08, 0x7f, 0xff, 0x08, 0x08, 0x04, 0x08, 0x00, 0x38, 0x00, 0x00 },
{ 0xe3, 0xfd, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x04, 0x08, 0x24, 0x04, 0x24, 0x02, 0x24, 0x02, 0x24, 0x01, 0x44, 0x09, 0x44, 0x08, 0x04, 0x08, 0x03, 0xf8, 0x00, 0x00 },
{ 0xe3, 0xfe, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x00, 0x00, 0x40, 0x40, 0x20, 0x40, 0x12, 0x44, 0x02, 0x42, 0x02, 0x42, 0x12, 0x41, 0x14, 0x41, 0x24, 0x40, 0x20, 0x42, 0x40, 0x42, 0x40, 0x3e, 0x00, 0x00 },
{ 0xe4, 0xa1, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xfe, 0x42, 0x22, 0x22, 0x22, 0x12, 0x22, 0x00, 0x20, 0x00, 0x40, 0x10, 0x50, 0x10, 0x90, 0x20, 0x90, 0x21, 0x11, 0x42, 0x11, 0x44, 0x0f, 0x00, 0x00 },
{ 0xe4, 0xa2, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x49, 0x02, 0x49, 0x40, 0x48, 0x20, 0x89, 0x13, 0x07, 0x00, 0x20, 0x00, 0x20, 0x13, 0xff, 0x10, 0x70, 0x20, 0xa8, 0x21, 0x24, 0x46, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xe4, 0xa3, 0x20, 0x20, 0x13, 0xff, 0x0a, 0x05, 0x02, 0xf9, 0x41, 0x24, 0x20, 0xa8, 0x13, 0xff, 0x00, 0xa8, 0x01, 0x24, 0x12, 0x02, 0x15, 0xfd, 0x21, 0x24, 0x21, 0xfc, 0x41, 0x24, 0x41, 0xfc, 0x00, 0x00 },
{ 0xe4, 0xa4, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x7f, 0xff, 0x11, 0x20, 0x11, 0x22, 0x12, 0x1e, 0x14, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x00, 0x00 },
{ 0xe4, 0xa5, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x01, 0x00, 0x00, 0x80, 0x04, 0x40, 0x04, 0x44, 0x24, 0x02, 0x24, 0x02, 0x24, 0x01, 0x44, 0x11, 0x44, 0x10, 0x03, 0xf0, 0x00, 0x00 },
{ 0xe4, 0xa6, 0x00, 0x44, 0x3c, 0x44, 0x01, 0xff, 0x7e, 0x44, 0x00, 0x7c, 0x3c, 0x44, 0x00, 0x7c, 0x3c, 0x44, 0x03, 0xff, 0x00, 0xa4, 0x3c, 0xa5, 0x24, 0xa7, 0x24, 0xc0, 0x24, 0x80, 0x3c, 0xff, 0x00, 0x00 },
{ 0xe4, 0xa7, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x10, 0x20, 0x33, 0xff, 0x30, 0x20, 0x50, 0x20, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xe4, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe4, 0xa9, 0x10, 0x30, 0x10, 0x28, 0x10, 0x48, 0x7c, 0x44, 0x10, 0x82, 0x11, 0x01, 0x10, 0x7c, 0x1c, 0x00, 0x70, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x30, 0xfe, 0x00, 0x00 },
{ 0xe4, 0xaa, 0x24, 0x48, 0x3f, 0x7e, 0x64, 0xc8, 0x3f, 0x7e, 0x24, 0x48, 0x3f, 0x7e, 0x24, 0x48, 0x3f, 0x7e, 0x00, 0x00, 0x3f, 0xf8, 0x04, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x00, 0x00 },
{ 0xe4, 0xab, 0x00, 0x3c, 0x1f, 0xc0, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x10, 0x10, 0x11, 0x11, 0x89, 0x1e, 0x05, 0x70, 0x03, 0x00, 0x00 },
{ 0xe4, 0xac, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x3e, 0x3e, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3e, 0x3e, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe4, 0xad, 0x08, 0x28, 0x08, 0xca, 0x17, 0x89, 0x10, 0x88, 0x30, 0x88, 0x37, 0xff, 0x50, 0x88, 0x10, 0x89, 0x10, 0xa9, 0x11, 0xca, 0x16, 0x8a, 0x10, 0x84, 0x10, 0x8d, 0x10, 0x95, 0x13, 0xa3, 0x00, 0x00 },
{ 0xe4, 0xae, 0x06, 0x00, 0x38, 0x7c, 0x20, 0x04, 0x20, 0x04, 0x3e, 0x7c, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x02, 0x40, 0x02, 0x40, 0x04, 0x40, 0x04, 0x40, 0x08, 0x41, 0x10, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xe4, 0xaf, 0x03, 0xff, 0x78, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4b, 0xcf, 0x4a, 0x01, 0x4a, 0x01, 0x4a, 0x01, 0x4a, 0x01, 0x4b, 0xcf, 0x78, 0x48, 0x00, 0x48, 0x00, 0x48, 0x00, 0x48, 0x03, 0xff, 0x00, 0x00 },
{ 0xe4, 0xb0, 0x10, 0xd0, 0x13, 0x92, 0x10, 0x91, 0x7c, 0x90, 0x24, 0x90, 0x27, 0xff, 0x24, 0x90, 0x24, 0x92, 0x44, 0x92, 0x68, 0xd4, 0x5b, 0x8c, 0x08, 0x88, 0x14, 0x95, 0x22, 0xa3, 0x41, 0x81, 0x00, 0x00 },
{ 0xe4, 0xb1, 0x10, 0x28, 0x11, 0xca, 0x10, 0x49, 0x54, 0x48, 0x54, 0x48, 0x55, 0xff, 0x54, 0x48, 0x54, 0x48, 0x54, 0x49, 0x54, 0x65, 0x55, 0xc6, 0x54, 0x44, 0x7c, 0x4d, 0x00, 0x55, 0x00, 0xe3, 0x00, 0x00 },
{ 0xe4, 0xb2, 0x03, 0x24, 0x3c, 0x22, 0x04, 0x21, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x22, 0x04, 0x12, 0x05, 0x92, 0x0e, 0x14, 0x74, 0x0c, 0x04, 0x08, 0x04, 0x15, 0x04, 0x25, 0x1c, 0xc3, 0x00, 0x00 },
{ 0xe4, 0xb3, 0x00, 0x00, 0x1f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x3f, 0xff, 0x00, 0x30, 0x00, 0x50, 0x00, 0x90, 0x03, 0x10, 0x0c, 0x10, 0x70, 0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xe4, 0xb4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x30, 0x00, 0x50, 0x01, 0x90, 0x0e, 0x10, 0x70, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xe4, 0xb5, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x0e, 0x48, 0x38, 0x44, 0x08, 0x40, 0x7f, 0xff, 0x08, 0x40, 0x08, 0x24, 0x0e, 0x28, 0x78, 0x10, 0x08, 0x29, 0x08, 0x45, 0x39, 0x83, 0x00, 0x00 },
{ 0xe4, 0xb6, 0x10, 0x2a, 0x11, 0xc9, 0x10, 0x48, 0x7c, 0x48, 0x55, 0xff, 0x54, 0x48, 0x54, 0x48, 0x54, 0x49, 0x54, 0x69, 0x7d, 0xca, 0x10, 0x46, 0x14, 0x44, 0x14, 0x45, 0x1a, 0x4b, 0x62, 0xd1, 0x00, 0x00 },
{ 0xe4, 0xb7, 0x08, 0x00, 0x0b, 0xf7, 0x10, 0x80, 0x20, 0x80, 0x4b, 0xe0, 0x09, 0x2f, 0x11, 0x22, 0x17, 0xfa, 0x30, 0x02, 0x50, 0x02, 0x13, 0xf2, 0x12, 0x12, 0x12, 0x12, 0x13, 0xf2, 0x10, 0x06, 0x00, 0x00 },
{ 0xe4, 0xb8, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x24, 0x7e, 0x24, 0x00, 0x24, 0x3c, 0x24, 0x01, 0xff, 0x3c, 0x0c, 0x00, 0x0c, 0x00, 0x14, 0x3c, 0x24, 0x24, 0x44, 0x24, 0x84, 0x24, 0x04, 0x3c, 0x1c, 0x00, 0x00 },
{ 0xe4, 0xb9, 0x00, 0x00, 0x7d, 0xff, 0x44, 0x04, 0x48, 0x04, 0x48, 0x04, 0x51, 0xe4, 0x49, 0x24, 0x49, 0x24, 0x45, 0x24, 0x45, 0x24, 0x45, 0xe4, 0x58, 0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x1c, 0x00, 0x00 },
{ 0xe4, 0xba, 0x00, 0x24, 0x7f, 0x24, 0x24, 0x48, 0x24, 0x7f, 0x24, 0xc8, 0x24, 0x48, 0x7f, 0x48, 0x0c, 0x7e, 0x0c, 0x48, 0x14, 0x48, 0x14, 0x7e, 0x24, 0x48, 0x44, 0x48, 0x04, 0x48, 0x1c, 0x7f, 0x00, 0x00 },
{ 0xe4, 0xbb, 0x08, 0x28, 0x15, 0xc8, 0x22, 0x4a, 0x5c, 0x49, 0x00, 0x48, 0x3f, 0xff, 0x22, 0x48, 0x3e, 0x49, 0x22, 0x49, 0x3e, 0x6a, 0x21, 0xca, 0x3e, 0x4c, 0x20, 0x55, 0x3e, 0x65, 0x20, 0xc3, 0x00, 0x00 },
{ 0xe4, 0xbc, 0x00, 0x10, 0x3f, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x7f, 0x40, 0x04, 0x7f, 0x0c, 0x40, 0x0c, 0x7f, 0x14, 0x01, 0x14, 0xa9, 0x24, 0xa9, 0x45, 0x01, 0x0c, 0x06, 0x00, 0x00 },
{ 0xe4, 0xbd, 0x0a, 0x08, 0x12, 0xbe, 0x72, 0xa2, 0x12, 0x3e, 0x12, 0x22, 0x7f, 0xbe, 0x12, 0x20, 0x12, 0xbf, 0x12, 0xa0, 0x1a, 0xbf, 0x72, 0x81, 0x11, 0x55, 0x11, 0x55, 0x12, 0xc1, 0x34, 0x06, 0x00, 0x00 },
{ 0xe4, 0xbe, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x1e, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x1e, 0x3c, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe4, 0xbf, 0x00, 0x78, 0x1f, 0x80, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xfc, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7f, 0xff, 0x00, 0x80, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe4, 0xc0, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x2b, 0xc6, 0x10, 0x05, 0x17, 0xe4, 0x28, 0x1f, 0x4b, 0xc4, 0x18, 0x04, 0x2b, 0xc4, 0x4a, 0x4a, 0x0a, 0x4a, 0x33, 0xd1, 0x00, 0x00 },
{ 0xe4, 0xc1, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0x02, 0x55, 0xfe, 0x55, 0x00, 0x55, 0xff, 0x55, 0x24, 0x55, 0x46, 0x55, 0xf9, 0x5d, 0x10, 0x11, 0x7e, 0x12, 0x10, 0x12, 0x10, 0x12, 0xff, 0x00, 0x00 },
{ 0xe4, 0xc2, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x1e, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x1e, 0x3c, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x04, 0x80, 0x24, 0x52, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xe4, 0xc3, 0x10, 0x00, 0x13, 0xde, 0x1a, 0x52, 0x56, 0x52, 0x53, 0xde, 0x50, 0x00, 0x51, 0xfc, 0x10, 0x00, 0x17, 0xff, 0x10, 0x80, 0x11, 0xfc, 0x11, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x38, 0x00, 0x00 },
{ 0xe4, 0xc4, 0x13, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x7b, 0xfe, 0x12, 0x00, 0x12, 0xfe, 0x12, 0x20, 0x1a, 0x44, 0x72, 0xfa, 0x12, 0x12, 0x12, 0x10, 0x12, 0xfe, 0x14, 0x10, 0x14, 0x10, 0x35, 0xff, 0x00, 0x00 },
{ 0xe4, 0xc5, 0x10, 0x82, 0x21, 0x04, 0x4b, 0xe9, 0x32, 0x26, 0x13, 0xe2, 0x2a, 0x25, 0x7a, 0x2f, 0x0b, 0xe1, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xe4, 0xc6, 0x23, 0xfe, 0x12, 0x02, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x00, 0x22, 0xfe, 0x12, 0x20, 0x02, 0x44, 0x02, 0xfa, 0x12, 0x12, 0x12, 0x10, 0x22, 0xfe, 0x24, 0x10, 0x44, 0x10, 0x49, 0xff, 0x00, 0x00 },
{ 0xe4, 0xc7, 0x00, 0x00, 0x7b, 0xdf, 0x4a, 0x51, 0x7b, 0xd2, 0x00, 0x12, 0x3f, 0x94, 0x00, 0x12, 0x7f, 0xd2, 0x10, 0x11, 0x10, 0x11, 0x3f, 0x11, 0x21, 0x11, 0x01, 0x16, 0x01, 0x10, 0x0e, 0x10, 0x00, 0x00 },
{ 0xe4, 0xc8, 0x18, 0x00, 0x24, 0xee, 0x40, 0xaa, 0x00, 0xaa, 0x7c, 0xee, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x00, 0x11, 0xff, 0x10, 0x20, 0x54, 0x3e, 0x34, 0x42, 0x10, 0x42, 0x18, 0x02, 0x60, 0x1c, 0x00, 0x00 },
{ 0xe4, 0xc9, 0x00, 0x00, 0x77, 0x7f, 0x55, 0x08, 0x55, 0x10, 0x77, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x00, 0x42, 0x7f, 0x7e, 0x10, 0x42, 0x3e, 0x42, 0x22, 0x7e, 0x02, 0x00, 0x02, 0x26, 0x1c, 0xc1, 0x00, 0x00 },
{ 0xe4, 0xca, 0x10, 0x00, 0x1c, 0xee, 0x24, 0xaa, 0x28, 0xaa, 0x7e, 0xee, 0x2a, 0x00, 0x2a, 0x7e, 0x3e, 0x00, 0x2a, 0xff, 0x2a, 0x20, 0x3e, 0x7e, 0x00, 0x42, 0x2a, 0x02, 0x2a, 0x02, 0x40, 0x1c, 0x00, 0x00 },
{ 0xe4, 0xcb, 0x08, 0x00, 0x28, 0x7f, 0x2f, 0x41, 0x28, 0x41, 0x7f, 0x7f, 0x00, 0x40, 0x55, 0x7f, 0x6b, 0x48, 0x41, 0x52, 0x7f, 0x7d, 0x55, 0x48, 0x55, 0x5e, 0x6b, 0x48, 0x41, 0x48, 0x7f, 0xbf, 0x00, 0x00 },
{ 0xe4, 0xcc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x41, 0x01, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x10, 0x04, 0x20, 0x0f, 0x20, 0x00, 0xe0, 0x00, 0x98, 0x03, 0x04, 0x3c, 0x02, 0x00, 0x00 },
{ 0xe4, 0xcd, 0x00, 0x80, 0x10, 0x82, 0x10, 0x82, 0x1f, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x00, 0x27, 0xfc, 0x20, 0x40, 0x20, 0x40, 0x2f, 0xfe, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00 },
{ 0xe4, 0xce, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7a, 0x01, 0x12, 0x21, 0x10, 0x20, 0x13, 0xff, 0x18, 0x44, 0x70, 0x84, 0x10, 0x88, 0x11, 0x68, 0x10, 0x10, 0x10, 0x28, 0x10, 0xc4, 0x33, 0x02, 0x00, 0x00 },
{ 0xe4, 0xcf, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x01, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x00, 0xe0, 0x03, 0x98, 0x3c, 0x06, 0x00, 0x00 },
{ 0xe4, 0xd0, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x01, 0x42, 0x01, 0x1f, 0xfc, 0x04, 0x20, 0x0e, 0x40, 0x01, 0xf0, 0x1e, 0x0c, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xe4, 0xd1, 0x00, 0x00, 0x79, 0xfe, 0x49, 0x02, 0x49, 0x02, 0x49, 0xfe, 0x79, 0x02, 0x49, 0x02, 0x49, 0xfe, 0x79, 0x20, 0x49, 0x12, 0x49, 0x14, 0x49, 0x08, 0x79, 0x34, 0x01, 0xc2, 0x07, 0x01, 0x00, 0x00 },
{ 0xe4, 0xd2, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x00, 0x22, 0x24, 0x22, 0x48, 0x24, 0xff, 0x25, 0x88, 0x2c, 0x88, 0x34, 0xfe, 0x24, 0x88, 0x24, 0x88, 0x24, 0xfe, 0x44, 0x88, 0x44, 0x88, 0x44, 0xff, 0x00, 0x00 },
{ 0xe4, 0xd3, 0x28, 0x10, 0x28, 0x10, 0x7d, 0xff, 0x29, 0x01, 0x39, 0x21, 0x10, 0x20, 0x7d, 0xff, 0x54, 0x44, 0x54, 0x44, 0x7c, 0x44, 0x10, 0xe8, 0x10, 0x18, 0x7c, 0x14, 0x10, 0x62, 0x11, 0x81, 0x00, 0x00 },
{ 0xe4, 0xd4, 0x04, 0x00, 0x04, 0x3f, 0x3f, 0x84, 0x11, 0x08, 0x0a, 0x3f, 0x3f, 0xa1, 0x20, 0x3f, 0x22, 0x21, 0x2d, 0x3f, 0x22, 0x21, 0x2c, 0x21, 0x21, 0x3f, 0x42, 0x00, 0x4c, 0x12, 0x40, 0x61, 0x00, 0x00 },
{ 0xe4, 0xd5, 0x10, 0x10, 0x1c, 0x10, 0x24, 0xff, 0x28, 0x81, 0x7e, 0x91, 0x2a, 0x10, 0x2a, 0xff, 0x3e, 0x22, 0x2a, 0x22, 0x2a, 0x42, 0x3e, 0x64, 0x00, 0x54, 0x2a, 0x0c, 0x2a, 0x32, 0x40, 0xc1, 0x00, 0x00 },
{ 0xe4, 0xd6, 0x08, 0x08, 0x08, 0x14, 0x7f, 0x22, 0x08, 0x41, 0x08, 0x04, 0x3e, 0x24, 0x22, 0x14, 0x3e, 0x04, 0x22, 0x44, 0x3e, 0x24, 0x08, 0x07, 0x08, 0x1c, 0x7f, 0x64, 0x08, 0x04, 0x08, 0x04, 0x00, 0x00 },
{ 0xe4, 0xd7, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x82, 0x7e, 0xfe, 0x00, 0x82, 0x00, 0xfe, 0x3c, 0x40, 0x00, 0x7f, 0x3c, 0x89, 0x01, 0x89, 0x00, 0x95, 0x3c, 0xa3, 0x24, 0xfd, 0x24, 0x01, 0x3c, 0x06, 0x00, 0x00 },
{ 0xe4, 0xd8, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xd0, 0x04, 0x10, 0x3f, 0x90, 0x24, 0x90, 0x3f, 0x90, 0x24, 0x90, 0x3f, 0x90, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xd0, 0x04, 0x11, 0x04, 0x11, 0x04, 0x0f, 0x00, 0x00 },
{ 0xe4, 0xd9, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x44, 0x22, 0x5f, 0x52, 0x44, 0x8a, 0x47, 0x42, 0x45, 0x22, 0x49, 0x02, 0x49, 0x12, 0x52, 0x62, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe4, 0xda, 0x00, 0x40, 0x78, 0x40, 0x4f, 0xfe, 0x48, 0x90, 0x49, 0x48, 0x4a, 0x44, 0x4f, 0xfb, 0x4a, 0x48, 0x4b, 0xf8, 0x7a, 0x48, 0x03, 0xf8, 0x00, 0x42, 0x00, 0x42, 0x00, 0x42, 0x00, 0x3e, 0x00, 0x00 },
{ 0xe4, 0xdb, 0x00, 0x80, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x14, 0x04, 0x24, 0x04, 0x44, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xe4, 0xdc, 0x20, 0x82, 0x3f, 0xfe, 0x09, 0x24, 0x0f, 0x3c, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x10, 0x2f, 0x90, 0x22, 0x3f, 0x3f, 0xd2, 0x29, 0x12, 0x2f, 0x0c, 0x29, 0x0c, 0x5f, 0x12, 0x41, 0x61, 0x00, 0x00 },
{ 0xe4, 0xdd, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x40, 0x20, 0x80, 0x2f, 0xfe, 0x21, 0x10, 0x22, 0x48, 0x27, 0xfc, 0x3a, 0x4b, 0x23, 0xf8, 0x22, 0x48, 0x23, 0xf9, 0x40, 0x41, 0x40, 0x7f, 0x00, 0x00 },
{ 0xe4, 0xde, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xfe, 0x49, 0x08, 0x48, 0x88, 0x48, 0x90, 0x7b, 0xff, 0x48, 0x00, 0x49, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xe4, 0xdf, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x51, 0xf8, 0x31, 0x08, 0x11, 0xf8, 0x10, 0x00, 0x37, 0x9f, 0x54, 0x91, 0x17, 0x9f, 0x10, 0x20, 0x24, 0x21, 0x24, 0x21, 0x47, 0xff, 0x00, 0x00 },
{ 0xe4, 0xe0, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x88, 0x1f, 0xfc, 0x68, 0x8b, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xe4, 0xe1, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x41, 0x02, 0x4f, 0xf2, 0x42, 0x42, 0x5f, 0xfa, 0x40, 0x02, 0x47, 0xe2, 0x44, 0x22, 0x47, 0xe2, 0x44, 0x22, 0x47, 0xee, 0x00, 0x00 },
{ 0xe4, 0xe2, 0x3f, 0xff, 0x28, 0x88, 0x2f, 0x8a, 0x28, 0x88, 0x2f, 0xbf, 0x28, 0x88, 0x2f, 0x94, 0x28, 0x94, 0x28, 0xa2, 0x49, 0xc1, 0x40, 0x00, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe4, 0xe3, 0x10, 0x00, 0x11, 0xff, 0x11, 0x11, 0x7d, 0x11, 0x11, 0x11, 0x11, 0xff, 0x11, 0x11, 0x1d, 0x11, 0x71, 0x11, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xe4, 0xe4, 0x04, 0x00, 0x45, 0xff, 0x29, 0x11, 0x11, 0x11, 0x31, 0x11, 0x51, 0xff, 0x09, 0x11, 0x09, 0x11, 0x19, 0x11, 0x29, 0xff, 0x48, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xe4, 0xe5, 0x00, 0x10, 0x7e, 0x7e, 0x52, 0x42, 0x52, 0x7e, 0x52, 0x42, 0x7e, 0x7e, 0x52, 0x40, 0x52, 0x7f, 0x52, 0x40, 0x7e, 0x7f, 0x10, 0x01, 0x10, 0xa9, 0x10, 0xa9, 0x11, 0x01, 0x10, 0x06, 0x00, 0x00 },
{ 0xe4, 0xe6, 0x08, 0xc0, 0x0b, 0x00, 0x12, 0x1f, 0x12, 0x11, 0x32, 0x11, 0x32, 0x11, 0x52, 0x11, 0x12, 0x11, 0x12, 0x11, 0x12, 0x51, 0x13, 0x91, 0x16, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe4, 0xe7, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe4, 0xe8, 0x10, 0x20, 0x10, 0x20, 0x18, 0x20, 0x55, 0xfc, 0x55, 0x24, 0x51, 0x24, 0x51, 0x24, 0x11, 0x24, 0x17, 0xff, 0x10, 0x20, 0x10, 0x50, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x16, 0x03, 0x00, 0x00 },
{ 0xe4, 0xe9, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x00, 0x00, 0x3f, 0x7f, 0x08, 0x41, 0x08, 0x41, 0x08, 0x41, 0x08, 0x41, 0x0f, 0x4f, 0x78, 0x40, 0x00, 0x40, 0x00, 0x00 },
{ 0xe4, 0xea, 0x00, 0x10, 0x7e, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x1c, 0x92, 0x24, 0x92, 0x24, 0x92, 0x25, 0xff, 0x58, 0x10, 0x48, 0x10, 0x08, 0x28, 0x10, 0x28, 0x10, 0x44, 0x20, 0x82, 0x43, 0x01, 0x00, 0x00 },
{ 0xe4, 0xeb, 0x0c, 0x10, 0x70, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x7c, 0x92, 0x10, 0x92, 0x10, 0x92, 0x38, 0x92, 0x35, 0xff, 0x50, 0x28, 0x50, 0x28, 0x10, 0x44, 0x10, 0x44, 0x10, 0x82, 0x11, 0x01, 0x00, 0x00 },
{ 0xe4, 0xec, 0x00, 0x80, 0x0f, 0xf8, 0x09, 0x08, 0x7f, 0xff, 0x04, 0x88, 0x19, 0x04, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x00, 0x0f, 0xff, 0x24, 0x91, 0x42, 0x4e, 0x00, 0x00 },
{ 0xe4, 0xed, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x40, 0x27, 0xfc, 0x20, 0x40, 0x20, 0x40, 0x2f, 0xfe, 0x20, 0x00, 0x20, 0x40, 0x20, 0x40, 0x27, 0xfc, 0x20, 0x40, 0x40, 0x40, 0x5f, 0xff, 0x00, 0x00 },
{ 0xe4, 0xee, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x42, 0x02, 0x24, 0x0c, 0x28, 0x74, 0x10, 0x04, 0xc8, 0x07, 0x04, 0x1c, 0x03, 0x00, 0x00 },
{ 0xe4, 0xef, 0x10, 0x20, 0x10, 0x28, 0x10, 0x44, 0x10, 0x5a, 0x7d, 0xe2, 0x10, 0x40, 0x10, 0x40, 0x10, 0xfe, 0x11, 0x10, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x10, 0x00, 0x28, 0x00, 0x44, 0x01, 0x83, 0x00, 0x00 },
{ 0xe4, 0xf0, 0x00, 0x40, 0x08, 0x42, 0x08, 0x42, 0x0f, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x13, 0xfe, 0x20, 0x20, 0x20, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe4, 0xf1, 0x00, 0x7c, 0x3f, 0x88, 0x09, 0x08, 0x04, 0x90, 0x7f, 0xff, 0x40, 0x81, 0x54, 0x55, 0x17, 0xf2, 0x22, 0x02, 0x07, 0xf0, 0x0a, 0x10, 0x31, 0x20, 0x00, 0xc0, 0x03, 0x30, 0x3c, 0x0e, 0x00, 0x00 },
{ 0xe4, 0xf2, 0x00, 0x0e, 0x7b, 0xf0, 0x49, 0x24, 0x48, 0x98, 0x4b, 0xff, 0x4a, 0x01, 0x79, 0x54, 0x49, 0x4a, 0x4a, 0x39, 0x48, 0x40, 0x48, 0xf8, 0x79, 0x88, 0x06, 0x50, 0x00, 0x70, 0x07, 0x8f, 0x00, 0x00 },
{ 0xe4, 0xf3, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x00, 0x02, 0x10, 0x42, 0x10, 0x22, 0xfe, 0x12, 0x10, 0x02, 0x10, 0x03, 0xff, 0x12, 0x00, 0x12, 0x10, 0x22, 0xfe, 0x24, 0x10, 0x44, 0x10, 0x49, 0xff, 0x00, 0x00 },
{ 0xe4, 0xf4, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x20, 0xfe, 0x3c, 0x00, 0x24, 0xfe, 0x64, 0x04, 0x25, 0xff, 0x24, 0x04, 0x24, 0x84, 0x3c, 0x44, 0x00, 0x04, 0x00, 0x1c, 0x00, 0x00 },
{ 0xe4, 0xf5, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0x02, 0x40, 0x01, 0x80, 0x01, 0x80, 0x06, 0x60, 0x18, 0x18, 0x60, 0x06, 0x00, 0x00 },
{ 0xe4, 0xf6, 0x7c, 0x38, 0x44, 0x88, 0x44, 0x84, 0x49, 0x02, 0x4a, 0xfd, 0x50, 0x00, 0x48, 0x38, 0x48, 0x88, 0x44, 0x84, 0x45, 0x02, 0x46, 0x01, 0x59, 0xfe, 0x41, 0x52, 0x41, 0x52, 0x47, 0xff, 0x00, 0x00 },
{ 0xe4, 0xf7, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x7f, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x00, 0x42, 0x3e, 0x7f, 0x01, 0x91, 0x3e, 0xa9, 0x22, 0xf9, 0x3e, 0x06, 0x00, 0x00 },
{ 0xe4, 0xf8, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x38, 0x11, 0x00, 0x11, 0x01, 0x21, 0x01, 0x21, 0x01, 0x40, 0xff, 0x00, 0x00 },
{ 0xe4, 0xf9, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x7d, 0x00, 0x11, 0x3e, 0x11, 0x22, 0x11, 0x22, 0x1d, 0x22, 0x71, 0x22, 0x11, 0x2c, 0x11, 0x20, 0x12, 0x20, 0x12, 0x21, 0x12, 0x21, 0x34, 0x1f, 0x00, 0x00 },
{ 0xe4, 0xfa, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x00, 0x10, 0x90, 0x10, 0x9e, 0x11, 0x22, 0x19, 0x32, 0x73, 0x4a, 0x15, 0xa4, 0x11, 0x24, 0x11, 0x18, 0x11, 0x18, 0x11, 0x24, 0x31, 0x43, 0x00, 0x00 },
{ 0xe4, 0xfb, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x00, 0x40, 0x90, 0x20, 0x9e, 0x11, 0x22, 0x01, 0x32, 0x03, 0x4a, 0x15, 0xa4, 0x11, 0x14, 0x21, 0x08, 0x21, 0x18, 0x41, 0x24, 0x41, 0x43, 0x00, 0x00 },
{ 0xe4, 0xfc, 0x10, 0x1c, 0x10, 0x44, 0x24, 0x44, 0x44, 0x82, 0x29, 0x39, 0x10, 0x00, 0x10, 0x1c, 0x24, 0x44, 0x7c, 0x44, 0x14, 0x82, 0x51, 0x01, 0x54, 0xfe, 0x54, 0xaa, 0x10, 0xaa, 0x11, 0xff, 0x00, 0x00 },
{ 0xe4, 0xfd, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x50, 0x24, 0x50, 0x3c, 0x9e, 0x24, 0xa2, 0x25, 0xaa, 0x26, 0xa2, 0x3c, 0xd4, 0x24, 0x94, 0x24, 0x88, 0x24, 0x98, 0x44, 0xa4, 0x4c, 0xc3, 0x00, 0x00 },
{ 0xe4, 0xfe, 0x08, 0x00, 0x08, 0xff, 0x7f, 0x08, 0x51, 0x10, 0x10, 0x7e, 0x1e, 0x42, 0x32, 0x42, 0x4c, 0x7e, 0x0c, 0x42, 0x12, 0x7e, 0x21, 0x42, 0x7e, 0x42, 0x22, 0x7e, 0x22, 0x24, 0x3e, 0xc3, 0x00, 0x00 },
{ 0xe5, 0xa1, 0x13, 0xde, 0x12, 0x52, 0x13, 0xde, 0x7a, 0x52, 0x13, 0xde, 0x12, 0x52, 0x33, 0xde, 0x3a, 0x52, 0x34, 0x21, 0x50, 0x40, 0x57, 0xff, 0x50, 0x88, 0x11, 0x88, 0x10, 0x70, 0x17, 0x8e, 0x00, 0x00 },
{ 0xe5, 0xa2, 0x00, 0x00, 0x3f, 0x7e, 0x21, 0x42, 0x3f, 0x7e, 0x21, 0x42, 0x3f, 0x7e, 0x12, 0x24, 0x61, 0x42, 0x08, 0x00, 0x1f, 0xfc, 0x20, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe5, 0xa3, 0x29, 0x29, 0x4a, 0x4a, 0x14, 0x14, 0x22, 0x22, 0x7f, 0xff, 0x41, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x00, 0x0f, 0xff, 0x24, 0x91, 0x42, 0x4e, 0x00, 0x00 },
{ 0xe5, 0xa4, 0x3b, 0x88, 0x2a, 0x90, 0x3b, 0xbe, 0x2a, 0xa2, 0x3b, 0xbe, 0x2a, 0xa2, 0x3b, 0xbe, 0x2a, 0xa0, 0x44, 0x7f, 0x08, 0x20, 0x7f, 0xff, 0x11, 0x01, 0x32, 0x2b, 0x0f, 0x29, 0x70, 0x87, 0x00, 0x00 },
{ 0xe5, 0xa5, 0x00, 0x80, 0x10, 0x80, 0x10, 0x8c, 0x10, 0xb4, 0x11, 0xc4, 0x16, 0x84, 0x18, 0x84, 0x70, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x9c, 0x10, 0x81, 0x10, 0x01, 0x10, 0x01, 0x0f, 0xff, 0x00, 0x00 },
{ 0xe5, 0xa6, 0x08, 0x00, 0x0f, 0xff, 0x12, 0x51, 0x12, 0x52, 0x33, 0xd2, 0x32, 0x54, 0x52, 0x52, 0x53, 0xd2, 0x12, 0x51, 0x12, 0x51, 0x12, 0xd1, 0x17, 0x57, 0x10, 0x50, 0x10, 0x50, 0x10, 0x50, 0x00, 0x00 },
{ 0xe5, 0xa7, 0x00, 0x20, 0x20, 0x20, 0x10, 0x44, 0x08, 0x42, 0x00, 0x9e, 0x03, 0xe1, 0x00, 0x01, 0x08, 0x00, 0x09, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xe5, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x40, 0x08, 0x40, 0x08, 0x7c, 0x10, 0x84, 0x10, 0xa4, 0x31, 0x98, 0x32, 0x48, 0x50, 0x50, 0x10, 0x20, 0x10, 0x50, 0x10, 0x8c, 0x13, 0x03, 0x00, 0x00 },
{ 0xe5, 0xa9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x1f, 0xfc, 0x64, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xe5, 0xaa, 0x10, 0x00, 0x17, 0xff, 0x12, 0x51, 0x7a, 0x52, 0x13, 0xd2, 0x12, 0x54, 0x12, 0x54, 0x1b, 0xd2, 0x72, 0x52, 0x12, 0x51, 0x12, 0x51, 0x13, 0xd1, 0x16, 0x56, 0x10, 0x50, 0x30, 0x50, 0x00, 0x00 },
{ 0xe5, 0xab, 0x10, 0x00, 0x13, 0xef, 0x11, 0x29, 0x7d, 0x29, 0x11, 0xea, 0x11, 0x2a, 0x39, 0x2c, 0x39, 0xea, 0x35, 0x2a, 0x55, 0x29, 0x51, 0x69, 0x51, 0xa9, 0x12, 0x2e, 0x10, 0x28, 0x10, 0x28, 0x00, 0x00 },
{ 0xe5, 0xac, 0x0c, 0x18, 0x72, 0x27, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x00, 0x00, 0x7f, 0xbf, 0x11, 0x21, 0x1f, 0x22, 0x11, 0x24, 0x1f, 0x22, 0x11, 0x21, 0x1f, 0x21, 0x71, 0x2e, 0x01, 0x20, 0x00, 0x00 },
{ 0xe5, 0xad, 0x00, 0x00, 0x7f, 0xbf, 0x11, 0x21, 0x11, 0x22, 0x1f, 0x22, 0x11, 0x24, 0x11, 0x22, 0x1f, 0x22, 0x11, 0x21, 0x11, 0x21, 0x11, 0x21, 0x1f, 0x21, 0x71, 0x2e, 0x01, 0x20, 0x01, 0x20, 0x00, 0x00 },
{ 0xe5, 0xae, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x90, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x07, 0xf8, 0x1c, 0x08, 0x64, 0x08, 0x04, 0x08, 0x04, 0x08, 0x07, 0xf8, 0x00, 0x00 },
{ 0xe5, 0xaf, 0x00, 0x00, 0x7f, 0x7f, 0x49, 0x02, 0x49, 0x24, 0x7f, 0x18, 0x49, 0x08, 0x49, 0x7f, 0x7f, 0x09, 0x08, 0x0a, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0x08, 0x78, 0x38, 0x00, 0x00 },
{ 0xe5, 0xb0, 0x00, 0x00, 0x7f, 0x7f, 0x01, 0x01, 0x01, 0x01, 0x3f, 0x3f, 0x20, 0x20, 0x20, 0x20, 0x3f, 0x3f, 0x09, 0x09, 0x13, 0x13, 0x65, 0x65, 0x09, 0x09, 0x11, 0x11, 0x62, 0x62, 0x0c, 0x0c, 0x00, 0x00 },
{ 0xe5, 0xb1, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x1c, 0xfe, 0x70, 0x10, 0x10, 0x54, 0x10, 0x92, 0x11, 0x11, 0x12, 0x11, 0x10, 0x10, 0x30, 0x70, 0x00, 0x00 },
{ 0xe5, 0xb2, 0x00, 0x40, 0x00, 0x7e, 0x7c, 0x84, 0x55, 0x88, 0x56, 0x50, 0x54, 0x20, 0x7c, 0x50, 0x54, 0x88, 0x57, 0x07, 0x54, 0x00, 0x7d, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xe5, 0xb3, 0x10, 0x20, 0x10, 0x20, 0x24, 0x40, 0x44, 0x7f, 0x28, 0x81, 0x10, 0x81, 0x11, 0x01, 0x24, 0x21, 0x7c, 0x11, 0x10, 0x11, 0x54, 0x01, 0x54, 0x01, 0x50, 0x02, 0x10, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xe5, 0xb4, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x90, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x07, 0xfc, 0x1c, 0x04, 0x64, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xe5, 0xb5, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x00, 0x08, 0x20, 0x32, 0x3e, 0x14, 0x42, 0x08, 0x82, 0x12, 0x02, 0x7d, 0x22, 0x08, 0x12, 0x2a, 0x12, 0x29, 0x02, 0x48, 0x02, 0x08, 0x1c, 0x00, 0x00 },
{ 0xe5, 0xb6, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x00, 0x3f, 0x7e, 0x01, 0x02, 0x3f, 0x7e, 0x20, 0x40, 0x3f, 0x7e, 0x09, 0x12, 0x13, 0x26, 0x65, 0xca, 0x09, 0x12, 0x31, 0x62, 0x06, 0x0c, 0x00, 0x00 },
{ 0xe5, 0xb7, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x10, 0x82, 0x23, 0xe4, 0x4a, 0x29, 0x33, 0xe6, 0x2a, 0x25, 0x7b, 0xef, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xe5, 0xb8, 0x00, 0x00, 0x3d, 0xef, 0x24, 0x63, 0x25, 0xad, 0x24, 0x63, 0x3d, 0xad, 0x08, 0x44, 0x08, 0x48, 0x2e, 0xff, 0x28, 0x90, 0x29, 0xfe, 0x2a, 0x90, 0x28, 0xfe, 0x2e, 0x90, 0x78, 0xff, 0x00, 0x00 },
{ 0xe5, 0xb9, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x22, 0x22, 0x02, 0x20, 0x04, 0x21, 0x08, 0x21, 0x70, 0x1f, 0x00, 0x00 },
{ 0xe5, 0xba, 0x09, 0x04, 0x08, 0x84, 0x10, 0x08, 0x17, 0xff, 0x30, 0x20, 0x30, 0x20, 0x50, 0x20, 0x53, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xe5, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x2c, 0xb2, 0x24, 0x92, 0x24, 0x92, 0x2a, 0xaa, 0x31, 0xc6, 0x20, 0x82, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x00 },
{ 0xe5, 0xbc, 0x00, 0x20, 0x40, 0x20, 0x27, 0xff, 0x10, 0x00, 0x03, 0xfc, 0x02, 0x04, 0x02, 0x04, 0x03, 0xfc, 0x10, 0x20, 0x11, 0x28, 0x21, 0x24, 0x22, 0x22, 0x44, 0x22, 0x40, 0x20, 0x00, 0xe0, 0x00, 0x00 },
{ 0xe5, 0xbd, 0x10, 0x20, 0x17, 0xff, 0x12, 0x52, 0x12, 0x52, 0x7f, 0xde, 0x10, 0x88, 0x13, 0xfe, 0x10, 0x88, 0x13, 0xfe, 0x10, 0x88, 0x1f, 0xff, 0x71, 0x22, 0x07, 0x14, 0x39, 0x6c, 0x07, 0x83, 0x00, 0x00 },
{ 0xe5, 0xbe, 0x20, 0x20, 0x20, 0x20, 0x23, 0xff, 0x78, 0x00, 0x2b, 0xde, 0x2a, 0x52, 0x2b, 0xde, 0x28, 0x88, 0x4b, 0xfe, 0x68, 0x88, 0x53, 0xff, 0x11, 0x92, 0x2a, 0x8c, 0x24, 0xe4, 0x43, 0x83, 0x00, 0x00 },
{ 0xe5, 0xbf, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x04, 0x80, 0x04, 0x40, 0x24, 0x12, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xe5, 0xc0, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x1f, 0xff, 0x70, 0x80, 0x10, 0xff, 0x11, 0x29, 0x16, 0x49, 0x10, 0x91, 0x13, 0x21, 0x30, 0xc6, 0x00, 0x00 },
{ 0xe5, 0xc1, 0x10, 0x20, 0x13, 0xff, 0x11, 0x4a, 0x7d, 0x4a, 0x11, 0xce, 0x10, 0x48, 0x13, 0xfe, 0x1c, 0x48, 0x71, 0xfe, 0x10, 0x48, 0x13, 0xff, 0x10, 0xa2, 0x11, 0x94, 0x16, 0xac, 0x31, 0xc3, 0x00, 0x00 },
{ 0xe5, 0xc2, 0x00, 0x10, 0x3f, 0x10, 0x21, 0x10, 0x3f, 0x3f, 0x21, 0x22, 0x3f, 0x52, 0x00, 0x12, 0x3f, 0x94, 0x10, 0x14, 0x3f, 0x88, 0x4a, 0x88, 0x12, 0x94, 0x64, 0x94, 0x08, 0xa2, 0x33, 0x41, 0x00, 0x00 },
{ 0xe5, 0xc3, 0x00, 0x00, 0x01, 0xfc, 0x79, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x48, 0x00, 0x7b, 0xff, 0x49, 0x00, 0x49, 0xfe, 0x4a, 0x52, 0x48, 0x92, 0x7b, 0x24, 0x00, 0x44, 0x01, 0x98, 0x00, 0x00 },
{ 0xe5, 0xc4, 0x10, 0x00, 0x09, 0xf8, 0x40, 0x48, 0x22, 0x4a, 0x02, 0x49, 0x14, 0x89, 0x10, 0x89, 0x21, 0x30, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xe5, 0xc5, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x38, 0x00, 0x35, 0xff, 0x34, 0x40, 0x50, 0xff, 0x53, 0x25, 0x10, 0x49, 0x11, 0x91, 0x10, 0x21, 0x10, 0xce, 0x00, 0x00 },
{ 0xe5, 0xc6, 0x10, 0x44, 0x11, 0xff, 0x10, 0x10, 0x7c, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x38, 0x00, 0x38, 0x78, 0x34, 0x00, 0x54, 0x71, 0x51, 0x9a, 0x50, 0x54, 0x10, 0x92, 0x13, 0x11, 0x10, 0x70, 0x00, 0x00 },
{ 0xe5, 0xc7, 0x21, 0x04, 0x10, 0x84, 0x08, 0x88, 0x07, 0xff, 0x40, 0x20, 0x20, 0x20, 0x13, 0xfe, 0x00, 0x20, 0x00, 0x20, 0x10, 0x20, 0x17, 0xff, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xe5, 0xc8, 0x20, 0x88, 0x13, 0xfe, 0x08, 0x20, 0x01, 0xfc, 0x40, 0x20, 0x27, 0xff, 0x10, 0xa8, 0x01, 0xfc, 0x06, 0x8b, 0x10, 0xf8, 0x10, 0x88, 0x20, 0xf9, 0x20, 0x92, 0x40, 0xec, 0x47, 0x83, 0x00, 0x00 },
{ 0xe5, 0xc9, 0x10, 0xfc, 0x10, 0x84, 0x12, 0xfc, 0x54, 0x84, 0x58, 0x84, 0x50, 0xfc, 0x50, 0x00, 0x13, 0xff, 0x10, 0x80, 0x10, 0xfe, 0x29, 0x2a, 0x2a, 0x4a, 0x24, 0x92, 0x41, 0x22, 0x40, 0x4c, 0x00, 0x00 },
{ 0xe5, 0xca, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x51, 0x04, 0x30, 0x88, 0x17, 0xff, 0x10, 0x20, 0x30, 0x20, 0x53, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xe5, 0xcb, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x11, 0xfc, 0x51, 0x04, 0x31, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x30, 0x80, 0x57, 0xff, 0x11, 0x00, 0x13, 0xff, 0x2c, 0x49, 0x21, 0x91, 0x46, 0x66, 0x00, 0x00 },
{ 0xe5, 0xcc, 0x00, 0x20, 0x7b, 0xff, 0x01, 0x52, 0x01, 0x52, 0x7d, 0xde, 0x10, 0x44, 0x11, 0xff, 0x54, 0x44, 0x55, 0xff, 0x54, 0x44, 0x57, 0xff, 0x54, 0x48, 0x50, 0xca, 0x13, 0x64, 0x10, 0xc3, 0x00, 0x00 },
{ 0xe5, 0xcd, 0x0c, 0x20, 0x73, 0xff, 0x11, 0x52, 0x11, 0x52, 0x7d, 0xde, 0x10, 0x48, 0x11, 0xfe, 0x38, 0x48, 0x35, 0xfe, 0x50, 0x48, 0x53, 0xff, 0x10, 0x50, 0x11, 0xca, 0x16, 0x74, 0x11, 0x83, 0x00, 0x00 },
{ 0xe5, 0xce, 0x11, 0xfc, 0x53, 0x04, 0x35, 0xfc, 0x11, 0x04, 0x7d, 0xfc, 0x10, 0x00, 0x3f, 0xff, 0x35, 0x24, 0x35, 0xfc, 0x51, 0x24, 0x51, 0xfc, 0x10, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xe5, 0xcf, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe5, 0xd0, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x1b, 0xcc, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x86, 0x08, 0x58, 0x08, 0x20, 0x0f, 0x98, 0x38, 0x07, 0x00, 0x00 },
{ 0xe5, 0xd1, 0x00, 0x80, 0x7f, 0xff, 0x11, 0x44, 0x1f, 0x7c, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x24, 0x1a, 0x18, 0x62, 0xcc, 0x0f, 0x03, 0x00, 0x00 },
{ 0xe5, 0xd2, 0x00, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x00, 0x00, 0x7e, 0xfc, 0x00, 0x84, 0x3c, 0x84, 0x00, 0xfc, 0x3c, 0x10, 0x00, 0x54, 0x3c, 0x92, 0x25, 0x11, 0x26, 0x11, 0x24, 0x10, 0x3c, 0x70, 0x00, 0x00 },
{ 0xe5, 0xd3, 0x00, 0x10, 0x3d, 0xff, 0x00, 0xaa, 0x7e, 0xee, 0x00, 0x28, 0x3c, 0xfe, 0x00, 0x28, 0x3c, 0xfe, 0x00, 0x28, 0x01, 0xff, 0x3c, 0x51, 0x24, 0xca, 0x27, 0x4c, 0x24, 0x74, 0x3c, 0xc3, 0x00, 0x00 },
{ 0xe5, 0xd4, 0x00, 0x10, 0x7d, 0xff, 0x10, 0xaa, 0x10, 0xee, 0x7c, 0x48, 0x55, 0xfe, 0x54, 0x48, 0x54, 0xfc, 0x6c, 0x48, 0x45, 0xff, 0x44, 0x49, 0x7c, 0xca, 0x45, 0x44, 0x44, 0x72, 0x7d, 0xc1, 0x00, 0x00 },
{ 0xe5, 0xd5, 0x7c, 0xfe, 0x44, 0x82, 0x48, 0xfe, 0x48, 0x82, 0x50, 0xfe, 0x48, 0x00, 0x4b, 0xff, 0x44, 0x40, 0x44, 0xff, 0x45, 0x25, 0x5a, 0x49, 0x40, 0x89, 0x41, 0x11, 0x40, 0x21, 0x40, 0xc6, 0x00, 0x00 },
{ 0xe5, 0xd6, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe5, 0xd7, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x90, 0x0f, 0xf8, 0x14, 0x14, 0x67, 0xf3, 0x04, 0x10, 0x07, 0xf4, 0x04, 0x48, 0x05, 0xb0, 0x3e, 0x0f, 0x00, 0x00 },
{ 0xe5, 0xd8, 0x7f, 0xfe, 0x40, 0x02, 0x4f, 0xf2, 0x41, 0x02, 0x41, 0x02, 0x4f, 0xe2, 0x42, 0x22, 0x42, 0x22, 0x5f, 0xfa, 0x40, 0x02, 0x4f, 0xf2, 0x48, 0x12, 0x4f, 0xf2, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xe5, 0xd9, 0x09, 0x00, 0x09, 0x00, 0x11, 0x0f, 0x23, 0xe9, 0x4a, 0x89, 0x08, 0x89, 0x13, 0xe9, 0x10, 0x89, 0x32, 0x89, 0x52, 0xe9, 0x12, 0x89, 0x12, 0x89, 0x12, 0xeb, 0x17, 0x88, 0x10, 0x08, 0x00, 0x00 },
{ 0xe5, 0xda, 0x10, 0x10, 0x10, 0x10, 0x10, 0x28, 0x7f, 0x28, 0x10, 0x44, 0x10, 0x44, 0x10, 0x82, 0x1f, 0x21, 0x12, 0x10, 0x12, 0x08, 0x12, 0x00, 0x22, 0x20, 0x22, 0x10, 0x22, 0x08, 0x4c, 0x04, 0x00, 0x00 },
{ 0xe5, 0xdb, 0x20, 0x80, 0x10, 0xf8, 0x09, 0x08, 0x02, 0x10, 0x47, 0xfe, 0x22, 0x22, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x20, 0x00, 0x22, 0x92, 0x42, 0x49, 0x44, 0x49, 0x00, 0x00 },
{ 0xe5, 0xdc, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x52, 0x08, 0x32, 0x08, 0x1f, 0xd4, 0x12, 0x14, 0x32, 0x22, 0x53, 0x81, 0x12, 0x98, 0x12, 0x84, 0x14, 0x80, 0x24, 0x98, 0x28, 0x84, 0x4b, 0x00, 0x00, 0x00 },
{ 0xe5, 0xdd, 0x0a, 0x00, 0x13, 0xef, 0x60, 0x89, 0x0b, 0xe9, 0x10, 0x89, 0x72, 0xe9, 0x12, 0x8b, 0x17, 0xe8, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x8c, 0x33, 0x82, 0x00, 0x00 },
{ 0xe5, 0xde, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x20, 0x7e, 0x20, 0x00, 0xfc, 0x3c, 0x44, 0x00, 0x44, 0x3d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x3c, 0xfe, 0x00, 0x00 },
{ 0xe5, 0xdf, 0x00, 0x00, 0x3f, 0x7e, 0x24, 0x22, 0x3f, 0x22, 0x24, 0x22, 0x3f, 0x22, 0x24, 0x24, 0x24, 0x24, 0x3f, 0x14, 0x01, 0x18, 0x55, 0x08, 0x55, 0x14, 0x42, 0x24, 0x02, 0x42, 0x0c, 0x81, 0x00, 0x00 },
{ 0xe5, 0xe0, 0x04, 0x00, 0x0f, 0xe0, 0x08, 0x20, 0x10, 0x40, 0x3f, 0xfc, 0x50, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x12, 0x44, 0x21, 0x22, 0x41, 0x21, 0x00, 0x00 },
{ 0xe5, 0xe1, 0x08, 0x00, 0x28, 0x7f, 0x2f, 0x08, 0x28, 0x08, 0x7f, 0x3e, 0x00, 0x12, 0x55, 0x12, 0x6b, 0x7f, 0x41, 0x00, 0x7f, 0x00, 0x55, 0x3e, 0x55, 0x22, 0x6b, 0x22, 0x41, 0x22, 0x7f, 0x3e, 0x00, 0x00 },
{ 0xe5, 0xe2, 0x08, 0x20, 0x09, 0xfe, 0x08, 0x84, 0x10, 0x48, 0x13, 0xff, 0x30, 0x00, 0x31, 0xfe, 0x51, 0x02, 0x51, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x20, 0x12, 0x92, 0x12, 0x85, 0x14, 0x7c, 0x00, 0x00 },
{ 0xe5, 0xe3, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x84, 0x58, 0x48, 0x55, 0xff, 0x54, 0x00, 0x51, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x20, 0x12, 0x92, 0x12, 0x85, 0x14, 0x7d, 0x00, 0x00 },
{ 0xe5, 0xe4, 0x10, 0x20, 0x10, 0x40, 0x11, 0x9f, 0x7d, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1d, 0x11, 0x71, 0x11, 0x11, 0x51, 0x11, 0x91, 0x16, 0x17, 0x10, 0x10, 0x10, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xe5, 0xe5, 0x10, 0x20, 0x13, 0xfe, 0x11, 0x04, 0x7c, 0x88, 0x13, 0xff, 0x10, 0x00, 0x39, 0xfe, 0x39, 0x02, 0x35, 0xfe, 0x55, 0x02, 0x51, 0xfe, 0x50, 0x20, 0x12, 0x92, 0x12, 0x85, 0x14, 0x7d, 0x00, 0x00 },
{ 0xe5, 0xe6, 0x00, 0x10, 0x3c, 0xfe, 0x24, 0x44, 0x24, 0x28, 0x25, 0xff, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x00, 0x25, 0x52, 0x45, 0x45, 0x4c, 0x3d, 0x00, 0x00 },
{ 0xe5, 0xe7, 0x08, 0x00, 0x0b, 0xff, 0x12, 0x00, 0x12, 0xfe, 0x32, 0x82, 0x32, 0xfe, 0x52, 0x82, 0x52, 0xfe, 0x12, 0x20, 0x13, 0xff, 0x12, 0x44, 0x12, 0xc8, 0x12, 0x38, 0x12, 0xc4, 0x13, 0xff, 0x00, 0x00 },
{ 0xe5, 0xe8, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x11, 0x7e, 0x7d, 0x42, 0x11, 0x7e, 0x11, 0x42, 0x11, 0x7e, 0x11, 0x10, 0x11, 0xff, 0x1d, 0x24, 0x71, 0x74, 0x01, 0x0c, 0x01, 0x12, 0x01, 0xff, 0x00, 0x00 },
{ 0xe5, 0xe9, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x04, 0x08, 0x02, 0x10, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x30, 0x27, 0xc0, 0x20, 0x0c, 0x20, 0x30, 0x27, 0xc0, 0x40, 0x06, 0x40, 0x38, 0x4f, 0xc0, 0x00, 0x00 },
{ 0xe5, 0xea, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x08, 0x80, 0x7f, 0xff, 0x04, 0x00, 0x07, 0xfc, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xff, 0x00, 0x01, 0x24, 0x91, 0x42, 0x4e, 0x00, 0x00 },
{ 0xe5, 0xeb, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x00, 0x00 },
{ 0xe5, 0xec, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xff, 0x7e, 0x42, 0x00, 0x24, 0x3c, 0xff, 0x00, 0x82, 0x3c, 0x8c, 0x00, 0xb1, 0x00, 0x82, 0x3c, 0x8c, 0x24, 0xb1, 0x25, 0x02, 0x25, 0x0c, 0x3d, 0x30, 0x00, 0x00 },
{ 0xe5, 0xed, 0x24, 0x88, 0x3f, 0xff, 0x08, 0x22, 0x1f, 0x14, 0x31, 0x7f, 0x5f, 0x08, 0x10, 0x7f, 0x1f, 0x08, 0x11, 0x08, 0x1f, 0xf8, 0x00, 0x10, 0x00, 0x60, 0x7f, 0xff, 0x00, 0x40, 0x03, 0xc0, 0x00, 0x00 },
{ 0xe5, 0xee, 0x02, 0x20, 0x7f, 0xff, 0x0a, 0x20, 0x10, 0x08, 0x3e, 0x7f, 0x22, 0x22, 0x3e, 0x7f, 0x20, 0x08, 0x3e, 0x7f, 0x22, 0x08, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xe5, 0xef, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x50, 0x10, 0x88, 0x31, 0x24, 0x32, 0x22, 0x55, 0xfd, 0x51, 0x24, 0x11, 0xfc, 0x11, 0x24, 0x11, 0xfc, 0x10, 0x21, 0x10, 0x21, 0x10, 0x1f, 0x00, 0x00 },
{ 0xe5, 0xf0, 0x0b, 0xde, 0x0a, 0x52, 0x13, 0xde, 0x10, 0x00, 0x33, 0xff, 0x32, 0x08, 0x52, 0xe8, 0x52, 0x4f, 0x13, 0xf2, 0x12, 0xaa, 0x12, 0xea, 0x12, 0xa4, 0x14, 0xe4, 0x15, 0xaa, 0x10, 0x31, 0x00, 0x00 },
{ 0xe5, 0xf1, 0x1f, 0x3e, 0x11, 0x22, 0x1f, 0x3e, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0x10, 0x24, 0x10, 0x3f, 0xbf, 0x29, 0x22, 0x2f, 0x52, 0x49, 0x14, 0x4f, 0x08, 0x59, 0x14, 0x01, 0x63, 0x00, 0x00 },
{ 0xe5, 0xf2, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x04, 0x90, 0x08, 0x88, 0x1f, 0xfc, 0x68, 0x8b, 0x0f, 0xf8, 0x08, 0x88, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xe5, 0xf3, 0x10, 0x20, 0x10, 0x40, 0x13, 0xfe, 0x7c, 0x88, 0x11, 0x24, 0x12, 0x22, 0x15, 0xfd, 0x11, 0x24, 0x1d, 0xfc, 0x71, 0x24, 0x11, 0x24, 0x11, 0xfc, 0x10, 0x21, 0x10, 0x21, 0x30, 0x1f, 0x00, 0x00 },
{ 0xe5, 0xf4, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x88, 0x41, 0x24, 0x22, 0x22, 0x15, 0xfd, 0x01, 0x24, 0x01, 0xfc, 0x11, 0x24, 0x11, 0x24, 0x21, 0xfc, 0x20, 0x21, 0x40, 0x21, 0x40, 0x1f, 0x00, 0x00 },
{ 0xe5, 0xf5, 0x20, 0x82, 0x3f, 0xfe, 0x22, 0x22, 0x12, 0x24, 0x7f, 0xff, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xe5, 0xf6, 0x22, 0x22, 0x12, 0x24, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe5, 0xf7, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x0e, 0x00, 0x00 },
{ 0xe5, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x08, 0x00, 0x10, 0x02, 0x20, 0x01, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x81, 0x00, 0x82, 0x00, 0x84, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0x80, 0x00, 0x00 },
{ 0xe5, 0xf9, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0x88, 0x08, 0x84, 0x10, 0x82, 0x20, 0x82, 0x03, 0x80, 0x00, 0x00 },
{ 0xe5, 0xfa, 0x3f, 0xe4, 0x22, 0x84, 0x2f, 0xe4, 0x22, 0x84, 0x2f, 0xff, 0x29, 0x25, 0x2f, 0xe5, 0x29, 0x25, 0x2f, 0xe5, 0x21, 0x05, 0x2f, 0xe5, 0x29, 0x29, 0x2b, 0xa9, 0x48, 0x29, 0x48, 0xd2, 0x00, 0x00 },
{ 0xe5, 0xfb, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xe5, 0xfc, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x02, 0x10, 0x02, 0x10, 0x04, 0x20, 0x04, 0x20, 0x0f, 0x40, 0x00, 0xe0, 0x01, 0x18, 0x06, 0x04, 0x38, 0x02, 0x00, 0x00 },
{ 0xe5, 0xfd, 0x10, 0x00, 0x10, 0x00, 0x10, 0x7e, 0x7e, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x24, 0x42, 0x44, 0x42, 0x64, 0x42, 0x58, 0x42, 0x0c, 0x42, 0x12, 0x42, 0x21, 0x7e, 0x40, 0x00, 0x00, 0x00 },
{ 0xe5, 0xfe, 0x00, 0x80, 0x1f, 0xff, 0x10, 0x80, 0x10, 0xf8, 0x17, 0xff, 0x14, 0x41, 0x15, 0xfc, 0x14, 0x40, 0x15, 0xff, 0x15, 0x24, 0x27, 0xff, 0x25, 0x24, 0x2b, 0xfe, 0x4a, 0x52, 0x57, 0xff, 0x00, 0x00 },
{ 0xe6, 0xa1, 0x10, 0x40, 0x10, 0x40, 0x7e, 0xff, 0x10, 0x80, 0x11, 0x46, 0x10, 0x78, 0x1e, 0x49, 0x12, 0x4a, 0x12, 0x4c, 0x12, 0x48, 0x22, 0x48, 0x22, 0x44, 0x22, 0x44, 0x42, 0x72, 0x4c, 0xc1, 0x00, 0x00 },
{ 0xe6, 0xa2, 0x14, 0x10, 0x27, 0x90, 0x24, 0x90, 0x24, 0xbf, 0x37, 0xa9, 0x22, 0xca, 0x2a, 0x8a, 0x3b, 0x88, 0x2a, 0x88, 0x2a, 0x88, 0x7f, 0xd4, 0x00, 0x14, 0x12, 0x22, 0x21, 0x42, 0x40, 0x81, 0x00, 0x00 },
{ 0xe6, 0xa3, 0x20, 0x40, 0x10, 0x40, 0x08, 0x40, 0x00, 0x40, 0x47, 0xff, 0x20, 0x84, 0x10, 0x84, 0x01, 0x04, 0x03, 0x08, 0x10, 0xc8, 0x10, 0x30, 0x20, 0x18, 0x20, 0x24, 0x40, 0xc2, 0x47, 0x01, 0x00, 0x00 },
{ 0xe6, 0xa4, 0x20, 0x40, 0x10, 0x78, 0x08, 0x40, 0x43, 0xff, 0x22, 0x41, 0x12, 0xfc, 0x02, 0x40, 0x02, 0xff, 0x12, 0x92, 0x12, 0xfe, 0x22, 0x92, 0x22, 0xfe, 0x44, 0x52, 0x45, 0x45, 0x09, 0x3c, 0x00, 0x00 },
{ 0xe6, 0xa5, 0x00, 0x10, 0x00, 0x5e, 0x7c, 0x92, 0x10, 0x92, 0x10, 0xde, 0x10, 0x8a, 0x7c, 0xaa, 0x10, 0xee, 0x10, 0xaa, 0x10, 0xaa, 0x1d, 0xff, 0x70, 0x00, 0x00, 0x44, 0x00, 0x82, 0x01, 0x01, 0x00, 0x00 },
{ 0xe6, 0xa6, 0x00, 0x10, 0x00, 0x5e, 0x7e, 0x92, 0x10, 0x92, 0x10, 0xde, 0x20, 0x8a, 0x3c, 0xaa, 0x64, 0xee, 0x24, 0xaa, 0x24, 0xaa, 0x25, 0xff, 0x24, 0x00, 0x3c, 0x44, 0x00, 0x82, 0x01, 0x01, 0x00, 0x00 },
{ 0xe6, 0xa7, 0x01, 0xff, 0x7d, 0x12, 0x11, 0x7f, 0x11, 0x12, 0x21, 0x7f, 0x3d, 0x49, 0x65, 0x7f, 0x25, 0x49, 0x25, 0x7f, 0x25, 0x08, 0x25, 0x7f, 0x3d, 0x49, 0x02, 0x4d, 0x02, 0x51, 0x04, 0x46, 0x00, 0x00 },
{ 0xe6, 0xa8, 0x05, 0x00, 0x19, 0x1c, 0x11, 0xc4, 0x11, 0x04, 0x1d, 0x1c, 0x11, 0xc4, 0x10, 0x44, 0x1d, 0x5c, 0x11, 0x44, 0x11, 0x44, 0x7f, 0xff, 0x00, 0x00, 0x02, 0x20, 0x0c, 0x18, 0x30, 0x06, 0x00, 0x00 },
{ 0xe6, 0xa9, 0x08, 0x10, 0x08, 0x10, 0x3e, 0x28, 0x22, 0x44, 0x2a, 0x83, 0x2b, 0x7c, 0x22, 0x10, 0x2e, 0x10, 0x7a, 0xfe, 0x2a, 0x10, 0x2a, 0x52, 0x2a, 0x51, 0x22, 0x91, 0x42, 0x10, 0x4e, 0x30, 0x00, 0x00 },
{ 0xe6, 0xaa, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0a, 0x20, 0x08, 0x00, 0x08, 0x7e, 0x7f, 0x42, 0x11, 0x42, 0x11, 0x42, 0x11, 0x42, 0x32, 0x42, 0x2a, 0x42, 0x06, 0x42, 0x19, 0x42, 0x60, 0x7e, 0x00, 0x00 },
{ 0xe6, 0xab, 0x08, 0x80, 0x33, 0xee, 0x20, 0x82, 0x23, 0xe2, 0x3a, 0xae, 0x23, 0xe2, 0x22, 0xa2, 0x3b, 0xee, 0x20, 0x82, 0x23, 0xe2, 0x20, 0x82, 0x7f, 0xff, 0x04, 0x18, 0x18, 0x06, 0x60, 0x01, 0x00, 0x00 },
{ 0xe6, 0xac, 0x09, 0x1c, 0x11, 0xc4, 0x1d, 0x1c, 0x11, 0xc4, 0x1c, 0x5c, 0x11, 0x44, 0x7f, 0xff, 0x08, 0x88, 0x1f, 0xfc, 0x64, 0x93, 0x07, 0xf0, 0x04, 0x90, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe6, 0xad, 0x00, 0x00, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x47, 0xc2, 0x44, 0x42, 0x47, 0xc2, 0x41, 0x02, 0x4f, 0xe2, 0x48, 0x22, 0x48, 0x22, 0x4f, 0xe2, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe6, 0xae, 0x08, 0x10, 0x14, 0x28, 0x22, 0x44, 0x5c, 0x82, 0x01, 0x01, 0x3e, 0x7c, 0x22, 0x10, 0x3e, 0x10, 0x22, 0xfe, 0x3e, 0x10, 0x20, 0x10, 0x3e, 0x92, 0x20, 0x91, 0x3f, 0x11, 0x20, 0x30, 0x00, 0x00 },
{ 0xe6, 0xaf, 0x01, 0xef, 0x7c, 0x00, 0x51, 0xff, 0x7d, 0x11, 0x51, 0x55, 0x7c, 0x10, 0x51, 0xff, 0x51, 0x28, 0x7d, 0xff, 0x05, 0x29, 0x55, 0xff, 0x55, 0x49, 0x45, 0x6e, 0x05, 0x49, 0x0a, 0xef, 0x00, 0x00 },
{ 0xe6, 0xb0, 0x1f, 0x3e, 0x00, 0x00, 0x1f, 0x3e, 0x15, 0x2a, 0x15, 0x2a, 0x00, 0x80, 0x1f, 0xfe, 0x11, 0x20, 0x1f, 0xfe, 0x11, 0x22, 0x1f, 0xfe, 0x14, 0x24, 0x27, 0xb9, 0x24, 0x21, 0x4f, 0x9f, 0x00, 0x00 },
{ 0xe6, 0xb1, 0x0c, 0x40, 0x38, 0x7e, 0x08, 0x92, 0x7f, 0x12, 0x1c, 0x22, 0x2a, 0x42, 0x48, 0x8c, 0x09, 0x40, 0x06, 0x30, 0x38, 0x8e, 0x04, 0x90, 0x03, 0xe0, 0x06, 0xb0, 0x18, 0x8c, 0x13, 0x02, 0x00, 0x00 },
{ 0xe6, 0xb2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x12, 0x24, 0x12, 0x22, 0x22, 0x22, 0x22, 0x21, 0x44, 0x21, 0x04, 0x20, 0x08, 0x20, 0x10, 0x20, 0x20, 0xe0, 0x00, 0x00 },
{ 0xe6, 0xb3, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x3f, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x02, 0x04, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 0x70, 0x00, 0x00 },
{ 0xe6, 0xb4, 0x10, 0x14, 0x10, 0x12, 0x10, 0x10, 0x13, 0xff, 0x7c, 0x10, 0x10, 0x10, 0x13, 0xd2, 0x12, 0x52, 0x12, 0x52, 0x13, 0xd4, 0x18, 0x0c, 0x70, 0xc9, 0x07, 0x15, 0x00, 0x63, 0x01, 0x81, 0x00, 0x00 },
{ 0xe6, 0xb5, 0x08, 0x00, 0x08, 0xf8, 0x10, 0x88, 0x20, 0x89, 0x48, 0x89, 0x09, 0x0f, 0x12, 0x00, 0x13, 0xfc, 0x30, 0x84, 0x50, 0x84, 0x10, 0x48, 0x10, 0x30, 0x10, 0x30, 0x10, 0xcc, 0x13, 0x03, 0x00, 0x00 },
{ 0xe6, 0xb6, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x04, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x62, 0x22, 0x04, 0x42, 0x18, 0x84, 0x61, 0x04, 0x06, 0x38, 0x00, 0x00 },
{ 0xe6, 0xb7, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x84, 0x17, 0x38, 0x11, 0x08, 0x17, 0xfe, 0x13, 0x9c, 0x15, 0x6a, 0x11, 0x08, 0x10, 0x00, 0x17, 0xfe, 0x14, 0x02, 0x27, 0xfe, 0x24, 0x02, 0x47, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xb8, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x84, 0x13, 0x18, 0x11, 0x08, 0x17, 0xfe, 0x13, 0x9c, 0x15, 0x6a, 0x11, 0x08, 0x10, 0x20, 0x10, 0x20, 0x11, 0x3e, 0x21, 0x20, 0x21, 0x20, 0x4f, 0xff, 0x00, 0x00 },
{ 0xe6, 0xb9, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x51, 0xf0, 0x31, 0x10, 0x11, 0x12, 0x12, 0x1e, 0x34, 0x00, 0x57, 0xfc, 0x11, 0x08, 0x10, 0x90, 0x20, 0x60, 0x21, 0x98, 0x46, 0x06, 0x00, 0x00 },
{ 0xe6, 0xba, 0x11, 0xff, 0x11, 0x29, 0x25, 0x29, 0x45, 0xff, 0x28, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x25, 0xff, 0x7c, 0x44, 0x14, 0x48, 0x51, 0xff, 0x54, 0x10, 0x54, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xe6, 0xbb, 0x00, 0x00, 0x3c, 0xff, 0x00, 0xa9, 0x7e, 0xff, 0x00, 0x10, 0x3c, 0x7e, 0x00, 0x10, 0x3c, 0xff, 0x00, 0x44, 0x00, 0x28, 0x3c, 0xff, 0x24, 0x10, 0x24, 0x7e, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xe6, 0xbc, 0x10, 0x92, 0x10, 0xba, 0x7d, 0x2c, 0x11, 0x7d, 0x7c, 0xaa, 0x55, 0x6d, 0x7f, 0xff, 0x54, 0x90, 0x7c, 0x10, 0x11, 0xff, 0x7c, 0x38, 0x10, 0x54, 0x10, 0x92, 0x11, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xe6, 0xbd, 0x41, 0x04, 0x20, 0x84, 0x10, 0x88, 0x07, 0xff, 0x40, 0x20, 0x22, 0x22, 0x12, 0x22, 0x02, 0x22, 0x03, 0xfe, 0x70, 0x20, 0x10, 0x40, 0x10, 0x40, 0x10, 0x80, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe6, 0xbe, 0x00, 0x00, 0x3f, 0x7f, 0x24, 0x55, 0x3f, 0x7f, 0x24, 0x08, 0x3f, 0x3e, 0x24, 0x08, 0x24, 0x7f, 0x3f, 0x22, 0x01, 0x14, 0x55, 0x7f, 0x55, 0x08, 0x42, 0x3e, 0x02, 0x08, 0x0c, 0x08, 0x00, 0x00 },
{ 0xe6, 0xbf, 0x00, 0x88, 0x77, 0xff, 0x50, 0x88, 0x50, 0xf8, 0x51, 0x04, 0x51, 0x75, 0x57, 0x56, 0x51, 0x54, 0x51, 0x54, 0x53, 0x75, 0x75, 0x03, 0x00, 0x00, 0x02, 0x92, 0x02, 0x49, 0x04, 0x49, 0x00, 0x00 },
{ 0xe6, 0xc0, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x11, 0xfe, 0x7d, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x56, 0x10, 0x20, 0x1c, 0x20, 0x73, 0xfe, 0x00, 0x20, 0x00, 0x50, 0x00, 0x88, 0x07, 0x07, 0x00, 0x00 },
{ 0xe6, 0xc1, 0x10, 0x00, 0x13, 0xff, 0x10, 0x84, 0x7c, 0x84, 0x24, 0x84, 0x24, 0x84, 0x24, 0xa4, 0x24, 0xdf, 0x27, 0x84, 0x68, 0x84, 0x58, 0x84, 0x08, 0x84, 0x15, 0x04, 0x25, 0x04, 0x42, 0x04, 0x00, 0x00 },
{ 0xe6, 0xc2, 0x10, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7c, 0xfc, 0x24, 0x00, 0x25, 0xfe, 0x25, 0x02, 0x25, 0x02, 0x45, 0xfe, 0x69, 0x02, 0x59, 0x02, 0x09, 0xfe, 0x15, 0x02, 0x21, 0x02, 0x41, 0x0e, 0x00, 0x00 },
{ 0xe6, 0xc3, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x00, 0xf8, 0x3f, 0x06, 0x00, 0x00 },
{ 0xe6, 0xc4, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x10, 0x80, 0x20, 0x80, 0x4f, 0xfc, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe6, 0xc5, 0x00, 0x00, 0x7c, 0x0e, 0x05, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x10, 0x90, 0x3c, 0x9e, 0x44, 0x90, 0x04, 0x90, 0x28, 0x90, 0x28, 0x90, 0x10, 0x7f, 0x18, 0x00, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe6, 0xc6, 0x10, 0x92, 0x10, 0x54, 0x11, 0xff, 0x18, 0x38, 0x54, 0x54, 0x55, 0x93, 0x50, 0x10, 0x50, 0x82, 0x10, 0xef, 0x11, 0x2a, 0x12, 0xaa, 0x10, 0x4f, 0x10, 0x82, 0x11, 0x02, 0x12, 0x02, 0x00, 0x00 },
{ 0xe6, 0xc7, 0x11, 0xc4, 0x28, 0x0a, 0x51, 0xd4, 0x24, 0x09, 0x7d, 0xdf, 0x10, 0x04, 0x55, 0xd5, 0x55, 0x55, 0x11, 0xc4, 0x00, 0x00, 0x14, 0x84, 0x24, 0x42, 0x44, 0x49, 0x44, 0x0d, 0x03, 0xf8, 0x00, 0x00 },
{ 0xe6, 0xc8, 0x10, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7c, 0xfc, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x1d, 0x02, 0x71, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x31, 0x0e, 0x00, 0x00 },
{ 0xe6, 0xc9, 0x10, 0x00, 0x13, 0xc3, 0x10, 0x5c, 0x7c, 0x84, 0x10, 0x84, 0x11, 0x14, 0x13, 0xd7, 0x1c, 0x54, 0x70, 0x54, 0x10, 0x54, 0x12, 0x94, 0x11, 0x8f, 0x10, 0x80, 0x11, 0x60, 0x72, 0x1f, 0x00, 0x00 },
{ 0xe6, 0xca, 0x10, 0x88, 0x10, 0x8a, 0x10, 0xe9, 0x7d, 0x28, 0x11, 0x3f, 0x12, 0xa8, 0x10, 0x54, 0x1d, 0x54, 0x70, 0xa2, 0x11, 0x22, 0x12, 0x41, 0x10, 0x00, 0x12, 0x92, 0x12, 0x49, 0x74, 0x49, 0x00, 0x00 },
{ 0xe6, 0xcb, 0x10, 0x40, 0x10, 0x7c, 0x10, 0x84, 0x7c, 0xf8, 0x10, 0x08, 0x13, 0xff, 0x38, 0x48, 0x34, 0xe8, 0x33, 0x29, 0x50, 0x5a, 0x53, 0x94, 0x50, 0x34, 0x10, 0xd2, 0x13, 0x11, 0x10, 0x60, 0x00, 0x00 },
{ 0xe6, 0xcc, 0x20, 0x40, 0x10, 0x40, 0x08, 0x88, 0x00, 0x84, 0x41, 0x3c, 0x23, 0xc2, 0x10, 0x02, 0x00, 0x90, 0x10, 0x90, 0x10, 0x90, 0x20, 0x90, 0x21, 0x11, 0x41, 0x11, 0x42, 0x11, 0x04, 0x0f, 0x00, 0x00 },
{ 0xe6, 0xcd, 0x20, 0x38, 0x10, 0x88, 0x08, 0x88, 0x00, 0x84, 0x41, 0x04, 0x21, 0x02, 0x12, 0x01, 0x00, 0x00, 0x01, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xce, 0x20, 0x00, 0x17, 0x83, 0x00, 0xbc, 0x01, 0x04, 0x41, 0x04, 0x22, 0x24, 0x03, 0xa7, 0x00, 0xa4, 0x10, 0xa4, 0x10, 0xa4, 0x25, 0x24, 0x23, 0x1f, 0x41, 0x00, 0x42, 0xc0, 0x04, 0x3f, 0x00, 0x00 },
{ 0xe6, 0xcf, 0x21, 0xfc, 0x11, 0x04, 0x09, 0x04, 0x01, 0xfc, 0x40, 0x00, 0x23, 0xfe, 0x12, 0x02, 0x02, 0x02, 0x03, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x23, 0xfe, 0x22, 0x02, 0x42, 0x02, 0x42, 0x0e, 0x00, 0x00 },
{ 0xe6, 0xd0, 0x22, 0x49, 0x12, 0x49, 0x0a, 0x49, 0x03, 0xcf, 0x42, 0x01, 0x22, 0x01, 0x13, 0xff, 0x02, 0x01, 0x02, 0x01, 0x13, 0xcf, 0x12, 0x49, 0x22, 0x49, 0x24, 0x49, 0x44, 0x49, 0x48, 0x49, 0x00, 0x00 },
{ 0xe6, 0xd1, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x04, 0x01, 0x45, 0xfd, 0x20, 0x20, 0x13, 0xfe, 0x02, 0x22, 0x03, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x23, 0xfe, 0x20, 0x00, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xe6, 0xd2, 0x44, 0x10, 0x22, 0xfe, 0x00, 0x10, 0x00, 0xfe, 0x48, 0x92, 0x24, 0xfe, 0x00, 0x92, 0x00, 0x92, 0x16, 0xfe, 0x12, 0x10, 0x23, 0xff, 0x22, 0x10, 0x42, 0x10, 0x45, 0x00, 0x08, 0xff, 0x00, 0x00 },
{ 0xe6, 0xd3, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x22, 0x56, 0x22, 0x5a, 0x22, 0x52, 0xfa, 0x52, 0x22, 0x12, 0x22, 0x12, 0x22, 0x12, 0x52, 0x2a, 0x52, 0x26, 0x8a, 0x22, 0x02, 0x42, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xd4, 0x08, 0x10, 0x08, 0x14, 0x1f, 0x12, 0x11, 0x10, 0x29, 0x7e, 0x46, 0x10, 0x12, 0x28, 0x0c, 0x28, 0x08, 0x44, 0x10, 0x82, 0x61, 0x01, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xe6, 0xd5, 0x10, 0x00, 0x13, 0xff, 0x10, 0x50, 0x54, 0x50, 0x59, 0xfe, 0x51, 0x52, 0x51, 0x5e, 0x11, 0x82, 0x11, 0xfe, 0x10, 0x20, 0x28, 0x20, 0x25, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe6, 0xd6, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x14, 0x20, 0x55, 0xfe, 0x59, 0xa6, 0x51, 0x6a, 0x51, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x28, 0x70, 0x24, 0xa8, 0x25, 0x24, 0x42, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xe6, 0xd7, 0x10, 0x88, 0x10, 0x8a, 0x11, 0xe9, 0x51, 0x28, 0x55, 0x3f, 0x5a, 0xa8, 0x52, 0x48, 0x55, 0x48, 0x10, 0x94, 0x11, 0x14, 0x2a, 0x22, 0x24, 0x41, 0x22, 0x92, 0x42, 0x49, 0x44, 0x49, 0x00, 0x00 },
{ 0xe6, 0xd8, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0b, 0xe8, 0x08, 0x08, 0x7b, 0xe9, 0x0a, 0x2e, 0x0a, 0x28, 0x1a, 0x28, 0x6b, 0xe9, 0x08, 0x0f, 0x00, 0x00, 0x14, 0x44, 0x22, 0x22, 0x42, 0x21, 0x00, 0x00 },
{ 0xe6, 0xd9, 0x01, 0x08, 0x00, 0xbe, 0x7c, 0x08, 0x12, 0x3e, 0x11, 0x2a, 0x10, 0x3e, 0x7c, 0x2a, 0x10, 0x3e, 0x13, 0x88, 0x10, 0xff, 0x1c, 0x88, 0x70, 0x88, 0x00, 0x88, 0x01, 0x40, 0x02, 0x3f, 0x00, 0x00 },
{ 0xe6, 0xda, 0x00, 0x00, 0x7f, 0xff, 0x10, 0x84, 0x10, 0x84, 0x20, 0x84, 0x3c, 0x84, 0x64, 0xa4, 0x24, 0xdf, 0x27, 0x84, 0x24, 0x84, 0x24, 0x84, 0x3c, 0x84, 0x01, 0x04, 0x01, 0x04, 0x02, 0x04, 0x00, 0x00 },
{ 0xe6, 0xdb, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x20, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x64, 0x82, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x28, 0x24, 0x28, 0x3c, 0x49, 0x00, 0x89, 0x03, 0x0f, 0x00, 0x00 },
{ 0xe6, 0xdc, 0x00, 0x1c, 0x1f, 0xe0, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x70, 0x0f, 0x80, 0x00, 0x80, 0x7f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe6, 0xdd, 0x08, 0x10, 0x1f, 0x3f, 0x68, 0xc8, 0x04, 0x04, 0x00, 0x00, 0x3c, 0x1c, 0x08, 0xf0, 0x10, 0x10, 0x3c, 0x1e, 0x04, 0x90, 0x08, 0x90, 0x28, 0x90, 0x10, 0x7f, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe6, 0xde, 0x10, 0x40, 0x14, 0x7c, 0x24, 0x84, 0x48, 0xf8, 0x28, 0x08, 0x13, 0xff, 0x24, 0x60, 0x7c, 0x92, 0x11, 0x34, 0x54, 0x48, 0x55, 0x9c, 0x54, 0x2a, 0x50, 0xc9, 0x13, 0x08, 0x10, 0x30, 0x00, 0x00 },
{ 0xe6, 0xdf, 0x10, 0x10, 0x14, 0x10, 0x25, 0xff, 0x48, 0x10, 0x28, 0xfe, 0x10, 0x92, 0x24, 0xd6, 0x7c, 0xba, 0x10, 0x92, 0x54, 0xfe, 0x54, 0x38, 0x54, 0x54, 0x50, 0x92, 0x11, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xe6, 0xe0, 0x10, 0x10, 0x14, 0x10, 0x25, 0xff, 0x49, 0x01, 0x28, 0x7c, 0x10, 0x10, 0x24, 0xfe, 0x7e, 0x92, 0x12, 0xfe, 0x54, 0x92, 0x54, 0xfe, 0x52, 0x00, 0x52, 0x44, 0x10, 0x82, 0x11, 0x01, 0x00, 0x00 },
{ 0xe6, 0xe1, 0x00, 0x44, 0x7e, 0x44, 0x24, 0x88, 0x24, 0xaa, 0x3c, 0x44, 0x24, 0xaa, 0x24, 0xee, 0x3c, 0x00, 0x24, 0xaa, 0x24, 0xaa, 0x2e, 0xaa, 0x74, 0xee, 0x04, 0x28, 0x04, 0x48, 0x04, 0x88, 0x00, 0x00 },
{ 0xe6, 0xe2, 0x09, 0x00, 0x08, 0x9e, 0x10, 0x40, 0x24, 0x00, 0x44, 0x00, 0x09, 0x3f, 0x10, 0x84, 0x10, 0x44, 0x30, 0x04, 0x50, 0x84, 0x10, 0x84, 0x11, 0x04, 0x11, 0x04, 0x12, 0x04, 0x12, 0x1c, 0x00, 0x00 },
{ 0xe6, 0xe3, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x7f, 0x08, 0x51, 0x3e, 0x51, 0x2a, 0x92, 0x3e, 0x10, 0x2a, 0x10, 0x2a, 0x28, 0x3e, 0x28, 0x08, 0x28, 0x7f, 0x44, 0x08, 0x44, 0x08, 0x82, 0x09, 0x01, 0x00, 0x00 },
{ 0xe6, 0xe4, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x7f, 0x7f, 0x14, 0x14, 0x22, 0xa2, 0x3f, 0xfe, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe6, 0xe5, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x20, 0x20, 0x13, 0xfe, 0x00, 0x20, 0x21, 0xfc, 0x11, 0x24, 0x01, 0xfc, 0x01, 0x24, 0x71, 0xfc, 0x10, 0x20, 0x13, 0xfe, 0x28, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe6, 0xe6, 0x20, 0x20, 0x13, 0xfe, 0x08, 0x20, 0x41, 0xfc, 0x21, 0x24, 0x11, 0xfc, 0x01, 0x24, 0x01, 0xfc, 0x70, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x18, 0x20, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe6, 0xe7, 0x18, 0x3c, 0x24, 0x04, 0x40, 0x44, 0x00, 0x44, 0x7c, 0x82, 0x10, 0x82, 0x11, 0x01, 0x7c, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x54, 0x82, 0x34, 0x82, 0x10, 0x82, 0x18, 0x82, 0x60, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xe8, 0x18, 0x10, 0x14, 0x10, 0x25, 0xff, 0x20, 0x10, 0x7c, 0xfe, 0x10, 0x92, 0x10, 0xd6, 0x7c, 0xba, 0x10, 0x92, 0x54, 0xfe, 0x54, 0x38, 0x50, 0x54, 0x1c, 0x92, 0x71, 0x11, 0x40, 0x10, 0x00, 0x00 },
{ 0xe6, 0xe9, 0x00, 0x44, 0x7f, 0xff, 0x01, 0x10, 0x1f, 0xf9, 0x10, 0x0d, 0x1f, 0xfb, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x1f, 0xff, 0x24, 0x91, 0x42, 0x49, 0x00, 0x06, 0x00, 0x00 },
{ 0xe6, 0xea, 0x00, 0x02, 0x3f, 0x82, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x1f, 0x22, 0x11, 0x22, 0x11, 0x22, 0x29, 0x22, 0x46, 0x22, 0x02, 0x22, 0x04, 0x22, 0x04, 0x02, 0x08, 0x02, 0x10, 0x1e, 0x00, 0x00 },
{ 0xe6, 0xeb, 0x00, 0x80, 0x00, 0x80, 0x10, 0x88, 0x10, 0x84, 0x27, 0xa2, 0x40, 0xc2, 0x01, 0x00, 0x06, 0x80, 0x18, 0x80, 0x6f, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x02, 0x04, 0x0c, 0x08, 0x70, 0x70, 0x00, 0x00 },
{ 0xe6, 0xec, 0x00, 0x00, 0x03, 0xfe, 0x7a, 0x22, 0x4a, 0x22, 0x4a, 0x22, 0x4b, 0xfe, 0x4a, 0x22, 0x4a, 0x22, 0x4a, 0x52, 0x4a, 0x52, 0x7a, 0x8a, 0x02, 0x8a, 0x03, 0x06, 0x02, 0x02, 0x03, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xed, 0x10, 0x9c, 0x10, 0x84, 0x11, 0x02, 0x5b, 0xff, 0x55, 0x02, 0x55, 0x02, 0x51, 0x02, 0x51, 0xfe, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x10, 0x88, 0x10, 0x89, 0x11, 0x09, 0x12, 0x07, 0x00, 0x00 },
{ 0xe6, 0xee, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x02, 0x02, 0x43, 0xfe, 0x22, 0x02, 0x12, 0x02, 0x03, 0xfe, 0x00, 0x00, 0x10, 0x20, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe6, 0xef, 0x00, 0x02, 0x3f, 0x82, 0x08, 0x22, 0x08, 0x22, 0x1f, 0x22, 0x31, 0x22, 0x49, 0x22, 0x06, 0x22, 0x04, 0x02, 0x18, 0x0e, 0x60, 0x00, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xe6, 0xf0, 0x08, 0x20, 0x3e, 0x20, 0x08, 0xfc, 0x7f, 0x24, 0x14, 0x24, 0x26, 0xa4, 0x48, 0x64, 0x3e, 0x55, 0x08, 0x55, 0x0e, 0x83, 0x79, 0x01, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xe6, 0xf1, 0x00, 0x02, 0x1f, 0xc2, 0x04, 0x12, 0x0f, 0x92, 0x38, 0x92, 0x05, 0x12, 0x02, 0x02, 0x0c, 0x0e, 0x30, 0x80, 0x7f, 0xff, 0x02, 0x44, 0x0c, 0x28, 0x34, 0x10, 0x07, 0x8c, 0x1c, 0x03, 0x00, 0x00 },
{ 0xe6, 0xf2, 0x00, 0x5c, 0x3c, 0x44, 0x00, 0x82, 0x01, 0xfd, 0x7e, 0x84, 0x00, 0x84, 0x3c, 0x84, 0x00, 0xfc, 0x3c, 0x48, 0x00, 0x48, 0x3c, 0x48, 0x24, 0x89, 0x24, 0x89, 0x3d, 0x09, 0x02, 0x07, 0x00, 0x00 },
{ 0xe6, 0xf3, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x45, 0xe2, 0x48, 0x12, 0x57, 0xea, 0x44, 0x22, 0x47, 0xe2, 0x42, 0x82, 0x42, 0x82, 0x44, 0x92, 0x58, 0x76, 0x00, 0x00 },
{ 0xe6, 0xf4, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0x8a, 0x28, 0x89, 0x2f, 0x88, 0x28, 0xff, 0x2f, 0x88, 0x20, 0x08, 0x2f, 0x88, 0x28, 0x94, 0x2f, 0x94, 0x28, 0x94, 0x4f, 0xa2, 0x48, 0xa2, 0x49, 0xc1, 0x00, 0x00 },
{ 0xe6, 0xf5, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x90, 0x23, 0x60, 0x3f, 0xff, 0x21, 0x20, 0x2f, 0xfc, 0x21, 0x24, 0x3f, 0xff, 0x21, 0x24, 0x2f, 0xfc, 0x23, 0x30, 0x25, 0x28, 0x49, 0x24, 0x51, 0x23, 0x00, 0x00 },
{ 0xe6, 0xf6, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x73, 0xe7, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x14, 0x84, 0x24, 0x42, 0x44, 0x49, 0x44, 0x09, 0x03, 0xf8, 0x00, 0x00 },
{ 0xe6, 0xf7, 0x10, 0x20, 0x10, 0x50, 0x10, 0x88, 0x7d, 0x04, 0x12, 0xf3, 0x10, 0x00, 0x11, 0xfc, 0x1c, 0x08, 0x70, 0x10, 0x10, 0x20, 0x10, 0x92, 0x12, 0x91, 0x14, 0x85, 0x14, 0x84, 0x60, 0x7c, 0x00, 0x00 },
{ 0xe6, 0xf8, 0x10, 0x40, 0x08, 0x40, 0x43, 0xf8, 0x20, 0x48, 0x08, 0x89, 0x11, 0x09, 0x26, 0x0f, 0x40, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xe6, 0xf9, 0x00, 0x10, 0x7e, 0x10, 0x10, 0x28, 0x10, 0x44, 0x11, 0xbb, 0x3e, 0x00, 0x24, 0xee, 0x24, 0xaa, 0x54, 0xaa, 0x48, 0xee, 0x08, 0x00, 0x08, 0x44, 0x10, 0x44, 0x10, 0xaa, 0x21, 0x11, 0x00, 0x00 },
{ 0xe6, 0xfa, 0x00, 0x80, 0x04, 0x84, 0x08, 0x88, 0x11, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x30, 0x86, 0x00, 0x80, 0x04, 0x84, 0x09, 0x48, 0x11, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe6, 0xfb, 0x10, 0x40, 0x10, 0x7e, 0x10, 0x82, 0x10, 0x82, 0x55, 0x02, 0x54, 0x04, 0x54, 0x18, 0x50, 0x40, 0x10, 0x8e, 0x11, 0x02, 0x29, 0x02, 0x25, 0xce, 0x25, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xe6, 0xfc, 0x00, 0x10, 0x00, 0x51, 0x7c, 0x52, 0x10, 0xaa, 0x10, 0x28, 0x10, 0x44, 0x7d, 0x83, 0x10, 0x10, 0x10, 0x10, 0x10, 0x51, 0x1c, 0x52, 0x70, 0xaa, 0x00, 0x28, 0x00, 0x44, 0x01, 0x83, 0x00, 0x00 },
{ 0xe6, 0xfd, 0x14, 0x10, 0x7f, 0x10, 0x55, 0x3c, 0x7f, 0x24, 0x55, 0x48, 0x7f, 0x7f, 0x00, 0xc9, 0x7f, 0x49, 0x00, 0x49, 0x3e, 0x49, 0x22, 0x7f, 0x3e, 0x40, 0x24, 0x41, 0x17, 0x41, 0x78, 0x3f, 0x00, 0x00 },
{ 0xe6, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xe7, 0xa1, 0x10, 0x20, 0x1f, 0x3e, 0x24, 0xc8, 0x42, 0x84, 0x3f, 0xff, 0x22, 0x10, 0x3f, 0xff, 0x21, 0x20, 0x2f, 0xfc, 0x21, 0x24, 0x3f, 0xff, 0x21, 0x24, 0x2f, 0xfc, 0x47, 0x38, 0x79, 0x27, 0x00, 0x00 },
{ 0xe7, 0xa2, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x02, 0x43, 0xe2, 0x4c, 0x22, 0x42, 0xc2, 0x4c, 0x72, 0x48, 0x12, 0x4e, 0xf2, 0x48, 0x12, 0x4f, 0xf2, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe7, 0xa3, 0x1f, 0x02, 0x10, 0x0c, 0x1f, 0x31, 0x10, 0x06, 0x7f, 0xb9, 0x11, 0x06, 0x7e, 0xb8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x7f, 0xff, 0x10, 0x04, 0x7f, 0xff, 0x10, 0x04, 0x10, 0x3c, 0x00, 0x00 },
{ 0xe7, 0xa4, 0x10, 0x0a, 0x10, 0x09, 0x1e, 0x08, 0x10, 0xff, 0x10, 0x88, 0x7e, 0x89, 0x4a, 0xe9, 0x62, 0x89, 0x56, 0xea, 0x4a, 0xaa, 0x6a, 0xa4, 0x56, 0xe5, 0x66, 0x8d, 0x4a, 0x93, 0x7f, 0x21, 0x00, 0x00 },
{ 0xe7, 0xa5, 0x00, 0x88, 0x07, 0xff, 0x78, 0x88, 0x48, 0x00, 0x4b, 0xfe, 0x49, 0x24, 0x49, 0x24, 0x7b, 0xff, 0x49, 0x24, 0x49, 0x24, 0x4b, 0xfe, 0x48, 0x20, 0x7b, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe7, 0xa6, 0x48, 0x92, 0x29, 0x24, 0x11, 0x24, 0x10, 0x92, 0x29, 0xfe, 0x49, 0x4a, 0x15, 0x32, 0x15, 0x4a, 0x25, 0xfe, 0x25, 0xb4, 0x45, 0x6c, 0x05, 0xb4, 0x05, 0x6d, 0x09, 0xfb, 0x73, 0x21, 0x00, 0x00 },
{ 0xe7, 0xa7, 0x10, 0x88, 0x17, 0xff, 0x10, 0x88, 0x54, 0x00, 0x57, 0xfe, 0x59, 0x24, 0x51, 0x24, 0x17, 0xff, 0x11, 0x24, 0x11, 0x24, 0x2b, 0xfe, 0x24, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xe7, 0xa8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x08, 0xf8, 0x08, 0x00, 0x0f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x00 },
{ 0xe7, 0xa9, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0x84, 0x00, 0x84, 0x00, 0x88, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe7, 0xaa, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x21, 0x42, 0x22, 0x22, 0x2c, 0x1a, 0x23, 0xe2, 0x20, 0x02, 0x27, 0xf2, 0x20, 0x92, 0x20, 0x92, 0x20, 0xa2, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xe7, 0xab, 0x08, 0x10, 0x29, 0x12, 0x2a, 0x54, 0x48, 0x90, 0x14, 0x28, 0x22, 0x44, 0x40, 0x82, 0x7f, 0xfe, 0x40, 0x02, 0x40, 0x82, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xe7, 0xac, 0x00, 0x80, 0x7f, 0xff, 0x41, 0x09, 0x14, 0x84, 0x24, 0x14, 0x23, 0xf0, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x24, 0x7f, 0xff, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x03, 0x80, 0x00, 0x00 },
{ 0xe7, 0xad, 0x00, 0x80, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x08, 0xff, 0x14, 0x10, 0x63, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x00, 0x42, 0x7f, 0x7e, 0x09, 0x42, 0x09, 0x7e, 0x0a, 0x24, 0x08, 0xc3, 0x00, 0x00 },
{ 0xe7, 0xae, 0x10, 0x84, 0x12, 0xb5, 0x12, 0x94, 0x55, 0x4a, 0x55, 0x4a, 0x56, 0x31, 0x54, 0x00, 0x55, 0xff, 0x55, 0x01, 0x54, 0x10, 0x55, 0xff, 0x7c, 0x38, 0x00, 0x54, 0x00, 0x92, 0x03, 0x11, 0x00, 0x00 },
{ 0xe7, 0xaf, 0x3f, 0x81, 0x20, 0x82, 0x3f, 0x84, 0x20, 0x88, 0x3f, 0xb0, 0x04, 0x01, 0x7f, 0xc2, 0x00, 0x04, 0x3f, 0x88, 0x20, 0xb0, 0x3f, 0x81, 0x04, 0x02, 0x25, 0x04, 0x24, 0x88, 0x4c, 0xb0, 0x00, 0x00 },
{ 0xe7, 0xb0, 0x20, 0x20, 0x10, 0x50, 0x08, 0x88, 0x41, 0x04, 0x22, 0x03, 0x10, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x13, 0xfe, 0x10, 0x22, 0x20, 0x22, 0x20, 0x22, 0x40, 0x24, 0x40, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe7, 0xb1, 0x00, 0x20, 0x78, 0x20, 0x49, 0xfc, 0x49, 0x24, 0x49, 0x24, 0x79, 0x24, 0x49, 0x24, 0x49, 0x24, 0x4f, 0xff, 0x48, 0x50, 0x78, 0x88, 0x00, 0x88, 0x01, 0x04, 0x02, 0x02, 0x0c, 0x01, 0x00, 0x00 },
{ 0xe7, 0xb2, 0x00, 0x88, 0x78, 0x88, 0x4b, 0xff, 0x48, 0x88, 0x48, 0x20, 0x49, 0xfe, 0x79, 0x22, 0x49, 0x22, 0x49, 0x22, 0x4b, 0xff, 0x48, 0x20, 0x78, 0x50, 0x00, 0x88, 0x01, 0x04, 0x06, 0x03, 0x00, 0x00 },
{ 0xe7, 0xb3, 0x10, 0x00, 0x13, 0xf8, 0x11, 0x08, 0x7d, 0x10, 0x11, 0xfe, 0x11, 0x22, 0x32, 0xc2, 0x3a, 0x42, 0x34, 0xac, 0x50, 0x00, 0x53, 0xfe, 0x52, 0x52, 0x12, 0x52, 0x12, 0x52, 0x17, 0xff, 0x00, 0x00 },
{ 0xe7, 0xb4, 0x08, 0x08, 0x29, 0x29, 0x4a, 0x4a, 0x14, 0x14, 0x22, 0x22, 0x41, 0x41, 0x7f, 0xff, 0x40, 0x81, 0x40, 0x81, 0x1f, 0xfc, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xe7, 0xb5, 0x03, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x82, 0x00, 0x84, 0x3e, 0xc8, 0x02, 0xd0, 0x04, 0xa0, 0x04, 0xa0, 0x08, 0x90, 0x10, 0x88, 0x20, 0x84, 0x40, 0x83, 0x03, 0x80, 0x00, 0x00 },
{ 0xe7, 0xb6, 0x20, 0xc0, 0x10, 0x30, 0x08, 0x00, 0x01, 0xe0, 0x40, 0x22, 0x20, 0x24, 0x17, 0xa8, 0x00, 0xb0, 0x00, 0xb0, 0x11, 0x28, 0x11, 0x28, 0x22, 0x24, 0x24, 0x22, 0x48, 0x21, 0x40, 0xe0, 0x00, 0x00 },
{ 0xe7, 0xb7, 0x20, 0x88, 0x10, 0x88, 0x0b, 0xff, 0x40, 0x88, 0x20, 0x20, 0x13, 0xfe, 0x02, 0x22, 0x02, 0x22, 0x12, 0x22, 0x17, 0xff, 0x20, 0x50, 0x20, 0x50, 0x40, 0x88, 0x41, 0x04, 0x06, 0x03, 0x00, 0x00 },
{ 0xe7, 0xb8, 0x20, 0x00, 0x26, 0xff, 0x38, 0x08, 0x20, 0x10, 0x22, 0x7e, 0x1e, 0x42, 0x00, 0x7e, 0x08, 0x42, 0x09, 0x7e, 0x7a, 0x42, 0x1c, 0x42, 0x2c, 0x7e, 0x2a, 0x00, 0x49, 0x26, 0x18, 0xc1, 0x00, 0x00 },
{ 0xe7, 0xb9, 0x21, 0x08, 0x15, 0x6a, 0x05, 0x28, 0x42, 0x94, 0x22, 0x52, 0x04, 0x62, 0x00, 0x00, 0x07, 0xff, 0x14, 0x21, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x70, 0x40, 0xa8, 0x41, 0x24, 0x06, 0x23, 0x00, 0x00 },
{ 0xe7, 0xba, 0x20, 0x20, 0x13, 0xfe, 0x0a, 0x00, 0x01, 0xfc, 0x40, 0x00, 0x21, 0xfc, 0x11, 0x04, 0x07, 0xfe, 0x05, 0x22, 0x17, 0xf2, 0x15, 0x5a, 0x27, 0x56, 0x25, 0x52, 0x45, 0x22, 0x49, 0x53, 0x00, 0x00 },
{ 0xe7, 0xbb, 0x21, 0x04, 0x15, 0x55, 0x05, 0x55, 0x42, 0x8a, 0x24, 0x51, 0x07, 0xff, 0x04, 0x01, 0x00, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x20, 0x20, 0x21, 0xfe, 0x41, 0x02, 0x41, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xe7, 0xbc, 0x10, 0x44, 0x10, 0x44, 0x11, 0xff, 0x10, 0x44, 0x58, 0x10, 0x54, 0xfe, 0x54, 0x92, 0x50, 0x92, 0x10, 0x92, 0x13, 0xff, 0x28, 0x10, 0x24, 0x28, 0x24, 0x44, 0x41, 0x82, 0x46, 0x01, 0x00, 0x00 },
{ 0xe7, 0xbd, 0x09, 0x09, 0x29, 0x29, 0x4a, 0x4a, 0x14, 0x14, 0x22, 0x22, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe7, 0xbe, 0x00, 0x20, 0x4b, 0xff, 0x2a, 0x01, 0x12, 0xa1, 0x31, 0x8a, 0x52, 0xf9, 0x08, 0x00, 0x09, 0xfe, 0x19, 0x52, 0x2b, 0xff, 0x48, 0x00, 0x0b, 0xff, 0x08, 0x20, 0x08, 0x20, 0x30, 0xe0, 0x00, 0x00 },
{ 0xe7, 0xbf, 0x00, 0x20, 0x7c, 0x50, 0x10, 0x88, 0x11, 0x04, 0x12, 0x03, 0x7c, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x22, 0x1c, 0x22, 0x70, 0x22, 0x00, 0x24, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe7, 0xc0, 0x00, 0x44, 0x7c, 0x44, 0x11, 0xff, 0x10, 0x44, 0x10, 0x10, 0x10, 0xfe, 0x7c, 0x92, 0x10, 0x92, 0x10, 0x92, 0x11, 0xff, 0x1c, 0x10, 0x70, 0x28, 0x00, 0x44, 0x01, 0x82, 0x06, 0x01, 0x00, 0x00 },
{ 0xe7, 0xc1, 0x08, 0x08, 0x29, 0x29, 0x2a, 0x2a, 0x48, 0x48, 0x14, 0x14, 0x62, 0x63, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0xfd, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0xa0, 0x00, 0x90, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe7, 0xc2, 0x00, 0x00, 0x03, 0xde, 0x7a, 0x52, 0x13, 0xde, 0x12, 0x52, 0x13, 0xde, 0x7a, 0x52, 0x13, 0xde, 0x12, 0x52, 0x14, 0x21, 0x13, 0xff, 0x18, 0x88, 0x71, 0x90, 0x00, 0x78, 0x03, 0x86, 0x00, 0x00 },
{ 0xe7, 0xc3, 0x3f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xbe, 0x08, 0xa2, 0x14, 0x82, 0x13, 0x02, 0x22, 0x8c, 0x4c, 0x40, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe7, 0xc4, 0x20, 0x00, 0x26, 0xff, 0x38, 0x08, 0x21, 0x10, 0x3f, 0x7e, 0x00, 0x42, 0x02, 0x7e, 0x3c, 0x42, 0x08, 0x7e, 0x7f, 0x42, 0x08, 0x42, 0x1c, 0x7e, 0x2a, 0x00, 0x48, 0x26, 0x08, 0xc1, 0x00, 0x00 },
{ 0xe7, 0xc5, 0x10, 0x00, 0x11, 0xef, 0x25, 0x29, 0x45, 0xef, 0x29, 0x29, 0x11, 0xef, 0x10, 0xaa, 0x25, 0x11, 0x7c, 0x20, 0x15, 0xff, 0x50, 0x44, 0x54, 0x84, 0x54, 0xe8, 0x10, 0x16, 0x11, 0xe1, 0x00, 0x00 },
{ 0xe7, 0xc6, 0x22, 0x10, 0x14, 0x28, 0x7e, 0x44, 0x08, 0x82, 0x09, 0x01, 0x7e, 0x7c, 0x08, 0x00, 0x08, 0x00, 0x0e, 0xfe, 0x78, 0x12, 0x08, 0x12, 0x08, 0x12, 0x10, 0x14, 0x10, 0x10, 0x20, 0x10, 0x00, 0x00 },
{ 0xe7, 0xc7, 0x00, 0x10, 0x7c, 0x28, 0x24, 0x44, 0x24, 0x82, 0x3d, 0x01, 0x24, 0x7c, 0x24, 0x00, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0x12, 0x2f, 0x12, 0x74, 0x12, 0x04, 0x14, 0x04, 0x10, 0x04, 0x10, 0x00, 0x00 },
{ 0xe7, 0xc8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe7, 0xc9, 0x00, 0x20, 0x3c, 0x10, 0x00, 0x08, 0x7e, 0x00, 0x00, 0xf0, 0x00, 0x11, 0x3c, 0x12, 0x01, 0xd4, 0x3c, 0x58, 0x00, 0x58, 0x00, 0x54, 0x3c, 0x94, 0x24, 0x92, 0x25, 0x11, 0x3c, 0x30, 0x00, 0x00 },
{ 0xe7, 0xca, 0x20, 0x30, 0x11, 0xc0, 0x09, 0x1e, 0x01, 0x12, 0x41, 0x12, 0x21, 0x12, 0x11, 0x12, 0x01, 0x12, 0x01, 0x12, 0x71, 0xd2, 0x17, 0x16, 0x10, 0x10, 0x10, 0x10, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe7, 0xcb, 0x08, 0x10, 0x0c, 0x28, 0x12, 0x44, 0x12, 0x82, 0x21, 0x01, 0x7e, 0x7c, 0x08, 0x00, 0x3e, 0x00, 0x08, 0xfe, 0x2a, 0x12, 0x2a, 0x12, 0x28, 0x12, 0x0f, 0x14, 0x78, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe7, 0xcc, 0x10, 0x44, 0x18, 0x44, 0x25, 0xff, 0x22, 0x44, 0x40, 0x10, 0x7c, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x7c, 0x92, 0x11, 0xff, 0x54, 0x28, 0x54, 0x28, 0x50, 0x44, 0x1c, 0x44, 0x71, 0x83, 0x00, 0x00 },
{ 0xe7, 0xcd, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x01, 0x40, 0x0e, 0x38, 0x73, 0xe7, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0x84, 0x00, 0x88, 0x00, 0x00 },
{ 0xe7, 0xce, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x90, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xe7, 0xcf, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x3d, 0xde, 0x25, 0x52, 0x3d, 0xde, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe7, 0xd0, 0x08, 0x00, 0x08, 0xff, 0x14, 0x08, 0x22, 0x10, 0x41, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x00, 0x42, 0x7f, 0x7e, 0x09, 0x42, 0x09, 0x42, 0x09, 0x7e, 0x0a, 0x24, 0x08, 0x42, 0x08, 0x81, 0x00, 0x00 },
{ 0xe7, 0xd1, 0x08, 0x08, 0x18, 0x08, 0x28, 0x08, 0x44, 0x10, 0x04, 0x10, 0x04, 0x10, 0x02, 0x20, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe7, 0xd2, 0x08, 0xc0, 0x0b, 0x1e, 0x12, 0x02, 0x12, 0x02, 0x33, 0xde, 0x32, 0x02, 0x52, 0x02, 0x52, 0x02, 0x13, 0xfe, 0x10, 0x90, 0x10, 0x90, 0x11, 0x10, 0x11, 0x11, 0x12, 0x11, 0x14, 0x0f, 0x00, 0x00 },
{ 0xe7, 0xd3, 0x08, 0x01, 0x0f, 0xc1, 0x09, 0x09, 0x11, 0x09, 0x11, 0x09, 0x33, 0xc9, 0x32, 0x49, 0x52, 0x49, 0x15, 0x49, 0x14, 0x89, 0x10, 0x89, 0x10, 0x89, 0x11, 0x01, 0x11, 0x01, 0x12, 0x07, 0x00, 0x00 },
{ 0xe7, 0xd4, 0x02, 0x02, 0x02, 0x12, 0x42, 0x12, 0x22, 0x12, 0x12, 0x12, 0x0c, 0x12, 0x04, 0x12, 0x06, 0x12, 0x05, 0x12, 0x09, 0x12, 0x08, 0x92, 0x10, 0x82, 0x10, 0x02, 0x20, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe7, 0xd5, 0x04, 0x00, 0x07, 0x80, 0x04, 0x3f, 0x7f, 0xd1, 0x40, 0x51, 0x5f, 0x51, 0x24, 0x91, 0x4a, 0x4a, 0x1f, 0x0a, 0x31, 0x8a, 0x5f, 0x44, 0x11, 0x0c, 0x1f, 0x0a, 0x11, 0x12, 0x1f, 0x21, 0x00, 0x00 },
{ 0xe7, 0xd6, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x84, 0x00, 0x58, 0x00, 0xe1, 0x07, 0x19, 0x78, 0x07, 0x00, 0x00 },
{ 0xe7, 0xd7, 0x21, 0xe0, 0x10, 0x20, 0x08, 0x20, 0x40, 0x20, 0x23, 0xfe, 0x12, 0x22, 0x02, 0x22, 0x02, 0x52, 0x12, 0x52, 0x12, 0x8a, 0x23, 0x06, 0x22, 0x02, 0x42, 0x02, 0x42, 0x02, 0x02, 0x0e, 0x00, 0x00 },
{ 0xe7, 0xd8, 0x20, 0x10, 0x10, 0x5e, 0x08, 0x50, 0x41, 0xff, 0x20, 0x04, 0x10, 0x12, 0x03, 0xff, 0x02, 0x10, 0x13, 0xd1, 0x12, 0x89, 0x23, 0xaa, 0x22, 0xaa, 0x44, 0xc4, 0x44, 0x8d, 0x09, 0x33, 0x00, 0x00 },
{ 0xe7, 0xd9, 0x04, 0x40, 0x45, 0x9e, 0x29, 0x02, 0x11, 0x02, 0x31, 0xde, 0x51, 0x02, 0x09, 0x02, 0x09, 0x02, 0x19, 0xfe, 0x28, 0x50, 0x48, 0x50, 0x08, 0x90, 0x08, 0x91, 0x09, 0x11, 0x32, 0x0f, 0x00, 0x00 },
{ 0xe7, 0xda, 0x00, 0x80, 0x00, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0xfd, 0x11, 0xc4, 0x22, 0x22, 0x0f, 0xf8, 0x18, 0x0e, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xe7, 0xdb, 0x0c, 0x10, 0x70, 0x9e, 0x10, 0x90, 0x11, 0xff, 0x7c, 0x04, 0x10, 0x12, 0x13, 0xff, 0x3a, 0x10, 0x37, 0xd1, 0x52, 0x89, 0x53, 0xaa, 0x12, 0xaa, 0x13, 0xc4, 0x14, 0x8d, 0x15, 0x33, 0x00, 0x00 },
{ 0xe7, 0xdc, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x03, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x11, 0x44, 0x12, 0x24, 0x1c, 0x1c, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xe7, 0xdd, 0x04, 0x20, 0x7f, 0xff, 0x08, 0x20, 0x3e, 0x10, 0x08, 0x7c, 0x3f, 0x14, 0x14, 0x54, 0x3f, 0x25, 0x0a, 0xd3, 0x7c, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0x04, 0x08, 0x3f, 0xf4, 0x00, 0x00 },
{ 0xe7, 0xde, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x20, 0x0a, 0x88, 0x12, 0x24, 0x01, 0xe0, 0x14, 0x0a, 0x52, 0xa1, 0x5e, 0xbc, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xe7, 0xdf, 0x00, 0x48, 0x39, 0xfe, 0x01, 0x4a, 0x01, 0xfe, 0x7d, 0x4a, 0x11, 0xfe, 0x10, 0x00, 0x55, 0xfe, 0x54, 0x00, 0x54, 0xfc, 0x54, 0x84, 0x54, 0xfc, 0x10, 0x48, 0x10, 0x48, 0x11, 0xfe, 0x00, 0x00 },
{ 0xe7, 0xe0, 0x01, 0x00, 0x7f, 0xff, 0x03, 0x80, 0x0c, 0x48, 0x78, 0x30, 0x0b, 0x98, 0x3c, 0x07, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x4a, 0x24, 0x7a, 0x2b, 0xe2, 0x22, 0x22, 0x23, 0xe2, 0x20, 0x1e, 0x00, 0x00 },
{ 0xe7, 0xe1, 0x00, 0x40, 0x3e, 0x43, 0x00, 0x7c, 0x7f, 0x40, 0x00, 0x41, 0x3e, 0x3f, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7f, 0x00, 0x41, 0x3e, 0x41, 0x22, 0x7f, 0x22, 0x41, 0x22, 0x41, 0x3e, 0x7f, 0x00, 0x00 },
{ 0xe7, 0xe2, 0x05, 0x00, 0x19, 0xdc, 0x11, 0x04, 0x1d, 0xdc, 0x10, 0x44, 0x1d, 0x5c, 0x11, 0x44, 0x7f, 0xff, 0x04, 0x10, 0x1b, 0xec, 0x60, 0x03, 0x07, 0xf0, 0x04, 0x10, 0x04, 0x10, 0x07, 0xf0, 0x00, 0x00 },
{ 0xe7, 0xe3, 0x00, 0x40, 0x7c, 0x78, 0x04, 0x88, 0x29, 0x10, 0x13, 0xfe, 0x09, 0x22, 0x7d, 0xfe, 0x14, 0x20, 0x18, 0xd0, 0x13, 0x32, 0x10, 0xd4, 0x13, 0x38, 0x10, 0xd4, 0x13, 0x13, 0x30, 0x60, 0x00, 0x00 },
{ 0xe7, 0xe4, 0x00, 0x24, 0x7e, 0xff, 0x14, 0xa5, 0x14, 0xff, 0x14, 0xa5, 0x7f, 0xff, 0x55, 0x00, 0x55, 0xff, 0x67, 0x00, 0x41, 0x7e, 0x41, 0x42, 0x7f, 0x7e, 0x41, 0x24, 0x41, 0x24, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe7, 0xe5, 0x18, 0x5c, 0x14, 0x44, 0x12, 0x82, 0x21, 0xff, 0x3e, 0x82, 0x48, 0x82, 0x08, 0x82, 0x7e, 0xfe, 0x08, 0x28, 0x4a, 0x28, 0x4c, 0x28, 0x28, 0x48, 0x28, 0x49, 0x0e, 0x89, 0x71, 0x07, 0x00, 0x00 },
{ 0xe7, 0xe6, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x7e, 0x08, 0x12, 0x08, 0xff, 0x3e, 0x12, 0x00, 0x12, 0x3e, 0x7e, 0x00, 0x10, 0x7f, 0x51, 0x08, 0x3a, 0x2a, 0x18, 0x29, 0x34, 0x49, 0xd2, 0x18, 0x31, 0x00, 0x00 },
{ 0xe7, 0xe7, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x02, 0x00, 0x1c, 0x7c, 0x10, 0x04, 0x1f, 0x7c, 0x10, 0x04, 0x1f, 0xfc, 0x02, 0x40, 0x02, 0x41, 0x0c, 0x41, 0x70, 0x3f, 0x00, 0x00 },
{ 0xe7, 0xe8, 0x00, 0x00, 0x7e, 0xff, 0x02, 0x08, 0x24, 0x10, 0x18, 0x7e, 0x08, 0x42, 0x00, 0x7e, 0x7f, 0x42, 0x09, 0x7e, 0x0a, 0x42, 0x08, 0x42, 0x08, 0x7e, 0x08, 0x00, 0x08, 0x26, 0x38, 0xc1, 0x00, 0x00 },
{ 0xe7, 0xe9, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x01, 0x00, 0x1f, 0xf8, 0x01, 0x08, 0x02, 0x08, 0x02, 0x08, 0x02, 0x08, 0x04, 0x08, 0x04, 0x08, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xe7, 0xea, 0x08, 0x00, 0x0b, 0xfe, 0x10, 0x40, 0x10, 0x40, 0x30, 0x40, 0x30, 0x40, 0x51, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x17, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xe7, 0xeb, 0x08, 0x00, 0x0b, 0xfe, 0x10, 0x40, 0x10, 0x40, 0x13, 0xfc, 0x20, 0x84, 0x30, 0x84, 0x57, 0xff, 0x10, 0x00, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xe7, 0xec, 0x09, 0x08, 0x0f, 0xc8, 0x11, 0x08, 0x11, 0x1f, 0x37, 0xd2, 0x31, 0x32, 0x51, 0x52, 0x57, 0xd2, 0x12, 0x0a, 0x13, 0xcc, 0x12, 0x44, 0x12, 0x4c, 0x14, 0x4a, 0x14, 0x52, 0x19, 0xa1, 0x00, 0x00 },
{ 0xe7, 0xed, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x10, 0x80, 0x20, 0x80, 0x40, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe7, 0xee, 0x00, 0x00, 0x3f, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x1f, 0xf8, 0x02, 0x08, 0x02, 0x08, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xe7, 0xef, 0x13, 0xf8, 0x12, 0x08, 0x12, 0x08, 0x13, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xe7, 0xf0, 0x00, 0x20, 0x00, 0x40, 0x01, 0xfc, 0x79, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x00, 0x49, 0xff, 0x49, 0x00, 0x49, 0x00, 0x49, 0xff, 0x78, 0x01, 0x02, 0xa9, 0x02, 0xa1, 0x04, 0x8e, 0x00, 0x00 },
{ 0xe7, 0xf1, 0x10, 0x40, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x7d, 0xfc, 0x11, 0x00, 0x11, 0x00, 0x11, 0xff, 0x11, 0x00, 0x11, 0x00, 0x1d, 0xff, 0x70, 0x01, 0x02, 0xa9, 0x02, 0xa1, 0x04, 0x8e, 0x00, 0x00 },
{ 0xe7, 0xf2, 0x10, 0x20, 0x10, 0x40, 0x13, 0xfe, 0x12, 0x1a, 0x7a, 0xe2, 0x12, 0x22, 0x12, 0xfa, 0x12, 0x72, 0x12, 0xaa, 0x12, 0x22, 0x1f, 0xff, 0x70, 0x20, 0x00, 0x50, 0x01, 0x8c, 0x06, 0x03, 0x00, 0x00 },
{ 0xe7, 0xf3, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x34, 0x13, 0xc4, 0x14, 0x94, 0x12, 0xa4, 0x1f, 0xfc, 0x11, 0xc4, 0x12, 0xa4, 0x14, 0x94, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xe7, 0xf4, 0x10, 0x00, 0x10, 0x3e, 0x10, 0xa2, 0x7c, 0xa2, 0x24, 0xbe, 0x24, 0x80, 0x24, 0x80, 0x24, 0xfe, 0x44, 0x12, 0x68, 0x12, 0x59, 0xff, 0x08, 0x18, 0x14, 0x24, 0x22, 0x42, 0x41, 0x81, 0x00, 0x00 },
{ 0xe7, 0xf5, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x42, 0x01, 0x12, 0x7e, 0x12, 0x10, 0x1e, 0xfc, 0x02, 0x24, 0x02, 0x24, 0x3e, 0xff, 0x12, 0x00, 0x12, 0x7e, 0x12, 0x42, 0x22, 0x42, 0x02, 0x7e, 0x00, 0x00 },
{ 0xe7, 0xf6, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x40, 0x58, 0x40, 0x55, 0xfc, 0x54, 0x84, 0x50, 0x84, 0x17, 0xff, 0x10, 0x00, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xe7, 0xf7, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x1e, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x1e, 0x3c, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x24, 0x82, 0x24, 0x49, 0x44, 0x09, 0x03, 0xf8, 0x00, 0x00 },
{ 0xe7, 0xf8, 0x10, 0x20, 0x10, 0x40, 0x13, 0xfe, 0x5a, 0x1a, 0x56, 0xf2, 0x56, 0x26, 0x52, 0xaa, 0x13, 0xfe, 0x12, 0x72, 0x13, 0xae, 0x12, 0x22, 0x17, 0xff, 0x10, 0x50, 0x11, 0x8c, 0x16, 0x03, 0x00, 0x00 },
{ 0xe7, 0xf9, 0x08, 0x20, 0x08, 0x20, 0x3f, 0x20, 0x08, 0x7f, 0x08, 0x44, 0x7f, 0x44, 0x08, 0xc4, 0x08, 0x44, 0x7f, 0x28, 0x10, 0x28, 0x10, 0x10, 0x1f, 0x10, 0x21, 0x28, 0x21, 0x44, 0x46, 0x83, 0x00, 0x00 },
{ 0xe7, 0xfa, 0x00, 0x80, 0x78, 0x80, 0x48, 0x80, 0x49, 0xfe, 0x49, 0x10, 0x7a, 0x10, 0x48, 0x10, 0x48, 0x10, 0x4b, 0xff, 0x48, 0x10, 0x78, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe7, 0xfb, 0x00, 0x00, 0x01, 0xfe, 0x78, 0x20, 0x48, 0x20, 0x49, 0xfc, 0x48, 0x44, 0x78, 0x44, 0x4b, 0xff, 0x48, 0x00, 0x48, 0x00, 0x48, 0xfc, 0x78, 0x84, 0x00, 0x84, 0x00, 0x84, 0x00, 0xfc, 0x00, 0x00 },
{ 0xe7, 0xfc, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x20, 0x7c, 0x20, 0x11, 0xfc, 0x10, 0x44, 0x38, 0x44, 0x3b, 0xff, 0x34, 0x00, 0x54, 0x00, 0x51, 0xfe, 0x51, 0x02, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xe7, 0xfd, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x40, 0x00, 0x40, 0x40, 0x40, 0x27, 0xff, 0x10, 0x80, 0x00, 0x80, 0x00, 0x80, 0x11, 0xfc, 0x11, 0x04, 0x20, 0x04, 0x20, 0x08, 0x40, 0x08, 0x40, 0x70, 0x00, 0x00 },
{ 0xe7, 0xfe, 0x20, 0x10, 0x10, 0x20, 0x0b, 0xfe, 0x02, 0x1a, 0x42, 0xe2, 0x22, 0x2a, 0x13, 0xfe, 0x02, 0x72, 0x02, 0xaa, 0x12, 0x22, 0x17, 0xff, 0x20, 0x20, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xe8, 0xa1, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x1f, 0xff, 0x00, 0x01, 0x24, 0x91, 0x22, 0x49, 0x42, 0x46, 0x00, 0x00 },
{ 0xe8, 0xa2, 0x08, 0x20, 0x08, 0x20, 0x3f, 0x20, 0x08, 0x7f, 0x7f, 0x44, 0x08, 0xc4, 0x3f, 0x44, 0x08, 0x28, 0x1f, 0x10, 0x21, 0x2c, 0x46, 0xc3, 0x00, 0x00, 0x12, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xe8, 0xa3, 0x08, 0x20, 0x3e, 0x20, 0x08, 0x7f, 0x7f, 0x44, 0x08, 0xa4, 0x7f, 0x18, 0x08, 0x18, 0x1f, 0x24, 0x21, 0xc3, 0x46, 0x88, 0x00, 0x84, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x30, 0x38, 0x0e, 0x00, 0x00 },
{ 0xe8, 0xa4, 0x10, 0x20, 0x1f, 0x3e, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x13, 0xf8, 0x12, 0x08, 0x13, 0xf8, 0x10, 0x00, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xa5, 0x10, 0x00, 0x10, 0x7c, 0x10, 0x44, 0x7d, 0x44, 0x55, 0x7c, 0x55, 0x00, 0x55, 0xfc, 0x54, 0x24, 0x54, 0x24, 0x7d, 0xff, 0x10, 0x20, 0x14, 0x50, 0x14, 0x48, 0x1a, 0x84, 0x63, 0x03, 0x00, 0x00 },
{ 0xe8, 0xa6, 0x00, 0x00, 0x3c, 0x3e, 0x00, 0xa2, 0x7e, 0xa2, 0x00, 0xbe, 0x3c, 0x80, 0x00, 0x80, 0x3c, 0xfe, 0x00, 0x12, 0x00, 0x12, 0x3d, 0xff, 0x24, 0x28, 0x24, 0x24, 0x24, 0x42, 0x3c, 0x81, 0x00, 0x00 },
{ 0xe8, 0xa7, 0x08, 0x20, 0x3e, 0x3f, 0x08, 0x64, 0x7f, 0x54, 0x08, 0x88, 0x1f, 0xd4, 0x62, 0x63, 0x07, 0xfc, 0x1c, 0x44, 0x67, 0xfc, 0x04, 0x44, 0x07, 0xfc, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xe8, 0xa8, 0x08, 0x10, 0x3f, 0x10, 0x08, 0x3f, 0x7f, 0x52, 0x08, 0x12, 0x1f, 0x0c, 0x21, 0x33, 0x42, 0x00, 0x1f, 0xfc, 0x11, 0x44, 0x1f, 0x7c, 0x11, 0x44, 0x1f, 0x7d, 0x01, 0x41, 0x00, 0xff, 0x00, 0x00 },
{ 0xe8, 0xa9, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x88, 0x11, 0x1c, 0x17, 0xe2, 0x10, 0x40, 0x17, 0xfc, 0x20, 0x40, 0x20, 0x40, 0x5f, 0xff, 0x00, 0x00 },
{ 0xe8, 0xaa, 0x20, 0x1e, 0x13, 0xe0, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x20, 0x20, 0x17, 0xff, 0x00, 0x20, 0x00, 0x50, 0x10, 0x50, 0x10, 0x88, 0x20, 0x88, 0x21, 0x04, 0x42, 0x02, 0x44, 0x01, 0x00, 0x00 },
{ 0xe8, 0xab, 0x04, 0x04, 0x47, 0xc4, 0x28, 0x05, 0x17, 0xe5, 0x30, 0x04, 0x53, 0xdf, 0x08, 0x04, 0x0b, 0xc4, 0x18, 0x04, 0x28, 0x0a, 0x4b, 0xca, 0x0a, 0x4a, 0x0a, 0x52, 0x0b, 0xd1, 0x30, 0x21, 0x00, 0x00 },
{ 0xe8, 0xac, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x90, 0x00, 0x88, 0x00, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe8, 0xad, 0x08, 0x00, 0x15, 0xff, 0x12, 0x10, 0x22, 0x10, 0x20, 0x10, 0x5e, 0x10, 0x08, 0x10, 0x08, 0xfe, 0x7e, 0x10, 0x08, 0x14, 0x4a, 0x12, 0x2a, 0x12, 0x28, 0x10, 0x0e, 0x10, 0x79, 0xff, 0x00, 0x00 },
{ 0xe8, 0xae, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x24, 0x01, 0x24, 0x41, 0x54, 0x21, 0x8c, 0x11, 0x04, 0x01, 0xfc, 0x00, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x22, 0x52, 0x22, 0x52, 0x42, 0x52, 0x47, 0xff, 0x00, 0x00 },
{ 0xe8, 0xaf, 0x00, 0x00, 0x7d, 0xfc, 0x11, 0x24, 0x11, 0x24, 0x11, 0x54, 0x7d, 0x8c, 0x11, 0xfc, 0x10, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x1e, 0x52, 0x72, 0x52, 0x02, 0x52, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xe8, 0xb0, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x53, 0xfe, 0x32, 0x22, 0x12, 0x52, 0x12, 0x8a, 0x33, 0xfe, 0x50, 0x00, 0x13, 0xfe, 0x12, 0x52, 0x22, 0x52, 0x22, 0x52, 0x4f, 0xff, 0x00, 0x00 },
{ 0xe8, 0xb1, 0x0c, 0x0e, 0x71, 0xf0, 0x11, 0x12, 0x12, 0xfd, 0x7c, 0x20, 0x11, 0xfe, 0x10, 0x00, 0x38, 0xfc, 0x34, 0x04, 0x51, 0xff, 0x50, 0x04, 0x10, 0xfc, 0x10, 0x20, 0x12, 0x95, 0x14, 0xfd, 0x00, 0x00 },
{ 0xe8, 0xb2, 0x08, 0x00, 0x11, 0xfc, 0x21, 0x24, 0x45, 0x24, 0x29, 0x54, 0x11, 0x8c, 0x25, 0xfc, 0x7c, 0x00, 0x54, 0x00, 0x11, 0xfe, 0x59, 0x4a, 0x55, 0x4a, 0x55, 0x4a, 0x17, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xe8, 0xb3, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x08, 0x00, 0x10, 0xfe, 0x22, 0x92, 0x14, 0xaa, 0x08, 0x82, 0x12, 0xfe, 0x7e, 0x00, 0x08, 0xfe, 0x2a, 0xaa, 0x2a, 0xaa, 0x48, 0xaa, 0x09, 0xff, 0x00, 0x00 },
{ 0xe8, 0xb4, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x20, 0x08, 0x20, 0x10, 0x21, 0x20, 0x21, 0x40, 0x1f, 0x00, 0x00 },
{ 0xe8, 0xb5, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x48, 0x10, 0x90, 0x25, 0xff, 0x1a, 0x90, 0x10, 0xfe, 0x22, 0x90, 0x7c, 0xfe, 0x08, 0x90, 0x70, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe8, 0xb6, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x79, 0x12, 0x12, 0x24, 0x14, 0xbf, 0x12, 0xe4, 0x19, 0x24, 0x72, 0x3f, 0x12, 0xa4, 0x17, 0xa4, 0x11, 0x3f, 0x11, 0x24, 0x12, 0x24, 0x34, 0x3f, 0x00, 0x00 },
{ 0xe8, 0xb7, 0x01, 0xe0, 0x04, 0x10, 0x19, 0x08, 0x62, 0x07, 0x04, 0x20, 0x09, 0xd0, 0x3e, 0x08, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x00, 0x07, 0xf0, 0x09, 0x10, 0x08, 0x91, 0x11, 0xf1, 0x7e, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xb8, 0x00, 0x80, 0x7f, 0xff, 0x50, 0x91, 0x25, 0xfe, 0x1a, 0x90, 0x10, 0xfc, 0x7c, 0x90, 0x08, 0xfe, 0x10, 0x00, 0x6f, 0xfc, 0x04, 0x00, 0x07, 0xe0, 0x09, 0x22, 0x0b, 0xe2, 0x3c, 0x1e, 0x00, 0x00 },
{ 0xe8, 0xb9, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x12, 0x40, 0x54, 0x89, 0x32, 0x52, 0x17, 0xdf, 0x14, 0x74, 0x37, 0xd4, 0x55, 0x5f, 0x15, 0x54, 0x17, 0xdf, 0x24, 0x14, 0x24, 0x54, 0x43, 0xdf, 0x00, 0x00 },
{ 0xe8, 0xba, 0x01, 0xf0, 0x04, 0x10, 0x04, 0x08, 0x08, 0x84, 0x11, 0x22, 0x62, 0x31, 0x0f, 0xc8, 0x00, 0x00, 0x7e, 0x7e, 0x1a, 0x1a, 0x62, 0x62, 0x06, 0x06, 0x1a, 0x1a, 0x62, 0x62, 0x0e, 0x0e, 0x00, 0x00 },
{ 0xe8, 0xbb, 0x11, 0x10, 0x22, 0x20, 0x22, 0x20, 0x11, 0x10, 0x1f, 0xf0, 0x10, 0x10, 0x1f, 0xf0, 0x00, 0x00, 0x3f, 0xf8, 0x21, 0x08, 0x21, 0x08, 0x3f, 0xfa, 0x20, 0x02, 0x20, 0x02, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xe8, 0xbc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x10, 0x24, 0x10, 0x48, 0x64, 0x7f, 0x24, 0xc8, 0x19, 0x48, 0x32, 0x7e, 0x7c, 0x48, 0x04, 0x7e, 0x08, 0x48, 0x10, 0x48, 0x60, 0x7f, 0x00, 0x00 },
{ 0xe8, 0xbd, 0x00, 0x80, 0x7f, 0xfe, 0x10, 0x48, 0x64, 0xfe, 0x29, 0x90, 0x12, 0xfe, 0x7e, 0x90, 0x03, 0x7e, 0x05, 0xd0, 0x38, 0x0e, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0xc4, 0x3f, 0x3f, 0x00, 0x00 },
{ 0xe8, 0xbe, 0x20, 0x00, 0x10, 0xfe, 0x08, 0x82, 0x00, 0x82, 0x40, 0x9e, 0x20, 0x92, 0x10, 0x92, 0x03, 0xff, 0x02, 0x01, 0x12, 0x79, 0x12, 0x49, 0x22, 0x49, 0x22, 0x79, 0x42, 0x01, 0x42, 0x07, 0x00, 0x00 },
{ 0xe8, 0xbf, 0x00, 0x00, 0x3f, 0xfe, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x07, 0xf0, 0x04, 0x10, 0x05, 0x10, 0x08, 0x90, 0x08, 0xa0, 0x08, 0x20, 0x08, 0x20, 0x08, 0xe1, 0x0f, 0x21, 0x70, 0x1f, 0x00, 0x00 },
{ 0xe8, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x18, 0x3c, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0xf8, 0x08, 0x88, 0x3f, 0xfe, 0x20, 0x02, 0x27, 0xe2, 0x24, 0x22, 0x27, 0xe2, 0x20, 0x0e, 0x00, 0x00 },
{ 0xe8, 0xc1, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x1c, 0x7c, 0x00, 0x00, 0x20, 0x20, 0x13, 0xfe, 0x00, 0x20, 0x47, 0xff, 0x20, 0x20, 0x00, 0x20, 0x0b, 0xfe, 0x10, 0x20, 0x20, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe8, 0xc2, 0x00, 0x10, 0x7f, 0x10, 0x48, 0x10, 0x48, 0x10, 0x7e, 0x10, 0x42, 0x10, 0x42, 0x10, 0x42, 0x28, 0x7e, 0x28, 0x48, 0x28, 0x48, 0x44, 0x48, 0x44, 0x7f, 0x82, 0x00, 0x82, 0x01, 0x01, 0x00, 0x00 },
{ 0xe8, 0xc3, 0x10, 0x10, 0x10, 0x10, 0x10, 0xfe, 0x7c, 0x10, 0x54, 0x10, 0x54, 0x10, 0x55, 0xff, 0x54, 0x00, 0x54, 0x10, 0x7c, 0x10, 0x10, 0xfe, 0x14, 0x10, 0x14, 0x10, 0x1a, 0x10, 0x63, 0xff, 0x00, 0x00 },
{ 0xe8, 0xc4, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x42, 0x7c, 0x42, 0x54, 0x5e, 0x54, 0x52, 0x54, 0x52, 0x54, 0xff, 0x54, 0x81, 0x7c, 0xbd, 0x10, 0xa5, 0x14, 0xa5, 0x14, 0xbd, 0x1a, 0x81, 0x62, 0x87, 0x00, 0x00 },
{ 0xe8, 0xc5, 0x00, 0x28, 0x3c, 0x28, 0x00, 0x28, 0x7e, 0x48, 0x00, 0x49, 0x3c, 0xca, 0x00, 0xcc, 0x3d, 0x48, 0x01, 0x48, 0x00, 0x48, 0x3c, 0x48, 0x24, 0x48, 0x24, 0x49, 0x24, 0x49, 0x3c, 0x47, 0x00, 0x00 },
{ 0xe8, 0xc6, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7d, 0x01, 0x25, 0x01, 0x24, 0x80, 0x24, 0xef, 0x25, 0x29, 0x45, 0x29, 0x6a, 0xa9, 0x58, 0x4b, 0x08, 0x48, 0x14, 0x89, 0x21, 0x09, 0x46, 0x07, 0x00, 0x00 },
{ 0xe8, 0xc7, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x40, 0x02, 0x40, 0x04, 0x40, 0x04, 0x41, 0x08, 0x41, 0x70, 0x3f, 0x00, 0x00 },
{ 0xe8, 0xc8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x01, 0x48, 0x7d, 0x1f, 0x44, 0x11, 0x44, 0x21, 0x44, 0x52, 0x44, 0x0a, 0x5c, 0x04, 0x40, 0x08, 0x41, 0x10, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xe8, 0xc9, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x7a, 0x02, 0x12, 0x02, 0x10, 0xf8, 0x38, 0x00, 0x34, 0x00, 0x37, 0xfe, 0x50, 0x90, 0x10, 0x90, 0x11, 0x10, 0x11, 0x12, 0x12, 0x12, 0x14, 0x0e, 0x00, 0x00 },
{ 0xe8, 0xca, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7a, 0x01, 0x12, 0x01, 0x11, 0x00, 0x39, 0xde, 0x35, 0x52, 0x32, 0x52, 0x52, 0x52, 0x55, 0x96, 0x50, 0x90, 0x11, 0x11, 0x12, 0x11, 0x14, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xcb, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x04, 0x01, 0x44, 0x01, 0x25, 0xfd, 0x10, 0x00, 0x00, 0x00, 0x07, 0xff, 0x10, 0x90, 0x10, 0x90, 0x20, 0x90, 0x21, 0x11, 0x42, 0x11, 0x4c, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xcc, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x7d, 0xff, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x1c, 0x48, 0x70, 0x88, 0x00, 0x89, 0x01, 0x09, 0x06, 0x07, 0x00, 0x00 },
{ 0xe8, 0xcd, 0x00, 0x20, 0x00, 0x20, 0x7d, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x10, 0x78, 0x7c, 0x00, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x48, 0x1c, 0x48, 0x70, 0x88, 0x00, 0x89, 0x01, 0x09, 0x02, 0x07, 0x00, 0x00 },
{ 0xe8, 0xce, 0x00, 0x20, 0x00, 0x20, 0x7f, 0xff, 0x12, 0x01, 0x12, 0x01, 0x11, 0x00, 0x7d, 0xde, 0x12, 0x52, 0x14, 0x52, 0x11, 0x52, 0x1c, 0x96, 0x70, 0x90, 0x01, 0x11, 0x02, 0x11, 0x04, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xcf, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x01, 0x10, 0x80, 0x20, 0x8f, 0x3c, 0xe9, 0x25, 0x29, 0x65, 0x29, 0x26, 0xa9, 0x24, 0x4b, 0x24, 0x48, 0x3c, 0x89, 0x01, 0x09, 0x02, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xd0, 0x10, 0x8e, 0x10, 0xf1, 0x25, 0x22, 0x46, 0x14, 0x29, 0xff, 0x10, 0x20, 0x10, 0x20, 0x25, 0xff, 0x7c, 0x40, 0x10, 0x7e, 0x54, 0xa2, 0x54, 0x94, 0x51, 0x08, 0x12, 0x34, 0x10, 0xc3, 0x00, 0x00 },
{ 0xe8, 0xd1, 0x00, 0x00, 0x77, 0xbe, 0x32, 0x80, 0x54, 0x80, 0x31, 0x80, 0x56, 0x80, 0x10, 0xff, 0x08, 0x24, 0x3f, 0x24, 0x21, 0x24, 0x21, 0x24, 0x3f, 0x24, 0x21, 0x45, 0x21, 0x45, 0x3f, 0x87, 0x00, 0x00 },
{ 0xe8, 0xd2, 0x00, 0x20, 0x3c, 0x20, 0x25, 0xfe, 0x25, 0x02, 0x25, 0x02, 0x3c, 0xf8, 0x24, 0x00, 0x24, 0x00, 0x25, 0xfe, 0x3c, 0x48, 0x24, 0x48, 0x24, 0x88, 0x24, 0x89, 0x45, 0x09, 0x4e, 0x07, 0x00, 0x00 },
{ 0xe8, 0xd3, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x25, 0x01, 0x25, 0x01, 0x3c, 0x80, 0x24, 0xef, 0x24, 0xa9, 0x25, 0x29, 0x3d, 0xa9, 0x26, 0x4b, 0x24, 0x48, 0x24, 0x89, 0x44, 0x89, 0x4d, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xd4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x04, 0x21, 0x18, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xe8, 0xd5, 0x00, 0x10, 0x7e, 0x10, 0x01, 0xff, 0x01, 0x01, 0x3d, 0x41, 0x24, 0x4e, 0x24, 0xea, 0x24, 0xaa, 0x3c, 0xaa, 0x00, 0xea, 0x05, 0x2e, 0x24, 0x48, 0x28, 0x49, 0x0c, 0x89, 0x73, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xd6, 0x00, 0x00, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0x00, 0x28, 0x00, 0x28, 0x00, 0x29, 0xff, 0x24, 0x48, 0x24, 0x48, 0x24, 0x48, 0x24, 0x48, 0x38, 0x88, 0x20, 0x89, 0x21, 0x09, 0x26, 0x07, 0x00, 0x00 },
{ 0xe8, 0xd7, 0x00, 0x00, 0x3e, 0xff, 0x00, 0x08, 0x00, 0x10, 0x00, 0x7e, 0x7f, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x15, 0x42, 0x15, 0x7e, 0x27, 0x00, 0x20, 0x26, 0x40, 0xc1, 0x00, 0x00 },
{ 0xe8, 0xd8, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xf2, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xe8, 0xd9, 0x08, 0x80, 0x08, 0x40, 0x10, 0x20, 0x23, 0xff, 0x48, 0x20, 0x08, 0x20, 0x10, 0x20, 0x10, 0x20, 0x31, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x00, 0x00 },
{ 0xe8, 0xda, 0x00, 0x00, 0x01, 0xff, 0x7c, 0x10, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x7c, 0xfe, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x7c, 0x10, 0x00, 0x10, 0x01, 0xff, 0x00, 0x00 },
{ 0xe8, 0xdb, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x20, 0x7c, 0x20, 0x10, 0x20, 0x10, 0x20, 0x38, 0x20, 0x39, 0xfe, 0x34, 0x20, 0x54, 0x20, 0x50, 0x20, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x00, 0x00 },
{ 0xe8, 0xdc, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x01, 0xfc, 0x00, 0x20, 0x10, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xe8, 0xdd, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xe8, 0xde, 0x08, 0x1c, 0x0b, 0xe0, 0x08, 0x20, 0x17, 0xff, 0x10, 0xa8, 0x31, 0x24, 0x36, 0x23, 0x50, 0x40, 0x57, 0xff, 0x10, 0x88, 0x11, 0x08, 0x13, 0x90, 0x10, 0x70, 0x10, 0xcc, 0x17, 0x02, 0x00, 0x00 },
{ 0xe8, 0xdf, 0x10, 0x10, 0x10, 0x10, 0x10, 0xfe, 0x7c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x24, 0x00, 0x44, 0x10, 0x68, 0x10, 0x58, 0xfe, 0x08, 0x10, 0x14, 0x10, 0x20, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xe8, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x40, 0x01, 0x98, 0x0e, 0x86, 0x70, 0x81, 0x00, 0x80, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x08, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe8, 0xe1, 0x10, 0x06, 0x10, 0xf8, 0x20, 0x10, 0x3e, 0x10, 0x49, 0xff, 0x08, 0x38, 0x08, 0x54, 0x7e, 0x93, 0x08, 0x20, 0x08, 0x20, 0x0d, 0xff, 0x12, 0x44, 0x12, 0xc8, 0x20, 0x3c, 0x41, 0xc3, 0x00, 0x00 },
{ 0xe8, 0xe2, 0x08, 0x10, 0x08, 0x10, 0x0f, 0x90, 0x10, 0x90, 0x10, 0xd0, 0x10, 0xb0, 0x29, 0x18, 0x45, 0x14, 0x02, 0x13, 0x02, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x40, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe8, 0xe3, 0x01, 0x00, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x02, 0x00, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x04, 0x90, 0x04, 0xa8, 0x08, 0xf5, 0x10, 0x81, 0x60, 0x7f, 0x00, 0x00 },
{ 0xe8, 0xe4, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x20, 0x3e, 0x40, 0x08, 0xfc, 0x7e, 0xa4, 0x1c, 0xfc, 0x2a, 0xa4, 0x48, 0xfc, 0x10, 0x52, 0x7e, 0x55, 0x22, 0x57, 0x1c, 0x91, 0x62, 0x8f, 0x00, 0x00 },
{ 0xe8, 0xe5, 0x04, 0x00, 0x45, 0xfe, 0x29, 0x22, 0x11, 0xfe, 0x31, 0x22, 0x51, 0x22, 0x09, 0xfe, 0x08, 0x00, 0x1b, 0xff, 0x28, 0xa0, 0x48, 0x92, 0x08, 0x94, 0x08, 0x88, 0x08, 0xe4, 0x33, 0x83, 0x00, 0x00 },
{ 0xe8, 0xe6, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x40, 0x08, 0x44, 0x08, 0x28, 0x08, 0x10, 0x0b, 0x8c, 0x7c, 0x03, 0x00, 0x00 },
{ 0xe8, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00 },
{ 0xe8, 0xe8, 0x08, 0x20, 0x0f, 0xff, 0x08, 0x20, 0x12, 0x52, 0x11, 0x8c, 0x36, 0x03, 0x31, 0xfc, 0x51, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x10, 0x20, 0x13, 0x24, 0x12, 0x22, 0x14, 0xe2, 0x00, 0x00 },
{ 0xe8, 0xe9, 0x08, 0x20, 0x0b, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x31, 0x04, 0x37, 0xdf, 0x51, 0x04, 0x51, 0xc4, 0x17, 0x1f, 0x10, 0x00, 0x17, 0xff, 0x10, 0x90, 0x10, 0x90, 0x11, 0x11, 0x16, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xea, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0xe2, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xe8, 0xeb, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x3f, 0x3e, 0x08, 0x08, 0x0f, 0x08, 0x78, 0x7f, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x21, 0x04, 0x21, 0x78, 0x1f, 0x00, 0x00 },
{ 0xe8, 0xec, 0x00, 0x0c, 0x00, 0xf0, 0x3f, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe8, 0xed, 0x10, 0x0e, 0x10, 0xf0, 0x10, 0x10, 0x7c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x44, 0x28, 0x68, 0x28, 0x58, 0x28, 0x08, 0x44, 0x14, 0x44, 0x22, 0x82, 0x41, 0x01, 0x00, 0x00 },
{ 0xe8, 0xee, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x7c, 0x48, 0x25, 0x49, 0x24, 0xca, 0x24, 0x4c, 0x24, 0x48, 0x44, 0xcc, 0x69, 0x4a, 0x58, 0x49, 0x08, 0x88, 0x14, 0x89, 0x21, 0x09, 0x42, 0x07, 0x00, 0x00 },
{ 0xe8, 0xef, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0x7d, 0x0b, 0x2c, 0x15, 0x54, 0x08, 0x84, 0x03, 0x60, 0x0c, 0x18, 0x70, 0xc7, 0x0f, 0x30, 0x00, 0xc0, 0x1f, 0x0c, 0x00, 0x70, 0x1f, 0x80, 0x00, 0x00 },
{ 0xe8, 0xf0, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x3f, 0xfe, 0x00, 0x80, 0x13, 0x64, 0x0c, 0x18, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x10, 0x84, 0x10, 0x82, 0x23, 0x82, 0x00, 0x00 },
{ 0xe8, 0xf1, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x44, 0x10, 0x40, 0x10, 0x44, 0x17, 0x68, 0x11, 0x70, 0x12, 0x50, 0x12, 0x48, 0x24, 0x44, 0x28, 0x43, 0x51, 0xc0, 0x00, 0x00 },
{ 0xe8, 0xf2, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x55, 0xff, 0x54, 0x84, 0x55, 0xef, 0x54, 0x84, 0x54, 0xe4, 0x55, 0x8f, 0x54, 0x00, 0x55, 0xff, 0x7c, 0x48, 0x00, 0x49, 0x00, 0x89, 0x03, 0x07, 0x00, 0x00 },
{ 0xe8, 0xf3, 0x10, 0x88, 0x10, 0x88, 0x11, 0x08, 0x7d, 0x1f, 0x12, 0x49, 0x11, 0x49, 0x11, 0x49, 0x1c, 0x89, 0x70, 0x89, 0x10, 0xa9, 0x11, 0x29, 0x11, 0xd1, 0x17, 0x11, 0x10, 0x21, 0x30, 0x46, 0x00, 0x00 },
{ 0xe8, 0xf4, 0x10, 0x20, 0x10, 0x7e, 0x10, 0xa2, 0x7b, 0x94, 0x10, 0x48, 0x10, 0x30, 0x11, 0xc0, 0x1c, 0x40, 0x70, 0xfe, 0x10, 0x90, 0x11, 0xff, 0x10, 0x10, 0x10, 0x92, 0x10, 0x92, 0x30, 0xfe, 0x00, 0x00 },
{ 0xe8, 0xf5, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x7b, 0xff, 0x11, 0x04, 0x13, 0xdf, 0x11, 0x04, 0x1d, 0xc4, 0x73, 0x1f, 0x10, 0x00, 0x17, 0xff, 0x10, 0x90, 0x10, 0x91, 0x11, 0x11, 0x36, 0x0f, 0x00, 0x00 },
{ 0xe8, 0xf6, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x1d, 0xff, 0x71, 0x25, 0x10, 0xbc, 0x10, 0x40, 0x10, 0xfc, 0x13, 0x24, 0x10, 0x18, 0x31, 0xe7, 0x00, 0x00 },
{ 0xe8, 0xf7, 0x08, 0x04, 0x49, 0x24, 0x2a, 0x14, 0x1c, 0x14, 0x7f, 0x04, 0x08, 0x44, 0x18, 0x24, 0x1c, 0x24, 0x1a, 0x07, 0x2a, 0x1c, 0x28, 0xe4, 0x48, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x00, 0x00 },
{ 0xe8, 0xf8, 0x00, 0x00, 0x01, 0xef, 0x78, 0x63, 0x49, 0xad, 0x48, 0x63, 0x49, 0xad, 0x48, 0x24, 0x78, 0x48, 0x48, 0xff, 0x49, 0x88, 0x4a, 0xfe, 0x48, 0x88, 0x78, 0xfe, 0x00, 0x88, 0x00, 0xff, 0x00, 0x00 },
{ 0xe8, 0xf9, 0x10, 0x82, 0x20, 0x84, 0x43, 0xe8, 0x52, 0x2a, 0x23, 0xe4, 0x4a, 0x29, 0x7b, 0xef, 0x08, 0x81, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xe8, 0xfa, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x7b, 0xff, 0x10, 0x84, 0x13, 0xef, 0x38, 0x84, 0x34, 0xef, 0x33, 0x80, 0x50, 0x00, 0x53, 0xff, 0x50, 0x48, 0x10, 0x48, 0x10, 0x89, 0x17, 0x07, 0x00, 0x00 },
{ 0xe8, 0xfb, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x15, 0x52, 0x58, 0x8c, 0x53, 0x03, 0x50, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x18, 0xfc, 0x24, 0x10, 0x24, 0x94, 0x20, 0x92, 0x41, 0x32, 0x00, 0x00 },
{ 0xe8, 0xfc, 0x10, 0x00, 0x13, 0xef, 0x14, 0xa5, 0x59, 0x29, 0x52, 0x73, 0x50, 0xa5, 0x51, 0x29, 0x10, 0x88, 0x11, 0xff, 0x13, 0x10, 0x29, 0xfe, 0x25, 0x10, 0x21, 0xfe, 0x41, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xe8, 0xfd, 0x00, 0x10, 0x00, 0x3e, 0x7c, 0x62, 0x11, 0x94, 0x10, 0x58, 0x11, 0xe0, 0x10, 0x40, 0x7c, 0xfe, 0x11, 0x10, 0x12, 0x10, 0x11, 0xff, 0x1c, 0x10, 0x70, 0x92, 0x00, 0x92, 0x00, 0xfe, 0x00, 0x00 },
{ 0xe8, 0xfe, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x57, 0xff, 0x32, 0x52, 0x11, 0x8c, 0x17, 0xfb, 0x11, 0x08, 0x31, 0xf8, 0x51, 0x08, 0x11, 0xf8, 0x20, 0x20, 0x21, 0x24, 0x46, 0x62, 0x00, 0x00 },
{ 0xe9, 0xa1, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x18, 0x3c, 0x00, 0x00, 0x08, 0x10, 0x10, 0x10, 0x62, 0xfe, 0x24, 0x12, 0x14, 0x12, 0x08, 0x22, 0x12, 0x22, 0x25, 0x42, 0x78, 0x8c, 0x00, 0x00 },
{ 0xe9, 0xa2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x45, 0x44, 0x7d, 0x1a, 0x10, 0x01, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x24, 0x44, 0x22, 0x22, 0x42, 0x22, 0x00, 0x00 },
{ 0xe9, 0xa3, 0x10, 0x03, 0x1f, 0x1e, 0x29, 0x68, 0x66, 0x12, 0x14, 0x34, 0x18, 0x08, 0x60, 0x12, 0x3f, 0x3f, 0x48, 0x29, 0x08, 0x08, 0x7f, 0x2a, 0x08, 0x29, 0x49, 0x29, 0x49, 0x09, 0x7f, 0x08, 0x00, 0x00 },
{ 0xe9, 0xa4, 0x10, 0x10, 0x10, 0xfe, 0x24, 0x10, 0x45, 0xff, 0x28, 0x44, 0x11, 0xef, 0x10, 0x44, 0x24, 0x64, 0x7d, 0x9f, 0x14, 0x00, 0x51, 0xff, 0x54, 0x48, 0x54, 0x48, 0x10, 0x89, 0x13, 0x07, 0x00, 0x00 },
{ 0xe9, 0xa5, 0x10, 0x00, 0x11, 0xef, 0x54, 0x63, 0x55, 0xad, 0x58, 0x63, 0x11, 0xad, 0x7c, 0x24, 0x28, 0x48, 0x28, 0xff, 0x29, 0x88, 0x2a, 0xfe, 0x2a, 0x88, 0x2c, 0xfe, 0x48, 0x88, 0x40, 0xff, 0x00, 0x00 },
{ 0xe9, 0xa6, 0x00, 0x00, 0x3d, 0xff, 0x24, 0x28, 0x25, 0xff, 0x25, 0x29, 0x3d, 0x29, 0x25, 0xff, 0x24, 0x10, 0x24, 0x20, 0x3d, 0xff, 0x24, 0x44, 0x24, 0xe4, 0x24, 0x18, 0x44, 0x36, 0x4d, 0xc1, 0x00, 0x00 },
{ 0xe9, 0xa7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x1f, 0x7c, 0x0b, 0x2c, 0x15, 0x54, 0x08, 0x84, 0x03, 0x60, 0x0c, 0x18, 0x70, 0xc7, 0x0f, 0x30, 0x00, 0xc0, 0x1f, 0x0c, 0x00, 0x70, 0x1f, 0x80, 0x00, 0x00 },
{ 0xe9, 0xa8, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x7d, 0xff, 0x54, 0x44, 0x54, 0xee, 0x54, 0x44, 0x54, 0x64, 0x55, 0xdf, 0x7c, 0x00, 0x11, 0xff, 0x14, 0x48, 0x14, 0x49, 0x1a, 0x89, 0x63, 0x0f, 0x00, 0x00 },
{ 0xe9, 0xa9, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x02, 0x00, 0x04, 0x00, 0x7f, 0xff, 0x08, 0x20, 0x16, 0x40, 0x01, 0xb8, 0x3e, 0x06, 0x00, 0x00 },
{ 0xe9, 0xaa, 0x00, 0x10, 0x3c, 0x3f, 0x00, 0xc9, 0x7e, 0x26, 0x00, 0x1c, 0x3c, 0xf0, 0x00, 0x20, 0x3c, 0x3f, 0x00, 0x48, 0x00, 0x08, 0x3c, 0xff, 0x24, 0x08, 0x24, 0x49, 0x24, 0x49, 0x3c, 0x7f, 0x00, 0x00 },
{ 0xe9, 0xab, 0x00, 0x10, 0x10, 0x20, 0x08, 0x7e, 0x01, 0x92, 0x40, 0x4c, 0x23, 0xf0, 0x10, 0x40, 0x00, 0xfe, 0x01, 0x10, 0x73, 0xff, 0x10, 0x10, 0x10, 0x92, 0x10, 0xfe, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe9, 0xac, 0x20, 0x20, 0x13, 0xfe, 0x09, 0x24, 0x40, 0xd8, 0x21, 0x8c, 0x16, 0xfb, 0x00, 0x88, 0x00, 0xf8, 0x78, 0x88, 0x08, 0xf8, 0x09, 0x24, 0x09, 0x22, 0x16, 0x62, 0x22, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xe9, 0xad, 0x21, 0x08, 0x12, 0x08, 0x07, 0xc8, 0x44, 0x5f, 0x27, 0xd2, 0x04, 0x72, 0x07, 0xd2, 0x01, 0x12, 0x77, 0xd4, 0x12, 0x0c, 0x13, 0xcc, 0x12, 0x52, 0x15, 0xa1, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe9, 0xae, 0x08, 0x10, 0x14, 0xfe, 0x22, 0x10, 0x5d, 0xff, 0x00, 0x44, 0x3d, 0xef, 0x24, 0x44, 0x3c, 0x64, 0x25, 0x9f, 0x3c, 0x00, 0x21, 0xff, 0x3c, 0x48, 0x20, 0x48, 0x3c, 0x89, 0x23, 0x0f, 0x00, 0x00 },
{ 0xe9, 0xaf, 0x12, 0x10, 0x21, 0x10, 0x48, 0x3f, 0x14, 0x29, 0x22, 0x4a, 0x41, 0x08, 0x3e, 0x08, 0x22, 0x14, 0x22, 0x14, 0x3e, 0x22, 0x00, 0x41, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xe9, 0xb0, 0x12, 0x20, 0x21, 0x20, 0x40, 0x40, 0x08, 0x7f, 0x14, 0x91, 0x22, 0x92, 0x41, 0x10, 0x00, 0x10, 0x3e, 0x28, 0x22, 0x28, 0x22, 0x28, 0x22, 0x44, 0x22, 0x44, 0x3e, 0x82, 0x01, 0x01, 0x00, 0x00 },
{ 0xe9, 0xb1, 0x20, 0x88, 0x10, 0x84, 0x09, 0x02, 0x02, 0x22, 0x40, 0x50, 0x20, 0x88, 0x11, 0x04, 0x06, 0x03, 0x00, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xe9, 0xb2, 0x10, 0x00, 0x11, 0xff, 0x25, 0x00, 0x45, 0x7e, 0x29, 0x00, 0x11, 0xff, 0x11, 0x2a, 0x25, 0x24, 0x7d, 0x3a, 0x15, 0x61, 0x52, 0x02, 0x54, 0xff, 0x54, 0x22, 0x10, 0x12, 0x10, 0x06, 0x00, 0x00 },
{ 0xe9, 0xb3, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x7d, 0x7c, 0x05, 0x00, 0x09, 0xff, 0x09, 0x52, 0x11, 0x4c, 0x35, 0x74, 0x59, 0xc3, 0x15, 0x04, 0x12, 0xff, 0x12, 0x44, 0x14, 0x24, 0x10, 0x0c, 0x00, 0x00 },
{ 0xe9, 0xb4, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x00, 0x27, 0xf8, 0x20, 0x00, 0x3f, 0xff, 0x24, 0x44, 0x44, 0x28, 0x45, 0x98, 0x5e, 0x07, 0x00, 0x10, 0x7f, 0xff, 0x08, 0x10, 0x04, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xe9, 0xb5, 0x08, 0x00, 0x09, 0xfc, 0x08, 0x04, 0x10, 0x48, 0x10, 0x30, 0x33, 0xfe, 0x32, 0x22, 0x52, 0x22, 0x53, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x12, 0x2e, 0x00, 0x00 },
{ 0xe9, 0xb6, 0x08, 0x20, 0x0b, 0xff, 0x0a, 0x10, 0x12, 0xfe, 0x12, 0x12, 0x33, 0xff, 0x32, 0x12, 0x52, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x14, 0x92, 0x14, 0x92, 0x14, 0x96, 0x00, 0x00 },
{ 0xe9, 0xb7, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x07, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x20, 0x08, 0x20, 0x10, 0x21, 0x20, 0x21, 0x40, 0x1f, 0x00, 0x00 },
{ 0xe9, 0xb8, 0x00, 0x00, 0x1f, 0xf8, 0x01, 0x30, 0x00, 0xc0, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xfe, 0x01, 0x02, 0x02, 0x02, 0x0c, 0x02, 0x70, 0x1c, 0x00, 0x00 },
{ 0xe9, 0xb9, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x04, 0x10, 0x68, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x11, 0x11, 0x1d, 0x11, 0x71, 0xff, 0x01, 0x11, 0x01, 0x11, 0x01, 0x13, 0x00, 0x00 },
{ 0xe9, 0xba, 0x10, 0x20, 0x13, 0xff, 0x12, 0x10, 0x12, 0xfe, 0x7e, 0x12, 0x13, 0xff, 0x12, 0x12, 0x12, 0xfe, 0x12, 0x92, 0x1e, 0xfe, 0x72, 0x92, 0x02, 0xfe, 0x02, 0x92, 0x04, 0x92, 0x04, 0x96, 0x00, 0x00 },
{ 0xe9, 0xbb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x44, 0x19, 0x18, 0x84, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xe9, 0xbc, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x40, 0x27, 0xfe, 0x20, 0x42, 0x3f, 0xff, 0x20, 0x42, 0x27, 0xfe, 0x24, 0x42, 0x27, 0xfe, 0x24, 0x42, 0x47, 0xfe, 0x44, 0x42, 0x44, 0x4e, 0x00, 0x00 },
{ 0xe9, 0xbd, 0x21, 0xfc, 0x10, 0x48, 0x00, 0x30, 0x43, 0xfe, 0x22, 0x22, 0x0b, 0xfe, 0x0a, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x22, 0x2e, 0x40, 0x00, 0x04, 0x80, 0x24, 0x42, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xe9, 0xbe, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7e, 0x01, 0x12, 0x49, 0x10, 0x84, 0x39, 0x02, 0x38, 0x30, 0x34, 0x48, 0x54, 0x84, 0x51, 0xfe, 0x50, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0xfc, 0x00, 0x00 },
{ 0xe9, 0xbf, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x4c, 0x00, 0x30, 0x43, 0xff, 0x22, 0x21, 0x12, 0x21, 0x03, 0xff, 0x02, 0x21, 0x12, 0x21, 0x13, 0xff, 0x22, 0x21, 0x22, 0x21, 0x42, 0x21, 0x42, 0x27, 0x00, 0x00 },
{ 0xe9, 0xc0, 0x20, 0x00, 0x11, 0xfe, 0x08, 0x4c, 0x00, 0x30, 0x41, 0xff, 0x21, 0x11, 0x11, 0xff, 0x01, 0x11, 0x01, 0xff, 0x10, 0x20, 0x13, 0xff, 0x20, 0x21, 0x20, 0x41, 0x40, 0x81, 0x43, 0x0e, 0x00, 0x00 },
{ 0xe9, 0xc1, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x02, 0x01, 0x40, 0x8c, 0x23, 0x22, 0x10, 0x50, 0x00, 0x88, 0x01, 0x04, 0x16, 0x03, 0x11, 0xfc, 0x21, 0x04, 0x21, 0x04, 0x41, 0x04, 0x41, 0xfc, 0x00, 0x00 },
{ 0xe9, 0xc2, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x55, 0x01, 0x58, 0x46, 0x51, 0x91, 0x50, 0x28, 0x10, 0x44, 0x10, 0x82, 0x11, 0x01, 0x28, 0xfe, 0x24, 0x82, 0x20, 0x82, 0x40, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xe9, 0xc3, 0x00, 0x10, 0x7d, 0xff, 0x11, 0x01, 0x11, 0x45, 0x10, 0x82, 0x11, 0x11, 0x7c, 0x28, 0x10, 0x44, 0x10, 0x82, 0x13, 0x01, 0x10, 0x7c, 0x1c, 0x44, 0x70, 0x44, 0x00, 0x44, 0x00, 0x7c, 0x00, 0x00 },
{ 0xe9, 0xc4, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x20, 0x84, 0x20, 0x84, 0x40, 0x9c, 0x00, 0x00 },
{ 0xe9, 0xc5, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x18, 0x03, 0x60, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x00 },
{ 0xe9, 0xc6, 0x10, 0x88, 0x21, 0x54, 0x4a, 0x02, 0x11, 0x20, 0x31, 0x3c, 0x52, 0xa0, 0x14, 0x7f, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0xfe, 0x7f, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xe9, 0xc7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x3f, 0xfe, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x0f, 0x7f, 0xf8, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00 },
{ 0xe9, 0xc8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x44, 0x11, 0x58, 0x8d, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x6f, 0xfb, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xe9, 0xc9, 0x3e, 0xfe, 0x22, 0x04, 0x22, 0x28, 0x22, 0x10, 0x3e, 0xff, 0x08, 0x91, 0x08, 0x91, 0x28, 0xff, 0x2e, 0x91, 0x28, 0x91, 0x28, 0xff, 0x28, 0x91, 0x28, 0x91, 0x2e, 0x91, 0x78, 0x97, 0x00, 0x00 },
{ 0xe9, 0xca, 0x08, 0x10, 0x14, 0xff, 0x22, 0x81, 0x40, 0x24, 0x3e, 0x42, 0x08, 0x81, 0x08, 0x18, 0x7e, 0x24, 0x08, 0x42, 0x4a, 0x81, 0x2a, 0x7e, 0x28, 0x42, 0x08, 0x42, 0x0e, 0x42, 0x70, 0x7e, 0x00, 0x00 },
{ 0xe9, 0xcb, 0x08, 0x10, 0x14, 0xff, 0x12, 0x88, 0x22, 0xbe, 0x20, 0x8a, 0x5e, 0xff, 0x08, 0x8a, 0x08, 0xbe, 0x7e, 0x88, 0x08, 0xbe, 0x4a, 0xaa, 0x2a, 0xbe, 0x29, 0x2a, 0x0f, 0x3e, 0x79, 0x2a, 0x00, 0x00 },
{ 0xe9, 0xcc, 0x08, 0x20, 0x7f, 0xbf, 0x21, 0x20, 0x12, 0x3e, 0x7f, 0x82, 0x00, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x3f, 0x20, 0x21, 0x3e, 0x21, 0x20, 0x21, 0x21, 0x26, 0x1f, 0x00, 0x00 },
{ 0xe9, 0xcd, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe9, 0xce, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x40, 0x10, 0x40, 0x30, 0x80, 0x30, 0x80, 0x51, 0xfe, 0x11, 0x82, 0x12, 0x82, 0x14, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe9, 0xcf, 0x08, 0x00, 0x09, 0xfe, 0x11, 0x22, 0x11, 0xfe, 0x31, 0x22, 0x31, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x13, 0xff, 0x12, 0x21, 0x12, 0x29, 0x12, 0x3d, 0x12, 0xe5, 0x12, 0x01, 0x12, 0x03, 0x00, 0x00 },
{ 0xe9, 0xd0, 0x08, 0x00, 0x0b, 0xff, 0x08, 0x20, 0x10, 0xfc, 0x10, 0x84, 0x30, 0xfc, 0x30, 0x84, 0x53, 0xff, 0x52, 0xa1, 0x12, 0x8a, 0x14, 0x79, 0x10, 0xc4, 0x13, 0x48, 0x10, 0x30, 0x13, 0xcf, 0x00, 0x00 },
{ 0xe9, 0xd1, 0x00, 0x00, 0x3f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x04, 0x08, 0x04, 0x08, 0x02, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0xc0, 0x00, 0xc0, 0x01, 0x20, 0x06, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xe9, 0xd2, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0xfc, 0x02, 0x84, 0x04, 0x88, 0x04, 0x48, 0x08, 0x50, 0x08, 0x20, 0x10, 0x50, 0x21, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xe9, 0xd3, 0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfe, 0x14, 0x02, 0x24, 0x02, 0x44, 0x02, 0x04, 0x02, 0x04, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xe9, 0xd4, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe9, 0xd5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x92, 0x20, 0xfa, 0x2f, 0x8a, 0x20, 0x06, 0x00, 0x00 },
{ 0xe9, 0xd6, 0x00, 0x90, 0x00, 0x88, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 0x02, 0x20, 0x02, 0x20, 0x04, 0x21, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xe9, 0xd7, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0xa2, 0x27, 0xd2, 0x20, 0x06, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xe9, 0xd8, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x42, 0x41, 0x4a, 0x14, 0x11, 0xf2, 0x06, 0x20, 0x19, 0x20, 0x01, 0xc0, 0x7e, 0x3f, 0x00, 0x00 },
{ 0xe9, 0xd9, 0x00, 0x00, 0x78, 0x00, 0x49, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x78, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x48, 0x20, 0x78, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe9, 0xda, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x3f, 0xfe, 0x20, 0x80, 0x40, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe9, 0xdb, 0x00, 0x00, 0x7c, 0x00, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x7c, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x10, 0x20, 0x1c, 0x20, 0x70, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xe9, 0xdc, 0x00, 0x38, 0x7d, 0xe0, 0x10, 0x20, 0x11, 0xfc, 0x11, 0x24, 0x7d, 0x24, 0x11, 0xfc, 0x10, 0x20, 0x13, 0xfe, 0x12, 0x22, 0x1e, 0x22, 0x72, 0x3a, 0x02, 0xe2, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00 },
{ 0xe9, 0xdd, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe9, 0xde, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x00, 0xff, 0x7f, 0x10, 0x08, 0x20, 0x08, 0x20, 0x2a, 0x7e, 0x2a, 0x62, 0x2a, 0xa2, 0x2b, 0x22, 0x4a, 0x22, 0x4a, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x00, 0x00 },
{ 0xe9, 0xdf, 0x00, 0x00, 0x38, 0xfe, 0x00, 0x92, 0x00, 0xfe, 0x7c, 0x92, 0x10, 0x92, 0x10, 0xfe, 0x54, 0x10, 0x55, 0xff, 0x55, 0x11, 0x55, 0x15, 0x55, 0x1d, 0x11, 0x73, 0x11, 0x01, 0x11, 0x03, 0x00, 0x00 },
{ 0xe9, 0xe0, 0x00, 0xfc, 0x7f, 0x00, 0x01, 0x00, 0x3f, 0xfc, 0x21, 0x04, 0x21, 0x04, 0x3f, 0xfc, 0x01, 0x00, 0x7f, 0xfe, 0x41, 0x22, 0x41, 0x12, 0x41, 0xea, 0x5f, 0x0a, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xe9, 0xe1, 0x08, 0x00, 0x08, 0x7e, 0x52, 0x08, 0x22, 0x08, 0x14, 0x08, 0x08, 0x08, 0x12, 0x08, 0x7e, 0xff, 0x0a, 0x08, 0x08, 0x08, 0x2a, 0x08, 0x29, 0x08, 0x49, 0x08, 0x48, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xe9, 0xe2, 0x00, 0x00, 0x7f, 0x7f, 0x03, 0x03, 0x05, 0x05, 0x09, 0x09, 0x11, 0x11, 0x63, 0x63, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05, 0x09, 0x09, 0x11, 0x11, 0x61, 0x61, 0x01, 0x01, 0x07, 0x07, 0x00, 0x00 },
{ 0xe9, 0xe3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xe9, 0xe4, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x08, 0x00, 0x0e, 0xfe, 0x78, 0x92, 0x08, 0xfe, 0x3e, 0x92, 0x08, 0xfe, 0x7e, 0x10, 0x09, 0xff, 0x1d, 0x15, 0x29, 0x7b, 0x49, 0x01, 0x09, 0x03, 0x00, 0x00 },
{ 0xe9, 0xe5, 0x00, 0x80, 0x00, 0xf8, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x2f, 0xf8, 0x20, 0x82, 0x21, 0xfe, 0x25, 0x08, 0x25, 0x08, 0x27, 0xfc, 0x20, 0x04, 0x5f, 0xff, 0x42, 0x08, 0x4c, 0x04, 0x00, 0x00 },
{ 0xe9, 0xe6, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x20, 0x20, 0x17, 0xff, 0x00, 0x20, 0x00, 0x20, 0x70, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0xe0, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe9, 0xe7, 0x21, 0xfe, 0x11, 0x22, 0x09, 0xfe, 0x01, 0x22, 0x41, 0xfe, 0x20, 0x20, 0x10, 0x20, 0x03, 0xff, 0x02, 0x21, 0x72, 0x29, 0x12, 0x3d, 0x12, 0xe5, 0x12, 0x03, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xe9, 0xe8, 0x00, 0x00, 0x03, 0x9f, 0x7c, 0x11, 0x08, 0x11, 0x7f, 0xd2, 0x29, 0x12, 0x29, 0x14, 0x7f, 0xd2, 0x29, 0x12, 0x29, 0x11, 0x7f, 0xd1, 0x08, 0x11, 0x08, 0x16, 0x0b, 0x90, 0x7c, 0x10, 0x00, 0x00 },
{ 0xe9, 0xe9, 0x10, 0x00, 0x18, 0xfe, 0x24, 0x10, 0x40, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x10, 0x10, 0x10, 0x54, 0x10, 0x54, 0x10, 0x50, 0x10, 0x1e, 0x10, 0x70, 0x70, 0x00, 0x00, 0x00, 0x00 },
{ 0xe9, 0xea, 0x7c, 0xfe, 0x44, 0x92, 0x48, 0xfe, 0x48, 0x92, 0x50, 0x92, 0x48, 0xfe, 0x48, 0x10, 0x44, 0x10, 0x45, 0xff, 0x45, 0x11, 0x59, 0x15, 0x41, 0x1d, 0x41, 0x75, 0x41, 0x01, 0x41, 0x03, 0x00, 0x00 },
{ 0xe9, 0xeb, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x28, 0xa2, 0x24, 0x92, 0x22, 0x8a, 0x20, 0x82, 0x28, 0xa2, 0x24, 0x92, 0x22, 0x8a, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x00 },
{ 0xe9, 0xec, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x00, 0x0f, 0xf8, 0x00, 0x08, 0x00, 0x10, 0x03, 0xe0, 0x00, 0x00 },
{ 0xe9, 0xed, 0x00, 0x10, 0x7f, 0x10, 0x41, 0x10, 0x5d, 0x10, 0x41, 0x7e, 0x5d, 0x12, 0x00, 0x12, 0x7f, 0x12, 0x41, 0x12, 0x7f, 0x12, 0x41, 0x12, 0x7f, 0x22, 0x41, 0x22, 0x7f, 0x22, 0x00, 0x4c, 0x00, 0x00 },
{ 0xe9, 0xee, 0x00, 0x4c, 0x00, 0x42, 0x7f, 0xff, 0x00, 0x40, 0x3e, 0x48, 0x22, 0x70, 0x23, 0xc4, 0x22, 0x58, 0x3e, 0x62, 0x00, 0xc4, 0x03, 0x28, 0x0c, 0x31, 0x70, 0x51, 0x01, 0x89, 0x0e, 0x06, 0x00, 0x00 },
{ 0xe9, 0xef, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x42, 0x7e, 0x42, 0x12, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x12, 0x42, 0x12, 0x42, 0x22, 0x7e, 0x22, 0x00, 0x22, 0x01, 0x42, 0x01, 0x41, 0xff, 0x00, 0x00 },
{ 0xe9, 0xf0, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xe9, 0xf1, 0x10, 0x20, 0x10, 0x20, 0x11, 0xff, 0x7c, 0x20, 0x10, 0x40, 0x10, 0x7e, 0x38, 0xc2, 0x35, 0x42, 0x34, 0x7e, 0x50, 0x42, 0x50, 0x42, 0x10, 0x7e, 0x10, 0x42, 0x10, 0x42, 0x10, 0x4e, 0x00, 0x00 },
{ 0xe9, 0xf2, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x15, 0xfe, 0x55, 0x02, 0x59, 0x02, 0x51, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x17, 0xff, 0x11, 0x04, 0x29, 0x04, 0x24, 0x84, 0x20, 0x88, 0x47, 0xff, 0x00, 0x00 },
{ 0xe9, 0xf3, 0x04, 0x0a, 0x18, 0x0a, 0x71, 0xff, 0x10, 0x08, 0x11, 0xea, 0x7d, 0x2c, 0x11, 0x38, 0x31, 0xea, 0x38, 0x0c, 0x34, 0x18, 0x54, 0x6a, 0x51, 0x8d, 0x10, 0x15, 0x10, 0x63, 0x11, 0x81, 0x00, 0x00 },
{ 0xe9, 0xf4, 0x08, 0x00, 0x08, 0x1f, 0x7f, 0xd1, 0x08, 0x11, 0x10, 0x12, 0x1f, 0x92, 0x30, 0x94, 0x50, 0x92, 0x1f, 0x92, 0x10, 0x91, 0x10, 0x91, 0x1f, 0x91, 0x10, 0x96, 0x10, 0x90, 0x13, 0x90, 0x00, 0x00 },
{ 0xe9, 0xf5, 0x00, 0x00, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x7c, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x24, 0x00, 0x42, 0x01, 0x81, 0x00, 0x00 },
{ 0xe9, 0xf6, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x02, 0x10, 0x04, 0x08, 0x04, 0x04, 0x08, 0xfe, 0x7f, 0x01, 0x00, 0x01, 0x00, 0x00 },
{ 0xe9, 0xf7, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x7f, 0xff, 0x40, 0x81, 0x5f, 0xfd, 0x00, 0x80, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xe9, 0xf8, 0x10, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x7d, 0x11, 0x11, 0x55, 0x11, 0x11, 0x38, 0x54, 0x34, 0x00, 0x34, 0xfe, 0x50, 0x02, 0x50, 0x02, 0x11, 0xff, 0x10, 0x02, 0x10, 0x02, 0x10, 0xfe, 0x00, 0x00 },
{ 0xe9, 0xf9, 0x00, 0xfc, 0x7e, 0x84, 0x10, 0x84, 0x10, 0xfc, 0x1c, 0x00, 0x25, 0xfe, 0x25, 0x02, 0x25, 0xfe, 0x59, 0x02, 0x49, 0xfe, 0x09, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x21, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xe9, 0xfa, 0x01, 0xfc, 0x20, 0x20, 0x17, 0xff, 0x04, 0x21, 0x45, 0xad, 0x20, 0x20, 0x01, 0xac, 0x00, 0x00, 0x10, 0xf8, 0x10, 0x00, 0x23, 0xfe, 0x20, 0x40, 0x40, 0x88, 0x41, 0x3c, 0x03, 0xc4, 0x00, 0x00 },
{ 0xe9, 0xfb, 0x10, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x14, 0xfc, 0x54, 0x00, 0x59, 0xfe, 0x51, 0x02, 0x51, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x19, 0x02, 0x15, 0xfe, 0x24, 0x00, 0x24, 0x4c, 0x43, 0x83, 0x00, 0x00 },
{ 0xe9, 0xfc, 0x08, 0x00, 0x0e, 0x7e, 0x78, 0x00, 0x08, 0x00, 0x08, 0x00, 0x7e, 0x00, 0x08, 0xff, 0x08, 0x10, 0x7e, 0x10, 0x08, 0x20, 0x1c, 0x24, 0x1a, 0x22, 0x29, 0x42, 0x48, 0x5d, 0x08, 0xe1, 0x00, 0x00 },
{ 0xe9, 0xfd, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x02, 0x08, 0x04, 0x04, 0x08, 0xfc, 0x3f, 0x02, 0x00, 0x00 },
{ 0xe9, 0xfe, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x08, 0x08, 0xf4, 0x3f, 0x02, 0x00, 0x00 },
{ 0xea, 0xa1, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x21, 0x41, 0xfe, 0x20, 0x20, 0x11, 0xfe, 0x01, 0x22, 0x01, 0xfe, 0x71, 0x22, 0x11, 0xfe, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x2c, 0x20, 0x43, 0xff, 0x00, 0x00 },
{ 0xea, 0xa2, 0x7c, 0xfc, 0x44, 0x84, 0x44, 0x84, 0x48, 0xfc, 0x48, 0x00, 0x51, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x45, 0x02, 0x45, 0xfe, 0x45, 0x02, 0x59, 0xfe, 0x40, 0x00, 0x40, 0x84, 0x43, 0x03, 0x00, 0x00 },
{ 0xea, 0xa3, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x08, 0x08, 0x74, 0x3f, 0x82, 0x00, 0x00 },
{ 0xea, 0xa4, 0x08, 0x00, 0x08, 0x7e, 0x7f, 0x42, 0x22, 0x7e, 0x12, 0x00, 0x14, 0x00, 0x7f, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x22, 0x42, 0x22, 0x7e, 0x3e, 0x42, 0x22, 0x7e, 0x22, 0x22, 0x3e, 0xc1, 0x00, 0x00 },
{ 0xea, 0xa5, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x02, 0x3f, 0x82, 0x20, 0x82, 0x3f, 0xbf, 0x20, 0x02, 0x2f, 0x82, 0x20, 0x22, 0x2f, 0x92, 0x22, 0x12, 0x4a, 0x82, 0x52, 0x42, 0x46, 0x0e, 0x00, 0x00 },
{ 0xea, 0xa6, 0x11, 0x04, 0x7b, 0xef, 0x14, 0x84, 0x3b, 0xee, 0x56, 0xb5, 0x12, 0xa4, 0x7f, 0xff, 0x4a, 0x05, 0x35, 0x88, 0x2a, 0xb2, 0x3f, 0x84, 0x23, 0x39, 0x3c, 0x02, 0x20, 0x8c, 0x3f, 0xb0, 0x00, 0x00 },
{ 0xea, 0xa7, 0x00, 0x00, 0x1f, 0xfe, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x10, 0x01, 0xe0, 0x00, 0x00 },
{ 0xea, 0xa8, 0x08, 0x20, 0x12, 0x26, 0x21, 0x38, 0x7e, 0xa0, 0x00, 0x21, 0x3f, 0x1f, 0x21, 0x20, 0x3f, 0x26, 0x21, 0x38, 0x3f, 0x20, 0x21, 0x21, 0x23, 0x1f, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xea, 0xa9, 0x08, 0x12, 0x08, 0x12, 0x08, 0x24, 0x7f, 0x3f, 0x08, 0x64, 0x10, 0x64, 0x10, 0xa4, 0x14, 0x3f, 0x24, 0x24, 0x24, 0x24, 0x49, 0x3f, 0x49, 0x24, 0x13, 0xa4, 0x3c, 0xa4, 0x00, 0x3f, 0x00, 0x00 },
{ 0xea, 0xaa, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xea, 0xab, 0x1f, 0xff, 0x10, 0x20, 0x10, 0x40, 0x13, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x10, 0x20, 0x11, 0x24, 0x22, 0x22, 0x24, 0x21, 0x40, 0xe0, 0x00, 0x00 },
{ 0xea, 0xac, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x0c, 0x1c, 0x70, 0x03, 0x00, 0x00 },
{ 0xea, 0xad, 0x7f, 0xfe, 0x40, 0x02, 0x4f, 0xf2, 0x48, 0x12, 0x4f, 0xf2, 0x40, 0x02, 0x4f, 0xf2, 0x48, 0x12, 0x4f, 0xf2, 0x48, 0x12, 0x4f, 0xf2, 0x46, 0x62, 0x58, 0x1a, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xea, 0xae, 0x7f, 0xfe, 0x41, 0x02, 0x4f, 0xf2, 0x41, 0x02, 0x5f, 0xfa, 0x40, 0x02, 0x4f, 0xe2, 0x48, 0x22, 0x4f, 0xe2, 0x43, 0x92, 0x45, 0x62, 0x59, 0x3a, 0x41, 0x02, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xea, 0xaf, 0x10, 0x00, 0x11, 0xff, 0x10, 0x00, 0x10, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00 },
{ 0xea, 0xb0, 0x10, 0x47, 0x10, 0x78, 0x10, 0x92, 0x7d, 0x09, 0x24, 0xfe, 0x24, 0x20, 0x24, 0x20, 0x25, 0xff, 0x44, 0x20, 0x68, 0x7e, 0x58, 0x42, 0x08, 0xa4, 0x15, 0x18, 0x22, 0x24, 0x40, 0xc3, 0x00, 0x00 },
{ 0xea, 0xb1, 0x10, 0x00, 0x11, 0xff, 0x11, 0x10, 0x7d, 0x20, 0x25, 0x7e, 0x25, 0x42, 0x25, 0x7e, 0x25, 0x42, 0x45, 0x7e, 0x69, 0x08, 0x59, 0x08, 0x09, 0x4a, 0x16, 0x49, 0x22, 0x89, 0x44, 0x38, 0x00, 0x00 },
{ 0xea, 0xb2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x01, 0x43, 0xe1, 0x04, 0x20, 0x08, 0x40, 0x1f, 0xfc, 0x68, 0x84, 0x08, 0x84, 0x0f, 0xfc, 0x01, 0x48, 0x02, 0x45, 0x0c, 0x41, 0x70, 0x3f, 0x00, 0x00 },
{ 0xea, 0xb3, 0x08, 0x00, 0x0f, 0x7e, 0x11, 0x42, 0x21, 0x42, 0x52, 0x4e, 0x0a, 0x40, 0x04, 0x41, 0x08, 0x41, 0x10, 0x3f, 0x60, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xea, 0xb4, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x80, 0x27, 0xfc, 0x24, 0x04, 0x27, 0xfc, 0x24, 0x04, 0x27, 0xfc, 0x40, 0x40, 0x0c, 0x4c, 0x30, 0x43, 0x04, 0x80, 0x04, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xea, 0xb5, 0x10, 0x8f, 0x10, 0xf0, 0x11, 0x24, 0x7d, 0x12, 0x12, 0x00, 0x11, 0xff, 0x10, 0x40, 0x1b, 0xff, 0x70, 0x80, 0x10, 0xfe, 0x11, 0x42, 0x11, 0x24, 0x12, 0x18, 0x14, 0x66, 0x31, 0x81, 0x00, 0x00 },
{ 0xea, 0xb6, 0x20, 0x00, 0x10, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x20, 0x00, 0x0b, 0xff, 0x08, 0x48, 0x10, 0x48, 0x10, 0x48, 0x20, 0x48, 0x20, 0x89, 0x40, 0x89, 0x41, 0x09, 0x06, 0x07, 0x00, 0x00 },
{ 0xea, 0xb7, 0x20, 0x00, 0x13, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x41, 0xfc, 0x21, 0x04, 0x09, 0x04, 0x09, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x21, 0xfc, 0x20, 0x00, 0x40, 0x00, 0x47, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xea, 0xb8, 0x20, 0x0e, 0x11, 0xf0, 0x09, 0x22, 0x02, 0x11, 0x45, 0xfe, 0x20, 0x40, 0x10, 0x40, 0x03, 0xff, 0x00, 0x80, 0x10, 0xfc, 0x10, 0x84, 0x21, 0x48, 0x21, 0x30, 0x42, 0x2c, 0x4c, 0xc3, 0x00, 0x00 },
{ 0xea, 0xb9, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x10, 0x02, 0x20, 0x42, 0xfe, 0x22, 0x82, 0x12, 0xfe, 0x02, 0x82, 0x02, 0x82, 0x12, 0xfe, 0x12, 0x10, 0x22, 0x92, 0x24, 0x91, 0x45, 0x11, 0x48, 0x30, 0x00, 0x00 },
{ 0xea, 0xba, 0x00, 0x3c, 0x1f, 0xc0, 0x11, 0x04, 0x20, 0x82, 0x4f, 0xf9, 0x02, 0x00, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x00, 0x07, 0xf8, 0x09, 0x08, 0x10, 0x90, 0x20, 0x60, 0x41, 0x98, 0x0e, 0x07, 0x00, 0x00 },
{ 0xea, 0xbb, 0x04, 0x20, 0x44, 0x20, 0x2b, 0xfe, 0x10, 0x20, 0x37, 0xff, 0x50, 0x00, 0x09, 0xfc, 0x09, 0x04, 0x19, 0x04, 0x29, 0xfc, 0x48, 0x52, 0x09, 0x94, 0x0e, 0x88, 0x08, 0xe4, 0x33, 0x83, 0x00, 0x00 },
{ 0xea, 0xbc, 0x00, 0x0e, 0x7d, 0xf0, 0x11, 0x22, 0x12, 0x11, 0x13, 0xfe, 0x7c, 0x40, 0x10, 0x40, 0x13, 0xfe, 0x10, 0x80, 0x10, 0xfc, 0x1d, 0x88, 0x71, 0x50, 0x02, 0x20, 0x0c, 0x58, 0x01, 0x87, 0x00, 0x00 },
{ 0xea, 0xbd, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x08, 0x00, 0x08, 0x00, 0x1f, 0x3e, 0x11, 0x22, 0x21, 0x22, 0x52, 0x22, 0x0a, 0x22, 0x04, 0x2e, 0x04, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xea, 0xbe, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x42, 0x0c, 0x24, 0x74, 0x18, 0x05, 0xcc, 0x3e, 0x03, 0x00, 0x00 },
{ 0xea, 0xbf, 0x08, 0x10, 0x08, 0x7e, 0x7f, 0x10, 0x08, 0xff, 0x3e, 0x00, 0x2a, 0x7e, 0x3e, 0x42, 0x2a, 0x42, 0x3e, 0x7e, 0x08, 0x28, 0x08, 0x49, 0x7f, 0xc6, 0x08, 0x44, 0x08, 0x72, 0x09, 0xc1, 0x00, 0x00 },
{ 0xea, 0xc0, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x20, 0x07, 0xff, 0x40, 0x00, 0x21, 0xfc, 0x11, 0x04, 0x01, 0x04, 0x01, 0xfd, 0x70, 0xb2, 0x11, 0x2c, 0x16, 0x23, 0x10, 0x20, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xea, 0xc1, 0x7c, 0xfe, 0x44, 0x00, 0x44, 0x00, 0x48, 0x00, 0x48, 0x00, 0x51, 0xff, 0x48, 0x48, 0x48, 0x48, 0x44, 0x48, 0x44, 0x48, 0x44, 0x48, 0x58, 0x88, 0x40, 0x89, 0x41, 0x09, 0x42, 0x0f, 0x00, 0x00 },
{ 0xea, 0xc2, 0x00, 0x10, 0x7c, 0x10, 0x45, 0xff, 0x49, 0x01, 0x49, 0x01, 0x50, 0x7c, 0x48, 0x00, 0x48, 0x00, 0x45, 0xff, 0x44, 0x48, 0x44, 0x48, 0x58, 0x88, 0x40, 0x89, 0x41, 0x09, 0x42, 0x0f, 0x00, 0x00 },
{ 0xea, 0xc3, 0x00, 0x00, 0x3f, 0xbf, 0x22, 0x04, 0x24, 0x08, 0x2f, 0x9f, 0x28, 0x91, 0x2f, 0x9f, 0x28, 0x91, 0x2f, 0x9f, 0x22, 0x11, 0x2a, 0x91, 0x2a, 0x5f, 0x4a, 0x40, 0x52, 0x0a, 0x46, 0x31, 0x00, 0x00 },
{ 0xea, 0xc4, 0x08, 0x00, 0x1f, 0x3c, 0x21, 0x24, 0x52, 0xac, 0x0d, 0x21, 0x1f, 0xff, 0x68, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x00, 0x0f, 0xff, 0x24, 0x91, 0x22, 0x49, 0x40, 0x06, 0x00, 0x00 },
{ 0xea, 0xc5, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x10, 0x08, 0x10, 0x08, 0x20, 0x08, 0x40, 0x38, 0x00, 0x00 },
{ 0xea, 0xc6, 0x08, 0x14, 0x08, 0x12, 0x3e, 0x10, 0x08, 0xfe, 0x08, 0x90, 0x7e, 0x92, 0x08, 0x92, 0x08, 0x94, 0x2e, 0x88, 0x28, 0xea, 0x29, 0x96, 0x38, 0x22, 0x28, 0x40, 0x46, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xea, 0xc7, 0x08, 0x14, 0x14, 0x12, 0x22, 0x10, 0x40, 0xff, 0x3e, 0x90, 0x08, 0x92, 0x08, 0x92, 0x7e, 0x92, 0x08, 0x94, 0x4a, 0x94, 0x2a, 0xe8, 0x29, 0x89, 0x08, 0x15, 0x0e, 0x23, 0x70, 0xc1, 0x00, 0x00 },
{ 0xea, 0xc8, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x13, 0xfe, 0x10, 0x00, 0x30, 0x04, 0x31, 0x04, 0x51, 0x04, 0x50, 0x84, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0x10, 0x10, 0x10, 0x17, 0xff, 0x00, 0x00 },
{ 0xea, 0xc9, 0x08, 0x20, 0x09, 0xfc, 0x08, 0x44, 0x10, 0x44, 0x13, 0xff, 0x30, 0x00, 0x31, 0xfc, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x10, 0x13, 0xfe, 0x11, 0x10, 0x17, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xea, 0xca, 0x08, 0x0e, 0x0b, 0xf0, 0x12, 0x42, 0x12, 0x21, 0x35, 0xf8, 0x31, 0x08, 0x51, 0x08, 0x51, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xff, 0x12, 0x01, 0x12, 0xa9, 0x14, 0xa9, 0x11, 0x06, 0x00, 0x00 },
{ 0xea, 0xcb, 0x02, 0x00, 0x02, 0x00, 0x07, 0xf0, 0x08, 0x10, 0x10, 0x20, 0x3f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x13, 0xf8, 0x12, 0x08, 0x12, 0x08, 0x12, 0x38, 0x22, 0x02, 0x22, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xea, 0xcc, 0x7f, 0xfe, 0x41, 0x02, 0x47, 0xe2, 0x42, 0x22, 0x5f, 0xfa, 0x44, 0x12, 0x44, 0x12, 0x47, 0xf2, 0x40, 0x42, 0x47, 0xf2, 0x42, 0x42, 0x4f, 0xfa, 0x40, 0x42, 0x40, 0x42, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xea, 0xcd, 0x00, 0x3c, 0x1f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x10, 0x0f, 0x20, 0x00, 0xf0, 0x03, 0x0c, 0x3c, 0x03, 0x00, 0x00 },
{ 0xea, 0xce, 0x00, 0x24, 0x00, 0x22, 0x3f, 0xff, 0x20, 0x20, 0x20, 0x20, 0x3f, 0xa2, 0x24, 0x22, 0x24, 0x22, 0x3f, 0x94, 0x25, 0x14, 0x29, 0x08, 0x2d, 0x09, 0x42, 0x15, 0x45, 0x23, 0x48, 0xc1, 0x00, 0x00 },
{ 0xea, 0xcf, 0x3f, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0x82, 0x20, 0x3f, 0x2f, 0x82, 0x20, 0x02, 0x20, 0x22, 0x2f, 0x92, 0x22, 0x12, 0x2a, 0x82, 0x2a, 0x42, 0x52, 0x42, 0x42, 0x02, 0x46, 0x0e, 0x00, 0x00 },
{ 0xea, 0xd0, 0x00, 0x02, 0x3f, 0x82, 0x20, 0x82, 0x3f, 0xbf, 0x20, 0x02, 0x3f, 0x92, 0x22, 0x0a, 0x2a, 0x8a, 0x4a, 0x42, 0x52, 0x42, 0x06, 0x0e, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xea, 0xd1, 0x00, 0x20, 0x79, 0xfc, 0x48, 0x44, 0x48, 0x44, 0x4b, 0xff, 0x78, 0x00, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x48, 0x10, 0x7b, 0xfe, 0x01, 0x10, 0x07, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xea, 0xd2, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x22, 0x03, 0xfe, 0x42, 0x22, 0x23, 0xfe, 0x10, 0x00, 0x01, 0xfc, 0x01, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x21, 0xfc, 0x21, 0x04, 0x41, 0x04, 0x41, 0x1c, 0x00, 0x00 },
{ 0xea, 0xd3, 0x00, 0x7c, 0x1f, 0x88, 0x11, 0x04, 0x20, 0x82, 0x5f, 0xf1, 0x10, 0x10, 0x10, 0x10, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xff, 0x10, 0x09, 0x25, 0x25, 0x24, 0x91, 0x48, 0x06, 0x00, 0x00 },
{ 0xea, 0xd4, 0x00, 0x20, 0x7c, 0xfc, 0x10, 0x24, 0x10, 0x44, 0x11, 0xff, 0x7c, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x08, 0x1d, 0xff, 0x70, 0x88, 0x03, 0xff, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00 },
{ 0xea, 0xd5, 0x10, 0x20, 0x10, 0xfc, 0x24, 0x24, 0x44, 0x44, 0x29, 0xff, 0x10, 0x00, 0x10, 0xfe, 0x24, 0x82, 0x7c, 0xfe, 0x10, 0x10, 0x54, 0xfe, 0x54, 0x90, 0x51, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xea, 0xd6, 0x00, 0x00, 0x3f, 0xfc, 0x21, 0x04, 0x3f, 0xfc, 0x21, 0x04, 0x3f, 0xfc, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x38, 0x00, 0x00 },
{ 0xea, 0xd7, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x1c, 0x1f, 0xe0, 0x00, 0x80, 0x7f, 0xff, 0x06, 0xb0, 0x78, 0x8f, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x00, 0xf8, 0x3f, 0x06, 0x00, 0x00 },
{ 0xea, 0xd8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x0f, 0xf8, 0x01, 0x08, 0x3f, 0xfe, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x40, 0x1f, 0xfc, 0x04, 0x40, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x00 },
{ 0xea, 0xd9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x3e, 0x0f, 0xc0, 0x08, 0x84, 0x10, 0x42, 0x2f, 0xfc, 0x08, 0x04, 0x0f, 0xfe, 0x08, 0x02, 0x1f, 0xff, 0x24, 0x09, 0x25, 0x25, 0x48, 0x96, 0x00, 0x00 },
{ 0xea, 0xda, 0x10, 0x00, 0x10, 0xff, 0x10, 0x91, 0x7c, 0xff, 0x54, 0x91, 0x54, 0xff, 0x54, 0x00, 0x54, 0x7e, 0x54, 0x42, 0x7c, 0x7e, 0x10, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x1a, 0x42, 0x62, 0x46, 0x00, 0x00 },
{ 0xea, 0xdb, 0x08, 0x80, 0x0b, 0xef, 0x11, 0x20, 0x21, 0x20, 0x4b, 0xf0, 0x08, 0x0f, 0x13, 0xf2, 0x12, 0x12, 0x33, 0xf2, 0x50, 0x42, 0x17, 0xf2, 0x12, 0x42, 0x17, 0xfa, 0x10, 0x42, 0x10, 0x46, 0x00, 0x00 },
{ 0xea, 0xdc, 0x10, 0x20, 0x10, 0xfc, 0x10, 0x24, 0x7c, 0x44, 0x05, 0xff, 0x08, 0x00, 0x0a, 0xfe, 0x14, 0x82, 0x38, 0xfe, 0x54, 0x08, 0x15, 0xff, 0x10, 0x88, 0x11, 0xff, 0x10, 0x08, 0x10, 0x08, 0x00, 0x00 },
{ 0xea, 0xdd, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x91, 0x7e, 0xff, 0x00, 0x91, 0x3c, 0xff, 0x00, 0x00, 0x3c, 0x7e, 0x00, 0x42, 0x00, 0x7e, 0x3c, 0x42, 0x24, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x3c, 0x46, 0x00, 0x00 },
{ 0xea, 0xde, 0x20, 0x20, 0x11, 0xfc, 0x08, 0x44, 0x43, 0xff, 0x20, 0x00, 0x11, 0xfc, 0x01, 0x04, 0x01, 0xfc, 0x70, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x13, 0xff, 0x10, 0x10, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xea, 0xdf, 0x01, 0x00, 0x1f, 0xf8, 0x02, 0x08, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x40, 0x1f, 0xfc, 0x08, 0x40, 0x08, 0x40, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00 },
{ 0xea, 0xe0, 0x03, 0x10, 0x3c, 0x20, 0x08, 0xfe, 0x7e, 0x92, 0x1c, 0x92, 0x2a, 0xfe, 0x48, 0x92, 0x00, 0x92, 0x08, 0xfe, 0x7f, 0x52, 0x12, 0x55, 0x32, 0x57, 0x0c, 0x90, 0x1a, 0x91, 0x61, 0x0f, 0x00, 0x00 },
{ 0xea, 0xe1, 0x03, 0x90, 0x7c, 0x10, 0x00, 0x90, 0x48, 0x90, 0x25, 0x10, 0x00, 0x10, 0x7f, 0x90, 0x03, 0x10, 0x04, 0x10, 0x05, 0x90, 0x0e, 0x10, 0x74, 0x11, 0x04, 0x11, 0x04, 0x11, 0x1c, 0x0f, 0x00, 0x00 },
{ 0xea, 0xe2, 0x08, 0x20, 0x08, 0x20, 0x13, 0xff, 0x10, 0x40, 0x30, 0x80, 0x30, 0xfe, 0x51, 0x82, 0x52, 0x82, 0x14, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xea, 0xe3, 0x08, 0x00, 0x0b, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x34, 0x21, 0x35, 0xad, 0x50, 0x00, 0x17, 0xff, 0x10, 0x20, 0x10, 0x40, 0x13, 0xff, 0x12, 0x49, 0x12, 0x49, 0x12, 0x49, 0x12, 0x4b, 0x00, 0x00 },
{ 0xea, 0xe4, 0x1f, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x1b, 0xec, 0x60, 0x03, 0x1e, 0x24, 0x12, 0x24, 0x1a, 0x48, 0x16, 0x48, 0x12, 0x90, 0x1a, 0x48, 0x16, 0x48, 0x12, 0x24, 0x16, 0x24, 0x00, 0x00 },
{ 0xea, 0xe5, 0x08, 0x02, 0x33, 0xc2, 0x21, 0x52, 0x29, 0x52, 0x2a, 0x52, 0x74, 0xd2, 0x0a, 0x12, 0x11, 0x12, 0x7e, 0x92, 0x04, 0x12, 0x3f, 0x92, 0x25, 0x12, 0x16, 0x02, 0x17, 0x82, 0x78, 0x0e, 0x00, 0x00 },
{ 0xea, 0xe6, 0x00, 0x88, 0x00, 0x88, 0x79, 0x10, 0x4b, 0xff, 0x4d, 0x10, 0x49, 0x10, 0x49, 0x10, 0x49, 0xfe, 0x49, 0x10, 0x49, 0x10, 0x49, 0xfe, 0x49, 0x10, 0x79, 0x10, 0x01, 0x10, 0x01, 0xff, 0x00, 0x00 },
{ 0xea, 0xe7, 0x01, 0xe0, 0x78, 0x50, 0x49, 0x8c, 0x4e, 0x03, 0x48, 0xf8, 0x48, 0x00, 0x4b, 0xc9, 0x4a, 0x49, 0x4b, 0x52, 0x4a, 0xd2, 0x7a, 0x64, 0x03, 0x52, 0x02, 0xd2, 0x02, 0x49, 0x02, 0xc9, 0x00, 0x00 },
{ 0xea, 0xe8, 0x00, 0x00, 0x7d, 0xfe, 0x04, 0x20, 0x0b, 0xff, 0x12, 0x21, 0x13, 0xad, 0x10, 0x20, 0x19, 0xac, 0x30, 0x00, 0x53, 0xff, 0x10, 0x40, 0x11, 0xfe, 0x11, 0x52, 0x11, 0x52, 0x31, 0x56, 0x00, 0x00 },
{ 0xea, 0xe9, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x14, 0x04, 0x27, 0xfc, 0x44, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00 },
{ 0xea, 0xea, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x12, 0x7f, 0x62, 0x11, 0x24, 0x11, 0x14, 0x11, 0x08, 0x11, 0x08, 0x11, 0x12, 0x21, 0x12, 0x21, 0x27, 0x21, 0x79, 0x41, 0x00, 0x41, 0x00, 0x86, 0x00, 0x00 },
{ 0xea, 0xeb, 0x01, 0x00, 0x01, 0x00, 0x49, 0x12, 0x49, 0x12, 0x49, 0x12, 0x71, 0x62, 0x55, 0x2a, 0x55, 0x2a, 0x49, 0x12, 0x49, 0x12, 0x55, 0x2a, 0x7d, 0x7a, 0x45, 0x0a, 0x41, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xea, 0xec, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x11, 0x40, 0x16, 0x5c, 0x14, 0x44, 0x17, 0x5c, 0x14, 0x44, 0x17, 0xfc, 0x10, 0xa0, 0x10, 0xa0, 0x21, 0x10, 0x22, 0x08, 0x4c, 0x06, 0x00, 0x00 },
{ 0xea, 0xed, 0x08, 0x20, 0x08, 0x20, 0x12, 0x7f, 0x12, 0x42, 0x32, 0xa2, 0x32, 0x24, 0x52, 0x18, 0x12, 0x18, 0x12, 0x24, 0x10, 0xc3, 0x00, 0x00, 0x04, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xea, 0xee, 0x10, 0x88, 0x10, 0x88, 0x19, 0x10, 0x55, 0xff, 0x57, 0x10, 0x51, 0x10, 0x51, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xea, 0xef, 0x0f, 0xc0, 0x02, 0x20, 0x05, 0xd0, 0x18, 0x0c, 0x7f, 0x27, 0x11, 0x24, 0x19, 0x48, 0x15, 0x48, 0x19, 0x48, 0x15, 0x24, 0x13, 0x24, 0x04, 0x80, 0x24, 0x4a, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xea, 0xf0, 0x11, 0xf0, 0x10, 0x48, 0x10, 0x84, 0x19, 0x02, 0x56, 0xfd, 0x54, 0x00, 0x50, 0x09, 0x53, 0xc9, 0x12, 0x52, 0x13, 0x52, 0x12, 0xe4, 0x13, 0x52, 0x12, 0xd2, 0x12, 0x49, 0x12, 0xc9, 0x00, 0x00 },
{ 0xea, 0xf1, 0x11, 0xe0, 0x10, 0x50, 0x10, 0x88, 0x79, 0x04, 0x16, 0xfb, 0x10, 0x00, 0x13, 0xc9, 0x1a, 0x49, 0x73, 0x52, 0x12, 0xd2, 0x12, 0x64, 0x13, 0x52, 0x12, 0xd2, 0x12, 0x49, 0x32, 0xc9, 0x00, 0x00 },
{ 0xea, 0xf2, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x12, 0x7f, 0x12, 0x44, 0x32, 0x84, 0x33, 0x44, 0x52, 0x44, 0x52, 0x44, 0x12, 0x28, 0x12, 0x28, 0x12, 0x10, 0x12, 0x28, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xea, 0xf3, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x07, 0xfc, 0x0c, 0x04, 0x14, 0x04, 0x27, 0xfc, 0x44, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00 },
{ 0xea, 0xf4, 0x10, 0x00, 0x11, 0xfc, 0x10, 0x44, 0x7e, 0x44, 0x10, 0x44, 0x10, 0x44, 0x38, 0x44, 0x35, 0xff, 0x34, 0x44, 0x50, 0x44, 0x50, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x44, 0x13, 0xff, 0x00, 0x00 },
{ 0xea, 0xf5, 0x00, 0x00, 0x1f, 0xf0, 0x02, 0x20, 0x01, 0x40, 0x7f, 0xff, 0x02, 0x82, 0x04, 0x84, 0x18, 0x80, 0x63, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xea, 0xf6, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0xff, 0x10, 0x91, 0x10, 0x91, 0x38, 0x91, 0x38, 0x91, 0x34, 0xff, 0x54, 0x91, 0x50, 0x91, 0x50, 0x91, 0x10, 0x91, 0x10, 0x91, 0x10, 0xff, 0x00, 0x00 },
{ 0xea, 0xf7, 0x10, 0x40, 0x11, 0x80, 0x11, 0x1e, 0x7d, 0x52, 0x11, 0x52, 0x11, 0x52, 0x39, 0x52, 0x35, 0x52, 0x35, 0x52, 0x51, 0x52, 0x51, 0xd2, 0x12, 0x56, 0x10, 0x90, 0x10, 0x90, 0x11, 0x10, 0x00, 0x00 },
{ 0xea, 0xf8, 0x10, 0xf0, 0x10, 0x28, 0x10, 0x44, 0x7c, 0x82, 0x11, 0x7d, 0x10, 0x00, 0x39, 0xe5, 0x39, 0x25, 0x35, 0xaa, 0x55, 0x6a, 0x51, 0x34, 0x51, 0xaa, 0x11, 0x6a, 0x11, 0x25, 0x11, 0x65, 0x00, 0x00 },
{ 0xea, 0xf9, 0x10, 0x9c, 0x10, 0x84, 0x11, 0x02, 0x13, 0xfd, 0x7c, 0x50, 0x11, 0xfe, 0x39, 0x52, 0x35, 0x52, 0x35, 0x4e, 0x51, 0x82, 0x51, 0x02, 0x51, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xea, 0xfa, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x20, 0x43, 0xff, 0x22, 0x21, 0x12, 0x21, 0x02, 0x21, 0x02, 0x21, 0x13, 0xff, 0x12, 0x21, 0x22, 0x21, 0x22, 0x21, 0x42, 0x21, 0x43, 0xff, 0x00, 0x00 },
{ 0xea, 0xfb, 0x20, 0x40, 0x10, 0x40, 0x0b, 0xfe, 0x00, 0x80, 0x41, 0x00, 0x21, 0xfc, 0x13, 0x04, 0x05, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x21, 0xfc, 0x21, 0x04, 0x41, 0x04, 0x41, 0x04, 0x01, 0x18, 0x00, 0x00 },
{ 0xea, 0xfc, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x00, 0x20, 0x40, 0x44, 0x20, 0x9e, 0x13, 0xe2, 0x00, 0x00, 0x11, 0x24, 0x11, 0x24, 0x21, 0x24, 0x21, 0x25, 0x42, 0x25, 0x42, 0x25, 0x04, 0x23, 0x00, 0x00 },
{ 0xea, 0xfd, 0x22, 0x08, 0x12, 0x08, 0x02, 0x10, 0x0f, 0xdf, 0x42, 0x20, 0x22, 0x00, 0x12, 0x1e, 0x03, 0xc2, 0x02, 0x44, 0x12, 0x44, 0x14, 0x5f, 0x24, 0x44, 0x24, 0x44, 0x48, 0x44, 0x49, 0x8c, 0x00, 0x00 },
{ 0xea, 0xfe, 0x20, 0xc0, 0x13, 0x1f, 0x0a, 0x09, 0x42, 0x89, 0x22, 0x51, 0x13, 0xd1, 0x00, 0x26, 0x00, 0x00, 0x13, 0xfe, 0x12, 0x22, 0x22, 0x22, 0x23, 0xfe, 0x42, 0x22, 0x42, 0x22, 0x03, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xa1, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x20, 0x07, 0xff, 0x44, 0x21, 0x25, 0xad, 0x10, 0x00, 0x07, 0xff, 0x00, 0x20, 0x10, 0x40, 0x13, 0xff, 0x22, 0x49, 0x22, 0x49, 0x42, 0x49, 0x42, 0x4b, 0x00, 0x00 },
{ 0xeb, 0xa2, 0x48, 0xbc, 0x28, 0x84, 0x11, 0xfe, 0x11, 0x51, 0x2a, 0x50, 0x49, 0xfe, 0x0d, 0x52, 0x15, 0x52, 0x15, 0x5e, 0x25, 0x82, 0x25, 0x02, 0x45, 0xfe, 0x05, 0x02, 0x09, 0x02, 0x71, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xa3, 0x0e, 0x08, 0x22, 0x08, 0x3f, 0x0a, 0x55, 0x89, 0x14, 0x7f, 0x7f, 0x08, 0x55, 0x08, 0x55, 0x08, 0x57, 0x14, 0x61, 0x14, 0x41, 0x14, 0x7f, 0x24, 0x41, 0x22, 0x41, 0x42, 0x7f, 0x81, 0x00, 0x00 },
{ 0xeb, 0xa4, 0x00, 0x20, 0x7c, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x44, 0x7c, 0x9e, 0x13, 0xe2, 0x10, 0x00, 0x11, 0x24, 0x11, 0x24, 0x1d, 0x24, 0x71, 0x25, 0x02, 0x25, 0x02, 0x25, 0x04, 0x23, 0x00, 0x00 },
{ 0xeb, 0xa5, 0x01, 0xf0, 0x00, 0x28, 0x7c, 0x44, 0x10, 0x82, 0x13, 0x7d, 0x10, 0x00, 0x7b, 0xc9, 0x12, 0x49, 0x13, 0x52, 0x12, 0xd2, 0x12, 0x64, 0x1b, 0x52, 0x72, 0xd2, 0x02, 0x49, 0x02, 0xc9, 0x00, 0x00 },
{ 0xeb, 0xa6, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xa7, 0x03, 0x00, 0x1c, 0x7e, 0x10, 0x12, 0x12, 0x12, 0x11, 0x22, 0x17, 0x22, 0x19, 0x4c, 0x30, 0x00, 0x0f, 0xfc, 0x08, 0x84, 0x08, 0x84, 0x0f, 0xfc, 0x08, 0x84, 0x08, 0x84, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xeb, 0xa8, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x60, 0x51, 0x98, 0x3e, 0x0f, 0x13, 0xc9, 0x12, 0x52, 0x33, 0x52, 0x52, 0xc9, 0x12, 0x49, 0x11, 0x40, 0x25, 0x22, 0x25, 0x09, 0x48, 0xf9, 0x00, 0x00 },
{ 0xeb, 0xa9, 0x00, 0x20, 0x7c, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x44, 0x20, 0x9e, 0x3d, 0xe2, 0x24, 0x00, 0x65, 0x24, 0x25, 0x24, 0x25, 0x24, 0x25, 0x25, 0x3d, 0x25, 0x22, 0x25, 0x02, 0x23, 0x00, 0x00 },
{ 0xeb, 0xaa, 0x10, 0x00, 0x15, 0xfc, 0x24, 0x44, 0x48, 0x44, 0x28, 0x44, 0x10, 0x44, 0x24, 0x44, 0x7d, 0xff, 0x10, 0x44, 0x54, 0x44, 0x54, 0x44, 0x54, 0x44, 0x54, 0x44, 0x10, 0x44, 0x13, 0xff, 0x00, 0x00 },
{ 0xeb, 0xab, 0x10, 0x44, 0x10, 0x44, 0x24, 0x88, 0x44, 0xff, 0x29, 0x88, 0x12, 0x88, 0x10, 0x88, 0x24, 0xfe, 0x7c, 0x88, 0x10, 0x88, 0x54, 0xfe, 0x54, 0x88, 0x50, 0x88, 0x10, 0x88, 0x10, 0xff, 0x00, 0x00 },
{ 0xeb, 0xac, 0x00, 0x80, 0x0c, 0x80, 0x30, 0xbe, 0x20, 0x82, 0x20, 0x82, 0x3c, 0xbe, 0x20, 0x82, 0x20, 0x82, 0x3c, 0xbe, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xeb, 0xad, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x80, 0x02, 0x80, 0x1c, 0xbc, 0x10, 0x84, 0x1e, 0xbc, 0x10, 0x84, 0x10, 0x84, 0x1e, 0xbc, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xeb, 0xae, 0x10, 0x44, 0x10, 0x42, 0x10, 0x81, 0x7d, 0x11, 0x04, 0x28, 0x08, 0x44, 0x08, 0x82, 0x11, 0x01, 0x34, 0x00, 0x58, 0xfe, 0x14, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xaf, 0x00, 0x0e, 0x3c, 0xf0, 0x00, 0x10, 0x7d, 0xff, 0x00, 0x38, 0x3c, 0x54, 0x01, 0x93, 0x3c, 0x00, 0x00, 0xfc, 0x00, 0x24, 0x3c, 0x2f, 0x24, 0x49, 0x24, 0x41, 0x24, 0x81, 0x3d, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xb0, 0x00, 0x10, 0x3c, 0x50, 0x01, 0x97, 0x7d, 0x11, 0x01, 0x11, 0x3d, 0xd7, 0x01, 0x11, 0x3d, 0x11, 0x01, 0xff, 0x00, 0x10, 0x3c, 0x28, 0x24, 0x28, 0x24, 0x44, 0x24, 0x82, 0x3d, 0x01, 0x00, 0x00 },
{ 0xeb, 0xb1, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x28, 0x7e, 0x44, 0x00, 0x82, 0x3d, 0x7d, 0x00, 0x00, 0x3c, 0xf5, 0x00, 0x95, 0x00, 0xd5, 0x3c, 0xba, 0x24, 0xda, 0x24, 0xb5, 0x24, 0x95, 0x3c, 0xb5, 0x00, 0x00 },
{ 0xeb, 0xb2, 0x00, 0x00, 0x3e, 0x70, 0x22, 0x18, 0x22, 0x24, 0x22, 0xc3, 0x3e, 0x3c, 0x08, 0x00, 0x08, 0xf5, 0x08, 0x95, 0x2e, 0xd5, 0x28, 0xba, 0x28, 0xda, 0x28, 0xb5, 0x2e, 0x95, 0x70, 0xb5, 0x00, 0x00 },
{ 0xeb, 0xb3, 0x00, 0x00, 0x3e, 0xfe, 0x22, 0x24, 0x22, 0x18, 0x22, 0xff, 0x3e, 0x31, 0x08, 0x52, 0x08, 0x90, 0x28, 0x30, 0x2e, 0x10, 0x29, 0xfe, 0x28, 0x38, 0x28, 0x54, 0x2e, 0x92, 0x71, 0x11, 0x00, 0x00 },
{ 0xeb, 0xb4, 0x21, 0x08, 0x11, 0x08, 0x01, 0x10, 0x07, 0xdf, 0x21, 0x20, 0x11, 0x1f, 0x01, 0xc2, 0x01, 0x44, 0x71, 0x5f, 0x12, 0x44, 0x12, 0x44, 0x14, 0x44, 0x10, 0xcc, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xeb, 0xb5, 0x20, 0x00, 0x11, 0xf0, 0x00, 0x48, 0x41, 0x84, 0x26, 0x7b, 0x00, 0x00, 0x03, 0xca, 0x02, 0x4a, 0x73, 0x54, 0x12, 0x54, 0x13, 0x4a, 0x12, 0x4a, 0x12, 0xca, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xeb, 0xb6, 0x20, 0x20, 0x11, 0xfe, 0x09, 0x22, 0x01, 0xfe, 0x40, 0x20, 0x23, 0xff, 0x11, 0x02, 0x01, 0xfe, 0x01, 0x02, 0x71, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x84, 0x2d, 0x02, 0x43, 0xff, 0x00, 0x00 },
{ 0xeb, 0xb7, 0x00, 0x00, 0x7f, 0xfe, 0x02, 0x40, 0x02, 0x40, 0x3f, 0xfc, 0x22, 0x44, 0x22, 0x44, 0x24, 0x44, 0x24, 0x3c, 0x28, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xeb, 0xb8, 0x07, 0x08, 0x78, 0x08, 0x09, 0x08, 0x49, 0x08, 0x2a, 0x7f, 0x08, 0x49, 0x7f, 0x49, 0x08, 0x49, 0x1c, 0x49, 0x1a, 0x7f, 0x29, 0x49, 0x28, 0x49, 0x48, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x00, 0x00 },
{ 0xeb, 0xb9, 0x18, 0xf0, 0x24, 0x28, 0x40, 0x44, 0x01, 0x83, 0x7c, 0x7c, 0x10, 0x00, 0x11, 0xea, 0x7d, 0x2a, 0x11, 0xaa, 0x11, 0x74, 0x55, 0x34, 0x35, 0xaa, 0x11, 0x6a, 0x19, 0x2a, 0x61, 0x6a, 0x00, 0x00 },
{ 0xeb, 0xba, 0x08, 0x00, 0x4a, 0xff, 0x2a, 0x08, 0x2c, 0x10, 0x7f, 0x7e, 0x1c, 0x42, 0x2a, 0x7e, 0x4a, 0x42, 0x02, 0x7e, 0x09, 0x42, 0x7f, 0x42, 0x08, 0x7e, 0x0c, 0x00, 0x12, 0x26, 0x62, 0xc1, 0x00, 0x00 },
{ 0xeb, 0xbb, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0x10, 0x08, 0x08, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00 },
{ 0xeb, 0xbc, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x88, 0x7d, 0x1c, 0x13, 0xe2, 0x12, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x1d, 0xfc, 0x71, 0x04, 0x01, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x01, 0x18, 0x00, 0x00 },
{ 0xeb, 0xbd, 0x00, 0x10, 0x7b, 0x90, 0x19, 0x92, 0x6e, 0x91, 0x09, 0xff, 0x1e, 0x90, 0x68, 0x90, 0x14, 0x11, 0x62, 0x12, 0x19, 0x94, 0x62, 0x0c, 0x0c, 0x89, 0x71, 0x15, 0x06, 0x26, 0x78, 0x42, 0x00, 0x00 },
{ 0xeb, 0xbe, 0x10, 0x10, 0x10, 0x10, 0x3e, 0xff, 0x40, 0x20, 0x3e, 0x24, 0x22, 0x4e, 0x2a, 0xf1, 0x22, 0x00, 0x7f, 0x54, 0x22, 0x54, 0x2a, 0x54, 0x22, 0x54, 0x7f, 0x55, 0x42, 0x95, 0x0c, 0x87, 0x00, 0x00 },
{ 0xeb, 0xbf, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x41, 0x02, 0x42, 0xc2, 0x44, 0x22, 0x58, 0x12, 0x41, 0x02, 0x41, 0x02, 0x42, 0xc2, 0x44, 0x22, 0x58, 0x12, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x08, 0x04, 0x3c, 0x3f, 0xc2, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xeb, 0xc1, 0x00, 0x20, 0x3c, 0x20, 0x25, 0xfc, 0x24, 0x20, 0x28, 0x20, 0x2b, 0xff, 0x28, 0x50, 0x24, 0x91, 0x25, 0x31, 0x26, 0x2f, 0x24, 0x20, 0x39, 0xfc, 0x20, 0x20, 0x20, 0x20, 0x23, 0xff, 0x00, 0x00 },
{ 0xeb, 0xc2, 0x08, 0x60, 0x08, 0x50, 0x08, 0x90, 0x11, 0x08, 0x12, 0xf4, 0x34, 0x03, 0x30, 0x00, 0x53, 0xfc, 0x12, 0xa4, 0x12, 0xa4, 0x13, 0xfc, 0x12, 0xa4, 0x12, 0xa4, 0x12, 0xa4, 0x12, 0x0c, 0x00, 0x00 },
{ 0xeb, 0xc3, 0x01, 0x00, 0x01, 0x00, 0x02, 0x10, 0x02, 0x08, 0x04, 0x04, 0x08, 0xfa, 0x7f, 0x21, 0x02, 0x21, 0x02, 0x20, 0x02, 0x20, 0x04, 0x20, 0x04, 0x21, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xeb, 0xc4, 0x01, 0x00, 0x7f, 0xfe, 0x02, 0x40, 0x04, 0x20, 0x18, 0x18, 0x60, 0x07, 0x22, 0xaa, 0x12, 0xaa, 0x43, 0xae, 0x22, 0x22, 0x03, 0xfe, 0x22, 0x22, 0x27, 0xae, 0x44, 0xaa, 0x48, 0xaa, 0x00, 0x00 },
{ 0xeb, 0xc5, 0x00, 0x00, 0x1f, 0xf8, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x7f, 0xff, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x1f, 0xf8, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00 },
{ 0xeb, 0xc6, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x1b, 0xec, 0x60, 0x03, 0x1f, 0xf8, 0x12, 0x48, 0x1f, 0xf8, 0x12, 0x48, 0x12, 0x48, 0x10, 0x18, 0x00, 0x00 },
{ 0xeb, 0xc7, 0x20, 0x40, 0x10, 0xa0, 0x00, 0x90, 0x41, 0x08, 0x23, 0xfc, 0x04, 0x03, 0x08, 0x00, 0x03, 0xfc, 0x12, 0xa4, 0x12, 0xa4, 0x23, 0xfc, 0x22, 0xa4, 0x42, 0xa4, 0x42, 0xa4, 0x02, 0x0c, 0x00, 0x00 },
{ 0xeb, 0xc8, 0x20, 0x00, 0x17, 0x9f, 0x0c, 0x91, 0x07, 0x9f, 0x44, 0x91, 0x27, 0x9f, 0x14, 0x01, 0x04, 0x01, 0x05, 0xfd, 0x14, 0x21, 0x14, 0xf9, 0x24, 0x21, 0x25, 0xfd, 0x44, 0x01, 0x44, 0x07, 0x00, 0x00 },
{ 0xeb, 0xc9, 0x00, 0x20, 0x7c, 0x20, 0x10, 0x48, 0x10, 0x84, 0x11, 0x3a, 0x7f, 0xd2, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x1c, 0x90, 0x71, 0x12, 0x01, 0x12, 0x02, 0x12, 0x04, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xca, 0x10, 0x84, 0x14, 0xa4, 0x13, 0x24, 0x11, 0x44, 0x10, 0x84, 0x11, 0x24, 0x17, 0xd4, 0x10, 0x04, 0x13, 0xe4, 0x12, 0x24, 0x13, 0xe4, 0x12, 0x24, 0x23, 0xe5, 0x22, 0x25, 0x42, 0x67, 0x00, 0x00 },
{ 0xeb, 0xcb, 0x10, 0xea, 0x10, 0x08, 0x7e, 0xff, 0x04, 0x24, 0x28, 0xb4, 0x18, 0xa5, 0x6f, 0xfb, 0x08, 0x09, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xcc, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x28, 0x10, 0x44, 0x7d, 0x83, 0x54, 0x7c, 0x7c, 0x00, 0x54, 0xfe, 0x7c, 0xaa, 0x10, 0xaa, 0x7c, 0xfe, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0xaa, 0x10, 0x86, 0x00, 0x00 },
{ 0xeb, 0xcd, 0x18, 0x20, 0x14, 0x20, 0x24, 0x44, 0x20, 0x42, 0x7c, 0x9d, 0x13, 0xe9, 0x10, 0x48, 0x7c, 0x48, 0x10, 0x48, 0x54, 0x48, 0x54, 0x4a, 0x54, 0x8a, 0x50, 0x8a, 0x1d, 0x0a, 0x62, 0x06, 0x00, 0x00 },
{ 0xeb, 0xce, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x40, 0x02, 0x4f, 0xe2, 0x41, 0x02, 0x4f, 0xe2, 0x41, 0x02, 0x41, 0x02, 0x5f, 0xf2, 0x40, 0x02, 0x40, 0x1e, 0x00, 0x00 },
{ 0xeb, 0xcf, 0x08, 0x20, 0x10, 0x20, 0x21, 0xfe, 0x44, 0x22, 0x0b, 0xff, 0x10, 0x22, 0x11, 0xfe, 0x30, 0x20, 0x51, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xeb, 0xd0, 0x10, 0x00, 0x13, 0xff, 0x10, 0x48, 0x19, 0xfe, 0x55, 0x4a, 0x55, 0x4a, 0x51, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x10, 0x20, 0x00, 0x00 },
{ 0xeb, 0xd1, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xeb, 0xd2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x22, 0x04, 0x14, 0x48, 0x02, 0x80, 0x19, 0x58, 0x62, 0x46, 0x07, 0xa0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xeb, 0xd3, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xeb, 0xd4, 0x00, 0x24, 0x00, 0x22, 0x7f, 0xff, 0x00, 0x20, 0x04, 0x20, 0x04, 0x22, 0x04, 0x22, 0x07, 0xa4, 0x7c, 0x14, 0x04, 0x18, 0x08, 0x10, 0x08, 0x29, 0x10, 0xc5, 0x03, 0x03, 0x1c, 0x01, 0x00, 0x00 },
{ 0xeb, 0xd5, 0x00, 0x04, 0x27, 0xe4, 0x10, 0x04, 0x03, 0xc4, 0x02, 0x5f, 0x42, 0x55, 0x23, 0xd5, 0x00, 0x15, 0x17, 0xff, 0x15, 0xa4, 0x25, 0xe4, 0x26, 0x26, 0x45, 0xe7, 0x44, 0xbd, 0x04, 0x20, 0x00, 0x00 },
{ 0xeb, 0xd6, 0x10, 0x12, 0x10, 0x11, 0x24, 0x10, 0x45, 0xff, 0x28, 0x10, 0x10, 0x90, 0x10, 0x92, 0x24, 0xd2, 0x7f, 0x94, 0x10, 0x94, 0x54, 0x88, 0x54, 0x88, 0x51, 0x15, 0x11, 0x23, 0x10, 0x41, 0x00, 0x00 },
{ 0xeb, 0xd7, 0x00, 0x08, 0x7f, 0x88, 0x00, 0x08, 0x3f, 0x3e, 0x21, 0x2a, 0x21, 0x2a, 0x3f, 0x2a, 0x00, 0x2a, 0x7f, 0xaa, 0x54, 0xbe, 0x57, 0x88, 0x60, 0x8a, 0x5e, 0x8a, 0x48, 0x8f, 0x43, 0xb9, 0x00, 0x00 },
{ 0xeb, 0xd8, 0x00, 0x40, 0x3c, 0x7e, 0x24, 0xc4, 0x25, 0x28, 0x28, 0x10, 0x28, 0x28, 0x28, 0xc6, 0x24, 0x90, 0x24, 0x90, 0x25, 0xfe, 0x26, 0x10, 0x39, 0xfe, 0x20, 0x10, 0x20, 0x10, 0x23, 0xff, 0x00, 0x00 },
{ 0xeb, 0xd9, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x7d, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x20, 0x11, 0x21, 0x11, 0x12, 0x1d, 0x14, 0x71, 0x08, 0x01, 0x34, 0x01, 0xc2, 0x07, 0x01, 0x00, 0x00 },
{ 0xeb, 0xda, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x17, 0xf4, 0x10, 0x84, 0x11, 0x44, 0x16, 0x34, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x04, 0x80, 0x24, 0x44, 0x24, 0x02, 0x44, 0x12, 0x03, 0xf0, 0x00, 0x00 },
{ 0xeb, 0xdb, 0x06, 0x00, 0x38, 0x78, 0x20, 0x48, 0x3e, 0x49, 0x22, 0x8f, 0x3e, 0x00, 0x22, 0xfc, 0x3e, 0x44, 0x22, 0x28, 0x42, 0x38, 0x4c, 0xc7, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xeb, 0xdc, 0x06, 0x00, 0x38, 0x78, 0x20, 0x48, 0x3e, 0x49, 0x22, 0x49, 0x3e, 0x87, 0x23, 0x00, 0x3e, 0x00, 0x21, 0xfc, 0x20, 0x44, 0x3e, 0x44, 0x22, 0x28, 0x22, 0x10, 0x42, 0x6c, 0x4d, 0x83, 0x00, 0x00 },
{ 0xeb, 0xdd, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x23, 0xe2, 0x20, 0x02, 0x2f, 0xfa, 0x20, 0x02, 0x27, 0xf2, 0x20, 0x02, 0x27, 0xf2, 0x24, 0x12, 0x27, 0xf6, 0x00, 0x00 },
{ 0xeb, 0xde, 0x08, 0x00, 0x14, 0x7e, 0x22, 0x42, 0x40, 0x42, 0x3e, 0x7e, 0x08, 0x42, 0x08, 0x42, 0x7e, 0x7e, 0x08, 0x48, 0x4a, 0x49, 0x2a, 0x4a, 0x28, 0x44, 0x08, 0x44, 0x0e, 0x7a, 0x71, 0xc1, 0x00, 0x00 },
{ 0xeb, 0xdf, 0x78, 0x0e, 0x49, 0xf0, 0x49, 0x12, 0x52, 0xfd, 0x50, 0x20, 0x63, 0xfe, 0x50, 0x00, 0x51, 0xfc, 0x48, 0x04, 0x4b, 0xff, 0x48, 0x04, 0x71, 0xfc, 0x42, 0xa2, 0x42, 0x85, 0x44, 0xfc, 0x00, 0x00 },
{ 0xeb, 0xe0, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x10, 0x00, 0x20, 0x00, 0xc0, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x02, 0x20, 0x02, 0x10, 0x02, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xeb, 0xe1, 0x00, 0x30, 0x00, 0x48, 0x78, 0x84, 0x49, 0x02, 0x4a, 0x01, 0x48, 0xfc, 0x48, 0x00, 0x48, 0x00, 0x49, 0xfe, 0x48, 0x02, 0x78, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00 },
{ 0xeb, 0xe2, 0x20, 0x1e, 0x11, 0xe0, 0x09, 0x04, 0x02, 0x42, 0x44, 0x22, 0x20, 0x20, 0x10, 0x0e, 0x03, 0xf0, 0x00, 0x20, 0x10, 0x20, 0x17, 0xff, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x43, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xe3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3c, 0x28, 0x24, 0x44, 0x25, 0xbb, 0x28, 0x00, 0x28, 0x7c, 0x24, 0x04, 0x24, 0xfe, 0x24, 0x00, 0x39, 0xff, 0x20, 0x24, 0x20, 0x4e, 0x21, 0xf1, 0x00, 0x00 },
{ 0xeb, 0xe4, 0x00, 0x10, 0x7c, 0x28, 0x44, 0x44, 0x48, 0x82, 0x49, 0x7d, 0x50, 0x00, 0x48, 0xfc, 0x48, 0x04, 0x44, 0x08, 0x44, 0xfe, 0x44, 0x00, 0x59, 0xff, 0x40, 0x22, 0x40, 0x4d, 0x41, 0xf1, 0x00, 0x00 },
{ 0xeb, 0xe5, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xeb, 0xe6, 0x08, 0x20, 0x14, 0x20, 0x22, 0x20, 0x5d, 0x7f, 0x00, 0x51, 0x3e, 0x52, 0x22, 0x92, 0x3e, 0x10, 0x22, 0x28, 0x3e, 0x28, 0x20, 0x28, 0x3e, 0x44, 0x20, 0x44, 0x3e, 0x82, 0x21, 0x01, 0x00, 0x00 },
{ 0xeb, 0xe7, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x11, 0xff, 0x1c, 0x82, 0x70, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x9f, 0x13, 0xe2, 0x30, 0x02, 0x00, 0x00 },
{ 0xeb, 0xe8, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xfe, 0x40, 0x00, 0x20, 0x04, 0x11, 0x04, 0x01, 0x04, 0x01, 0x04, 0x10, 0x88, 0x10, 0x88, 0x20, 0x88, 0x20, 0x10, 0x40, 0x10, 0x47, 0xff, 0x00, 0x00 },
{ 0xeb, 0xe9, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0x08, 0x3f, 0xf8, 0x00, 0x00, 0x7f, 0xfc, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0xfc, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xeb, 0xea, 0x04, 0x00, 0x44, 0xbe, 0x27, 0x02, 0x04, 0x14, 0x04, 0x48, 0x03, 0xbf, 0x04, 0x09, 0x17, 0xca, 0x19, 0x28, 0x21, 0x2f, 0x2f, 0xe8, 0x41, 0x28, 0x02, 0xa8, 0x04, 0x58, 0x18, 0x87, 0x00, 0x00 },
{ 0xeb, 0xeb, 0x00, 0x40, 0x3f, 0xff, 0x22, 0x24, 0x22, 0x48, 0x24, 0xfe, 0x2d, 0x90, 0x34, 0xfc, 0x24, 0x90, 0x24, 0xfc, 0x24, 0x90, 0x24, 0xfe, 0x20, 0x40, 0x4a, 0x22, 0x4a, 0x09, 0x11, 0xf9, 0x00, 0x00 },
{ 0xeb, 0xec, 0x00, 0x80, 0x3f, 0xff, 0x24, 0x48, 0x28, 0x90, 0x39, 0xfe, 0x2a, 0x90, 0x28, 0xfe, 0x28, 0x90, 0x27, 0xfe, 0x24, 0x04, 0x27, 0xfc, 0x44, 0x04, 0x47, 0xfc, 0x44, 0x04, 0x04, 0x1c, 0x00, 0x00 },
{ 0xeb, 0xed, 0x00, 0x80, 0x3f, 0xff, 0x24, 0x90, 0x29, 0xfe, 0x2a, 0x90, 0x38, 0xfe, 0x28, 0x90, 0x2a, 0xff, 0x27, 0xf8, 0x24, 0x08, 0x27, 0xf8, 0x24, 0x08, 0x47, 0xff, 0x4a, 0xa1, 0x52, 0x56, 0x00, 0x00 },
{ 0xeb, 0xee, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x17, 0xff, 0x10, 0x40, 0x30, 0x40, 0x30, 0xa2, 0x50, 0xa4, 0x51, 0x18, 0x13, 0x10, 0x15, 0x08, 0x11, 0x08, 0x11, 0x34, 0x11, 0xc2, 0x17, 0x01, 0x00, 0x00 },
{ 0xeb, 0xef, 0x08, 0x20, 0x08, 0x20, 0x13, 0xfe, 0x10, 0x50, 0x30, 0x88, 0x33, 0x06, 0x50, 0x00, 0x57, 0xff, 0x10, 0x02, 0x11, 0xf2, 0x11, 0x12, 0x11, 0x12, 0x11, 0xf2, 0x10, 0x02, 0x10, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xf0, 0x08, 0x88, 0x0b, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x30, 0x20, 0x37, 0xff, 0x50, 0x00, 0x13, 0xd4, 0x11, 0x12, 0x17, 0xff, 0x11, 0x10, 0x11, 0xca, 0x17, 0x0c, 0x11, 0x15, 0x13, 0x63, 0x00, 0x00 },
{ 0xeb, 0xf1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x47, 0xf1, 0x04, 0x10, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00 },
{ 0xeb, 0xf2, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xeb, 0xf3, 0x10, 0x10, 0x7e, 0x10, 0x11, 0xbf, 0x3c, 0x2a, 0x00, 0x08, 0x7e, 0x54, 0x42, 0x94, 0x3d, 0x22, 0x00, 0x41, 0x7c, 0x10, 0x44, 0x08, 0x7c, 0x20, 0x28, 0xa2, 0x2e, 0xa9, 0x71, 0x39, 0x00, 0x00 },
{ 0xeb, 0xf4, 0x12, 0x00, 0x12, 0x5f, 0x13, 0x81, 0x7a, 0x0a, 0x12, 0x44, 0x13, 0xc4, 0x12, 0x1f, 0x1b, 0xc5, 0x75, 0x06, 0x11, 0x14, 0x17, 0xd7, 0x11, 0x14, 0x12, 0x94, 0x12, 0xac, 0x34, 0x43, 0x00, 0x00 },
{ 0xeb, 0xf5, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x28, 0x10, 0x44, 0x11, 0x83, 0x38, 0x00, 0x39, 0xff, 0x34, 0x02, 0x54, 0xf2, 0x50, 0x92, 0x50, 0x92, 0x10, 0xf2, 0x10, 0x02, 0x10, 0x0e, 0x00, 0x00 },
{ 0xeb, 0xf6, 0x08, 0x00, 0x08, 0x3c, 0x7f, 0x24, 0x22, 0x24, 0x14, 0x25, 0x7f, 0x47, 0x10, 0x00, 0x69, 0x7e, 0x0e, 0x22, 0x14, 0x22, 0x66, 0x14, 0x0b, 0x08, 0x12, 0x94, 0x62, 0x22, 0x0c, 0xc1, 0x00, 0x00 },
{ 0xeb, 0xf7, 0x20, 0x00, 0x26, 0x7e, 0x38, 0x02, 0x20, 0x24, 0x22, 0x18, 0x1e, 0x08, 0x00, 0xff, 0x20, 0x09, 0x3e, 0x4a, 0x48, 0x48, 0x08, 0x4e, 0x3e, 0x48, 0x08, 0xa8, 0x14, 0x98, 0x63, 0x07, 0x00, 0x00 },
{ 0xeb, 0xf8, 0x02, 0x00, 0x02, 0x10, 0x04, 0x08, 0x04, 0x7c, 0x3f, 0x82, 0x08, 0x02, 0x08, 0x00, 0x1f, 0xfc, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xeb, 0xf9, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x3f, 0x28, 0x04, 0x24, 0x7f, 0xff, 0x04, 0x20, 0x07, 0x14, 0x7c, 0x09, 0x04, 0x35, 0x1c, 0xc3, 0x00, 0x00 },
{ 0xeb, 0xfa, 0x08, 0x44, 0x10, 0xfe, 0x3e, 0x10, 0x22, 0xfe, 0x2a, 0x10, 0x2b, 0xff, 0x22, 0x00, 0x26, 0xea, 0x7a, 0x49, 0x2b, 0xff, 0x2a, 0x4a, 0x2a, 0x64, 0x23, 0xc5, 0x42, 0x4b, 0x46, 0xd1, 0x00, 0x00 },
{ 0xeb, 0xfb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x3f, 0xfc, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x24, 0x82, 0x24, 0x49, 0x43, 0xf9, 0x00, 0x00 },
{ 0xeb, 0xfc, 0x10, 0x44, 0x11, 0xff, 0x10, 0x10, 0x7c, 0xfe, 0x54, 0x10, 0x55, 0xff, 0x54, 0x00, 0x54, 0xea, 0x54, 0x49, 0x7d, 0xff, 0x10, 0x48, 0x14, 0x6a, 0x15, 0xc4, 0x1a, 0x4d, 0x62, 0xd3, 0x00, 0x00 },
{ 0xeb, 0xfd, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x40, 0x02, 0x40, 0x04, 0x42, 0x0c, 0x24, 0x14, 0x28, 0x64, 0x10, 0x04, 0x10, 0x04, 0x08, 0x04, 0xc4, 0x07, 0x02, 0x38, 0x01, 0x00, 0x00 },
{ 0xeb, 0xfe, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xff, 0x7e, 0x81, 0x00, 0x81, 0x3c, 0x7e, 0x00, 0x42, 0x3c, 0x42, 0x00, 0x7e, 0x00, 0x42, 0x3c, 0x42, 0x24, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x3c, 0xff, 0x00, 0x00 },
{ 0xec, 0xa1, 0x00, 0x44, 0x3d, 0xff, 0x00, 0x10, 0x7e, 0xfe, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x00, 0x3c, 0xea, 0x00, 0x49, 0x01, 0xff, 0x3c, 0x48, 0x24, 0x6a, 0x25, 0xc4, 0x24, 0x4d, 0x3c, 0xd3, 0x00, 0x00 },
{ 0xec, 0xa2, 0x00, 0x00, 0x3f, 0xbc, 0x2a, 0x25, 0x2f, 0x47, 0x32, 0x7c, 0x2f, 0xa4, 0x25, 0x18, 0x28, 0xe6, 0x7f, 0xff, 0x02, 0x20, 0x1f, 0xfc, 0x12, 0x24, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xec, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
{ 0xec, 0xa4, 0x10, 0x04, 0x10, 0x04, 0x11, 0x04, 0x10, 0x84, 0x10, 0x44, 0x10, 0x44, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x88, 0x11, 0x08, 0x16, 0x18, 0x18, 0x24, 0x60, 0xc2, 0x03, 0x01, 0x00, 0x00 },
{ 0xec, 0xa5, 0x08, 0x00, 0x0b, 0xfc, 0x10, 0x44, 0x10, 0x44, 0x30, 0x44, 0x37, 0xff, 0x50, 0x44, 0x50, 0x44, 0x10, 0x44, 0x13, 0xfc, 0x10, 0x40, 0x10, 0x80, 0x10, 0x80, 0x11, 0x00, 0x12, 0x00, 0x00, 0x00 },
{ 0xec, 0xa6, 0x00, 0x02, 0x06, 0x02, 0x78, 0x22, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x22, 0x1c, 0x22, 0x1a, 0x22, 0x29, 0x22, 0x29, 0x22, 0x48, 0x22, 0x08, 0x02, 0x08, 0x02, 0x08, 0x1e, 0x00, 0x00 },
{ 0xec, 0xa7, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x04, 0x80, 0x03, 0x00, 0x01, 0x80, 0x06, 0x70, 0x78, 0x0f, 0x00, 0x00 },
{ 0xec, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x3f, 0xfc, 0x00, 0x84, 0x1f, 0xfc, 0x10, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x01, 0x42, 0x02, 0x2c, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xec, 0xa9, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7c, 0x20, 0x25, 0xfe, 0x24, 0x22, 0x25, 0xfe, 0x25, 0x20, 0x45, 0xff, 0x6a, 0x21, 0x58, 0x51, 0x08, 0x56, 0x14, 0x88, 0x21, 0x04, 0x42, 0x03, 0x00, 0x00 },
{ 0xec, 0xaa, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x3f, 0xfe, 0x22, 0x40, 0x24, 0x7e, 0x28, 0xc2, 0x32, 0x7e, 0x22, 0x42, 0x24, 0x7e, 0x2c, 0x20, 0x34, 0x7e, 0x25, 0xa4, 0x44, 0x18, 0x45, 0xe7, 0x00, 0x00 },
{ 0xec, 0xab, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x01, 0x20, 0x01, 0x20, 0x01, 0x1f, 0xff, 0x00, 0x00 },
{ 0xec, 0xac, 0x00, 0x10, 0x78, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x9e, 0x38, 0xf2, 0x23, 0x92, 0x20, 0x92, 0x78, 0x92, 0x48, 0x96, 0x08, 0x90, 0x08, 0x90, 0x08, 0x81, 0x08, 0x81, 0x30, 0x7f, 0x00, 0x00 },
{ 0xec, 0xad, 0x07, 0xf0, 0x00, 0x10, 0x1f, 0xfe, 0x00, 0x10, 0x07, 0xf0, 0x2a, 0x28, 0x08, 0x44, 0x7e, 0xbe, 0x1c, 0x15, 0x2a, 0x24, 0x4a, 0xcc, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xec, 0xae, 0x10, 0x20, 0x10, 0x20, 0x18, 0x20, 0x54, 0x44, 0x54, 0x42, 0x50, 0x9e, 0x51, 0xe1, 0x10, 0x01, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xec, 0xaf, 0x0f, 0xf0, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x11, 0x24, 0x62, 0x24, 0x04, 0x44, 0x08, 0x84, 0x31, 0x08, 0x06, 0x30, 0x00, 0x00 },
{ 0xec, 0xb0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x07, 0x0f, 0xf0, 0x00, 0x60, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xec, 0xb1, 0x03, 0x02, 0x3c, 0x22, 0x04, 0x22, 0x7f, 0xa2, 0x0e, 0x22, 0x15, 0x02, 0x25, 0x0e, 0x44, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xec, 0xb2, 0x00, 0x00, 0x23, 0xfe, 0x12, 0x02, 0x02, 0x02, 0x42, 0x02, 0x23, 0xfe, 0x02, 0x00, 0x02, 0x40, 0x12, 0x42, 0x12, 0x4c, 0x22, 0x70, 0x22, 0x40, 0x44, 0x42, 0x44, 0x42, 0x08, 0x3e, 0x00, 0x00 },
{ 0xec, 0xb3, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x88, 0x10, 0x84, 0x7f, 0xff, 0x20, 0x82, 0x2a, 0xaa, 0x24, 0x92, 0x2a, 0xaa, 0x20, 0x82, 0x2a, 0xaa, 0x24, 0x92, 0x2a, 0xaa, 0x20, 0x82, 0x20, 0x86, 0x00, 0x00 },
{ 0xec, 0xb4, 0x00, 0x00, 0x03, 0xff, 0x7c, 0x84, 0x10, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x7c, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1c, 0xbc, 0x73, 0xc4, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00 },
{ 0xec, 0xb5, 0x00, 0x00, 0x7d, 0xfc, 0x11, 0x24, 0x11, 0x24, 0x11, 0xfc, 0x7d, 0x24, 0x11, 0x24, 0x11, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x1d, 0xfc, 0x70, 0x20, 0x00, 0x20, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xec, 0xb6, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x06, 0x00, 0x00 },
{ 0xec, 0xb7, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x57, 0xff, 0x30, 0x20, 0x13, 0xfe, 0x10, 0x22, 0x33, 0xfe, 0x52, 0x20, 0x17, 0xff, 0x14, 0x61, 0x20, 0x92, 0x23, 0x0c, 0x4c, 0x03, 0x00, 0x00 },
{ 0xec, 0xb8, 0x00, 0x40, 0x00, 0x40, 0x0f, 0xff, 0x48, 0x00, 0x28, 0xc1, 0x2b, 0x89, 0x08, 0x89, 0x1f, 0xe9, 0x29, 0x89, 0x49, 0xc9, 0x12, 0xa9, 0x12, 0xa9, 0x24, 0x81, 0x20, 0x81, 0x40, 0x87, 0x00, 0x00 },
{ 0xec, 0xb9, 0x0c, 0x40, 0x70, 0x7e, 0x10, 0x82, 0x11, 0x44, 0x7c, 0x28, 0x10, 0x10, 0x18, 0x60, 0x39, 0xa0, 0x34, 0x3f, 0x54, 0x41, 0x51, 0xa2, 0x50, 0x14, 0x10, 0x08, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xec, 0xba, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x88, 0x10, 0x90, 0x11, 0xfe, 0x59, 0x90, 0x56, 0xfc, 0x50, 0x90, 0x10, 0xfc, 0x10, 0x90, 0x10, 0x90, 0x10, 0xfe, 0x00, 0x00 },
{ 0xec, 0xbb, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x02, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x2e, 0x00, 0x00 },
{ 0xec, 0xbc, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0x09, 0xf0, 0x7e, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xec, 0xbd, 0x20, 0x10, 0x26, 0x10, 0x38, 0x7e, 0x20, 0x12, 0x22, 0xff, 0x1e, 0x12, 0x00, 0x12, 0x20, 0x7e, 0x3e, 0x10, 0x48, 0x7e, 0x7f, 0x10, 0x08, 0x10, 0x14, 0xff, 0x22, 0x10, 0x42, 0x10, 0x00, 0x00 },
{ 0xec, 0xbe, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x04, 0x20, 0x10, 0x04, 0x11, 0x04, 0x10, 0x84, 0x10, 0x44, 0x10, 0x08, 0x10, 0x08, 0x11, 0x94, 0x1e, 0x22, 0x70, 0x41, 0x01, 0x81, 0x00, 0x00 },
{ 0xec, 0xbf, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x1f, 0xfc, 0x10, 0x80, 0x3f, 0xff, 0x20, 0x81, 0x01, 0x46, 0x06, 0x30, 0x38, 0x0e, 0x00, 0x00 },
{ 0xec, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x44, 0x7c, 0x28, 0x05, 0x98, 0x1e, 0x07, 0x00, 0x00 },
{ 0xec, 0xc1, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x92, 0x7e, 0x92, 0x04, 0xfe, 0x08, 0x92, 0x0a, 0x92, 0x1c, 0xfe, 0x32, 0x10, 0x52, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xec, 0xc2, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0x24, 0x3e, 0x22, 0x22, 0x4e, 0x22, 0xf1, 0x3e, 0x01, 0x22, 0x00, 0x22, 0x7e, 0x22, 0x42, 0x3e, 0x42, 0x00, 0x42, 0x24, 0x42, 0x42, 0x7e, 0x00, 0x00 },
{ 0xec, 0xc3, 0x00, 0x14, 0x00, 0x12, 0x7f, 0xff, 0x00, 0x10, 0x3f, 0x90, 0x00, 0x10, 0x7f, 0xd0, 0x20, 0x90, 0x3f, 0x88, 0x20, 0x88, 0x3f, 0x88, 0x20, 0x85, 0x3f, 0x85, 0x11, 0x03, 0x60, 0xc1, 0x00, 0x00 },
{ 0xec, 0xc4, 0x20, 0x00, 0x17, 0xff, 0x01, 0x24, 0x42, 0x22, 0x27, 0xff, 0x02, 0x22, 0x03, 0x76, 0x02, 0xaa, 0x73, 0x76, 0x12, 0xaa, 0x13, 0x76, 0x12, 0x22, 0x12, 0x22, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xec, 0xc5, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xec, 0xc6, 0x08, 0x24, 0x08, 0x24, 0x7f, 0x24, 0x00, 0x7f, 0x55, 0x48, 0x49, 0xc8, 0x55, 0x7e, 0x7f, 0x48, 0x08, 0x48, 0x7f, 0x48, 0x49, 0x7e, 0x55, 0x48, 0x5d, 0x48, 0x41, 0x48, 0x47, 0x7f, 0x00, 0x00 },
{ 0xec, 0xc7, 0x08, 0x10, 0x14, 0x10, 0x22, 0x20, 0x5d, 0x24, 0x00, 0x42, 0x3e, 0x4d, 0x22, 0xf1, 0x3e, 0x00, 0x22, 0x00, 0x3e, 0x7e, 0x20, 0x42, 0x3e, 0x42, 0x20, 0x42, 0x3e, 0x42, 0x20, 0x7e, 0x00, 0x00 },
{ 0xec, 0xc8, 0x08, 0x00, 0x14, 0x00, 0x22, 0xff, 0x5d, 0x44, 0x00, 0x44, 0x3e, 0x7c, 0x22, 0x44, 0x3e, 0x44, 0x22, 0x7c, 0x3e, 0x44, 0x20, 0x44, 0x3e, 0x4f, 0x20, 0xf4, 0x3e, 0x04, 0x20, 0x04, 0x00, 0x00 },
{ 0xec, 0xc9, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x20, 0x3f, 0xfe, 0x22, 0xa0, 0x20, 0x80, 0x3f, 0xfe, 0x21, 0x00, 0x23, 0xf0, 0x2e, 0x10, 0x22, 0x10, 0x22, 0x10, 0x23, 0xf0, 0x20, 0x00, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xec, 0xca, 0x20, 0x00, 0x17, 0xdf, 0x00, 0x41, 0x40, 0x41, 0x27, 0xdf, 0x04, 0x10, 0x04, 0x10, 0x07, 0xdf, 0x10, 0xc3, 0x11, 0x45, 0x26, 0x59, 0x20, 0xc3, 0x41, 0x45, 0x46, 0x59, 0x01, 0x86, 0x00, 0x00 },
{ 0xec, 0xcb, 0x23, 0xde, 0x11, 0x4a, 0x0a, 0xd6, 0x41, 0x4a, 0x23, 0xfe, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x13, 0xfe, 0x10, 0x88, 0x23, 0xfe, 0x20, 0x88, 0x47, 0xff, 0x41, 0x8c, 0x02, 0x02, 0x00, 0x00 },
{ 0xec, 0xcc, 0x05, 0xf0, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x27, 0xf2, 0x40, 0x01, 0x05, 0xf0, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x6f, 0xfb, 0x09, 0x48, 0x09, 0x48, 0x09, 0x48, 0x7f, 0xff, 0x00, 0x00 },
{ 0xec, 0xcd, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x22, 0x7c, 0x66, 0x00, 0x66, 0x04, 0xaa, 0x45, 0x32, 0x44, 0x22, 0x24, 0x66, 0x28, 0x66, 0x28, 0xaa, 0x09, 0x32, 0x0e, 0x22, 0x70, 0x22, 0x00, 0x66, 0x00, 0x00 },
{ 0xec, 0xce, 0x00, 0x00, 0x7e, 0x7e, 0x12, 0x12, 0x66, 0x26, 0x0a, 0x4a, 0x12, 0x12, 0x62, 0x62, 0x0e, 0x8e, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xec, 0xcf, 0x7f, 0x7f, 0x11, 0x11, 0x65, 0x65, 0x19, 0x19, 0x3f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x7f, 0xff, 0x08, 0x08, 0x30, 0x06, 0x00, 0x00 },
{ 0xec, 0xd0, 0x00, 0x3c, 0x3c, 0x44, 0x00, 0x42, 0x7e, 0xbe, 0x01, 0x01, 0x3c, 0x3c, 0x00, 0x44, 0x3c, 0x42, 0x00, 0x82, 0x01, 0x01, 0x3c, 0xfe, 0x24, 0xaa, 0x24, 0xaa, 0x24, 0xaa, 0x3d, 0xff, 0x00, 0x00 },
{ 0xec, 0xd1, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x00, 0x00 },
{ 0xec, 0xd2, 0x08, 0x00, 0x08, 0x00, 0x11, 0xfe, 0x10, 0x00, 0x20, 0x00, 0x30, 0x00, 0x50, 0x00, 0x50, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x13, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xec, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x22, 0x04, 0x02, 0x04, 0x04, 0x04, 0x08, 0x04, 0x10, 0x08, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00 },
{ 0xec, 0xd4, 0x02, 0x00, 0x0c, 0x00, 0x70, 0x7f, 0x40, 0x41, 0x40, 0x41, 0x40, 0x41, 0x7e, 0x41, 0x40, 0x41, 0x40, 0x41, 0x40, 0x41, 0x40, 0x41, 0x7e, 0x47, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00 },
{ 0xec, 0xd5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x01, 0xc0, 0x0e, 0x38, 0x70, 0x07, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xec, 0xd6, 0x00, 0x00, 0x01, 0xff, 0x79, 0x01, 0x49, 0x11, 0x49, 0x11, 0x49, 0x7d, 0x49, 0x11, 0x49, 0x11, 0x49, 0x29, 0x49, 0x29, 0x49, 0x45, 0x79, 0x45, 0x01, 0x83, 0x01, 0x01, 0x01, 0xff, 0x00, 0x00 },
{ 0xec, 0xd7, 0x7f, 0xfe, 0x40, 0x02, 0x40, 0x82, 0x40, 0x82, 0x40, 0x82, 0x4f, 0xfa, 0x40, 0x82, 0x41, 0x42, 0x41, 0x42, 0x42, 0x22, 0x44, 0x12, 0x48, 0x0a, 0x40, 0x02, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xec, 0xd8, 0x10, 0x00, 0x11, 0xff, 0x11, 0x01, 0x7d, 0x11, 0x25, 0x11, 0x25, 0x7d, 0x25, 0x11, 0x25, 0x11, 0x45, 0x29, 0x69, 0x29, 0x59, 0x45, 0x09, 0x45, 0x15, 0x83, 0x21, 0x01, 0x41, 0xff, 0x00, 0x00 },
{ 0xec, 0xd9, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0xfd, 0x00, 0x80, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x06, 0x00, 0x00 },
{ 0xec, 0xda, 0x00, 0x02, 0x1f, 0x82, 0x00, 0x82, 0x00, 0x82, 0x1f, 0x82, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x3f, 0x82, 0x20, 0x82, 0x00, 0x82, 0x00, 0x82, 0x01, 0x02, 0x01, 0x02, 0x1e, 0x02, 0x00, 0x00 },
{ 0xec, 0xdb, 0x00, 0x00, 0x3f, 0xfe, 0x01, 0x02, 0x11, 0x02, 0x22, 0x02, 0x02, 0x02, 0x04, 0x04, 0x18, 0x04, 0x60, 0x38, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xec, 0xdc, 0x20, 0x00, 0x17, 0xff, 0x08, 0x50, 0x00, 0x50, 0x43, 0xfe, 0x22, 0x52, 0x12, 0x9e, 0x03, 0x02, 0x03, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xec, 0xdd, 0x11, 0x24, 0x10, 0xa4, 0x10, 0xa8, 0x15, 0xfe, 0x54, 0x70, 0x58, 0xac, 0x53, 0x23, 0x50, 0x80, 0x10, 0xff, 0x11, 0x2a, 0x19, 0xaa, 0x26, 0x4a, 0x24, 0x5f, 0x20, 0x82, 0x43, 0x02, 0x00, 0x00 },
{ 0xec, 0xde, 0x01, 0x24, 0x7c, 0xa4, 0x10, 0xa8, 0x11, 0xfe, 0x10, 0x70, 0x7c, 0xac, 0x13, 0x22, 0x10, 0x82, 0x11, 0xfe, 0x12, 0x54, 0x1d, 0x54, 0x70, 0x94, 0x00, 0xbf, 0x01, 0x04, 0x06, 0x04, 0x00, 0x00 },
{ 0xec, 0xdf, 0x08, 0x00, 0x11, 0xff, 0x21, 0x01, 0x45, 0x11, 0x29, 0x11, 0x11, 0x7d, 0x25, 0x11, 0x7d, 0x11, 0x15, 0x29, 0x11, 0x25, 0x59, 0x45, 0x55, 0x81, 0x55, 0x01, 0x11, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xec, 0xe0, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x82, 0x2f, 0xfa, 0x20, 0x82, 0x21, 0x42, 0x22, 0x22, 0x2c, 0x1a, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xec, 0xe1, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x3f, 0x7e, 0x21, 0x42, 0x3f, 0x7e, 0x21, 0x42, 0x3f, 0x7e, 0x22, 0x82, 0x27, 0xf2, 0x2c, 0x82, 0x27, 0xf2, 0x24, 0x82, 0x27, 0xf2, 0x24, 0x0e, 0x00, 0x00 },
{ 0xec, 0xe2, 0x10, 0x02, 0x11, 0xe2, 0x10, 0x22, 0x7c, 0x22, 0x54, 0x22, 0x55, 0xe2, 0x55, 0x02, 0x55, 0x02, 0x7d, 0x02, 0x11, 0xe2, 0x11, 0x22, 0x14, 0x22, 0x14, 0x22, 0x1a, 0x22, 0x62, 0xc2, 0x00, 0x00 },
{ 0xec, 0xe3, 0x00, 0x00, 0x3e, 0xff, 0x00, 0x11, 0x7e, 0x11, 0x00, 0xd1, 0x3e, 0x31, 0x00, 0x29, 0x3e, 0x41, 0x00, 0x86, 0x00, 0x10, 0x3e, 0x2a, 0x22, 0xa1, 0x22, 0xa1, 0x23, 0x22, 0x3e, 0x1e, 0x00, 0x00 },
{ 0xec, 0xe4, 0x00, 0x91, 0x7c, 0x52, 0x44, 0x10, 0x49, 0xff, 0x48, 0x38, 0x50, 0x54, 0x49, 0x93, 0x48, 0x82, 0x44, 0xff, 0x45, 0x2a, 0x45, 0xaa, 0x5a, 0x4a, 0x40, 0x5f, 0x40, 0x82, 0x43, 0x02, 0x00, 0x00 },
{ 0xec, 0xe5, 0x11, 0x00, 0x11, 0x3f, 0x3f, 0x89, 0x11, 0x09, 0x1f, 0x29, 0x04, 0x29, 0x3f, 0xa9, 0x24, 0xa9, 0x24, 0xc9, 0x3f, 0x91, 0x04, 0x11, 0x3f, 0xa1, 0x04, 0x21, 0x04, 0x42, 0x04, 0x8c, 0x00, 0x00 },
{ 0xec, 0xe6, 0x14, 0xf2, 0x14, 0x12, 0x7f, 0x12, 0x14, 0x12, 0x1c, 0xf2, 0x08, 0x82, 0x3e, 0x82, 0x2a, 0x82, 0x2a, 0xf2, 0x3e, 0x92, 0x08, 0x12, 0x7f, 0x12, 0x08, 0x12, 0x08, 0x12, 0x08, 0x62, 0x00, 0x00 },
{ 0xec, 0xe7, 0x10, 0x92, 0x1c, 0x54, 0x24, 0x10, 0x28, 0xff, 0x7e, 0x38, 0x2a, 0x54, 0x2a, 0x93, 0x3e, 0x10, 0x2a, 0x82, 0x2a, 0xff, 0x3f, 0x2a, 0x00, 0xaa, 0x2a, 0x5f, 0x2a, 0x82, 0x41, 0x02, 0x00, 0x00 },
{ 0xec, 0xe8, 0x04, 0x49, 0x04, 0x2a, 0x3f, 0x88, 0x2a, 0x7f, 0x2a, 0x1c, 0x3f, 0xaa, 0x2a, 0xc9, 0x3f, 0xa2, 0x20, 0x3a, 0x2a, 0x4f, 0x2f, 0xaa, 0x2a, 0x12, 0x4e, 0x9f, 0x5b, 0xa2, 0x40, 0x42, 0x00, 0x00 },
{ 0xec, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
{ 0xec, 0xea, 0x08, 0x20, 0x09, 0x20, 0x11, 0x20, 0x11, 0x20, 0x33, 0xfe, 0x32, 0x20, 0x54, 0x20, 0x50, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x50, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x16, 0x03, 0x00, 0x00 },
{ 0xec, 0xeb, 0x08, 0x78, 0x09, 0x08, 0x09, 0x04, 0x12, 0x02, 0x13, 0xfd, 0x35, 0x04, 0x31, 0x04, 0x51, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x12, 0x04, 0x12, 0x04, 0x14, 0x1c, 0x00, 0x00 },
{ 0xec, 0xec, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xec, 0xed, 0x00, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00 },
{ 0xec, 0xee, 0x00, 0x78, 0x41, 0x08, 0x21, 0x04, 0x02, 0xfa, 0x44, 0x01, 0x20, 0x78, 0x01, 0x08, 0x01, 0x04, 0x12, 0x02, 0x15, 0xfd, 0x21, 0x54, 0x21, 0x54, 0x41, 0x54, 0x41, 0x54, 0x07, 0xff, 0x00, 0x00 },
{ 0xec, 0xef, 0x01, 0x00, 0x41, 0xf8, 0x21, 0x08, 0x12, 0x10, 0x07, 0xfe, 0x4a, 0x22, 0x22, 0x22, 0x13, 0xfe, 0x00, 0x50, 0x78, 0x55, 0x08, 0x91, 0x0b, 0x1e, 0x08, 0x00, 0x16, 0x00, 0x61, 0xff, 0x00, 0x00 },
{ 0xec, 0xf0, 0x18, 0x38, 0x24, 0x48, 0x40, 0x44, 0x00, 0x82, 0x7d, 0x7d, 0x10, 0x00, 0x10, 0x5c, 0x7c, 0x44, 0x10, 0x82, 0x11, 0x01, 0x54, 0xfe, 0x34, 0xaa, 0x10, 0xaa, 0x18, 0xaa, 0x61, 0xff, 0x00, 0x00 },
{ 0xec, 0xf1, 0x00, 0x00, 0x7e, 0x7e, 0x48, 0x42, 0x7e, 0x42, 0x48, 0x42, 0x7e, 0x42, 0x48, 0x7e, 0x48, 0x42, 0x7f, 0x42, 0x01, 0x42, 0x55, 0x42, 0x55, 0x42, 0x41, 0x7e, 0x02, 0x00, 0x0c, 0x00, 0x00, 0x00 },
{ 0xec, 0xf2, 0x08, 0x0e, 0x0b, 0xf0, 0x08, 0x20, 0x10, 0x20, 0x10, 0x20, 0x30, 0x20, 0x30, 0x20, 0x57, 0xff, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00 },
{ 0xec, 0xf3, 0x00, 0x0e, 0x00, 0x70, 0x3f, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xec, 0xf4, 0x10, 0x00, 0x10, 0x0e, 0x10, 0xf0, 0x7c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x25, 0xff, 0x44, 0x10, 0x68, 0x10, 0x58, 0x10, 0x08, 0x10, 0x14, 0x10, 0x22, 0x10, 0x40, 0xfe, 0x00, 0x00 },
{ 0xec, 0xf5, 0x10, 0x40, 0x10, 0x46, 0x10, 0xb8, 0x7c, 0x88, 0x25, 0x88, 0x25, 0x88, 0x26, 0x88, 0x24, 0xff, 0x44, 0x88, 0x68, 0x88, 0x58, 0x88, 0x08, 0x88, 0x14, 0x88, 0x22, 0x88, 0x40, 0xbe, 0x00, 0x00 },
{ 0xec, 0xf6, 0x08, 0x1c, 0x0b, 0xe0, 0x10, 0x20, 0x30, 0x20, 0x57, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00, 0x04, 0x80, 0x04, 0x40, 0x24, 0x12, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xec, 0xf7, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x7e, 0xfe, 0x08, 0x10, 0x08, 0x10, 0x1c, 0x38, 0x1a, 0x38, 0x2a, 0x54, 0x28, 0x54, 0x48, 0x92, 0x09, 0x11, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xec, 0xf8, 0x21, 0x08, 0x11, 0x08, 0x01, 0x08, 0x47, 0xbe, 0x21, 0x08, 0x01, 0x08, 0x03, 0x9c, 0x13, 0x5c, 0x15, 0x2a, 0x25, 0x2a, 0x29, 0x49, 0x41, 0x08, 0x41, 0x08, 0x01, 0x08, 0x01, 0x08, 0x00, 0x00 },
{ 0xec, 0xf9, 0x0c, 0x10, 0x70, 0x28, 0x10, 0x44, 0x10, 0x82, 0x7d, 0x01, 0x10, 0x7c, 0x18, 0x00, 0x38, 0xfe, 0x34, 0x02, 0x54, 0x04, 0x50, 0xa8, 0x52, 0x92, 0x12, 0x81, 0x14, 0x85, 0x10, 0x7c, 0x00, 0x00 },
{ 0xec, 0xfa, 0x00, 0x40, 0x7e, 0x40, 0x48, 0xff, 0x48, 0x80, 0x49, 0x00, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x00, 0x49, 0xef, 0x49, 0x29, 0x49, 0x29, 0x7f, 0x29, 0x01, 0xef, 0x00, 0x00 },
{ 0xec, 0xfb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x08, 0x1e, 0x0b, 0xe0, 0x10, 0x20, 0x10, 0x20, 0x30, 0x20, 0x57, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00 },
{ 0xec, 0xfc, 0x04, 0x0e, 0x09, 0xf0, 0x18, 0x20, 0x6b, 0xff, 0x08, 0x20, 0x0f, 0xfe, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xec, 0xfd, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x60, 0x03, 0x00, 0x00 },
{ 0xec, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00 },
{ 0xed, 0xa1, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x10, 0x10, 0x08, 0x10, 0x08, 0x10, 0x04, 0x10, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x00, 0x40, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xed, 0xa2, 0x10, 0x20, 0x10, 0x20, 0x3f, 0x7f, 0x48, 0x88, 0x04, 0x04, 0x04, 0x84, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x08, 0x04, 0x08, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xed, 0xa3, 0x08, 0x10, 0x08, 0x10, 0x4a, 0x10, 0x2a, 0xfe, 0x2c, 0x00, 0x08, 0x00, 0x7e, 0x84, 0x08, 0x84, 0x1c, 0x44, 0x1a, 0x44, 0x2a, 0x48, 0x28, 0x08, 0x48, 0x10, 0x09, 0xff, 0x08, 0x00, 0x00, 0x00 },
{ 0xed, 0xa4, 0x08, 0x00, 0x0b, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x30, 0x88, 0x30, 0x88, 0x50, 0x88, 0x50, 0x9f, 0x11, 0x11, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x12, 0x02, 0x12, 0x02, 0x14, 0x1c, 0x00, 0x00 },
{ 0xed, 0xa5, 0x03, 0x81, 0x3c, 0x01, 0x04, 0x09, 0x7f, 0xc9, 0x04, 0x09, 0x15, 0x09, 0x75, 0xc9, 0x15, 0x09, 0x75, 0x49, 0x15, 0xc9, 0x0e, 0x09, 0x15, 0x09, 0x64, 0x81, 0x04, 0x01, 0x04, 0x07, 0x00, 0x00 },
{ 0xed, 0xa6, 0x00, 0x00, 0x3f, 0xf8, 0x02, 0x08, 0x02, 0x10, 0x04, 0x3e, 0x08, 0x22, 0x10, 0x02, 0x67, 0xe2, 0x00, 0x2c, 0x00, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xed, 0xa7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x00, 0x0b, 0xf8, 0x10, 0x88, 0x10, 0x88, 0x30, 0x9e, 0x50, 0x82, 0x11, 0x02, 0x11, 0x02, 0x12, 0x02, 0x12, 0x04, 0x14, 0x38, 0x00, 0x00 },
{ 0xed, 0xa8, 0x08, 0x00, 0x09, 0xfe, 0x10, 0x04, 0x10, 0x08, 0x30, 0x10, 0x30, 0x10, 0x50, 0x10, 0x13, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, 0x00 },
{ 0xed, 0xa9, 0x04, 0x01, 0x04, 0x01, 0x7f, 0xd1, 0x04, 0x11, 0x04, 0x11, 0x3f, 0x91, 0x24, 0x91, 0x24, 0x91, 0x24, 0x91, 0x25, 0x91, 0x0e, 0x11, 0x15, 0x01, 0x24, 0x81, 0x44, 0x01, 0x04, 0x07, 0x00, 0x00 },
{ 0xed, 0xaa, 0x00, 0x80, 0x00, 0x80, 0x7d, 0xfe, 0x01, 0x42, 0x02, 0x44, 0x18, 0x40, 0x60, 0xb0, 0x03, 0x0c, 0x0c, 0x03, 0x70, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xed, 0xab, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x10, 0x24, 0x10, 0x24, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x44, 0x92, 0x68, 0x92, 0x58, 0x92, 0x08, 0x92, 0x14, 0x96, 0x22, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xed, 0xac, 0x00, 0x80, 0x38, 0x80, 0x01, 0xff, 0x02, 0x21, 0x04, 0x22, 0x10, 0x50, 0x21, 0x8c, 0x46, 0x03, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x08, 0x0f, 0x10, 0x00, 0xe0, 0x03, 0x9c, 0x3c, 0x03, 0x00, 0x00 },
{ 0xed, 0xad, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x08, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xed, 0xae, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x0f, 0xf8, 0x00, 0x10, 0x00, 0x20, 0x00, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xed, 0xaf, 0x00, 0x20, 0x00, 0x20, 0x7f, 0x40, 0x02, 0x7f, 0x04, 0x44, 0x08, 0x84, 0x08, 0x84, 0x09, 0x44, 0x0c, 0x48, 0x18, 0x28, 0x68, 0x30, 0x08, 0x10, 0x08, 0x28, 0x08, 0xc4, 0x3b, 0x03, 0x00, 0x00 },
{ 0xed, 0xb0, 0x00, 0x80, 0x00, 0x80, 0x7d, 0xfe, 0x01, 0x22, 0x02, 0x24, 0x00, 0x20, 0x0c, 0x50, 0x71, 0x8c, 0x06, 0x03, 0x00, 0x80, 0x04, 0x40, 0x24, 0x04, 0x24, 0x12, 0x44, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xed, 0xb1, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x08, 0x08, 0x10, 0x31, 0x62, 0x12, 0x24, 0x0c, 0x18, 0x09, 0x12, 0x13, 0x26, 0x7c, 0xf9, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xed, 0xb2, 0x21, 0x08, 0x10, 0x88, 0x08, 0x10, 0x07, 0xff, 0x41, 0x04, 0x21, 0x04, 0x12, 0x49, 0x02, 0x49, 0x04, 0x92, 0x12, 0x8a, 0x11, 0x04, 0x21, 0x04, 0x22, 0x89, 0x42, 0xcb, 0x4f, 0x5d, 0x00, 0x00 },
{ 0xed, 0xb3, 0x00, 0x80, 0x01, 0xfc, 0x06, 0x04, 0x39, 0x08, 0x08, 0xb0, 0x04, 0xc0, 0x07, 0x00, 0x78, 0x00, 0x00, 0x84, 0x08, 0x88, 0x08, 0x90, 0x11, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xed, 0xb4, 0x01, 0x00, 0x01, 0x04, 0x1f, 0xe8, 0x01, 0x10, 0x01, 0x20, 0x7f, 0xff, 0x01, 0x90, 0x07, 0xfc, 0x1c, 0x04, 0x67, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xed, 0xb5, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x7f, 0xfe, 0x08, 0x10, 0x10, 0x20, 0x10, 0x20, 0x22, 0x44, 0x14, 0x28, 0x0c, 0x18, 0x08, 0x10, 0x0a, 0x14, 0x12, 0x24, 0x1f, 0x3e, 0x61, 0xc2, 0x00, 0x00 },
{ 0xed, 0xb6, 0x00, 0x80, 0x00, 0x80, 0x7c, 0xfe, 0x01, 0x22, 0x00, 0x24, 0x0c, 0xd8, 0x73, 0x07, 0x00, 0x00, 0x3f, 0xfe, 0x04, 0x00, 0x07, 0xe0, 0x05, 0x20, 0x08, 0xa1, 0x09, 0xe1, 0x7e, 0x1f, 0x00, 0x00 },
{ 0xed, 0xb7, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x88, 0x30, 0x88, 0x12, 0x88, 0x12, 0x89, 0x32, 0xee, 0x52, 0x88, 0x12, 0x88, 0x12, 0x88, 0x22, 0x89, 0x22, 0xe9, 0x4f, 0x07, 0x00, 0x00 },
{ 0xed, 0xb8, 0x00, 0x84, 0x7c, 0x44, 0x10, 0x08, 0x11, 0xff, 0x10, 0x84, 0x20, 0x84, 0x39, 0x29, 0x2a, 0x29, 0x69, 0x52, 0x29, 0x4a, 0x28, 0x84, 0x28, 0x84, 0x39, 0x29, 0x01, 0x6b, 0x03, 0xbd, 0x00, 0x00 },
{ 0xed, 0xb9, 0x04, 0x20, 0x24, 0x23, 0x27, 0xbc, 0x24, 0x21, 0x27, 0xa1, 0x78, 0x1f, 0x01, 0x00, 0x0a, 0x20, 0x04, 0x48, 0x02, 0x84, 0x01, 0x7a, 0x7f, 0x81, 0x08, 0x8c, 0x30, 0x82, 0x00, 0x80, 0x00, 0x00 },
{ 0xed, 0xba, 0x01, 0x00, 0x01, 0x02, 0x1f, 0xf4, 0x01, 0x08, 0x01, 0x10, 0x7f, 0xff, 0x00, 0x90, 0x01, 0x08, 0x07, 0xfc, 0x1c, 0x04, 0x64, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xed, 0xbb, 0x01, 0x00, 0x02, 0x00, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x3f, 0xf8, 0x00, 0x00 },
{ 0xed, 0xbc, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfe, 0x79, 0x22, 0x01, 0x24, 0x02, 0x24, 0x00, 0x20, 0x00, 0x50, 0x0e, 0x50, 0x70, 0x88, 0x01, 0x04, 0x06, 0x03, 0x00, 0x00 },
{ 0xed, 0xbd, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x08, 0x11, 0x08, 0x17, 0xfe, 0x11, 0x08, 0x11, 0x08, 0x1f, 0xff, 0x10, 0x00, 0x22, 0x92, 0x22, 0x49, 0x44, 0x49, 0x00, 0x00 },
{ 0xed, 0xbe, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x08, 0x24, 0x0e, 0x24, 0x78, 0xff, 0x08, 0x24, 0x3e, 0x24, 0x08, 0xff, 0x7f, 0x00, 0x08, 0x7e, 0x1c, 0x42, 0x2a, 0x7e, 0x48, 0x42, 0x08, 0x7e, 0x00, 0x00 },
{ 0xed, 0xbf, 0x00, 0x10, 0x3c, 0x10, 0x01, 0xbf, 0x7e, 0x29, 0x00, 0x4a, 0x3c, 0x94, 0x03, 0x14, 0x3c, 0x22, 0x00, 0xc1, 0x00, 0x00, 0x3c, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x24, 0x42, 0x3c, 0x7e, 0x00, 0x00 },
{ 0xed, 0xc0, 0x00, 0x80, 0x39, 0xfe, 0x02, 0x22, 0x00, 0x50, 0x0d, 0x8c, 0x70, 0x03, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x04, 0x08, 0x38, 0x07, 0x00, 0x00 },
{ 0xed, 0xc1, 0x0a, 0x12, 0x0a, 0x14, 0x2a, 0x3f, 0x2a, 0xa4, 0x2b, 0x64, 0x2a, 0x64, 0x2e, 0xbf, 0x2a, 0xa4, 0x2a, 0x24, 0x2a, 0x24, 0x2a, 0x3f, 0x2a, 0x24, 0x2e, 0xa4, 0x3a, 0xa4, 0x63, 0xbf, 0x00, 0x00 },
{ 0xed, 0xc2, 0x08, 0x40, 0x08, 0x40, 0x10, 0x80, 0x10, 0xff, 0x31, 0x20, 0x32, 0x20, 0x54, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xed, 0xc3, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xff, 0x08, 0x01, 0x10, 0x01, 0x10, 0x01, 0x20, 0x01, 0x47, 0xf1, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xed, 0xc4, 0x00, 0x0e, 0x01, 0xf0, 0x72, 0x42, 0x54, 0x21, 0x53, 0xfe, 0x52, 0x92, 0x53, 0xfe, 0x50, 0x04, 0x53, 0xc4, 0x52, 0x5f, 0x53, 0xc4, 0x72, 0x14, 0x03, 0xd4, 0x02, 0x04, 0x03, 0xcc, 0x00, 0x00 },
{ 0xed, 0xc5, 0x00, 0x0e, 0x7c, 0xf0, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x20, 0xff, 0x3c, 0x84, 0x24, 0x84, 0x64, 0x84, 0x24, 0x84, 0x24, 0x84, 0x24, 0x84, 0x3d, 0x04, 0x01, 0x04, 0x02, 0x04, 0x00, 0x00 },
{ 0xed, 0xc6, 0x00, 0x80, 0x7c, 0x80, 0x45, 0xff, 0x45, 0x20, 0x46, 0x20, 0x44, 0x20, 0x7c, 0x3e, 0x44, 0x20, 0x44, 0x20, 0x44, 0x20, 0x44, 0x3e, 0x7c, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xed, 0xc7, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x12, 0xff, 0x54, 0x81, 0x59, 0x01, 0x51, 0x01, 0x52, 0x01, 0x10, 0xf9, 0x10, 0x01, 0x28, 0x01, 0x24, 0x01, 0x20, 0x02, 0x40, 0x02, 0x40, 0x1c, 0x00, 0x00 },
{ 0xed, 0xc8, 0x10, 0x40, 0x10, 0x40, 0x12, 0xff, 0x54, 0xa0, 0x59, 0x20, 0x52, 0x20, 0x50, 0x3e, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x28, 0x3e, 0x24, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xed, 0xc9, 0x00, 0x7c, 0x1f, 0x84, 0x21, 0x02, 0x7f, 0xff, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x3f, 0x04, 0x21, 0x04, 0x3f, 0x7f, 0x21, 0x04, 0x3f, 0x44, 0x20, 0x24, 0x3f, 0x04, 0x20, 0x0c, 0x00, 0x00 },
{ 0xed, 0xca, 0x10, 0x10, 0x10, 0x1e, 0x24, 0x10, 0x44, 0x10, 0x28, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x24, 0x82, 0x7c, 0xfe, 0x14, 0x10, 0x50, 0x10, 0x55, 0xff, 0x54, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xed, 0xcb, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x14, 0x20, 0x10, 0x00, 0x1f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x40, 0x04, 0x0f, 0xc4, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x70, 0x00, 0x00 },
{ 0xed, 0xcc, 0x00, 0x10, 0x7f, 0x10, 0x14, 0x10, 0x14, 0x3f, 0x14, 0x21, 0x7f, 0x41, 0x55, 0x01, 0x55, 0x21, 0x57, 0x11, 0x61, 0x11, 0x41, 0x01, 0x7f, 0x01, 0x41, 0x02, 0x41, 0x02, 0x7f, 0x1c, 0x00, 0x00 },
{ 0xed, 0xcd, 0x00, 0x80, 0x08, 0x84, 0x10, 0x82, 0x60, 0x91, 0x03, 0xa1, 0x00, 0xc0, 0x03, 0x20, 0x0c, 0x40, 0x7f, 0xfe, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xff, 0x00, 0x00 },
{ 0xed, 0xce, 0x14, 0x10, 0x14, 0x7e, 0x7f, 0x42, 0x14, 0x7e, 0x14, 0x42, 0x14, 0x7e, 0x7f, 0x40, 0x00, 0x7f, 0x3e, 0x40, 0x22, 0x7f, 0x22, 0x01, 0x3e, 0xa9, 0x22, 0xa9, 0x23, 0x01, 0x3e, 0x06, 0x00, 0x00 },
{ 0xed, 0xcf, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x00, 0x27, 0xf0, 0x20, 0x20, 0x2f, 0xfe, 0x20, 0x40, 0x20, 0x40, 0x2f, 0xde, 0x21, 0x04, 0x5f, 0xbf, 0x42, 0x08, 0x46, 0x18, 0x00, 0x00 },
{ 0xed, 0xd0, 0x10, 0x90, 0x10, 0x9e, 0x13, 0xe4, 0x78, 0x48, 0x10, 0x31, 0x10, 0xd9, 0x3b, 0x27, 0x34, 0x90, 0x30, 0x8e, 0x50, 0xf0, 0x57, 0x44, 0x50, 0x28, 0x10, 0x31, 0x10, 0xcd, 0x17, 0x03, 0x00, 0x00 },
{ 0xed, 0xd1, 0x00, 0x50, 0x7e, 0x48, 0x10, 0x5e, 0x11, 0xe4, 0x1c, 0x28, 0x24, 0x19, 0x24, 0x67, 0x25, 0x90, 0x58, 0x48, 0x48, 0x5e, 0x0b, 0xe0, 0x10, 0x24, 0x10, 0x18, 0x20, 0xed, 0x47, 0x03, 0x00, 0x00 },
{ 0xed, 0xd2, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x01, 0x03, 0xff, 0x42, 0x00, 0x22, 0x7c, 0x12, 0x10, 0x02, 0xff, 0x02, 0x10, 0x12, 0x30, 0x12, 0xce, 0x24, 0x44, 0x24, 0xef, 0x45, 0x44, 0x48, 0xcc, 0x00, 0x00 },
{ 0xed, 0xd3, 0x02, 0x20, 0x7f, 0xff, 0x01, 0x10, 0x01, 0xe2, 0x3e, 0x9e, 0x02, 0x40, 0x7f, 0xff, 0x01, 0x10, 0x01, 0xe2, 0x3e, 0x1e, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xed, 0xd4, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x1b, 0xec, 0x60, 0x03, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00 },
{ 0xed, 0xd5, 0x08, 0x03, 0x7f, 0xbc, 0x08, 0x20, 0x3f, 0x3f, 0x29, 0x24, 0x3f, 0x24, 0x29, 0x24, 0x7f, 0x44, 0x08, 0x44, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xed, 0xd6, 0x40, 0x00, 0x2f, 0xbe, 0x05, 0x14, 0x05, 0x14, 0x4f, 0xbf, 0x22, 0x08, 0x05, 0x55, 0x09, 0xa6, 0x00, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x21, 0xfe, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xed, 0xd7, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x48, 0x00, 0x44, 0x3f, 0xff, 0x20, 0x40, 0x2f, 0x44, 0x20, 0x24, 0x2f, 0x28, 0x29, 0x10, 0x4f, 0x29, 0x40, 0x45, 0x41, 0x83, 0x00, 0x00 },
{ 0xed, 0xd8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x40, 0x80, 0x7e, 0x7e, 0x24, 0x24, 0x7f, 0x7f, 0x0c, 0x0c, 0x15, 0x15, 0x66, 0x27, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xed, 0xd9, 0x00, 0x00, 0x3f, 0x7e, 0x14, 0x28, 0x7f, 0x7e, 0x0a, 0xa9, 0x72, 0xcf, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x3f, 0xfe, 0x29, 0x52, 0x3f, 0x7e, 0x0a, 0x12, 0x7d, 0x7d, 0x00, 0x00 },
{ 0xed, 0xda, 0x08, 0x24, 0x08, 0x24, 0x7f, 0x48, 0x00, 0x7f, 0x22, 0xc8, 0x22, 0x48, 0x55, 0x48, 0x08, 0x7e, 0x08, 0x48, 0x7f, 0x48, 0x08, 0x7e, 0x1c, 0x48, 0x2a, 0x48, 0x48, 0x48, 0x08, 0x7f, 0x00, 0x00 },
{ 0xed, 0xdb, 0x00, 0x40, 0x00, 0x40, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x08, 0x40, 0x18, 0x40, 0x24, 0x80, 0x04, 0x80, 0x02, 0x80, 0x01, 0x00, 0x02, 0x80, 0x04, 0x40, 0x18, 0x38, 0x60, 0x07, 0x00, 0x00 },
{ 0xed, 0xdc, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x17, 0xff, 0x30, 0x10, 0x30, 0x10, 0x51, 0x10, 0x51, 0x10, 0x10, 0xa0, 0x10, 0xa0, 0x10, 0x40, 0x10, 0x60, 0x10, 0x90, 0x11, 0x0c, 0x16, 0x03, 0x00, 0x00 },
{ 0xed, 0xdd, 0x7f, 0xfe, 0x40, 0x00, 0x40, 0x38, 0x4f, 0xc0, 0x48, 0x00, 0x48, 0x00, 0x4f, 0xfc, 0x48, 0x40, 0x48, 0x40, 0x48, 0x40, 0x48, 0x40, 0x50, 0x40, 0x50, 0x40, 0x40, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xed, 0xde, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x7d, 0x04, 0x11, 0xfc, 0x10, 0x00, 0x13, 0xff, 0x10, 0x80, 0x11, 0xfe, 0x1a, 0x4a, 0x64, 0x92, 0x01, 0x22, 0x02, 0x42, 0x00, 0x9c, 0x00, 0x00 },
{ 0xed, 0xdf, 0x10, 0x20, 0x13, 0xfe, 0x11, 0x24, 0x11, 0x24, 0x7e, 0xaa, 0x10, 0x20, 0x17, 0xff, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x02, 0x1e, 0xfa, 0x72, 0x8a, 0x02, 0xfa, 0x02, 0x02, 0x03, 0xfe, 0x00, 0x00 },
{ 0xed, 0xe0, 0x04, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x05, 0xff, 0x04, 0x10, 0x7c, 0x10, 0x14, 0x10, 0x14, 0x10, 0x24, 0x10, 0x24, 0x10, 0x44, 0x10, 0x04, 0xfe, 0x00, 0x00 },
{ 0xed, 0xe1, 0x04, 0x10, 0x24, 0x7e, 0x25, 0xa4, 0x3c, 0x98, 0x05, 0xe4, 0x7c, 0x04, 0x15, 0xff, 0x24, 0x24, 0x44, 0x8c, 0x00, 0xa0, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xed, 0xe2, 0x04, 0x10, 0x24, 0x3e, 0x24, 0x62, 0x25, 0x94, 0x24, 0x48, 0x3c, 0x30, 0x05, 0xc4, 0x04, 0x04, 0x7d, 0xff, 0x24, 0x04, 0x24, 0x44, 0x24, 0x24, 0x24, 0x04, 0x44, 0x04, 0x04, 0x1c, 0x00, 0x00 },
{ 0xed, 0xe3, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x80, 0x54, 0xfc, 0x54, 0x80, 0x54, 0xfc, 0x54, 0x80, 0x57, 0xff, 0x54, 0xa0, 0x54, 0xa2, 0x5c, 0x94, 0x10, 0x98, 0x10, 0x88, 0x10, 0xf4, 0x13, 0x83, 0x00, 0x00 },
{ 0xed, 0xe4, 0x00, 0x40, 0x00, 0x40, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x40, 0x20, 0x40, 0x20, 0x40, 0x20, 0x40, 0x2f, 0xfe, 0x20, 0x40, 0x20, 0x40, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x5f, 0xff, 0x00, 0x00 },
{ 0xed, 0xe5, 0x00, 0x00, 0x7c, 0xfe, 0x04, 0x80, 0x04, 0xfc, 0x04, 0x80, 0x3c, 0xfc, 0x20, 0x80, 0x20, 0x80, 0x7d, 0xff, 0x44, 0x90, 0x04, 0x91, 0x04, 0x8a, 0x04, 0x84, 0x04, 0xf2, 0x3b, 0x81, 0x00, 0x00 },
{ 0xed, 0xe6, 0x10, 0x84, 0x08, 0x88, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x0c, 0x1f, 0xf0, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xed, 0xe7, 0x00, 0x20, 0x03, 0xfe, 0x78, 0x88, 0x48, 0x90, 0x4f, 0xff, 0x48, 0x00, 0x79, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x78, 0x20, 0x07, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xed, 0xe8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x10, 0x38, 0x90, 0x38, 0x90, 0x34, 0x90, 0x54, 0x50, 0x50, 0x60, 0x50, 0x20, 0x10, 0x50, 0x10, 0x8c, 0x13, 0x03, 0x00, 0x00 },
{ 0xed, 0xe9, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x44, 0x7c, 0x28, 0x11, 0xff, 0x10, 0x00, 0x38, 0xfe, 0x38, 0x82, 0x34, 0xfe, 0x54, 0x82, 0x50, 0xfe, 0x50, 0x10, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xed, 0xea, 0x10, 0x20, 0x11, 0xfe, 0x10, 0xa4, 0x7c, 0xa4, 0x11, 0x6a, 0x12, 0x31, 0x3b, 0xff, 0x38, 0x00, 0x35, 0xfe, 0x55, 0x02, 0x51, 0x7a, 0x51, 0x4a, 0x11, 0x7a, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xed, 0xeb, 0x10, 0x48, 0x13, 0xff, 0x10, 0x4a, 0x7c, 0x09, 0x12, 0xff, 0x12, 0x88, 0x3a, 0xfa, 0x37, 0xaa, 0x34, 0xf6, 0x53, 0x94, 0x52, 0xf4, 0x12, 0xa5, 0x12, 0xf5, 0x14, 0x8a, 0x11, 0x11, 0x00, 0x00 },
{ 0xed, 0xec, 0x24, 0x10, 0x24, 0x7f, 0x25, 0xa2, 0x3c, 0x9c, 0x05, 0xe0, 0x7c, 0x04, 0x25, 0xff, 0x24, 0x44, 0x44, 0xac, 0x00, 0x80, 0x3e, 0xc2, 0x02, 0xa4, 0x04, 0x98, 0x18, 0x8c, 0x61, 0x83, 0x00, 0x00 },
{ 0xed, 0xed, 0x04, 0x10, 0x24, 0x10, 0x25, 0xff, 0x24, 0x92, 0x24, 0x92, 0x3d, 0x55, 0x04, 0x10, 0x05, 0xff, 0x7c, 0x00, 0x14, 0xfe, 0x14, 0xaa, 0x24, 0xaa, 0x24, 0xba, 0x44, 0x82, 0x04, 0xfe, 0x00, 0x00 },
{ 0xed, 0xee, 0x04, 0x10, 0x24, 0x12, 0x24, 0x11, 0x24, 0x10, 0x25, 0xff, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x10, 0x7c, 0x28, 0x24, 0x28, 0x24, 0x28, 0x24, 0x44, 0x44, 0x44, 0x44, 0x82, 0x05, 0x01, 0x00, 0x00 },
{ 0xed, 0xef, 0x04, 0x20, 0x47, 0xfe, 0x28, 0x88, 0x10, 0x50, 0x37, 0xff, 0x50, 0x00, 0x09, 0xfc, 0x09, 0x04, 0x19, 0xfc, 0x29, 0x04, 0x49, 0xfc, 0x08, 0x20, 0x0f, 0xff, 0x08, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xed, 0xf0, 0x00, 0x20, 0x03, 0xfe, 0x7c, 0x88, 0x10, 0x50, 0x17, 0xff, 0x10, 0x00, 0x7d, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x1c, 0x20, 0x73, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xed, 0xf1, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xed, 0xf2, 0x10, 0x08, 0x10, 0x08, 0x54, 0xff, 0x58, 0x80, 0x10, 0x88, 0x7c, 0x88, 0x10, 0x88, 0x18, 0xbe, 0x34, 0x88, 0x34, 0x88, 0x50, 0x88, 0x50, 0x88, 0x11, 0x08, 0x11, 0x08, 0x12, 0x7f, 0x00, 0x00 },
{ 0xed, 0xf3, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x3c, 0xfe, 0x24, 0x00, 0x25, 0xff, 0x24, 0x40, 0x3c, 0xff, 0x25, 0x15, 0x24, 0x25, 0x24, 0xc9, 0x44, 0x11, 0x4c, 0x66, 0x00, 0x00 },
{ 0xed, 0xf4, 0x00, 0x48, 0x3b, 0xff, 0x28, 0x4a, 0x28, 0x09, 0x2a, 0xff, 0x3a, 0x88, 0x2a, 0xfa, 0x2b, 0xaa, 0x28, 0xf6, 0x3f, 0x94, 0x2a, 0xf4, 0x2a, 0xa4, 0x2a, 0xf5, 0x4c, 0x8b, 0x59, 0x11, 0x00, 0x00 },
{ 0xed, 0xf5, 0x00, 0x22, 0x00, 0x21, 0x2f, 0xff, 0x28, 0x20, 0x2b, 0xe0, 0x3a, 0xa2, 0x0a, 0x92, 0x7b, 0xd2, 0x2a, 0x54, 0x2b, 0xd4, 0x2a, 0x88, 0x4a, 0x89, 0x13, 0xd5, 0x10, 0x23, 0x20, 0xc1, 0x00, 0x00 },
{ 0xed, 0xf6, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x00, 0x00, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x05, 0xff, 0x04, 0x10, 0x7c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x44, 0xfe, 0x00, 0x00 },
{ 0xed, 0xf7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x3f, 0xfe, 0x04, 0x20, 0x0f, 0x26, 0x31, 0x38, 0x0a, 0x22, 0x3c, 0x1e, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xed, 0xf8, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x00, 0x00, 0x24, 0x20, 0x24, 0x7c, 0x24, 0xa4, 0x3d, 0x98, 0x04, 0x50, 0x04, 0x64, 0x7d, 0xff, 0x14, 0x04, 0x14, 0x44, 0x24, 0x84, 0x44, 0x18, 0x00, 0x00 },
{ 0xed, 0xf9, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x88, 0x14, 0x94, 0x22, 0xa2, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x24, 0x13, 0xe4, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xed, 0xfa, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x00, 0x14, 0x28, 0x12, 0x2f, 0xff, 0x28, 0x10, 0x3b, 0xd2, 0x0a, 0x92, 0x7b, 0xd4, 0x2a, 0x54, 0x2b, 0xc8, 0x4a, 0x89, 0x13, 0xd5, 0x20, 0x23, 0x00, 0x00 },
{ 0xed, 0xfb, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x7f, 0x02, 0x08, 0x7e, 0x08, 0x12, 0x3e, 0x22, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x80, 0x04, 0x44, 0x1c, 0x28, 0x64, 0xd0, 0x07, 0x0c, 0x3c, 0x03, 0x00, 0x00 },
{ 0xed, 0xfc, 0x00, 0x04, 0x38, 0x05, 0x2a, 0xff, 0x2a, 0x84, 0x3a, 0x84, 0x2b, 0xf5, 0x28, 0xa5, 0x38, 0xf5, 0x2f, 0x95, 0x2a, 0xf6, 0x2a, 0xa6, 0x3c, 0xf4, 0x01, 0x0d, 0x29, 0x13, 0x4a, 0x21, 0x00, 0x00 },
{ 0xed, 0xfd, 0x22, 0x1e, 0x22, 0xf2, 0x3e, 0x4c, 0x02, 0x30, 0x7e, 0xc4, 0x12, 0x7f, 0x12, 0x24, 0x22, 0x0c, 0x7f, 0xff, 0x02, 0x20, 0x1f, 0xfc, 0x12, 0x24, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xed, 0xfe, 0x00, 0x00, 0x0f, 0xfc, 0x08, 0x00, 0x0f, 0xf8, 0x08, 0x00, 0x0f, 0xf8, 0x08, 0x00, 0x08, 0x00, 0x7f, 0xff, 0x08, 0x84, 0x08, 0x48, 0x08, 0x30, 0x09, 0x90, 0x0e, 0x0c, 0x70, 0x03, 0x00, 0x00 },
{ 0xee, 0xa1, 0x00, 0x20, 0x7b, 0xfe, 0x49, 0x04, 0x50, 0x88, 0x57, 0xff, 0x60, 0x00, 0x51, 0xfc, 0x51, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x70, 0x20, 0x47, 0xff, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xee, 0xa2, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7f, 0xff, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xee, 0xa3, 0x04, 0x20, 0x04, 0x28, 0x3f, 0xa4, 0x04, 0x22, 0x04, 0x20, 0x7f, 0xff, 0x00, 0x10, 0x00, 0x10, 0x3f, 0x11, 0x21, 0x12, 0x21, 0x0c, 0x21, 0x09, 0x3f, 0x15, 0x00, 0x63, 0x01, 0x81, 0x00, 0x00 },
{ 0xee, 0xa4, 0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x08, 0x20, 0x10, 0x20, 0x30, 0x20, 0x51, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x00, 0x00 },
{ 0xee, 0xa5, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x81, 0x1f, 0xfc, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xee, 0xa6, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x7f, 0xff, 0x00, 0x20, 0x00, 0x24, 0x00, 0x28, 0x00, 0x30, 0x00, 0x60, 0x00, 0xa0, 0x03, 0x20, 0x0c, 0x20, 0x30, 0x20, 0x00, 0x20, 0x00, 0xe0, 0x00, 0x00 },
{ 0xee, 0xa7, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x7d, 0xff, 0x10, 0x04, 0x10, 0x0c, 0x38, 0x0c, 0x38, 0x14, 0x34, 0x14, 0x54, 0x24, 0x50, 0x44, 0x50, 0x84, 0x11, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xee, 0xa8, 0x04, 0x10, 0x04, 0x14, 0x3f, 0xd2, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x10, 0x04, 0x11, 0x7f, 0xd2, 0x04, 0x0a, 0x0e, 0x0c, 0x15, 0x08, 0x24, 0x95, 0x44, 0x63, 0x05, 0x81, 0x00, 0x00 },
{ 0xee, 0xa9, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x7c, 0x84, 0x10, 0x84, 0x10, 0x48, 0x38, 0x48, 0x3b, 0xff, 0x34, 0x20, 0x54, 0x20, 0x50, 0x20, 0x51, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xee, 0xaa, 0x20, 0x88, 0x10, 0x8a, 0x03, 0xe9, 0x40, 0x88, 0x20, 0x88, 0x07, 0xff, 0x00, 0x08, 0x00, 0x09, 0x13, 0xe9, 0x12, 0x2a, 0x22, 0x2a, 0x22, 0x24, 0x43, 0xed, 0x40, 0x13, 0x00, 0x21, 0x00, 0x00 },
{ 0xee, 0xab, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x04, 0x01, 0x44, 0x21, 0x23, 0xfe, 0x11, 0x08, 0x00, 0x88, 0x00, 0x90, 0x17, 0xff, 0x10, 0x20, 0x20, 0x20, 0x23, 0xfe, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xee, 0xac, 0x08, 0x42, 0x10, 0x84, 0x21, 0x08, 0x10, 0x84, 0x08, 0x42, 0x00, 0x80, 0x08, 0x82, 0x08, 0x84, 0x10, 0x88, 0x21, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xee, 0xad, 0x10, 0x10, 0x11, 0xff, 0x25, 0x01, 0x44, 0x10, 0x28, 0xfe, 0x10, 0x44, 0x10, 0x24, 0x24, 0x28, 0x7d, 0xff, 0x14, 0x10, 0x50, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xee, 0xae, 0x04, 0x10, 0x04, 0x14, 0x3f, 0x92, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x10, 0x04, 0x10, 0x7f, 0xd2, 0x04, 0x12, 0x0c, 0x4c, 0x12, 0x8c, 0x71, 0x09, 0x10, 0x95, 0x1e, 0xa3, 0x70, 0x41, 0x00, 0x00 },
{ 0xee, 0xaf, 0x00, 0x04, 0x3f, 0x04, 0x21, 0x04, 0x21, 0x04, 0x21, 0x7f, 0x3f, 0x0c, 0x21, 0x0c, 0x21, 0x0c, 0x3f, 0x14, 0x21, 0x14, 0x21, 0x24, 0x21, 0x24, 0x3f, 0x44, 0x12, 0x04, 0x61, 0x1c, 0x00, 0x00 },
{ 0xee, 0xb0, 0x04, 0x14, 0x3f, 0x92, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x7f, 0xd2, 0x04, 0x12, 0x3f, 0x94, 0x24, 0x94, 0x3f, 0x8c, 0x24, 0x88, 0x3f, 0x89, 0x04, 0x15, 0x7f, 0xe3, 0x04, 0x41, 0x00, 0x00 },
{ 0xee, 0xb1, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x22, 0x7d, 0x5c, 0x24, 0x94, 0x24, 0x92, 0x4c, 0xb9, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x84, 0x12, 0xa4, 0x24, 0x94, 0x40, 0x84, 0x00, 0x00 },
{ 0xee, 0xb2, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x42, 0x7d, 0x9c, 0x24, 0x94, 0x2d, 0xba, 0x50, 0x05, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x12, 0x24, 0x13, 0xe4, 0x12, 0x24, 0x23, 0xe4, 0x24, 0x24, 0x00, 0x00 },
{ 0xee, 0xb3, 0x00, 0x3c, 0x1f, 0xc0, 0x11, 0x04, 0x20, 0x82, 0x40, 0x01, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xee, 0xb4, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x80, 0x00, 0x3e, 0x1f, 0xc8, 0x21, 0x04, 0x40, 0x82, 0x1f, 0xf8, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x88, 0x1f, 0xf8, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xee, 0xb5, 0x00, 0x06, 0x3c, 0xf8, 0x00, 0x92, 0x7d, 0x09, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x12, 0x3c, 0x12, 0x01, 0xff, 0x00, 0x12, 0x3c, 0x12, 0x24, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x70, 0x00, 0x00 },
{ 0xee, 0xb6, 0x08, 0x06, 0x14, 0x78, 0x22, 0x52, 0x40, 0x89, 0x3e, 0xfe, 0x08, 0x12, 0x08, 0x12, 0x7e, 0xff, 0x08, 0x12, 0x4a, 0x12, 0x2a, 0xfe, 0x28, 0x10, 0x08, 0x10, 0x0e, 0x10, 0x70, 0x70, 0x00, 0x00 },
{ 0xee, 0xb7, 0x08, 0x10, 0x08, 0x10, 0x13, 0xff, 0x12, 0x01, 0x32, 0x01, 0x30, 0x00, 0x50, 0x00, 0x53, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, 0x00 },
{ 0xee, 0xb8, 0x08, 0x06, 0x08, 0x38, 0x11, 0xd0, 0x11, 0x10, 0x31, 0x10, 0x31, 0xff, 0x51, 0x10, 0x11, 0x08, 0x11, 0x08, 0x11, 0x38, 0x11, 0xc5, 0x17, 0x05, 0x10, 0x03, 0x13, 0xfd, 0x10, 0x00, 0x00, 0x00 },
{ 0xee, 0xb9, 0x08, 0x04, 0x0b, 0xc4, 0x10, 0x1e, 0x17, 0xc5, 0x30, 0x06, 0x33, 0xdf, 0x50, 0x04, 0x13, 0xca, 0x10, 0x1f, 0x10, 0x29, 0x13, 0xc9, 0x12, 0x4f, 0x12, 0x49, 0x12, 0x49, 0x13, 0xcf, 0x00, 0x00 },
{ 0xee, 0xba, 0x00, 0x00, 0x01, 0xfc, 0x79, 0x04, 0x49, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x07, 0xff, 0x00, 0x00 },
{ 0xee, 0xbb, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x42, 0x7c, 0x42, 0x24, 0x42, 0x24, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x44, 0x42, 0x68, 0x7e, 0x58, 0x42, 0x08, 0x42, 0x14, 0x42, 0x22, 0x42, 0x40, 0xff, 0x00, 0x00 },
{ 0xee, 0xbc, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x1c, 0x27, 0xe0, 0x24, 0x20, 0x24, 0x20, 0x27, 0xfe, 0x24, 0x20, 0x24, 0x10, 0x25, 0x90, 0x2e, 0x09, 0x40, 0x05, 0x4f, 0xf3, 0x40, 0x01, 0x00, 0x00 },
{ 0xee, 0xbd, 0x10, 0x06, 0x11, 0xf8, 0x11, 0x10, 0x7d, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0xff, 0x1d, 0x10, 0x71, 0x10, 0x11, 0x08, 0x11, 0x08, 0x11, 0xe5, 0x17, 0x05, 0x10, 0x03, 0x33, 0xf9, 0x00, 0x00 },
{ 0xee, 0xbe, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7c, 0xfe, 0x10, 0x90, 0x11, 0x10, 0x38, 0x10, 0x38, 0x10, 0x35, 0xff, 0x54, 0x10, 0x50, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xee, 0xbf, 0x10, 0x20, 0x10, 0x22, 0x11, 0xfa, 0x7c, 0x24, 0x10, 0x28, 0x13, 0xff, 0x38, 0x10, 0x38, 0x28, 0x34, 0x44, 0x54, 0xfe, 0x51, 0x82, 0x52, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xee, 0xc0, 0x10, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x7d, 0x11, 0x10, 0xd6, 0x10, 0x10, 0x38, 0x00, 0x34, 0xfe, 0x34, 0x00, 0x51, 0xff, 0x50, 0x40, 0x50, 0xfe, 0x10, 0x82, 0x10, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xee, 0xc1, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x04, 0x01, 0x04, 0x41, 0x04, 0x21, 0xfc, 0x11, 0x04, 0x01, 0x04, 0x01, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x21, 0x04, 0x21, 0x04, 0x41, 0x04, 0x47, 0xff, 0x00, 0x00 },
{ 0xee, 0xc2, 0x20, 0x40, 0x10, 0x42, 0x09, 0xfa, 0x00, 0x44, 0x40, 0x48, 0x27, 0xff, 0x10, 0x30, 0x00, 0x48, 0x01, 0xfe, 0x17, 0x02, 0x11, 0x02, 0x21, 0xfe, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xee, 0xc3, 0x04, 0x00, 0x44, 0xfc, 0x28, 0x84, 0x10, 0x84, 0x30, 0x84, 0x50, 0xfc, 0x08, 0x84, 0x08, 0x84, 0x18, 0x84, 0x28, 0xfc, 0x48, 0x84, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x33, 0xff, 0x00, 0x00 },
{ 0xee, 0xc4, 0x04, 0x21, 0x44, 0x21, 0x29, 0xfa, 0x10, 0x22, 0x30, 0x24, 0x53, 0xff, 0x08, 0x18, 0x08, 0x24, 0x18, 0xff, 0x2b, 0x41, 0x48, 0x41, 0x08, 0x7f, 0x08, 0x41, 0x08, 0x41, 0x30, 0x7f, 0x00, 0x00 },
{ 0xee, 0xc5, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x00, 0x33, 0xfc, 0x12, 0x04, 0x12, 0x04, 0x33, 0xfc, 0x52, 0x04, 0x12, 0x04, 0x13, 0xfc, 0x22, 0x04, 0x22, 0x04, 0x4f, 0xff, 0x00, 0x00 },
{ 0xee, 0xc6, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x01, 0x08, 0x1f, 0xf0, 0x01, 0x20, 0x7f, 0xff, 0x00, 0xc0, 0x03, 0x20, 0x0f, 0xfc, 0x74, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xee, 0xc7, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x45, 0x01, 0x29, 0x01, 0x10, 0x00, 0x11, 0xff, 0x24, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x54, 0x10, 0x54, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, 0x00 },
{ 0xee, 0xc8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xee, 0xc9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x20, 0x00, 0x11, 0xfc, 0x01, 0x04, 0x41, 0x04, 0x21, 0xfc, 0x09, 0x04, 0x09, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x21, 0x04, 0x27, 0xff, 0x00, 0x00 },
{ 0xee, 0xca, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x84, 0x1f, 0xe8, 0x00, 0x90, 0x00, 0xa0, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x20, 0x1f, 0xfc, 0x64, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xee, 0xcb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3c, 0x20, 0x00, 0x20, 0x7e, 0xfa, 0x00, 0x24, 0x3c, 0x28, 0x01, 0xff, 0x3c, 0x24, 0x00, 0x7e, 0x3d, 0xc2, 0x24, 0x7e, 0x24, 0x42, 0x3c, 0x7e, 0x00, 0x00 },
{ 0xee, 0xcc, 0x00, 0x00, 0x3c, 0x7e, 0x00, 0x42, 0x7e, 0x42, 0x00, 0x42, 0x3c, 0x7e, 0x00, 0x42, 0x3c, 0x42, 0x00, 0x42, 0x00, 0x7e, 0x3c, 0x42, 0x24, 0x42, 0x24, 0x42, 0x24, 0x42, 0x3d, 0xff, 0x00, 0x00 },
{ 0xee, 0xcd, 0x00, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x22, 0x81, 0x3e, 0x81, 0x22, 0x00, 0x22, 0xff, 0x3e, 0x10, 0x22, 0x10, 0x22, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x24, 0x10, 0x22, 0x10, 0x42, 0x70, 0x00, 0x00 },
{ 0xee, 0xce, 0x00, 0x48, 0x3d, 0xff, 0x24, 0x48, 0x24, 0x22, 0x24, 0xfa, 0x3c, 0x24, 0x08, 0x28, 0x09, 0xff, 0x28, 0x28, 0x2e, 0x44, 0x29, 0xfe, 0x28, 0x42, 0x28, 0x7e, 0x2e, 0x42, 0x70, 0x7e, 0x00, 0x00 },
{ 0xee, 0xcf, 0x40, 0x00, 0x21, 0xfc, 0x10, 0x00, 0x07, 0xff, 0x40, 0x00, 0x21, 0xfc, 0x10, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x71, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xee, 0xd0, 0x01, 0x80, 0x3e, 0x1f, 0x22, 0x11, 0x22, 0x12, 0x22, 0x12, 0x3f, 0xd4, 0x22, 0x12, 0x22, 0x12, 0x22, 0x11, 0x21, 0x11, 0x27, 0x51, 0x39, 0x51, 0x60, 0xd6, 0x00, 0x50, 0x3f, 0x10, 0x00, 0x00 },
{ 0xee, 0xd1, 0x00, 0x24, 0x3c, 0x24, 0x24, 0x48, 0x24, 0x7f, 0x24, 0xc8, 0x3d, 0x48, 0x24, 0x48, 0x24, 0x7e, 0x24, 0x48, 0x3c, 0x48, 0x24, 0x7e, 0x24, 0x48, 0x2e, 0x48, 0x78, 0x48, 0x00, 0x7f, 0x00, 0x00 },
{ 0xee, 0xd2, 0x08, 0x00, 0x28, 0x3e, 0x2f, 0x22, 0x28, 0x22, 0x7f, 0x22, 0x00, 0x3e, 0x55, 0x22, 0x6b, 0x22, 0x41, 0x22, 0x7f, 0x3e, 0x55, 0x22, 0x55, 0x22, 0x6b, 0x22, 0x41, 0x22, 0x7f, 0x7f, 0x00, 0x00 },
{ 0xee, 0xd3, 0x08, 0x10, 0x3f, 0x10, 0x08, 0x10, 0x3f, 0x7e, 0x08, 0x12, 0x7f, 0x92, 0x00, 0x12, 0x3f, 0x12, 0x21, 0x12, 0x3f, 0x12, 0x21, 0x12, 0x3f, 0x22, 0x21, 0x22, 0x1e, 0x22, 0x73, 0x4c, 0x00, 0x00 },
{ 0xee, 0xd4, 0x00, 0x00, 0x1f, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0xf0, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfc, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x1c, 0x01, 0x00, 0x00, 0x00 },
{ 0xee, 0xd5, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x44, 0x24, 0x28, 0x25, 0xff, 0x25, 0x11, 0x25, 0x7d, 0x45, 0x11, 0x69, 0x7d, 0x59, 0x45, 0x09, 0x45, 0x15, 0x7d, 0x23, 0x01, 0x41, 0x07, 0x00, 0x00 },
{ 0xee, 0xd6, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x48, 0x01, 0x0f, 0x7e, 0x08, 0x22, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x14, 0x2a, 0x14, 0x29, 0x08, 0x49, 0x14, 0x08, 0x22, 0x18, 0x41, 0x00, 0x00 },
{ 0xee, 0xd7, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x82, 0x10, 0x44, 0x11, 0xff, 0x11, 0x11, 0x1d, 0x7d, 0x71, 0x11, 0x11, 0x7d, 0x11, 0x45, 0x11, 0x45, 0x11, 0x7d, 0x11, 0x01, 0x31, 0x07, 0x00, 0x00 },
{ 0xee, 0xd8, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x20, 0x22, 0x3f, 0x14, 0x62, 0x7f, 0x62, 0x49, 0xa2, 0x5d, 0x22, 0x49, 0x14, 0x5d, 0x14, 0x55, 0x14, 0x55, 0x08, 0x5d, 0x14, 0x41, 0x22, 0x47, 0x41, 0x00, 0x00 },
{ 0xee, 0xd9, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x01, 0x04, 0x40, 0x88, 0x23, 0xfe, 0x12, 0x22, 0x02, 0xfa, 0x02, 0x22, 0x12, 0xfa, 0x12, 0x8a, 0x22, 0x8a, 0x22, 0xfa, 0x42, 0x02, 0x42, 0x0e, 0x00, 0x00 },
{ 0xee, 0xda, 0x04, 0x10, 0x44, 0x10, 0x28, 0x10, 0x10, 0x91, 0x30, 0x91, 0x51, 0x12, 0x09, 0x12, 0x08, 0x10, 0x18, 0x28, 0x28, 0x28, 0x48, 0x48, 0x08, 0x44, 0x08, 0x84, 0x09, 0x02, 0x32, 0x01, 0x00, 0x00 },
{ 0xee, 0xdb, 0x00, 0x80, 0x01, 0xfc, 0x06, 0x08, 0x18, 0x90, 0x02, 0x60, 0x01, 0x80, 0x06, 0x00, 0x38, 0x00, 0x04, 0x82, 0x04, 0x84, 0x08, 0x98, 0x11, 0x40, 0x02, 0x30, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xee, 0xdc, 0x10, 0x20, 0x10, 0x20, 0x20, 0x3f, 0x7e, 0x41, 0x42, 0x41, 0x42, 0x81, 0x42, 0x01, 0x7e, 0x21, 0x42, 0x11, 0x42, 0x11, 0x42, 0x01, 0x42, 0x01, 0x7e, 0x02, 0x00, 0x02, 0x00, 0x1c, 0x00, 0x00 },
{ 0xee, 0xdd, 0x0c, 0x10, 0x71, 0xff, 0x10, 0x10, 0x10, 0xfe, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x82, 0x38, 0xfe, 0x38, 0x82, 0x54, 0xfe, 0x54, 0x82, 0x50, 0xfe, 0x10, 0x00, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xee, 0xde, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x1f, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x1f, 0xfe, 0x00, 0x00 },
{ 0xee, 0xdf, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x24, 0x3e, 0xff, 0x08, 0x24, 0x3e, 0x24, 0x08, 0xff, 0x7f, 0x00, 0x08, 0x7e, 0x1c, 0x42, 0x2a, 0x7e, 0x48, 0x42, 0x08, 0x7e, 0x00, 0x00 },
{ 0xee, 0xe0, 0x10, 0x10, 0x11, 0xff, 0x24, 0x10, 0x44, 0xfe, 0x28, 0x10, 0x11, 0xff, 0x10, 0x82, 0x24, 0xfe, 0x7c, 0x82, 0x10, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x50, 0x00, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xee, 0xe1, 0x3f, 0x7e, 0x09, 0x12, 0x33, 0x26, 0x05, 0x4a, 0x19, 0x32, 0x07, 0x42, 0x04, 0x40, 0x0f, 0xfc, 0x18, 0x40, 0x6f, 0xfc, 0x08, 0x40, 0x0f, 0xfc, 0x08, 0x40, 0x0f, 0xfe, 0x08, 0x00, 0x00, 0x00 },
{ 0xee, 0xe2, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x22, 0x10, 0x14, 0x11, 0x18, 0x92, 0x68, 0x94, 0x04, 0x90, 0x0d, 0x10, 0x14, 0x28, 0x64, 0x28, 0x04, 0x44, 0x08, 0x82, 0x31, 0x01, 0x00, 0x00 },
{ 0xee, 0xe3, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xff, 0x7e, 0x44, 0x00, 0x24, 0x3c, 0xff, 0x00, 0x91, 0x3c, 0xbd, 0x00, 0x91, 0x00, 0xbd, 0x3c, 0xa5, 0x24, 0xa5, 0x24, 0xbd, 0x24, 0x81, 0x3c, 0x83, 0x00, 0x00 },
{ 0xee, 0xe4, 0x00, 0x12, 0x3c, 0x11, 0x24, 0x10, 0x25, 0xff, 0x3c, 0x10, 0x24, 0x92, 0x24, 0x92, 0x3c, 0x92, 0x25, 0xd4, 0x24, 0x8c, 0x24, 0x88, 0x3c, 0x89, 0x01, 0x15, 0x24, 0x23, 0x42, 0xc1, 0x00, 0x00 },
{ 0xee, 0xe5, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x22, 0x24, 0x22, 0x22, 0x42, 0x21, 0x44, 0x21, 0x04, 0x20, 0x08, 0x20, 0x30, 0xe0, 0x00, 0x00 },
{ 0xee, 0xe6, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x23, 0xff, 0x22, 0x28, 0x3e, 0x28, 0x08, 0x28, 0x08, 0xaa, 0x2e, 0xaa, 0x28, 0xa9, 0x29, 0x29, 0x29, 0x29, 0x28, 0x48, 0x2e, 0x48, 0x78, 0x98, 0x00, 0x00 },
{ 0xee, 0xe7, 0x00, 0x10, 0x3e, 0xff, 0x22, 0x10, 0x22, 0x7e, 0x22, 0x10, 0x3e, 0xff, 0x08, 0x42, 0x08, 0x7e, 0x2e, 0x42, 0x28, 0x7e, 0x28, 0x42, 0x28, 0x7e, 0x28, 0x00, 0x2e, 0x24, 0x78, 0xc3, 0x00, 0x00 },
{ 0xee, 0xe8, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xfe, 0x42, 0x22, 0x22, 0x22, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x72, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xee, 0xe9, 0x20, 0x20, 0x10, 0x20, 0x03, 0xff, 0x40, 0x48, 0x21, 0x4a, 0x01, 0x4a, 0x01, 0x49, 0x02, 0x49, 0x72, 0x49, 0x10, 0x88, 0x10, 0x88, 0x11, 0x38, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xee, 0xea, 0x20, 0x20, 0x10, 0x20, 0x0f, 0xff, 0x01, 0x04, 0x40, 0x88, 0x23, 0xfe, 0x12, 0x22, 0x02, 0xfa, 0x02, 0x22, 0x72, 0xfa, 0x12, 0x8a, 0x12, 0xfa, 0x12, 0x06, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xee, 0xeb, 0x18, 0x10, 0x24, 0x10, 0x41, 0xff, 0x00, 0x82, 0x7c, 0x44, 0x11, 0xff, 0x11, 0x01, 0x7d, 0x11, 0x11, 0x7d, 0x11, 0x11, 0x55, 0x7d, 0x35, 0x45, 0x11, 0x7d, 0x19, 0x01, 0x61, 0x07, 0x00, 0x00 },
{ 0xee, 0xec, 0x08, 0x00, 0x09, 0xff, 0x09, 0x11, 0x11, 0x11, 0x11, 0x11, 0x31, 0x11, 0x31, 0x11, 0x51, 0xff, 0x51, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xee, 0xed, 0x08, 0xc0, 0x08, 0x60, 0x08, 0x90, 0x11, 0x0c, 0x16, 0x03, 0x30, 0x00, 0x33, 0xfe, 0x50, 0x20, 0x50, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xee, 0xee, 0x08, 0x20, 0x0b, 0xff, 0x08, 0x20, 0x13, 0xfe, 0x12, 0x22, 0x33, 0xfe, 0x32, 0x22, 0x53, 0xfe, 0x50, 0x26, 0x13, 0xf9, 0x10, 0x04, 0x17, 0xff, 0x10, 0x84, 0x10, 0x44, 0x10, 0x1c, 0x00, 0x00 },
{ 0xee, 0xef, 0x0f, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xee, 0xf0, 0x02, 0x40, 0x02, 0x40, 0x1f, 0xf8, 0x12, 0x48, 0x12, 0x48, 0x12, 0x48, 0x1f, 0xf8, 0x12, 0x48, 0x12, 0x48, 0x12, 0x48, 0x7f, 0xfe, 0x00, 0x00, 0x04, 0x30, 0x18, 0x0c, 0x60, 0x02, 0x00, 0x00 },
{ 0xee, 0xf1, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x3f, 0x02, 0x21, 0x22, 0x21, 0x22, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x22, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x02, 0x21, 0x02, 0x27, 0x0e, 0x00, 0x00 },
{ 0xee, 0xf2, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x3f, 0x22, 0x29, 0x22, 0x25, 0x22, 0x29, 0x22, 0x25, 0x22, 0x21, 0x06, 0x00, 0x00, 0x7f, 0xfe, 0x02, 0x02, 0x0c, 0x04, 0x70, 0x38, 0x00, 0x00 },
{ 0xee, 0xf3, 0x10, 0x98, 0x10, 0xe0, 0x10, 0x82, 0x12, 0xfe, 0x7e, 0x00, 0x12, 0xfe, 0x12, 0x82, 0x12, 0xfe, 0x12, 0x82, 0x1e, 0xfe, 0x72, 0x00, 0x03, 0xff, 0x00, 0x8c, 0x01, 0x02, 0x06, 0x01, 0x00, 0x00 },
{ 0xee, 0xf4, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x13, 0xfe, 0x7e, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x26, 0x1f, 0xf9, 0x70, 0x04, 0x07, 0xff, 0x01, 0x04, 0x00, 0x84, 0x00, 0x1c, 0x00, 0x00 },
{ 0xee, 0xf5, 0x05, 0xf0, 0x08, 0x08, 0x17, 0xf4, 0x62, 0x23, 0x1f, 0xfc, 0x12, 0x24, 0x14, 0x1c, 0x18, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xee, 0xf6, 0x01, 0x00, 0x7f, 0xfe, 0x01, 0x00, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x11, 0x08, 0x1f, 0xf8, 0x01, 0x08, 0x01, 0xf4, 0x3e, 0x12, 0x00, 0x10, 0x7f, 0xfe, 0x04, 0x10, 0x02, 0x70, 0x00, 0x00 },
{ 0xee, 0xf7, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x21, 0x10, 0x21, 0x10, 0x2f, 0xfe, 0x21, 0x10, 0x21, 0x10, 0x3f, 0xff, 0x24, 0x42, 0x44, 0x34, 0x47, 0x8c, 0x5c, 0x03, 0x00, 0x00 },
{ 0xee, 0xf8, 0x00, 0x80, 0x3f, 0xff, 0x24, 0x44, 0x27, 0xfc, 0x24, 0x44, 0x27, 0xfc, 0x20, 0x40, 0x27, 0xfc, 0x20, 0x40, 0x2f, 0xff, 0x21, 0x12, 0x2e, 0x4e, 0x41, 0xf0, 0x40, 0x40, 0x4f, 0xff, 0x00, 0x00 },
{ 0xee, 0xf9, 0x10, 0x48, 0x10, 0x44, 0x18, 0x8e, 0x57, 0xf2, 0x54, 0x90, 0x50, 0x91, 0x51, 0x0f, 0x12, 0x40, 0x10, 0x40, 0x10, 0xfc, 0x11, 0x84, 0x12, 0x48, 0x10, 0x30, 0x10, 0xcc, 0x13, 0x03, 0x00, 0x00 },
{ 0xee, 0xfa, 0x00, 0x08, 0x7b, 0xca, 0x4a, 0x49, 0x7b, 0xc8, 0x00, 0x0f, 0x3f, 0xb8, 0x24, 0x8a, 0x3f, 0x8a, 0x24, 0x8c, 0x3f, 0x8c, 0x04, 0x08, 0x7f, 0xc9, 0x04, 0x15, 0x04, 0x23, 0x04, 0x41, 0x00, 0x00 },
{ 0xee, 0xfb, 0x10, 0xf0, 0x10, 0x28, 0x10, 0x44, 0x7c, 0x82, 0x11, 0x01, 0x10, 0x00, 0x38, 0xfe, 0x38, 0x10, 0x34, 0x10, 0x54, 0x10, 0x50, 0xfe, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xee, 0xfc, 0x00, 0x00, 0x3f, 0x3c, 0x21, 0x24, 0x21, 0x24, 0x3f, 0x25, 0x20, 0x47, 0x2a, 0x40, 0x3f, 0x00, 0x2a, 0x7e, 0x2a, 0x22, 0x3f, 0x22, 0x20, 0x14, 0x4a, 0x08, 0x49, 0x14, 0x50, 0xe3, 0x00, 0x00 },
{ 0xee, 0xfd, 0x04, 0x01, 0x7f, 0xc6, 0x00, 0x38, 0x3f, 0x88, 0x2a, 0x89, 0x2e, 0x8e, 0x20, 0xb8, 0x3f, 0x88, 0x11, 0x09, 0x1f, 0x0e, 0x11, 0x38, 0x1f, 0x08, 0x00, 0x09, 0x03, 0x89, 0x7c, 0x07, 0x00, 0x00 },
{ 0xee, 0xfe, 0x20, 0x00, 0x17, 0xee, 0x0c, 0x2a, 0x04, 0x2a, 0x47, 0xea, 0x24, 0x13, 0x15, 0x40, 0x07, 0xe0, 0x05, 0x5f, 0x15, 0x49, 0x17, 0xea, 0x24, 0x0a, 0x29, 0x44, 0x49, 0x2a, 0x4a, 0x31, 0x00, 0x00 },
{ 0xef, 0xa1, 0x08, 0x08, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00, 0x3e, 0x02, 0x22, 0x22, 0x32, 0x22, 0x2a, 0x22, 0x32, 0x22, 0x2a, 0x22, 0x22, 0x02, 0x2e, 0x0e, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xef, 0xa2, 0x00, 0x48, 0x7c, 0x48, 0x11, 0xfe, 0x11, 0x4a, 0x11, 0x4a, 0x7d, 0x4a, 0x11, 0xfe, 0x11, 0x4a, 0x11, 0x4a, 0x11, 0x4a, 0x1f, 0xff, 0x70, 0x00, 0x00, 0x84, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00 },
{ 0xef, 0xa3, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xef, 0xa4, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x10, 0x02, 0x20, 0x02, 0x4f, 0xe2, 0x09, 0x22, 0x09, 0x22, 0x0f, 0xe2, 0x09, 0x22, 0x09, 0x22, 0x0f, 0xe4, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xef, 0xa5, 0x08, 0x00, 0x08, 0x7f, 0x09, 0x49, 0x2a, 0x49, 0x2c, 0x49, 0x28, 0x49, 0x48, 0x49, 0x08, 0x7f, 0x08, 0x49, 0x08, 0x49, 0x14, 0x49, 0x12, 0x49, 0x21, 0x49, 0x20, 0x49, 0x40, 0x7f, 0x00, 0x00 },
{ 0xef, 0xa6, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x12, 0x00, 0x53, 0xbf, 0x32, 0x48, 0x13, 0xde, 0x11, 0x52, 0x35, 0xde, 0x55, 0x52, 0x15, 0xde, 0x15, 0x52, 0x27, 0xde, 0x22, 0x52, 0x4c, 0x21, 0x00, 0x00 },
{ 0xef, 0xa7, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x07, 0xc0, 0x01, 0x20, 0x06, 0x10, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xef, 0xa8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x24, 0x02, 0xff, 0x7f, 0x00, 0x00, 0x90, 0x03, 0xe2, 0x3c, 0x1e, 0x02, 0x00, 0x02, 0xff, 0x7f, 0x00, 0x00, 0x90, 0x01, 0xe2, 0x3e, 0x1e, 0x00, 0x00 },
{ 0xef, 0xa9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0x02, 0x15, 0x22, 0x13, 0x22, 0x11, 0x22, 0x15, 0x22, 0x13, 0x22, 0x11, 0x02, 0x13, 0x0e, 0x00, 0x00 },
{ 0xef, 0xaa, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x44, 0x47, 0xf0, 0x08, 0x10, 0x0f, 0xe0, 0x00, 0x20, 0x7f, 0xff, 0x03, 0x04, 0x0d, 0x88, 0x72, 0x50, 0x0c, 0xe0, 0x73, 0x50, 0x0c, 0x4c, 0x71, 0x83, 0x00, 0x00 },
{ 0xef, 0xab, 0x10, 0x10, 0x11, 0xff, 0x25, 0x52, 0x45, 0x7e, 0x29, 0x52, 0x11, 0x7e, 0x11, 0x10, 0x25, 0xff, 0x7d, 0x24, 0x11, 0x47, 0x55, 0x90, 0x55, 0x10, 0x52, 0x7e, 0x12, 0x10, 0x12, 0xff, 0x00, 0x00 },
{ 0xef, 0xac, 0x00, 0xf0, 0x3c, 0x28, 0x00, 0x44, 0x7e, 0x82, 0x01, 0x01, 0x3c, 0x00, 0x00, 0xfe, 0x3c, 0x10, 0x00, 0x10, 0x00, 0x10, 0x3c, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3d, 0xff, 0x00, 0x00 },
{ 0xef, 0xad, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x82, 0x10, 0x82, 0x7c, 0xfe, 0x54, 0x94, 0x7c, 0x94, 0x54, 0xff, 0x7c, 0x94, 0x10, 0x94, 0x10, 0xff, 0x7c, 0xaa, 0x11, 0x24, 0x11, 0x3a, 0x12, 0xe1, 0x00, 0x00 },
{ 0xef, 0xae, 0x08, 0x10, 0x08, 0x10, 0x7e, 0xff, 0x08, 0x52, 0x3e, 0x7e, 0x2a, 0x52, 0x3e, 0x7e, 0x2a, 0x14, 0x3e, 0x1e, 0x08, 0xf2, 0x08, 0x02, 0x7e, 0xff, 0x08, 0x22, 0x08, 0x12, 0x08, 0x06, 0x00, 0x00 },
{ 0xef, 0xaf, 0x08, 0x00, 0x14, 0x7f, 0x22, 0x49, 0x40, 0x49, 0x3e, 0x49, 0x08, 0x49, 0x08, 0x49, 0x7e, 0x7f, 0x08, 0x49, 0x4a, 0x49, 0x2a, 0x49, 0x28, 0x49, 0x08, 0x49, 0x0e, 0x49, 0x70, 0x7f, 0x00, 0x00 },
{ 0xef, 0xb0, 0x18, 0xf0, 0x24, 0x28, 0x40, 0x44, 0x00, 0x82, 0x7d, 0x01, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x54, 0xfe, 0x34, 0x10, 0x10, 0x10, 0x18, 0x10, 0x61, 0xff, 0x00, 0x00 },
{ 0xef, 0xb1, 0x08, 0x24, 0x14, 0x27, 0x22, 0xf8, 0x40, 0x12, 0x3e, 0x0c, 0x08, 0x35, 0x08, 0xc3, 0x7e, 0x14, 0x08, 0x13, 0x4a, 0xfc, 0x2a, 0x11, 0x28, 0x0a, 0x08, 0x0c, 0x0e, 0x35, 0x70, 0xc3, 0x00, 0x00 },
{ 0xef, 0xb2, 0x08, 0x24, 0x14, 0x24, 0x22, 0x7f, 0x40, 0xc8, 0x3f, 0x7e, 0x08, 0x48, 0x08, 0x7e, 0x7e, 0x48, 0x08, 0x7f, 0x4a, 0x00, 0x2a, 0xe7, 0x28, 0xa5, 0x08, 0xbd, 0x0e, 0x81, 0x70, 0x87, 0x00, 0x00 },
{ 0xef, 0xb3, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfd, 0x00, 0x81, 0x00, 0xff, 0x00, 0x00 },
{ 0xef, 0xb4, 0x20, 0x00, 0x23, 0x7f, 0x3c, 0x08, 0x20, 0x90, 0x3f, 0xbe, 0x11, 0x22, 0x5f, 0x22, 0x51, 0x3e, 0x5f, 0x22, 0x51, 0x3e, 0x5f, 0x22, 0x40, 0x22, 0x7f, 0xbe, 0x12, 0x14, 0x61, 0x63, 0x00, 0x00 },
{ 0xef, 0xb5, 0x08, 0x00, 0x7f, 0x7f, 0x00, 0x08, 0x7f, 0x10, 0x55, 0x3e, 0x55, 0x22, 0x5d, 0x3e, 0x41, 0x22, 0x7f, 0x3e, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x00, 0x23, 0x94, 0x7c, 0x63, 0x00, 0x00 },
{ 0xef, 0xb6, 0x08, 0x24, 0x14, 0x27, 0x22, 0xf8, 0x5c, 0x12, 0x00, 0x0c, 0x3e, 0x35, 0x22, 0xc3, 0x3e, 0x28, 0x22, 0x27, 0x3e, 0xf8, 0x20, 0x12, 0x3e, 0x14, 0x20, 0x08, 0x3e, 0x35, 0x21, 0xc3, 0x00, 0x00 },
{ 0xef, 0xb7, 0x10, 0x00, 0x10, 0xff, 0x10, 0x11, 0x10, 0x11, 0x17, 0x11, 0x78, 0x11, 0x10, 0x11, 0x10, 0x11, 0x11, 0x21, 0x11, 0x21, 0x0f, 0x21, 0x00, 0x41, 0x00, 0x42, 0x00, 0x82, 0x01, 0x0c, 0x00, 0x00 },
{ 0xef, 0xb8, 0x04, 0x20, 0x04, 0x24, 0x3f, 0xa2, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x12, 0x20, 0x24, 0x24, 0x3f, 0x94, 0x64, 0x14, 0x3f, 0x18, 0x24, 0x08, 0x3f, 0x19, 0x24, 0x25, 0x3f, 0xc3, 0x00, 0x00 },
{ 0xef, 0xb9, 0x10, 0x01, 0x10, 0x0e, 0x10, 0xf0, 0x7c, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0xff, 0x1c, 0x84, 0x70, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x11, 0x04, 0x11, 0x04, 0x32, 0x04, 0x00, 0x00 },
{ 0xef, 0xba, 0x21, 0x03, 0x11, 0x1c, 0x01, 0x10, 0x07, 0xd0, 0x41, 0x10, 0x21, 0x1f, 0x11, 0x12, 0x01, 0xd2, 0x07, 0x12, 0x11, 0x12, 0x11, 0x12, 0x21, 0x12, 0x21, 0x22, 0x41, 0x22, 0x43, 0x42, 0x00, 0x00 },
{ 0xef, 0xbb, 0x00, 0x40, 0x1f, 0xff, 0x12, 0x10, 0x53, 0xdf, 0x35, 0x14, 0x18, 0xa2, 0x17, 0xdf, 0x34, 0x51, 0x57, 0xd1, 0x54, 0x51, 0x17, 0xd1, 0x14, 0x11, 0x27, 0xd7, 0x24, 0x10, 0x47, 0xd0, 0x00, 0x00 },
{ 0xef, 0xbc, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x45, 0x5c, 0x3d, 0x00, 0x20, 0x06, 0x3e, 0x78, 0x20, 0x2a, 0xfe, 0x28, 0x92, 0x7e, 0xaa, 0x09, 0xff, 0x1d, 0x21, 0x2b, 0x49, 0x49, 0x75, 0x09, 0x03, 0x00, 0x00 },
{ 0xef, 0xbd, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x3f, 0x3f, 0x21, 0x21, 0x3f, 0x21, 0x21, 0x21, 0x3f, 0x21, 0x20, 0x21, 0x3f, 0x21, 0x20, 0x27, 0x3f, 0x20, 0x20, 0x20, 0x00, 0x00 },
{ 0xef, 0xbe, 0x10, 0x20, 0x10, 0x7c, 0x24, 0x44, 0x44, 0x88, 0x29, 0x90, 0x10, 0xfe, 0x10, 0x92, 0x24, 0x92, 0x7c, 0x92, 0x10, 0xfe, 0x54, 0x80, 0x54, 0x80, 0x50, 0x81, 0x10, 0x81, 0x10, 0x7f, 0x00, 0x00 },
{ 0xef, 0xbf, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xef, 0xc0, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x14, 0x20, 0x54, 0x3e, 0x54, 0x20, 0x54, 0x20, 0x54, 0x20, 0x54, 0x20, 0x55, 0xfe, 0x55, 0x02, 0x55, 0x02, 0x7d, 0x02, 0x01, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xef, 0xc1, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x80, 0x20, 0x80, 0x20, 0xfe, 0x20, 0x80, 0x20, 0x80, 0x27, 0xfc, 0x24, 0x04, 0x24, 0x04, 0x44, 0x04, 0x44, 0x04, 0x47, 0xfc, 0x00, 0x00 },
{ 0xef, 0xc2, 0x21, 0x03, 0x11, 0x1c, 0x07, 0xd0, 0x01, 0x10, 0x47, 0xd0, 0x25, 0x5f, 0x17, 0xd2, 0x05, 0x52, 0x07, 0xd2, 0x11, 0x12, 0x11, 0x12, 0x27, 0xd2, 0x21, 0x22, 0x41, 0x22, 0x41, 0x42, 0x00, 0x00 },
{ 0xef, 0xc3, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xef, 0xc4, 0x08, 0x10, 0x08, 0x10, 0x4a, 0x10, 0x2c, 0x1f, 0x08, 0x10, 0x7e, 0x10, 0x08, 0x10, 0x18, 0xfe, 0x1c, 0x82, 0x2a, 0x82, 0x28, 0x82, 0x48, 0x82, 0x48, 0x82, 0x08, 0x82, 0x08, 0xfe, 0x00, 0x00 },
{ 0xef, 0xc5, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x1e, 0xbc, 0x20, 0x00, 0x10, 0x40, 0x40, 0x7f, 0x20, 0x40, 0x0b, 0xfe, 0x12, 0x02, 0x22, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xef, 0xc6, 0x10, 0x10, 0x1c, 0x10, 0x24, 0x10, 0x28, 0x1f, 0x7e, 0x10, 0x2a, 0x10, 0x2a, 0x10, 0x3e, 0x10, 0x2a, 0xfe, 0x2a, 0x82, 0x3e, 0x82, 0x00, 0x82, 0x54, 0x82, 0x54, 0x82, 0x54, 0xfe, 0x00, 0x00 },
{ 0xef, 0xc7, 0x00, 0x08, 0x7f, 0x08, 0x49, 0x08, 0x6b, 0x08, 0x5d, 0x0f, 0x49, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x41, 0x0f, 0x41, 0x78, 0x41, 0x01, 0x41, 0x55, 0x41, 0x54, 0x7f, 0x00, 0x00 },
{ 0xef, 0xc8, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x7c, 0x84, 0x10, 0x48, 0x13, 0xff, 0x14, 0x00, 0x18, 0x40, 0x73, 0xff, 0x10, 0x44, 0x10, 0x84, 0x11, 0x68, 0x10, 0x1c, 0x10, 0x62, 0x33, 0x81, 0x00, 0x00 },
{ 0xef, 0xc9, 0x10, 0x00, 0x11, 0xef, 0x10, 0xa5, 0x7d, 0x6b, 0x10, 0xa5, 0x11, 0x29, 0x10, 0x63, 0x1c, 0x10, 0x70, 0xff, 0x10, 0x81, 0x10, 0x81, 0x10, 0xff, 0x10, 0x81, 0x10, 0x81, 0x30, 0xff, 0x00, 0x00 },
{ 0xef, 0xca, 0x10, 0x94, 0x10, 0x94, 0x11, 0xff, 0x7c, 0x94, 0x54, 0x9c, 0x54, 0x80, 0x54, 0xff, 0x54, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x38, 0x14, 0x54, 0x1c, 0x92, 0x73, 0x11, 0x02, 0x10, 0x00, 0x00 },
{ 0xef, 0xcb, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xef, 0xcc, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x20, 0x10, 0x00, 0x00 },
{ 0xef, 0xcd, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xef, 0xce, 0x08, 0x20, 0x0b, 0xff, 0x08, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x31, 0xfc, 0x30, 0x00, 0x57, 0xff, 0x54, 0x01, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0xe0, 0x00, 0x00 },
{ 0xef, 0xcf, 0x08, 0x20, 0x08, 0x3e, 0x08, 0x20, 0x11, 0xfe, 0x11, 0x02, 0x31, 0xfe, 0x31, 0x02, 0x51, 0x02, 0x51, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x10, 0x86, 0x13, 0x01, 0x00, 0x00 },
{ 0xef, 0xd0, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x00, 0x00, 0x00, 0x7c, 0x3f, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xef, 0xd1, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x10, 0x24, 0x10, 0x24, 0x90, 0x24, 0x9e, 0x44, 0x90, 0x68, 0x90, 0x58, 0x90, 0x0c, 0x90, 0x12, 0x90, 0x23, 0xff, 0x40, 0x00, 0x00, 0x00 },
{ 0xef, 0xd2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x5f, 0xfd, 0x00, 0x80, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x18, 0x80, 0x14, 0x80, 0x23, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xef, 0xd3, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x7c, 0xfc, 0x54, 0x84, 0x54, 0x84, 0x54, 0xfc, 0x54, 0x84, 0x54, 0xfc, 0x54, 0x84, 0x54, 0x84, 0x5c, 0xfc, 0x10, 0x00, 0x10, 0xcc, 0x13, 0x03, 0x00, 0x00 },
{ 0xef, 0xd4, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0x03, 0x21, 0x7c, 0x22, 0x08, 0x24, 0x08, 0x2f, 0x7f, 0x21, 0x08, 0x29, 0x08, 0x26, 0x3e, 0x46, 0x00, 0x49, 0x80, 0x50, 0x7f, 0x00, 0x00 },
{ 0xef, 0xd5, 0x00, 0x00, 0x78, 0x06, 0x08, 0xf8, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x3d, 0xff, 0x44, 0x10, 0x04, 0x10, 0x28, 0x10, 0x28, 0x10, 0x10, 0xfe, 0x18, 0x00, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xef, 0xd6, 0x08, 0x00, 0x09, 0xff, 0x10, 0x10, 0x20, 0x10, 0x48, 0x10, 0x08, 0x90, 0x10, 0x90, 0x10, 0x9e, 0x30, 0x90, 0x50, 0x90, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x13, 0xff, 0x00, 0x00 },
{ 0xef, 0xd7, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x58, 0xfe, 0x54, 0x10, 0x55, 0xff, 0x50, 0x00, 0x10, 0xfe, 0x10, 0x92, 0x10, 0x92, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xef, 0xd8, 0x10, 0x00, 0x13, 0xc3, 0x10, 0x5c, 0x78, 0x84, 0x10, 0x84, 0x11, 0x04, 0x11, 0xdf, 0x1a, 0x44, 0x70, 0x44, 0x12, 0x84, 0x12, 0x84, 0x11, 0x1f, 0x11, 0x80, 0x12, 0x60, 0x34, 0x1f, 0x00, 0x00 },
{ 0xef, 0xd9, 0x00, 0x20, 0x7f, 0x20, 0x08, 0x40, 0x08, 0x7f, 0x08, 0xc4, 0x29, 0x44, 0x2e, 0x44, 0x28, 0x44, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x10, 0x3c, 0x28, 0x60, 0x44, 0x01, 0x83, 0x00, 0x00 },
{ 0xef, 0xda, 0x08, 0x10, 0x7f, 0x10, 0x08, 0x3f, 0x7f, 0x22, 0x49, 0x62, 0x7f, 0x14, 0x1c, 0x08, 0x2a, 0x14, 0x49, 0x63, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x08, 0xf8, 0x08, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xef, 0xdb, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7e, 0xff, 0x10, 0x80, 0x11, 0x10, 0x10, 0x50, 0x1e, 0x50, 0x12, 0x7e, 0x12, 0x90, 0x12, 0x90, 0x22, 0x7e, 0x22, 0x10, 0x22, 0x10, 0x4c, 0xff, 0x00, 0x00 },
{ 0xef, 0xdc, 0x00, 0x00, 0x0f, 0xf0, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x00, 0x00 },
{ 0xef, 0xdd, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x20, 0x7f, 0x3f, 0x08, 0x62, 0x08, 0xa2, 0x2f, 0x14, 0x28, 0x14, 0x28, 0x08, 0x2f, 0x14, 0x78, 0x63, 0x00, 0x00 },
{ 0xef, 0xde, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x90, 0x38, 0x9e, 0x34, 0x90, 0x54, 0x90, 0x50, 0x90, 0x50, 0x90, 0x10, 0x90, 0x10, 0x90, 0x13, 0xff, 0x00, 0x00 },
{ 0xef, 0xdf, 0x08, 0x10, 0x08, 0x1f, 0x08, 0x10, 0x7e, 0x10, 0x08, 0xfe, 0x08, 0x82, 0x18, 0xfe, 0x1c, 0x82, 0x1a, 0xfe, 0x2a, 0x82, 0x28, 0x82, 0x48, 0xfe, 0x08, 0x44, 0x08, 0x82, 0x0b, 0x01, 0x00, 0x00 },
{ 0xef, 0xe0, 0x17, 0xe0, 0x12, 0x5e, 0x13, 0xd2, 0x7a, 0x52, 0x13, 0xd2, 0x12, 0x52, 0x3b, 0xde, 0x36, 0x40, 0x34, 0x7c, 0x53, 0xe0, 0x50, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x00, 0x00 },
{ 0xef, 0xe1, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x10, 0x80, 0x10, 0xfc, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xef, 0xe2, 0x20, 0x00, 0x10, 0x00, 0x0b, 0xff, 0x00, 0x10, 0x40, 0x10, 0x20, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x20, 0x10, 0x40, 0x10, 0x40, 0xe0, 0x00, 0x00 },
{ 0xef, 0xe3, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x02, 0x01, 0x42, 0x01, 0x20, 0x00, 0x11, 0xfe, 0x00, 0x20, 0x00, 0x20, 0x11, 0x3e, 0x11, 0x20, 0x22, 0x20, 0x23, 0x20, 0x44, 0xa0, 0x48, 0x7f, 0x00, 0x00 },
{ 0xef, 0xe4, 0x20, 0x0e, 0x11, 0xf0, 0x09, 0x24, 0x02, 0x12, 0x44, 0x00, 0x23, 0xfe, 0x10, 0x22, 0x00, 0x22, 0x07, 0xff, 0x10, 0x22, 0x10, 0x22, 0x23, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x40, 0xe0, 0x00, 0x00 },
{ 0xef, 0xe5, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x00, 0x41, 0xfc, 0x21, 0x04, 0x11, 0xfc, 0x00, 0x00, 0x07, 0xff, 0x14, 0x01, 0x15, 0xfd, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x60, 0x00, 0x00 },
{ 0xef, 0xe6, 0x20, 0x40, 0x10, 0x7e, 0x08, 0x40, 0x43, 0xfc, 0x22, 0x04, 0x13, 0xfc, 0x02, 0x04, 0x02, 0x04, 0x13, 0xfc, 0x12, 0x04, 0x22, 0x04, 0x23, 0xfc, 0x41, 0x08, 0x42, 0x04, 0x04, 0x02, 0x00, 0x00 },
{ 0xef, 0xe7, 0x22, 0x10, 0x17, 0x9c, 0x02, 0x24, 0x07, 0x88, 0x42, 0x3e, 0x2f, 0xca, 0x00, 0x0a, 0x07, 0xbf, 0x04, 0x8a, 0x17, 0x8a, 0x14, 0xbe, 0x27, 0x88, 0x24, 0x88, 0x44, 0x88, 0x45, 0x98, 0x00, 0x00 },
{ 0xef, 0xe8, 0x10, 0x00, 0x13, 0xff, 0x10, 0x10, 0x14, 0x10, 0x58, 0x10, 0x50, 0x10, 0x50, 0x90, 0x50, 0x9e, 0x10, 0x90, 0x10, 0x90, 0x28, 0x90, 0x24, 0x90, 0x24, 0x90, 0x43, 0xff, 0x40, 0x00, 0x00, 0x00 },
{ 0xef, 0xe9, 0x00, 0x00, 0x7c, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x10, 0x70, 0x10, 0x00, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00 },
{ 0xef, 0xea, 0x00, 0x00, 0x7d, 0xc7, 0x10, 0x7c, 0x10, 0x44, 0x10, 0x84, 0x7c, 0x84, 0x11, 0xff, 0x10, 0x44, 0x10, 0x44, 0x11, 0x44, 0x1d, 0x84, 0x70, 0x9f, 0x00, 0xc0, 0x01, 0x20, 0x02, 0x1f, 0x00, 0x00 },
{ 0xef, 0xeb, 0x00, 0x00, 0x7f, 0x00, 0x49, 0xff, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x08, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x38, 0x00, 0x00 },
{ 0xef, 0xec, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xfe, 0x48, 0x20, 0x49, 0xfc, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x00, 0x79, 0xfc, 0x49, 0x24, 0x49, 0x24, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0x0c, 0x00, 0x00 },
{ 0xef, 0xed, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x01, 0x10, 0x00, 0x21, 0xff, 0x3c, 0x10, 0x24, 0x10, 0x64, 0x90, 0x24, 0x9e, 0x24, 0x90, 0x24, 0x90, 0x3c, 0x90, 0x01, 0x70, 0x02, 0x1f, 0x00, 0x00 },
{ 0xef, 0xee, 0x00, 0x10, 0x3e, 0x1e, 0x00, 0x10, 0x7f, 0x7e, 0x08, 0x42, 0x08, 0x7e, 0x2a, 0x42, 0x2a, 0x42, 0x2a, 0x7e, 0x2a, 0x42, 0x2a, 0x42, 0x4a, 0x7e, 0x48, 0x00, 0x08, 0x24, 0x08, 0xc3, 0x00, 0x00 },
{ 0xef, 0xef, 0x0c, 0x00, 0x70, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x7c, 0x82, 0x10, 0xfe, 0x18, 0x00, 0x38, 0x0e, 0x34, 0xf0, 0x54, 0x10, 0x50, 0x10, 0x51, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0xfe, 0x00, 0x00 },
{ 0xef, 0xf0, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x18, 0x3c, 0x00, 0x00, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xef, 0xf1, 0x10, 0x10, 0x15, 0xff, 0x54, 0x10, 0x58, 0xfe, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x30, 0xfe, 0x38, 0x92, 0x34, 0x92, 0x54, 0xfe, 0x50, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xef, 0xf2, 0x08, 0x00, 0x11, 0xc3, 0x20, 0x5c, 0x44, 0x84, 0x28, 0x84, 0x11, 0x04, 0x25, 0xdf, 0x7c, 0x44, 0x55, 0x44, 0x11, 0x44, 0x59, 0x44, 0x54, 0x9f, 0x54, 0xc0, 0x11, 0x3e, 0x12, 0x00, 0x00, 0x00 },
{ 0xef, 0xf3, 0x08, 0x00, 0x10, 0xe3, 0x3e, 0x2c, 0x22, 0x44, 0x2a, 0x44, 0x2a, 0x84, 0x22, 0xef, 0x26, 0xa4, 0x7a, 0x24, 0x2a, 0xa4, 0x2a, 0xa4, 0x2a, 0x4f, 0x22, 0x40, 0x42, 0xb0, 0x47, 0x0f, 0x00, 0x00 },
{ 0xef, 0xf4, 0x00, 0x00, 0x3e, 0x00, 0x00, 0xff, 0x7f, 0x08, 0x00, 0x08, 0x3e, 0x08, 0x00, 0x08, 0x3e, 0x08, 0x00, 0x08, 0x00, 0x08, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x38, 0x00, 0x00 },
{ 0xef, 0xf5, 0x00, 0x10, 0x3e, 0x10, 0x00, 0xff, 0x00, 0x00, 0x7f, 0x7e, 0x00, 0x42, 0x3e, 0x7e, 0x00, 0x00, 0x3e, 0xff, 0x00, 0x81, 0x3e, 0x3e, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x38, 0x00, 0x00 },
{ 0xef, 0xf6, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xef, 0xf7, 0x17, 0x00, 0x11, 0x1e, 0x3f, 0x92, 0x4a, 0x52, 0x3f, 0x94, 0x2a, 0x94, 0x32, 0x94, 0x3f, 0x92, 0x20, 0x92, 0x3f, 0x92, 0x04, 0x12, 0x7f, 0xd2, 0x0a, 0x1c, 0x11, 0x10, 0x61, 0x10, 0x00, 0x00 },
{ 0xef, 0xf8, 0x00, 0x00, 0x7f, 0x7f, 0x14, 0x04, 0x14, 0x04, 0x7f, 0x04, 0x55, 0x04, 0x55, 0x04, 0x55, 0x04, 0x67, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0x1c, 0x00, 0x00 },
{ 0xef, 0xf9, 0x08, 0x00, 0x14, 0x00, 0x22, 0xff, 0x40, 0x08, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7e, 0x08, 0x08, 0x08, 0x4a, 0x08, 0x2a, 0x08, 0x28, 0x08, 0x08, 0x08, 0x0e, 0x08, 0x70, 0x38, 0x00, 0x00 },
{ 0xef, 0xfa, 0x08, 0x00, 0x14, 0xff, 0x22, 0x08, 0x40, 0x08, 0x3e, 0x08, 0x08, 0x48, 0x08, 0x48, 0x7e, 0x4e, 0x08, 0x48, 0x4a, 0x48, 0x2a, 0x48, 0x28, 0x48, 0x08, 0x48, 0x0e, 0x48, 0x71, 0xff, 0x00, 0x00 },
{ 0xef, 0xfb, 0x18, 0x00, 0x14, 0xe3, 0x22, 0x2c, 0x20, 0x44, 0x7e, 0x44, 0x08, 0x84, 0x08, 0xef, 0x7e, 0x24, 0x08, 0xa4, 0x4a, 0xa4, 0x2a, 0xa4, 0x28, 0x4f, 0x08, 0x60, 0x0e, 0x9f, 0x79, 0x00, 0x00, 0x00 },
{ 0xef, 0xfc, 0x08, 0x10, 0x14, 0x10, 0x22, 0xff, 0x40, 0x81, 0x3e, 0x00, 0x08, 0x7e, 0x08, 0x08, 0x7e, 0x08, 0x08, 0x48, 0x4a, 0x4e, 0x2a, 0x48, 0x28, 0x48, 0x08, 0xa8, 0x0e, 0x98, 0x71, 0x07, 0x00, 0x00 },
{ 0xef, 0xfd, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x80, 0x3c, 0x0e, 0x04, 0xf0, 0x08, 0x10, 0x3c, 0xfe, 0x04, 0x10, 0x25, 0xff, 0x18, 0x00, 0x16, 0x00, 0x61, 0xff, 0x00, 0x00 },
{ 0xef, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x7e, 0x10, 0x00, 0xfe, 0x04, 0x10, 0x45, 0xff, 0x44, 0x00, 0x24, 0xfe, 0x28, 0x92, 0x28, 0x92, 0x08, 0xfe, 0x1e, 0x82, 0x60, 0x82, 0x00, 0x82, 0x00, 0x8e, 0x00, 0x00 },
{ 0xf0, 0xa1, 0x08, 0x06, 0x7f, 0x78, 0x08, 0x52, 0x3e, 0x89, 0x08, 0x7e, 0x7f, 0x12, 0x00, 0x12, 0x3e, 0xff, 0x2a, 0x12, 0x2a, 0x12, 0x3e, 0x7e, 0x22, 0x10, 0x22, 0x10, 0x22, 0x10, 0x26, 0x30, 0x00, 0x00 },
{ 0xf0, 0xa2, 0x00, 0x00, 0x01, 0xff, 0x7c, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x30, 0x46, 0x01, 0x81, 0x00, 0x00 },
{ 0xf0, 0xa3, 0x00, 0x00, 0x27, 0xe4, 0x24, 0x24, 0x27, 0xe4, 0x24, 0x24, 0x27, 0xe4, 0x20, 0x04, 0x3e, 0x7c, 0x02, 0x40, 0x02, 0x40, 0x7e, 0x7e, 0x22, 0x44, 0x22, 0x44, 0x22, 0x44, 0x42, 0x44, 0x00, 0x00 },
{ 0xf0, 0xa4, 0x04, 0x01, 0x24, 0x11, 0x3f, 0x91, 0x44, 0x11, 0x04, 0x11, 0x7f, 0xd1, 0x04, 0x11, 0x04, 0x11, 0x3f, 0x91, 0x24, 0x91, 0x24, 0x91, 0x24, 0x81, 0x24, 0x81, 0x25, 0x81, 0x04, 0x07, 0x00, 0x00 },
{ 0xf0, 0xa5, 0x02, 0x01, 0x7f, 0xe1, 0x08, 0x89, 0x05, 0x29, 0x7a, 0xc9, 0x2a, 0xa9, 0x2a, 0xa9, 0x5a, 0xd9, 0x00, 0x09, 0x10, 0x49, 0x1f, 0xc9, 0x10, 0x41, 0x1f, 0xc1, 0x10, 0x41, 0x20, 0x47, 0x00, 0x00 },
{ 0xf0, 0xa6, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xfe, 0x48, 0x88, 0x48, 0x88, 0x48, 0x50, 0x4b, 0xff, 0x4a, 0x21, 0x4a, 0x21, 0x49, 0xfc, 0x49, 0x24, 0x79, 0x24, 0x01, 0x24, 0x01, 0x2c, 0x00, 0x20, 0x00, 0x00 },
{ 0xf0, 0xa7, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x7c, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x90, 0x1c, 0x9e, 0x70, 0x90, 0x00, 0x90, 0x01, 0x50, 0x02, 0x3f, 0x00, 0x00 },
{ 0xf0, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x04, 0x08, 0x04, 0x10, 0x7f, 0xff, 0x40, 0x81, 0x40, 0x81, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x9c, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xa9, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x1f, 0xfe, 0x10, 0x80, 0x10, 0x80, 0x3f, 0xff, 0x21, 0x81, 0x02, 0x81, 0x04, 0x81, 0x18, 0x81, 0x60, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xaa, 0x10, 0x84, 0x10, 0x48, 0x11, 0xfe, 0x58, 0x22, 0x54, 0x22, 0x55, 0xfe, 0x51, 0x20, 0x11, 0x20, 0x13, 0xff, 0x12, 0x21, 0x10, 0x61, 0x10, 0xa1, 0x13, 0x26, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf0, 0xab, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x1d, 0xff, 0x70, 0x10, 0x10, 0x90, 0x10, 0x9e, 0x10, 0x90, 0x10, 0x90, 0x11, 0x50, 0x32, 0x3f, 0x00, 0x00 },
{ 0xf0, 0xac, 0x10, 0x84, 0x10, 0x48, 0x11, 0xfe, 0x7c, 0x22, 0x10, 0x22, 0x11, 0xfe, 0x39, 0x20, 0x39, 0x20, 0x37, 0xff, 0x52, 0x21, 0x50, 0x61, 0x50, 0xa1, 0x13, 0x26, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf0, 0xad, 0x20, 0x20, 0x17, 0xff, 0x00, 0x88, 0x00, 0x51, 0x47, 0xae, 0x22, 0xaa, 0x12, 0xa9, 0x05, 0xac, 0x02, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x23, 0xfe, 0x24, 0x02, 0x44, 0x02, 0x48, 0x02, 0x00, 0x00 },
{ 0xf0, 0xae, 0x08, 0x00, 0x1f, 0x3f, 0x31, 0x21, 0x4a, 0x22, 0x24, 0x14, 0x18, 0x08, 0x17, 0xf4, 0x60, 0x03, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x8c, 0x10, 0x82, 0x60, 0x81, 0x03, 0x80, 0x00, 0x00 },
{ 0xf0, 0xaf, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x3f, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x3f, 0xfe, 0x20, 0x80, 0x7f, 0xff, 0x42, 0x81, 0x04, 0x81, 0x18, 0x81, 0x60, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xb0, 0x00, 0x20, 0x3b, 0xff, 0x28, 0x88, 0x28, 0x51, 0x2f, 0xae, 0x3a, 0xaa, 0x2a, 0xaa, 0x2d, 0x3d, 0x28, 0x20, 0x39, 0x02, 0x29, 0xfe, 0x29, 0x02, 0x29, 0xfe, 0x4a, 0x02, 0x5a, 0x02, 0x00, 0x00 },
{ 0xf0, 0xb1, 0x02, 0x20, 0x7f, 0xff, 0x02, 0xa0, 0x7f, 0xff, 0x02, 0x21, 0x7d, 0x5e, 0x14, 0x94, 0x24, 0x92, 0x4c, 0xb9, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x10, 0x08, 0x20, 0x08, 0x00, 0x00 },
{ 0xf0, 0xb2, 0x14, 0x02, 0x3f, 0x92, 0x44, 0x12, 0x7f, 0xd2, 0x04, 0x12, 0x3f, 0x92, 0x24, 0x82, 0x25, 0x86, 0x04, 0x80, 0x7f, 0xff, 0x06, 0x44, 0x1c, 0x28, 0x64, 0x10, 0x07, 0x8c, 0x1c, 0x03, 0x00, 0x00 },
{ 0xf0, 0xb3, 0x00, 0x20, 0x3c, 0x22, 0x01, 0xfa, 0x7e, 0x24, 0x00, 0x28, 0x3d, 0xff, 0x00, 0x28, 0x3c, 0x44, 0x00, 0xfe, 0x01, 0x42, 0x3e, 0x42, 0x24, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x3c, 0x7e, 0x00, 0x00 },
{ 0xf0, 0xb4, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x82, 0x24, 0x44, 0x3d, 0xff, 0x09, 0x11, 0x09, 0x11, 0x28, 0xfe, 0x2e, 0x92, 0x28, 0x92, 0x28, 0x92, 0x28, 0x92, 0x2e, 0x96, 0x70, 0x10, 0x00, 0x00 },
{ 0xf0, 0xb5, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x7c, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x54, 0x00, 0x6d, 0xff, 0x44, 0x10, 0x44, 0x90, 0x7c, 0x9e, 0x44, 0x90, 0x45, 0x50, 0x7e, 0x3f, 0x00, 0x00 },
{ 0xf0, 0xb6, 0x00, 0x20, 0x78, 0x50, 0x48, 0x88, 0x51, 0x04, 0x52, 0x02, 0x65, 0xfd, 0x50, 0x20, 0x50, 0x20, 0x4b, 0xfe, 0x48, 0x20, 0x49, 0x24, 0x71, 0x22, 0x42, 0x22, 0x40, 0x20, 0x40, 0x60, 0x00, 0x00 },
{ 0xf0, 0xb7, 0x01, 0x00, 0x79, 0xde, 0x4a, 0x52, 0x55, 0x4c, 0x52, 0x88, 0x61, 0x04, 0x56, 0xfb, 0x50, 0x00, 0x48, 0x00, 0x4b, 0xff, 0x48, 0x20, 0x71, 0x24, 0x41, 0x22, 0x42, 0x22, 0x40, 0x60, 0x00, 0x00 },
{ 0xf0, 0xb8, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x22, 0x7d, 0x5c, 0x24, 0x92, 0x48, 0x99, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x10, 0x08, 0x00, 0x00 },
{ 0xf0, 0xb9, 0x00, 0x00, 0x3e, 0x7e, 0x22, 0x10, 0x3e, 0x7e, 0x22, 0x42, 0x3e, 0x7e, 0x00, 0x42, 0x00, 0x7e, 0x7f, 0x42, 0x08, 0x7e, 0x28, 0x00, 0x2e, 0x26, 0x28, 0xc1, 0x58, 0x00, 0x47, 0xff, 0x00, 0x00 },
{ 0xf0, 0xba, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x01, 0x43, 0x7c, 0x9c, 0x24, 0x94, 0x24, 0x92, 0x58, 0xbd, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x00, 0x00 },
{ 0xf0, 0xbb, 0x08, 0x00, 0x08, 0x7e, 0x08, 0x42, 0x14, 0x42, 0x12, 0x42, 0x21, 0x7e, 0x40, 0x42, 0x08, 0x42, 0x08, 0x42, 0x08, 0x7e, 0x14, 0x42, 0x12, 0x42, 0x21, 0x42, 0x40, 0x42, 0x00, 0xff, 0x00, 0x00 },
{ 0xf0, 0xbc, 0x02, 0x20, 0x22, 0x22, 0x12, 0x22, 0x0a, 0x24, 0x0a, 0x28, 0x02, 0x20, 0x02, 0x20, 0x06, 0x38, 0x1a, 0x26, 0x62, 0x21, 0x04, 0x20, 0x04, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xf0, 0xbd, 0x00, 0x00, 0x43, 0xff, 0x22, 0x01, 0x12, 0x21, 0x02, 0xfd, 0x02, 0x21, 0x02, 0x21, 0x12, 0xfd, 0x12, 0x01, 0x22, 0x79, 0x22, 0x49, 0x42, 0x49, 0x44, 0x79, 0x04, 0x01, 0x08, 0x07, 0x00, 0x00 },
{ 0xf0, 0xbe, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0x10, 0x22, 0xff, 0x3e, 0x11, 0x22, 0x11, 0x22, 0x11, 0x22, 0x21, 0x3e, 0x21, 0x22, 0x21, 0x23, 0x41, 0x2c, 0x42, 0x70, 0x82, 0x01, 0x0c, 0x00, 0x00 },
{ 0xf0, 0xbf, 0x00, 0x80, 0x00, 0x8f, 0x77, 0xe9, 0x50, 0x89, 0x50, 0x8d, 0x57, 0xeb, 0x54, 0x29, 0x57, 0xe9, 0x54, 0x2d, 0x57, 0xeb, 0x50, 0x89, 0x70, 0x89, 0x07, 0xf1, 0x00, 0x91, 0x00, 0xa3, 0x00, 0x00 },
{ 0xf0, 0xc0, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x00, 0x82, 0x3f, 0xfe, 0x20, 0x80, 0x20, 0x80, 0x20, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x00, 0x81, 0x00, 0x81, 0x00, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xc1, 0x00, 0x01, 0x3f, 0xc2, 0x20, 0x44, 0x24, 0x58, 0x2f, 0x40, 0x24, 0x41, 0x2f, 0x42, 0x20, 0x44, 0x2f, 0x58, 0x29, 0x40, 0x29, 0x40, 0x2f, 0x41, 0x40, 0x42, 0x40, 0x44, 0x41, 0xd8, 0x00, 0x00 },
{ 0xf0, 0xc2, 0x10, 0x88, 0x10, 0x88, 0x13, 0xfe, 0x78, 0x88, 0x10, 0x88, 0x10, 0x88, 0x17, 0xff, 0x18, 0x00, 0x71, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x31, 0xfc, 0x00, 0x00 },
{ 0xf0, 0xc3, 0x10, 0x00, 0x10, 0x7c, 0x10, 0x44, 0x7c, 0x7c, 0x10, 0x00, 0x11, 0xef, 0x11, 0x29, 0x1d, 0xef, 0x70, 0x10, 0x10, 0x10, 0x11, 0xff, 0x10, 0x38, 0x10, 0x54, 0x11, 0x93, 0x30, 0x10, 0x00, 0x00 },
{ 0xf0, 0xc4, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xc5, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x02, 0x40, 0x22, 0x44, 0x12, 0x48, 0x02, 0x50, 0x06, 0x70, 0x1a, 0x4c, 0x62, 0x42, 0x04, 0x41, 0x08, 0x41, 0x30, 0x3f, 0x00, 0x00 },
{ 0xf0, 0xc6, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xf0, 0xc7, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf0, 0xc8, 0x08, 0x00, 0x08, 0x3e, 0x7f, 0x22, 0x08, 0x22, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x08, 0x3e, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x42, 0x08, 0x42, 0x08, 0x8e, 0x00, 0x00 },
{ 0xf0, 0xc9, 0x08, 0x40, 0x08, 0x40, 0x08, 0xfe, 0x10, 0x84, 0x15, 0x48, 0x34, 0x30, 0x34, 0xcc, 0x55, 0x03, 0x54, 0x20, 0x15, 0xfe, 0x14, 0x70, 0x14, 0xa8, 0x11, 0x24, 0x12, 0x23, 0x10, 0x20, 0x00, 0x00 },
{ 0xf0, 0xca, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x11, 0xc4, 0x12, 0xa4, 0x0c, 0x98, 0x30, 0x86, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x11, 0xc4, 0x12, 0xa4, 0x0c, 0x98, 0x30, 0x86, 0x00, 0x00 },
{ 0xf0, 0xcb, 0x10, 0x28, 0x10, 0x28, 0x11, 0xff, 0x7c, 0x28, 0x11, 0xff, 0x11, 0x29, 0x39, 0xff, 0x39, 0x29, 0x35, 0xff, 0x54, 0x00, 0x50, 0xfe, 0x50, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf0, 0xcc, 0x20, 0x48, 0x10, 0x48, 0x0b, 0xff, 0x00, 0x48, 0x43, 0xff, 0x22, 0x49, 0x13, 0xff, 0x02, 0x49, 0x03, 0xff, 0x10, 0x00, 0x11, 0xfe, 0x21, 0x02, 0x21, 0xfe, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xf0, 0xcd, 0x21, 0x00, 0x11, 0x0f, 0x0f, 0xc9, 0x01, 0x09, 0x47, 0xc9, 0x24, 0x4f, 0x17, 0xc9, 0x04, 0x49, 0x07, 0xc9, 0x11, 0x0f, 0x11, 0x09, 0x27, 0xc9, 0x21, 0x11, 0x41, 0x11, 0x41, 0x23, 0x00, 0x00 },
{ 0xf0, 0xce, 0x00, 0x00, 0x3e, 0x7f, 0x22, 0x11, 0x22, 0x11, 0x22, 0x21, 0x3e, 0xc6, 0x22, 0x00, 0x22, 0x7f, 0x22, 0x41, 0x3e, 0x41, 0x00, 0x7f, 0x00, 0x00, 0x12, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xf0, 0xcf, 0x10, 0x00, 0x10, 0x7c, 0x12, 0x44, 0x54, 0x7c, 0x58, 0x00, 0x51, 0xef, 0x51, 0x29, 0x11, 0xef, 0x10, 0x10, 0x11, 0xff, 0x28, 0x38, 0x24, 0x54, 0x20, 0x92, 0x41, 0x11, 0x40, 0x10, 0x00, 0x00 },
{ 0xf0, 0xd0, 0x00, 0x0c, 0x00, 0xf0, 0x1f, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0x11, 0x08, 0x11, 0x08, 0x21, 0x08, 0x21, 0x08, 0x21, 0x04, 0x21, 0x04, 0x41, 0x02, 0x41, 0x01, 0x00, 0x00 },
{ 0xf0, 0xd1, 0x00, 0x00, 0x7c, 0xf8, 0x10, 0x88, 0x10, 0xf8, 0x10, 0x00, 0x7f, 0xde, 0x12, 0x52, 0x13, 0xde, 0x10, 0x20, 0x13, 0xfe, 0x1c, 0x70, 0x70, 0xa8, 0x01, 0x24, 0x02, 0x23, 0x00, 0x20, 0x00, 0x00 },
{ 0xf0, 0xd2, 0x00, 0x48, 0x78, 0x48, 0x48, 0x48, 0x4a, 0x49, 0x49, 0x4a, 0x79, 0x4c, 0x48, 0x48, 0x48, 0xcc, 0x4b, 0x4a, 0x78, 0x49, 0x48, 0x48, 0x48, 0x88, 0x48, 0x89, 0x79, 0x09, 0x02, 0x0f, 0x00, 0x00 },
{ 0xf0, 0xd3, 0x00, 0x00, 0x3c, 0x7c, 0x00, 0x44, 0x00, 0x44, 0x7e, 0x44, 0x08, 0x7c, 0x08, 0x44, 0x2a, 0x44, 0x2a, 0x44, 0x2a, 0x7c, 0x2a, 0x44, 0x4a, 0x44, 0x48, 0x44, 0x08, 0x44, 0x09, 0xff, 0x00, 0x00 },
{ 0xf0, 0xd4, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x20, 0x00, 0x20, 0x7f, 0x7f, 0x08, 0x50, 0x08, 0x90, 0x2a, 0x1e, 0x2a, 0x10, 0x2a, 0x10, 0x2a, 0x1e, 0x4a, 0x10, 0x48, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xf0, 0xd5, 0x0c, 0x00, 0x70, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x7c, 0x84, 0x10, 0xfc, 0x18, 0x84, 0x38, 0x84, 0x34, 0x84, 0x54, 0xfc, 0x50, 0x84, 0x50, 0x84, 0x10, 0x84, 0x10, 0x84, 0x13, 0xff, 0x00, 0x00 },
{ 0xf0, 0xd6, 0x0c, 0x00, 0x71, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x7d, 0x7a, 0x11, 0x22, 0x11, 0x7a, 0x39, 0x22, 0x35, 0x02, 0x51, 0x7a, 0x51, 0x4a, 0x11, 0x7a, 0x12, 0x02, 0x12, 0x02, 0x14, 0x0e, 0x00, 0x00 },
{ 0xf0, 0xd7, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x18, 0x3c, 0x00, 0x00, 0x02, 0x40, 0x22, 0x44, 0x12, 0x58, 0x02, 0x60, 0x0e, 0x58, 0x32, 0x44, 0x04, 0x41, 0x18, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xf0, 0xd8, 0x08, 0x00, 0x08, 0x7e, 0x4a, 0x42, 0x2c, 0x42, 0x08, 0x42, 0x7e, 0x7e, 0x08, 0x42, 0x18, 0x42, 0x1c, 0x42, 0x2a, 0x7e, 0x28, 0x42, 0x48, 0x42, 0x48, 0x42, 0x08, 0x42, 0x08, 0xff, 0x00, 0x00 },
{ 0xf0, 0xd9, 0x10, 0x28, 0x10, 0x28, 0x55, 0xff, 0x58, 0x28, 0x11, 0xff, 0x7d, 0x29, 0x11, 0xff, 0x11, 0x29, 0x39, 0xff, 0x34, 0x00, 0x50, 0xfe, 0x50, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf0, 0xda, 0x08, 0x00, 0x08, 0x7e, 0x52, 0x42, 0x22, 0x42, 0x14, 0x42, 0x08, 0x7e, 0x12, 0x42, 0x7f, 0x42, 0x09, 0x42, 0x08, 0x7e, 0x2a, 0x42, 0x29, 0x42, 0x49, 0x42, 0x48, 0x42, 0x08, 0xff, 0x00, 0x00 },
{ 0xf0, 0xdb, 0x10, 0x7c, 0x10, 0x44, 0x24, 0x7c, 0x44, 0x00, 0x29, 0xef, 0x11, 0x29, 0x11, 0xef, 0x24, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x54, 0x38, 0x54, 0x54, 0x50, 0x92, 0x11, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xf0, 0xdc, 0x07, 0x10, 0x38, 0x3f, 0x3f, 0x22, 0x21, 0x54, 0x3f, 0x08, 0x20, 0x94, 0x5f, 0xfb, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x88, 0x1f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xdd, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0xf8, 0x20, 0x88, 0x10, 0xf8, 0x00, 0x00, 0x43, 0xde, 0x22, 0x52, 0x03, 0xde, 0x10, 0x20, 0x27, 0xff, 0x20, 0xa8, 0x41, 0x24, 0x46, 0x23, 0x00, 0x00 },
{ 0xf0, 0xde, 0x00, 0x00, 0x3f, 0xfc, 0x04, 0x84, 0x12, 0x48, 0x09, 0x30, 0x00, 0xc0, 0x07, 0x38, 0x78, 0x87, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0xbe, 0x7f, 0xc1, 0x00, 0x00 },
{ 0xf0, 0xdf, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x11, 0x7e, 0x11, 0x00, 0x21, 0x3c, 0x21, 0x00, 0x41, 0x3c, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7f, 0x24, 0x41, 0x24, 0x41, 0x24, 0x41, 0x3c, 0x7f, 0x00, 0x00 },
{ 0xf0, 0xe0, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x81, 0x7e, 0x91, 0x00, 0xbd, 0x3c, 0x91, 0x00, 0xbd, 0x3c, 0x81, 0x00, 0x81, 0x00, 0xbd, 0x3c, 0xa5, 0x24, 0xa5, 0x25, 0x3d, 0x25, 0x01, 0x3e, 0x07, 0x00, 0x00 },
{ 0xf0, 0xe1, 0x08, 0x10, 0x08, 0x52, 0x3e, 0x51, 0x08, 0x91, 0x08, 0x7e, 0x7f, 0x42, 0x08, 0x7e, 0x08, 0x42, 0x2f, 0x7e, 0x28, 0x42, 0x28, 0x42, 0x38, 0x46, 0x28, 0x00, 0x46, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xf0, 0xe2, 0x00, 0x00, 0x3c, 0x7c, 0x24, 0x44, 0x24, 0x7c, 0x24, 0x00, 0x3d, 0xef, 0x09, 0x29, 0x09, 0xef, 0x28, 0x10, 0x2c, 0x10, 0x29, 0xff, 0x28, 0x38, 0x28, 0x54, 0x2d, 0x93, 0x70, 0x10, 0x00, 0x00 },
{ 0xf0, 0xe3, 0x21, 0x20, 0x11, 0x20, 0x0b, 0xfe, 0x02, 0x20, 0x44, 0x20, 0x27, 0xff, 0x10, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x71, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf0, 0xe4, 0x20, 0x48, 0x13, 0xff, 0x08, 0x48, 0x03, 0xff, 0x42, 0x49, 0x23, 0xff, 0x12, 0x49, 0x03, 0xff, 0x01, 0x02, 0x71, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf0, 0xe5, 0x08, 0x20, 0x14, 0x20, 0x22, 0x40, 0x40, 0x7f, 0x3e, 0x41, 0x08, 0x81, 0x08, 0x81, 0x7e, 0x01, 0x08, 0x21, 0x4a, 0x11, 0x2a, 0x11, 0x28, 0x01, 0x08, 0x01, 0x0e, 0x01, 0x70, 0x0e, 0x00, 0x00 },
{ 0xf0, 0xe6, 0x00, 0x00, 0x7c, 0xfc, 0x44, 0x84, 0x48, 0x84, 0x48, 0x84, 0x50, 0xfc, 0x48, 0x84, 0x48, 0x84, 0x44, 0x84, 0x44, 0xfc, 0x44, 0x84, 0x58, 0x84, 0x40, 0x84, 0x40, 0x84, 0x43, 0xff, 0x00, 0x00 },
{ 0xf0, 0xe7, 0x00, 0x12, 0x3f, 0xa4, 0x20, 0xbf, 0x24, 0xe4, 0x2e, 0xa4, 0x24, 0xa4, 0x2e, 0xbf, 0x24, 0xa4, 0x20, 0xa4, 0x2e, 0xa4, 0x2a, 0xbf, 0x2a, 0xa4, 0x2e, 0xa4, 0x40, 0xa4, 0x43, 0xbf, 0x00, 0x00 },
{ 0xf0, 0xe8, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x1f, 0xff, 0x00, 0x01, 0x24, 0x91, 0x22, 0x49, 0x42, 0x46, 0x00, 0x00 },
{ 0xf0, 0xe9, 0x20, 0x80, 0x20, 0x80, 0x21, 0xff, 0x7d, 0x00, 0x22, 0x40, 0x20, 0x40, 0x3c, 0xfe, 0x24, 0x90, 0x25, 0x10, 0x25, 0xff, 0x24, 0x28, 0x24, 0x28, 0x44, 0x44, 0x44, 0x82, 0x59, 0x01, 0x00, 0x00 },
{ 0xf0, 0xea, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x7f, 0x10, 0x80, 0x10, 0x20, 0x1e, 0x7e, 0x12, 0x90, 0x12, 0xff, 0x22, 0x10, 0x22, 0x2c, 0x4c, 0xc3, 0x00, 0x00 },
{ 0xf0, 0xeb, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x14, 0x80, 0x12, 0x80, 0x21, 0x80, 0x40, 0x7f, 0x00, 0x00 },
{ 0xf0, 0xec, 0x19, 0x10, 0x25, 0x10, 0x41, 0x1f, 0x03, 0xd0, 0x7d, 0x20, 0x11, 0x28, 0x11, 0xcf, 0x7d, 0x54, 0x11, 0x44, 0x15, 0x5f, 0x55, 0x44, 0x31, 0x44, 0x12, 0x4a, 0x1a, 0x4a, 0x64, 0x91, 0x00, 0x00 },
{ 0xf0, 0xed, 0x02, 0x00, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x00, 0x04, 0x00, 0x08, 0xfe, 0x08, 0x04, 0x18, 0x08, 0x28, 0x10, 0x49, 0xff, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x70, 0x00, 0x00 },
{ 0xf0, 0xee, 0x08, 0xf8, 0x08, 0x08, 0x1f, 0xfc, 0x22, 0x42, 0x5f, 0xfc, 0x12, 0x44, 0x14, 0x24, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xf0, 0xef, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x04, 0x08, 0x04, 0x08, 0x0a, 0x14, 0x11, 0x22, 0x20, 0x40, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf0, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x7d, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x1c, 0x10, 0x70, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x31, 0xff, 0x00, 0x00 },
{ 0xf0, 0xf1, 0x04, 0x20, 0x44, 0x20, 0x29, 0xff, 0x10, 0x00, 0x30, 0x84, 0x50, 0x84, 0x09, 0x4a, 0x0a, 0x31, 0x18, 0x00, 0x28, 0x20, 0x48, 0x20, 0x0b, 0xff, 0x08, 0x20, 0x08, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xf0, 0xf2, 0x08, 0x10, 0x08, 0x10, 0x09, 0xff, 0x11, 0x01, 0x11, 0x01, 0x30, 0x7c, 0x30, 0x00, 0x50, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x94, 0x10, 0x92, 0x11, 0x11, 0x12, 0x11, 0x10, 0x70, 0x00, 0x00 },
{ 0xf0, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x88, 0x08, 0x88, 0x10, 0x84, 0x20, 0x82, 0x03, 0x80, 0x00, 0x00 },
{ 0xf0, 0xf4, 0x08, 0x84, 0x08, 0x84, 0x11, 0x08, 0x21, 0x8c, 0x4a, 0x52, 0x0c, 0x21, 0x10, 0x00, 0x10, 0x10, 0x30, 0x90, 0x50, 0x9e, 0x10, 0x90, 0x11, 0x90, 0x11, 0x50, 0x12, 0x30, 0x14, 0x0f, 0x00, 0x00 },
{ 0xf0, 0xf5, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x19, 0x01, 0x55, 0x01, 0x54, 0x7c, 0x50, 0x00, 0x50, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x94, 0x10, 0x92, 0x11, 0x11, 0x12, 0x11, 0x10, 0x70, 0x00, 0x00 },
{ 0xf0, 0xf6, 0x08, 0x88, 0x10, 0x88, 0x21, 0x54, 0x4a, 0x02, 0x10, 0x20, 0x31, 0x20, 0x51, 0x3e, 0x11, 0x20, 0x12, 0xa0, 0x14, 0x7f, 0x10, 0x00, 0x04, 0x80, 0x24, 0x42, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xf0, 0xf7, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7d, 0x01, 0x11, 0x01, 0x11, 0x7d, 0x38, 0x00, 0x38, 0x00, 0x35, 0xff, 0x54, 0x10, 0x50, 0x92, 0x50, 0x92, 0x11, 0x11, 0x12, 0x11, 0x10, 0x30, 0x00, 0x00 },
{ 0xf0, 0xf8, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x04, 0x01, 0x44, 0x01, 0x21, 0xfc, 0x10, 0x00, 0x00, 0x00, 0x07, 0xff, 0x10, 0x20, 0x12, 0x24, 0x22, 0x24, 0x24, 0x22, 0x48, 0x21, 0x40, 0xe0, 0x00, 0x00 },
{ 0xf0, 0xf9, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x01, 0x11, 0x01, 0x11, 0x7d, 0x7c, 0x00, 0x10, 0x00, 0x11, 0xff, 0x10, 0x10, 0x10, 0x94, 0x1c, 0x92, 0x71, 0x11, 0x02, 0x11, 0x00, 0x30, 0x00, 0x00 },
{ 0xf0, 0xfa, 0x0c, 0x1e, 0x71, 0xe0, 0x10, 0x20, 0x13, 0xfe, 0x7c, 0x20, 0x11, 0xfe, 0x19, 0x22, 0x39, 0xfe, 0x35, 0x22, 0x55, 0xfe, 0x50, 0x20, 0x50, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x13, 0xff, 0x00, 0x00 },
{ 0xf0, 0xfb, 0x10, 0x20, 0x10, 0x20, 0x24, 0x7e, 0x44, 0x42, 0x28, 0xa4, 0x11, 0x18, 0x10, 0x18, 0x24, 0x24, 0x7c, 0x42, 0x11, 0xb1, 0x54, 0x0c, 0x54, 0x00, 0x50, 0x70, 0x10, 0x0c, 0x10, 0x02, 0x00, 0x00 },
{ 0xf0, 0xfc, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x45, 0x01, 0x29, 0x01, 0x10, 0xfe, 0x10, 0x00, 0x24, 0x00, 0x7d, 0xff, 0x10, 0x10, 0x54, 0x92, 0x54, 0x91, 0x50, 0x91, 0x11, 0x11, 0x10, 0x30, 0x00, 0x00 },
{ 0xf0, 0xfd, 0x10, 0xa4, 0x10, 0xa4, 0x25, 0x24, 0x45, 0x24, 0x2a, 0x5a, 0x10, 0x49, 0x10, 0x80, 0x24, 0x84, 0x7d, 0x94, 0x16, 0x97, 0x50, 0x94, 0x54, 0x94, 0x54, 0x9c, 0x10, 0xa4, 0x10, 0xa3, 0x00, 0x00 },
{ 0xf0, 0xfe, 0x00, 0x07, 0x3c, 0xf8, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x3c, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x24, 0xfe, 0x44, 0x10, 0x4d, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa1, 0x00, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x22, 0x81, 0x22, 0x81, 0x3e, 0x3c, 0x08, 0x00, 0x08, 0x00, 0x28, 0xff, 0x2e, 0x10, 0x28, 0x52, 0x28, 0x51, 0x28, 0x91, 0x2e, 0x10, 0x70, 0x30, 0x00, 0x00 },
{ 0xf1, 0xa2, 0x00, 0x06, 0x3e, 0xf8, 0x22, 0x10, 0x23, 0xff, 0x22, 0x10, 0x3e, 0xfe, 0x08, 0x92, 0x08, 0xfe, 0x28, 0x92, 0x2e, 0xfe, 0x28, 0x10, 0x28, 0xfe, 0x28, 0x10, 0x2e, 0x10, 0x71, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa3, 0x18, 0x06, 0x24, 0xf8, 0x40, 0x10, 0x01, 0xff, 0x7c, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x7c, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x54, 0x10, 0x34, 0xfe, 0x10, 0x10, 0x18, 0x10, 0x61, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa4, 0x18, 0x10, 0x25, 0xff, 0x40, 0x44, 0x00, 0x28, 0x7d, 0xff, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x54, 0xfe, 0x34, 0x10, 0x10, 0xfe, 0x18, 0x10, 0x61, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa5, 0x08, 0x20, 0x08, 0x20, 0x10, 0x40, 0x13, 0xff, 0x30, 0x40, 0x30, 0x40, 0x50, 0x80, 0x10, 0x80, 0x11, 0xfe, 0x11, 0x10, 0x12, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x13, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa6, 0x00, 0x80, 0x00, 0x80, 0x08, 0x84, 0x08, 0x84, 0x10, 0x88, 0x18, 0x8c, 0x24, 0x92, 0x42, 0xa1, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa7, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xfe, 0x08, 0x40, 0x10, 0x40, 0x20, 0x40, 0x40, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa8, 0x00, 0x40, 0x00, 0x40, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x40, 0x22, 0x44, 0x22, 0x44, 0x25, 0x4a, 0x28, 0xd1, 0x20, 0x40, 0x27, 0xfc, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x5f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xa9, 0x10, 0x20, 0x10, 0x20, 0x11, 0x24, 0x7d, 0x24, 0x11, 0x24, 0x11, 0xaa, 0x12, 0x6a, 0x12, 0x31, 0x1c, 0x20, 0x71, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x33, 0xff, 0x00, 0x00 },
{ 0xf1, 0xaa, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x02, 0x20, 0x7e, 0x3f, 0x02, 0x20, 0x3e, 0x3e, 0x02, 0x20, 0x7c, 0x3f, 0x04, 0x20, 0x08, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xf1, 0xab, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xac, 0x08, 0x40, 0x08, 0x20, 0x10, 0x10, 0x10, 0x00, 0x37, 0xff, 0x30, 0x20, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xf1, 0xad, 0x08, 0x20, 0x09, 0x20, 0x09, 0x20, 0x13, 0xfe, 0x12, 0x20, 0x34, 0x20, 0x30, 0x20, 0x57, 0xff, 0x50, 0x70, 0x10, 0xa8, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x14, 0x21, 0x10, 0x20, 0x00, 0x00 },
{ 0xf1, 0xae, 0x09, 0x08, 0x09, 0x08, 0x11, 0x10, 0x17, 0xdf, 0x31, 0x32, 0x31, 0x52, 0x51, 0x12, 0x57, 0xd2, 0x14, 0x54, 0x14, 0x4c, 0x14, 0x48, 0x14, 0x48, 0x17, 0xd4, 0x10, 0x22, 0x10, 0x41, 0x00, 0x00 },
{ 0xf1, 0xaf, 0x10, 0x10, 0x10, 0x90, 0x10, 0x90, 0x10, 0xfe, 0x7d, 0x10, 0x26, 0x10, 0x24, 0x10, 0x25, 0xff, 0x44, 0x30, 0x68, 0x58, 0x58, 0x58, 0x08, 0x94, 0x15, 0x12, 0x22, 0x11, 0x40, 0x10, 0x00, 0x00 },
{ 0xf1, 0xb0, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xf1, 0xb1, 0x00, 0x00, 0x01, 0xfe, 0x79, 0x02, 0x49, 0x02, 0x49, 0x02, 0x49, 0x02, 0x49, 0xfe, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x78, 0x88, 0x00, 0x88, 0x01, 0x09, 0x02, 0x09, 0x0c, 0x0f, 0x00, 0x00 },
{ 0xf1, 0xb2, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x82, 0x13, 0xf2, 0x10, 0x82, 0x10, 0x82, 0x17, 0xfa, 0x10, 0x02, 0x13, 0xf2, 0x12, 0x12, 0x12, 0x12, 0x23, 0xf2, 0x20, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf1, 0xb3, 0x01, 0x08, 0x71, 0x08, 0x57, 0xdf, 0x52, 0x10, 0x52, 0x28, 0x52, 0x08, 0x53, 0xcf, 0x52, 0x54, 0x52, 0x44, 0x52, 0x5f, 0x72, 0x44, 0x02, 0x44, 0x04, 0x4a, 0x04, 0x52, 0x09, 0xa1, 0x00, 0x00 },
{ 0xf1, 0xb4, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x00, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x08, 0x13, 0xe4, 0x60, 0x83, 0x1f, 0xfc, 0x01, 0x40, 0x06, 0x30, 0x38, 0x0e, 0x00, 0x00 },
{ 0xf1, 0xb5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x81, 0x40, 0x81, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf1, 0xb6, 0x08, 0x02, 0x08, 0x42, 0x08, 0x42, 0x08, 0x42, 0x08, 0x42, 0x2a, 0x52, 0x29, 0x4a, 0x29, 0x4a, 0x48, 0xc6, 0x48, 0x42, 0x08, 0x42, 0x10, 0x42, 0x10, 0x42, 0x20, 0x02, 0x40, 0x02, 0x00, 0x00 },
{ 0xf1, 0xb7, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x22, 0x04, 0x2f, 0xc4, 0x22, 0x04, 0x2f, 0xbf, 0x20, 0x04, 0x2f, 0x84, 0x28, 0xa4, 0x2f, 0x94, 0x20, 0x04, 0x49, 0x04, 0x49, 0x84, 0x5e, 0x1c, 0x00, 0x00 },
{ 0xf1, 0xb8, 0x00, 0x80, 0x1f, 0xf8, 0x00, 0x88, 0x7f, 0xff, 0x00, 0x88, 0x1f, 0xf8, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xb9, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x1f, 0xfe, 0x10, 0x80, 0x20, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf1, 0xba, 0x10, 0x20, 0x10, 0x10, 0x10, 0x08, 0x7c, 0x00, 0x11, 0xff, 0x10, 0x10, 0x38, 0x10, 0x38, 0x10, 0x34, 0x10, 0x54, 0xfe, 0x50, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xf1, 0xbb, 0x10, 0x10, 0x10, 0x90, 0x10, 0x90, 0x7c, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x38, 0x10, 0x39, 0xff, 0x34, 0x38, 0x54, 0x54, 0x50, 0x54, 0x50, 0x92, 0x11, 0x12, 0x12, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xf1, 0xbc, 0x20, 0x40, 0x10, 0x20, 0x08, 0x00, 0x03, 0xfe, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x00, 0x20, 0x03, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xf1, 0xbd, 0x21, 0x01, 0x11, 0x11, 0x09, 0x11, 0x01, 0x11, 0x41, 0x11, 0x25, 0x55, 0x15, 0x55, 0x05, 0x33, 0x09, 0x33, 0x11, 0x11, 0x11, 0x11, 0x21, 0x11, 0x22, 0x11, 0x42, 0x01, 0x44, 0x01, 0x00, 0x00 },
{ 0xf1, 0xbe, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x00, 0x20, 0x41, 0xfc, 0x20, 0x50, 0x10, 0x88, 0x07, 0xff, 0x01, 0x04, 0x16, 0xfb, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x50, 0x40, 0x88, 0x43, 0x06, 0x00, 0x00 },
{ 0xf1, 0xbf, 0x21, 0x02, 0x11, 0x02, 0x07, 0xe2, 0x01, 0x02, 0x4f, 0xdf, 0x20, 0x02, 0x07, 0xd2, 0x14, 0x4a, 0x14, 0x4a, 0x27, 0xca, 0x22, 0x82, 0x42, 0x82, 0x42, 0xe2, 0x47, 0x8e, 0x02, 0x04, 0x00, 0x00 },
{ 0xf1, 0xc0, 0x10, 0x20, 0x10, 0x20, 0x14, 0x20, 0x17, 0xfe, 0x54, 0x20, 0x58, 0x20, 0x50, 0x20, 0x50, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x28, 0x20, 0x24, 0x20, 0x24, 0x20, 0x47, 0xff, 0x40, 0x00, 0x00, 0x00 },
{ 0xf1, 0xc1, 0x00, 0x10, 0x00, 0x90, 0x7c, 0x90, 0x10, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x38, 0x10, 0x54, 0x10, 0x54, 0x1c, 0x92, 0x70, 0x92, 0x01, 0x11, 0x00, 0x10, 0x00, 0x00 },
{ 0xf1, 0xc2, 0x00, 0x10, 0x01, 0xff, 0x7c, 0x10, 0x54, 0xfe, 0x54, 0x00, 0x55, 0xff, 0x7c, 0x01, 0x54, 0xfc, 0x54, 0x10, 0x55, 0xff, 0x54, 0x04, 0x7d, 0xdf, 0x01, 0x54, 0x01, 0xc4, 0x00, 0x0c, 0x00, 0x00 },
{ 0xf1, 0xc3, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x7f, 0xff, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x81, 0x7f, 0xfe, 0x00, 0x04, 0x1e, 0xff, 0x12, 0x24, 0x1e, 0x04, 0x00, 0x1c, 0x00, 0x00 },
{ 0xf1, 0xc4, 0x08, 0x04, 0x08, 0x04, 0x52, 0x04, 0x22, 0xff, 0x14, 0x04, 0x08, 0x04, 0x12, 0x04, 0x7f, 0x44, 0x09, 0x24, 0x08, 0x24, 0x2a, 0x04, 0x29, 0x04, 0x49, 0x04, 0x48, 0x04, 0x08, 0x1c, 0x00, 0x00 },
{ 0xf1, 0xc5, 0x08, 0x08, 0x08, 0x08, 0x52, 0x08, 0x22, 0x08, 0x14, 0x7f, 0x08, 0x49, 0x12, 0x49, 0x7f, 0x49, 0x09, 0x49, 0x08, 0x7f, 0x2a, 0x49, 0x29, 0x49, 0x49, 0x49, 0x48, 0x49, 0x08, 0x7f, 0x00, 0x00 },
{ 0xf1, 0xc6, 0x10, 0x00, 0x11, 0xfe, 0x25, 0x02, 0x45, 0x22, 0x29, 0x7a, 0x11, 0x22, 0x11, 0x7a, 0x25, 0x22, 0x7d, 0x02, 0x15, 0x7a, 0x51, 0x4a, 0x55, 0x4a, 0x55, 0x7a, 0x12, 0x02, 0x12, 0x0e, 0x00, 0x00 },
{ 0xf1, 0xc7, 0x00, 0x80, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x09, 0x08, 0x08, 0x88, 0x08, 0x48, 0x08, 0x08, 0x7f, 0xff, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x10, 0x88, 0x10, 0x08, 0x20, 0x38, 0x00, 0x00 },
{ 0xf1, 0xc8, 0x10, 0x10, 0x10, 0x50, 0x10, 0x50, 0x7c, 0xfe, 0x54, 0x90, 0x55, 0x10, 0x54, 0x10, 0x55, 0xff, 0x7c, 0x38, 0x10, 0x38, 0x10, 0x54, 0x14, 0x54, 0x16, 0x92, 0x1b, 0x11, 0x60, 0x10, 0x00, 0x00 },
{ 0xf1, 0xc9, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xfe, 0x00, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3d, 0xff, 0x00, 0x00 },
{ 0xf1, 0xca, 0x00, 0x10, 0x3c, 0x50, 0x00, 0x50, 0x7e, 0xfe, 0x00, 0x90, 0x3d, 0x10, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x38, 0x00, 0x54, 0x3c, 0x54, 0x24, 0x92, 0x25, 0x11, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xf1, 0xcb, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x14, 0x80, 0x23, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xf1, 0xcc, 0x00, 0x10, 0x3d, 0xff, 0x24, 0x10, 0x24, 0xfe, 0x24, 0x00, 0x3d, 0xff, 0x08, 0x11, 0x08, 0xfe, 0x28, 0x00, 0x2d, 0xff, 0x28, 0x02, 0x29, 0xff, 0x29, 0x2a, 0x2d, 0xe2, 0x70, 0x06, 0x00, 0x00 },
{ 0xf1, 0xcd, 0x08, 0x10, 0x08, 0x10, 0x7e, 0xff, 0x08, 0x10, 0x3e, 0x7e, 0x2a, 0x28, 0x3e, 0xff, 0x2a, 0x44, 0x3e, 0x82, 0x09, 0x7d, 0x08, 0x10, 0x7e, 0xff, 0x08, 0x28, 0x08, 0x44, 0x09, 0x83, 0x00, 0x00 },
{ 0xf1, 0xce, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x02, 0x22, 0x42, 0xfa, 0x22, 0x22, 0x12, 0xfa, 0x02, 0x02, 0x02, 0xfa, 0x72, 0x8a, 0x14, 0x8a, 0x14, 0xfa, 0x10, 0x06, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf1, 0xcf, 0x00, 0x04, 0x7f, 0x04, 0x14, 0x04, 0x14, 0x04, 0x7f, 0x7f, 0x55, 0x04, 0x55, 0x04, 0x55, 0x44, 0x67, 0x24, 0x41, 0x14, 0x41, 0x04, 0x7f, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0x1c, 0x00, 0x00 },
{ 0xf1, 0xd0, 0x20, 0x00, 0x13, 0xff, 0x08, 0x48, 0x00, 0x48, 0x43, 0xff, 0x22, 0x49, 0x12, 0x49, 0x02, 0x89, 0x03, 0x0f, 0x12, 0x01, 0x12, 0x01, 0x23, 0xff, 0x22, 0x01, 0x42, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xf1, 0xd1, 0x08, 0x10, 0x14, 0xff, 0x22, 0x10, 0x40, 0x7e, 0x3e, 0x00, 0x08, 0xff, 0x08, 0x01, 0x7e, 0x7c, 0x08, 0x10, 0x4a, 0xff, 0x2a, 0x02, 0x28, 0xff, 0x08, 0xaa, 0x0e, 0xe2, 0x70, 0x06, 0x00, 0x00 },
{ 0xf1, 0xd2, 0x00, 0x20, 0x3e, 0x10, 0x28, 0x00, 0x28, 0xfe, 0x3e, 0x10, 0x28, 0x10, 0x3e, 0x10, 0x28, 0x10, 0x28, 0xfe, 0x3e, 0x10, 0x02, 0x10, 0x52, 0x10, 0x52, 0x10, 0x42, 0x10, 0x0d, 0xff, 0x00, 0x00 },
{ 0xf1, 0xd3, 0x08, 0x20, 0x08, 0x20, 0x10, 0x40, 0x1f, 0x7f, 0x24, 0x88, 0x24, 0x88, 0x45, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x38, 0x00, 0x00 },
{ 0xf1, 0xd4, 0x00, 0x80, 0x78, 0x8f, 0x0a, 0xa1, 0x0a, 0xa1, 0x3a, 0xa1, 0x20, 0x87, 0x23, 0xe4, 0x20, 0x84, 0x79, 0xcf, 0x49, 0xc9, 0x0a, 0xa1, 0x0a, 0xa1, 0x0a, 0x81, 0x08, 0x81, 0x30, 0x86, 0x00, 0x00 },
{ 0xf1, 0xd5, 0x08, 0x20, 0x08, 0x44, 0x10, 0x82, 0x13, 0xfd, 0x30, 0x48, 0x30, 0x89, 0x53, 0x47, 0x10, 0x40, 0x10, 0xfc, 0x10, 0x84, 0x11, 0x44, 0x12, 0x28, 0x10, 0x10, 0x10, 0x6c, 0x13, 0x83, 0x00, 0x00 },
{ 0xf1, 0xd6, 0x08, 0x88, 0x08, 0x90, 0x11, 0xff, 0x13, 0x10, 0x35, 0xfe, 0x31, 0x10, 0x51, 0xfe, 0x51, 0x10, 0x11, 0xff, 0x10, 0x00, 0x13, 0xcf, 0x12, 0x49, 0x12, 0x79, 0x12, 0x01, 0x12, 0x03, 0x00, 0x00 },
{ 0xf1, 0xd7, 0x00, 0x88, 0x20, 0x88, 0x11, 0x10, 0x09, 0xff, 0x03, 0x10, 0x05, 0x10, 0x01, 0x10, 0x01, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x21, 0xfe, 0x21, 0x10, 0x41, 0x10, 0x41, 0x10, 0x01, 0xff, 0x00, 0x00 },
{ 0xf1, 0xd8, 0x10, 0x40, 0x10, 0x48, 0x10, 0x84, 0x10, 0x84, 0x13, 0xfa, 0x7c, 0x91, 0x10, 0x91, 0x11, 0x1e, 0x16, 0x40, 0x10, 0x78, 0x1c, 0x88, 0x73, 0x50, 0x00, 0x30, 0x00, 0xcc, 0x07, 0x03, 0x00, 0x00 },
{ 0xf1, 0xd9, 0x00, 0x80, 0x7f, 0xfe, 0x48, 0x42, 0x48, 0x82, 0x1f, 0xf8, 0x30, 0x80, 0x5f, 0xf8, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x00, 0x3e, 0x7c, 0x22, 0x44, 0x23, 0xc4, 0x20, 0x04, 0x20, 0x18, 0x00, 0x00 },
{ 0xf1, 0xda, 0x10, 0x10, 0x10, 0x24, 0x10, 0x42, 0x55, 0xfd, 0x54, 0x28, 0x54, 0x49, 0x55, 0x8f, 0x54, 0x20, 0x54, 0x20, 0x54, 0x7e, 0x7c, 0xc2, 0x01, 0x24, 0x00, 0x18, 0x00, 0x64, 0x03, 0x83, 0x00, 0x00 },
{ 0xf1, 0xdb, 0x00, 0x40, 0x00, 0x48, 0x78, 0x84, 0x49, 0x1a, 0x4b, 0xe2, 0x48, 0x91, 0x48, 0x9f, 0x79, 0x20, 0x4e, 0x3c, 0x48, 0x44, 0x48, 0x84, 0x4b, 0x48, 0x78, 0x30, 0x00, 0xcc, 0x07, 0x03, 0x00, 0x00 },
{ 0xf1, 0xdc, 0x10, 0x5c, 0x10, 0xfa, 0x11, 0x29, 0x7f, 0xff, 0x11, 0x29, 0x11, 0xcf, 0x11, 0x01, 0x39, 0xff, 0x35, 0x01, 0x55, 0xff, 0x50, 0x04, 0x13, 0xff, 0x10, 0x84, 0x10, 0x44, 0x10, 0x0c, 0x00, 0x00 },
{ 0xf1, 0xdd, 0x20, 0x40, 0x10, 0x44, 0x08, 0x82, 0x03, 0xfd, 0x40, 0x90, 0x20, 0x90, 0x11, 0x11, 0x02, 0x4f, 0x00, 0x40, 0x10, 0xfc, 0x11, 0x04, 0x22, 0x88, 0x20, 0x70, 0x40, 0xd8, 0x47, 0x07, 0x00, 0x00 },
{ 0xf1, 0xde, 0x21, 0x10, 0x13, 0xff, 0x06, 0x20, 0x4b, 0xfe, 0x22, 0x20, 0x0b, 0xfe, 0x0a, 0x20, 0x12, 0x20, 0x23, 0xff, 0x40, 0x00, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf1, 0xdf, 0x20, 0x20, 0x10, 0x3e, 0x08, 0x20, 0x03, 0xff, 0x42, 0x01, 0x22, 0xfd, 0x11, 0x24, 0x02, 0x52, 0x01, 0x8c, 0x16, 0x03, 0x11, 0xfc, 0x21, 0x04, 0x21, 0xfc, 0x41, 0x04, 0x41, 0xfc, 0x00, 0x00 },
{ 0xf1, 0xe0, 0x10, 0x20, 0x10, 0x24, 0x14, 0x42, 0x15, 0xfe, 0x58, 0x4a, 0x50, 0x48, 0x50, 0x49, 0x50, 0xa7, 0x11, 0x20, 0x10, 0x7c, 0x28, 0x88, 0x25, 0x50, 0x24, 0x20, 0x40, 0xd8, 0x47, 0x07, 0x00, 0x00 },
{ 0xf1, 0xe1, 0x00, 0x20, 0x7c, 0x24, 0x54, 0x42, 0x54, 0x9e, 0x55, 0xe2, 0x54, 0x51, 0x7c, 0x91, 0x57, 0x1e, 0x54, 0x20, 0x54, 0x3c, 0x54, 0xc4, 0x57, 0x28, 0x7c, 0x10, 0x00, 0x6c, 0x03, 0x83, 0x00, 0x00 },
{ 0xf1, 0xe2, 0x10, 0x10, 0x10, 0x22, 0x10, 0x46, 0x7d, 0xf9, 0x00, 0x48, 0x04, 0x49, 0x44, 0x8f, 0x45, 0x20, 0x24, 0x7e, 0x28, 0x42, 0x28, 0xa4, 0x09, 0x18, 0x1c, 0x18, 0x60, 0x64, 0x03, 0x83, 0x00, 0x00 },
{ 0xf1, 0xe3, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x0c, 0x18, 0x17, 0xf4, 0x64, 0x13, 0x0b, 0xf0, 0x3e, 0x3e, 0x2a, 0x2a, 0x3e, 0x3e, 0x0a, 0x0a, 0x7d, 0x7d, 0x00, 0x00 },
{ 0xf1, 0xe4, 0x20, 0x40, 0x10, 0x44, 0x00, 0x86, 0x43, 0xfa, 0x20, 0x49, 0x00, 0x8f, 0x03, 0x20, 0x00, 0x7c, 0x70, 0xc4, 0x13, 0x28, 0x10, 0x10, 0x10, 0x6c, 0x13, 0x83, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf1, 0xe5, 0x21, 0x1c, 0x11, 0x04, 0x03, 0xfa, 0x44, 0x51, 0x23, 0xfe, 0x02, 0x92, 0x03, 0x0e, 0x03, 0xfe, 0x72, 0x02, 0x17, 0xff, 0x11, 0x08, 0x10, 0x88, 0x18, 0x38, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xf1, 0xe6, 0x04, 0x20, 0x08, 0x40, 0x1f, 0xff, 0x30, 0x40, 0x5f, 0xfe, 0x10, 0x40, 0x1f, 0xfe, 0x10, 0x40, 0x1f, 0xff, 0x00, 0x00, 0x3e, 0x1f, 0x22, 0x11, 0x23, 0xf1, 0x20, 0x01, 0x20, 0x07, 0x00, 0x00 },
{ 0xf1, 0xe7, 0x00, 0x20, 0x3e, 0x24, 0x28, 0x42, 0x29, 0xfd, 0x3e, 0x48, 0x28, 0x49, 0x3e, 0x8f, 0x29, 0x20, 0x28, 0x3e, 0x3e, 0x42, 0x02, 0xa4, 0x52, 0x18, 0x52, 0x18, 0x42, 0x24, 0x0c, 0xc3, 0x00, 0x00 },
{ 0xf1, 0xe8, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x90, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf1, 0xe9, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf1, 0xea, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x11, 0xff, 0x31, 0x11, 0x31, 0x11, 0x51, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf1, 0xeb, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x02, 0x20, 0x04, 0x40, 0x19, 0xc2, 0x60, 0xa4, 0x02, 0xa8, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf1, 0xec, 0x00, 0x3c, 0x1f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xed, 0x04, 0x00, 0x08, 0x3e, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x22, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x22, 0x3f, 0x22, 0x00, 0x2e, 0x22, 0x20, 0x2c, 0x20, 0x31, 0x20, 0x21, 0x20, 0x1f, 0x20, 0x00, 0x00 },
{ 0xf1, 0xee, 0x11, 0x08, 0x11, 0xef, 0x12, 0x94, 0x7c, 0x42, 0x10, 0x80, 0x10, 0x8f, 0x39, 0xe9, 0x39, 0x29, 0x35, 0xe9, 0x55, 0x29, 0x51, 0xe9, 0x51, 0x09, 0x11, 0xeb, 0x11, 0x08, 0x11, 0xe8, 0x00, 0x00 },
{ 0xf1, 0xef, 0x10, 0x00, 0x10, 0xfc, 0x10, 0x84, 0x7c, 0x84, 0x10, 0xfc, 0x10, 0x00, 0x3b, 0xff, 0x38, 0x84, 0x34, 0xfc, 0x54, 0x84, 0x50, 0xfc, 0x50, 0x84, 0x10, 0xbf, 0x13, 0xc4, 0x10, 0x04, 0x00, 0x00 },
{ 0xf1, 0xf0, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x27, 0xff, 0x10, 0x20, 0x00, 0x20, 0x00, 0x20, 0x10, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf1, 0xf1, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x0f, 0x7f, 0xf8, 0x00, 0x08, 0x00, 0x00 },
{ 0xf1, 0xf2, 0x01, 0x7c, 0x11, 0x04, 0x12, 0x02, 0x13, 0xfe, 0x17, 0x2b, 0x7a, 0xaa, 0x12, 0xb2, 0x13, 0xfe, 0x10, 0x00, 0x1d, 0xfc, 0x71, 0x04, 0x01, 0xfc, 0x01, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xf1, 0xf3, 0x11, 0x7c, 0x11, 0x04, 0x12, 0x02, 0x1b, 0xfe, 0x57, 0x2b, 0x56, 0xaa, 0x52, 0xb2, 0x53, 0xfe, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xf1, 0xf4, 0x05, 0xf8, 0x08, 0x08, 0x10, 0x04, 0x3f, 0xfe, 0x54, 0x95, 0x12, 0xa4, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xf1, 0xf5, 0x10, 0x00, 0x11, 0xfc, 0x10, 0x08, 0x7c, 0x10, 0x10, 0x20, 0x13, 0xb1, 0x10, 0xb2, 0x1c, 0xac, 0x70, 0xa8, 0x11, 0x24, 0x11, 0x24, 0x12, 0x22, 0x14, 0x61, 0x10, 0x00, 0x33, 0xff, 0x00, 0x00 },
{ 0xf1, 0xf6, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x20, 0x00, 0xc2, 0x7e, 0xa4, 0x04, 0xa8, 0x08, 0x90, 0x10, 0x8c, 0x63, 0x83, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x12, 0x44, 0x21, 0x22, 0x41, 0x21, 0x00, 0x00 },
{ 0xf1, 0xf7, 0x14, 0x00, 0x12, 0xff, 0x21, 0x20, 0x41, 0x20, 0x7f, 0x20, 0x6b, 0x3c, 0x49, 0x24, 0x7f, 0x24, 0x00, 0x34, 0x3e, 0x54, 0x22, 0x4c, 0x3e, 0x45, 0x22, 0x5d, 0x22, 0xe5, 0x3e, 0x03, 0x00, 0x00 },
{ 0xf1, 0xf8, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x00, 0x33, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x31, 0x20, 0x51, 0x3c, 0x11, 0x20, 0x11, 0x20, 0x21, 0x20, 0x21, 0x20, 0x4f, 0xff, 0x00, 0x00 },
{ 0xf1, 0xf9, 0x08, 0x5c, 0x08, 0x44, 0x10, 0x82, 0x54, 0x82, 0x25, 0xff, 0x2a, 0x92, 0x10, 0xd6, 0x24, 0x92, 0x7c, 0xfe, 0x10, 0x00, 0x54, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf1, 0xfa, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x0f, 0xe2, 0x00, 0xc4, 0x3c, 0xa8, 0x04, 0x90, 0x08, 0x88, 0x11, 0x84, 0x60, 0x03, 0x0f, 0xf0, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xf1, 0xfb, 0x00, 0x00, 0x3c, 0xf4, 0x00, 0x18, 0x7c, 0xa9, 0x00, 0x46, 0x3c, 0x82, 0x01, 0x7d, 0x3c, 0x00, 0x00, 0xfe, 0x00, 0x82, 0x3c, 0xfe, 0x24, 0x44, 0x24, 0x24, 0x24, 0x28, 0x3d, 0xff, 0x00, 0x00 },
{ 0xf1, 0xfc, 0x00, 0x00, 0x7c, 0x5c, 0x44, 0x44, 0x44, 0x82, 0x7d, 0xff, 0x44, 0xda, 0x44, 0x92, 0x7c, 0xfe, 0x44, 0x00, 0x44, 0x7c, 0x7c, 0x44, 0x00, 0x7c, 0x28, 0x44, 0x44, 0x44, 0x44, 0x7c, 0x00, 0x00 },
{ 0xf1, 0xfd, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfc, 0x00, 0x04, 0x00, 0x08, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x08, 0x40, 0x08, 0x80, 0x15, 0x00, 0x12, 0x00, 0x21, 0x80, 0x40, 0x7f, 0x00, 0x00 },
{ 0xf1, 0xfe, 0x00, 0x00, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x3f, 0xf8, 0x00, 0x00, 0x08, 0x20, 0x08, 0x10, 0x10, 0x08, 0x20, 0x04, 0x40, 0x04, 0x00, 0x00 },
{ 0xf2, 0xa1, 0x00, 0x00, 0x3f, 0x7e, 0x21, 0x42, 0x21, 0x42, 0x21, 0x42, 0x21, 0x42, 0x3f, 0x42, 0x28, 0x7e, 0x28, 0x00, 0x24, 0x44, 0x24, 0x42, 0x22, 0x82, 0x21, 0x00, 0x40, 0xc0, 0x40, 0x3f, 0x00, 0x00 },
{ 0xf2, 0xa2, 0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x10, 0x96, 0x7c, 0x9a, 0x10, 0xf2, 0x13, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x96, 0x1c, 0x90, 0x70, 0x90, 0x00, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xf2, 0xa3, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x90, 0x10, 0x90, 0x10, 0x9e, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x1c, 0x90, 0x70, 0x90, 0x00, 0x90, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xf2, 0xa4, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xf2, 0xa5, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x7c, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x08, 0x1c, 0x08, 0x73, 0xff, 0x10, 0x08, 0x11, 0x08, 0x10, 0x88, 0x10, 0x08, 0x10, 0x08, 0x30, 0x38, 0x00, 0x00 },
{ 0xf2, 0xa6, 0x10, 0x80, 0x10, 0x83, 0x10, 0xfc, 0x7c, 0x81, 0x10, 0x81, 0x10, 0x7f, 0x10, 0x00, 0x1c, 0x00, 0x70, 0xff, 0x10, 0x81, 0x10, 0x81, 0x10, 0xff, 0x10, 0x81, 0x10, 0x81, 0x30, 0xff, 0x00, 0x00 },
{ 0xf2, 0xa7, 0x08, 0x20, 0x3e, 0xfc, 0x08, 0x24, 0x7f, 0x64, 0x22, 0x25, 0x14, 0x55, 0x7f, 0x83, 0x08, 0x38, 0x0f, 0xc0, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xf2, 0xa8, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xf8, 0x04, 0x08, 0x04, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0xc0, 0x01, 0xa0, 0x0e, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xf2, 0xa9, 0x20, 0x00, 0x21, 0xe0, 0x3e, 0x08, 0x20, 0x08, 0x20, 0x08, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x1f, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x1f, 0xf0, 0x00, 0x00 },
{ 0xf2, 0xaa, 0x10, 0x00, 0x10, 0x00, 0x3f, 0x3f, 0x44, 0x21, 0x04, 0x21, 0x7f, 0xa1, 0x0a, 0x3f, 0x11, 0x00, 0x60, 0x00, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xf2, 0xab, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x10, 0x38, 0xfe, 0x38, 0x42, 0x34, 0x44, 0x54, 0x24, 0x50, 0x28, 0x50, 0x10, 0x10, 0x28, 0x10, 0xc4, 0x13, 0x03, 0x00, 0x00 },
{ 0xf2, 0xac, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0x02, 0x11, 0x02, 0x11, 0x02, 0x39, 0x02, 0x35, 0x02, 0x35, 0xfe, 0x50, 0x00, 0x50, 0x48, 0x50, 0x48, 0x10, 0x84, 0x11, 0x02, 0x12, 0x01, 0x00, 0x00 },
{ 0xf2, 0xad, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0xfe, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf2, 0xae, 0x20, 0x20, 0x10, 0x20, 0x09, 0x20, 0x01, 0x26, 0x41, 0x3a, 0x21, 0xe2, 0x11, 0x22, 0x07, 0x22, 0x01, 0x22, 0x11, 0x22, 0x11, 0x2c, 0x21, 0x20, 0x21, 0x01, 0x41, 0x01, 0x40, 0xff, 0x00, 0x00 },
{ 0xf2, 0xaf, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x20, 0x42, 0x20, 0x22, 0x20, 0x12, 0x3e, 0x02, 0x20, 0x02, 0x20, 0x12, 0x20, 0x12, 0x20, 0x22, 0x20, 0x22, 0x20, 0x42, 0x20, 0x4f, 0xff, 0x00, 0x00 },
{ 0xf2, 0xb0, 0x20, 0x20, 0x13, 0xfe, 0x08, 0x20, 0x01, 0xfc, 0x40, 0x20, 0x27, 0xff, 0x11, 0x04, 0x01, 0xfc, 0x01, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x21, 0xfc, 0x20, 0x00, 0x40, 0x88, 0x43, 0x06, 0x00, 0x00 },
{ 0xf2, 0xb1, 0x10, 0x00, 0x10, 0x00, 0x3f, 0x3f, 0x28, 0x21, 0x48, 0x21, 0x08, 0x21, 0x08, 0x21, 0x7f, 0xa1, 0x08, 0x21, 0x08, 0x21, 0x0c, 0x21, 0x12, 0x21, 0x11, 0x21, 0x21, 0x3f, 0x40, 0x00, 0x00, 0x00 },
{ 0xf2, 0xb2, 0x00, 0x06, 0x7c, 0xf8, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x20, 0xff, 0x3c, 0x88, 0x24, 0x88, 0x64, 0x88, 0x24, 0x88, 0x24, 0xe4, 0x25, 0x85, 0x3c, 0x05, 0x01, 0xf3, 0x00, 0x01, 0x00, 0x00 },
{ 0xf2, 0xb3, 0x00, 0x08, 0x3e, 0x08, 0x00, 0x08, 0x00, 0x08, 0x7f, 0x08, 0x08, 0x48, 0x2a, 0x4e, 0x2a, 0x48, 0x2a, 0x48, 0x2a, 0x48, 0x2a, 0x48, 0x4a, 0x48, 0x48, 0x48, 0x08, 0x48, 0x09, 0xff, 0x00, 0x00 },
{ 0xf2, 0xb4, 0x00, 0x06, 0x3e, 0xf8, 0x00, 0x90, 0x00, 0x90, 0x7e, 0x90, 0x08, 0x90, 0x08, 0xff, 0x2a, 0x88, 0x2a, 0x88, 0x2a, 0x88, 0x2a, 0x84, 0x4a, 0xe5, 0x49, 0x85, 0x08, 0x03, 0x09, 0xf9, 0x00, 0x00 },
{ 0xf2, 0xb5, 0x10, 0x07, 0x10, 0xf8, 0x24, 0x88, 0x44, 0x88, 0x28, 0x88, 0x10, 0x88, 0x10, 0xff, 0x24, 0x88, 0x7c, 0x88, 0x10, 0x88, 0x54, 0x88, 0x54, 0x84, 0x50, 0x85, 0x10, 0xf5, 0x13, 0x83, 0x00, 0x00 },
{ 0xf2, 0xb6, 0x00, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x3c, 0x10, 0x24, 0xfe, 0x24, 0x42, 0x24, 0x44, 0x3c, 0x24, 0x24, 0x28, 0x24, 0x10, 0x24, 0x28, 0x44, 0x44, 0x4d, 0x83, 0x00, 0x00 },
{ 0xf2, 0xb7, 0x00, 0x00, 0x3c, 0x40, 0x24, 0x46, 0x24, 0x78, 0x24, 0x41, 0x3c, 0x3f, 0x24, 0x00, 0x24, 0x00, 0x24, 0x7f, 0x3c, 0x41, 0x24, 0x41, 0x24, 0x7f, 0x24, 0x41, 0x44, 0x41, 0x4c, 0x7f, 0x00, 0x00 },
{ 0xf2, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x02, 0x10, 0x02, 0x08, 0x04, 0xf8, 0x3f, 0x04, 0x00, 0x04, 0x01, 0x00, 0x01, 0x00, 0x3f, 0xfc, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xf2, 0xb9, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x02, 0x00, 0x04, 0x00, 0x18, 0x08, 0x60, 0x0b, 0x80, 0x14, 0x00, 0x23, 0x00, 0x40, 0xff, 0x00, 0x00 },
{ 0xf2, 0xba, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x08, 0x40, 0x08, 0x40, 0x08, 0x7e, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xf2, 0xbb, 0x10, 0x80, 0x10, 0x80, 0x10, 0x8f, 0x7d, 0xe9, 0x55, 0x49, 0x56, 0x49, 0x54, 0x49, 0x55, 0xe9, 0x54, 0x49, 0x7c, 0x49, 0x10, 0x49, 0x14, 0xa9, 0x14, 0xa9, 0x1b, 0x09, 0x62, 0x0f, 0x00, 0x00 },
{ 0xf2, 0xbc, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xfe, 0x3c, 0x00, 0x00, 0x10, 0x00, 0x4a, 0x3d, 0x49, 0x25, 0x41, 0x25, 0x40, 0x24, 0x42, 0x3c, 0x3e, 0x00, 0x00 },
{ 0xf2, 0xbd, 0x00, 0x00, 0x38, 0x88, 0x00, 0x8a, 0x03, 0xe9, 0x7d, 0x48, 0x01, 0x48, 0x3b, 0xff, 0x00, 0x08, 0x3b, 0xca, 0x02, 0x4a, 0x3b, 0xc4, 0x2a, 0x45, 0x2b, 0xcd, 0x28, 0x12, 0x38, 0x61, 0x00, 0x00 },
{ 0xf2, 0xbe, 0x08, 0x10, 0x3e, 0x10, 0x08, 0x7c, 0x7f, 0x14, 0x14, 0x35, 0x3e, 0x2d, 0x08, 0x47, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xf2, 0xbf, 0x00, 0x08, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x48, 0x3e, 0x48, 0x08, 0x4f, 0x08, 0x48, 0x28, 0x48, 0x2e, 0x48, 0x28, 0x48, 0x28, 0x48, 0x28, 0x48, 0x2e, 0x48, 0x71, 0xff, 0x00, 0x00 },
{ 0xf2, 0xc0, 0x20, 0x00, 0x13, 0xff, 0x02, 0x01, 0x43, 0xff, 0x22, 0x10, 0x02, 0xd6, 0x02, 0x10, 0x02, 0xd6, 0x72, 0x50, 0x12, 0x7e, 0x14, 0x90, 0x15, 0xff, 0x10, 0x10, 0x2c, 0x10, 0x43, 0xff, 0x00, 0x00 },
{ 0xf2, 0xc1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x4f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x40, 0x00, 0x40, 0x00, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf2, 0xc2, 0x0c, 0x08, 0x70, 0x08, 0x11, 0xff, 0x10, 0x08, 0x7c, 0x08, 0x10, 0x3e, 0x10, 0x22, 0x39, 0x3e, 0x35, 0x22, 0x51, 0x3e, 0x51, 0x22, 0x11, 0x3e, 0x11, 0x00, 0x11, 0x00, 0x11, 0xff, 0x00, 0x00 },
{ 0xf2, 0xc3, 0x0c, 0xfe, 0x70, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x7c, 0xfe, 0x10, 0x28, 0x10, 0x49, 0x39, 0x87, 0x34, 0x20, 0x50, 0x7e, 0x50, 0xc2, 0x13, 0x24, 0x10, 0x18, 0x10, 0x6c, 0x13, 0x83, 0x00, 0x00 },
{ 0xf2, 0xc4, 0x10, 0x88, 0x10, 0x88, 0x27, 0xea, 0x45, 0x49, 0x29, 0x48, 0x11, 0x48, 0x13, 0xff, 0x24, 0x08, 0x7d, 0xea, 0x11, 0x2a, 0x55, 0xe4, 0x55, 0x2c, 0x51, 0xed, 0x10, 0x13, 0x10, 0x21, 0x00, 0x00 },
{ 0xf2, 0xc5, 0x00, 0x88, 0x7c, 0x88, 0x2b, 0xea, 0x29, 0x49, 0x39, 0x48, 0x29, 0x48, 0x2b, 0xff, 0x38, 0x08, 0x29, 0xea, 0x29, 0x2a, 0x29, 0xe4, 0x39, 0x25, 0x69, 0xed, 0x08, 0x13, 0x08, 0x21, 0x00, 0x00 },
{ 0xf2, 0xc6, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x00, 0x2f, 0xf8, 0x20, 0x00, 0x3f, 0xff, 0x24, 0x44, 0x24, 0x28, 0x45, 0x90, 0x5e, 0x0c, 0x40, 0x03, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf2, 0xc7, 0x01, 0x18, 0x01, 0xe2, 0x79, 0x02, 0x48, 0xfe, 0x48, 0x00, 0x48, 0x7e, 0x4a, 0x42, 0x4a, 0x7e, 0x4a, 0x42, 0x4a, 0x7e, 0x7a, 0x42, 0x03, 0xff, 0x00, 0x00, 0x00, 0xcc, 0x03, 0x03, 0x00, 0x00 },
{ 0xf2, 0xc8, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x24, 0x20, 0x27, 0xa6, 0x24, 0x38, 0x25, 0xa1, 0x2e, 0x1f, 0x20, 0x40, 0x47, 0xfc, 0x40, 0x40, 0x5f, 0xff, 0x00, 0x00 },
{ 0xf2, 0xc9, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x7d, 0x00, 0x11, 0xfe, 0x11, 0x00, 0x11, 0xff, 0x1d, 0x48, 0x71, 0x49, 0x11, 0x4a, 0x11, 0x44, 0x11, 0x44, 0x12, 0x42, 0x12, 0x72, 0x35, 0xc1, 0x00, 0x00 },
{ 0xf2, 0xca, 0x10, 0x00, 0x11, 0xff, 0x10, 0x84, 0x7c, 0x84, 0x11, 0x29, 0x11, 0xef, 0x10, 0x00, 0x1d, 0xff, 0x70, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x70, 0xfe, 0x00, 0x00 },
{ 0xf2, 0xcb, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x10, 0x08, 0x10, 0x12, 0x24, 0x3d, 0x7a, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf2, 0xcc, 0x00, 0x00, 0x3f, 0xfe, 0x02, 0x20, 0x12, 0x24, 0x0a, 0x28, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf2, 0xcd, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x7d, 0x00, 0x11, 0xfe, 0x11, 0x00, 0x39, 0xff, 0x35, 0x48, 0x35, 0x48, 0x51, 0x49, 0x51, 0x46, 0x11, 0x44, 0x12, 0x4a, 0x12, 0x72, 0x14, 0xc1, 0x00, 0x00 },
{ 0xf2, 0xce, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x7c, 0xfe, 0x10, 0x28, 0x11, 0xff, 0x38, 0x44, 0x38, 0x9a, 0x35, 0x71, 0x54, 0x10, 0x50, 0xfe, 0x50, 0x38, 0x10, 0x54, 0x11, 0x93, 0x10, 0x10, 0x00, 0x00 },
{ 0xf2, 0xcf, 0x00, 0x00, 0x7f, 0x10, 0x08, 0x28, 0x08, 0x44, 0x1e, 0x82, 0x13, 0x11, 0x12, 0x20, 0x22, 0xc4, 0x34, 0x08, 0x4c, 0x31, 0x08, 0xc2, 0x08, 0x04, 0x10, 0x18, 0x20, 0x60, 0x43, 0x80, 0x00, 0x00 },
{ 0xf2, 0xd0, 0x20, 0x20, 0x13, 0xfe, 0x08, 0x22, 0x07, 0xff, 0x40, 0x22, 0x20, 0x22, 0x13, 0xfe, 0x00, 0x20, 0x03, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf2, 0xd1, 0x20, 0x20, 0x13, 0xfe, 0x08, 0x20, 0x41, 0xfc, 0x20, 0x50, 0x17, 0xff, 0x00, 0x88, 0x01, 0x34, 0x16, 0xe3, 0x10, 0x20, 0x23, 0xfe, 0x20, 0x70, 0x41, 0xac, 0x46, 0x23, 0x00, 0x20, 0x00, 0x00 },
{ 0xf2, 0xd2, 0x00, 0x10, 0x00, 0x28, 0x7c, 0x44, 0x10, 0x82, 0x11, 0x01, 0x10, 0x08, 0x10, 0x10, 0x7c, 0x60, 0x11, 0x84, 0x10, 0x08, 0x10, 0x31, 0x1d, 0xc2, 0x70, 0x0c, 0x00, 0x30, 0x01, 0xc0, 0x00, 0x00 },
{ 0xf2, 0xd3, 0x00, 0x00, 0x7d, 0xff, 0x10, 0x84, 0x10, 0x84, 0x11, 0x29, 0x7d, 0xef, 0x10, 0x00, 0x11, 0xff, 0x10, 0x00, 0x10, 0xfe, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xf2, 0xd4, 0x02, 0x12, 0x79, 0x12, 0x10, 0x24, 0x10, 0x3f, 0x14, 0x64, 0x7a, 0xa4, 0x10, 0x3f, 0x10, 0x24, 0x17, 0x24, 0x11, 0x3f, 0x19, 0x24, 0x71, 0x24, 0x01, 0x3f, 0x02, 0x80, 0x04, 0x7f, 0x00, 0x00 },
{ 0xf2, 0xd5, 0x00, 0x10, 0x00, 0x28, 0x7c, 0x44, 0x54, 0x82, 0x55, 0x09, 0x54, 0x30, 0x7c, 0xc0, 0x54, 0x04, 0x54, 0x08, 0x54, 0x30, 0x54, 0xc1, 0x7c, 0x02, 0x00, 0x0c, 0x00, 0x30, 0x01, 0xc0, 0x00, 0x00 },
{ 0xf2, 0xd6, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x50, 0x50, 0x31, 0x8c, 0x16, 0x13, 0x10, 0x60, 0x33, 0x84, 0x50, 0x18, 0x10, 0x61, 0x13, 0x82, 0x20, 0x0c, 0x20, 0x70, 0x47, 0x80, 0x00, 0x00 },
{ 0xf2, 0xd7, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf2, 0xd8, 0x10, 0x3c, 0x1f, 0xc0, 0x10, 0x02, 0x0f, 0xfe, 0x24, 0x08, 0x27, 0xf8, 0x24, 0x08, 0x27, 0xf8, 0x24, 0x08, 0x27, 0xf8, 0x20, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x06, 0x1c, 0x38, 0x03, 0x00, 0x00 },
{ 0xf2, 0xd9, 0x00, 0x86, 0x78, 0xf8, 0x48, 0x81, 0x48, 0x7f, 0x48, 0x00, 0x78, 0x7e, 0x49, 0x42, 0x49, 0x7e, 0x79, 0x42, 0x49, 0x7e, 0x49, 0x42, 0x49, 0x42, 0x79, 0xff, 0x00, 0x48, 0x03, 0x87, 0x00, 0x00 },
{ 0xf2, 0xda, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x00, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x68, 0x17, 0x84, 0x60, 0x83, 0x0f, 0xf8, 0x01, 0xc0, 0x06, 0xb0, 0x38, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf2, 0xdb, 0x11, 0xff, 0x10, 0x44, 0x24, 0x44, 0x44, 0xa9, 0x29, 0xef, 0x10, 0x00, 0x11, 0xff, 0x24, 0x00, 0x7c, 0xfe, 0x14, 0x82, 0x50, 0x82, 0x54, 0xfe, 0x54, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf2, 0xdc, 0x08, 0x86, 0x08, 0xf8, 0x10, 0x81, 0x64, 0x7f, 0x28, 0x00, 0x10, 0x7e, 0x25, 0x42, 0x7d, 0x7e, 0x13, 0x42, 0x11, 0x7e, 0x59, 0x42, 0x55, 0x42, 0x55, 0xff, 0x10, 0x24, 0x10, 0xc3, 0x00, 0x00 },
{ 0xf2, 0xdd, 0x00, 0x20, 0x7e, 0xfe, 0x10, 0x20, 0x14, 0xfe, 0x26, 0x28, 0x7b, 0xff, 0x00, 0x44, 0x10, 0x9a, 0x11, 0x71, 0x7c, 0x10, 0x10, 0xfe, 0x10, 0x38, 0x1c, 0x54, 0x71, 0x93, 0x00, 0x10, 0x00, 0x00 },
{ 0xf2, 0xde, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x20, 0x3d, 0xfe, 0x24, 0x20, 0x29, 0xfc, 0x29, 0x24, 0x25, 0xfc, 0x25, 0x24, 0x25, 0xfc, 0x38, 0x70, 0x21, 0xac, 0x26, 0x23, 0x20, 0x20, 0x00, 0x00 },
{ 0xf2, 0xdf, 0x10, 0x10, 0x10, 0x28, 0x10, 0x44, 0x7c, 0x82, 0x05, 0x09, 0x08, 0x30, 0x08, 0xc0, 0x10, 0x04, 0x34, 0x08, 0x58, 0x30, 0x14, 0xc1, 0x10, 0x02, 0x10, 0x0c, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xf2, 0xe0, 0x00, 0x10, 0x3c, 0x28, 0x00, 0x44, 0x7e, 0x82, 0x01, 0x09, 0x3c, 0x10, 0x00, 0x20, 0x3c, 0xc4, 0x00, 0x08, 0x00, 0x31, 0x3c, 0xc2, 0x24, 0x04, 0x24, 0x08, 0x24, 0x30, 0x3d, 0xc0, 0x00, 0x00 },
{ 0xf2, 0xe1, 0x00, 0x00, 0x3c, 0xff, 0x24, 0x80, 0x24, 0x80, 0x3c, 0xbe, 0x24, 0x80, 0x24, 0x80, 0x3c, 0xff, 0x24, 0xa8, 0x24, 0xa9, 0x3c, 0xa6, 0x00, 0xa4, 0x29, 0x22, 0x25, 0x3a, 0x42, 0xe1, 0x00, 0x00 },
{ 0xf2, 0xe2, 0x08, 0x10, 0x08, 0x28, 0x7e, 0x28, 0x08, 0x44, 0x3e, 0x82, 0x2b, 0x11, 0x3e, 0x20, 0x2a, 0xc4, 0x3e, 0x08, 0x08, 0x30, 0x08, 0xc1, 0x7e, 0x02, 0x08, 0x0c, 0x08, 0x30, 0x08, 0xc0, 0x00, 0x00 },
{ 0xf2, 0xe3, 0x00, 0x00, 0x1f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x13, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xfe, 0x12, 0x40, 0x12, 0x44, 0x12, 0x28, 0x12, 0x30, 0x22, 0x10, 0x23, 0x88, 0x4c, 0x06, 0x00, 0x00 },
{ 0xf2, 0xe4, 0x20, 0x88, 0x10, 0x88, 0x09, 0x10, 0x01, 0xfe, 0x43, 0x10, 0x25, 0x10, 0x11, 0xfc, 0x01, 0x10, 0x01, 0xfc, 0x71, 0x10, 0x11, 0x10, 0x11, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf2, 0xe5, 0x18, 0x8e, 0x24, 0xf0, 0x40, 0x81, 0x00, 0xff, 0x7c, 0x42, 0x10, 0x7e, 0x11, 0x42, 0x7d, 0x7e, 0x11, 0x42, 0x11, 0x7e, 0x55, 0x00, 0x35, 0xff, 0x10, 0x00, 0x18, 0x46, 0x61, 0x81, 0x00, 0x00 },
{ 0xf2, 0xe6, 0x00, 0x10, 0x7d, 0xff, 0x44, 0x10, 0x48, 0xfe, 0x48, 0x92, 0x50, 0x92, 0x48, 0xfe, 0x48, 0x92, 0x44, 0x92, 0x44, 0xfe, 0x44, 0x10, 0x59, 0xff, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xf2, 0xe7, 0x00, 0x20, 0x7c, 0x20, 0x47, 0xff, 0x48, 0x20, 0x49, 0xfe, 0x51, 0x22, 0x49, 0xfe, 0x49, 0x22, 0x45, 0xfe, 0x44, 0x20, 0x44, 0x70, 0x58, 0xa8, 0x41, 0x24, 0x46, 0x23, 0x40, 0x20, 0x00, 0x00 },
{ 0xf2, 0xe8, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x0e, 0xb8, 0x00, 0x00, 0x3f, 0xff, 0x20, 0x00, 0x27, 0xf8, 0x20, 0x00, 0x3f, 0xff, 0x44, 0x24, 0x45, 0x98, 0x5e, 0x07, 0x00, 0x00 },
{ 0xf2, 0xe9, 0x08, 0x00, 0x0b, 0xfe, 0x08, 0x20, 0x10, 0x48, 0x10, 0x88, 0x30, 0xf4, 0x33, 0x02, 0x50, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x00, 0x00, 0x00 },
{ 0xf2, 0xea, 0x00, 0x80, 0x00, 0x80, 0x78, 0x80, 0x48, 0x82, 0x48, 0x84, 0x48, 0x88, 0x48, 0x90, 0x48, 0xa0, 0x48, 0xc0, 0x4b, 0x80, 0x48, 0x80, 0x78, 0x81, 0x00, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xf2, 0xeb, 0x10, 0x00, 0x11, 0xff, 0x10, 0x20, 0x7c, 0x44, 0x24, 0x42, 0x24, 0x8f, 0x25, 0xf1, 0x24, 0x00, 0x44, 0x10, 0x68, 0x10, 0x58, 0xfe, 0x08, 0x10, 0x14, 0x10, 0x22, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xf2, 0xec, 0x20, 0x10, 0x20, 0x10, 0x20, 0xff, 0x78, 0x80, 0x2a, 0x90, 0x29, 0x90, 0x28, 0x9e, 0x28, 0xa8, 0x49, 0x88, 0x6a, 0xbf, 0x50, 0x88, 0x10, 0x94, 0x29, 0x14, 0x21, 0x22, 0x42, 0x41, 0x00, 0x00 },
{ 0xf2, 0xed, 0x10, 0x90, 0x10, 0x90, 0x7c, 0x90, 0x54, 0xfe, 0x55, 0x10, 0x55, 0x10, 0x54, 0x10, 0x55, 0xff, 0x54, 0x10, 0x54, 0x10, 0x54, 0x28, 0x5c, 0x28, 0x10, 0x44, 0x10, 0x82, 0x13, 0x01, 0x00, 0x00 },
{ 0xf2, 0xee, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x40, 0x7c, 0x48, 0x10, 0x84, 0x10, 0x9a, 0x39, 0xe2, 0x38, 0x02, 0x34, 0x20, 0x54, 0x20, 0x51, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x00, 0x00 },
{ 0xf2, 0xef, 0x00, 0x63, 0x7d, 0x8c, 0x11, 0xef, 0x11, 0x4a, 0x12, 0x52, 0x7c, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x1d, 0xfe, 0x71, 0x02, 0x01, 0xfe, 0x00, 0x48, 0x03, 0x87, 0x00, 0x00 },
{ 0xf2, 0xf0, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x00, 0x51, 0x00, 0x33, 0xfe, 0x12, 0x20, 0x14, 0x20, 0x30, 0x20, 0x57, 0xff, 0x10, 0x50, 0x10, 0x50, 0x20, 0x88, 0x21, 0x04, 0x46, 0x03, 0x00, 0x00 },
{ 0xf2, 0xf1, 0x0c, 0x10, 0x70, 0x50, 0x10, 0x50, 0x10, 0xfe, 0x7c, 0x90, 0x11, 0x10, 0x10, 0x10, 0x39, 0xff, 0x34, 0x10, 0x54, 0x28, 0x50, 0x28, 0x10, 0x44, 0x10, 0x44, 0x10, 0x82, 0x11, 0x01, 0x00, 0x00 },
{ 0xf2, 0xf2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x44, 0x25, 0x18, 0x1c, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x08, 0x04, 0x74, 0x3f, 0x82, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf2, 0xf3, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x25, 0x29, 0x24, 0xce, 0x3c, 0x00, 0x25, 0xff, 0x24, 0x28, 0x24, 0x44, 0x3c, 0xfa, 0x24, 0x10, 0x24, 0xfe, 0x24, 0x10, 0x44, 0x10, 0x4d, 0xff, 0x00, 0x00 },
{ 0xf2, 0xf4, 0x10, 0x00, 0x11, 0xff, 0x10, 0x20, 0x7c, 0x24, 0x54, 0x42, 0x54, 0x4f, 0x55, 0xf1, 0x54, 0x00, 0x54, 0x10, 0x7c, 0x10, 0x10, 0xfe, 0x14, 0x10, 0x14, 0x10, 0x1a, 0x10, 0x63, 0xff, 0x00, 0x00 },
{ 0xf2, 0xf5, 0x03, 0x03, 0x3c, 0x3c, 0x20, 0x20, 0x3f, 0xbf, 0x24, 0x24, 0x44, 0x44, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x04, 0x08, 0x38, 0x07, 0x00, 0x00 },
{ 0xf2, 0xf6, 0x00, 0x10, 0x3e, 0x50, 0x22, 0x50, 0x22, 0xfe, 0x23, 0x10, 0x3e, 0x10, 0x08, 0x10, 0x09, 0xff, 0x28, 0x10, 0x2e, 0x28, 0x28, 0x28, 0x28, 0x44, 0x28, 0x44, 0x2e, 0x82, 0x71, 0x01, 0x00, 0x00 },
{ 0xf2, 0xf7, 0x20, 0x20, 0x10, 0xa0, 0x08, 0xa0, 0x01, 0xfc, 0x41, 0x20, 0x22, 0x20, 0x10, 0x20, 0x03, 0xfe, 0x00, 0x20, 0x70, 0x50, 0x10, 0x50, 0x10, 0x88, 0x13, 0x06, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf2, 0xf8, 0x12, 0x04, 0x12, 0x24, 0x7f, 0x94, 0x12, 0x04, 0x1e, 0x04, 0x12, 0x44, 0x1e, 0x24, 0x12, 0x04, 0x12, 0x07, 0x7f, 0xcc, 0x2a, 0x34, 0x2a, 0x84, 0x33, 0x84, 0x20, 0x04, 0x3f, 0xc4, 0x00, 0x00 },
{ 0xf2, 0xf9, 0x3c, 0x5c, 0x24, 0x44, 0x24, 0x82, 0x25, 0x7d, 0x34, 0x10, 0x2c, 0x10, 0x24, 0x10, 0x25, 0xff, 0x34, 0x10, 0x2c, 0x28, 0x24, 0x28, 0x24, 0x44, 0x24, 0x44, 0x44, 0x82, 0x4d, 0x01, 0x00, 0x00 },
{ 0xf2, 0xfa, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x10, 0x40, 0x10, 0x40, 0x37, 0xfe, 0x30, 0x40, 0x50, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x00, 0x00 },
{ 0xf2, 0xfb, 0x08, 0x20, 0x08, 0x20, 0x3e, 0x20, 0x08, 0x20, 0x08, 0xfc, 0x7f, 0x24, 0x22, 0x24, 0x14, 0xa4, 0x7f, 0x64, 0x08, 0x34, 0x08, 0x2c, 0x3e, 0x25, 0x08, 0x45, 0x08, 0x43, 0x08, 0x81, 0x00, 0x00 },
{ 0xf2, 0xfc, 0x21, 0x10, 0x11, 0x20, 0x0b, 0xfe, 0x42, 0x20, 0x27, 0xfc, 0x12, 0x20, 0x03, 0xfc, 0x02, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x27, 0xff, 0x20, 0x70, 0x41, 0xac, 0x46, 0x23, 0x00, 0x20, 0x00, 0x00 },
{ 0xf2, 0xfd, 0x10, 0x00, 0x10, 0xfc, 0x24, 0x84, 0x44, 0x84, 0x28, 0xfc, 0x10, 0x00, 0x11, 0xff, 0x24, 0x84, 0x7c, 0xfc, 0x14, 0x84, 0x50, 0xfc, 0x54, 0x84, 0x54, 0x9c, 0x11, 0xe4, 0x10, 0x04, 0x00, 0x00 },
{ 0xf2, 0xfe, 0x10, 0x00, 0x10, 0x7c, 0x7c, 0x44, 0x10, 0x7c, 0x7c, 0x00, 0x55, 0xff, 0x7c, 0x44, 0x54, 0x7c, 0x54, 0x44, 0x7c, 0x7c, 0x10, 0x44, 0x7c, 0x5f, 0x11, 0xe4, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00 },
{ 0xf3, 0xa1, 0x18, 0x88, 0x14, 0x90, 0x25, 0xfe, 0x21, 0x10, 0x7f, 0xfe, 0x11, 0x10, 0x11, 0xfe, 0x7d, 0x10, 0x11, 0xff, 0x54, 0x20, 0x57, 0xff, 0x50, 0x70, 0x1c, 0xac, 0x73, 0x23, 0x00, 0x20, 0x00, 0x00 },
{ 0xf3, 0xa2, 0x04, 0x40, 0x08, 0x80, 0x1f, 0xfe, 0x30, 0x80, 0x5f, 0xfc, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xa3, 0x11, 0x08, 0x15, 0x48, 0x25, 0x48, 0x27, 0xdf, 0x40, 0x12, 0x10, 0x32, 0x17, 0xd2, 0x21, 0x12, 0x21, 0x12, 0x67, 0xd4, 0x21, 0x0c, 0x21, 0x0c, 0x21, 0xca, 0x27, 0x12, 0x20, 0x21, 0x00, 0x00 },
{ 0xf3, 0xa4, 0x11, 0x08, 0x15, 0x48, 0x25, 0x48, 0x4f, 0xdf, 0x10, 0x12, 0x37, 0xea, 0x51, 0x0a, 0x17, 0xc4, 0x11, 0x04, 0x11, 0xca, 0x17, 0x11, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xf3, 0xa5, 0x20, 0x00, 0x13, 0xd2, 0x08, 0x54, 0x02, 0x89, 0x41, 0x8a, 0x21, 0x74, 0x12, 0x02, 0x05, 0xfd, 0x01, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x20, 0x00, 0x21, 0x04, 0x40, 0x88, 0x47, 0xff, 0x00, 0x00 },
{ 0xf3, 0xa6, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf3, 0xa7, 0x08, 0x20, 0x08, 0x20, 0x13, 0xfe, 0x12, 0x02, 0x32, 0x02, 0x30, 0x38, 0x53, 0xc0, 0x10, 0x40, 0x10, 0x40, 0x17, 0xfe, 0x10, 0x40, 0x10, 0x40, 0x10, 0x42, 0x10, 0x42, 0x10, 0x3e, 0x00, 0x00 },
{ 0xf3, 0xa8, 0x08, 0x88, 0x08, 0x88, 0x13, 0xfe, 0x10, 0x88, 0x30, 0x88, 0x37, 0xff, 0x50, 0x00, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xa9, 0x00, 0x00, 0x3f, 0xf8, 0x08, 0x08, 0x09, 0x08, 0x04, 0x90, 0x04, 0x90, 0x02, 0x20, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xf3, 0xaa, 0x00, 0x84, 0x00, 0x48, 0x7b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x80, 0x48, 0x80, 0x79, 0x7e, 0x02, 0x10, 0x0c, 0x10, 0x01, 0xff, 0x00, 0x00 },
{ 0xf3, 0xab, 0x10, 0x82, 0x10, 0x44, 0x11, 0xff, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x54, 0x10, 0x55, 0xff, 0x54, 0x80, 0x54, 0x80, 0x55, 0xfe, 0x7d, 0x10, 0x02, 0x10, 0x04, 0x10, 0x09, 0xff, 0x00, 0x00 },
{ 0xf3, 0xac, 0x04, 0x10, 0x02, 0x20, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xfe, 0x10, 0x40, 0x20, 0x40, 0x4f, 0xff, 0x00, 0x00 },
{ 0xf3, 0xad, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x79, 0xff, 0x01, 0x21, 0x02, 0x22, 0x02, 0x24, 0x00, 0x20, 0x00, 0x50, 0x08, 0x50, 0x10, 0x88, 0x20, 0x88, 0x41, 0x04, 0x02, 0x02, 0x04, 0x01, 0x00, 0x00 },
{ 0xf3, 0xae, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x24, 0x21, 0x24, 0x26, 0x27, 0xb8, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x27, 0xa1, 0x3c, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xf3, 0xaf, 0x00, 0x82, 0x7c, 0x44, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x20, 0xfe, 0x3c, 0x10, 0x24, 0x10, 0x65, 0xff, 0x24, 0x40, 0x24, 0x40, 0x24, 0xfe, 0x3d, 0x10, 0x02, 0x10, 0x04, 0xff, 0x00, 0x00 },
{ 0xf3, 0xb0, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x04, 0x00, 0x0a, 0x02, 0x11, 0x12, 0x20, 0x92, 0x5f, 0x12, 0x00, 0x12, 0x3f, 0x12, 0x21, 0x12, 0x21, 0x02, 0x21, 0x02, 0x3f, 0x0e, 0x00, 0x00 },
{ 0xf3, 0xb1, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x20, 0x84, 0x00, 0x00 },
{ 0xf3, 0xb2, 0x00, 0x42, 0x3e, 0x24, 0x22, 0xff, 0x22, 0x10, 0x22, 0x7e, 0x3e, 0x10, 0x08, 0x10, 0x08, 0xff, 0x08, 0x20, 0x2e, 0x20, 0x28, 0x7e, 0x28, 0x48, 0x28, 0x88, 0x2f, 0x08, 0x70, 0x7f, 0x00, 0x00 },
{ 0xf3, 0xb3, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xb4, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xfe, 0x02, 0x48, 0x42, 0x48, 0x23, 0xfe, 0x12, 0x48, 0x02, 0x48, 0x02, 0x78, 0x72, 0x00, 0x14, 0xaa, 0x15, 0x2a, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf3, 0xb5, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x1c, 0x10, 0x70, 0x10, 0x10, 0x9e, 0x10, 0x90, 0x10, 0x90, 0x11, 0x50, 0x11, 0x30, 0x32, 0x0f, 0x00, 0x00 },
{ 0xf3, 0xb6, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7e, 0x49, 0x10, 0x48, 0x10, 0x89, 0x13, 0x27, 0x1c, 0x40, 0x70, 0xff, 0x11, 0x20, 0x12, 0x3e, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x30, 0x20, 0x00, 0x00 },
{ 0xf3, 0xb7, 0x08, 0x08, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x00, 0x0f, 0xf8, 0x14, 0x08, 0x17, 0xf8, 0x24, 0x08, 0x47, 0xf8, 0x04, 0x08, 0x07, 0xf8, 0x00, 0x00 },
{ 0xf3, 0xb8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x09, 0x3c, 0x32, 0x00, 0x07, 0xff, 0x19, 0x00, 0x61, 0xfe, 0x01, 0x00, 0x01, 0xfe, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00 },
{ 0xf3, 0xb9, 0x08, 0x24, 0x14, 0x24, 0x22, 0xff, 0x40, 0x24, 0x3e, 0x24, 0x08, 0x24, 0x08, 0xff, 0x7e, 0x00, 0x08, 0x7e, 0x4a, 0x42, 0x2a, 0x42, 0x28, 0x7e, 0x08, 0x42, 0x0e, 0x42, 0x70, 0x7e, 0x00, 0x00 },
{ 0xf3, 0xba, 0x55, 0x00, 0x14, 0x3c, 0x7f, 0xa5, 0x12, 0x27, 0x7f, 0x40, 0x49, 0x3e, 0x6b, 0x24, 0x49, 0x18, 0x7f, 0x94, 0x02, 0x63, 0x0d, 0xd8, 0x70, 0x87, 0x0f, 0xf8, 0x04, 0x90, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf3, 0xbb, 0x08, 0x00, 0x28, 0x3e, 0x2f, 0x22, 0x28, 0x22, 0x7f, 0xa2, 0x00, 0x3e, 0x55, 0x08, 0x6b, 0x08, 0x41, 0x28, 0x7f, 0x2f, 0x55, 0x28, 0x55, 0x28, 0x6b, 0x58, 0x41, 0x48, 0x7f, 0x87, 0x00, 0x00 },
{ 0xf3, 0xbc, 0x10, 0x00, 0x11, 0xef, 0x11, 0x29, 0x7d, 0xef, 0x11, 0x08, 0x11, 0x29, 0x11, 0xef, 0x1c, 0x44, 0x71, 0xff, 0x10, 0x44, 0x10, 0x44, 0x11, 0xff, 0x10, 0x00, 0x10, 0x46, 0x31, 0x81, 0x00, 0x00 },
{ 0xf3, 0xbd, 0x20, 0x80, 0x10, 0xef, 0x08, 0x81, 0x41, 0xea, 0x22, 0x26, 0x15, 0x45, 0x01, 0x89, 0x06, 0x10, 0x10, 0x92, 0x10, 0x54, 0x21, 0xff, 0x20, 0x38, 0x40, 0x54, 0x40, 0x92, 0x03, 0x11, 0x00, 0x00 },
{ 0xf3, 0xbe, 0x10, 0x80, 0x10, 0xef, 0x14, 0x89, 0x55, 0xea, 0x5a, 0x2a, 0x55, 0x44, 0x50, 0x8a, 0x13, 0x11, 0x10, 0x92, 0x10, 0x54, 0x29, 0xff, 0x24, 0x38, 0x20, 0x54, 0x41, 0x93, 0x40, 0x10, 0x00, 0x00 },
{ 0xf3, 0xbf, 0x00, 0x80, 0x7c, 0xef, 0x10, 0x81, 0x11, 0xea, 0x12, 0x26, 0x7d, 0x45, 0x11, 0x89, 0x16, 0x10, 0x10, 0x92, 0x10, 0x54, 0x1d, 0xff, 0x70, 0x38, 0x00, 0x54, 0x00, 0x92, 0x03, 0x11, 0x00, 0x00 },
{ 0xf3, 0xc0, 0x02, 0x94, 0x7f, 0xde, 0x10, 0xa4, 0x13, 0xdf, 0x11, 0xa4, 0x7e, 0xcd, 0x10, 0x97, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x1d, 0xfc, 0x71, 0x04, 0x41, 0xfc, 0x00, 0x88, 0x03, 0x04, 0x00, 0x00 },
{ 0xf3, 0xc1, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x5c, 0x7d, 0x03, 0x00, 0x1c, 0x7c, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x80, 0x1e, 0xf4, 0x10, 0x84, 0x1e, 0xf4, 0x10, 0x85, 0x16, 0xb3, 0x79, 0xc1, 0x00, 0x00 },
{ 0xf3, 0xc2, 0x10, 0x40, 0x1f, 0x7e, 0x24, 0x90, 0x4f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x00, 0x7f, 0xff, 0x09, 0x08, 0x12, 0x44, 0x6c, 0x93, 0x01, 0x38, 0x07, 0xc8, 0x00, 0x00 },
{ 0xf3, 0xc3, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x4f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x02, 0x00, 0x7f, 0xff, 0x0c, 0x8c, 0x73, 0x23, 0x1f, 0xfe, 0x04, 0x90, 0x18, 0x8c, 0x00, 0x00 },
{ 0xf3, 0xc4, 0x04, 0x00, 0x07, 0x7e, 0x14, 0x22, 0x1f, 0x24, 0x21, 0x18, 0x52, 0x14, 0x0c, 0x63, 0x70, 0x00, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xc5, 0x12, 0x94, 0x13, 0xde, 0x24, 0xa4, 0x4b, 0xdf, 0x29, 0x6a, 0x12, 0x53, 0x14, 0xff, 0x24, 0x82, 0x7c, 0xfe, 0x14, 0x82, 0x50, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xf3, 0xc6, 0x01, 0x4a, 0x3d, 0xef, 0x02, 0x52, 0x7d, 0xef, 0x00, 0xc6, 0x3d, 0x6b, 0x02, 0x00, 0x3c, 0xfe, 0x00, 0x82, 0x00, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x3d, 0x83, 0x00, 0x00 },
{ 0xf3, 0xc7, 0x28, 0x28, 0x3e, 0x3e, 0x48, 0x48, 0x7f, 0x7f, 0x14, 0x14, 0x25, 0x25, 0x4f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x38, 0x0e, 0x00, 0x00 },
{ 0xf3, 0xc8, 0x12, 0x94, 0x2b, 0xde, 0x44, 0xa4, 0x03, 0xdf, 0x7d, 0xa4, 0x12, 0xcd, 0x10, 0x97, 0x7c, 0x00, 0x10, 0xfc, 0x10, 0x84, 0x54, 0xfc, 0x34, 0x84, 0x10, 0xfc, 0x18, 0x48, 0x61, 0x86, 0x00, 0x00 },
{ 0xf3, 0xc9, 0x04, 0x00, 0x07, 0x7e, 0x14, 0x24, 0x3e, 0x18, 0x54, 0xa4, 0x19, 0x42, 0x66, 0x30, 0x18, 0x8c, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xfa, 0x08, 0x24, 0x7f, 0x1f, 0x00, 0x00 },
{ 0xf3, 0xca, 0x08, 0x00, 0x14, 0xef, 0x22, 0xa9, 0x5c, 0xef, 0x00, 0x88, 0x3c, 0xa9, 0x24, 0xef, 0x3c, 0x44, 0x24, 0xfe, 0x3c, 0x44, 0x20, 0x44, 0x3d, 0xff, 0x20, 0x00, 0x3c, 0x46, 0x21, 0x81, 0x00, 0x00 },
{ 0xf3, 0xcb, 0x00, 0x81, 0x30, 0x81, 0x09, 0x11, 0x06, 0x11, 0x19, 0x11, 0x60, 0x91, 0x04, 0x11, 0x04, 0x11, 0x7f, 0x91, 0x0c, 0x11, 0x16, 0x11, 0x15, 0x01, 0x24, 0x81, 0x44, 0x01, 0x04, 0x07, 0x00, 0x00 },
{ 0xf3, 0xcc, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x02, 0x20, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xf3, 0xcd, 0x10, 0x20, 0x13, 0xff, 0x12, 0x81, 0x78, 0xee, 0x11, 0xaa, 0x12, 0x4a, 0x11, 0x84, 0x19, 0x7a, 0x72, 0x01, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x11, 0x24, 0x12, 0x22, 0x30, 0x60, 0x00, 0x00 },
{ 0xf3, 0xce, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x20, 0x08, 0x20, 0x08, 0x20, 0x1c, 0x20, 0x1a, 0x20, 0x2a, 0x20, 0x29, 0x20, 0x49, 0x20, 0x48, 0x21, 0x08, 0x21, 0x08, 0x21, 0x08, 0x1f, 0x00, 0x00 },
{ 0xf3, 0xcf, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x20, 0x08, 0x20, 0x1e, 0x21, 0x29, 0x21, 0x48, 0x1f, 0x01, 0x00, 0x0a, 0x20, 0x04, 0x44, 0x02, 0x82, 0x7f, 0xfd, 0x00, 0x81, 0x08, 0x8c, 0x30, 0x82, 0x00, 0x00 },
{ 0xf3, 0xd0, 0x08, 0x00, 0x0f, 0xdf, 0x15, 0x14, 0x15, 0x14, 0x37, 0xdf, 0x31, 0x04, 0x53, 0x4d, 0x55, 0x97, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xd1, 0x01, 0x00, 0x02, 0x08, 0x3f, 0xf4, 0x10, 0x0a, 0x24, 0x12, 0x7a, 0xbd, 0x01, 0x40, 0x06, 0x30, 0x18, 0x4c, 0x61, 0x83, 0x0e, 0x20, 0x00, 0xc0, 0x0f, 0x08, 0x00, 0x70, 0x1f, 0x80, 0x00, 0x00 },
{ 0xf3, 0xd2, 0x08, 0x0e, 0x7f, 0x70, 0x08, 0x40, 0x3e, 0x40, 0x2a, 0x7f, 0x3e, 0x44, 0x2a, 0x44, 0x3e, 0x44, 0x08, 0x44, 0x7f, 0x84, 0x08, 0x04, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf3, 0xd3, 0x10, 0x20, 0x10, 0x48, 0x11, 0xf4, 0x59, 0x08, 0x56, 0x52, 0x53, 0xde, 0x50, 0x20, 0x10, 0xd8, 0x17, 0x07, 0x10, 0x60, 0x11, 0x88, 0x10, 0x30, 0x11, 0xc6, 0x10, 0x18, 0x13, 0xe0, 0x00, 0x00 },
{ 0xf3, 0xd4, 0x04, 0x06, 0x7f, 0xb8, 0x04, 0x20, 0x3f, 0xa0, 0x24, 0xbf, 0x3f, 0xa4, 0x24, 0xa4, 0x3f, 0xa4, 0x04, 0x24, 0x7f, 0x44, 0x04, 0x44, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xf3, 0xd5, 0x12, 0x48, 0x12, 0xca, 0x15, 0x29, 0x58, 0x08, 0x57, 0xff, 0x52, 0x88, 0x56, 0xe8, 0x12, 0x8a, 0x16, 0xea, 0x12, 0x8a, 0x16, 0xe4, 0x12, 0x85, 0x12, 0xed, 0x17, 0x13, 0x10, 0x21, 0x00, 0x00 },
{ 0xf3, 0xd6, 0x08, 0x03, 0x08, 0x3c, 0x7f, 0xa0, 0x08, 0x20, 0x3f, 0x20, 0x29, 0x3f, 0x3f, 0x24, 0x29, 0x24, 0x29, 0x24, 0x3f, 0x24, 0x08, 0x24, 0x7f, 0xa4, 0x08, 0x44, 0x08, 0x44, 0x08, 0x84, 0x00, 0x00 },
{ 0xf3, 0xd7, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7e, 0x1f, 0x00, 0x10, 0x04, 0x10, 0x44, 0x10, 0x24, 0x10, 0x24, 0xfe, 0x28, 0x82, 0x08, 0x82, 0x0e, 0x82, 0x70, 0x82, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xd8, 0x00, 0x38, 0x3c, 0x48, 0x00, 0xfe, 0x7e, 0x42, 0x00, 0x7e, 0x3c, 0x88, 0x00, 0xee, 0x3c, 0x99, 0x01, 0xef, 0x00, 0x24, 0x3c, 0x7f, 0x25, 0xc9, 0x24, 0x7f, 0x24, 0x29, 0x3d, 0xcf, 0x00, 0x00 },
{ 0xf3, 0xd9, 0x00, 0x08, 0x39, 0x48, 0x01, 0x4a, 0x7a, 0xa9, 0x00, 0x08, 0x03, 0xff, 0x39, 0x48, 0x03, 0x68, 0x39, 0x4a, 0x03, 0x6a, 0x01, 0x44, 0x3b, 0x65, 0x29, 0x4d, 0x29, 0xf3, 0x3f, 0x21, 0x00, 0x00 },
{ 0xf3, 0xda, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x1b, 0xec, 0x60, 0x03, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x0f, 0xfc, 0x10, 0x00, 0x17, 0xfc, 0x24, 0x04, 0x44, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xdb, 0x08, 0x00, 0x09, 0xfc, 0x09, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x31, 0x04, 0x31, 0xfc, 0x50, 0x00, 0x53, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xdc, 0x02, 0x00, 0x05, 0x01, 0x08, 0x89, 0x17, 0x49, 0x20, 0x29, 0x5f, 0xc9, 0x10, 0x49, 0x1f, 0xc9, 0x10, 0x49, 0x1f, 0xc9, 0x10, 0x09, 0x2f, 0xc1, 0x28, 0x41, 0x48, 0x41, 0x0f, 0xc7, 0x00, 0x00 },
{ 0xf3, 0xdd, 0x00, 0x00, 0x00, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x00, 0x24, 0x00, 0x25, 0xff, 0x25, 0x01, 0x3d, 0x01, 0x01, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0x00, 0x00 },
{ 0xf3, 0xde, 0x10, 0x00, 0x10, 0x7e, 0x10, 0x42, 0x7c, 0x7e, 0x24, 0x42, 0x24, 0x7e, 0x24, 0x00, 0x24, 0x00, 0x44, 0xff, 0x68, 0x81, 0x58, 0x81, 0x08, 0xff, 0x14, 0x81, 0x22, 0x81, 0x40, 0xff, 0x00, 0x00 },
{ 0xf3, 0xdf, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x2a, 0x90, 0x32, 0x50, 0x2f, 0x9f, 0x28, 0x92, 0x2e, 0xaa, 0x2a, 0xaa, 0x2a, 0x8a, 0x2e, 0x84, 0x48, 0x8a, 0x48, 0x8a, 0x49, 0x91, 0x00, 0x00 },
{ 0xf3, 0xe0, 0x04, 0x01, 0x7f, 0xc2, 0x11, 0x04, 0x0a, 0x18, 0x7f, 0xc0, 0x00, 0x01, 0x3f, 0x82, 0x20, 0x84, 0x3f, 0x98, 0x20, 0x80, 0x3f, 0x80, 0x04, 0x01, 0x7f, 0xc2, 0x04, 0x0c, 0x04, 0x30, 0x00, 0x00 },
{ 0xf3, 0xe1, 0x10, 0x30, 0x10, 0x48, 0x18, 0x84, 0x55, 0xfb, 0x54, 0x00, 0x51, 0xfc, 0x51, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x12, 0x00, 0x13, 0xfe, 0x15, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xe2, 0x08, 0x10, 0x2a, 0x10, 0x29, 0x10, 0x48, 0xa0, 0x08, 0x3f, 0x7f, 0x62, 0x41, 0xa2, 0x41, 0x22, 0x5d, 0x22, 0x55, 0x14, 0x55, 0x14, 0x5d, 0x08, 0x41, 0x14, 0x41, 0x22, 0x43, 0x41, 0x00, 0x00 },
{ 0xf3, 0xe3, 0x00, 0x00, 0x0f, 0xf0, 0x08, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x00, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xe4, 0x00, 0x00, 0x3f, 0x3e, 0x00, 0x22, 0x3c, 0x22, 0x04, 0x3e, 0x04, 0xa2, 0x75, 0x22, 0x16, 0x22, 0x15, 0x22, 0x15, 0x3e, 0x14, 0x80, 0x24, 0x40, 0x24, 0x30, 0x44, 0x0f, 0x1c, 0x00, 0x00, 0x00 },
{ 0xf3, 0xe5, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x7c, 0x00, 0x55, 0xff, 0x54, 0x40, 0x7c, 0xff, 0x13, 0x25, 0x10, 0x49, 0x11, 0x91, 0x10, 0x21, 0x10, 0xc6, 0x00, 0x00 },
{ 0xf3, 0xe6, 0x10, 0x38, 0x10, 0x44, 0x10, 0x82, 0x7d, 0x7d, 0x10, 0x00, 0x10, 0xfe, 0x38, 0x82, 0x38, 0xfe, 0x34, 0x82, 0x54, 0xfe, 0x51, 0x00, 0x51, 0xfe, 0x12, 0x82, 0x14, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xe7, 0x20, 0x60, 0x10, 0x90, 0x09, 0x08, 0x02, 0xf4, 0x44, 0x03, 0x23, 0xfc, 0x12, 0x04, 0x03, 0xfc, 0x02, 0x04, 0x13, 0xfc, 0x12, 0x00, 0x23, 0xfe, 0x25, 0x02, 0x45, 0x02, 0x49, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xe8, 0x20, 0x00, 0x17, 0x3f, 0x09, 0x20, 0x01, 0x3e, 0x41, 0x20, 0x27, 0x3e, 0x14, 0x20, 0x04, 0x20, 0x07, 0x7f, 0x15, 0x28, 0x11, 0x29, 0x21, 0x26, 0x21, 0x24, 0x41, 0x3a, 0x46, 0x61, 0x00, 0x00 },
{ 0xf3, 0xe9, 0x04, 0x00, 0x44, 0xfe, 0x28, 0x82, 0x10, 0xfe, 0x30, 0x82, 0x50, 0x82, 0x08, 0xfe, 0x08, 0x00, 0x19, 0xff, 0x29, 0x01, 0x49, 0x01, 0x09, 0xff, 0x09, 0x01, 0x09, 0x01, 0x31, 0xff, 0x00, 0x00 },
{ 0xf3, 0xea, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x60, 0x50, 0x90, 0x33, 0x6c, 0x1c, 0x03, 0x13, 0xfc, 0x32, 0x04, 0x53, 0xfc, 0x12, 0x00, 0x13, 0xfc, 0x25, 0x04, 0x25, 0x04, 0x49, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xeb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x41, 0x44, 0x45, 0x08, 0x3c, 0x31, 0x00, 0x02, 0x08, 0x04, 0x3c, 0x3f, 0xc2, 0x00, 0x82, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xf3, 0xec, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x80, 0x24, 0xfc, 0x24, 0x80, 0x3c, 0xfc, 0x24, 0x80, 0x24, 0x80, 0x25, 0xff, 0x3c, 0x90, 0x24, 0x92, 0x24, 0x8c, 0x24, 0x88, 0x44, 0xf4, 0x4d, 0x83, 0x00, 0x00 },
{ 0xf3, 0xed, 0x08, 0x18, 0x10, 0x24, 0x3e, 0x42, 0x22, 0xbd, 0x2a, 0x00, 0x2a, 0x7e, 0x22, 0x42, 0x27, 0x7e, 0x7a, 0x42, 0x2a, 0x7e, 0x2a, 0x40, 0x2a, 0xbf, 0x22, 0xa1, 0x43, 0x21, 0x46, 0x3f, 0x00, 0x00 },
{ 0xf3, 0xee, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xef, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x01, 0xc0, 0x06, 0x30, 0x18, 0x0c, 0x63, 0xe3, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x10, 0x00, 0x17, 0xfc, 0x24, 0x04, 0x47, 0xfc, 0x00, 0x00 },
{ 0xf3, 0xf0, 0x08, 0x20, 0x0b, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x30, 0x20, 0x37, 0xff, 0x51, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x10, 0x00, 0x11, 0x8c, 0x16, 0x03, 0x00, 0x00 },
{ 0xf3, 0xf1, 0x10, 0x00, 0x10, 0x06, 0x11, 0xf8, 0x11, 0x24, 0x12, 0x12, 0x7e, 0x12, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x1c, 0x70, 0x70, 0xa8, 0x01, 0x24, 0x06, 0x23, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xf3, 0xf2, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x39, 0x5f, 0xe1, 0x12, 0x18, 0x21, 0x04, 0x41, 0x02, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xf3, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x5f, 0xfd, 0x02, 0x20, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x18, 0x8c, 0x67, 0xf3, 0x01, 0xc0, 0x06, 0xb0, 0x38, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xf4, 0x03, 0x82, 0x7c, 0x04, 0x00, 0x98, 0x48, 0xa0, 0x25, 0x01, 0x21, 0x02, 0x08, 0x04, 0x08, 0x18, 0x7f, 0x20, 0x08, 0x00, 0x1c, 0x01, 0x2a, 0x02, 0x29, 0x0c, 0x48, 0x30, 0x08, 0xc0, 0x00, 0x00 },
{ 0xf3, 0xf5, 0x10, 0x87, 0x10, 0xf8, 0x10, 0x80, 0x7d, 0x24, 0x11, 0x12, 0x12, 0x12, 0x10, 0x00, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x38, 0x10, 0x54, 0x10, 0x92, 0x11, 0x11, 0x10, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xf3, 0xf6, 0x04, 0x20, 0x24, 0x23, 0x27, 0xbc, 0x24, 0x20, 0x24, 0x21, 0x27, 0xa1, 0x78, 0x1f, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfe, 0x14, 0x02, 0x64, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xf3, 0xf7, 0x10, 0x0e, 0x10, 0xf0, 0x24, 0x84, 0x44, 0x92, 0x29, 0x09, 0x11, 0x00, 0x10, 0x10, 0x24, 0x10, 0x7d, 0xff, 0x14, 0x38, 0x50, 0x38, 0x54, 0x54, 0x54, 0x92, 0x11, 0x11, 0x10, 0x10, 0x00, 0x00 },
{ 0xf3, 0xf8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x3e, 0x3f, 0xc0, 0x11, 0x04, 0x08, 0x88, 0x00, 0x90, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xf9, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x08, 0x00, 0x0f, 0x3e, 0x11, 0x22, 0x6a, 0x14, 0x14, 0x18, 0x1b, 0xe4, 0x60, 0x03, 0x1f, 0xfc, 0x00, 0x80, 0x08, 0x8c, 0x10, 0x82, 0x61, 0x81, 0x00, 0x00 },
{ 0xf3, 0xfa, 0x08, 0x00, 0x08, 0x3c, 0x1f, 0xc0, 0x12, 0x10, 0x21, 0x08, 0x41, 0x08, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf3, 0xfb, 0x08, 0x00, 0x14, 0xfe, 0x22, 0x02, 0x40, 0x42, 0x3e, 0x52, 0x08, 0x4a, 0x08, 0x42, 0x7e, 0x24, 0x08, 0x24, 0x4a, 0x24, 0x2a, 0x18, 0x28, 0x18, 0x08, 0x24, 0x0e, 0x42, 0x70, 0x81, 0x00, 0x00 },
{ 0xf3, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x10, 0x1c, 0x00, 0x00 },
{ 0xf3, 0xfd, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x52, 0x7d, 0x52, 0x11, 0x52, 0x11, 0x52, 0x39, 0x52, 0x3b, 0xff, 0x35, 0x52, 0x55, 0x52, 0x51, 0x52, 0x51, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x06, 0x00, 0x00 },
{ 0xf3, 0xfe, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x21, 0xc2, 0x22, 0xae, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf4, 0xa1, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x08, 0x08, 0x30, 0x06, 0x00, 0x00 },
{ 0xf4, 0xa2, 0x00, 0x40, 0x47, 0xff, 0x20, 0x40, 0x13, 0xfc, 0x00, 0x44, 0x07, 0xff, 0x00, 0x44, 0x03, 0xfc, 0x10, 0x80, 0x1f, 0xff, 0x21, 0x08, 0x23, 0x90, 0x40, 0x70, 0x40, 0xcc, 0x07, 0x02, 0x00, 0x00 },
{ 0xf4, 0xa3, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x08, 0x04, 0x10, 0x0b, 0xa0, 0x00, 0x78, 0x3f, 0x87, 0x00, 0x00 },
{ 0xf4, 0xa4, 0x10, 0x20, 0x10, 0x20, 0x1b, 0xff, 0x54, 0x20, 0x55, 0xfc, 0x50, 0x24, 0x53, 0xff, 0x10, 0x24, 0x11, 0xfc, 0x10, 0x40, 0x13, 0xff, 0x10, 0x84, 0x11, 0xc8, 0x10, 0x38, 0x13, 0xc6, 0x00, 0x00 },
{ 0xf4, 0xa5, 0x01, 0x00, 0x01, 0xf8, 0x01, 0x00, 0x3f, 0xff, 0x21, 0x01, 0x21, 0xf1, 0x2f, 0x04, 0x20, 0xfc, 0x24, 0x00, 0x27, 0x38, 0x29, 0x28, 0x55, 0x2a, 0x42, 0x4e, 0x45, 0x00, 0x58, 0xff, 0x00, 0x00 },
{ 0xf4, 0xa6, 0x08, 0x00, 0x0b, 0xfe, 0x0a, 0x22, 0x12, 0x22, 0x12, 0xfa, 0x32, 0x22, 0x32, 0xfa, 0x52, 0x02, 0x12, 0xfa, 0x12, 0x8a, 0x12, 0x8a, 0x12, 0x8a, 0x14, 0xfa, 0x14, 0x02, 0x18, 0x0c, 0x00, 0x00 },
{ 0xf4, 0xa7, 0x04, 0x02, 0x04, 0x02, 0x7f, 0xd2, 0x04, 0x12, 0x3f, 0x92, 0x24, 0x92, 0x24, 0x92, 0x24, 0x92, 0x25, 0x92, 0x04, 0x12, 0x0e, 0x12, 0x15, 0x02, 0x24, 0x82, 0x44, 0x82, 0x04, 0x1e, 0x00, 0x00 },
{ 0xf4, 0xa8, 0x00, 0x01, 0x3f, 0x81, 0x20, 0x91, 0x3f, 0x91, 0x20, 0x91, 0x3f, 0x91, 0x08, 0x11, 0x10, 0x11, 0x1f, 0xd1, 0x25, 0x51, 0x49, 0x51, 0x12, 0x41, 0x24, 0x41, 0x48, 0x41, 0x11, 0x87, 0x00, 0x00 },
{ 0xf4, 0xa9, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x80, 0x10, 0x40, 0x10, 0x40, 0x10, 0x20, 0x10, 0x10, 0x20, 0x08, 0x20, 0x04, 0x40, 0x03, 0x00, 0x00 },
{ 0xf4, 0xaa, 0x10, 0x0a, 0x10, 0x09, 0x13, 0xff, 0x1a, 0x08, 0x56, 0x48, 0x56, 0x49, 0x52, 0x79, 0x52, 0x49, 0x13, 0xfa, 0x12, 0x4a, 0x12, 0xea, 0x12, 0xdd, 0x15, 0x55, 0x14, 0x4b, 0x10, 0xd1, 0x00, 0x00 },
{ 0xf4, 0xab, 0x00, 0x24, 0x00, 0x22, 0x3f, 0xff, 0x20, 0x20, 0x22, 0x20, 0x23, 0xa2, 0x22, 0x22, 0x22, 0x12, 0x3f, 0xd4, 0x22, 0x14, 0x2a, 0x88, 0x2a, 0x4d, 0x52, 0x15, 0x42, 0x23, 0x46, 0x41, 0x00, 0x00 },
{ 0xf4, 0xac, 0x10, 0x00, 0x10, 0x00, 0x11, 0xff, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x20, 0x16, 0x40, 0x78, 0xfe, 0x11, 0x82, 0x12, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x70, 0xfe, 0x00, 0x00 },
{ 0xf4, 0xad, 0x11, 0x40, 0x12, 0x2f, 0x15, 0xd9, 0x78, 0x89, 0x13, 0xea, 0x12, 0xaa, 0x13, 0x6c, 0x1a, 0x2a, 0x73, 0xea, 0x12, 0x29, 0x13, 0xe9, 0x10, 0x89, 0x17, 0xee, 0x11, 0x48, 0x36, 0x28, 0x00, 0x00 },
{ 0xf4, 0xae, 0x00, 0x06, 0x00, 0x78, 0x1f, 0x80, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x40, 0x10, 0x40, 0x13, 0xc0, 0x10, 0x70, 0x10, 0x4c, 0x20, 0x42, 0x20, 0x40, 0x40, 0x40, 0x00, 0x00 },
{ 0xf4, 0xaf, 0x21, 0x10, 0x11, 0x10, 0x0a, 0x3f, 0x02, 0x24, 0x46, 0xd4, 0x2a, 0x88, 0x02, 0x94, 0x02, 0xa3, 0x02, 0x88, 0x12, 0xbf, 0x12, 0x88, 0x22, 0x9c, 0x22, 0xaa, 0x42, 0xc9, 0x42, 0x88, 0x00, 0x00 },
{ 0xf4, 0xb0, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x57, 0x4e, 0x30, 0x40, 0x16, 0xae, 0x11, 0x10, 0x32, 0x0c, 0x55, 0xfb, 0x11, 0x08, 0x11, 0xf8, 0x21, 0x08, 0x21, 0x08, 0x41, 0x18, 0x00, 0x00 },
{ 0xf4, 0xb1, 0x00, 0x80, 0x7c, 0x9f, 0x01, 0x40, 0x7a, 0x2f, 0x04, 0x10, 0x18, 0x0c, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xf4, 0xb2, 0x00, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x22, 0x80, 0x22, 0x94, 0x3e, 0x94, 0x08, 0xff, 0x08, 0x94, 0x28, 0x94, 0x2e, 0x94, 0x28, 0xff, 0x28, 0x80, 0x29, 0x55, 0x2d, 0x55, 0x72, 0x95, 0x00, 0x00 },
{ 0xf4, 0xb3, 0x7c, 0x10, 0x44, 0x90, 0x44, 0x9e, 0x48, 0x90, 0x48, 0x90, 0x53, 0xff, 0x48, 0x10, 0x48, 0x92, 0x44, 0x92, 0x45, 0x12, 0x46, 0x34, 0x58, 0x04, 0x40, 0x08, 0x40, 0x30, 0x41, 0xc0, 0x00, 0x00 },
{ 0xf4, 0xb4, 0x08, 0x40, 0x1f, 0xfe, 0x30, 0x80, 0x5f, 0xfc, 0x10, 0x80, 0x1f, 0xfc, 0x10, 0x80, 0x1f, 0xfe, 0x00, 0x00, 0x3f, 0xfc, 0x04, 0x08, 0x02, 0x30, 0x01, 0xc0, 0x06, 0x30, 0x78, 0x0f, 0x00, 0x00 },
{ 0xf4, 0xb5, 0x08, 0x0c, 0x08, 0x30, 0x0b, 0xe0, 0x10, 0x20, 0x10, 0x20, 0x30, 0x20, 0x30, 0x20, 0x57, 0xff, 0x50, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf4, 0xb6, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xe0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf4, 0xb7, 0x00, 0x20, 0x02, 0x22, 0x7a, 0x22, 0x4a, 0x22, 0x4b, 0xfe, 0x48, 0x00, 0x4b, 0xfe, 0x48, 0x20, 0x48, 0x40, 0x4b, 0xfe, 0x4a, 0x52, 0x7a, 0x52, 0x02, 0x52, 0x02, 0x52, 0x02, 0x56, 0x00, 0x00 },
{ 0xf4, 0xb8, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x60, 0x03, 0x00, 0x00 },
{ 0xf4, 0xb9, 0x10, 0x01, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x10, 0x41, 0x20, 0x41, 0x20, 0x01, 0x40, 0x01, 0x00, 0x00 },
{ 0xf4, 0xba, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7d, 0x4a, 0x11, 0x7a, 0x11, 0x02, 0x11, 0xfe, 0x1c, 0x00, 0x70, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x10, 0x00, 0x33, 0xff, 0x00, 0x00 },
{ 0xf4, 0xbb, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0xc2, 0x3e, 0xc4, 0x04, 0xa8, 0x08, 0x90, 0x10, 0x8c, 0x60, 0x83, 0x03, 0x80, 0x00, 0x00 },
{ 0xf4, 0xbc, 0x20, 0x48, 0x10, 0x44, 0x08, 0x5f, 0x03, 0xe0, 0x40, 0x24, 0x20, 0x19, 0x10, 0x6d, 0x03, 0x83, 0x00, 0x50, 0x10, 0x4f, 0x17, 0xf0, 0x20, 0x24, 0x20, 0x19, 0x40, 0x6d, 0x47, 0x83, 0x00, 0x00 },
{ 0xf4, 0xbd, 0x00, 0x00, 0x7c, 0x82, 0x10, 0x92, 0x10, 0x92, 0x10, 0x92, 0x7c, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x92, 0x1c, 0x92, 0x70, 0x92, 0x01, 0x12, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00 },
{ 0xf4, 0xbe, 0x00, 0x80, 0x7f, 0xff, 0x42, 0x21, 0x04, 0x22, 0x18, 0x3e, 0x60, 0x00, 0x1f, 0xfc, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x00, 0xa0, 0x03, 0x20, 0x0c, 0x20, 0x70, 0x20, 0x00, 0xe0, 0x00, 0x00 },
{ 0xf4, 0xbf, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1e, 0xff, 0x22, 0x44, 0x22, 0x44, 0x42, 0x44, 0x14, 0x44, 0x0c, 0x44, 0x05, 0xff, 0x08, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x00, 0x00 },
{ 0xf4, 0xc0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x3f, 0xff, 0x22, 0x10, 0x3f, 0xfe, 0x22, 0x12, 0x3f, 0xfe, 0x24, 0x00, 0x27, 0xf8, 0x28, 0x00, 0x4f, 0xff, 0x45, 0x51, 0x49, 0x56, 0x00, 0x00 },
{ 0xf4, 0xc1, 0x00, 0x28, 0x3e, 0x27, 0x22, 0xf8, 0x22, 0x12, 0x3e, 0x0c, 0x22, 0x35, 0x22, 0xc3, 0x3e, 0x08, 0x22, 0x24, 0x22, 0x27, 0x22, 0xf8, 0x3e, 0x12, 0x00, 0x0c, 0x24, 0x35, 0x42, 0xc3, 0x00, 0x00 },
{ 0xf4, 0xc2, 0x00, 0x28, 0x3e, 0x27, 0x22, 0xf8, 0x22, 0x14, 0x22, 0x09, 0x3e, 0x35, 0x08, 0xc3, 0x08, 0x28, 0x28, 0x24, 0x2e, 0x27, 0x28, 0xf8, 0x28, 0x14, 0x28, 0x09, 0x2e, 0x35, 0x70, 0xc3, 0x00, 0x00 },
{ 0xf4, 0xc3, 0x20, 0x00, 0x17, 0xff, 0x08, 0x50, 0x03, 0xfe, 0x42, 0x52, 0x27, 0xff, 0x10, 0x88, 0x01, 0x04, 0x03, 0xfa, 0x75, 0x09, 0x11, 0x78, 0x11, 0x02, 0x11, 0xfe, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf4, 0xc4, 0x08, 0x00, 0x14, 0x41, 0x22, 0x49, 0x40, 0x49, 0x3e, 0x49, 0x08, 0x49, 0x08, 0x49, 0x7e, 0x49, 0x08, 0x49, 0x4a, 0x49, 0x2a, 0x49, 0x28, 0x49, 0x08, 0x89, 0x0e, 0x81, 0x71, 0x01, 0x00, 0x00 },
{ 0xf4, 0xc5, 0x7c, 0x7e, 0x44, 0x42, 0x7c, 0x7e, 0x44, 0x42, 0x7c, 0x7e, 0x4e, 0xe2, 0x4a, 0xa2, 0x4f, 0xe2, 0x45, 0x42, 0x47, 0xc2, 0x45, 0x42, 0x47, 0xc2, 0x41, 0x02, 0x4f, 0xe2, 0x41, 0x0e, 0x00, 0x00 },
{ 0xf4, 0xc6, 0x7c, 0x06, 0x44, 0xf8, 0x44, 0x10, 0x48, 0x10, 0x48, 0x10, 0x50, 0x10, 0x49, 0xff, 0x48, 0x10, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x58, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xf4, 0xc7, 0x28, 0xfe, 0x2a, 0x28, 0x7d, 0xfe, 0x28, 0xaa, 0x38, 0xfe, 0x12, 0x20, 0x7d, 0xff, 0x54, 0x42, 0x54, 0xbd, 0x7f, 0x24, 0x11, 0x2c, 0x7d, 0x22, 0x11, 0x1e, 0x12, 0x80, 0x14, 0x7f, 0x00, 0x00 },
{ 0xf4, 0xc8, 0x00, 0x00, 0x07, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x7c, 0x3e, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xf4, 0xc9, 0x08, 0x07, 0x08, 0x78, 0x7f, 0x40, 0x08, 0x40, 0x08, 0x7f, 0x0e, 0x44, 0x78, 0x84, 0x08, 0x84, 0x19, 0x04, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf4, 0xca, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x3e, 0x00, 0x00 },
{ 0xf4, 0xcb, 0x09, 0x08, 0x09, 0x08, 0x17, 0xe8, 0x21, 0x1f, 0x4a, 0x52, 0x0f, 0xd2, 0x10, 0x22, 0x13, 0xd2, 0x32, 0x52, 0x53, 0xd4, 0x12, 0x4c, 0x13, 0xcc, 0x12, 0x4a, 0x12, 0x52, 0x12, 0xe1, 0x00, 0x00 },
{ 0xf4, 0xcc, 0x11, 0x08, 0x11, 0x08, 0x17, 0xe8, 0x79, 0x0f, 0x12, 0x52, 0x17, 0xd2, 0x10, 0x22, 0x1b, 0xd2, 0x72, 0x52, 0x13, 0xd4, 0x12, 0x4c, 0x13, 0xcc, 0x12, 0x4a, 0x12, 0x52, 0x32, 0xe1, 0x00, 0x00 },
{ 0xf4, 0xcd, 0x41, 0x08, 0x2f, 0xe8, 0x02, 0x08, 0x02, 0x8f, 0x44, 0x4a, 0x2f, 0xd2, 0x00, 0x32, 0x07, 0xda, 0x14, 0x6a, 0x17, 0xc4, 0x24, 0x44, 0x27, 0xca, 0x44, 0x4a, 0x44, 0x51, 0x04, 0xd1, 0x00, 0x00 },
{ 0xf4, 0xce, 0x10, 0x00, 0x11, 0xef, 0x24, 0x21, 0x45, 0x29, 0x28, 0xc6, 0x10, 0xa5, 0x11, 0x08, 0x24, 0x00, 0x7d, 0xef, 0x10, 0x29, 0x55, 0x29, 0x54, 0xca, 0x50, 0x46, 0x10, 0xaa, 0x13, 0x11, 0x00, 0x00 },
{ 0xf4, 0xcf, 0x10, 0x00, 0x11, 0xee, 0x7c, 0x22, 0x10, 0xaa, 0x7c, 0x44, 0x54, 0xaa, 0x7d, 0x12, 0x54, 0x00, 0x7d, 0xfe, 0x10, 0x2a, 0x10, 0xaa, 0x7c, 0x44, 0x10, 0xa4, 0x11, 0x0a, 0x12, 0x11, 0x00, 0x00 },
{ 0xf4, 0xd0, 0x10, 0x88, 0x10, 0x88, 0x7d, 0xe8, 0x10, 0x9f, 0x7d, 0x2a, 0x55, 0xea, 0x7c, 0x0a, 0x55, 0xea, 0x7d, 0x2a, 0x11, 0xea, 0x11, 0x24, 0x7d, 0xe4, 0x11, 0x2a, 0x11, 0x2a, 0x11, 0x71, 0x00, 0x00 },
{ 0xf4, 0xd1, 0x18, 0x8a, 0x25, 0xe9, 0x40, 0x88, 0x03, 0xff, 0x7c, 0x08, 0x11, 0xe8, 0x11, 0x2a, 0x7d, 0xea, 0x10, 0x0a, 0x11, 0xea, 0x54, 0x8a, 0x35, 0xe4, 0x10, 0x85, 0x18, 0xcb, 0x63, 0xb1, 0x00, 0x00 },
{ 0xf4, 0xd2, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x00, 0x1f, 0x7c, 0x11, 0x44, 0x11, 0x44, 0x1f, 0x7c, 0x04, 0x10, 0x0c, 0x30, 0x12, 0x4c, 0x21, 0x82, 0x00, 0x00 },
{ 0xf4, 0xd3, 0x00, 0x80, 0x08, 0x98, 0x08, 0x84, 0x10, 0x82, 0x60, 0x81, 0x03, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xf4, 0xd4, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x00, 0x3f, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x00, 0x20, 0x03, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x22, 0x02, 0x22, 0x02, 0x42, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xf4, 0xd5, 0x20, 0x0e, 0x13, 0xf0, 0x08, 0x20, 0x00, 0x20, 0x47, 0xff, 0x20, 0x50, 0x10, 0x88, 0x01, 0x04, 0x06, 0x43, 0x10, 0x40, 0x10, 0x40, 0x22, 0x52, 0x22, 0x49, 0x44, 0x49, 0x41, 0xc0, 0x00, 0x00 },
{ 0xf4, 0xd6, 0x22, 0x00, 0x22, 0x0e, 0x22, 0x70, 0x7f, 0x10, 0x22, 0x10, 0x22, 0xff, 0x22, 0x10, 0x22, 0x10, 0x3e, 0x10, 0x22, 0x7e, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x22, 0x42, 0x3e, 0x7e, 0x00, 0x00 },
{ 0xf4, 0xd7, 0x00, 0x40, 0x78, 0xfc, 0x49, 0x08, 0x4b, 0xff, 0x49, 0x24, 0x79, 0xc7, 0x49, 0x00, 0x49, 0xff, 0x79, 0x00, 0x49, 0x3c, 0x49, 0x00, 0x49, 0x7e, 0x7a, 0x42, 0x02, 0x42, 0x04, 0x7e, 0x00, 0x00 },
{ 0xf4, 0xd8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x03, 0x60, 0x0c, 0x18, 0x77, 0xf7, 0x00, 0x00, 0x1f, 0x7c, 0x11, 0x44, 0x1f, 0x7c, 0x04, 0x10, 0x0a, 0x18, 0x11, 0x24, 0x60, 0x42, 0x00, 0x00 },
{ 0xf4, 0xd9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x48, 0x90, 0x15, 0x54, 0x22, 0x12, 0x7f, 0xff, 0x09, 0x10, 0x39, 0xd2, 0x09, 0x12, 0x39, 0xd4, 0x09, 0x08, 0x39, 0xc9, 0x0f, 0x15, 0x78, 0x63, 0x00, 0x00 },
{ 0xf4, 0xda, 0x04, 0x00, 0x0f, 0xf0, 0x08, 0x20, 0x1f, 0xff, 0x11, 0x12, 0x32, 0x1c, 0x55, 0xf8, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x13, 0xfc, 0x10, 0x00, 0x27, 0xfe, 0x24, 0x02, 0x47, 0xfe, 0x00, 0x00 },
{ 0xf4, 0xdb, 0x00, 0x20, 0x3c, 0x20, 0x00, 0x7e, 0x7e, 0x42, 0x00, 0x82, 0x3d, 0x02, 0x00, 0x0c, 0x3c, 0x20, 0x00, 0xce, 0x00, 0x82, 0x3c, 0x82, 0x24, 0xee, 0x24, 0x82, 0x24, 0x82, 0x3c, 0xfe, 0x00, 0x00 },
{ 0xf4, 0xdc, 0x10, 0x94, 0x10, 0x94, 0x11, 0xff, 0x10, 0x94, 0x7c, 0x9c, 0x10, 0x80, 0x10, 0xff, 0x10, 0x10, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x38, 0x00, 0x54, 0x00, 0x92, 0x01, 0x11, 0x00, 0x10, 0x00, 0x00 },
{ 0xf4, 0xdd, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x1f, 0x20, 0x00, 0xe0, 0x07, 0x18, 0x38, 0x06, 0x00, 0x00 },
{ 0xf4, 0xde, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7e, 0x10, 0x52, 0x1f, 0x52, 0x10, 0x52, 0x10, 0x52, 0x10, 0x52, 0xfe, 0x52, 0x82, 0x52, 0x82, 0x56, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf4, 0xdf, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x10, 0x10, 0xfe, 0x10, 0x12, 0x11, 0xff, 0x1c, 0x12, 0x70, 0xfe, 0x10, 0x10, 0x10, 0x90, 0x10, 0x9e, 0x10, 0x90, 0x11, 0x50, 0x32, 0x3f, 0x00, 0x00 },
{ 0xf4, 0xe0, 0x28, 0x94, 0x28, 0x94, 0x29, 0xff, 0x28, 0x94, 0x3e, 0x9c, 0x20, 0x80, 0x20, 0xff, 0x20, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x38, 0x24, 0x54, 0x44, 0x92, 0x45, 0x11, 0x44, 0x10, 0x00, 0x00 },
{ 0xf4, 0xe1, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x3f, 0xfe, 0x29, 0x52, 0x3f, 0x7e, 0x29, 0x52, 0x7f, 0xff, 0x44, 0x11, 0x47, 0xf1, 0x04, 0x10, 0x07, 0xf0, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf4, 0xe2, 0x00, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x49, 0xfc, 0x78, 0x24, 0x4b, 0xff, 0x48, 0x24, 0x79, 0xfc, 0x48, 0x20, 0x48, 0x20, 0x49, 0x3e, 0x79, 0x20, 0x02, 0xa0, 0x04, 0x7f, 0x00, 0x00 },
{ 0xf4, 0xe3, 0x00, 0x94, 0x3c, 0x94, 0x01, 0xff, 0x7e, 0x94, 0x00, 0x9c, 0x3c, 0x80, 0x00, 0xff, 0x3c, 0x10, 0x00, 0x10, 0x01, 0xff, 0x3c, 0x38, 0x24, 0x54, 0x24, 0x92, 0x25, 0x11, 0x3c, 0x10, 0x00, 0x00 },
{ 0xf4, 0xe4, 0x00, 0x08, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x0f, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x08, 0x3e, 0x08, 0x22, 0x7f, 0x22, 0x41, 0x3e, 0x41, 0x00, 0x41, 0x24, 0x41, 0x22, 0x41, 0x42, 0x7f, 0x00, 0x00 },
{ 0xf4, 0xe5, 0x08, 0x00, 0x09, 0xff, 0x7e, 0xa0, 0x08, 0xa0, 0x3e, 0xfe, 0x2a, 0xaa, 0x3e, 0xaa, 0x2a, 0xea, 0x3e, 0xaa, 0x08, 0xaa, 0x08, 0xa4, 0x7e, 0xe4, 0x09, 0xaa, 0x08, 0x2a, 0x08, 0x31, 0x00, 0x00 },
{ 0xf4, 0xe6, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x10, 0x3f, 0xfe, 0x29, 0x10, 0x2f, 0xfe, 0x29, 0x2a, 0x3f, 0xfe, 0x21, 0x00, 0x3d, 0xfe, 0x29, 0x00, 0x3d, 0x28, 0x49, 0x62, 0x4d, 0xaa, 0x59, 0x38, 0x00, 0x00 },
{ 0xf4, 0xe7, 0x00, 0x20, 0x07, 0xff, 0x78, 0x20, 0x4b, 0xfe, 0x48, 0x20, 0x4f, 0xff, 0x78, 0x00, 0x49, 0xfc, 0x49, 0x24, 0x49, 0x24, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x1c, 0x00, 0x00 },
{ 0xf4, 0xe8, 0x40, 0x20, 0x27, 0xff, 0x10, 0x20, 0x03, 0xfe, 0x40, 0x20, 0x27, 0xff, 0x10, 0x00, 0x01, 0xfc, 0x01, 0x24, 0x09, 0x24, 0x09, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x21, 0x04, 0x41, 0x1c, 0x00, 0x00 },
{ 0xf4, 0xe9, 0x00, 0x10, 0x7e, 0x10, 0x25, 0xff, 0x3c, 0x20, 0x24, 0xfe, 0x3c, 0xaa, 0x24, 0xaa, 0x7c, 0xfe, 0x04, 0x00, 0x75, 0xff, 0x24, 0x10, 0x74, 0xaa, 0x24, 0xa1, 0x75, 0x24, 0x04, 0x1c, 0x00, 0x00 },
{ 0xf4, 0xea, 0x02, 0x20, 0x7f, 0xff, 0x02, 0xa0, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xf4, 0xeb, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x10, 0x7e, 0xfe, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x92, 0x00, 0x92, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x3c, 0x8e, 0x00, 0x00 },
{ 0xf4, 0xec, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x88, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00 },
{ 0xf4, 0xed, 0x10, 0x10, 0x1c, 0xff, 0x24, 0x10, 0x28, 0x7e, 0x7e, 0x10, 0x2a, 0xff, 0x2a, 0x00, 0x3e, 0x7e, 0x2a, 0x52, 0x2a, 0x52, 0x3e, 0x7e, 0x00, 0x42, 0x2a, 0x42, 0x2a, 0x42, 0x40, 0x4e, 0x00, 0x00 },
{ 0xf4, 0xee, 0x00, 0x00, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x22, 0x10, 0x22, 0x1f, 0x22, 0x70, 0x22, 0x10, 0x22, 0x11, 0x22, 0x11, 0x22, 0x11, 0x42, 0x0f, 0x42, 0x00, 0x82, 0x01, 0x04, 0x02, 0x38, 0x00, 0x00 },
{ 0xf4, 0xef, 0x21, 0x01, 0x11, 0x09, 0x0a, 0x09, 0x3f, 0xc9, 0x04, 0x49, 0x04, 0x49, 0x3f, 0xc9, 0x24, 0x09, 0x24, 0x09, 0x7f, 0xc9, 0x4c, 0x49, 0x14, 0x41, 0x25, 0xc1, 0x44, 0x01, 0x04, 0x07, 0x00, 0x00 },
{ 0xf4, 0xf0, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x14, 0x14, 0x22, 0x22, 0x40, 0x41, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf4, 0xf1, 0x21, 0x08, 0x10, 0x88, 0x08, 0x90, 0x03, 0xfe, 0x40, 0x22, 0x20, 0x22, 0x13, 0xfe, 0x02, 0x20, 0x02, 0x20, 0x17, 0xff, 0x14, 0x61, 0x20, 0xa1, 0x21, 0x21, 0x42, 0x26, 0x4c, 0x20, 0x00, 0x00 },
{ 0xf4, 0xf2, 0x21, 0x54, 0x11, 0x54, 0x07, 0xff, 0x01, 0x54, 0x41, 0x55, 0x26, 0x77, 0x10, 0x00, 0x07, 0xff, 0x04, 0x21, 0x14, 0x21, 0x13, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x42, 0x26, 0x40, 0x20, 0x00, 0x00 },
{ 0xf4, 0xf3, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x44, 0x82, 0x28, 0x44, 0x11, 0xff, 0x11, 0x11, 0x25, 0x11, 0x7c, 0xfe, 0x10, 0x92, 0x54, 0x92, 0x54, 0x92, 0x50, 0x96, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf4, 0xf4, 0x00, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x7e, 0x82, 0x00, 0x44, 0x3d, 0xff, 0x01, 0x11, 0x3d, 0x11, 0x00, 0xfe, 0x00, 0x92, 0x3c, 0x92, 0x24, 0x92, 0x24, 0x92, 0x24, 0x96, 0x3c, 0x10, 0x00, 0x00 },
{ 0xf4, 0xf5, 0x20, 0x10, 0x10, 0x10, 0x09, 0xfe, 0x00, 0x12, 0x43, 0xff, 0x20, 0x12, 0x11, 0xfe, 0x01, 0x11, 0x00, 0x92, 0x70, 0x1c, 0x10, 0xd2, 0x13, 0x11, 0x10, 0x30, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf4, 0xf6, 0x20, 0x0e, 0x13, 0xf0, 0x02, 0x1c, 0x42, 0x10, 0x22, 0xff, 0x02, 0x91, 0x02, 0x9c, 0x02, 0xf0, 0x72, 0x9e, 0x14, 0x80, 0x15, 0x28, 0x19, 0x29, 0x12, 0xcf, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf4, 0xf7, 0x00, 0x14, 0x3e, 0x7f, 0x22, 0x55, 0x2e, 0x7f, 0x2a, 0x55, 0x7f, 0x7f, 0x41, 0x00, 0x3e, 0x7f, 0x22, 0x00, 0x3e, 0x7f, 0x22, 0x41, 0x3e, 0x7f, 0x22, 0x22, 0x22, 0x14, 0x26, 0x7f, 0x00, 0x00 },
{ 0xf4, 0xf8, 0x10, 0x00, 0x10, 0x00, 0x10, 0xff, 0x7c, 0x11, 0x04, 0x11, 0x08, 0x11, 0x08, 0x11, 0x12, 0x21, 0x3c, 0x21, 0x54, 0x21, 0x12, 0x21, 0x10, 0x41, 0x10, 0x42, 0x10, 0x82, 0x11, 0x0c, 0x00, 0x00 },
{ 0xf4, 0xf9, 0x24, 0x81, 0x49, 0x01, 0x24, 0x89, 0x00, 0x09, 0x3f, 0x89, 0x24, 0x89, 0x3f, 0x89, 0x24, 0x89, 0x3f, 0x89, 0x04, 0x09, 0x7f, 0xc9, 0x0e, 0x01, 0x15, 0x01, 0x64, 0x81, 0x04, 0x07, 0x00, 0x00 },
{ 0xf4, 0xfa, 0x00, 0x10, 0x00, 0x94, 0x78, 0x92, 0x4b, 0x11, 0x49, 0xfe, 0x49, 0x02, 0x49, 0x02, 0x49, 0xfe, 0x49, 0x02, 0x49, 0x02, 0x49, 0xfe, 0x79, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x0e, 0x00, 0x00 },
{ 0xf4, 0xfb, 0x10, 0x88, 0x11, 0x10, 0x11, 0xfe, 0x5b, 0x10, 0x55, 0x10, 0x55, 0xfe, 0x51, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x11, 0xff, 0x10, 0x00, 0x12, 0x52, 0x12, 0x49, 0x14, 0x49, 0x00, 0x00 },
{ 0xf4, 0xfc, 0x10, 0x10, 0x10, 0x10, 0x10, 0x94, 0x7c, 0x92, 0x10, 0x92, 0x11, 0x11, 0x11, 0x11, 0x1c, 0x10, 0x70, 0x12, 0x10, 0x72, 0x10, 0x04, 0x10, 0x08, 0x10, 0x10, 0x10, 0x60, 0x31, 0x80, 0x00, 0x00 },
{ 0xf4, 0xfd, 0x10, 0x00, 0x11, 0xff, 0x10, 0x21, 0x7c, 0x21, 0x10, 0x41, 0x10, 0x41, 0x10, 0x86, 0x1d, 0x00, 0x70, 0x00, 0x10, 0xff, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x30, 0xff, 0x00, 0x00 },
{ 0xf4, 0xfe, 0x10, 0x10, 0x10, 0x94, 0x10, 0x92, 0x7d, 0x11, 0x10, 0xfe, 0x10, 0x82, 0x38, 0x82, 0x38, 0xfe, 0x34, 0x82, 0x54, 0x82, 0x50, 0xfe, 0x50, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xf5, 0xa1, 0x10, 0x80, 0x10, 0x9f, 0x10, 0x89, 0x7c, 0xe9, 0x10, 0x89, 0x10, 0x89, 0x3b, 0xe9, 0x34, 0x8a, 0x30, 0x8a, 0x52, 0xa6, 0x52, 0xa4, 0x54, 0xa4, 0x14, 0x8a, 0x10, 0x92, 0x11, 0xa1, 0x00, 0x00 },
{ 0xf5, 0xa2, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x18, 0x1c, 0x2c, 0x2a, 0x4a, 0x49, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x81, 0x08, 0x82, 0x08, 0xf8, 0x08, 0x80, 0x14, 0x80, 0x23, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xf5, 0xa3, 0x10, 0x44, 0x10, 0x44, 0x10, 0x88, 0x7d, 0xff, 0x12, 0x88, 0x10, 0xfe, 0x38, 0x88, 0x38, 0xfe, 0x34, 0x88, 0x54, 0x88, 0x50, 0xff, 0x50, 0x00, 0x11, 0x52, 0x11, 0x29, 0x12, 0x29, 0x00, 0x00 },
{ 0xf5, 0xa4, 0x10, 0x10, 0x10, 0x10, 0x12, 0x92, 0x54, 0x92, 0x58, 0x91, 0x51, 0x11, 0x51, 0x11, 0x10, 0x10, 0x10, 0x32, 0x10, 0x02, 0x28, 0x04, 0x24, 0x08, 0x20, 0x10, 0x40, 0x60, 0x41, 0x80, 0x00, 0x00 },
{ 0xf5, 0xa5, 0x04, 0x10, 0x08, 0x20, 0x1f, 0xff, 0x30, 0x40, 0x50, 0x40, 0x1f, 0xfe, 0x10, 0x40, 0x1f, 0xfe, 0x10, 0x40, 0x10, 0x40, 0x1f, 0xff, 0x00, 0x00, 0x12, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xf5, 0xa6, 0x00, 0x10, 0x7c, 0x54, 0x10, 0x92, 0x11, 0x11, 0x10, 0xfe, 0x20, 0x82, 0x3c, 0x82, 0x24, 0xfe, 0x64, 0x82, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x3c, 0x82, 0x00, 0x82, 0x00, 0x8e, 0x00, 0x00 },
{ 0xf5, 0xa7, 0x00, 0x44, 0x7c, 0x44, 0x10, 0x88, 0x11, 0xff, 0x12, 0x88, 0x20, 0xfe, 0x3c, 0x88, 0x24, 0xfe, 0x64, 0x88, 0x24, 0x88, 0x24, 0xff, 0x24, 0x00, 0x3d, 0x52, 0x01, 0x29, 0x02, 0x29, 0x00, 0x00 },
{ 0xf5, 0xa8, 0x00, 0x44, 0x7c, 0x44, 0x11, 0xff, 0x10, 0xee, 0x11, 0x55, 0x20, 0x44, 0x3c, 0x00, 0x25, 0xff, 0x64, 0x12, 0x24, 0x10, 0x24, 0x9e, 0x24, 0x90, 0x3c, 0x90, 0x01, 0x50, 0x02, 0x3f, 0x00, 0x00 },
{ 0xf5, 0xa9, 0x0c, 0x10, 0x70, 0x10, 0x10, 0x10, 0x10, 0x94, 0x7c, 0x92, 0x10, 0x91, 0x11, 0x11, 0x39, 0x10, 0x34, 0x11, 0x54, 0x72, 0x50, 0x02, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0xc0, 0x00, 0x00 },
{ 0xf5, 0xaa, 0x0c, 0x10, 0x70, 0x54, 0x10, 0x92, 0x11, 0x11, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x38, 0xfe, 0x34, 0x82, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xf5, 0xab, 0x00, 0x80, 0x04, 0x90, 0x08, 0x88, 0x30, 0x86, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x3c, 0x00, 0x00 },
{ 0xf5, 0xac, 0x08, 0x10, 0x08, 0x10, 0x4a, 0x92, 0x4a, 0x92, 0x4a, 0x92, 0x4a, 0x92, 0x4a, 0x92, 0x4a, 0x92, 0x4a, 0x92, 0x7e, 0xfe, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xf5, 0xad, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x1f, 0xfc, 0x02, 0x04, 0x02, 0x04, 0x04, 0x04, 0x18, 0x38, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf5, 0xae, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf5, 0xaf, 0x02, 0x10, 0x7f, 0xff, 0x02, 0x10, 0x08, 0x20, 0x08, 0x40, 0x1f, 0xff, 0x30, 0x40, 0x5f, 0xfe, 0x10, 0x40, 0x1f, 0xfe, 0x10, 0x40, 0x1f, 0xff, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xf5, 0xb0, 0x0c, 0x00, 0x70, 0xfe, 0x0a, 0x22, 0x24, 0x22, 0x18, 0x42, 0x68, 0x42, 0x08, 0x82, 0x15, 0x1c, 0x64, 0x00, 0x0c, 0xfe, 0x14, 0x82, 0x64, 0x82, 0x04, 0x82, 0x04, 0x82, 0x18, 0xfe, 0x00, 0x00 },
{ 0xf5, 0xb1, 0x08, 0x00, 0x08, 0xfe, 0x3e, 0x22, 0x08, 0x22, 0x08, 0x42, 0x7f, 0x42, 0x08, 0x8c, 0x08, 0x00, 0x28, 0x7e, 0x2f, 0x42, 0x28, 0x42, 0x28, 0x42, 0x38, 0x7e, 0x4e, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xf5, 0xb2, 0x00, 0x20, 0x7f, 0x20, 0x14, 0x20, 0x14, 0x7f, 0x7f, 0x48, 0x55, 0x88, 0x55, 0x08, 0x55, 0x0f, 0x67, 0x08, 0x41, 0x08, 0x41, 0x0f, 0x7f, 0x08, 0x41, 0x08, 0x41, 0x08, 0x7f, 0x08, 0x00, 0x00 },
{ 0xf5, 0xb3, 0x00, 0x14, 0x7f, 0x14, 0x14, 0x14, 0x14, 0x7f, 0x7f, 0x14, 0x55, 0x14, 0x55, 0x7f, 0x55, 0x00, 0x67, 0x3e, 0x41, 0x22, 0x41, 0x22, 0x7f, 0x3e, 0x41, 0x22, 0x41, 0x22, 0x7f, 0x3e, 0x00, 0x00 },
{ 0xf5, 0xb4, 0x00, 0x24, 0x7e, 0x24, 0x10, 0x48, 0x10, 0xff, 0x7f, 0x48, 0x52, 0x7f, 0x52, 0x48, 0x52, 0x7f, 0x6e, 0x48, 0x42, 0x48, 0x42, 0x7f, 0x7e, 0x00, 0x42, 0xaa, 0x7e, 0x95, 0x43, 0x15, 0x00, 0x00 },
{ 0xf5, 0xb5, 0x08, 0x00, 0x09, 0xfe, 0x09, 0x02, 0x11, 0x02, 0x11, 0x02, 0x31, 0x02, 0x31, 0xfe, 0x50, 0x20, 0x50, 0x20, 0x11, 0x3e, 0x11, 0x20, 0x11, 0x20, 0x12, 0xa0, 0x12, 0x60, 0x14, 0x1f, 0x00, 0x00 },
{ 0xf5, 0xb6, 0x07, 0xfe, 0x74, 0x02, 0x57, 0xfe, 0x54, 0x20, 0x55, 0xae, 0x54, 0x20, 0x55, 0xfe, 0x55, 0x4a, 0x55, 0xfe, 0x74, 0x80, 0x09, 0xff, 0x0a, 0xa9, 0x10, 0xf9, 0x10, 0x29, 0x21, 0xf6, 0x00, 0x00 },
{ 0xf5, 0xb7, 0x10, 0x00, 0x11, 0xff, 0x13, 0x29, 0x55, 0x29, 0x59, 0xff, 0x50, 0x80, 0x51, 0xff, 0x11, 0x21, 0x12, 0xfd, 0x10, 0xa5, 0x28, 0xfd, 0x24, 0x29, 0x20, 0x3d, 0x41, 0xc5, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf5, 0xb8, 0x00, 0x40, 0x3f, 0xfe, 0x00, 0x80, 0x13, 0xf8, 0x12, 0x08, 0x13, 0xf8, 0x12, 0x08, 0x1f, 0xfe, 0x04, 0x04, 0x7f, 0x7f, 0x08, 0x08, 0x5e, 0x5e, 0x52, 0x52, 0x52, 0x52, 0x7f, 0x7f, 0x00, 0x00 },
{ 0xf5, 0xb9, 0x00, 0x00, 0x3f, 0xfc, 0x22, 0x44, 0x22, 0x44, 0x3f, 0xfc, 0x10, 0x00, 0x1f, 0xfe, 0x22, 0x02, 0x5f, 0xc2, 0x12, 0x42, 0x1f, 0xc2, 0x02, 0x42, 0x02, 0xe4, 0x3f, 0x24, 0x00, 0x18, 0x00, 0x00 },
{ 0xf5, 0xba, 0x10, 0x00, 0x1c, 0xfe, 0x24, 0xaa, 0x28, 0xaa, 0x7e, 0xfe, 0x2a, 0x40, 0x2a, 0x40, 0x3e, 0xfe, 0x2b, 0x22, 0x2a, 0xfa, 0x3e, 0xaa, 0x22, 0xfa, 0x22, 0x32, 0x42, 0xea, 0x46, 0x0c, 0x00, 0x00 },
{ 0xf5, 0xbb, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x7f, 0xff, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x04, 0x10, 0x02, 0x10, 0x02, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xf5, 0xbc, 0x10, 0x08, 0x10, 0x08, 0x18, 0x08, 0x55, 0xff, 0x54, 0x08, 0x50, 0x08, 0x50, 0x08, 0x11, 0x08, 0x10, 0x88, 0x10, 0x88, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x38, 0x00, 0x00 },
{ 0xf5, 0xbd, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x7d, 0xff, 0x10, 0x04, 0x10, 0x04, 0x38, 0x04, 0x38, 0x84, 0x34, 0x44, 0x54, 0x24, 0x50, 0x04, 0x50, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xf5, 0xbe, 0x04, 0x00, 0x04, 0x1f, 0x07, 0x91, 0x7c, 0x12, 0x04, 0x12, 0x24, 0x94, 0x24, 0x92, 0x24, 0x92, 0x24, 0x91, 0x3f, 0x91, 0x04, 0x11, 0x04, 0x11, 0x04, 0x96, 0x03, 0x90, 0x00, 0x10, 0x00, 0x00 },
{ 0xf5, 0xbf, 0x0a, 0x48, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x11, 0x00, 0x1f, 0x7e, 0x11, 0x22, 0x1f, 0x24, 0x11, 0x18, 0x7f, 0x14, 0x01, 0x63, 0x00, 0x00 },
{ 0xf5, 0xc0, 0x10, 0x00, 0x13, 0xff, 0x12, 0x01, 0x12, 0xfd, 0x7c, 0x20, 0x10, 0xc2, 0x17, 0x24, 0x10, 0x78, 0x12, 0x90, 0x13, 0x18, 0x1d, 0x34, 0x70, 0xd3, 0x03, 0x10, 0x0c, 0x10, 0x00, 0x60, 0x00, 0x00 },
{ 0xf5, 0xc1, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x44, 0x21, 0x3f, 0xbe, 0x0a, 0x20, 0x3f, 0xbe, 0x00, 0x02, 0x1f, 0x3e, 0x11, 0x20, 0x1f, 0x3e, 0x11, 0x20, 0x1f, 0x3e, 0x11, 0x21, 0x13, 0x1f, 0x00, 0x00 },
{ 0xf5, 0xc2, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x11, 0xf4, 0x17, 0x14, 0x10, 0xa4, 0x10, 0xc4, 0x17, 0x24, 0x10, 0x04, 0x1f, 0xfc, 0x01, 0x00, 0x24, 0x94, 0x24, 0x92, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xf5, 0xc3, 0x10, 0x20, 0x11, 0xfe, 0x11, 0x22, 0x19, 0x3a, 0x55, 0x4a, 0x55, 0xb2, 0x51, 0x12, 0x51, 0x2a, 0x11, 0x42, 0x11, 0xfe, 0x10, 0x00, 0x10, 0xa2, 0x12, 0x95, 0x12, 0x85, 0x14, 0x7d, 0x00, 0x00 },
{ 0xf5, 0xc4, 0x10, 0x10, 0x11, 0xfe, 0x11, 0x22, 0x7d, 0x3a, 0x11, 0x4a, 0x11, 0xaa, 0x11, 0x12, 0x1d, 0x2a, 0x71, 0x42, 0x11, 0xfe, 0x10, 0x00, 0x10, 0xa2, 0x12, 0x95, 0x12, 0x85, 0x74, 0xf9, 0x00, 0x00 },
{ 0xf5, 0xc5, 0x10, 0x10, 0x10, 0x20, 0x24, 0xfe, 0x44, 0xa2, 0x28, 0xba, 0x10, 0xea, 0x10, 0x92, 0x24, 0xaa, 0x7c, 0xfe, 0x14, 0x00, 0x50, 0x50, 0x55, 0x4a, 0x55, 0x41, 0x11, 0x45, 0x12, 0x3c, 0x00, 0x00 },
{ 0xf5, 0xc6, 0x00, 0x10, 0x7e, 0x20, 0x24, 0xff, 0x24, 0x91, 0x3c, 0xbd, 0x24, 0xc5, 0x24, 0x99, 0x3c, 0xa5, 0x24, 0xff, 0x24, 0x10, 0x24, 0x08, 0x2c, 0xa2, 0x74, 0xa1, 0x05, 0x25, 0x04, 0x1c, 0x00, 0x00 },
{ 0xf5, 0xc7, 0x04, 0x10, 0x7f, 0xff, 0x05, 0x10, 0x02, 0x00, 0x1f, 0xfc, 0x11, 0xe4, 0x17, 0x24, 0x10, 0xc4, 0x17, 0x44, 0x10, 0x24, 0x1f, 0xfc, 0x01, 0x00, 0x24, 0x94, 0x24, 0x12, 0x43, 0xf2, 0x00, 0x00 },
{ 0xf5, 0xc8, 0x18, 0x10, 0x24, 0x10, 0x41, 0xff, 0x00, 0x24, 0x7c, 0x22, 0x10, 0x4f, 0x11, 0xf1, 0x7c, 0x00, 0x10, 0x48, 0x10, 0x48, 0x54, 0x48, 0x34, 0x88, 0x10, 0x89, 0x19, 0x09, 0x62, 0x07, 0x00, 0x00 },
{ 0xf5, 0xc9, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x7d, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x17, 0xff, 0x19, 0x20, 0x71, 0xff, 0x11, 0x21, 0x11, 0xe9, 0x11, 0x2a, 0x11, 0xe4, 0x13, 0x2a, 0x30, 0x31, 0x00, 0x00 },
{ 0xf5, 0xca, 0x08, 0x20, 0x0a, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x30, 0x48, 0x30, 0x90, 0x51, 0xff, 0x11, 0x10, 0x13, 0x10, 0x15, 0xfe, 0x11, 0x10, 0x11, 0xfe, 0x11, 0x10, 0x11, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xf5, 0xcb, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x02, 0x10, 0x04, 0x20, 0x0f, 0xfe, 0x18, 0x40, 0x68, 0x40, 0x0f, 0xfe, 0x08, 0x40, 0x0f, 0xfe, 0x08, 0x40, 0x08, 0x40, 0x0f, 0xff, 0x00, 0x00 },
{ 0xf5, 0xcc, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x11, 0x00, 0x1f, 0x7e, 0x11, 0x22, 0x1f, 0x22, 0x11, 0x14, 0x17, 0x08, 0x79, 0x14, 0x01, 0x63, 0x00, 0x00 },
{ 0xf5, 0xcd, 0x00, 0x58, 0x3c, 0x84, 0x27, 0xfb, 0x28, 0x60, 0x29, 0xb2, 0x24, 0x54, 0x25, 0x98, 0x24, 0x6c, 0x39, 0x8b, 0x20, 0xb0, 0x20, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf5, 0xce, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1d, 0xff, 0x71, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x31, 0xff, 0x00, 0x00 },
{ 0xf5, 0xcf, 0x10, 0x44, 0x10, 0x44, 0x10, 0x88, 0x7c, 0xff, 0x11, 0x88, 0x12, 0x88, 0x10, 0x88, 0x1c, 0xfe, 0x70, 0x88, 0x10, 0x88, 0x10, 0xfe, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x30, 0xff, 0x00, 0x00 },
{ 0xf5, 0xd0, 0x10, 0x44, 0x10, 0x44, 0x10, 0x88, 0x7c, 0xff, 0x11, 0x88, 0x12, 0x88, 0x38, 0x88, 0x38, 0xfe, 0x34, 0x88, 0x54, 0x88, 0x50, 0xfe, 0x50, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0xff, 0x00, 0x00 },
{ 0xf5, 0xd1, 0x10, 0xc8, 0x17, 0x08, 0x11, 0x08, 0x79, 0x09, 0x17, 0xe9, 0x11, 0x2a, 0x31, 0x2a, 0x3b, 0x08, 0x33, 0x88, 0x55, 0x54, 0x55, 0x14, 0x11, 0x14, 0x11, 0x22, 0x11, 0x22, 0x11, 0x41, 0x00, 0x00 },
{ 0xf5, 0xd2, 0x10, 0x00, 0x13, 0xff, 0x12, 0x00, 0x7e, 0x00, 0x12, 0x7c, 0x12, 0x44, 0x32, 0x7c, 0x3a, 0x00, 0x36, 0xee, 0x52, 0xaa, 0x52, 0xaa, 0x52, 0xee, 0x12, 0x00, 0x12, 0x00, 0x13, 0xff, 0x00, 0x00 },
{ 0xf5, 0xd3, 0x20, 0xc8, 0x17, 0x08, 0x09, 0x08, 0x01, 0x09, 0x47, 0xe9, 0x21, 0x2a, 0x11, 0x4a, 0x03, 0x08, 0x03, 0x88, 0x13, 0x48, 0x15, 0x14, 0x25, 0x14, 0x21, 0x22, 0x41, 0x22, 0x41, 0x41, 0x00, 0x00 },
{ 0xf5, 0xd4, 0x20, 0x08, 0x20, 0x08, 0x7f, 0x08, 0x11, 0x7f, 0x55, 0x49, 0x7d, 0x4a, 0x11, 0x48, 0x26, 0x7f, 0x50, 0x51, 0x3f, 0x52, 0x51, 0x4a, 0x55, 0x4c, 0x7d, 0x4c, 0x21, 0x52, 0x46, 0xa1, 0x00, 0x00 },
{ 0xf5, 0xd5, 0x0c, 0x10, 0x70, 0x10, 0x10, 0x10, 0x10, 0x91, 0x7c, 0x91, 0x10, 0x92, 0x11, 0x12, 0x39, 0x28, 0x34, 0x28, 0x54, 0x28, 0x50, 0x44, 0x50, 0x44, 0x10, 0x84, 0x11, 0x02, 0x12, 0x01, 0x00, 0x00 },
{ 0xf5, 0xd6, 0x08, 0x00, 0x1f, 0xfe, 0x60, 0x82, 0x04, 0x92, 0x07, 0xf2, 0x01, 0x02, 0x06, 0x0c, 0x3a, 0x00, 0x07, 0xfe, 0x18, 0x82, 0x64, 0x92, 0x04, 0x92, 0x07, 0xf2, 0x01, 0x02, 0x1e, 0x0c, 0x00, 0x00 },
{ 0xf5, 0xd7, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x06, 0x10, 0x38, 0x10, 0x08, 0x51, 0x7f, 0x52, 0x08, 0x94, 0x1c, 0x10, 0x1a, 0x28, 0x2a, 0x28, 0x48, 0x44, 0x08, 0x82, 0x09, 0x01, 0x00, 0x00 },
{ 0xf5, 0xd8, 0x00, 0x00, 0x3b, 0xff, 0x01, 0x20, 0x7d, 0x20, 0x01, 0xff, 0x3d, 0x29, 0x01, 0x29, 0x3d, 0xe9, 0x01, 0x2a, 0x01, 0x2a, 0x3d, 0xe4, 0x27, 0x24, 0x24, 0x2a, 0x24, 0x31, 0x3c, 0x20, 0x00, 0x00 },
{ 0xf5, 0xd9, 0x08, 0x80, 0x08, 0xfe, 0x3f, 0x22, 0x08, 0xaa, 0x08, 0xfa, 0x08, 0x22, 0x7f, 0x4c, 0x08, 0x80, 0x08, 0xfe, 0x29, 0x22, 0x2e, 0xaa, 0x28, 0xfa, 0x28, 0x22, 0x58, 0x4c, 0x47, 0xff, 0x00, 0x00 },
{ 0xf5, 0xda, 0x00, 0x20, 0x20, 0x40, 0x11, 0xfc, 0x09, 0x04, 0x01, 0x04, 0x41, 0xfc, 0x21, 0x00, 0x11, 0x00, 0x01, 0xfe, 0x71, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf5, 0xdb, 0x10, 0x00, 0x3f, 0x9f, 0x48, 0x91, 0x2a, 0x92, 0x3e, 0x92, 0x08, 0x94, 0x13, 0x12, 0x10, 0x12, 0x3f, 0x91, 0x48, 0x91, 0x2a, 0x91, 0x3e, 0x91, 0x08, 0x96, 0x10, 0x90, 0x63, 0x10, 0x00, 0x00 },
{ 0xf5, 0xdc, 0x0b, 0xfc, 0x10, 0x04, 0x2f, 0xfa, 0x42, 0x41, 0x02, 0x40, 0x3f, 0xfe, 0x22, 0x42, 0x22, 0x42, 0x24, 0x3e, 0x28, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf5, 0xdd, 0x00, 0x10, 0x7e, 0x20, 0x10, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x7e, 0x92, 0x52, 0x92, 0x52, 0xfe, 0x6e, 0x50, 0x42, 0x52, 0x42, 0x55, 0x7e, 0x57, 0x42, 0x50, 0x42, 0x91, 0x7e, 0x8f, 0x00, 0x00 },
{ 0xf5, 0xde, 0x18, 0x44, 0x24, 0x44, 0x40, 0x88, 0x00, 0xff, 0x7d, 0x88, 0x10, 0x88, 0x10, 0xfe, 0x7c, 0x88, 0x10, 0x88, 0x10, 0x88, 0x54, 0xfe, 0x34, 0x88, 0x10, 0x88, 0x18, 0x88, 0x60, 0xff, 0x00, 0x00 },
{ 0xf5, 0xdf, 0x18, 0x0f, 0x25, 0xf0, 0x40, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x10, 0x92, 0x10, 0x92, 0x7d, 0xff, 0x10, 0x92, 0x10, 0x92, 0x55, 0xff, 0x34, 0x10, 0x10, 0x10, 0x18, 0x10, 0x61, 0xff, 0x00, 0x00 },
{ 0xf5, 0xe0, 0x18, 0x08, 0x25, 0x3e, 0x40, 0xaa, 0x00, 0x2a, 0x7c, 0x7f, 0x11, 0x00, 0x10, 0xbe, 0x7c, 0x22, 0x10, 0x3e, 0x13, 0x20, 0x55, 0x3e, 0x39, 0x22, 0x11, 0x3e, 0x1a, 0xc0, 0x64, 0x3f, 0x00, 0x00 },
{ 0xf5, 0xe1, 0x10, 0x12, 0x3f, 0xa4, 0x48, 0xff, 0x2a, 0xa4, 0x2a, 0xa4, 0x3e, 0xa4, 0x08, 0xbf, 0x13, 0x24, 0x3f, 0xa4, 0x48, 0xa4, 0x2a, 0xbf, 0x2a, 0xa4, 0x3e, 0xa4, 0x08, 0xa4, 0x33, 0x3f, 0x00, 0x00 },
{ 0xf5, 0xe2, 0x00, 0x40, 0x3e, 0xfe, 0x29, 0x22, 0x3e, 0xaa, 0x28, 0xaa, 0x3e, 0xfa, 0x28, 0x22, 0x28, 0x4c, 0x3e, 0xfe, 0x03, 0x22, 0x56, 0xaa, 0x56, 0xaa, 0x52, 0xfa, 0x02, 0x22, 0x1c, 0xcc, 0x00, 0x00 },
{ 0xf5, 0xe3, 0x10, 0x34, 0x1d, 0xc4, 0x24, 0x44, 0x28, 0x44, 0x7f, 0xf5, 0x2a, 0x56, 0x2a, 0x44, 0x3e, 0xe4, 0x2a, 0xe4, 0x2b, 0x54, 0x3f, 0x4a, 0x00, 0x4a, 0x2a, 0x4a, 0x2a, 0x51, 0x40, 0x51, 0x00, 0x00 },
{ 0xf5, 0xe4, 0x00, 0x00, 0x1f, 0xf8, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x7f, 0xff, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf5, 0xe5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x0a, 0x24, 0x04, 0x42, 0x02, 0x8f, 0x7f, 0xf1, 0x00, 0x01, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf5, 0xe6, 0x00, 0x00, 0x38, 0xfe, 0x00, 0x82, 0x00, 0x82, 0x7c, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x54, 0x48, 0x54, 0x48, 0x54, 0x48, 0x54, 0x48, 0x54, 0x88, 0x54, 0x89, 0x11, 0x09, 0x12, 0x07, 0x00, 0x00 },
{ 0xf5, 0xe7, 0x08, 0x10, 0x08, 0x10, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf5, 0xe8, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x00, 0xf8, 0x7c, 0x88, 0x10, 0x88, 0x10, 0xc8, 0x10, 0xa8, 0x10, 0xa8, 0x1c, 0x88, 0x71, 0x09, 0x01, 0x09, 0x02, 0x0f, 0x00, 0x00 },
{ 0xf5, 0xe9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x3e, 0x7c, 0x08, 0x44, 0x0e, 0x65, 0x78, 0x97, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x00 },
{ 0xf5, 0xea, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x45, 0x01, 0x28, 0x40, 0x10, 0x5f, 0x10, 0x84, 0x24, 0x88, 0x7d, 0x9f, 0x12, 0x91, 0x54, 0x91, 0x54, 0x9f, 0x50, 0x91, 0x10, 0x91, 0x10, 0x9f, 0x00, 0x00 },
{ 0xf5, 0xeb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x00, 0x06, 0x24, 0x01, 0x42, 0x7f, 0xfd, 0x00, 0x01, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf5, 0xec, 0x00, 0x28, 0x3f, 0xff, 0x22, 0x20, 0x23, 0xd2, 0x22, 0x14, 0x3f, 0xc9, 0x4a, 0x95, 0x52, 0x43, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x10, 0x80, 0x10, 0xfc, 0x28, 0x80, 0x47, 0xff, 0x00, 0x00 },
{ 0xf5, 0xed, 0x00, 0x84, 0x78, 0x85, 0x4b, 0xe5, 0x48, 0x04, 0x48, 0x1f, 0x7b, 0xe4, 0x12, 0x24, 0x12, 0x24, 0x53, 0xec, 0x58, 0x8c, 0x52, 0xac, 0x52, 0xb4, 0x52, 0x95, 0x5c, 0x95, 0x71, 0xa7, 0x00, 0x00 },
{ 0xf5, 0xee, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x3e, 0x49, 0x2a, 0x49, 0x3e, 0x49, 0x2a, 0x49, 0x3e, 0x7f, 0x08, 0x49, 0x7f, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x00, 0x00 },
{ 0xf5, 0xef, 0x20, 0x00, 0x13, 0xff, 0x08, 0x20, 0x40, 0xe1, 0x23, 0x12, 0x10, 0x2c, 0x00, 0xc8, 0x03, 0x1c, 0x70, 0x2a, 0x10, 0xca, 0x13, 0x09, 0x10, 0x08, 0x10, 0x30, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf5, 0xf0, 0x01, 0x00, 0x3f, 0xfe, 0x02, 0x00, 0x1f, 0xfc, 0x04, 0x10, 0x7f, 0xff, 0x08, 0x08, 0x10, 0x04, 0x2f, 0xfa, 0x48, 0x09, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xf5, 0xf1, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x7c, 0x20, 0x10, 0xfc, 0x10, 0x48, 0x3b, 0xff, 0x38, 0x84, 0x35, 0x02, 0x56, 0xfd, 0x50, 0x84, 0x50, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0xfc, 0x00, 0x00 },
{ 0xf5, 0xf2, 0x00, 0x20, 0x7c, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x10, 0xfc, 0x7c, 0x48, 0x13, 0xff, 0x10, 0x84, 0x11, 0x02, 0x12, 0xfd, 0x1c, 0x84, 0x70, 0xfc, 0x00, 0x84, 0x00, 0x84, 0x00, 0xfc, 0x00, 0x00 },
{ 0xf5, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf5, 0xf4, 0x00, 0x90, 0x00, 0x88, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x04, 0x90, 0x04, 0x90, 0x04, 0x90, 0x04, 0x90, 0x08, 0x90, 0x08, 0x91, 0x10, 0x91, 0x20, 0x8f, 0x00, 0x80, 0x00, 0x00 },
{ 0xf5, 0xf5, 0x00, 0x08, 0x7f, 0x49, 0x49, 0x49, 0x6b, 0x49, 0x5d, 0x49, 0x49, 0x49, 0x7f, 0x7f, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x49, 0x0f, 0x49, 0x78, 0x49, 0x01, 0x49, 0x55, 0x49, 0x54, 0x7f, 0x00, 0x00 },
{ 0xf5, 0xf6, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x08, 0x02, 0x04, 0x04, 0x3a, 0x3f, 0xe2, 0x02, 0x20, 0x02, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xf5, 0xf7, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xf5, 0xf8, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xff, 0x42, 0x21, 0x22, 0x21, 0x12, 0x21, 0x02, 0x21, 0x02, 0x21, 0x13, 0xff, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf5, 0xf9, 0x00, 0x80, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x90, 0x00, 0xb8, 0x1f, 0xc4, 0x08, 0x10, 0x08, 0x10, 0x3f, 0x7e, 0x29, 0x52, 0x3f, 0x7e, 0x08, 0x10, 0x0b, 0x16, 0x7c, 0xf9, 0x00, 0x00 },
{ 0xf5, 0xfa, 0x08, 0x60, 0x0b, 0x8f, 0x10, 0x80, 0x23, 0xe0, 0x48, 0x80, 0x0b, 0xef, 0x12, 0xa2, 0x13, 0xe2, 0x32, 0xa2, 0x53, 0xe2, 0x10, 0x82, 0x13, 0xe2, 0x10, 0x82, 0x10, 0xe2, 0x13, 0x8e, 0x00, 0x00 },
{ 0xf5, 0xfb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x20, 0x04, 0x22, 0x1c, 0x14, 0x64, 0x08, 0x05, 0xc4, 0x1e, 0x03, 0x00, 0x00 },
{ 0xf5, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x1b, 0xff, 0x54, 0x00, 0x54, 0x84, 0x50, 0x84, 0x51, 0x8c, 0x12, 0x52, 0x14, 0x01, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf5, 0xfd, 0x00, 0x44, 0x3c, 0x44, 0x25, 0xff, 0x24, 0x44, 0x24, 0x10, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0x92, 0x25, 0x55, 0x3d, 0x55, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x44, 0x10, 0x4c, 0x10, 0x00, 0x00 },
{ 0xf5, 0xfe, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x08, 0x08, 0x08, 0x14, 0x14, 0x22, 0xa2, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf6, 0xa1, 0x08, 0x10, 0x7f, 0x10, 0x08, 0x3f, 0x7f, 0xa2, 0x10, 0x54, 0x1f, 0x0c, 0x21, 0x13, 0x4f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xf6, 0xa2, 0x00, 0x00, 0x7f, 0x00, 0x22, 0xfe, 0x22, 0x42, 0x3e, 0x42, 0x22, 0x42, 0x22, 0x44, 0x3e, 0x24, 0x22, 0x24, 0x22, 0x28, 0x26, 0x18, 0x3a, 0x18, 0x62, 0x24, 0x02, 0x42, 0x02, 0x81, 0x00, 0x00 },
{ 0xf6, 0xa3, 0x00, 0x40, 0x00, 0x40, 0x78, 0xff, 0x48, 0x91, 0x49, 0x11, 0x49, 0x12, 0x4a, 0x10, 0x48, 0x10, 0x48, 0x28, 0x48, 0x28, 0x78, 0x48, 0x00, 0x44, 0x00, 0x84, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00 },
{ 0xf6, 0xa4, 0x00, 0x89, 0x7a, 0xee, 0x4a, 0x88, 0x4a, 0xe9, 0x4b, 0x87, 0x48, 0x78, 0x48, 0x88, 0x49, 0xfe, 0x4a, 0x92, 0x78, 0xfe, 0x00, 0x92, 0x00, 0xfe, 0x01, 0x02, 0x01, 0x02, 0x02, 0x06, 0x00, 0x00 },
{ 0xf6, 0xa5, 0x7f, 0x00, 0x22, 0xfe, 0x3e, 0x42, 0x22, 0x44, 0x3e, 0x28, 0x22, 0x10, 0x2e, 0x2c, 0x72, 0xc3, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x00, 0xe0, 0x03, 0x98, 0x3c, 0x06, 0x00, 0x00 },
{ 0xf6, 0xa6, 0x08, 0x10, 0x08, 0x14, 0x7f, 0x12, 0x00, 0x10, 0x00, 0xfe, 0x3e, 0x10, 0x22, 0x10, 0x22, 0x28, 0x3e, 0x28, 0x08, 0x28, 0x2a, 0x28, 0x29, 0x28, 0x48, 0x49, 0x08, 0x49, 0x18, 0x8f, 0x00, 0x00 },
{ 0xf6, 0xa7, 0x10, 0x40, 0x10, 0x40, 0x12, 0x7f, 0x54, 0x91, 0x58, 0x92, 0x51, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x28, 0x10, 0x28, 0x28, 0x48, 0x24, 0x44, 0x20, 0x84, 0x41, 0x02, 0x42, 0x01, 0x00, 0x00 },
{ 0xf6, 0xa8, 0x00, 0x00, 0x7f, 0x7f, 0x09, 0x09, 0x71, 0x71, 0x07, 0x07, 0x39, 0x39, 0x01, 0x01, 0x00, 0x80, 0x3f, 0xfe, 0x08, 0x08, 0x14, 0x94, 0x22, 0xa2, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf6, 0xa9, 0x00, 0x00, 0x7f, 0x7e, 0x22, 0x22, 0x3e, 0x24, 0x22, 0x18, 0x2e, 0x34, 0x72, 0xc3, 0x02, 0x08, 0x08, 0x70, 0x13, 0xa2, 0x60, 0xa4, 0x00, 0x98, 0x04, 0x90, 0x08, 0x8c, 0x30, 0x83, 0x00, 0x00 },
{ 0xf6, 0xaa, 0x00, 0x20, 0x3c, 0x3c, 0x24, 0x44, 0x24, 0x88, 0x25, 0xff, 0x3c, 0x80, 0x24, 0x80, 0x24, 0xbe, 0x24, 0xa2, 0x3c, 0xa2, 0x24, 0xa2, 0x24, 0xae, 0x25, 0x21, 0x45, 0x21, 0x4d, 0x1f, 0x00, 0x00 },
{ 0xf6, 0xab, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x90, 0x00, 0x88, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xf6, 0xac, 0x10, 0x00, 0x13, 0xfe, 0x7d, 0x20, 0x11, 0x20, 0x11, 0xfe, 0x7d, 0x2a, 0x11, 0x2a, 0x11, 0xea, 0x51, 0x24, 0x5d, 0x24, 0x51, 0xea, 0x53, 0x31, 0x50, 0x20, 0x70, 0x00, 0x4f, 0xff, 0x00, 0x00 },
{ 0xf6, 0xad, 0x00, 0x08, 0x7f, 0x08, 0x14, 0x7f, 0x14, 0x22, 0x7f, 0x22, 0x55, 0x55, 0x55, 0x55, 0x55, 0x49, 0x67, 0x00, 0x41, 0x08, 0x41, 0x7f, 0x7f, 0x08, 0x41, 0x08, 0x41, 0x08, 0x7f, 0x08, 0x00, 0x00 },
{ 0xf6, 0xae, 0x00, 0x00, 0x3f, 0xfe, 0x28, 0xaa, 0x3e, 0xaa, 0x28, 0xe4, 0x3e, 0xa4, 0x28, 0xea, 0x29, 0xb1, 0x3e, 0x04, 0x02, 0x58, 0x52, 0x92, 0x53, 0x1c, 0x44, 0x54, 0x04, 0x92, 0x19, 0x11, 0x00, 0x00 },
{ 0xf6, 0xaf, 0x04, 0x08, 0x3f, 0x8a, 0x11, 0x7f, 0x1f, 0x14, 0x25, 0x15, 0x25, 0xa7, 0x02, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xff, 0x24, 0x91, 0x22, 0x49, 0x42, 0x4e, 0x00, 0x00 },
{ 0xf6, 0xb0, 0x08, 0x01, 0x0b, 0xc9, 0x12, 0x49, 0x12, 0x49, 0x33, 0xc9, 0x32, 0x49, 0x52, 0x49, 0x13, 0xc9, 0x12, 0x49, 0x12, 0x49, 0x12, 0x49, 0x13, 0xc1, 0x10, 0x01, 0x12, 0x41, 0x14, 0x27, 0x00, 0x00 },
{ 0xf6, 0xb1, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x50, 0x10, 0x50, 0x10, 0x50, 0x20, 0x88, 0x20, 0x88, 0x21, 0x04, 0x42, 0x02, 0x44, 0x01, 0x00, 0x00 },
{ 0xf6, 0xb2, 0x3f, 0xff, 0x20, 0x00, 0x20, 0x00, 0x27, 0x82, 0x24, 0x92, 0x24, 0x92, 0x27, 0x92, 0x24, 0x92, 0x27, 0x92, 0x24, 0x92, 0x24, 0x92, 0x27, 0x92, 0x40, 0x02, 0x44, 0x82, 0x48, 0x46, 0x00, 0x00 },
{ 0xf6, 0xb3, 0x10, 0x02, 0x13, 0xc2, 0x1a, 0x52, 0x56, 0x52, 0x53, 0xd2, 0x52, 0x52, 0x52, 0x52, 0x13, 0xd2, 0x12, 0x52, 0x12, 0x52, 0x12, 0x52, 0x13, 0xd2, 0x10, 0x02, 0x12, 0x42, 0x14, 0x26, 0x00, 0x00 },
{ 0xf6, 0xb4, 0x20, 0x01, 0x13, 0xc9, 0x0a, 0x49, 0x02, 0x49, 0x43, 0xc9, 0x22, 0x49, 0x12, 0x49, 0x03, 0xc9, 0x02, 0x49, 0x12, 0x49, 0x12, 0x49, 0x23, 0xc1, 0x20, 0x01, 0x42, 0x41, 0x44, 0x27, 0x00, 0x00 },
{ 0xf6, 0xb5, 0x1f, 0xff, 0x10, 0x01, 0x1f, 0xff, 0x10, 0x00, 0x12, 0xf8, 0x14, 0x04, 0x1f, 0xfe, 0x15, 0x55, 0x17, 0xfc, 0x10, 0x00, 0x17, 0xfc, 0x14, 0x04, 0x27, 0xfc, 0x24, 0x04, 0x47, 0xfc, 0x00, 0x00 },
{ 0xf6, 0xb6, 0x08, 0x40, 0x08, 0xfc, 0x09, 0x84, 0x12, 0x48, 0x10, 0x30, 0x30, 0x60, 0x33, 0x88, 0x50, 0x10, 0x50, 0x3f, 0x10, 0x41, 0x11, 0xa2, 0x10, 0x14, 0x10, 0x08, 0x10, 0x30, 0x11, 0xc0, 0x00, 0x00 },
{ 0xf6, 0xb7, 0x08, 0x08, 0x08, 0x08, 0x11, 0xff, 0x10, 0x10, 0x30, 0x10, 0x30, 0x7e, 0x52, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x7e, 0x12, 0x42, 0x12, 0x42, 0x12, 0x7e, 0x12, 0x00, 0x13, 0xff, 0x00, 0x00 },
{ 0xf6, 0xb8, 0x00, 0x20, 0x01, 0x22, 0x79, 0x22, 0x49, 0xfe, 0x48, 0x40, 0x4b, 0xff, 0x48, 0x20, 0x49, 0xfe, 0x49, 0x22, 0x49, 0x22, 0x79, 0xfe, 0x00, 0x20, 0x00, 0x24, 0x00, 0x3a, 0x03, 0xc1, 0x00, 0x00 },
{ 0xf6, 0xb9, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x54, 0x20, 0x54, 0x20, 0x54, 0x20, 0x55, 0xff, 0x54, 0x08, 0x54, 0x08, 0x55, 0xff, 0x54, 0x08, 0x7c, 0x88, 0x00, 0x48, 0x00, 0x08, 0x00, 0x38, 0x00, 0x00 },
{ 0xf6, 0xba, 0x10, 0x88, 0x10, 0x88, 0x13, 0xfa, 0x7d, 0x29, 0x55, 0x28, 0x55, 0x48, 0x57, 0xff, 0x54, 0x08, 0x55, 0xea, 0x55, 0x2a, 0x55, 0x24, 0x5d, 0xe5, 0x11, 0x2d, 0x11, 0x33, 0x11, 0xe1, 0x00, 0x00 },
{ 0xf6, 0xbb, 0x00, 0x20, 0x7e, 0x10, 0x24, 0x08, 0x24, 0x00, 0x3c, 0x20, 0x24, 0x20, 0x24, 0xa2, 0x3c, 0xa2, 0x24, 0xa1, 0x25, 0x21, 0x2d, 0x20, 0x74, 0x20, 0x04, 0x22, 0x04, 0x22, 0x04, 0x1e, 0x00, 0x00 },
{ 0xf6, 0xbc, 0x10, 0x0e, 0x11, 0xf0, 0x11, 0x00, 0x7d, 0x00, 0x11, 0xff, 0x11, 0x00, 0x39, 0x7e, 0x39, 0x52, 0x35, 0x52, 0x55, 0x52, 0x51, 0x7e, 0x51, 0x40, 0x12, 0x41, 0x12, 0x41, 0x14, 0x3f, 0x00, 0x00 },
{ 0xf6, 0xbd, 0x20, 0x40, 0x10, 0x40, 0x08, 0x40, 0x00, 0x84, 0x40, 0x82, 0x21, 0x1e, 0x17, 0xe1, 0x00, 0x01, 0x00, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xbe, 0x21, 0x24, 0x11, 0x24, 0x0a, 0x48, 0x40, 0x00, 0x22, 0x48, 0x11, 0x24, 0x01, 0x24, 0x00, 0x00, 0x13, 0xfe, 0x12, 0x22, 0x22, 0x22, 0x23, 0xfe, 0x42, 0x22, 0x42, 0x22, 0x03, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xbf, 0x10, 0x88, 0x10, 0x88, 0x13, 0xea, 0x55, 0x49, 0x59, 0x48, 0x53, 0xff, 0x50, 0x08, 0x13, 0xc9, 0x12, 0x49, 0x12, 0x4a, 0x2b, 0xc6, 0x26, 0x44, 0x22, 0x4d, 0x43, 0xd3, 0x40, 0x21, 0x00, 0x00 },
{ 0xf6, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x20, 0x33, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x30, 0x04, 0x50, 0x04, 0x17, 0xff, 0x11, 0x04, 0x20, 0x84, 0x20, 0x04, 0x40, 0x1c, 0x00, 0x00 },
{ 0xf6, 0xc1, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x52, 0x00, 0x32, 0x1e, 0x17, 0xd2, 0x15, 0x12, 0x31, 0x12, 0x57, 0xd2, 0x11, 0x12, 0x12, 0x92, 0x22, 0x52, 0x24, 0x52, 0x48, 0x1e, 0x00, 0x00 },
{ 0xf6, 0xc2, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x14, 0x80, 0x57, 0x3e, 0x34, 0x82, 0x17, 0x94, 0x12, 0x08, 0x33, 0xbf, 0x55, 0x0a, 0x11, 0x28, 0x17, 0xee, 0x21, 0x38, 0x22, 0xa8, 0x4c, 0x47, 0x00, 0x00 },
{ 0xf6, 0xc3, 0x0c, 0x44, 0x70, 0x44, 0x10, 0x88, 0x10, 0xff, 0x7d, 0x88, 0x12, 0x88, 0x18, 0x88, 0x38, 0xfe, 0x34, 0x88, 0x54, 0x88, 0x50, 0xfe, 0x50, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0xff, 0x00, 0x00 },
{ 0xf6, 0xc4, 0x0c, 0x00, 0x71, 0xff, 0x11, 0x01, 0x11, 0xff, 0x7d, 0x00, 0x11, 0x6b, 0x11, 0x08, 0x39, 0x6b, 0x35, 0x00, 0x51, 0x28, 0x51, 0x3f, 0x12, 0x48, 0x12, 0x7f, 0x14, 0x08, 0x10, 0x08, 0x00, 0x00 },
{ 0xf6, 0xc5, 0x10, 0x92, 0x10, 0x92, 0x25, 0x24, 0x45, 0x24, 0x28, 0x92, 0x10, 0x92, 0x10, 0x00, 0x24, 0x00, 0x7d, 0xfe, 0x15, 0x22, 0x51, 0x22, 0x55, 0xfe, 0x55, 0x22, 0x11, 0x22, 0x11, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xc6, 0x10, 0x08, 0x13, 0xe8, 0x24, 0x88, 0x44, 0x88, 0x29, 0x2f, 0x11, 0x6a, 0x13, 0xaa, 0x24, 0x1a, 0x7c, 0x8a, 0x17, 0xe4, 0x50, 0x84, 0x54, 0x8a, 0x54, 0xea, 0x13, 0x91, 0x10, 0x11, 0x00, 0x00 },
{ 0xf6, 0xc7, 0x7f, 0xfe, 0x44, 0x42, 0x7f, 0xfe, 0x01, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x0f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x48, 0x08, 0x4f, 0xf8, 0x40, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf6, 0xc8, 0x00, 0x10, 0x7f, 0x10, 0x08, 0x20, 0x10, 0x3f, 0x12, 0x22, 0x27, 0x42, 0x79, 0x62, 0x00, 0xa2, 0x08, 0x24, 0x7f, 0x14, 0x08, 0x18, 0x08, 0x08, 0x0f, 0x14, 0x78, 0x22, 0x00, 0xc1, 0x00, 0x00 },
{ 0xf6, 0xc9, 0x00, 0x80, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0xfe, 0x7f, 0x03, 0x00, 0x00 },
{ 0xf6, 0xca, 0x08, 0x49, 0x08, 0x49, 0x7e, 0x92, 0x08, 0x92, 0x3e, 0x49, 0x2a, 0x49, 0x3e, 0x00, 0x2a, 0x7f, 0x3e, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x7f, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x00, 0x00 },
{ 0xf6, 0xcb, 0x10, 0x24, 0x10, 0x24, 0x10, 0x48, 0x3e, 0x7f, 0x28, 0xc8, 0x49, 0x48, 0x08, 0x48, 0x7f, 0x7e, 0x08, 0x48, 0x08, 0x48, 0x14, 0x7e, 0x12, 0x48, 0x22, 0x48, 0x20, 0x48, 0x40, 0x7f, 0x00, 0x00 },
{ 0xf6, 0xcc, 0x00, 0x10, 0x3e, 0x10, 0x28, 0x50, 0x3e, 0x56, 0x28, 0x5a, 0x3e, 0x72, 0x28, 0xd2, 0x28, 0x52, 0x3e, 0x52, 0x02, 0x56, 0x52, 0x50, 0x52, 0x50, 0x42, 0x41, 0x02, 0x41, 0x0c, 0x3f, 0x00, 0x00 },
{ 0xf6, 0xcd, 0x00, 0x80, 0x08, 0x80, 0x08, 0xfc, 0x08, 0x80, 0x7f, 0xfe, 0x04, 0x20, 0x24, 0x24, 0x2a, 0x54, 0x20, 0x04, 0x3f, 0xfc, 0x24, 0x24, 0x24, 0x24, 0x2a, 0x54, 0x20, 0x04, 0x3f, 0xfc, 0x00, 0x00 },
{ 0xf6, 0xce, 0x00, 0x01, 0x3f, 0x11, 0x21, 0x11, 0x21, 0x11, 0x3f, 0x11, 0x21, 0x11, 0x21, 0x11, 0x3f, 0x11, 0x21, 0x11, 0x21, 0x11, 0x3f, 0x11, 0x00, 0x01, 0x12, 0x01, 0x21, 0x01, 0x40, 0x87, 0x00, 0x00 },
{ 0xf6, 0xcf, 0x04, 0x08, 0x04, 0x08, 0x7f, 0xc8, 0x04, 0x08, 0x04, 0x3f, 0x3f, 0x89, 0x24, 0x89, 0x24, 0x89, 0x3f, 0x89, 0x04, 0x11, 0x0e, 0x11, 0x15, 0x11, 0x24, 0xa1, 0x44, 0x21, 0x04, 0x4e, 0x00, 0x00 },
{ 0xf6, 0xd0, 0x08, 0x40, 0x14, 0x40, 0x22, 0x40, 0x5d, 0x7f, 0x00, 0x80, 0x3f, 0x10, 0x22, 0x10, 0x3e, 0xfe, 0x22, 0x12, 0x3e, 0x12, 0x20, 0x12, 0x3e, 0x22, 0x20, 0x22, 0x3e, 0x42, 0x20, 0x8c, 0x00, 0x00 },
{ 0xf6, 0xd1, 0x08, 0x00, 0x08, 0x7e, 0x7f, 0x42, 0x22, 0x42, 0x14, 0x7e, 0x7f, 0x42, 0x08, 0x7e, 0x08, 0x42, 0x7f, 0x42, 0x08, 0x7e, 0x1c, 0x28, 0x2a, 0x28, 0x48, 0x29, 0x08, 0x49, 0x09, 0x87, 0x00, 0x00 },
{ 0xf6, 0xd2, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x0f, 0x03, 0xf0, 0x7e, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xd3, 0x20, 0x80, 0x10, 0x98, 0x40, 0xe2, 0x23, 0x82, 0x08, 0x82, 0x08, 0x7e, 0x10, 0x00, 0x10, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf6, 0xd4, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x70, 0x41, 0xac, 0x26, 0x23, 0x10, 0x50, 0x01, 0x8c, 0x06, 0x23, 0x11, 0x24, 0x10, 0xa8, 0x20, 0x20, 0x21, 0xac, 0x46, 0x23, 0x40, 0x60, 0x00, 0x00 },
{ 0xf6, 0xd5, 0x08, 0x00, 0x09, 0xfe, 0x10, 0x02, 0x13, 0xff, 0x30, 0x02, 0x31, 0xfe, 0x50, 0x00, 0x17, 0xff, 0x14, 0x01, 0x15, 0xfd, 0x10, 0x44, 0x10, 0x28, 0x10, 0x30, 0x10, 0xcc, 0x13, 0x03, 0x00, 0x00 },
{ 0xf6, 0xd6, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x44, 0xfd, 0x24, 0x04, 0x25, 0xff, 0x3c, 0x04, 0x04, 0xfc, 0x04, 0x00, 0x7d, 0xff, 0x25, 0x01, 0x24, 0xfc, 0x24, 0x44, 0x44, 0x38, 0x05, 0xc7, 0x00, 0x00 },
{ 0xf6, 0xd7, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x7d, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x38, 0x20, 0x38, 0x30, 0x54, 0x50, 0x54, 0x50, 0x50, 0x50, 0x10, 0x90, 0x10, 0x91, 0x11, 0x11, 0x12, 0x0f, 0x00, 0x00 },
{ 0xf6, 0xd8, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x03, 0xfe, 0x42, 0x22, 0x22, 0x22, 0x10, 0x20, 0x00, 0x50, 0x00, 0x50, 0x10, 0x50, 0x10, 0x90, 0x20, 0x90, 0x21, 0x11, 0x42, 0x11, 0x44, 0x0f, 0x00, 0x00 },
{ 0xf6, 0xd9, 0x20, 0x00, 0x11, 0xfe, 0x08, 0x02, 0x03, 0xff, 0x40, 0x02, 0x21, 0xfe, 0x10, 0x00, 0x07, 0xff, 0x04, 0x01, 0x15, 0xfd, 0x10, 0x84, 0x20, 0x48, 0x20, 0x30, 0x40, 0xcc, 0x43, 0x03, 0x00, 0x00 },
{ 0xf6, 0xda, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x29, 0x11, 0x28, 0x7c, 0x49, 0x10, 0x8f, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x1c, 0x38, 0x70, 0x54, 0x01, 0x93, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xf6, 0xdb, 0x00, 0x10, 0x7e, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x20, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x64, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x3c, 0x82, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xdc, 0x08, 0x10, 0x14, 0x10, 0x22, 0x10, 0x40, 0x10, 0x3e, 0x10, 0x08, 0xff, 0x08, 0x10, 0x7e, 0x10, 0x08, 0x10, 0x4a, 0x10, 0x2a, 0x10, 0x28, 0x10, 0x08, 0x10, 0x0e, 0x10, 0x70, 0x10, 0x00, 0x00 },
{ 0xf6, 0xdd, 0x18, 0x12, 0x24, 0x11, 0x40, 0x10, 0x01, 0xff, 0x7d, 0x08, 0x11, 0x08, 0x11, 0xe9, 0x7d, 0x09, 0x11, 0xea, 0x11, 0x2a, 0x55, 0x24, 0x35, 0xed, 0x11, 0x15, 0x1e, 0x23, 0x62, 0xc1, 0x00, 0x00 },
{ 0xf6, 0xde, 0x08, 0x10, 0x3e, 0x10, 0x08, 0x7c, 0x7f, 0x14, 0x22, 0x54, 0x7f, 0x24, 0x08, 0x25, 0x3e, 0x57, 0x08, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x00, 0x9e, 0x3f, 0xe1, 0x00, 0x00 },
{ 0xf6, 0xdf, 0x0c, 0x00, 0x70, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x54, 0x10, 0x92, 0x18, 0x92, 0x38, 0x10, 0x35, 0xff, 0x54, 0x10, 0x50, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf6, 0xe0, 0x0c, 0x06, 0x70, 0x78, 0x10, 0x92, 0x11, 0x09, 0x7c, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x38, 0x92, 0x35, 0xff, 0x50, 0x92, 0x50, 0x92, 0x13, 0xff, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xf6, 0xe1, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x5b, 0xfc, 0x54, 0x44, 0x54, 0x44, 0x50, 0x44, 0x10, 0x44, 0x17, 0xff, 0x10, 0x60, 0x10, 0x90, 0x10, 0x90, 0x11, 0x08, 0x12, 0x04, 0x14, 0x03, 0x00, 0x00 },
{ 0xf6, 0xe2, 0x08, 0x20, 0x08, 0x20, 0x11, 0x20, 0x11, 0x26, 0x31, 0x3a, 0x31, 0xe2, 0x57, 0x22, 0x11, 0x22, 0x11, 0x22, 0x11, 0x2e, 0x11, 0x20, 0x11, 0x20, 0x11, 0x01, 0x11, 0x01, 0x10, 0xff, 0x00, 0x00 },
{ 0xf6, 0xe3, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xff, 0x4a, 0x01, 0x4a, 0x09, 0x48, 0x30, 0x49, 0xc0, 0x48, 0x40, 0x48, 0x4e, 0x4b, 0xf0, 0x78, 0x40, 0x00, 0x40, 0x00, 0x41, 0x00, 0x41, 0x00, 0x3f, 0x00, 0x00 },
{ 0xf6, 0xe4, 0x00, 0x0c, 0x03, 0xf0, 0x78, 0x20, 0x48, 0x20, 0x4b, 0xfe, 0x49, 0x24, 0x49, 0x24, 0x4f, 0xff, 0x49, 0x24, 0x49, 0x24, 0x79, 0x24, 0x03, 0xfe, 0x00, 0x20, 0x00, 0x20, 0x07, 0xff, 0x00, 0x00 },
{ 0xf6, 0xe5, 0x00, 0x20, 0x3d, 0xff, 0x24, 0x40, 0x24, 0x7e, 0x28, 0x88, 0x24, 0xff, 0x25, 0x22, 0x24, 0x3e, 0x38, 0x22, 0x20, 0x3e, 0x21, 0x22, 0x01, 0x26, 0x1f, 0xf8, 0x01, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf6, 0xe6, 0x00, 0x1e, 0x3f, 0xe0, 0x00, 0x01, 0x10, 0x82, 0x08, 0x44, 0x08, 0x48, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x10, 0x14, 0x20, 0x03, 0x40, 0x00, 0xe0, 0x07, 0x18, 0x78, 0x06, 0x00, 0x00 },
{ 0xf6, 0xe7, 0x10, 0x20, 0x13, 0xff, 0x10, 0x40, 0x58, 0xfe, 0x55, 0x10, 0x56, 0xff, 0x50, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xf6, 0xe8, 0x10, 0x00, 0x10, 0x00, 0x11, 0xff, 0x7c, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1c, 0x08, 0x70, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x30, 0x38, 0x00, 0x00 },
{ 0xf6, 0xe9, 0x10, 0x80, 0x10, 0x80, 0x10, 0xfe, 0x7d, 0x00, 0x12, 0x20, 0x10, 0xa0, 0x10, 0xbc, 0x1c, 0xe4, 0x73, 0xa4, 0x10, 0xa4, 0x10, 0xa4, 0x10, 0xad, 0x10, 0x81, 0x10, 0x81, 0x70, 0x7f, 0x00, 0x00 },
{ 0xf6, 0xea, 0x00, 0x00, 0x3f, 0xf0, 0x02, 0x10, 0x04, 0x3e, 0x04, 0x22, 0x18, 0x02, 0x60, 0x1c, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x80, 0x00, 0x00 },
{ 0xf6, 0xeb, 0x10, 0x20, 0x11, 0xff, 0x10, 0x40, 0x7c, 0xbe, 0x11, 0x08, 0x10, 0xff, 0x38, 0x00, 0x38, 0xfe, 0x34, 0x82, 0x54, 0xfe, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x8e, 0x00, 0x00 },
{ 0xf6, 0xec, 0x08, 0x08, 0x10, 0x08, 0x3e, 0x08, 0x22, 0x7f, 0x2a, 0x41, 0x2a, 0x41, 0x22, 0x20, 0x27, 0x22, 0x7a, 0x24, 0x2a, 0x38, 0x2a, 0x20, 0x2a, 0x20, 0x22, 0x21, 0x42, 0x21, 0x46, 0x1f, 0x00, 0x00 },
{ 0xf6, 0xed, 0x00, 0x20, 0x7c, 0x20, 0x45, 0xfe, 0x49, 0x02, 0x49, 0x02, 0x50, 0x40, 0x48, 0x40, 0x48, 0x4c, 0x44, 0x70, 0x44, 0x40, 0x44, 0x40, 0x58, 0x40, 0x40, 0x42, 0x40, 0x42, 0x40, 0x3e, 0x00, 0x00 },
{ 0xf6, 0xee, 0x00, 0x10, 0x3e, 0x10, 0x28, 0x10, 0x3e, 0x10, 0x28, 0x10, 0x3f, 0xff, 0x28, 0x10, 0x28, 0x10, 0x3e, 0x28, 0x02, 0x28, 0x56, 0x28, 0x52, 0x44, 0x42, 0x44, 0x02, 0x82, 0x1d, 0x01, 0x00, 0x00 },
{ 0xf6, 0xef, 0x00, 0x10, 0x3e, 0x10, 0x28, 0xff, 0x3e, 0x81, 0x28, 0x81, 0x3e, 0x20, 0x28, 0x20, 0x28, 0x22, 0x3f, 0x2c, 0x01, 0x30, 0x55, 0x20, 0x55, 0x20, 0x41, 0x21, 0x02, 0x21, 0x0c, 0x1f, 0x00, 0x00 },
{ 0xf6, 0xf0, 0x08, 0x20, 0x08, 0x20, 0x08, 0x3e, 0x10, 0x20, 0x11, 0xfc, 0x31, 0x04, 0x31, 0xfc, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf6, 0xf1, 0x00, 0x80, 0x00, 0x80, 0x00, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf6, 0xf2, 0x00, 0x00, 0x03, 0xff, 0x78, 0x48, 0x48, 0xc8, 0x4b, 0x29, 0x48, 0x2a, 0x49, 0x5c, 0x48, 0x94, 0x4b, 0x94, 0x48, 0x34, 0x78, 0x52, 0x01, 0x92, 0x06, 0x11, 0x00, 0x10, 0x00, 0xe0, 0x00, 0x00 },
{ 0xf6, 0xf3, 0x10, 0x00, 0x10, 0x1c, 0x11, 0xe0, 0x11, 0x00, 0x7d, 0x00, 0x11, 0xff, 0x11, 0x10, 0x11, 0x10, 0x11, 0x70, 0x1d, 0x18, 0x71, 0x14, 0x01, 0x12, 0x02, 0x10, 0x02, 0x10, 0x04, 0x10, 0x00, 0x00 },
{ 0xf6, 0xf4, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x11, 0x10, 0x1f, 0xfe, 0x11, 0x10, 0x11, 0xf0, 0x10, 0x00, 0x1f, 0xfc, 0x12, 0x08, 0x11, 0x10, 0x10, 0xa0, 0x20, 0x40, 0x21, 0xb0, 0x4e, 0x0e, 0x00, 0x00 },
{ 0xf6, 0xf5, 0x10, 0x00, 0x10, 0x0e, 0x11, 0xf0, 0x7c, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x1c, 0x3f, 0x71, 0xe0, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x21, 0x10, 0x21, 0x30, 0x1f, 0x00, 0x00 },
{ 0xf6, 0xf6, 0x10, 0x00, 0x13, 0xff, 0x10, 0x40, 0x7c, 0x40, 0x10, 0x40, 0x10, 0x80, 0x10, 0xfe, 0x1d, 0x82, 0x71, 0x82, 0x12, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x30, 0xfe, 0x00, 0x00 },
{ 0xf6, 0xf7, 0x10, 0x00, 0x11, 0xef, 0x10, 0x63, 0x7d, 0xad, 0x10, 0x63, 0x11, 0xad, 0x10, 0x21, 0x1c, 0x88, 0x70, 0xff, 0x11, 0x88, 0x12, 0xfe, 0x10, 0x88, 0x10, 0xfe, 0x10, 0x88, 0x30, 0xff, 0x00, 0x00 },
{ 0xf6, 0xf8, 0x00, 0x20, 0x00, 0x20, 0x78, 0x3e, 0x48, 0x20, 0x49, 0xfe, 0x49, 0x02, 0x79, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x48, 0x20, 0x78, 0x20, 0x07, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xf6, 0xf9, 0x10, 0x0e, 0x10, 0xf0, 0x10, 0x80, 0x7c, 0x80, 0x10, 0x80, 0x10, 0xff, 0x38, 0x88, 0x38, 0x88, 0x34, 0xb8, 0x54, 0x8c, 0x50, 0x8a, 0x51, 0x09, 0x11, 0x08, 0x11, 0x08, 0x12, 0x08, 0x00, 0x00 },
{ 0xf6, 0xfa, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x49, 0x02, 0x49, 0x43, 0xff, 0x21, 0x00, 0x13, 0xff, 0x02, 0x21, 0x05, 0xfd, 0x11, 0x25, 0x11, 0xfd, 0x20, 0x21, 0x20, 0x29, 0x43, 0xf5, 0x40, 0x06, 0x00, 0x00 },
{ 0xf6, 0xfb, 0x20, 0x00, 0x13, 0xcf, 0x08, 0xc3, 0x03, 0x4d, 0x40, 0xc3, 0x23, 0x4d, 0x10, 0x41, 0x01, 0x10, 0x03, 0xff, 0x15, 0x10, 0x11, 0xfe, 0x21, 0x10, 0x21, 0xfe, 0x41, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xf6, 0xfc, 0x00, 0x00, 0x7d, 0xff, 0x10, 0x28, 0x10, 0x48, 0x11, 0xa8, 0x10, 0x39, 0x7d, 0x5a, 0x10, 0x94, 0x13, 0x94, 0x10, 0x34, 0x10, 0x52, 0x1c, 0x92, 0x73, 0x11, 0x00, 0x10, 0x00, 0x60, 0x00, 0x00 },
{ 0xf6, 0xfd, 0x00, 0x20, 0x7c, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x20, 0x1c, 0x20, 0x73, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xf6, 0xfe, 0x00, 0x06, 0x3c, 0x18, 0x00, 0xe0, 0x7e, 0x20, 0x00, 0x20, 0x3c, 0x20, 0x00, 0x3f, 0x3d, 0xe0, 0x00, 0x20, 0x00, 0x20, 0x3c, 0x20, 0x24, 0x20, 0x24, 0x21, 0x24, 0x21, 0x3c, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xa1, 0x18, 0x00, 0x24, 0xfe, 0x40, 0xaa, 0x00, 0xaa, 0x7c, 0xfe, 0x10, 0x10, 0x10, 0xfe, 0x7c, 0x10, 0x11, 0xff, 0x10, 0x44, 0x55, 0xff, 0x34, 0x10, 0x10, 0xfe, 0x18, 0x10, 0x60, 0x10, 0x00, 0x00 },
{ 0xf7, 0xa2, 0x00, 0x1c, 0x1f, 0xe0, 0x00, 0x80, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xf7, 0xa3, 0x00, 0x88, 0x7b, 0xff, 0x48, 0x88, 0x48, 0xf8, 0x48, 0x20, 0x49, 0xfe, 0x49, 0x22, 0x49, 0xfe, 0x48, 0x20, 0x49, 0xfe, 0x78, 0x20, 0x03, 0xff, 0x00, 0x50, 0x00, 0x8c, 0x03, 0x03, 0x00, 0x00 },
{ 0xf7, 0xa4, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x7c, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00 },
{ 0xf7, 0xa5, 0x7d, 0xef, 0x05, 0x29, 0x05, 0xef, 0x04, 0x00, 0x3c, 0xfe, 0x20, 0x92, 0x20, 0x92, 0x20, 0xfe, 0x7c, 0x92, 0x44, 0x92, 0x04, 0xfe, 0x04, 0x10, 0x05, 0xff, 0x04, 0x10, 0x38, 0x10, 0x00, 0x00 },
{ 0xf7, 0xa6, 0x10, 0x00, 0x11, 0xef, 0x11, 0x29, 0x59, 0xef, 0x54, 0x00, 0x54, 0xfe, 0x50, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x10, 0x10, 0x13, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf7, 0xa7, 0x14, 0x20, 0x7f, 0x20, 0x14, 0x20, 0x1c, 0x7f, 0x08, 0x51, 0x3e, 0x92, 0x2a, 0x10, 0x3e, 0x10, 0x08, 0x28, 0x3e, 0x28, 0x08, 0x28, 0x7f, 0x44, 0x08, 0x44, 0x14, 0x82, 0x63, 0x01, 0x00, 0x00 },
{ 0xf7, 0xa8, 0x22, 0x8a, 0x17, 0xca, 0x0a, 0x94, 0x01, 0x3f, 0x47, 0xd4, 0x25, 0x54, 0x15, 0x5f, 0x07, 0xd4, 0x01, 0x14, 0x17, 0xd4, 0x11, 0x1f, 0x2f, 0xd4, 0x22, 0x94, 0x44, 0x54, 0x48, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xa9, 0x00, 0x40, 0x08, 0x42, 0x08, 0x42, 0x0f, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x20, 0x11, 0x22, 0x11, 0x22, 0x12, 0x54, 0x10, 0x50, 0x20, 0x88, 0x21, 0x04, 0x46, 0x03, 0x00, 0x00 },
{ 0xf7, 0xaa, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x45, 0x01, 0x28, 0x00, 0x11, 0xff, 0x10, 0x10, 0x24, 0x10, 0x7c, 0x90, 0x10, 0x9e, 0x54, 0x90, 0x54, 0x90, 0x51, 0x50, 0x11, 0x30, 0x12, 0x0f, 0x00, 0x00 },
{ 0xf7, 0xab, 0x00, 0x03, 0x3d, 0xdc, 0x00, 0x44, 0x7e, 0x44, 0x00, 0x84, 0x3c, 0x94, 0x01, 0xd7, 0x3d, 0x54, 0x00, 0x54, 0x01, 0x54, 0x3d, 0x54, 0x24, 0x8f, 0x24, 0x80, 0x25, 0x60, 0x3e, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xac, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x08, 0x1a, 0x24, 0x64, 0x43, 0x0f, 0xfc, 0x38, 0x40, 0x0f, 0xfc, 0x08, 0x40, 0x0f, 0xfe, 0x00, 0x08, 0x7f, 0xff, 0x04, 0x08, 0x02, 0x08, 0x00, 0x38, 0x00, 0x00 },
{ 0xf7, 0xad, 0x00, 0x00, 0x3c, 0x5c, 0x24, 0x44, 0x24, 0x82, 0x25, 0xff, 0x3c, 0x82, 0x24, 0x82, 0x24, 0xfe, 0x24, 0x28, 0x3c, 0x28, 0x24, 0x28, 0x24, 0x48, 0x24, 0x49, 0x44, 0x89, 0x4d, 0x07, 0x00, 0x00 },
{ 0xf7, 0xae, 0x10, 0x00, 0x13, 0xff, 0x12, 0x51, 0x7a, 0x51, 0x10, 0x92, 0x13, 0x1e, 0x10, 0x00, 0x18, 0x20, 0x73, 0xff, 0x10, 0x20, 0x10, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x16, 0x23, 0x30, 0x20, 0x00, 0x00 },
{ 0xf7, 0xaf, 0x00, 0x20, 0x78, 0x20, 0x48, 0x20, 0x4b, 0xfe, 0x4a, 0x22, 0x7a, 0x22, 0x4a, 0x22, 0x48, 0x20, 0x78, 0x50, 0x48, 0x50, 0x48, 0x90, 0x48, 0x90, 0x79, 0x11, 0x02, 0x11, 0x04, 0x0f, 0x00, 0x00 },
{ 0xf7, 0xb0, 0x00, 0x10, 0x7e, 0x10, 0x24, 0x10, 0x25, 0xff, 0x3d, 0x11, 0x25, 0x11, 0x24, 0x10, 0x3c, 0x18, 0x24, 0x28, 0x24, 0x28, 0x2e, 0x28, 0x74, 0x48, 0x04, 0x49, 0x04, 0x89, 0x05, 0x0f, 0x00, 0x00 },
{ 0xf7, 0xb1, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x1b, 0xec, 0x60, 0x03, 0x07, 0xf0, 0x00, 0x10, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x06, 0x00, 0x00 },
{ 0xf7, 0xb2, 0x10, 0x88, 0x17, 0xff, 0x10, 0x88, 0x10, 0x20, 0x7c, 0x50, 0x10, 0x88, 0x11, 0x04, 0x16, 0xfb, 0x10, 0x00, 0x10, 0x00, 0x1d, 0xfc, 0x71, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xb3, 0x10, 0x88, 0x17, 0xff, 0x10, 0x88, 0x7c, 0x20, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x1e, 0xfb, 0x70, 0x00, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x31, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xb4, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x7d, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x38, 0x00, 0x37, 0xef, 0x30, 0xa5, 0x51, 0x29, 0x52, 0x63, 0x50, 0xa5, 0x11, 0x29, 0x12, 0x21, 0x10, 0x63, 0x00, 0x00 },
{ 0xf7, 0xb5, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x3f, 0xfe, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x14, 0x04, 0x64, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xb6, 0x08, 0x00, 0x08, 0x7e, 0x7f, 0x22, 0x11, 0x22, 0x11, 0x14, 0x3a, 0x08, 0x26, 0x14, 0x09, 0x63, 0x30, 0x00, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x9c, 0x00, 0x80, 0x00, 0x00 },
{ 0xf7, 0xb7, 0x20, 0x00, 0x11, 0xfe, 0x09, 0x02, 0x01, 0xfe, 0x41, 0x02, 0x21, 0xfe, 0x10, 0x00, 0x07, 0xff, 0x01, 0x00, 0x13, 0xff, 0x14, 0x49, 0x20, 0x89, 0x21, 0x11, 0x42, 0x21, 0x40, 0x4e, 0x00, 0x00 },
{ 0xf7, 0xb8, 0x10, 0x10, 0x54, 0x10, 0x35, 0xff, 0x19, 0x10, 0x7d, 0x7e, 0x11, 0x12, 0x19, 0xff, 0x35, 0x12, 0x35, 0x7e, 0x51, 0x10, 0x51, 0x7e, 0x11, 0x42, 0x12, 0x42, 0x12, 0x42, 0x14, 0x7e, 0x00, 0x00 },
{ 0xf7, 0xb9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x23, 0xfc, 0x12, 0x04, 0x03, 0xfc, 0x42, 0x04, 0x23, 0xfc, 0x00, 0x00, 0x17, 0xff, 0x11, 0x00, 0x23, 0xfe, 0x24, 0x92, 0x49, 0x22, 0x42, 0x4c, 0x00, 0x00 },
{ 0xf7, 0xba, 0x00, 0x20, 0x04, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x6f, 0xfb, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x20, 0x02, 0x20, 0x04, 0x22, 0x08, 0x22, 0x70, 0x1e, 0x00, 0x00 },
{ 0xf7, 0xbb, 0x02, 0x00, 0x02, 0x00, 0x04, 0x08, 0x04, 0x04, 0x08, 0x7e, 0x7f, 0x81, 0x00, 0x01, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xbc, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x09, 0x08, 0x10, 0x84, 0x20, 0x42, 0x40, 0x01, 0x00, 0x00 },
{ 0xf7, 0xbd, 0x02, 0x10, 0x04, 0x08, 0x08, 0x7c, 0x7f, 0x82, 0x00, 0x02, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x80, 0x04, 0x42, 0x24, 0x11, 0x24, 0x11, 0x43, 0xf0, 0x00, 0x00 },
{ 0xf7, 0xbe, 0x08, 0x20, 0x11, 0x23, 0x7f, 0xbc, 0x00, 0xa1, 0x3f, 0x1f, 0x21, 0x00, 0x3f, 0x20, 0x21, 0x23, 0x3f, 0x3c, 0x21, 0x21, 0x23, 0x1f, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xf7, 0xbf, 0x00, 0x10, 0x7f, 0x10, 0x10, 0x20, 0x10, 0x24, 0x1e, 0x42, 0x12, 0x4e, 0x22, 0xf1, 0x32, 0x01, 0x4c, 0x00, 0x04, 0xfe, 0x08, 0x82, 0x08, 0x82, 0x10, 0x82, 0x20, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xf7, 0xc0, 0x20, 0x20, 0x10, 0x20, 0x00, 0x20, 0x07, 0xff, 0x40, 0x20, 0x20, 0x20, 0x00, 0x50, 0x00, 0x50, 0x00, 0x50, 0x10, 0x88, 0x10, 0x88, 0x21, 0x44, 0x21, 0x24, 0x42, 0x22, 0x44, 0x01, 0x00, 0x00 },
{ 0xf7, 0xc1, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x00, 0x1f, 0xfc, 0x02, 0x20, 0x7f, 0xff, 0x08, 0x08, 0x10, 0x84, 0x24, 0x92, 0x42, 0xa1, 0x00, 0x80, 0x02, 0xb0, 0x0c, 0x8c, 0x30, 0x82, 0x01, 0x80, 0x00, 0x00 },
{ 0xf7, 0xc2, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x02, 0x08, 0x04, 0x04, 0x08, 0x7a, 0x3f, 0x81, 0x00, 0x00, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xc3, 0x00, 0x20, 0x3c, 0x20, 0x24, 0x44, 0x24, 0x42, 0x24, 0x8e, 0x3d, 0xf1, 0x24, 0x01, 0x24, 0x00, 0x24, 0xfe, 0x3c, 0x82, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x44, 0x82, 0x4c, 0xfe, 0x00, 0x00 },
{ 0xf7, 0xc4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x01, 0x04, 0x02, 0x02, 0x04, 0x3e, 0x7f, 0xc1, 0x00, 0x01, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xc5, 0x00, 0x20, 0x3c, 0x20, 0x24, 0x44, 0x24, 0x42, 0x24, 0x8d, 0x3d, 0xf1, 0x0b, 0x00, 0x08, 0x00, 0x08, 0xfe, 0x2e, 0x82, 0x28, 0x82, 0x28, 0x82, 0x2e, 0x82, 0x78, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xf7, 0xc6, 0x00, 0x00, 0x08, 0x3e, 0x08, 0x22, 0x08, 0x22, 0x11, 0x24, 0x16, 0xa4, 0x78, 0xa4, 0x00, 0x22, 0x00, 0x22, 0x3f, 0x22, 0x21, 0x22, 0x21, 0x2e, 0x21, 0x20, 0x3f, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xf7, 0xc7, 0x00, 0x08, 0x3f, 0x88, 0x20, 0x8a, 0x26, 0x92, 0x38, 0x93, 0x28, 0xbd, 0x3e, 0x80, 0x2a, 0x9e, 0x2a, 0x92, 0x2a, 0x92, 0x3e, 0x92, 0x28, 0x5e, 0x2a, 0x41, 0x4f, 0x21, 0x79, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xc8, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x19, 0x01, 0xe0, 0x1f, 0x00, 0x01, 0x00, 0x01, 0x1f, 0x7f, 0xe0, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0xff, 0x00, 0x00 },
{ 0xf7, 0xc9, 0x10, 0x00, 0x11, 0xff, 0x11, 0x29, 0x7d, 0xff, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x1d, 0xff, 0x70, 0x44, 0x10, 0x28, 0x11, 0xff, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xf7, 0xca, 0x20, 0x00, 0x13, 0xfe, 0x02, 0x52, 0x03, 0xfe, 0x40, 0x20, 0x23, 0xfe, 0x10, 0x20, 0x07, 0xff, 0x00, 0x88, 0x10, 0x90, 0x17, 0xff, 0x20, 0x20, 0x23, 0xfe, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf7, 0xcb, 0x11, 0x24, 0x10, 0xa8, 0x13, 0xfe, 0x7a, 0x02, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x1c, 0x08, 0x70, 0xf0, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x30, 0xc0, 0x00, 0x00 },
{ 0xf7, 0xcc, 0x10, 0x40, 0x10, 0x78, 0x13, 0xff, 0x7e, 0x41, 0x13, 0xf8, 0x12, 0x42, 0x12, 0xfe, 0x1e, 0x92, 0x72, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x12, 0x22, 0x15, 0x55, 0x15, 0x45, 0x35, 0x3c, 0x00, 0x00 },
{ 0xf7, 0xcd, 0x00, 0x3e, 0x3f, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x02, 0x40, 0x02, 0x50, 0x04, 0x49, 0x04, 0x41, 0x18, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xf7, 0xce, 0x00, 0x20, 0x00, 0x20, 0x78, 0x20, 0x48, 0x20, 0x48, 0x20, 0x4b, 0xfe, 0x48, 0x20, 0x48, 0x20, 0x48, 0x20, 0x48, 0x20, 0x48, 0x20, 0x78, 0x20, 0x00, 0x20, 0x00, 0x20, 0x07, 0xff, 0x00, 0x00 },
{ 0xf7, 0xcf, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xf7, 0xd0, 0x00, 0x04, 0x3e, 0x04, 0x00, 0x04, 0x7f, 0x04, 0x00, 0xff, 0x3e, 0x04, 0x00, 0x04, 0x3e, 0x44, 0x00, 0x24, 0x00, 0x14, 0x3e, 0x04, 0x22, 0x04, 0x22, 0x04, 0x22, 0x04, 0x3e, 0x1c, 0x00, 0x00 },
{ 0xf7, 0xd1, 0x10, 0x64, 0x13, 0x84, 0x10, 0x84, 0x5b, 0xe4, 0x54, 0x9f, 0x53, 0xe5, 0x52, 0xa5, 0x13, 0xe5, 0x12, 0xa5, 0x13, 0xe9, 0x10, 0x89, 0x13, 0xe9, 0x10, 0x91, 0x10, 0xf1, 0x13, 0xa6, 0x00, 0x00 },
{ 0xf7, 0xd2, 0x10, 0xfc, 0x10, 0x04, 0x10, 0x28, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x11, 0x39, 0x11, 0x39, 0xff, 0x35, 0x11, 0x55, 0x11, 0x51, 0xff, 0x51, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x17, 0x00, 0x00 },
{ 0xf7, 0xd3, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x42, 0x02, 0x22, 0xfa, 0x12, 0x02, 0x02, 0xfa, 0x02, 0x8a, 0x12, 0x8a, 0x12, 0x8a, 0x22, 0xfa, 0x22, 0x02, 0x42, 0x02, 0x42, 0x02, 0x02, 0x0e, 0x00, 0x00 },
{ 0xf7, 0xd4, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x51, 0xfc, 0x30, 0x48, 0x10, 0x30, 0x13, 0xff, 0x32, 0x21, 0x53, 0xff, 0x12, 0x21, 0x13, 0xff, 0x22, 0x21, 0x22, 0x21, 0x42, 0x27, 0x00, 0x00 },
{ 0xf7, 0xd5, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x27, 0xf2, 0x20, 0x02, 0x27, 0xf2, 0x24, 0x12, 0x24, 0x12, 0x27, 0xf2, 0x20, 0x02, 0x20, 0x0e, 0x00, 0x00 },
{ 0xf7, 0xd6, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x44, 0x20, 0x28, 0x24, 0x10, 0x46, 0x11, 0xf9, 0x24, 0x00, 0x7c, 0x48, 0x10, 0x48, 0x54, 0x48, 0x54, 0x88, 0x50, 0x89, 0x11, 0x09, 0x12, 0x0f, 0x00, 0x00 },
{ 0xf7, 0xd7, 0x20, 0x00, 0x13, 0xfc, 0x08, 0x08, 0x00, 0x50, 0x40, 0x20, 0x23, 0xfe, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x73, 0xfe, 0x12, 0x22, 0x12, 0x22, 0x12, 0x2e, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf7, 0xd8, 0x10, 0x44, 0x10, 0x44, 0x10, 0x88, 0x10, 0xff, 0x7d, 0x88, 0x11, 0x88, 0x12, 0x88, 0x10, 0xfe, 0x10, 0x88, 0x10, 0x88, 0x1c, 0xfe, 0x70, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xff, 0x00, 0x00 },
{ 0xf7, 0xd9, 0x10, 0x00, 0x12, 0x08, 0x11, 0x10, 0x7c, 0x3e, 0x10, 0x22, 0x12, 0x22, 0x39, 0x3e, 0x38, 0x20, 0x34, 0x20, 0x57, 0x3e, 0x51, 0x22, 0x51, 0x22, 0x11, 0x3e, 0x12, 0x80, 0x14, 0x7f, 0x00, 0x00 },
{ 0xf7, 0xda, 0x00, 0x00, 0x3d, 0x3e, 0x24, 0xa2, 0x24, 0x22, 0x24, 0x3e, 0x3d, 0x22, 0x24, 0xa2, 0x24, 0x3e, 0x24, 0x28, 0x3d, 0xa5, 0x24, 0xae, 0x24, 0xf2, 0x24, 0x81, 0x45, 0x60, 0x4e, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xdb, 0x10, 0x00, 0x11, 0x1e, 0x10, 0x92, 0x7c, 0x1e, 0x05, 0x12, 0x08, 0x9e, 0x08, 0x14, 0x10, 0x15, 0x35, 0x96, 0x58, 0x94, 0x14, 0x9a, 0x10, 0xb1, 0x10, 0x80, 0x11, 0x60, 0x12, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xdc, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x04, 0x01, 0x04, 0x41, 0xfc, 0x21, 0x04, 0x11, 0x04, 0x01, 0xfc, 0x01, 0x22, 0x71, 0x24, 0x11, 0x18, 0x11, 0xe4, 0x13, 0x03, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf7, 0xdd, 0x03, 0x00, 0x3c, 0x7f, 0x04, 0x08, 0x7f, 0x90, 0x0e, 0x3e, 0x15, 0x22, 0x64, 0xbe, 0x00, 0x22, 0x1e, 0x3e, 0x12, 0x22, 0x12, 0x22, 0x12, 0xbe, 0x23, 0x00, 0x26, 0x14, 0x40, 0x63, 0x00, 0x00 },
{ 0xf7, 0xde, 0x09, 0xf0, 0x08, 0x28, 0x10, 0x44, 0x11, 0x82, 0x36, 0x79, 0x30, 0x00, 0x53, 0xca, 0x52, 0x54, 0x13, 0x54, 0x12, 0xe8, 0x12, 0x68, 0x13, 0x54, 0x12, 0xd4, 0x12, 0x4a, 0x12, 0xca, 0x00, 0x00 },
{ 0xf7, 0xdf, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x08, 0x1f, 0xf4, 0x64, 0x03, 0x07, 0xf0, 0x04, 0x00, 0x07, 0xf0, 0x04, 0x00, 0x7f, 0xff, 0x02, 0x10, 0x04, 0x08, 0x08, 0xf4, 0x3f, 0x02, 0x00, 0x00 },
{ 0xf7, 0xe0, 0x10, 0x00, 0x11, 0xff, 0x10, 0x20, 0x7c, 0x20, 0x24, 0x20, 0x24, 0x40, 0x24, 0x40, 0x24, 0xfe, 0x44, 0xc2, 0x69, 0x42, 0x5a, 0x42, 0x08, 0x42, 0x14, 0x42, 0x22, 0x42, 0x40, 0x7e, 0x00, 0x00 },
{ 0xf7, 0xe1, 0x10, 0x00, 0x10, 0x78, 0x10, 0x48, 0x7c, 0x49, 0x10, 0x89, 0x10, 0x8f, 0x11, 0x00, 0x1c, 0x00, 0x71, 0xfe, 0x10, 0x42, 0x10, 0x44, 0x10, 0x28, 0x10, 0x10, 0x10, 0x6c, 0x31, 0x83, 0x00, 0x00 },
{ 0xf7, 0xe2, 0x40, 0x1c, 0x21, 0xe0, 0x10, 0x20, 0x07, 0xff, 0x40, 0xa8, 0x21, 0x24, 0x12, 0x23, 0x01, 0xfc, 0x00, 0x44, 0x70, 0x48, 0x10, 0x9e, 0x11, 0x02, 0x12, 0x1c, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf7, 0xe3, 0x40, 0x02, 0x5e, 0xfa, 0x44, 0x22, 0x5e, 0xfa, 0x44, 0x22, 0x5e, 0xfa, 0x40, 0x02, 0x5f, 0x12, 0x40, 0x7a, 0x5f, 0x12, 0x51, 0x52, 0x5f, 0x32, 0x4a, 0x12, 0x5f, 0x32, 0x40, 0x06, 0x00, 0x00 },
{ 0xf7, 0xe4, 0x3f, 0xff, 0x21, 0x10, 0x2f, 0xfe, 0x20, 0x90, 0x2f, 0xfe, 0x21, 0x00, 0x23, 0xfc, 0x2d, 0x04, 0x21, 0xfc, 0x20, 0x00, 0x3f, 0xff, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xf7, 0xe5, 0x08, 0x10, 0x08, 0x10, 0x28, 0xfe, 0x28, 0x10, 0x3e, 0x10, 0x49, 0xff, 0x48, 0x04, 0x08, 0x04, 0x1d, 0xff, 0x68, 0x04, 0x08, 0x44, 0x08, 0x24, 0x08, 0x04, 0x08, 0x04, 0x08, 0x1c, 0x00, 0x00 },
{ 0xf7, 0xe6, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x4f, 0xe2, 0x49, 0x02, 0x4f, 0xe2, 0x49, 0x02, 0x4f, 0xf2, 0x55, 0x52, 0x55, 0x12, 0x40, 0x62, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf7, 0xe7, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x11, 0x11, 0x7d, 0x12, 0x11, 0x10, 0x11, 0xfe, 0x11, 0x42, 0x11, 0x42, 0x11, 0x24, 0x1d, 0x24, 0x72, 0x18, 0x02, 0x18, 0x04, 0x24, 0x08, 0xc3, 0x00, 0x00 },
{ 0xf7, 0xe8, 0x10, 0x10, 0x09, 0xff, 0x41, 0x10, 0x21, 0x10, 0x01, 0xfe, 0x09, 0x42, 0x12, 0x24, 0x22, 0x18, 0x44, 0xe7, 0x02, 0x00, 0x7f, 0xff, 0x04, 0x08, 0x0f, 0x90, 0x00, 0x78, 0x3f, 0x87, 0x00, 0x00 },
{ 0xf7, 0xe9, 0x00, 0x00, 0x7f, 0xfc, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x41, 0x04, 0x7f, 0xfc, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf7, 0xea, 0x10, 0x00, 0x11, 0xff, 0x11, 0x11, 0x7d, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1d, 0xff, 0x71, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x01, 0x11, 0x01, 0x30, 0xff, 0x00, 0x00 },
{ 0xf7, 0xeb, 0x10, 0x1e, 0x13, 0xe0, 0x11, 0x24, 0x7c, 0xa8, 0x13, 0xff, 0x10, 0xa8, 0x11, 0x24, 0x1e, 0x23, 0x71, 0xfc, 0x11, 0x24, 0x11, 0x24, 0x11, 0xfc, 0x11, 0x24, 0x11, 0x24, 0x31, 0xfc, 0x00, 0x00 },
{ 0xf7, 0xec, 0x13, 0xfe, 0x12, 0x52, 0x13, 0xfe, 0x79, 0x00, 0x11, 0x13, 0x12, 0x5c, 0x17, 0xd0, 0x18, 0x11, 0x73, 0xcf, 0x12, 0x40, 0x13, 0xd3, 0x12, 0x5c, 0x13, 0xd0, 0x12, 0x51, 0x32, 0xcf, 0x00, 0x00 },
{ 0xf7, 0xed, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x22, 0x7d, 0x22, 0x11, 0x22, 0x11, 0x22, 0x39, 0x22, 0x39, 0xfe, 0x35, 0x00, 0x55, 0x00, 0x51, 0x00, 0x51, 0x00, 0x11, 0x01, 0x11, 0x01, 0x10, 0xff, 0x00, 0x00 },
{ 0xf7, 0xee, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x02, 0x21, 0x42, 0x22, 0x22, 0x20, 0x13, 0xfc, 0x02, 0x84, 0x02, 0x84, 0x12, 0x48, 0x12, 0x48, 0x22, 0x30, 0x24, 0x30, 0x44, 0xcc, 0x4b, 0x03, 0x00, 0x00 },
{ 0xf7, 0xef, 0x20, 0x0c, 0x10, 0x30, 0x0b, 0xc0, 0x02, 0x06, 0x42, 0x78, 0x22, 0x50, 0x12, 0x51, 0x02, 0x52, 0x02, 0x54, 0x12, 0x48, 0x12, 0x48, 0x22, 0x44, 0x24, 0x44, 0x44, 0x42, 0x48, 0x41, 0x00, 0x00 },
{ 0xf7, 0xf0, 0x01, 0xc0, 0x1f, 0x3f, 0x15, 0x29, 0x15, 0x29, 0x15, 0x29, 0x15, 0x3f, 0x15, 0x20, 0x15, 0x20, 0x15, 0x21, 0x14, 0xa1, 0x24, 0x9f, 0x24, 0x40, 0x24, 0x20, 0x44, 0x18, 0x44, 0x07, 0x00, 0x00 },
{ 0xf7, 0xf1, 0x00, 0x00, 0x7f, 0x7f, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x0e, 0x08, 0x78, 0x7f, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x3f, 0xfe, 0x20, 0x00, 0x20, 0x01, 0x1f, 0xff, 0x00, 0x00 },
{ 0xf7, 0xf2, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x11, 0x11, 0x12, 0x21, 0x10, 0x3d, 0xfe, 0x25, 0x42, 0x65, 0x42, 0x25, 0x24, 0x25, 0x24, 0x25, 0x18, 0x3e, 0x18, 0x02, 0x24, 0x04, 0xc3, 0x00, 0x00 },
{ 0xf7, 0xf3, 0x00, 0x00, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x08, 0x00, 0x11, 0x26, 0x7f, 0xb8, 0x00, 0xa1, 0x3f, 0x1f, 0x21, 0x00, 0x3f, 0x20, 0x21, 0x26, 0x3f, 0x38, 0x21, 0x21, 0x27, 0x1f, 0x00, 0x00 },
{ 0xf7, 0xf4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x01, 0x10, 0x01, 0x0f, 0xff, 0x00, 0x00 },
{ 0xf7, 0xf5, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0xff, 0x22, 0x91, 0x3e, 0x92, 0x08, 0x90, 0x08, 0xfe, 0x28, 0xa2, 0x2e, 0xa2, 0x28, 0x94, 0x28, 0x94, 0x29, 0x08, 0x2f, 0x14, 0x72, 0x63, 0x00, 0x00 },
{ 0xf7, 0xf6, 0x04, 0x00, 0x04, 0x7f, 0x04, 0x08, 0x3f, 0x90, 0x24, 0xbf, 0x25, 0x21, 0x24, 0x3f, 0x3f, 0x21, 0x21, 0x3f, 0x29, 0x21, 0x26, 0x21, 0x22, 0x3f, 0x45, 0x00, 0x49, 0x16, 0x50, 0x61, 0x00, 0x00 },
{ 0xf7, 0xf7, 0x04, 0x01, 0x15, 0x11, 0x24, 0x91, 0x44, 0x51, 0x04, 0x11, 0x3f, 0x91, 0x04, 0x11, 0x04, 0x11, 0x7f, 0xd1, 0x04, 0x11, 0x04, 0x11, 0x08, 0x11, 0x08, 0x01, 0x10, 0x01, 0x20, 0x07, 0x00, 0x00 },
{ 0xf7, 0xf8, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x11, 0x00, 0x7d, 0x00, 0x11, 0xfe, 0x11, 0x42, 0x11, 0x42, 0x11, 0x24, 0x11, 0x24, 0x1d, 0x18, 0x71, 0x18, 0x02, 0x24, 0x02, 0x42, 0x04, 0x81, 0x00, 0x00 },
{ 0xf7, 0xf9, 0x10, 0x00, 0x11, 0xff, 0x11, 0x00, 0x7d, 0x00, 0x11, 0x00, 0x11, 0xfe, 0x39, 0x42, 0x35, 0x42, 0x35, 0x24, 0x51, 0x24, 0x51, 0x18, 0x11, 0x18, 0x12, 0x24, 0x12, 0x42, 0x14, 0x81, 0x00, 0x00 },
{ 0xf7, 0xfa, 0x24, 0x00, 0x24, 0xff, 0x24, 0x80, 0x24, 0x80, 0x3e, 0x80, 0x20, 0xfe, 0x20, 0xa2, 0x20, 0xa2, 0x3c, 0xa2, 0x24, 0x94, 0x24, 0x94, 0x24, 0x88, 0x45, 0x14, 0x45, 0x22, 0x46, 0x41, 0x00, 0x00 },
{ 0xf7, 0xfb, 0x10, 0x14, 0x10, 0x64, 0x7b, 0xaf, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0xaa, 0x7a, 0xaf, 0x12, 0xa4, 0x1a, 0xa4, 0x72, 0xaf, 0x12, 0x94, 0x24, 0xd4, 0x25, 0x2c, 0x48, 0x04, 0x00, 0x00 },
{ 0xf7, 0xfc, 0x00, 0x00, 0x3e, 0xff, 0x22, 0x80, 0x22, 0x80, 0x3e, 0x80, 0x22, 0xfe, 0x22, 0xa2, 0x3e, 0xa2, 0x22, 0xa2, 0x22, 0x94, 0x22, 0x94, 0x3e, 0x88, 0x00, 0x94, 0x15, 0x22, 0x63, 0x41, 0x00, 0x00 },
{ 0xf7, 0xfd, 0x11, 0x04, 0x11, 0x04, 0x7f, 0xdf, 0x25, 0x49, 0x25, 0x4a, 0x29, 0x4a, 0x7d, 0x5f, 0x11, 0x44, 0x11, 0x44, 0x1d, 0x44, 0x72, 0x5f, 0x12, 0x44, 0x22, 0x44, 0x24, 0x44, 0x45, 0x84, 0x00, 0x00 },
{ 0xf7, 0xfe, 0x18, 0x00, 0x24, 0xff, 0x40, 0x80, 0x00, 0x80, 0x7c, 0x80, 0x10, 0xfe, 0x10, 0xa2, 0x7c, 0xa2, 0x10, 0xa2, 0x10, 0x94, 0x54, 0x94, 0x34, 0x88, 0x11, 0x14, 0x19, 0x22, 0x62, 0x41, 0x00, 0x00 },
{ 0xf8, 0xa1, 0x00, 0x00, 0x7d, 0xff, 0x45, 0x00, 0x49, 0x00, 0x49, 0x00, 0x51, 0xfe, 0x49, 0x42, 0x49, 0x42, 0x45, 0x42, 0x45, 0x24, 0x45, 0x24, 0x59, 0x18, 0x42, 0x18, 0x42, 0x24, 0x44, 0xc3, 0x00, 0x00 },
{ 0xf8, 0xa2, 0x01, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x08, 0x10, 0x08, 0x10, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0x01, 0x00, 0x00 },
{ 0xf8, 0xa3, 0x00, 0x78, 0x00, 0x08, 0x7c, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x84, 0x45, 0x04, 0x7d, 0x04, 0x01, 0x04, 0x02, 0x02, 0x02, 0x02, 0x04, 0x01, 0x00, 0x00 },
{ 0xf8, 0xa4, 0x10, 0x01, 0x13, 0xe9, 0x12, 0x29, 0x7a, 0x29, 0x12, 0x29, 0x13, 0xe9, 0x11, 0x09, 0x19, 0x09, 0x71, 0xe9, 0x11, 0x29, 0x11, 0x29, 0x11, 0x21, 0x12, 0x21, 0x12, 0x21, 0x34, 0xc7, 0x00, 0x00 },
{ 0xf8, 0xa5, 0x08, 0x00, 0x0b, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x32, 0xfa, 0x32, 0x22, 0x52, 0x22, 0x52, 0xfe, 0x12, 0xa6, 0x12, 0xa6, 0x12, 0xa6, 0x12, 0xa6, 0x12, 0xae, 0x14, 0x21, 0x14, 0x21, 0x00, 0x00 },
{ 0xf8, 0xa6, 0x00, 0xfe, 0x7c, 0x82, 0x44, 0x82, 0x44, 0xfe, 0x44, 0x82, 0x44, 0x82, 0x44, 0xfe, 0x44, 0x82, 0x44, 0x82, 0x7c, 0x82, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x82, 0x03, 0x01, 0x00, 0x00 },
{ 0xf8, 0xa7, 0x10, 0x10, 0x10, 0x10, 0x19, 0xff, 0x54, 0x10, 0x54, 0x10, 0x51, 0xff, 0x51, 0x01, 0x11, 0x7d, 0x10, 0x08, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, 0x00 },
{ 0xf8, 0xa8, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x20, 0x22, 0x3f, 0x3e, 0x22, 0x22, 0x42, 0x22, 0x42, 0x3e, 0xa2, 0x22, 0x24, 0x22, 0x14, 0x22, 0x14, 0x3e, 0x08, 0x00, 0x14, 0x16, 0x22, 0x61, 0x41, 0x00, 0x00 },
{ 0xf8, 0xa9, 0x20, 0x20, 0x10, 0x20, 0x00, 0x20, 0x07, 0xff, 0x40, 0x20, 0x20, 0x20, 0x13, 0xfe, 0x02, 0x22, 0x02, 0x22, 0x12, 0x22, 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x42, 0x26, 0x40, 0x20, 0x00, 0x00 },
{ 0xf8, 0xaa, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x04, 0x41, 0x04, 0x21, 0xfc, 0x11, 0x04, 0x01, 0x04, 0x09, 0xfc, 0x09, 0x04, 0x11, 0x04, 0x11, 0x04, 0x21, 0xfc, 0x20, 0x88, 0x41, 0x04, 0x46, 0x02, 0x00, 0x00 },
{ 0xf8, 0xab, 0x28, 0x20, 0x28, 0x40, 0x29, 0xfe, 0x29, 0x22, 0x3d, 0x22, 0x21, 0xfe, 0x21, 0x22, 0x3d, 0x22, 0x25, 0xfe, 0x24, 0x44, 0x24, 0x84, 0x25, 0xff, 0x24, 0x04, 0x44, 0x04, 0x44, 0x04, 0x00, 0x00 },
{ 0xf8, 0xac, 0x04, 0x00, 0x44, 0xfe, 0x28, 0x82, 0x10, 0x82, 0x30, 0xfe, 0x50, 0x82, 0x08, 0x82, 0x08, 0xfe, 0x18, 0x82, 0x28, 0x82, 0x48, 0x82, 0x08, 0xfe, 0x08, 0x00, 0x08, 0xc6, 0x33, 0x01, 0x00, 0x00 },
{ 0xf8, 0xad, 0x0c, 0x10, 0x70, 0x20, 0x11, 0xfe, 0x11, 0x22, 0x7d, 0x22, 0x11, 0xfe, 0x19, 0x22, 0x39, 0x22, 0x35, 0xfe, 0x54, 0x48, 0x50, 0x88, 0x53, 0xff, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x00, 0x00 },
{ 0xf8, 0xae, 0x00, 0x00, 0x7f, 0xff, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x3f, 0xfe, 0x12, 0x00, 0x7f, 0xbf, 0x12, 0x21, 0x3f, 0x3f, 0x29, 0x21, 0x3f, 0x3f, 0x08, 0x21, 0x7f, 0x41, 0x08, 0x47, 0x00, 0x00 },
{ 0xf8, 0xaf, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x04, 0x30, 0x18, 0x0c, 0x60, 0x02, 0x00, 0x00 },
{ 0xf8, 0xb0, 0x08, 0x02, 0x7f, 0x04, 0x08, 0x08, 0x08, 0x10, 0x3e, 0x62, 0x00, 0x04, 0x3e, 0x08, 0x22, 0x10, 0x22, 0x60, 0x3e, 0x01, 0x00, 0x02, 0x24, 0x04, 0x17, 0x08, 0x0c, 0x30, 0x70, 0xc0, 0x00, 0x00 },
{ 0xf8, 0xb1, 0x20, 0x81, 0x10, 0x81, 0x0b, 0xe2, 0x00, 0x84, 0x43, 0xe8, 0x20, 0x01, 0x13, 0xe1, 0x02, 0x22, 0x02, 0x24, 0x13, 0xe8, 0x10, 0x01, 0x22, 0x21, 0x21, 0x42, 0x40, 0x64, 0x47, 0x88, 0x00, 0x00 },
{ 0xf8, 0xb2, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x18, 0x00, 0xe0, 0x00, 0x80, 0x01, 0x80, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xf8, 0xb3, 0x00, 0x40, 0x3c, 0x41, 0x25, 0xf1, 0x24, 0x42, 0x24, 0x44, 0x3d, 0xf0, 0x24, 0x01, 0x25, 0xf1, 0x25, 0x12, 0x3d, 0x14, 0x25, 0xf0, 0x25, 0x11, 0x24, 0xa1, 0x44, 0x32, 0x4d, 0xcc, 0x00, 0x00 },
{ 0xf8, 0xb4, 0x10, 0x80, 0x10, 0xff, 0x11, 0x00, 0x5a, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x50, 0x82, 0x10, 0xfe, 0x10, 0x40, 0x10, 0x7c, 0x10, 0xc4, 0x13, 0x28, 0x10, 0x30, 0x10, 0xcc, 0x17, 0x03, 0x00, 0x00 },
{ 0xf8, 0xb5, 0x08, 0x00, 0x0b, 0xff, 0x08, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x32, 0x22, 0x33, 0xfe, 0x52, 0x22, 0x52, 0x22, 0x13, 0xfe, 0x11, 0x20, 0x10, 0xc0, 0x10, 0x60, 0x11, 0x98, 0x16, 0x07, 0x00, 0x00 },
{ 0xf8, 0xb6, 0x09, 0x1e, 0x09, 0xe0, 0x09, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x31, 0x02, 0x31, 0xfe, 0x51, 0x00, 0x51, 0xfe, 0x11, 0xaa, 0x11, 0xaa, 0x12, 0xfe, 0x12, 0xaa, 0x14, 0xaa, 0x10, 0xaa, 0x00, 0x00 },
{ 0xf8, 0xb7, 0x10, 0x7c, 0x1f, 0x80, 0x10, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x00, 0x1f, 0xfe, 0x19, 0x22, 0x29, 0x22, 0x2f, 0xfe, 0x29, 0x22, 0x49, 0x22, 0x09, 0x2e, 0x00, 0x00 },
{ 0xf8, 0xb8, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x0f, 0xff, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x10, 0x08, 0x10, 0x08, 0x20, 0x08, 0x40, 0x08, 0x00, 0x00 },
{ 0xf8, 0xb9, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x1f, 0xff, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x17, 0xfe, 0x14, 0x92, 0x27, 0xfe, 0x24, 0x92, 0x44, 0x96, 0x00, 0x00 },
{ 0xf8, 0xba, 0x11, 0x1e, 0x11, 0xe0, 0x25, 0x00, 0x45, 0xfe, 0x29, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x25, 0x00, 0x7d, 0xfe, 0x11, 0xaa, 0x55, 0xaa, 0x56, 0xfe, 0x52, 0xaa, 0x14, 0xaa, 0x10, 0xaa, 0x00, 0x00 },
{ 0xf8, 0xbb, 0x27, 0x00, 0x38, 0x77, 0x20, 0x11, 0x3f, 0x11, 0x21, 0x11, 0x21, 0x33, 0x3f, 0x55, 0x20, 0x11, 0x20, 0x11, 0x3f, 0x13, 0x35, 0x35, 0x55, 0x51, 0x5f, 0x11, 0x15, 0x11, 0x15, 0x33, 0x00, 0x00 },
{ 0xf8, 0xbc, 0x21, 0x1e, 0x11, 0xe0, 0x09, 0x00, 0x41, 0xfe, 0x21, 0x02, 0x11, 0xfe, 0x01, 0x00, 0x01, 0xfe, 0x71, 0xaa, 0x12, 0xfe, 0x12, 0xaa, 0x14, 0xaa, 0x10, 0xaa, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf8, 0xbd, 0x28, 0x80, 0x28, 0xbf, 0x7c, 0x88, 0x29, 0x08, 0x39, 0x3e, 0x13, 0x2a, 0x7d, 0x3e, 0x55, 0x2a, 0x55, 0x2a, 0x7d, 0x3e, 0x11, 0x48, 0x7d, 0x28, 0x11, 0x10, 0x11, 0x2c, 0x11, 0x43, 0x00, 0x00 },
{ 0xf8, 0xbe, 0x00, 0x4e, 0x3e, 0x70, 0x28, 0x40, 0x3e, 0x7e, 0x28, 0x42, 0x3e, 0x7e, 0x28, 0x40, 0x28, 0x40, 0x3e, 0x7f, 0x02, 0x55, 0x52, 0xd5, 0x52, 0xff, 0x45, 0x55, 0x04, 0x55, 0x18, 0x43, 0x00, 0x00 },
{ 0xf8, 0xbf, 0x00, 0x02, 0x3c, 0x1c, 0x24, 0xf0, 0x24, 0x10, 0x3c, 0x10, 0x25, 0xfe, 0x24, 0x02, 0x3c, 0x04, 0x24, 0x04, 0x24, 0x08, 0x24, 0x90, 0x3c, 0xa0, 0x01, 0x40, 0x29, 0x30, 0x44, 0x0f, 0x00, 0x00 },
{ 0xf8, 0xc0, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x78, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x1c, 0x20, 0x70, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xf8, 0xc1, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x04, 0x90, 0x08, 0x88, 0x10, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf8, 0xc2, 0x08, 0x00, 0x08, 0xfe, 0x08, 0x10, 0x7e, 0x54, 0x08, 0x92, 0x09, 0x11, 0x1c, 0x10, 0x1a, 0x10, 0x2b, 0xff, 0x28, 0x10, 0x48, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00 },
{ 0xf8, 0xc3, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x20, 0x00, 0x11, 0xfe, 0x00, 0x20, 0x41, 0x24, 0x21, 0x22, 0x0a, 0x22, 0x08, 0x20, 0x13, 0xff, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf8, 0xc4, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x10, 0x7e, 0x10, 0x00, 0x54, 0x3c, 0x92, 0x00, 0x92, 0x3c, 0x10, 0x01, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xf8, 0xc5, 0x00, 0x20, 0x00, 0x24, 0x78, 0x22, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x48, 0x50, 0x48, 0x50, 0x48, 0x50, 0x48, 0x88, 0x78, 0x88, 0x01, 0x04, 0x02, 0x02, 0x04, 0x01, 0x00, 0x00 },
{ 0xf8, 0xc6, 0x00, 0x10, 0x3e, 0xfe, 0x22, 0x44, 0x3e, 0x48, 0x20, 0xff, 0x3e, 0x10, 0x52, 0xfe, 0x5e, 0x10, 0x00, 0x90, 0x01, 0x00, 0x7f, 0xff, 0x04, 0x10, 0x0f, 0x20, 0x01, 0xf0, 0x3e, 0x0c, 0x00, 0x00 },
{ 0xf8, 0xc7, 0x2a, 0x10, 0x49, 0x10, 0x7f, 0x3f, 0x49, 0x62, 0x5d, 0x14, 0x6b, 0x08, 0x49, 0x14, 0x4b, 0x63, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x20, 0x82, 0x20, 0x82, 0x20, 0x8e, 0x00, 0x80, 0x00, 0x00 },
{ 0xf8, 0xc8, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x00, 0x23, 0xc4, 0x28, 0xa9, 0x25, 0x12, 0x26, 0x0c, 0x3b, 0x3b, 0x21, 0x2a, 0x2f, 0x4e, 0x28, 0x00, 0x2f, 0x7e, 0x49, 0x22, 0x41, 0x1c, 0x46, 0x63, 0x00, 0x00 },
{ 0xf8, 0xc9, 0x2a, 0x10, 0x49, 0x10, 0x7f, 0x3f, 0x49, 0x62, 0x5d, 0x14, 0x6b, 0x08, 0x49, 0x14, 0x4b, 0x63, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x04, 0x10, 0x08, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xf8, 0xca, 0x15, 0x20, 0x24, 0xa0, 0x44, 0x3e, 0x3f, 0xe4, 0x24, 0xa4, 0x2e, 0x98, 0x35, 0x98, 0x24, 0xe6, 0x00, 0x00, 0x7f, 0xfe, 0x08, 0x40, 0x1f, 0x4c, 0x69, 0x70, 0x0e, 0x42, 0x70, 0x7e, 0x00, 0x00 },
{ 0xf8, 0xcb, 0x00, 0x10, 0x3c, 0x10, 0x25, 0xff, 0x24, 0x10, 0x24, 0x10, 0x3c, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x24, 0x92, 0x3c, 0x92, 0x24, 0x92, 0x24, 0x92, 0x24, 0x96, 0x44, 0x10, 0x4c, 0x10, 0x00, 0x00 },
{ 0xf8, 0xcc, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x2a, 0x10, 0x49, 0x1f, 0x08, 0x22, 0x7f, 0x22, 0x49, 0x52, 0x49, 0x14, 0x5d, 0x14, 0x6b, 0x08, 0x49, 0x14, 0x49, 0x22, 0x4b, 0x41, 0x00, 0x00 },
{ 0xf8, 0xcd, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x40, 0x82, 0x40, 0x82, 0x5f, 0xf2, 0x41, 0x82, 0x42, 0x82, 0x44, 0x82, 0x58, 0x82, 0x41, 0x82, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf8, 0xce, 0x00, 0x88, 0x3c, 0x88, 0x24, 0x8b, 0x24, 0xec, 0x28, 0x88, 0x28, 0xe9, 0x2b, 0x89, 0x24, 0x07, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x39, 0xfc, 0x20, 0x20, 0x20, 0x20, 0x27, 0xff, 0x00, 0x00 },
{ 0xf8, 0xcf, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x40, 0x10, 0x50, 0x30, 0x90, 0x31, 0xfe, 0x52, 0x92, 0x14, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x96, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf8, 0xd0, 0x10, 0x00, 0x10, 0x00, 0x3f, 0xfc, 0x20, 0x04, 0x20, 0x04, 0x5f, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x84, 0x1f, 0x88, 0x10, 0x08, 0x10, 0x70, 0x10, 0x01, 0x10, 0x01, 0x0f, 0xff, 0x00, 0x00 },
{ 0xf8, 0xd1, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x12, 0x82, 0x12, 0x42, 0x3f, 0xe2, 0x42, 0x02, 0x1f, 0xe2, 0x12, 0x22, 0x1f, 0xe2, 0x12, 0x22, 0x1f, 0xe2, 0x12, 0x22, 0x12, 0x22, 0x12, 0x6c, 0x00, 0x00 },
{ 0xf8, 0xd2, 0x08, 0x20, 0x7f, 0x20, 0x0c, 0x7e, 0x12, 0x42, 0x60, 0x42, 0x3e, 0xfa, 0x00, 0x4a, 0x7f, 0x4a, 0x10, 0x7a, 0x10, 0x42, 0x3e, 0x4c, 0x22, 0x40, 0x02, 0x41, 0x02, 0x41, 0x0c, 0x3f, 0x00, 0x00 },
{ 0xf8, 0xd3, 0x00, 0x80, 0x00, 0x80, 0x79, 0xfe, 0x49, 0x02, 0x4a, 0x02, 0x4b, 0xf2, 0x4d, 0x12, 0x49, 0x12, 0x49, 0xf2, 0x49, 0x02, 0x79, 0x1c, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0xff, 0x00, 0x00 },
{ 0xf8, 0xd4, 0x00, 0x24, 0x00, 0x22, 0x7b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x49, 0xfe, 0x49, 0x22, 0x49, 0x22, 0x49, 0xfe, 0x49, 0x22, 0x49, 0x22, 0x79, 0xfe, 0x01, 0x22, 0x01, 0x22, 0x01, 0x26, 0x00, 0x00 },
{ 0xf8, 0xd5, 0x7f, 0xfe, 0x40, 0x02, 0x41, 0x22, 0x5f, 0xfa, 0x41, 0x02, 0x4f, 0xf2, 0x49, 0x12, 0x4f, 0xf2, 0x49, 0x12, 0x4f, 0xf2, 0x49, 0x12, 0x49, 0x12, 0x49, 0x72, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xf8, 0xd6, 0x01, 0x00, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x04, 0x80, 0x04, 0x80, 0x08, 0x80, 0x1f, 0xfc, 0x28, 0x84, 0x48, 0x84, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x08, 0x9c, 0x00, 0x80, 0x00, 0x00 },
{ 0xf8, 0xd7, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x58, 0x40, 0x54, 0x50, 0x54, 0x90, 0x50, 0x90, 0x11, 0xfe, 0x12, 0x92, 0x14, 0x92, 0x10, 0x92, 0x10, 0x92, 0x10, 0x96, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf8, 0xd8, 0x11, 0x08, 0x11, 0x08, 0x11, 0x08, 0x13, 0xc8, 0x7d, 0x5e, 0x11, 0x4a, 0x11, 0x4a, 0x11, 0x4a, 0x1d, 0x4a, 0x71, 0x4a, 0x11, 0x52, 0x11, 0x54, 0x12, 0x41, 0x12, 0x41, 0x34, 0x3f, 0x00, 0x00 },
{ 0xf8, 0xd9, 0x10, 0x80, 0x10, 0x80, 0x11, 0xfe, 0x7d, 0x02, 0x12, 0x02, 0x11, 0xf2, 0x11, 0x12, 0x1d, 0x12, 0x71, 0x12, 0x11, 0xf2, 0x11, 0x02, 0x11, 0x1c, 0x11, 0x01, 0x11, 0x01, 0x30, 0xff, 0x00, 0x00 },
{ 0xf8, 0xda, 0x10, 0x24, 0x10, 0x22, 0x13, 0xff, 0x7c, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x11, 0x22, 0x1d, 0xfe, 0x71, 0x22, 0x11, 0x22, 0x11, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x11, 0x22, 0x31, 0x2e, 0x00, 0x00 },
{ 0xf8, 0xdb, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x90, 0x1a, 0xac, 0x60, 0xe3, 0x06, 0x90, 0x19, 0x88, 0x00, 0x00 },
{ 0xf8, 0xdc, 0x21, 0x00, 0x11, 0x00, 0x0b, 0xfe, 0x02, 0x02, 0x44, 0x02, 0x21, 0xf2, 0x11, 0x12, 0x01, 0x12, 0x01, 0x12, 0x11, 0xf2, 0x11, 0x02, 0x21, 0x1c, 0x21, 0x01, 0x41, 0x01, 0x40, 0xff, 0x00, 0x00 },
{ 0xf8, 0xdd, 0x20, 0x24, 0x10, 0x22, 0x0b, 0xff, 0x00, 0x20, 0x43, 0xfe, 0x22, 0x22, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x12, 0x22, 0x13, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x42, 0x22, 0x42, 0x2e, 0x00, 0x00 },
{ 0xf8, 0xde, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x80, 0x50, 0x80, 0x31, 0xfe, 0x12, 0x02, 0x15, 0xf2, 0x31, 0x12, 0x51, 0x12, 0x11, 0xf2, 0x11, 0x0c, 0x21, 0x01, 0x21, 0x01, 0x40, 0xff, 0x00, 0x00 },
{ 0xf8, 0xdf, 0x00, 0x80, 0x7c, 0x80, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x22, 0xf2, 0x3c, 0x92, 0x24, 0x92, 0x64, 0x92, 0x24, 0xf2, 0x24, 0x82, 0x24, 0x8c, 0x3c, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xf8, 0xe0, 0x00, 0x40, 0x3c, 0x40, 0x24, 0xfe, 0x24, 0x82, 0x25, 0x02, 0x3e, 0xf2, 0x24, 0x92, 0x24, 0x92, 0x24, 0x92, 0x3c, 0xf2, 0x24, 0x82, 0x24, 0x8c, 0x24, 0x81, 0x44, 0x81, 0x4c, 0x7f, 0x00, 0x00 },
{ 0xf8, 0xe1, 0x00, 0x14, 0x3c, 0x12, 0x25, 0xff, 0x24, 0x10, 0x24, 0xfe, 0x3c, 0x92, 0x24, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x3c, 0x92, 0x24, 0xfe, 0x24, 0x92, 0x24, 0x92, 0x44, 0x92, 0x4c, 0x96, 0x00, 0x00 },
{ 0xf8, 0xe2, 0x04, 0x20, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x10, 0x00, 0x1f, 0xfc, 0x20, 0x04, 0x2f, 0xc4, 0x48, 0x44, 0x08, 0x44, 0x0f, 0xc4, 0x08, 0x18, 0x08, 0x02, 0x08, 0x02, 0x07, 0xfe, 0x00, 0x00 },
{ 0xf8, 0xe3, 0x04, 0x10, 0x7f, 0xff, 0x14, 0x10, 0x1f, 0xff, 0x21, 0x21, 0x3f, 0xf9, 0x41, 0x01, 0x1f, 0xf1, 0x11, 0x11, 0x1f, 0xf1, 0x11, 0x11, 0x1f, 0xf1, 0x11, 0x11, 0x11, 0x31, 0x00, 0x06, 0x00, 0x00 },
{ 0xf8, 0xe4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x04, 0x20, 0x22, 0x17, 0xff, 0x40, 0x20, 0x23, 0xfe, 0x02, 0x22, 0x13, 0xfe, 0x12, 0x22, 0x23, 0xfe, 0x22, 0x22, 0x42, 0x22, 0x42, 0x26, 0x00, 0x00 },
{ 0xf8, 0xe5, 0x10, 0x80, 0x10, 0x80, 0x11, 0xfe, 0x7d, 0x02, 0x06, 0x02, 0x08, 0xf2, 0x08, 0x92, 0x10, 0x92, 0x34, 0x92, 0x58, 0xf2, 0x14, 0x82, 0x10, 0x8c, 0x10, 0x81, 0x10, 0x81, 0x10, 0x7f, 0x00, 0x00 },
{ 0xf8, 0xe6, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x09, 0xfc, 0x09, 0x04, 0x11, 0xfc, 0x30, 0x20, 0x57, 0xff, 0x11, 0x24, 0x10, 0xa2, 0x03, 0x42, 0x0c, 0x24, 0x74, 0x18, 0x05, 0xcc, 0x3e, 0x03, 0x00, 0x00 },
{ 0xf8, 0xe7, 0x20, 0x24, 0x10, 0x22, 0x03, 0xff, 0x40, 0x20, 0x20, 0x20, 0x01, 0xfe, 0x01, 0x22, 0x01, 0xfe, 0x71, 0x22, 0x11, 0xfe, 0x11, 0x22, 0x11, 0x22, 0x11, 0x2e, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf8, 0xe8, 0x08, 0x0a, 0x14, 0x09, 0x22, 0x7f, 0x40, 0x08, 0x3e, 0x08, 0x08, 0x7f, 0x08, 0x49, 0x7e, 0x7f, 0x08, 0x49, 0x4a, 0x49, 0x2a, 0x7f, 0x28, 0x49, 0x08, 0x49, 0x0e, 0x49, 0x70, 0x4b, 0x00, 0x00 },
{ 0xf8, 0xe9, 0x08, 0x40, 0x14, 0x40, 0x22, 0xff, 0x5c, 0x81, 0x01, 0x01, 0x3f, 0x79, 0x22, 0x49, 0x3e, 0x49, 0x22, 0x79, 0x3e, 0x41, 0x20, 0x46, 0x3e, 0x40, 0x20, 0x41, 0x3e, 0x41, 0x20, 0x3f, 0x00, 0x00 },
{ 0xf8, 0xea, 0x10, 0x20, 0x1c, 0x20, 0x24, 0x7f, 0x28, 0x41, 0x7e, 0x81, 0x2b, 0x79, 0x2a, 0x49, 0x3e, 0x49, 0x2a, 0x79, 0x2a, 0x41, 0x3e, 0x46, 0x00, 0x40, 0x2a, 0x41, 0x2a, 0x41, 0x40, 0x3f, 0x00, 0x00 },
{ 0xf8, 0xeb, 0x10, 0x00, 0x11, 0xff, 0x10, 0x00, 0x7c, 0xfe, 0x54, 0x82, 0x54, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x55, 0xff, 0x55, 0x11, 0x5d, 0x11, 0x11, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x00, 0x00 },
{ 0xf8, 0xec, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x02, 0x20, 0x3f, 0xfe, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x90, 0x0c, 0x98, 0x12, 0xa4, 0x62, 0xa3, 0x1d, 0x98, 0x00, 0x00 },
{ 0xf8, 0xed, 0x00, 0x00, 0x01, 0xfc, 0x79, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x48, 0x88, 0x7b, 0xfe, 0x48, 0x88, 0x4f, 0xff, 0x49, 0x24, 0x4a, 0xaa, 0x7c, 0xa9, 0x03, 0x26, 0x00, 0x60, 0x00, 0x00 },
{ 0xf8, 0xee, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x02, 0x23, 0xfe, 0x10, 0x88, 0x03, 0xfe, 0x00, 0x88, 0x17, 0xff, 0x10, 0x88, 0x21, 0x24, 0x26, 0xab, 0x40, 0xac, 0x43, 0x62, 0x00, 0x00 },
{ 0xf8, 0xef, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x55, 0xfc, 0x59, 0x04, 0x51, 0xfc, 0x50, 0x88, 0x13, 0xfe, 0x10, 0x88, 0x17, 0xff, 0x29, 0x24, 0x26, 0xaa, 0x24, 0xa9, 0x43, 0x26, 0x40, 0x60, 0x00, 0x00 },
{ 0xf8, 0xf0, 0x10, 0x00, 0x11, 0xff, 0x7c, 0x00, 0x10, 0xfe, 0x7c, 0x82, 0x54, 0x82, 0x7c, 0xfe, 0x54, 0x00, 0x55, 0xff, 0x7d, 0x11, 0x11, 0x11, 0x11, 0xff, 0x7d, 0x11, 0x11, 0x11, 0x11, 0xff, 0x00, 0x00 },
{ 0xf8, 0xf1, 0x08, 0x20, 0x08, 0x20, 0x0b, 0xff, 0x10, 0x20, 0x11, 0xfe, 0x30, 0x20, 0x30, 0x20, 0x57, 0xff, 0x10, 0x50, 0x10, 0x91, 0x11, 0x92, 0x16, 0x8c, 0x10, 0x88, 0x10, 0xf4, 0x13, 0x83, 0x00, 0x00 },
{ 0xf8, 0xf2, 0x00, 0x01, 0x7f, 0xc1, 0x0a, 0x09, 0x3f, 0x89, 0x2a, 0x89, 0x2a, 0x89, 0x3f, 0x89, 0x00, 0x09, 0x3f, 0x89, 0x00, 0x09, 0x7f, 0xc9, 0x04, 0x01, 0x24, 0x81, 0x24, 0x41, 0x4c, 0x47, 0x00, 0x00 },
{ 0xf8, 0xf3, 0x04, 0x00, 0x04, 0x01, 0x07, 0xc2, 0x04, 0x0c, 0x3f, 0xd0, 0x24, 0x41, 0x27, 0x02, 0x3c, 0x0c, 0x24, 0x90, 0x27, 0x81, 0x20, 0x02, 0x25, 0x0c, 0x45, 0x31, 0x49, 0x01, 0x50, 0xff, 0x00, 0x00 },
{ 0xf8, 0xf4, 0x10, 0x00, 0x13, 0xff, 0x10, 0x50, 0x59, 0xfe, 0x55, 0x52, 0x55, 0x52, 0x51, 0xfe, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x11, 0x24, 0x11, 0x24, 0x12, 0x62, 0x00, 0x00 },
{ 0xf8, 0xf5, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x7c, 0xff, 0x10, 0x81, 0x11, 0x01, 0x3a, 0x01, 0x38, 0x01, 0x34, 0xf9, 0x54, 0x01, 0x50, 0x01, 0x50, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xf8, 0xf6, 0x10, 0x00, 0x13, 0xff, 0x10, 0x50, 0x7d, 0xfe, 0x11, 0x52, 0x11, 0x52, 0x39, 0xfe, 0x38, 0x00, 0x34, 0xfc, 0x54, 0x00, 0x53, 0xff, 0x50, 0x20, 0x11, 0x24, 0x11, 0x22, 0x12, 0x62, 0x00, 0x00 },
{ 0xf8, 0xf7, 0x20, 0x00, 0x17, 0xff, 0x08, 0x50, 0x03, 0xfe, 0x42, 0x52, 0x22, 0x52, 0x13, 0xfe, 0x00, 0x00, 0x01, 0xfc, 0x10, 0x00, 0x17, 0xff, 0x20, 0x20, 0x21, 0x26, 0x46, 0x21, 0x40, 0xe0, 0x00, 0x00 },
{ 0xf8, 0xf8, 0x00, 0x02, 0x7f, 0x0c, 0x14, 0x74, 0x7f, 0x54, 0x55, 0x54, 0x55, 0x54, 0x7f, 0x54, 0x00, 0x54, 0x3e, 0x52, 0x00, 0x52, 0x7f, 0x52, 0x08, 0x52, 0x2a, 0x95, 0x48, 0x9d, 0x19, 0x65, 0x00, 0x00 },
{ 0xf8, 0xf9, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x3f, 0xfe, 0x22, 0x22, 0x22, 0x22, 0x3f, 0xfe, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x8c, 0x10, 0x82, 0x60, 0x81, 0x03, 0x80, 0x00, 0x00 },
{ 0xf8, 0xfa, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x42, 0x04, 0x24, 0x1c, 0x28, 0x64, 0x10, 0x05, 0xcc, 0x3e, 0x03, 0x00, 0x00 },
{ 0xf8, 0xfb, 0x08, 0x20, 0x10, 0x20, 0x6a, 0x20, 0x04, 0x7f, 0x28, 0x41, 0x10, 0x81, 0x69, 0x01, 0x08, 0x01, 0x14, 0x7d, 0x64, 0x01, 0x0c, 0x01, 0x14, 0x01, 0x64, 0x02, 0x04, 0x02, 0x18, 0x1c, 0x00, 0x00 },
{ 0xf8, 0xfc, 0x00, 0x0a, 0x3f, 0x09, 0x21, 0x7f, 0x27, 0x08, 0x39, 0x14, 0x29, 0x63, 0x3f, 0x00, 0x2b, 0x35, 0x2b, 0x2d, 0x3f, 0xff, 0x29, 0x24, 0x28, 0x5a, 0x2a, 0x91, 0x4e, 0x41, 0x52, 0x3f, 0x00, 0x00 },
{ 0xf8, 0xfd, 0x00, 0x00, 0x7f, 0xfc, 0x15, 0x04, 0x15, 0x14, 0x7f, 0xe4, 0x55, 0x44, 0x7f, 0xf4, 0x01, 0x54, 0x3d, 0x54, 0x01, 0xf4, 0x7f, 0x44, 0x09, 0x45, 0x2b, 0x55, 0x49, 0x73, 0x1a, 0xd1, 0x00, 0x00 },
{ 0xf8, 0xfe, 0x00, 0x00, 0x3e, 0xff, 0x28, 0x28, 0x3e, 0xff, 0x28, 0xa9, 0x3e, 0xa9, 0x28, 0xff, 0x28, 0x00, 0x3e, 0x7e, 0x02, 0x00, 0x52, 0xff, 0x52, 0x10, 0x44, 0x92, 0x05, 0x11, 0x18, 0x30, 0x00, 0x00 },
{ 0xf9, 0xa1, 0x0f, 0xf0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x7e, 0x00, 0x00 },
{ 0xf9, 0xa2, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x24, 0x13, 0xe4, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x08, 0x0f, 0xf0, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xf9, 0xa3, 0x10, 0x00, 0x13, 0xfc, 0x12, 0x04, 0x7a, 0x34, 0x13, 0xc4, 0x12, 0x84, 0x3b, 0xf4, 0x36, 0x94, 0x32, 0x94, 0x53, 0xf4, 0x52, 0x84, 0x12, 0xa4, 0x14, 0xf5, 0x15, 0x95, 0x14, 0x03, 0x00, 0x00 },
{ 0xf9, 0xa4, 0x00, 0x00, 0x3d, 0xfc, 0x01, 0x04, 0x7f, 0x34, 0x01, 0xc4, 0x3d, 0x44, 0x01, 0xf4, 0x3d, 0x54, 0x01, 0x54, 0x01, 0xf4, 0x3d, 0x44, 0x25, 0x54, 0x25, 0xed, 0x26, 0x05, 0x3e, 0x03, 0x00, 0x00 },
{ 0xf9, 0xa5, 0x02, 0x20, 0x1f, 0xfc, 0x12, 0x24, 0x1f, 0xfc, 0x12, 0x24, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf9, 0xa6, 0x3f, 0xf8, 0x20, 0x08, 0x20, 0xe8, 0x2f, 0x08, 0x21, 0x08, 0x2f, 0xe8, 0x29, 0x28, 0x29, 0x28, 0x29, 0x28, 0x2f, 0xe4, 0x21, 0x04, 0x21, 0x25, 0x41, 0xe5, 0x5e, 0x13, 0x40, 0x11, 0x00, 0x00 },
{ 0xf9, 0xa7, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x20, 0x03, 0xfc, 0x02, 0x20, 0x03, 0xfc, 0x02, 0x20, 0x0a, 0x20, 0x0b, 0xfe, 0x10, 0x02, 0x10, 0x12, 0x25, 0x4a, 0x44, 0xa4, 0x08, 0x84, 0x00, 0x18, 0x00, 0x00 },
{ 0xf9, 0xa8, 0x08, 0x10, 0x08, 0x10, 0x10, 0x10, 0x21, 0xff, 0x49, 0x11, 0x09, 0x12, 0x11, 0x10, 0x11, 0xfe, 0x31, 0x42, 0x51, 0x42, 0x11, 0x24, 0x11, 0x18, 0x12, 0x18, 0x12, 0x24, 0x14, 0xc3, 0x00, 0x00 },
{ 0xf9, 0xa9, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x11, 0x11, 0x11, 0x12, 0x11, 0x10, 0x1d, 0xfe, 0x71, 0x42, 0x11, 0x42, 0x11, 0x24, 0x11, 0x18, 0x12, 0x18, 0x12, 0x24, 0x34, 0xc3, 0x00, 0x00 },
{ 0xf9, 0xaa, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x50, 0x20, 0x33, 0xfe, 0x12, 0x22, 0x12, 0x24, 0x33, 0xfc, 0x52, 0x84, 0x12, 0x48, 0x12, 0x30, 0x24, 0x30, 0x24, 0xcc, 0x4b, 0x03, 0x00, 0x00 },
{ 0xf9, 0xab, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x41, 0x10, 0x42, 0x10, 0x40, 0x1f, 0xfc, 0x12, 0x04, 0x11, 0x08, 0x11, 0x08, 0x10, 0x90, 0x10, 0x60, 0x20, 0x60, 0x21, 0x98, 0x46, 0x07, 0x00, 0x00 },
{ 0xf9, 0xac, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x05, 0x11, 0x09, 0x12, 0x09, 0x10, 0x11, 0xfe, 0x35, 0x42, 0x59, 0x44, 0x15, 0x24, 0x11, 0x18, 0x12, 0x18, 0x12, 0x24, 0x14, 0xc3, 0x00, 0x00 },
{ 0xf9, 0xad, 0x20, 0x04, 0x13, 0xc4, 0x0a, 0x5f, 0x42, 0x40, 0x23, 0xc9, 0x12, 0x0a, 0x02, 0x1f, 0x07, 0xc4, 0x76, 0x44, 0x1a, 0x5f, 0x12, 0x44, 0x13, 0xc4, 0x10, 0x04, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf9, 0xae, 0x7c, 0x10, 0x44, 0x10, 0x45, 0xff, 0x49, 0x11, 0x49, 0x12, 0x51, 0x10, 0x49, 0xfe, 0x49, 0x42, 0x45, 0x42, 0x45, 0x24, 0x45, 0x24, 0x59, 0x18, 0x42, 0x18, 0x42, 0x24, 0x44, 0xc3, 0x00, 0x00 },
{ 0xf9, 0xaf, 0x00, 0x00, 0x7f, 0xfe, 0x42, 0x40, 0x42, 0x40, 0x42, 0x40, 0x42, 0x40, 0x44, 0x40, 0x44, 0x44, 0x48, 0x44, 0x50, 0x44, 0x60, 0x7c, 0x40, 0x00, 0x40, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00 },
{ 0xf9, 0xb0, 0x00, 0x00, 0x7b, 0xef, 0x08, 0x81, 0x09, 0x01, 0x0b, 0xe1, 0x3a, 0x27, 0x22, 0x24, 0x22, 0x24, 0x7b, 0xef, 0x4a, 0x29, 0x0a, 0x21, 0x0a, 0x21, 0x0a, 0x21, 0x0b, 0xe1, 0x30, 0x06, 0x00, 0x00 },
{ 0xf9, 0xb1, 0x02, 0x00, 0x01, 0x04, 0x00, 0x84, 0x00, 0x08, 0x02, 0x08, 0x02, 0x10, 0x12, 0x10, 0x12, 0x20, 0x12, 0x44, 0x22, 0x82, 0x23, 0x01, 0x42, 0x01, 0x06, 0x04, 0x1a, 0x04, 0x61, 0xfc, 0x00, 0x00 },
{ 0xf9, 0xb2, 0x20, 0x80, 0x10, 0x48, 0x00, 0x28, 0x40, 0x88, 0x20, 0x90, 0x00, 0x90, 0x02, 0xa4, 0x12, 0xa2, 0x12, 0xc1, 0x24, 0xc1, 0x20, 0x84, 0x41, 0x84, 0x42, 0x84, 0x44, 0x7c, 0x00, 0x00, 0x00, 0x00 },
{ 0xf9, 0xb3, 0x00, 0x80, 0x7c, 0x44, 0x10, 0x28, 0x10, 0x88, 0x10, 0x90, 0x7c, 0x90, 0x12, 0xa4, 0x12, 0xa2, 0x12, 0xc1, 0x14, 0xc1, 0x1c, 0x84, 0x71, 0x84, 0x02, 0x84, 0x04, 0x7c, 0x00, 0x00, 0x00, 0x00 },
{ 0xf9, 0xb4, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf9, 0xb5, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x82, 0x00, 0x84, 0x00, 0x88, 0x00, 0x80, 0x10, 0x80, 0x10, 0xfc, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x18, 0x80, 0x24, 0x80, 0x23, 0x80, 0x40, 0xff, 0x00, 0x00 },
{ 0xf9, 0xb6, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf9, 0xb7, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x01, 0x00, 0x00, 0x88, 0x00, 0x48, 0x12, 0x12, 0x12, 0x21, 0x22, 0x41, 0x22, 0x81, 0x43, 0x04, 0x06, 0x04, 0x1a, 0x04, 0x61, 0xfc, 0x00, 0x00 },
{ 0xf9, 0xb8, 0x08, 0x40, 0x30, 0x20, 0x10, 0x14, 0x7e, 0x44, 0x10, 0x48, 0x38, 0x48, 0x55, 0x54, 0x11, 0x52, 0x7d, 0x61, 0x46, 0x61, 0x44, 0x44, 0x7c, 0xc4, 0x45, 0x44, 0x44, 0x3c, 0x7c, 0x00, 0x00, 0x00 },
{ 0xf9, 0xb9, 0x00, 0x1e, 0x3f, 0xe0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfc, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x08, 0x40, 0x09, 0x80, 0x16, 0x00, 0x23, 0x00, 0x40, 0xff, 0x00, 0x00 },
{ 0xf9, 0xba, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x00, 0x01, 0xfc, 0x41, 0x04, 0x21, 0xfc, 0x10, 0x00, 0x03, 0xfe, 0x02, 0x22, 0x73, 0xfe, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf9, 0xbb, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xc0, 0x00, 0xb0, 0x00, 0x88, 0x00, 0x84, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf9, 0xbc, 0x08, 0x00, 0x0b, 0xff, 0x08, 0x02, 0x10, 0x02, 0x10, 0x02, 0x31, 0xe2, 0x31, 0x22, 0x51, 0x22, 0x51, 0x22, 0x11, 0x22, 0x11, 0xe2, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x0e, 0x00, 0x00 },
{ 0xf9, 0xbd, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0xfe, 0x20, 0x80, 0x27, 0xfc, 0x24, 0x04, 0x27, 0xfc, 0x24, 0x04, 0x27, 0xfc, 0x21, 0x00, 0x21, 0xf8, 0x26, 0x08, 0x49, 0x10, 0x40, 0xe0, 0x4f, 0x1f, 0x00, 0x00 },
{ 0xf9, 0xbe, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x06, 0x10, 0x39, 0x20, 0x00, 0xc0, 0x07, 0x38, 0x78, 0x07, 0x00, 0x00 },
{ 0xf9, 0xbf, 0x00, 0x80, 0x3f, 0xff, 0x20, 0x00, 0x2f, 0xfe, 0x20, 0x80, 0x27, 0xf8, 0x24, 0x08, 0x27, 0xf8, 0x24, 0x08, 0x27, 0xf8, 0x21, 0x00, 0x23, 0xf8, 0x4d, 0x10, 0x40, 0xe0, 0x4f, 0x1e, 0x00, 0x00 },
{ 0xf9, 0xc0, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x04, 0xf8, 0x04, 0x80, 0x04, 0x80, 0x04, 0x80, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xc1, 0x20, 0x00, 0x13, 0xff, 0x08, 0x04, 0x00, 0x04, 0x40, 0x04, 0x23, 0xe4, 0x12, 0x24, 0x02, 0x24, 0x02, 0x24, 0x13, 0xe4, 0x10, 0x04, 0x20, 0x04, 0x20, 0x04, 0x40, 0x04, 0x40, 0x1c, 0x00, 0x00 },
{ 0xf9, 0xc2, 0x00, 0x00, 0x03, 0xdf, 0x7a, 0x41, 0x12, 0x41, 0x12, 0x41, 0x13, 0xdf, 0x7a, 0x00, 0x12, 0x00, 0x13, 0xdf, 0x12, 0x09, 0x12, 0x09, 0x1b, 0xca, 0x72, 0x04, 0x02, 0x0a, 0x02, 0x11, 0x00, 0x00 },
{ 0xf9, 0xc3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x00, 0x0b, 0xff, 0x10, 0x04, 0x10, 0x04, 0x33, 0xe4, 0x52, 0x24, 0x12, 0x24, 0x12, 0x24, 0x13, 0xe4, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xf9, 0xc4, 0x10, 0x00, 0x11, 0xef, 0x11, 0x21, 0x7d, 0x21, 0x55, 0x21, 0x55, 0xef, 0x55, 0x00, 0x55, 0x1f, 0x7d, 0xe9, 0x11, 0x09, 0x11, 0x0a, 0x15, 0xea, 0x15, 0x04, 0x1d, 0x0a, 0x65, 0x11, 0x00, 0x00 },
{ 0xf9, 0xc5, 0x08, 0x00, 0x7f, 0x3e, 0x09, 0x22, 0x11, 0x22, 0x26, 0x3e, 0x40, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xf9, 0xc6, 0x20, 0x00, 0x13, 0xde, 0x02, 0x42, 0x42, 0x42, 0x23, 0xde, 0x02, 0x00, 0x02, 0x1e, 0x03, 0xd2, 0x72, 0x12, 0x12, 0x0c, 0x13, 0xcc, 0x12, 0x12, 0x12, 0x21, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xf9, 0xc7, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x5e, 0xbd, 0x00, 0x00, 0x3f, 0x7e, 0x21, 0x02, 0x3f, 0x7e, 0x20, 0x00, 0x3f, 0x7e, 0x20, 0x22, 0x3f, 0x14, 0x20, 0x1c, 0x20, 0xe3, 0x00, 0x00 },
{ 0xf9, 0xc8, 0x10, 0x00, 0x1c, 0xf7, 0x24, 0x91, 0x28, 0x91, 0x7e, 0x91, 0x2a, 0xf7, 0x2a, 0x80, 0x3e, 0x80, 0x2a, 0xef, 0x2a, 0x89, 0x3e, 0x89, 0x00, 0xea, 0x2a, 0x84, 0x2a, 0x8a, 0x40, 0x91, 0x00, 0x00 },
{ 0xf9, 0xc9, 0x08, 0x00, 0x0f, 0x7e, 0x08, 0x22, 0x7f, 0xa2, 0x40, 0xa4, 0x1e, 0x14, 0x4c, 0x88, 0x12, 0x18, 0x7f, 0x24, 0x12, 0x43, 0x1e, 0x00, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf9, 0xca, 0x0d, 0x5c, 0x10, 0x84, 0x1d, 0x5c, 0x11, 0x44, 0x1c, 0x9c, 0x11, 0x44, 0x7f, 0xff, 0x40, 0x01, 0x47, 0xf1, 0x00, 0x20, 0x00, 0xc0, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xf9, 0xcb, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x1f, 0xff, 0x11, 0x01, 0x11, 0xfa, 0x17, 0x00, 0x11, 0x02, 0x10, 0xfe, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x00, 0x2f, 0xff, 0x22, 0x00, 0x43, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xcc, 0x00, 0x10, 0x3c, 0x1e, 0x00, 0x10, 0x7e, 0xff, 0x00, 0x91, 0x3c, 0x9d, 0x00, 0xf0, 0x3c, 0x92, 0x00, 0x9e, 0x00, 0x80, 0x3c, 0xbe, 0x25, 0x20, 0x25, 0x7f, 0x26, 0x20, 0x3c, 0x3e, 0x00, 0x00 },
{ 0xf9, 0xcd, 0x08, 0x10, 0x7f, 0x7e, 0x51, 0x42, 0x55, 0x7e, 0x14, 0x42, 0x3f, 0x7e, 0x28, 0x40, 0x7e, 0x7f, 0x28, 0x40, 0x28, 0x7f, 0x3e, 0x01, 0x28, 0xab, 0x28, 0xa9, 0x3f, 0x83, 0x00, 0x8e, 0x00, 0x00 },
{ 0xf9, 0xce, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x42, 0x21, 0x0f, 0xf8, 0x02, 0x20, 0x0f, 0xf8, 0x02, 0x20, 0x7f, 0xff, 0x04, 0x10, 0x09, 0x08, 0x10, 0x84, 0x60, 0x23, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00 },
{ 0xf9, 0xcf, 0x10, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x59, 0x02, 0x55, 0xfe, 0x55, 0x02, 0x51, 0x02, 0x11, 0xfe, 0x11, 0x20, 0x11, 0x21, 0x11, 0x12, 0x11, 0x14, 0x11, 0x08, 0x11, 0x74, 0x17, 0x83, 0x00, 0x00 },
{ 0xf9, 0xd0, 0x10, 0x00, 0x11, 0xfc, 0x19, 0x04, 0x55, 0xfc, 0x55, 0x04, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xf9, 0xd1, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf9, 0xd2, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x20, 0x00, 0x20, 0x40, 0x20, 0x20, 0x20, 0x10, 0x20, 0x07, 0xff, 0x00, 0x20, 0x10, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xf9, 0xd3, 0x20, 0x88, 0x17, 0xff, 0x08, 0x88, 0x00, 0xf8, 0x40, 0x20, 0x23, 0xfe, 0x12, 0x22, 0x03, 0xfe, 0x00, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x27, 0xff, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xf9, 0xd4, 0x21, 0x04, 0x11, 0x04, 0x07, 0xea, 0x01, 0x0a, 0x41, 0x11, 0x27, 0xd1, 0x14, 0x4e, 0x07, 0xc4, 0x04, 0x44, 0x17, 0xdf, 0x11, 0x04, 0x21, 0x04, 0x2f, 0xe4, 0x41, 0x04, 0x41, 0x04, 0x00, 0x00 },
{ 0xf9, 0xd5, 0x42, 0x08, 0x22, 0x14, 0x0f, 0xa2, 0x02, 0x00, 0x42, 0x7e, 0x2f, 0x92, 0x08, 0x92, 0x0f, 0xb6, 0x08, 0xda, 0x2f, 0x92, 0x22, 0x16, 0x22, 0x3a, 0x4f, 0xd2, 0x42, 0x12, 0x42, 0x36, 0x00, 0x00 },
{ 0xf9, 0xd6, 0x00, 0x00, 0x7f, 0xfe, 0x42, 0x42, 0x42, 0x42, 0x04, 0x44, 0x08, 0x3c, 0x30, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xf9, 0xd7, 0x10, 0x10, 0x10, 0x28, 0x7c, 0x44, 0x11, 0x83, 0x10, 0x00, 0x7d, 0xef, 0x44, 0x21, 0x7c, 0x63, 0x44, 0xa5, 0x7d, 0x29, 0x10, 0x63, 0x7c, 0xa5, 0x11, 0x29, 0x10, 0x21, 0x10, 0xe7, 0x00, 0x00 },
{ 0xf9, 0xd8, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x4f, 0xf2, 0x41, 0x02, 0x43, 0x82, 0x45, 0x42, 0x49, 0x32, 0x41, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf9, 0xd9, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x20, 0x02, 0x23, 0xe2, 0x22, 0x22, 0x23, 0xe2, 0x22, 0x22, 0x23, 0xe2, 0x22, 0x22, 0x22, 0x22, 0x24, 0x66, 0x00, 0x00 },
{ 0xf9, 0xda, 0x00, 0x00, 0x3e, 0xfe, 0x22, 0x82, 0x24, 0x82, 0x24, 0xfe, 0x28, 0x82, 0x24, 0x82, 0x22, 0xfe, 0x22, 0x90, 0x22, 0x91, 0x2c, 0x8a, 0x20, 0x8c, 0x20, 0xb4, 0x20, 0xc2, 0x23, 0x01, 0x00, 0x00 },
{ 0xf9, 0xdb, 0x10, 0x20, 0x10, 0xfc, 0x7c, 0x44, 0x10, 0x44, 0x11, 0xff, 0x7c, 0x00, 0x44, 0xfe, 0x7c, 0x82, 0x44, 0xfe, 0x7c, 0x10, 0x11, 0xfe, 0x10, 0x90, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xf9, 0xdc, 0x04, 0x01, 0x04, 0x01, 0x7f, 0xc9, 0x40, 0x49, 0x04, 0x09, 0x3f, 0x89, 0x04, 0x09, 0x3f, 0x89, 0x04, 0x09, 0x7f, 0xc9, 0x00, 0x09, 0x3f, 0x81, 0x20, 0x81, 0x20, 0x81, 0x3f, 0x87, 0x00, 0x00 },
{ 0xf9, 0xdd, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x11, 0x01, 0x7c, 0x10, 0x54, 0xfe, 0x7c, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xde, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x00, 0x02, 0x00, 0x03, 0x80, 0x24, 0x8a, 0x24, 0x92, 0x22, 0xa2, 0x20, 0x82, 0x22, 0xa2, 0x24, 0x92, 0x28, 0x8a, 0x23, 0x82, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xdf, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xf9, 0xe0, 0x00, 0x48, 0x00, 0x44, 0x3f, 0xff, 0x20, 0x40, 0x20, 0x40, 0x2f, 0x44, 0x20, 0x44, 0x20, 0x24, 0x2f, 0x28, 0x29, 0x28, 0x29, 0x10, 0x2f, 0x10, 0x40, 0x29, 0x40, 0xc5, 0x43, 0x03, 0x00, 0x00 },
{ 0xf9, 0xe1, 0x02, 0x00, 0x02, 0x00, 0x77, 0xde, 0x55, 0x12, 0x59, 0x12, 0x51, 0x12, 0x5f, 0xd2, 0x51, 0x12, 0x55, 0x12, 0x55, 0xd2, 0x75, 0x12, 0x05, 0x12, 0x05, 0xd6, 0x07, 0x10, 0x1c, 0x10, 0x00, 0x00 },
{ 0xf9, 0xe2, 0x00, 0x12, 0x00, 0x11, 0x70, 0x10, 0x57, 0xff, 0x54, 0x10, 0x54, 0x10, 0x55, 0xd2, 0x54, 0x12, 0x55, 0xd4, 0x55, 0x54, 0x75, 0x48, 0x05, 0xc9, 0x08, 0x15, 0x08, 0x23, 0x10, 0x41, 0x00, 0x00 },
{ 0xf9, 0xe3, 0x13, 0xe8, 0x12, 0x88, 0x13, 0xc8, 0x7e, 0x5f, 0x13, 0xd0, 0x12, 0xa0, 0x32, 0x80, 0x3b, 0xef, 0x34, 0x00, 0x50, 0x00, 0x53, 0xfe, 0x52, 0x52, 0x12, 0x52, 0x12, 0x52, 0x17, 0xff, 0x00, 0x00 },
{ 0xf9, 0xe4, 0x20, 0x00, 0x13, 0xfe, 0x08, 0x40, 0x00, 0x40, 0x40, 0x80, 0x24, 0xe2, 0x14, 0xaa, 0x05, 0x32, 0x04, 0xa2, 0x14, 0x72, 0x14, 0xaa, 0x25, 0x22, 0x24, 0xe2, 0x44, 0x02, 0x47, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xe5, 0x10, 0x0a, 0x10, 0x09, 0x24, 0x08, 0x45, 0xff, 0x29, 0x08, 0x11, 0x08, 0x11, 0xea, 0x25, 0x0a, 0x7d, 0xea, 0x15, 0x2a, 0x51, 0x24, 0x55, 0xe4, 0x55, 0x0d, 0x12, 0x15, 0x12, 0x23, 0x00, 0x00 },
{ 0xf9, 0xe6, 0x10, 0x04, 0x21, 0xe4, 0x7d, 0x48, 0x45, 0xef, 0x55, 0x30, 0x55, 0xe0, 0x45, 0x40, 0x5d, 0x4f, 0x75, 0xe0, 0x54, 0x00, 0x54, 0xfe, 0x54, 0xaa, 0x44, 0xaa, 0x44, 0xaa, 0x4d, 0xff, 0x00, 0x00 },
{ 0xf9, 0xe7, 0x08, 0x80, 0x09, 0x4f, 0x12, 0x20, 0x24, 0x00, 0x4b, 0xe0, 0x08, 0x8f, 0x10, 0x82, 0x17, 0xf2, 0x30, 0x82, 0x54, 0xa2, 0x12, 0xa2, 0x12, 0xc2, 0x10, 0x82, 0x10, 0xf2, 0x17, 0x0e, 0x00, 0x00 },
{ 0xf9, 0xe8, 0x7c, 0x40, 0x44, 0x7e, 0x44, 0x42, 0x48, 0x82, 0x48, 0x82, 0x51, 0x1c, 0x48, 0x00, 0x48, 0x40, 0x45, 0x9e, 0x45, 0x02, 0x45, 0x02, 0x59, 0xde, 0x41, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xe9, 0x10, 0x0a, 0x10, 0x09, 0x1e, 0x08, 0x10, 0xff, 0x10, 0x88, 0x7e, 0x88, 0x4a, 0xea, 0x66, 0x8a, 0x5a, 0xea, 0x4a, 0xaa, 0x56, 0xa4, 0x62, 0xe4, 0x4a, 0x8d, 0x43, 0x15, 0x7f, 0x23, 0x00, 0x00 },
{ 0xf9, 0xea, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xf9, 0xeb, 0x00, 0x20, 0x00, 0x50, 0x78, 0x88, 0x49, 0x04, 0x4a, 0x02, 0x4c, 0x01, 0x49, 0xfc, 0x48, 0x00, 0x48, 0x00, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xf9, 0xec, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x1b, 0xec, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xf9, 0xed, 0x10, 0x10, 0x10, 0x28, 0x10, 0x44, 0x7c, 0x82, 0x55, 0x01, 0x54, 0x00, 0x54, 0xfe, 0x54, 0x00, 0x54, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x14, 0x82, 0x14, 0x82, 0x1a, 0x82, 0x62, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xee, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x41, 0x82, 0x42, 0x42, 0x44, 0x22, 0x5b, 0xda, 0x40, 0x02, 0x47, 0xe2, 0x44, 0x22, 0x44, 0x22, 0x47, 0xe2, 0x40, 0x0e, 0x00, 0x00 },
{ 0xf9, 0xef, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x41, 0x02, 0x4f, 0xf2, 0x41, 0x02, 0x5f, 0xfa, 0x44, 0x42, 0x4f, 0xf2, 0x4a, 0x92, 0x4a, 0x92, 0x5f, 0xfa, 0x40, 0x06, 0x00, 0x00 },
{ 0xf9, 0xf0, 0x7c, 0x20, 0x44, 0x20, 0x47, 0xff, 0x48, 0x20, 0x49, 0x24, 0x51, 0x24, 0x49, 0x24, 0x4a, 0xaa, 0x46, 0xb1, 0x44, 0x50, 0x44, 0x48, 0x58, 0x88, 0x41, 0x04, 0x42, 0x02, 0x44, 0x01, 0x00, 0x00 },
{ 0xf9, 0xf1, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x08, 0x20, 0x08, 0x21, 0x10, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xf9, 0xf2, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x17, 0xff, 0x30, 0x00, 0x30, 0x00, 0x50, 0xf8, 0x50, 0x88, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x11, 0x08, 0x11, 0x09, 0x12, 0x09, 0x14, 0x0f, 0x00, 0x00 },
{ 0xf9, 0xf3, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x00, 0x7c, 0x00, 0x24, 0xfc, 0x24, 0x84, 0x24, 0x84, 0x24, 0xfc, 0x44, 0x84, 0x68, 0x84, 0x58, 0xfc, 0x0c, 0x00, 0x12, 0x00, 0x23, 0xff, 0x40, 0x00, 0x00, 0x00 },
{ 0xf9, 0xf4, 0x10, 0x92, 0x10, 0x54, 0x11, 0xff, 0x7d, 0x01, 0x25, 0x7d, 0x24, 0x44, 0x24, 0x44, 0x24, 0x7c, 0x44, 0x10, 0x68, 0xfe, 0x58, 0x92, 0x08, 0x92, 0x14, 0x92, 0x22, 0x96, 0x40, 0x10, 0x00, 0x00 },
{ 0xf9, 0xf5, 0x04, 0x10, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x08, 0x17, 0xf4, 0x24, 0x12, 0x44, 0x11, 0x07, 0xf0, 0x04, 0x02, 0x04, 0x02, 0x03, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xf6, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x00, 0x58, 0x00, 0x55, 0xfe, 0x55, 0x02, 0x51, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x13, 0xff, 0x00, 0x00 },
{ 0xf9, 0xf7, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x7c, 0x10, 0x44, 0x1c, 0x44, 0x70, 0x44, 0x10, 0x44, 0x10, 0x44, 0x10, 0x85, 0x10, 0x85, 0x31, 0x07, 0x00, 0x00 },
{ 0xf9, 0xf8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x10, 0x00, 0x38, 0x7c, 0x38, 0x44, 0x34, 0x44, 0x54, 0x44, 0x50, 0x44, 0x50, 0x84, 0x10, 0x85, 0x11, 0x05, 0x12, 0x07, 0x00, 0x00 },
{ 0xf9, 0xf9, 0x10, 0x40, 0x10, 0x5f, 0x10, 0x80, 0x7d, 0x00, 0x12, 0x40, 0x10, 0x40, 0x38, 0x9f, 0x34, 0x84, 0x35, 0x84, 0x52, 0x84, 0x50, 0x84, 0x50, 0x84, 0x10, 0x84, 0x10, 0x84, 0x10, 0x8c, 0x00, 0x00 },
{ 0xf9, 0xfa, 0x40, 0x40, 0x20, 0x40, 0x17, 0xff, 0x00, 0x00, 0x40, 0x00, 0x21, 0xf8, 0x11, 0x08, 0x01, 0x08, 0x09, 0x08, 0x09, 0x08, 0x11, 0x08, 0x12, 0x09, 0x22, 0x09, 0x64, 0x09, 0x08, 0x0e, 0x00, 0x00 },
{ 0xf9, 0xfb, 0x20, 0x88, 0x10, 0x88, 0x0b, 0xfe, 0x00, 0x88, 0x40, 0x88, 0x27, 0xff, 0x11, 0x04, 0x02, 0x02, 0x05, 0xf9, 0x10, 0x08, 0x10, 0x08, 0x21, 0xf8, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xf9, 0xfc, 0x10, 0x00, 0x10, 0x00, 0x20, 0x7f, 0x3f, 0x08, 0x48, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x49, 0x08, 0x49, 0x08, 0x49, 0x08, 0x7f, 0x08, 0x00, 0x7f, 0x00, 0x00 },
{ 0xf9, 0xfd, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x44, 0x10, 0x4d, 0xff, 0x00, 0x00 },
{ 0xf9, 0xfe, 0x08, 0x10, 0x10, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x2a, 0x00, 0x2a, 0x00, 0x22, 0x7c, 0x27, 0x44, 0x7a, 0x44, 0x2a, 0x44, 0x2a, 0x44, 0x2a, 0x44, 0x22, 0x45, 0x42, 0x85, 0x46, 0x87, 0x00, 0x00 },
{ 0xfa, 0xa1, 0x08, 0x00, 0x11, 0xfe, 0x20, 0x00, 0x44, 0x00, 0x08, 0x00, 0x13, 0xff, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x70, 0x00, 0x00 },
{ 0xfa, 0xa2, 0x00, 0x40, 0x3c, 0x7e, 0x24, 0xc4, 0x25, 0x28, 0x28, 0x10, 0x28, 0x6c, 0x29, 0x93, 0x24, 0x10, 0x24, 0xfe, 0x24, 0x90, 0x24, 0x90, 0x3b, 0xff, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x00, 0x00 },
{ 0xfa, 0xa3, 0x00, 0x00, 0x01, 0xff, 0x00, 0x10, 0x7c, 0x20, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x1c, 0x82, 0x70, 0xfe, 0x00, 0x00, 0x00, 0x46, 0x01, 0x81, 0x00, 0x00 },
{ 0xfa, 0xa4, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x12, 0x10, 0x0c, 0x20, 0x02, 0x44, 0x01, 0x88, 0x03, 0x10, 0x0c, 0x20, 0x70, 0x60, 0x01, 0x98, 0x0e, 0x04, 0x70, 0x02, 0x00, 0x00 },
{ 0xfa, 0xa5, 0x0a, 0x10, 0x0a, 0x13, 0x13, 0xdc, 0x12, 0x10, 0x32, 0x10, 0x32, 0xd1, 0x57, 0x0f, 0x50, 0x20, 0x10, 0x40, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xfa, 0xa6, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xff, 0x48, 0x10, 0x49, 0x20, 0x48, 0xc2, 0x48, 0x44, 0x48, 0x28, 0x48, 0x10, 0x48, 0x62, 0x4b, 0x84, 0x78, 0x08, 0x00, 0x34, 0x00, 0xc2, 0x07, 0x01, 0x00, 0x00 },
{ 0xfa, 0xa7, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x7c, 0x40, 0x11, 0x84, 0x10, 0x88, 0x10, 0x50, 0x10, 0x22, 0x10, 0x44, 0x1d, 0x88, 0x72, 0x18, 0x00, 0x24, 0x00, 0xc2, 0x03, 0x01, 0x00, 0x00 },
{ 0xfa, 0xa8, 0x00, 0x1c, 0x0f, 0xe0, 0x11, 0x04, 0x10, 0x82, 0x21, 0x81, 0x4a, 0x20, 0x04, 0x48, 0x02, 0x84, 0x1f, 0xfa, 0x00, 0x82, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xfa, 0xa9, 0x00, 0x10, 0x7e, 0x10, 0x02, 0xff, 0x04, 0x10, 0x08, 0x20, 0x08, 0x40, 0x0a, 0x84, 0x0c, 0x48, 0x18, 0x30, 0x68, 0x22, 0x08, 0x44, 0x09, 0x88, 0x08, 0x14, 0x08, 0x62, 0x39, 0x81, 0x00, 0x00 },
{ 0xfa, 0xaa, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x81, 0x1f, 0xfc, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xfa, 0xab, 0x12, 0x00, 0x13, 0x9e, 0x14, 0x8a, 0x59, 0x0a, 0x57, 0xd2, 0x5d, 0x66, 0x55, 0x40, 0x17, 0xd4, 0x15, 0x5f, 0x15, 0x44, 0x17, 0xe4, 0x14, 0x5f, 0x14, 0x44, 0x14, 0x44, 0x18, 0xc4, 0x00, 0x00 },
{ 0xfa, 0xac, 0x11, 0x10, 0x11, 0x10, 0x11, 0xd3, 0x7d, 0x1c, 0x11, 0x10, 0x11, 0xd1, 0x3b, 0x0f, 0x38, 0x20, 0x34, 0x40, 0x55, 0xfe, 0x51, 0x02, 0x51, 0xfe, 0x11, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x00, 0x00 },
{ 0xfa, 0xad, 0x21, 0x00, 0x11, 0x00, 0x0b, 0xff, 0x02, 0x00, 0x44, 0x00, 0x21, 0xfc, 0x11, 0x24, 0x01, 0x24, 0x07, 0xff, 0x11, 0x24, 0x11, 0x24, 0x21, 0x24, 0x23, 0xff, 0x42, 0x04, 0x40, 0x38, 0x00, 0x00 },
{ 0xfa, 0xae, 0x21, 0x00, 0x11, 0xff, 0x09, 0x11, 0x43, 0xca, 0x24, 0x44, 0x12, 0x8a, 0x03, 0x31, 0x0c, 0x90, 0x17, 0x9e, 0x10, 0x90, 0x27, 0x9e, 0x20, 0x90, 0x47, 0x9e, 0x40, 0x90, 0x0f, 0xff, 0x00, 0x00 },
{ 0xfa, 0xaf, 0x10, 0x00, 0x1e, 0x7f, 0x24, 0x11, 0x7f, 0x27, 0x29, 0x68, 0x3f, 0x3e, 0x29, 0x48, 0x3f, 0x7f, 0x40, 0x88, 0x5f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x88, 0x00, 0xfe, 0x7f, 0x81, 0x00, 0x00 },
{ 0xfa, 0xb0, 0x10, 0x00, 0x1e, 0xfe, 0x12, 0x22, 0x24, 0x22, 0x3e, 0x42, 0x6a, 0x8c, 0x2a, 0x10, 0x3e, 0x50, 0x2a, 0x7e, 0x2a, 0x90, 0x3e, 0x10, 0x22, 0xff, 0x22, 0x10, 0x42, 0x10, 0x4e, 0x10, 0x00, 0x00 },
{ 0xfa, 0xb1, 0x00, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x7e, 0x10, 0x00, 0x20, 0x00, 0x42, 0x3c, 0x24, 0x00, 0x18, 0x3c, 0x11, 0x00, 0x62, 0x01, 0x84, 0x3c, 0x0c, 0x24, 0x12, 0x24, 0x61, 0x3d, 0x81, 0x00, 0x00 },
{ 0xfa, 0xb2, 0x00, 0x88, 0x3c, 0x88, 0x00, 0xe9, 0x7e, 0x8e, 0x00, 0x88, 0x3c, 0xa9, 0x01, 0xcf, 0x3c, 0x20, 0x00, 0x40, 0x00, 0xfe, 0x3c, 0x82, 0x24, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x3c, 0xfe, 0x00, 0x00 },
{ 0xfa, 0xb3, 0x21, 0x00, 0x11, 0xdf, 0x02, 0x49, 0x42, 0x89, 0x27, 0xe9, 0x02, 0xb3, 0x03, 0xe0, 0x02, 0xaa, 0x72, 0xaf, 0x13, 0xf2, 0x12, 0x2f, 0x14, 0x22, 0x14, 0x62, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfa, 0xb4, 0x00, 0x10, 0x3e, 0x10, 0x28, 0xff, 0x3e, 0x10, 0x28, 0x10, 0x3e, 0xa2, 0x28, 0x44, 0x28, 0x28, 0x3e, 0x11, 0x02, 0x22, 0x52, 0xc4, 0x52, 0x08, 0x44, 0x14, 0x04, 0x62, 0x19, 0x81, 0x00, 0x00 },
{ 0xfa, 0xb5, 0x00, 0x10, 0x3e, 0x10, 0x22, 0xff, 0x2e, 0x08, 0x2a, 0x10, 0x7f, 0x62, 0x41, 0x24, 0x3e, 0x18, 0x22, 0x11, 0x3e, 0x62, 0x22, 0x84, 0x3e, 0x0c, 0x22, 0x12, 0x22, 0x61, 0x26, 0x81, 0x00, 0x00 },
{ 0xfa, 0xb6, 0x08, 0x10, 0x08, 0x10, 0x7f, 0x7f, 0x08, 0x11, 0x10, 0x11, 0x22, 0x11, 0x12, 0x11, 0x0c, 0x11, 0x09, 0x11, 0x11, 0x21, 0x62, 0x21, 0x04, 0x21, 0x0a, 0x41, 0x11, 0x41, 0x60, 0x8e, 0x00, 0x00 },
{ 0xfa, 0xb7, 0x10, 0x10, 0x10, 0x10, 0x11, 0xff, 0x7c, 0x10, 0x10, 0x20, 0x10, 0xc2, 0x38, 0x44, 0x38, 0x28, 0x34, 0x11, 0x54, 0x22, 0x50, 0xc4, 0x53, 0x0c, 0x10, 0x12, 0x10, 0x61, 0x13, 0x81, 0x00, 0x00 },
{ 0xfa, 0xb8, 0x08, 0x20, 0x08, 0x20, 0x09, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x37, 0xff, 0x31, 0x04, 0x50, 0x88, 0x10, 0x90, 0x17, 0xff, 0x10, 0x20, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xfa, 0xb9, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x04, 0x10, 0x02, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xfa, 0xba, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x83, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xfa, 0xbb, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x08, 0x00, 0x11, 0xfe, 0x28, 0x00, 0x48, 0x00, 0x13, 0xff, 0x30, 0x10, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60, 0x00, 0x00 },
{ 0xfa, 0xbc, 0x08, 0x00, 0x09, 0xfe, 0x10, 0x00, 0x20, 0x00, 0x48, 0x00, 0x08, 0x00, 0x13, 0xff, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x38, 0x00, 0x00 },
{ 0xfa, 0xbd, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x30, 0x00, 0xc0, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xfa, 0xbe, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x7f, 0xfe, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x47, 0xe2, 0x44, 0x22, 0x44, 0x22, 0x44, 0x22, 0x47, 0xe2, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x00, 0x00 },
{ 0xfa, 0xbf, 0x21, 0x1e, 0x4b, 0xd2, 0x32, 0x52, 0x23, 0x54, 0x4b, 0xd4, 0x7a, 0x12, 0x13, 0x92, 0x22, 0x56, 0x43, 0xd0, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x02, 0x23, 0xe2, 0x22, 0x22, 0x23, 0xee, 0x00, 0x00 },
{ 0xfa, 0xc0, 0x00, 0x40, 0x7c, 0x40, 0x10, 0x80, 0x13, 0xfe, 0x12, 0x02, 0x7e, 0x02, 0x12, 0xf2, 0x12, 0x92, 0x12, 0x92, 0x12, 0x92, 0x1e, 0xf2, 0x72, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00 },
{ 0xfa, 0xc1, 0x10, 0x80, 0x11, 0x1f, 0x23, 0xd1, 0x2a, 0x52, 0x4a, 0x52, 0x2b, 0xd4, 0x12, 0x54, 0x12, 0x52, 0x2b, 0xd2, 0x7a, 0x11, 0x0a, 0x51, 0x13, 0x91, 0x12, 0x17, 0x22, 0x50, 0x41, 0xd0, 0x00, 0x00 },
{ 0xfa, 0xc2, 0x23, 0xef, 0x4a, 0x29, 0x33, 0xe9, 0x26, 0x0a, 0x7b, 0x89, 0x0a, 0x29, 0x11, 0xee, 0x60, 0x88, 0x1f, 0xfc, 0x04, 0x10, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xfa, 0xc3, 0x08, 0x10, 0x14, 0x10, 0x22, 0x20, 0x5c, 0xff, 0x00, 0x81, 0x3e, 0x81, 0x22, 0xbd, 0x3e, 0xa5, 0x22, 0xa5, 0x3e, 0xa5, 0x20, 0xa5, 0x3e, 0xbd, 0x20, 0x81, 0x3e, 0x81, 0x20, 0x87, 0x00, 0x00 },
{ 0xfa, 0xc4, 0x23, 0xef, 0x4a, 0x29, 0x33, 0xea, 0x26, 0x09, 0x7b, 0xe9, 0x0a, 0x0e, 0x13, 0xe8, 0x61, 0xc0, 0x06, 0x30, 0x1f, 0xfc, 0x64, 0x13, 0x07, 0xf2, 0x04, 0x24, 0x07, 0x98, 0x3c, 0x06, 0x00, 0x00 },
{ 0xfa, 0xc5, 0x00, 0x3c, 0x1f, 0xc0, 0x00, 0x80, 0x7f, 0xff, 0x02, 0xa0, 0x04, 0x90, 0x18, 0x8c, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xfa, 0xc6, 0x00, 0x20, 0x00, 0x3e, 0x78, 0x20, 0x4b, 0xff, 0x4a, 0x41, 0x4b, 0xfc, 0x4a, 0x42, 0x4a, 0x7e, 0x4a, 0x00, 0x4a, 0x28, 0x7a, 0xaa, 0x02, 0xaa, 0x04, 0xee, 0x04, 0x28, 0x09, 0xff, 0x00, 0x00 },
{ 0xfa, 0xc7, 0x10, 0x20, 0x10, 0x3e, 0x10, 0x20, 0x13, 0xff, 0x7e, 0x21, 0x12, 0x3c, 0x13, 0xe1, 0x12, 0x3f, 0x12, 0x00, 0x12, 0x28, 0x1e, 0xaa, 0x72, 0xee, 0x04, 0x28, 0x04, 0x28, 0x0b, 0xff, 0x00, 0x00 },
{ 0xfa, 0xc8, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x1f, 0xff, 0x10, 0x81, 0x10, 0xfa, 0x17, 0x80, 0x10, 0x84, 0x10, 0x7c, 0x10, 0x00, 0x14, 0x92, 0x14, 0x92, 0x27, 0x9e, 0x20, 0x90, 0x4f, 0xff, 0x00, 0x00 },
{ 0xfa, 0xc9, 0x00, 0x40, 0x3c, 0x40, 0x00, 0x40, 0x7e, 0xfe, 0x00, 0x90, 0x3c, 0x90, 0x01, 0x10, 0x3c, 0x10, 0x01, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xfa, 0xca, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x81, 0x4f, 0xf9, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x1f, 0xfc, 0x12, 0x24, 0x1f, 0xfc, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xfa, 0xcb, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x7e, 0x21, 0x11, 0xfc, 0x10, 0x20, 0x39, 0xfc, 0x34, 0x20, 0x37, 0xff, 0x51, 0x54, 0x51, 0xfc, 0x10, 0x20, 0x12, 0x96, 0x12, 0x85, 0x14, 0x7d, 0x00, 0x00 },
{ 0xfa, 0xcc, 0x04, 0x08, 0x07, 0x88, 0x04, 0x0a, 0x3f, 0xc9, 0x24, 0x48, 0x27, 0xbf, 0x20, 0x08, 0x3f, 0xc8, 0x28, 0x88, 0x2f, 0x94, 0x20, 0x14, 0x2a, 0x94, 0x2f, 0xa2, 0x4a, 0xa2, 0x4a, 0xc1, 0x00, 0x00 },
{ 0xfa, 0xcd, 0x08, 0x00, 0x08, 0x00, 0x7f, 0xbe, 0x08, 0x08, 0x3f, 0x08, 0x29, 0x08, 0x3f, 0x08, 0x29, 0x7f, 0x29, 0x08, 0x3f, 0x08, 0x08, 0x08, 0x7f, 0x88, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00 },
{ 0xfa, 0xce, 0x00, 0x20, 0x3f, 0x20, 0x21, 0x20, 0x3f, 0x7f, 0x21, 0x51, 0x3f, 0x52, 0x10, 0x90, 0x3f, 0x10, 0x69, 0x10, 0x29, 0x28, 0x35, 0x28, 0x21, 0x24, 0x3d, 0x44, 0x01, 0x42, 0x06, 0x81, 0x00, 0x00 },
{ 0xfa, 0xcf, 0x7c, 0x30, 0x44, 0x48, 0x44, 0x84, 0x49, 0x02, 0x4a, 0xfd, 0x50, 0x00, 0x49, 0xde, 0x49, 0x52, 0x45, 0x52, 0x45, 0xde, 0x44, 0x00, 0x58, 0x84, 0x40, 0x84, 0x41, 0x4a, 0x46, 0x31, 0x00, 0x00 },
{ 0xfa, 0xd0, 0x00, 0x10, 0x3e, 0x28, 0x28, 0x44, 0x3f, 0x83, 0x28, 0x7c, 0x3e, 0x00, 0x28, 0xee, 0x28, 0xaa, 0x3e, 0xaa, 0x02, 0xee, 0x52, 0x00, 0x52, 0x44, 0x44, 0x44, 0x04, 0xaa, 0x19, 0x11, 0x00, 0x00 },
{ 0xfa, 0xd1, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x20, 0x12, 0x24, 0x12, 0x24, 0x24, 0x22, 0x44, 0xe1, 0x08, 0x00, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xfa, 0xd2, 0x10, 0x84, 0x10, 0x84, 0x17, 0xdf, 0x14, 0x84, 0x58, 0x84, 0x57, 0xff, 0x51, 0x4a, 0x53, 0x5b, 0x13, 0x5b, 0x15, 0x6b, 0x29, 0x6a, 0x29, 0x4a, 0x4a, 0x52, 0x42, 0x52, 0x04, 0x94, 0x00, 0x00 },
{ 0xfa, 0xd3, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x14, 0x14, 0x14, 0x14, 0x55, 0x55, 0x55, 0x55, 0x54, 0x55, 0x14, 0x95, 0x24, 0x24, 0x24, 0x24, 0x4c, 0x4c, 0x00, 0x00 },
{ 0xfa, 0xd4, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x07, 0xf0, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xfa, 0xd5, 0x08, 0x00, 0x09, 0xfe, 0x09, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x31, 0x02, 0x31, 0x02, 0x51, 0xfe, 0x51, 0x02, 0x11, 0x02, 0x11, 0xfe, 0x10, 0x48, 0x10, 0x49, 0x10, 0x89, 0x13, 0x07, 0x00, 0x00 },
{ 0xfa, 0xd6, 0x00, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x55, 0x04, 0x55, 0xfc, 0x55, 0x04, 0x55, 0x04, 0x55, 0xfc, 0x55, 0x04, 0x55, 0x04, 0x55, 0xfc, 0x7c, 0x50, 0x00, 0x51, 0x00, 0x91, 0x03, 0x0f, 0x00, 0x00 },
{ 0xfa, 0xd7, 0x00, 0x10, 0x7c, 0x10, 0x05, 0xff, 0x04, 0x10, 0x04, 0x10, 0x3c, 0x20, 0x20, 0xa4, 0x20, 0x44, 0x7c, 0x28, 0x44, 0x10, 0x04, 0x10, 0x04, 0x24, 0x04, 0x42, 0x04, 0x9d, 0x39, 0xe1, 0x00, 0x00 },
{ 0xfa, 0xd8, 0x00, 0x07, 0x2f, 0x78, 0x29, 0x12, 0x2f, 0x24, 0x29, 0x18, 0x2f, 0x11, 0x29, 0x7f, 0x3f, 0x88, 0x04, 0x2a, 0x15, 0x49, 0x25, 0x08, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xfa, 0xd9, 0x00, 0x00, 0x79, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x79, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x79, 0xfc, 0x00, 0x50, 0x00, 0x51, 0x00, 0x91, 0x03, 0x0f, 0x00, 0x00 },
{ 0xfa, 0xda, 0x20, 0x20, 0x10, 0x20, 0x08, 0x20, 0x43, 0xff, 0x20, 0x20, 0x10, 0x40, 0x02, 0x88, 0x01, 0x08, 0x10, 0x90, 0x10, 0xa0, 0x20, 0x24, 0x20, 0x42, 0x40, 0x9e, 0x47, 0xe1, 0x00, 0x00, 0x00, 0x00 },
{ 0xfa, 0xdb, 0x10, 0x20, 0x10, 0x20, 0x13, 0xff, 0x14, 0x00, 0x54, 0x20, 0x58, 0x24, 0x50, 0x44, 0x11, 0x48, 0x10, 0x88, 0x18, 0x50, 0x28, 0x20, 0x24, 0x24, 0x24, 0x42, 0x20, 0x8f, 0x43, 0xf1, 0x00, 0x00 },
{ 0xfa, 0xdc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x01, 0x08, 0x0a, 0x10, 0x04, 0x20, 0x02, 0x20, 0x01, 0x40, 0x00, 0x88, 0x01, 0x04, 0x02, 0x04, 0x04, 0x7a, 0x7f, 0x82, 0x00, 0x00 },
{ 0xfa, 0xdd, 0x00, 0x20, 0x7c, 0x20, 0x10, 0x20, 0x13, 0xff, 0x10, 0x20, 0x7c, 0x40, 0x12, 0x88, 0x11, 0x08, 0x10, 0x90, 0x10, 0x20, 0x1c, 0x24, 0x70, 0x42, 0x00, 0x9d, 0x07, 0xe1, 0x00, 0x00, 0x00, 0x00 },
{ 0xfa, 0xde, 0x00, 0x00, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x10, 0x48, 0x1c, 0x48, 0x70, 0x89, 0x01, 0x09, 0x06, 0x0f, 0x00, 0x00 },
{ 0xfa, 0xdf, 0x00, 0x20, 0x78, 0x20, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x78, 0x40, 0x4a, 0x84, 0x49, 0x08, 0x78, 0x90, 0x48, 0x60, 0x48, 0x24, 0x48, 0x42, 0x78, 0x86, 0x01, 0x39, 0x07, 0xc1, 0x00, 0x00 },
{ 0xfa, 0xe0, 0x00, 0x00, 0x79, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x79, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x79, 0xfc, 0x49, 0x04, 0x49, 0x04, 0x49, 0xfc, 0x78, 0x90, 0x00, 0x91, 0x01, 0x11, 0x06, 0x0f, 0x00, 0x00 },
{ 0xfa, 0xe1, 0x10, 0x10, 0x10, 0x10, 0x25, 0xff, 0x44, 0x10, 0x28, 0x20, 0x10, 0x22, 0x10, 0xc4, 0x24, 0x44, 0x7c, 0x28, 0x10, 0x10, 0x10, 0x10, 0x54, 0x22, 0x54, 0x42, 0x50, 0x9d, 0x11, 0xe1, 0x00, 0x00 },
{ 0xfa, 0xe2, 0x10, 0x40, 0x10, 0x40, 0x24, 0xff, 0x44, 0x81, 0x29, 0x01, 0x12, 0xf9, 0x10, 0x89, 0x24, 0x89, 0x7c, 0xf9, 0x10, 0x89, 0x54, 0x89, 0x54, 0xf9, 0x50, 0x02, 0x10, 0x02, 0x10, 0x1c, 0x00, 0x00 },
{ 0xfa, 0xe3, 0x00, 0x06, 0x1e, 0x78, 0x52, 0x10, 0x5e, 0x22, 0x52, 0x44, 0x5e, 0x28, 0x52, 0x14, 0x5e, 0x22, 0x40, 0x7d, 0x7f, 0x08, 0x08, 0x2a, 0x2a, 0x2a, 0x29, 0x49, 0x49, 0x49, 0x48, 0x08, 0x00, 0x00 },
{ 0xfa, 0xe4, 0x08, 0x10, 0x10, 0x10, 0x3e, 0xff, 0x22, 0x08, 0x2a, 0x10, 0x2a, 0x10, 0x22, 0x62, 0x27, 0x24, 0x7a, 0x14, 0x2a, 0x08, 0x2a, 0x10, 0x2a, 0x12, 0x22, 0x22, 0x42, 0x4d, 0x46, 0xf1, 0x00, 0x00 },
{ 0xfa, 0xe5, 0x08, 0x80, 0x08, 0x8f, 0x13, 0xf0, 0x20, 0x80, 0x49, 0x00, 0x09, 0x0f, 0x12, 0x22, 0x11, 0x42, 0x30, 0x82, 0x50, 0xa2, 0x11, 0x12, 0x12, 0x72, 0x17, 0x92, 0x10, 0x02, 0x10, 0x0e, 0x00, 0x00 },
{ 0xfa, 0xe6, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x21, 0x04, 0x21, 0x18, 0x21, 0x60, 0x3e, 0x00, 0x00 },
{ 0xfa, 0xe7, 0x00, 0x00, 0x7f, 0x7e, 0x48, 0x22, 0x7f, 0x22, 0x41, 0x14, 0x7f, 0x08, 0x48, 0x14, 0x48, 0x63, 0x7f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x08, 0x08, 0x70, 0x07, 0x00, 0x00 },
{ 0xfa, 0xe8, 0x08, 0x10, 0x14, 0x10, 0x22, 0xff, 0x40, 0x08, 0x3e, 0x10, 0x08, 0x10, 0x08, 0xa2, 0x7e, 0x44, 0x08, 0x24, 0x4a, 0x18, 0x2a, 0x10, 0x28, 0x14, 0x08, 0x22, 0x0e, 0x4f, 0x71, 0xf1, 0x00, 0x00 },
{ 0xfa, 0xe9, 0x00, 0x00, 0x3f, 0x7f, 0x21, 0x08, 0x3f, 0x10, 0x21, 0x3e, 0x3f, 0x22, 0x10, 0xbe, 0x21, 0x22, 0x4a, 0xbe, 0x31, 0x22, 0x2a, 0xa2, 0x7b, 0xbe, 0x00, 0x00, 0x2a, 0x94, 0x4a, 0x63, 0x00, 0x00 },
{ 0xfa, 0xea, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0xc0, 0x00, 0x83, 0x00, 0x9c, 0x03, 0xe0, 0x7c, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xfa, 0xeb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x01, 0xe0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x10, 0x08, 0x10, 0x08, 0x08, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x00, 0x00 },
{ 0xfa, 0xec, 0x00, 0x80, 0x01, 0x00, 0x02, 0x00, 0x1f, 0xfc, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfa, 0xed, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x04, 0x10, 0x78, 0x0f, 0x00, 0x00 },
{ 0xfa, 0xee, 0x20, 0x6c, 0x20, 0xd8, 0x20, 0x48, 0x7f, 0xff, 0x24, 0x48, 0x25, 0xfe, 0x24, 0x4a, 0x25, 0xff, 0x44, 0x4a, 0x69, 0xfe, 0x58, 0x48, 0x08, 0xcc, 0x15, 0x4a, 0x22, 0x49, 0x40, 0x48, 0x00, 0x00 },
{ 0xfa, 0xef, 0x08, 0x20, 0x08, 0x20, 0x08, 0x20, 0x13, 0xff, 0x10, 0x20, 0x31, 0x24, 0x31, 0x24, 0x51, 0x2a, 0x12, 0xa9, 0x14, 0x51, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x12, 0x02, 0x14, 0x01, 0x00, 0x00 },
{ 0xfa, 0xf0, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x22, 0x7c, 0x22, 0x10, 0x42, 0x11, 0x8c, 0x10, 0x00, 0x11, 0x04, 0x17, 0xdf, 0x11, 0x45, 0x11, 0x45, 0x12, 0x49, 0x12, 0x49, 0x15, 0x96, 0x00, 0x00 },
{ 0xfa, 0xf1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x14, 0x8a, 0x62, 0x91, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xfa, 0xf2, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x55, 0xff, 0x54, 0x20, 0x54, 0xa4, 0x54, 0xa4, 0x54, 0xa4, 0x55, 0x6a, 0x55, 0x29, 0x56, 0x50, 0x7c, 0x50, 0x00, 0x88, 0x01, 0x04, 0x06, 0x03, 0x00, 0x00 },
{ 0xfa, 0xf3, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x7d, 0xff, 0x10, 0x20, 0x11, 0x24, 0x11, 0x24, 0x1d, 0x24, 0x72, 0xaa, 0x12, 0x51, 0x10, 0x50, 0x10, 0x88, 0x11, 0x04, 0x12, 0x02, 0x34, 0x01, 0x00, 0x00 },
{ 0xfa, 0xf4, 0x20, 0x20, 0x10, 0x20, 0x0b, 0xff, 0x00, 0x20, 0x41, 0x24, 0x21, 0x24, 0x11, 0x24, 0x02, 0xaa, 0x04, 0x21, 0x10, 0x20, 0x10, 0x50, 0x20, 0x50, 0x20, 0x88, 0x41, 0x04, 0x46, 0x03, 0x00, 0x00 },
{ 0xfa, 0xf5, 0x04, 0x20, 0x44, 0x20, 0x28, 0x20, 0x13, 0xff, 0x30, 0x20, 0x51, 0x24, 0x09, 0x24, 0x0a, 0xaa, 0x1c, 0x21, 0x28, 0x20, 0x48, 0x50, 0x08, 0x50, 0x08, 0x88, 0x09, 0x04, 0x36, 0x03, 0x00, 0x00 },
{ 0xfa, 0xf6, 0x01, 0x00, 0x1f, 0xf8, 0x06, 0x08, 0x38, 0x30, 0x08, 0x08, 0x7f, 0x7f, 0x11, 0x11, 0x66, 0x66, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x1c, 0x00, 0x00 },
{ 0xfa, 0xf7, 0x00, 0x10, 0x3c, 0x10, 0x24, 0xfe, 0x24, 0x22, 0x24, 0x22, 0x3c, 0x42, 0x24, 0x8c, 0x24, 0x00, 0x24, 0x84, 0x3d, 0xef, 0x24, 0xa5, 0x24, 0xa5, 0x25, 0x29, 0x45, 0x29, 0x4e, 0xd6, 0x00, 0x00 },
{ 0xfa, 0xf8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x84, 0x08, 0x84, 0x08, 0x84, 0x15, 0x4a, 0x23, 0x51, 0x02, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xfa, 0xf9, 0x18, 0x10, 0x24, 0x10, 0x41, 0xff, 0x00, 0x10, 0x7c, 0x92, 0x10, 0x92, 0x10, 0x92, 0x7d, 0x55, 0x11, 0x55, 0x10, 0x28, 0x54, 0x28, 0x34, 0x44, 0x10, 0x44, 0x18, 0x82, 0x61, 0x01, 0x00, 0x00 },
{ 0xfa, 0xfa, 0x08, 0x00, 0x08, 0xff, 0x08, 0x08, 0x7f, 0x10, 0x08, 0x7e, 0x2a, 0x42, 0x2a, 0x7e, 0x5d, 0x42, 0x08, 0x7e, 0x08, 0x42, 0x08, 0x42, 0x14, 0x7e, 0x12, 0x00, 0x20, 0x66, 0x41, 0x81, 0x00, 0x00 },
{ 0xfa, 0xfb, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x0c, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xfa, 0xfc, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x04, 0x40, 0x04, 0x40, 0x08, 0x41, 0x10, 0x41, 0x60, 0x3f, 0x00, 0x00 },
{ 0xfa, 0xfd, 0x00, 0x01, 0x7f, 0xc1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x7f, 0xd1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x21, 0x01, 0x21, 0x01, 0x21, 0x01, 0x41, 0x07, 0x00, 0x00 },
{ 0xfa, 0xfe, 0x00, 0x02, 0x7f, 0x92, 0x12, 0x12, 0x12, 0x12, 0x7f, 0x92, 0x12, 0x12, 0x12, 0x12, 0x22, 0x02, 0x42, 0x8e, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfb, 0xa1, 0x00, 0x01, 0x7f, 0xc2, 0x11, 0x04, 0x11, 0x08, 0x11, 0x30, 0x11, 0x01, 0x7f, 0xc2, 0x11, 0x04, 0x11, 0x08, 0x11, 0x30, 0x11, 0x01, 0x21, 0x02, 0x21, 0x04, 0x21, 0x08, 0x41, 0x30, 0x00, 0x00 },
{ 0xfb, 0xa2, 0x20, 0x00, 0x13, 0xff, 0x0a, 0x01, 0x42, 0x01, 0x22, 0x01, 0x12, 0xf9, 0x02, 0x89, 0x02, 0x89, 0x02, 0x89, 0x12, 0xf9, 0x12, 0x01, 0x22, 0x01, 0x22, 0x01, 0x42, 0x01, 0x42, 0x07, 0x00, 0x00 },
{ 0xfb, 0xa3, 0x08, 0x10, 0x29, 0x52, 0x2a, 0x54, 0x14, 0x28, 0x12, 0x24, 0x22, 0x44, 0x7f, 0xfe, 0x40, 0x82, 0x40, 0x82, 0x1e, 0x88, 0x02, 0xd0, 0x04, 0xa0, 0x18, 0x98, 0x60, 0x86, 0x03, 0x80, 0x00, 0x00 },
{ 0xfb, 0xa4, 0x41, 0x04, 0x25, 0x55, 0x11, 0x04, 0x02, 0x8a, 0x4c, 0x51, 0x20, 0x00, 0x17, 0xff, 0x04, 0x01, 0x05, 0xfd, 0x04, 0x21, 0x10, 0x20, 0x11, 0xfc, 0x10, 0x28, 0x20, 0x24, 0x67, 0xff, 0x00, 0x00 },
{ 0xfb, 0xa5, 0x21, 0x04, 0x15, 0x45, 0x05, 0x55, 0x42, 0x8a, 0x24, 0x51, 0x00, 0x00, 0x07, 0xff, 0x04, 0x21, 0x14, 0x51, 0x11, 0x8c, 0x26, 0xfb, 0x20, 0x20, 0x41, 0xfc, 0x40, 0xa8, 0x07, 0xff, 0x00, 0x00 },
{ 0xfb, 0xa6, 0x10, 0x00, 0x11, 0xfe, 0x13, 0x02, 0x55, 0x02, 0x59, 0x7a, 0x51, 0x4a, 0x51, 0x4a, 0x11, 0x4a, 0x11, 0x4a, 0x11, 0x4a, 0x29, 0x7a, 0x25, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0x0e, 0x00, 0x00 },
{ 0xfb, 0xa7, 0x08, 0x10, 0x29, 0x52, 0x2a, 0x54, 0x14, 0x28, 0x12, 0x24, 0x22, 0x44, 0x7f, 0xfe, 0x40, 0x82, 0x40, 0x8a, 0x09, 0x48, 0x09, 0x50, 0x12, 0x20, 0x04, 0x10, 0x18, 0x0c, 0x60, 0x03, 0x00, 0x00 },
{ 0xfb, 0xa8, 0x00, 0x40, 0x7c, 0x8f, 0x11, 0x00, 0x11, 0x20, 0x12, 0x40, 0x7c, 0x40, 0x10, 0x8f, 0x10, 0x82, 0x11, 0x82, 0x12, 0x82, 0x1c, 0x82, 0x70, 0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x8e, 0x00, 0x00 },
{ 0xfb, 0xa9, 0x08, 0x10, 0x29, 0x52, 0x2a, 0x54, 0x14, 0x28, 0x12, 0x24, 0x22, 0x44, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x80, 0x00, 0x80, 0x0f, 0xf8, 0x00, 0xa0, 0x00, 0x90, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xaa, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x7f, 0x82, 0x12, 0x22, 0x12, 0x22, 0x12, 0x22, 0x7f, 0xa2, 0x12, 0x22, 0x12, 0x22, 0x12, 0x22, 0x22, 0x02, 0x22, 0x02, 0x42, 0x0e, 0x00, 0x00 },
{ 0xfb, 0xab, 0x08, 0x10, 0x29, 0x52, 0x4a, 0x94, 0x14, 0x28, 0x22, 0x44, 0x40, 0x82, 0x7f, 0xff, 0x40, 0x81, 0x4f, 0xf9, 0x08, 0x88, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x88, 0x00, 0xfc, 0x3f, 0x82, 0x00, 0x00 },
{ 0xfb, 0xac, 0x09, 0x00, 0x09, 0xcf, 0x12, 0x40, 0x20, 0x80, 0x4b, 0xe0, 0x0a, 0xaf, 0x13, 0xe2, 0x12, 0xa2, 0x32, 0xa2, 0x53, 0xe2, 0x10, 0x82, 0x17, 0xf2, 0x10, 0x82, 0x11, 0x42, 0x16, 0x26, 0x00, 0x00 },
{ 0xfb, 0xad, 0x20, 0x40, 0x10, 0x80, 0x03, 0xfe, 0x42, 0x02, 0x22, 0x02, 0x02, 0xf2, 0x02, 0x92, 0x02, 0x92, 0x72, 0xf2, 0x12, 0x02, 0x12, 0x02, 0x12, 0x0e, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfb, 0xae, 0x00, 0x00, 0x7f, 0xbe, 0x12, 0x22, 0x12, 0x22, 0x12, 0x24, 0x7f, 0xa4, 0x12, 0x24, 0x12, 0x22, 0x12, 0x22, 0x12, 0x22, 0x12, 0x22, 0x12, 0x2e, 0x22, 0x20, 0x22, 0x20, 0x42, 0x20, 0x00, 0x00 },
{ 0xfb, 0xaf, 0x08, 0x10, 0x29, 0x52, 0x2a, 0x54, 0x14, 0x28, 0x22, 0x44, 0x7f, 0xfe, 0x40, 0x82, 0x41, 0x42, 0x06, 0x30, 0x1b, 0xec, 0x60, 0x83, 0x0f, 0xf8, 0x04, 0x90, 0x02, 0xa0, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xb0, 0x08, 0x00, 0x7f, 0x3c, 0x08, 0x25, 0x3e, 0x7f, 0x2a, 0xa4, 0x3e, 0x18, 0x27, 0xe7, 0x40, 0x80, 0x7f, 0xff, 0x18, 0x8c, 0x6f, 0xfb, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xfb, 0xb1, 0x03, 0xc0, 0x04, 0x40, 0x04, 0x20, 0x08, 0x10, 0x10, 0x08, 0x20, 0x04, 0x4f, 0xf3, 0x02, 0x00, 0x02, 0x00, 0x07, 0xf0, 0x04, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00, 0x20, 0x01, 0xc0, 0x00, 0x00 },
{ 0xfb, 0xb2, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x0f, 0x7f, 0x78, 0x08, 0x08, 0x08, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x08, 0x7f, 0xff, 0x00, 0x08, 0x1f, 0xf8, 0x00, 0x00 },
{ 0xfb, 0xb3, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x88, 0x00, 0xf4, 0x3f, 0x02, 0x00, 0x80, 0x24, 0x42, 0x24, 0x11, 0x43, 0xf1, 0x00, 0x00 },
{ 0xfb, 0xb4, 0x08, 0x10, 0x7e, 0xfe, 0x08, 0x10, 0x3c, 0x7c, 0x0e, 0x10, 0x78, 0xfe, 0x08, 0x10, 0x1f, 0xfc, 0x00, 0x04, 0x7f, 0xff, 0x00, 0x04, 0x1f, 0xfc, 0x04, 0x82, 0x24, 0x49, 0x43, 0xf9, 0x00, 0x00 },
{ 0xfb, 0xb5, 0x00, 0x84, 0x00, 0x84, 0x7f, 0xdf, 0x48, 0x84, 0x4b, 0xdf, 0x48, 0x84, 0x78, 0xdf, 0x4b, 0x84, 0x48, 0x84, 0x48, 0xfe, 0x78, 0x02, 0x03, 0xff, 0x00, 0x02, 0x00, 0x02, 0x00, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xb6, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x7f, 0xff, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x88, 0x00, 0xf4, 0x3f, 0x82, 0x01, 0x00, 0x24, 0x94, 0x24, 0x12, 0x47, 0xe1, 0x00, 0x00 },
{ 0xfb, 0xb7, 0x00, 0x0e, 0x3e, 0xf0, 0x22, 0x92, 0x22, 0x89, 0x23, 0x11, 0x3e, 0x64, 0x08, 0x28, 0x08, 0x12, 0x29, 0xfd, 0x2e, 0x10, 0x28, 0xff, 0x28, 0x10, 0x28, 0x28, 0x2e, 0x44, 0x71, 0x83, 0x00, 0x00 },
{ 0xfb, 0xb8, 0x00, 0x10, 0x7e, 0xff, 0x10, 0x10, 0x10, 0x26, 0x7e, 0xf9, 0x52, 0x00, 0x52, 0x54, 0x52, 0x55, 0x6e, 0x97, 0x42, 0x00, 0x42, 0xfe, 0x7e, 0xaa, 0x42, 0xaa, 0x42, 0xaa, 0x7e, 0xff, 0x00, 0x00 },
{ 0xfb, 0xb9, 0x14, 0x10, 0x14, 0x10, 0x7f, 0x7e, 0x14, 0x10, 0x1c, 0x10, 0x08, 0x10, 0x3e, 0xff, 0x2a, 0x00, 0x2a, 0x10, 0x3e, 0x10, 0x08, 0x7e, 0x7f, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0xff, 0x00, 0x00 },
{ 0xfb, 0xba, 0x00, 0x7e, 0x3f, 0x80, 0x00, 0x80, 0x10, 0x84, 0x08, 0x84, 0x04, 0x88, 0x04, 0x90, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00 },
{ 0xfb, 0xbb, 0x00, 0x00, 0x3f, 0xfe, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0xf8, 0x04, 0x08, 0x04, 0x08, 0x04, 0x10, 0x0f, 0xf0, 0x08, 0x10, 0x00, 0x20, 0x00, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00 },
{ 0xfb, 0xbc, 0x00, 0x06, 0x7b, 0xf8, 0x48, 0x20, 0x4a, 0x22, 0x4a, 0x22, 0x49, 0x24, 0x49, 0x24, 0x48, 0x20, 0x4b, 0xff, 0x48, 0x20, 0x48, 0x20, 0x78, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0xe0, 0x00, 0x00 },
{ 0xfb, 0xbd, 0x10, 0x20, 0x13, 0xff, 0x10, 0x00, 0x11, 0xfe, 0x7d, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x13, 0xff, 0x12, 0x21, 0x10, 0xd0, 0x13, 0x2a, 0x1c, 0xdc, 0x73, 0x2a, 0x00, 0xc9, 0x03, 0x30, 0x00, 0x00 },
{ 0xfb, 0xbe, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x42, 0x21, 0x42, 0x21, 0x1e, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x1e, 0x3c, 0x02, 0x20, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfb, 0xbf, 0x10, 0x00, 0x11, 0xfe, 0x10, 0x04, 0x7c, 0x08, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x24, 0x10, 0x45, 0xff, 0x68, 0x10, 0x58, 0x10, 0x08, 0x10, 0x14, 0x10, 0x22, 0x10, 0x40, 0x70, 0x00, 0x00 },
{ 0xfb, 0xc0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x54, 0x10, 0x55, 0xff, 0x54, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x82, 0x7c, 0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xc1, 0x00, 0x00, 0x78, 0x1e, 0x09, 0xe8, 0x09, 0x48, 0x79, 0x48, 0x41, 0x48, 0x41, 0x48, 0x79, 0x48, 0x49, 0x48, 0x09, 0x48, 0x09, 0x48, 0x09, 0x54, 0x12, 0x74, 0x62, 0xca, 0x04, 0x89, 0x00, 0x00 },
{ 0xfb, 0xc2, 0x00, 0x00, 0x00, 0x3e, 0x1f, 0xc0, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x1f, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00, 0x00 },
{ 0xfb, 0xc3, 0x00, 0x0f, 0x1f, 0xf0, 0x10, 0x00, 0x1f, 0xfe, 0x10, 0x02, 0x1f, 0xfe, 0x12, 0x08, 0x13, 0xf8, 0x10, 0x00, 0x17, 0xfc, 0x14, 0x44, 0x17, 0xfc, 0x24, 0x01, 0x24, 0x01, 0x43, 0xff, 0x00, 0x00 },
{ 0xfb, 0xc4, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x3f, 0xfe, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xfb, 0xc5, 0x00, 0x20, 0x01, 0x20, 0x79, 0x20, 0x49, 0xfe, 0x4a, 0x20, 0x48, 0x20, 0x78, 0x20, 0x4b, 0xff, 0x48, 0x00, 0x48, 0x00, 0x49, 0xfc, 0x79, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0xfc, 0x00, 0x00 },
{ 0xfb, 0xc6, 0x01, 0x00, 0x7f, 0xfe, 0x08, 0x10, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x40, 0x02, 0x40, 0xf2, 0x1f, 0x00, 0x01, 0xf8, 0x1f, 0x00, 0x01, 0xfe, 0x7f, 0x00, 0x01, 0x02, 0x00, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xc7, 0x20, 0x20, 0x11, 0x20, 0x09, 0x20, 0x03, 0xfe, 0x42, 0x20, 0x24, 0x20, 0x10, 0x20, 0x07, 0xff, 0x00, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x22, 0x02, 0x22, 0x02, 0x42, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xc8, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x02, 0x23, 0xfe, 0x10, 0x00, 0x03, 0xfe, 0x00, 0x20, 0x00, 0x20, 0x17, 0xff, 0x10, 0x50, 0x20, 0x88, 0x21, 0x04, 0x66, 0x03, 0x00, 0x00 },
{ 0xfb, 0xc9, 0x21, 0x00, 0x11, 0x0f, 0x01, 0x09, 0x01, 0x09, 0x4f, 0xe9, 0x21, 0x0f, 0x11, 0x09, 0x01, 0x09, 0x07, 0xc9, 0x14, 0x4f, 0x14, 0x49, 0x24, 0x49, 0x27, 0xd1, 0x40, 0x11, 0x40, 0x23, 0x00, 0x00 },
{ 0xfb, 0xca, 0x20, 0x08, 0x17, 0x88, 0x00, 0x08, 0x0f, 0xdf, 0x40, 0x14, 0x27, 0xa4, 0x10, 0x04, 0x07, 0x84, 0x00, 0x3f, 0x10, 0x04, 0x17, 0x84, 0x24, 0x84, 0x24, 0x84, 0x44, 0x84, 0x47, 0x84, 0x00, 0x00 },
{ 0xfb, 0xcb, 0x00, 0x04, 0x21, 0x14, 0x12, 0x14, 0x07, 0x9f, 0x04, 0xa4, 0x44, 0xc4, 0x24, 0x84, 0x04, 0xbf, 0x07, 0x80, 0x14, 0x80, 0x14, 0xbf, 0x24, 0xa1, 0x27, 0xa1, 0x40, 0x21, 0x40, 0x3f, 0x00, 0x00 },
{ 0xfb, 0xcc, 0x20, 0x20, 0x13, 0xff, 0x08, 0x00, 0x01, 0xfc, 0x41, 0x04, 0x21, 0xfc, 0x10, 0x00, 0x07, 0xff, 0x04, 0x21, 0x10, 0xd1, 0x13, 0x2a, 0x20, 0xdc, 0x23, 0x2a, 0x40, 0xc9, 0x47, 0x30, 0x00, 0x00 },
{ 0xfb, 0xcd, 0x20, 0x84, 0x13, 0xff, 0x08, 0x94, 0x01, 0xff, 0x43, 0x10, 0x25, 0xfe, 0x11, 0x10, 0x01, 0xfe, 0x01, 0x10, 0x09, 0xff, 0x08, 0x00, 0x11, 0xfe, 0x10, 0x44, 0x20, 0x38, 0x21, 0xef, 0x00, 0x00 },
{ 0xfb, 0xce, 0x27, 0xbe, 0x14, 0x88, 0x07, 0x90, 0x04, 0xbe, 0x47, 0xa2, 0x22, 0x22, 0x07, 0xbe, 0x00, 0x22, 0x17, 0xbe, 0x14, 0xa2, 0x27, 0xa2, 0x22, 0x3e, 0x4a, 0x94, 0x52, 0xa2, 0x06, 0x41, 0x00, 0x00 },
{ 0xfb, 0xcf, 0x44, 0x00, 0x28, 0x1e, 0x11, 0xe8, 0x11, 0x48, 0x29, 0x48, 0x49, 0x48, 0x15, 0x48, 0x15, 0x48, 0x25, 0x48, 0x25, 0x48, 0x45, 0x48, 0x05, 0x54, 0x0a, 0x74, 0x0a, 0xca, 0x74, 0x89, 0x00, 0x00 },
{ 0xfb, 0xd0, 0x00, 0x20, 0x00, 0x3e, 0x7c, 0x20, 0x11, 0xff, 0x11, 0x21, 0x11, 0x3d, 0x7d, 0xe0, 0x11, 0x22, 0x11, 0x1e, 0x11, 0x00, 0x11, 0x28, 0x19, 0x28, 0x62, 0x49, 0x02, 0x49, 0x04, 0x8f, 0x00, 0x00 },
{ 0xfb, 0xd1, 0x00, 0x80, 0x7c, 0x8f, 0x10, 0x89, 0x13, 0xe9, 0x10, 0x89, 0x10, 0x8f, 0x7c, 0x89, 0x13, 0xe9, 0x12, 0x29, 0x12, 0x2f, 0x12, 0x29, 0x1e, 0x29, 0x73, 0xe9, 0x00, 0x11, 0x00, 0x13, 0x00, 0x00 },
{ 0xfb, 0xd2, 0x10, 0x0e, 0x10, 0xf4, 0x7e, 0xa4, 0x18, 0xa4, 0x24, 0xa4, 0x42, 0xa4, 0x3c, 0xa4, 0x00, 0xa4, 0x7e, 0xa4, 0x10, 0xa4, 0x3c, 0xa2, 0x24, 0xa2, 0x05, 0x2a, 0x05, 0x39, 0x19, 0x45, 0x00, 0x00 },
{ 0xfb, 0xd3, 0x10, 0x20, 0x11, 0x20, 0x21, 0x20, 0x79, 0xfe, 0x4a, 0x20, 0x4a, 0x20, 0x48, 0x20, 0x7b, 0xff, 0x48, 0x00, 0x48, 0x00, 0x49, 0xfe, 0x49, 0x02, 0x79, 0x02, 0x01, 0x02, 0x01, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xd4, 0x00, 0x10, 0x78, 0x10, 0x00, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x10, 0x10, 0x10, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0xfe, 0x54, 0x82, 0x54, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xfb, 0xd5, 0x10, 0x80, 0x54, 0x8f, 0x54, 0x89, 0x54, 0x89, 0x13, 0xe9, 0x7c, 0x8f, 0x10, 0x89, 0x10, 0x89, 0x3b, 0xe9, 0x3a, 0x2f, 0x36, 0x29, 0x52, 0x29, 0x53, 0xf1, 0x50, 0x11, 0x10, 0x23, 0x00, 0x00 },
{ 0xfb, 0xd6, 0x10, 0x10, 0x11, 0xff, 0x24, 0x00, 0x44, 0xfe, 0x28, 0x82, 0x10, 0xfe, 0x10, 0x00, 0x25, 0xff, 0x7d, 0x01, 0x11, 0x79, 0x55, 0x49, 0x55, 0x49, 0x51, 0x79, 0x11, 0x01, 0x11, 0x07, 0x00, 0x00 },
{ 0xfb, 0xd7, 0x08, 0x00, 0x08, 0x3f, 0x08, 0x21, 0x08, 0x21, 0x7f, 0x21, 0x08, 0x3f, 0x08, 0x21, 0x08, 0x21, 0x3e, 0x21, 0x22, 0x3f, 0x22, 0x21, 0x22, 0x41, 0x3e, 0x41, 0x00, 0x81, 0x01, 0x07, 0x00, 0x00 },
{ 0xfb, 0xd8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x00, 0x7c, 0x1f, 0x80, 0x10, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x00, 0x20, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00, 0x00 },
{ 0xfb, 0xd9, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x08, 0x00, 0x08, 0x3e, 0x08, 0x22, 0x7f, 0x22, 0x08, 0x3e, 0x08, 0x22, 0x3e, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x42, 0x3e, 0x42, 0x00, 0x8e, 0x00, 0x00 },
{ 0xfb, 0xda, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x90, 0x3f, 0xfe, 0x00, 0x00, 0x07, 0xf0, 0x04, 0x10, 0x07, 0xf0, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x23, 0xe2, 0x22, 0x22, 0x23, 0xe2, 0x20, 0x0e, 0x00, 0x00 },
{ 0xfb, 0xdb, 0x00, 0x80, 0x00, 0xfc, 0x00, 0x80, 0x1f, 0xff, 0x10, 0x81, 0x10, 0xfa, 0x17, 0x80, 0x10, 0x82, 0x10, 0x7e, 0x10, 0x00, 0x11, 0x10, 0x11, 0x10, 0x21, 0x11, 0x22, 0x11, 0x4c, 0x0f, 0x00, 0x00 },
{ 0xfb, 0xdc, 0x00, 0x10, 0x3c, 0x10, 0x24, 0x1e, 0x24, 0x10, 0x3c, 0xff, 0x00, 0x91, 0x00, 0x9c, 0x7e, 0xf1, 0x10, 0x9f, 0x10, 0x80, 0x3c, 0xa8, 0x24, 0xa8, 0x05, 0x29, 0x05, 0x49, 0x1a, 0x4f, 0x00, 0x00 },
{ 0xfb, 0xdd, 0x10, 0x80, 0x10, 0x8f, 0x10, 0x89, 0x7c, 0x89, 0x55, 0xe9, 0x54, 0x8f, 0x54, 0x89, 0x54, 0x89, 0x55, 0xe9, 0x7d, 0x2f, 0x11, 0x29, 0x15, 0x29, 0x15, 0xe9, 0x1a, 0x09, 0x62, 0x13, 0x00, 0x00 },
{ 0xfb, 0xde, 0x00, 0x44, 0x3d, 0xff, 0x00, 0x48, 0x7e, 0xff, 0x01, 0x88, 0x3c, 0xfe, 0x00, 0x88, 0x3c, 0xfe, 0x00, 0x88, 0x00, 0xff, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0x44, 0x24, 0x38, 0x3d, 0xc7, 0x00, 0x00 },
{ 0xfb, 0xdf, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x41, 0x81, 0x06, 0x44, 0x39, 0xe8, 0x06, 0x50, 0x39, 0xcc, 0x06, 0x43, 0x39, 0x80, 0x00, 0x00 },
{ 0xfb, 0xe0, 0x08, 0x10, 0x14, 0xff, 0x22, 0x00, 0x40, 0x7e, 0x3e, 0x42, 0x08, 0x7e, 0x08, 0x00, 0x7e, 0xff, 0x08, 0x81, 0x4a, 0xbd, 0x2a, 0xa5, 0x28, 0xa5, 0x08, 0xbd, 0x0e, 0x81, 0x70, 0x87, 0x00, 0x00 },
{ 0xfb, 0xe1, 0x10, 0x44, 0x11, 0xff, 0x7c, 0x44, 0x28, 0xff, 0x29, 0x88, 0x2a, 0xfe, 0x7c, 0x88, 0x00, 0xfe, 0x7c, 0x88, 0x44, 0xff, 0x44, 0x00, 0x7c, 0xfe, 0x44, 0x44, 0x44, 0x38, 0x7d, 0xc7, 0x00, 0x00 },
{ 0xfb, 0xe2, 0x3f, 0x7f, 0x21, 0x04, 0x3f, 0x08, 0x21, 0x3f, 0x3f, 0x21, 0x04, 0x21, 0x7f, 0xbf, 0x00, 0x21, 0x3f, 0x21, 0x21, 0x3f, 0x3f, 0x21, 0x04, 0x21, 0x25, 0x3f, 0x45, 0x12, 0x1c, 0x61, 0x00, 0x00 },
{ 0xfb, 0xe3, 0x00, 0x48, 0x00, 0x44, 0x7f, 0xff, 0x00, 0x20, 0x1f, 0x22, 0x11, 0x22, 0x1f, 0x14, 0x00, 0xd4, 0x07, 0x09, 0x78, 0x15, 0x00, 0x63, 0x00, 0x80, 0x24, 0x42, 0x24, 0x09, 0x43, 0xf9, 0x00, 0x00 },
{ 0xfb, 0xe4, 0x00, 0x48, 0x00, 0x44, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x3e, 0x44, 0x22, 0x24, 0x22, 0x28, 0x22, 0x28, 0x3e, 0x10, 0x00, 0x10, 0x03, 0x29, 0x1c, 0x45, 0x61, 0x83, 0x02, 0x01, 0x00, 0x00 },
{ 0xfb, 0xe5, 0x00, 0x08, 0x7f, 0x28, 0x14, 0x28, 0x14, 0x3f, 0x7f, 0x48, 0x55, 0x48, 0x55, 0x08, 0x55, 0x7f, 0x67, 0x00, 0x41, 0x00, 0x41, 0x3e, 0x7f, 0x22, 0x41, 0x22, 0x41, 0x22, 0x7f, 0x3e, 0x00, 0x00 },
{ 0xfb, 0xe6, 0x10, 0x03, 0x10, 0xfc, 0x10, 0x88, 0x7c, 0x88, 0x24, 0xff, 0x24, 0x88, 0x24, 0x84, 0x24, 0xe5, 0x45, 0x83, 0x68, 0x7e, 0x58, 0x42, 0x08, 0x7e, 0x14, 0x42, 0x22, 0x42, 0x40, 0x7e, 0x00, 0x00 },
{ 0xfb, 0xe7, 0x00, 0x3c, 0x1f, 0xc0, 0x10, 0x40, 0x10, 0x40, 0x1f, 0xff, 0x10, 0x20, 0x11, 0x91, 0x1e, 0x09, 0x70, 0x07, 0x0f, 0xfd, 0x08, 0x04, 0x0f, 0xfc, 0x08, 0x04, 0x08, 0x04, 0x0f, 0xfc, 0x00, 0x00 },
{ 0xfb, 0xe8, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x02, 0x22, 0x02, 0x13, 0xfe, 0x00, 0x00, 0x02, 0x10, 0x12, 0x13, 0x13, 0xdc, 0x22, 0x10, 0x22, 0x11, 0x43, 0xd1, 0x4e, 0x0f, 0x00, 0x00 },
{ 0xfb, 0xe9, 0x20, 0x00, 0x17, 0xff, 0x04, 0x21, 0x05, 0xfd, 0x40, 0x20, 0x23, 0xfe, 0x12, 0x22, 0x03, 0xfe, 0x02, 0x22, 0x13, 0xfe, 0x10, 0x20, 0x20, 0x20, 0x27, 0xff, 0x40, 0x20, 0x40, 0x20, 0x00, 0x00 },
{ 0xfb, 0xea, 0x00, 0x00, 0x01, 0xff, 0x7d, 0x01, 0x11, 0x11, 0x10, 0xfe, 0x10, 0x10, 0x7c, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x1c, 0x10, 0x71, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00 },
{ 0xfb, 0xeb, 0x00, 0x10, 0x00, 0x20, 0x3d, 0xfe, 0x01, 0x22, 0x01, 0xfe, 0x01, 0x22, 0x7d, 0x22, 0x11, 0xfe, 0x10, 0x50, 0x14, 0x52, 0x24, 0x55, 0x2e, 0x97, 0x72, 0x91, 0x01, 0x11, 0x06, 0x0f, 0x00, 0x00 },
{ 0xfb, 0xec, 0x04, 0x00, 0x04, 0x00, 0x0f, 0xfe, 0x11, 0x12, 0x61, 0x12, 0x02, 0x22, 0x04, 0x42, 0x18, 0x84, 0x01, 0x04, 0x00, 0x98, 0x04, 0x40, 0x24, 0x02, 0x24, 0x11, 0x44, 0x11, 0x03, 0xf0, 0x00, 0x00 },
{ 0xfb, 0xed, 0x10, 0x80, 0x10, 0x80, 0x11, 0xff, 0x59, 0x25, 0x56, 0x25, 0x54, 0x49, 0x50, 0x91, 0x11, 0x21, 0x10, 0x46, 0x10, 0x00, 0x10, 0xa0, 0x12, 0x92, 0x12, 0x85, 0x14, 0x85, 0x10, 0x7c, 0x00, 0x00 },
{ 0xfb, 0xee, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x08, 0x00, 0x08, 0x00, 0x1f, 0xfe, 0x12, 0x22, 0x22, 0x22, 0x44, 0x22, 0x04, 0x42, 0x08, 0x42, 0x10, 0x84, 0x21, 0x04, 0x02, 0x38, 0x00, 0x00 },
{ 0xfb, 0xef, 0x00, 0x88, 0x00, 0x88, 0x78, 0x88, 0x4b, 0xfe, 0x48, 0x88, 0x48, 0x88, 0x48, 0x88, 0x48, 0x88, 0x48, 0x88, 0x4b, 0xff, 0x78, 0x00, 0x00, 0x88, 0x00, 0x88, 0x01, 0x04, 0x02, 0x02, 0x00, 0x00 },
{ 0xfb, 0xf0, 0x00, 0x10, 0x7c, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x48, 0x44, 0x44, 0x04, 0x44, 0x04, 0x82, 0x04, 0x8e, 0x04, 0xf1, 0x39, 0x81, 0x00, 0x00 },
{ 0xfb, 0xf1, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x3e, 0xc2, 0x02, 0xc4, 0x04, 0xa8, 0x08, 0x90, 0x10, 0x8c, 0x60, 0x83, 0x03, 0x80, 0x00, 0x00 },
{ 0xfb, 0xf2, 0x20, 0x08, 0x17, 0x88, 0x00, 0x88, 0x00, 0x88, 0x40, 0x88, 0x23, 0x90, 0x12, 0x10, 0x02, 0x10, 0x07, 0x94, 0x14, 0x94, 0x10, 0xa2, 0x20, 0xa2, 0x20, 0xa2, 0x41, 0x2d, 0x46, 0x71, 0x00, 0x00 },
{ 0xfb, 0xf3, 0x20, 0x88, 0x10, 0x88, 0x08, 0x88, 0x03, 0xfe, 0x40, 0x88, 0x20, 0x88, 0x10, 0x88, 0x00, 0x88, 0x07, 0xff, 0x10, 0x00, 0x10, 0x00, 0x20, 0x88, 0x20, 0x84, 0x41, 0x02, 0x42, 0x02, 0x00, 0x00 },
{ 0xfb, 0xf4, 0x10, 0x88, 0x10, 0x88, 0x10, 0x88, 0x14, 0x88, 0x5b, 0xfe, 0x50, 0x88, 0x50, 0x88, 0x50, 0x88, 0x10, 0x88, 0x17, 0xff, 0x28, 0x00, 0x24, 0x88, 0x25, 0x04, 0x42, 0x02, 0x44, 0x02, 0x00, 0x00 },
{ 0xfb, 0xf5, 0x10, 0x00, 0x10, 0xfe, 0x24, 0x10, 0x44, 0x10, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x24, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x54, 0x10, 0x54, 0x10, 0x50, 0x10, 0x10, 0x10, 0x11, 0xff, 0x00, 0x00 },
{ 0xfb, 0xf6, 0x10, 0x00, 0x10, 0x00, 0x10, 0xfe, 0x7c, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0x10, 0x54, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x14, 0x10, 0x14, 0x10, 0x1a, 0x10, 0x62, 0xff, 0x00, 0x00 },
{ 0xfb, 0xf7, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x7f, 0x10, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x10, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x10, 0x22, 0x10, 0x22, 0x10, 0x3e, 0xff, 0x00, 0x00 },
{ 0xfb, 0xf8, 0x20, 0x10, 0x10, 0x7e, 0x0f, 0x42, 0x02, 0x7e, 0x42, 0x42, 0x22, 0x7e, 0x02, 0x40, 0x02, 0x7f, 0x02, 0x40, 0x12, 0x7f, 0x13, 0x01, 0x2e, 0xa9, 0x20, 0xa9, 0x41, 0x01, 0x40, 0x06, 0x00, 0x00 },
{ 0xfb, 0xf9, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x10, 0x81, 0x10, 0x86, 0x30, 0x98, 0x30, 0xe0, 0x50, 0x80, 0x50, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x81, 0x10, 0x81, 0x10, 0x81, 0x10, 0x7f, 0x00, 0x00 },
{ 0xfb, 0xfa, 0x07, 0x00, 0x78, 0x00, 0x08, 0x3f, 0x08, 0x21, 0x08, 0x21, 0x7f, 0x21, 0x08, 0x21, 0x1c, 0x21, 0x1a, 0x21, 0x19, 0x21, 0x29, 0x21, 0x28, 0x21, 0x48, 0x21, 0x08, 0x3f, 0x08, 0x00, 0x00, 0x00 },
{ 0xfb, 0xfb, 0x10, 0x44, 0x11, 0xff, 0x10, 0x44, 0x10, 0x00, 0x7d, 0xff, 0x24, 0x92, 0x27, 0xff, 0x24, 0x92, 0x44, 0x92, 0x69, 0xff, 0x18, 0x10, 0x08, 0x10, 0x15, 0xff, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xfb, 0xfc, 0x10, 0x44, 0x11, 0xff, 0x10, 0x44, 0x7c, 0x00, 0x11, 0xff, 0x10, 0x92, 0x3b, 0xff, 0x38, 0x92, 0x34, 0x92, 0x55, 0xff, 0x50, 0x10, 0x50, 0x10, 0x11, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },
{ 0xfb, 0xfd, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x08, 0x82, 0x08, 0x84, 0x10, 0x88, 0x21, 0x40, 0x01, 0x40, 0x02, 0x20, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x60, 0x03, 0x00, 0x00 },
{ 0xfb, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x84, 0x7f, 0xff, 0x00, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x14, 0x94, 0x17, 0xf4, 0x14, 0x94, 0x17, 0xf4, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xfc, 0xa1, 0x00, 0x00, 0x1c, 0x7e, 0x00, 0x42, 0x00, 0x4e, 0x3e, 0x4a, 0x08, 0x4a, 0x08, 0xff, 0x2a, 0x81, 0x2a, 0x81, 0x2a, 0xbd, 0x2a, 0xa5, 0x4a, 0xa5, 0x48, 0xbd, 0x08, 0x81, 0x08, 0x83, 0x00, 0x00 },
{ 0xfc, 0xa2, 0x00, 0x1c, 0x01, 0xe0, 0x3e, 0x80, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x01, 0xc0, 0x02, 0xa0, 0x02, 0xa0, 0x04, 0x90, 0x08, 0x88, 0x30, 0x86, 0x40, 0x81, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xfc, 0xa3, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x00, 0x02, 0x40, 0x04, 0x40, 0x04, 0x41, 0x08, 0x42, 0x18, 0x4c, 0x28, 0x70, 0x48, 0x40, 0x08, 0x40, 0x08, 0x41, 0x08, 0x41, 0x08, 0x3f, 0x00, 0x00 },
{ 0xfc, 0xa4, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x3f, 0xfe, 0x08, 0x88, 0x08, 0x88, 0x7f, 0xff, 0x08, 0x88, 0x08, 0x88, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xfc, 0xa5, 0x00, 0x0e, 0x3c, 0xf0, 0x00, 0x10, 0x7e, 0x10, 0x00, 0x10, 0x3d, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x00, 0xfe, 0x3c, 0x82, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x3c, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xa6, 0x00, 0x28, 0x3c, 0x28, 0x01, 0xff, 0x7c, 0x28, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x54, 0x3d, 0xff, 0x00, 0x54, 0x00, 0x54, 0x3c, 0xfe, 0x24, 0x10, 0x25, 0xff, 0x24, 0x10, 0x3c, 0x10, 0x00, 0x00 },
{ 0xfc, 0xa7, 0x02, 0x42, 0x04, 0x4c, 0x1c, 0x71, 0x64, 0x41, 0x04, 0x3f, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x78, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xa8, 0x14, 0x28, 0x7f, 0x28, 0x14, 0x28, 0x1c, 0x48, 0x08, 0x49, 0x3e, 0xca, 0x2b, 0x4c, 0x2a, 0x48, 0x2a, 0x48, 0x3e, 0x48, 0x08, 0x48, 0x08, 0x48, 0x7f, 0x49, 0x08, 0x49, 0x08, 0x4f, 0x00, 0x00 },
{ 0xfc, 0xa9, 0x00, 0x40, 0x3f, 0xff, 0x22, 0x00, 0x2f, 0xde, 0x20, 0x12, 0x27, 0x92, 0x24, 0x94, 0x27, 0x94, 0x20, 0x12, 0x2f, 0xd2, 0x20, 0x92, 0x21, 0x1e, 0x2f, 0xd0, 0x41, 0x10, 0x47, 0x10, 0x00, 0x00 },
{ 0xfc, 0xaa, 0x10, 0x20, 0x13, 0xff, 0x12, 0x44, 0x7b, 0xff, 0x12, 0x44, 0x12, 0x7c, 0x12, 0x00, 0x1b, 0xff, 0x72, 0x92, 0x12, 0xfe, 0x12, 0x92, 0x12, 0xfe, 0x12, 0x00, 0x14, 0x44, 0x35, 0x83, 0x00, 0x00 },
{ 0xfc, 0xab, 0x13, 0xde, 0x12, 0x52, 0x13, 0xde, 0x7a, 0x52, 0x13, 0xde, 0x11, 0x10, 0x11, 0xfe, 0x1b, 0x20, 0x75, 0xfc, 0x11, 0x20, 0x13, 0xff, 0x11, 0x08, 0x10, 0x90, 0x10, 0x70, 0x33, 0x8f, 0x00, 0x00 },
{ 0xfc, 0xac, 0x00, 0x10, 0x7c, 0x10, 0x11, 0xff, 0x11, 0x25, 0x11, 0x49, 0x20, 0xfe, 0x3d, 0x90, 0x24, 0x90, 0x64, 0xfe, 0x24, 0x90, 0x24, 0x90, 0x24, 0xfe, 0x24, 0x90, 0x3c, 0x90, 0x00, 0xff, 0x00, 0x00 },
{ 0xfc, 0xad, 0x00, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x10, 0x00, 0x10, 0x7c, 0x20, 0x44, 0x3c, 0x7c, 0x64, 0x00, 0x25, 0xff, 0x25, 0x01, 0x25, 0x7d, 0x25, 0x45, 0x3d, 0x7d, 0x01, 0x01, 0x01, 0x06, 0x00, 0x00 },
{ 0xfc, 0xae, 0x0c, 0x48, 0x73, 0xff, 0x10, 0x48, 0x10, 0x90, 0x7c, 0xff, 0x11, 0x90, 0x1a, 0xfe, 0x38, 0x90, 0x34, 0xfe, 0x54, 0x90, 0x53, 0xff, 0x50, 0x84, 0x10, 0x48, 0x10, 0x30, 0x13, 0xcf, 0x00, 0x00 },
{ 0xfc, 0xaf, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x7f, 0xf0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x32, 0x10, 0x0c, 0x10, 0x06, 0x10, 0x09, 0x10, 0x09, 0x10, 0x10, 0x11, 0x20, 0x11, 0x40, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xb0, 0x00, 0x40, 0x00, 0x40, 0x78, 0xfc, 0x48, 0x84, 0x49, 0x08, 0x4b, 0xfe, 0x49, 0x52, 0x49, 0x52, 0x49, 0x9e, 0x49, 0x22, 0x7b, 0xff, 0x00, 0x50, 0x00, 0x88, 0x01, 0x04, 0x06, 0x03, 0x00, 0x00 },
{ 0xfc, 0xb1, 0x04, 0x00, 0x0f, 0xc0, 0x10, 0x40, 0x3f, 0xfc, 0x52, 0x44, 0x12, 0x44, 0x14, 0x7c, 0x10, 0x04, 0x10, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x01, 0x40, 0x02, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xfc, 0xb2, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xfe, 0x40, 0x02, 0x5f, 0xfa, 0x10, 0x80, 0x10, 0x80, 0x1f, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x80, 0x10, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00 },
{ 0xfc, 0xb3, 0x04, 0x00, 0x04, 0xff, 0x08, 0x01, 0x08, 0x01, 0x51, 0x01, 0x21, 0x01, 0x12, 0x01, 0x0c, 0x01, 0x04, 0x01, 0x09, 0x01, 0x11, 0x01, 0x10, 0x81, 0x27, 0x82, 0x78, 0x42, 0x00, 0x5c, 0x00, 0x00 },
{ 0xfc, 0xb4, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x20, 0x82, 0x3f, 0xfe, 0x00, 0x80, 0x04, 0x80, 0x24, 0x44, 0x24, 0x02, 0x44, 0x12, 0x03, 0xf0, 0x00, 0x00 },
{ 0xfc, 0xb5, 0x10, 0x40, 0x10, 0x40, 0x10, 0xf8, 0x7c, 0x88, 0x11, 0x10, 0x13, 0xfe, 0x11, 0x52, 0x1d, 0x52, 0x71, 0x9e, 0x11, 0x22, 0x13, 0xff, 0x10, 0x30, 0x10, 0x48, 0x10, 0x84, 0x33, 0x03, 0x00, 0x00 },
{ 0xfc, 0xb6, 0x11, 0x10, 0x7f, 0xd0, 0x11, 0x10, 0x3b, 0xbf, 0x2a, 0xa9, 0x3b, 0xaa, 0x12, 0x48, 0x24, 0x08, 0x3f, 0x88, 0x64, 0x08, 0x3f, 0x94, 0x24, 0x14, 0x3f, 0xa2, 0x24, 0x22, 0x3f, 0xc1, 0x00, 0x00 },
{ 0xfc, 0xb7, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xff, 0x4a, 0x01, 0x4a, 0x01, 0x4a, 0xfd, 0x78, 0x00, 0x48, 0x00, 0x4b, 0xff, 0x48, 0x48, 0x48, 0x48, 0x78, 0x89, 0x00, 0x89, 0x01, 0x09, 0x06, 0x0e, 0x00, 0x00 },
{ 0xfc, 0xb8, 0x10, 0x00, 0x11, 0xff, 0x10, 0x00, 0x7c, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x38, 0x82, 0x38, 0xfe, 0x34, 0x82, 0x54, 0x82, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x00, 0x10, 0x00, 0x13, 0xff, 0x00, 0x00 },
{ 0xfc, 0xb9, 0x20, 0x80, 0x10, 0xf8, 0x09, 0x10, 0x02, 0x20, 0x47, 0xfe, 0x22, 0x52, 0x12, 0x52, 0x02, 0x9e, 0x02, 0x82, 0x10, 0x20, 0x17, 0xff, 0x20, 0x20, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xfc, 0xba, 0x10, 0x40, 0x10, 0xf8, 0x11, 0x10, 0x56, 0x20, 0x59, 0xfe, 0x51, 0x52, 0x51, 0x52, 0x11, 0x9e, 0x11, 0x02, 0x11, 0x22, 0x2b, 0xff, 0x24, 0x20, 0x20, 0x50, 0x41, 0x8c, 0x46, 0x03, 0x00, 0x00 },
{ 0xfc, 0xbb, 0x00, 0x00, 0x7d, 0xfe, 0x11, 0x52, 0x11, 0xfe, 0x10, 0x00, 0x13, 0xff, 0x7c, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x1c, 0x71, 0x70, 0xaa, 0x01, 0x24, 0x06, 0x23, 0x00, 0x20, 0x00, 0x00 },
{ 0xfc, 0xbc, 0x08, 0x40, 0x10, 0x40, 0x20, 0x40, 0x4b, 0xf8, 0x28, 0x48, 0x10, 0x48, 0x24, 0x48, 0x7d, 0x48, 0x14, 0xc8, 0x10, 0x48, 0x58, 0xa9, 0x54, 0xa9, 0x55, 0x09, 0x11, 0x09, 0x12, 0x07, 0x00, 0x00 },
{ 0xfc, 0xbd, 0x23, 0xfe, 0x12, 0x52, 0x0b, 0xfe, 0x00, 0x00, 0x47, 0xff, 0x20, 0x00, 0x13, 0xfe, 0x02, 0x02, 0x73, 0xfe, 0x10, 0x72, 0x11, 0xac, 0x16, 0x22, 0x10, 0x21, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfc, 0xbe, 0x00, 0x44, 0x3e, 0xff, 0x28, 0x44, 0x3e, 0xef, 0x28, 0xa9, 0x3e, 0xef, 0x28, 0x24, 0x28, 0x48, 0x3e, 0xff, 0x02, 0x48, 0x52, 0x7e, 0x52, 0x48, 0x44, 0x7e, 0x04, 0x48, 0x18, 0x7f, 0x00, 0x00 },
{ 0xfc, 0xbf, 0x10, 0x00, 0x1c, 0xfe, 0x24, 0xaa, 0x28, 0xaa, 0x7e, 0xaa, 0x2a, 0xfe, 0x2a, 0x00, 0x3e, 0x10, 0x2a, 0x54, 0x2a, 0x92, 0x3e, 0x10, 0x00, 0x54, 0x2a, 0x92, 0x2a, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xfc, 0xc0, 0x20, 0x00, 0x10, 0x1e, 0x0b, 0xe0, 0x00, 0x20, 0x40, 0x20, 0x27, 0xff, 0x10, 0x20, 0x00, 0x20, 0x00, 0x20, 0x13, 0xfe, 0x12, 0x02, 0x22, 0x02, 0x22, 0x02, 0x42, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xc1, 0x20, 0x00, 0x11, 0xfc, 0x09, 0x04, 0x01, 0x3c, 0x41, 0x24, 0x27, 0xff, 0x14, 0x01, 0x01, 0xfc, 0x01, 0x04, 0x11, 0xfc, 0x11, 0x04, 0x21, 0xfc, 0x21, 0x04, 0x41, 0x04, 0x41, 0x1c, 0x00, 0x00 },
{ 0xfc, 0xc2, 0x04, 0x00, 0x44, 0xfc, 0x28, 0x84, 0x10, 0x9c, 0x30, 0x94, 0x53, 0xff, 0x0a, 0x01, 0x0a, 0xfd, 0x18, 0x84, 0x28, 0xfc, 0x48, 0x84, 0x08, 0xfc, 0x08, 0x84, 0x08, 0x84, 0x30, 0x9c, 0x00, 0x00 },
{ 0xfc, 0xc3, 0x08, 0x24, 0x7f, 0x42, 0x41, 0x81, 0x08, 0x00, 0x3e, 0x18, 0x08, 0x24, 0x3e, 0x42, 0x08, 0x81, 0x7e, 0x00, 0x08, 0x00, 0x00, 0x7e, 0x3e, 0x42, 0x22, 0x42, 0x22, 0x42, 0x3e, 0x7e, 0x00, 0x00 },
{ 0xfc, 0xc4, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x42, 0x42, 0x7e, 0x7e, 0x40, 0x02, 0x48, 0x32, 0x45, 0xc2, 0x50, 0x42, 0x4b, 0xfa, 0x40, 0x42, 0x45, 0xf2, 0x49, 0x12, 0x51, 0xf2, 0x40, 0x0e, 0x00, 0x00 },
{ 0xfc, 0xc5, 0x1f, 0xfc, 0x10, 0x84, 0x11, 0x04, 0x17, 0xf4, 0x14, 0x14, 0x17, 0xf4, 0x14, 0x14, 0x17, 0xf4, 0x10, 0x04, 0x17, 0xf4, 0x10, 0x84, 0x27, 0xf5, 0x20, 0x85, 0x2f, 0xfb, 0x40, 0x01, 0x00, 0x00 },
{ 0xfc, 0xc6, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x54, 0x10, 0x54, 0x92, 0x54, 0x54, 0x55, 0xff, 0x54, 0x48, 0x5c, 0x48, 0x10, 0x49, 0x10, 0x89, 0x11, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xc7, 0x08, 0x20, 0x08, 0x40, 0x11, 0xfc, 0x21, 0x04, 0x49, 0xfc, 0x09, 0x04, 0x11, 0xfc, 0x10, 0x00, 0x33, 0xfe, 0x50, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xfc, 0xc8, 0x10, 0x20, 0x12, 0x22, 0x12, 0x22, 0x59, 0x24, 0x55, 0x24, 0x54, 0x20, 0x53, 0xff, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x10, 0x90, 0x11, 0x11, 0x11, 0x11, 0x12, 0x11, 0x14, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xc9, 0x10, 0x20, 0x10, 0x40, 0x19, 0xfc, 0x55, 0x04, 0x55, 0xfc, 0x51, 0x04, 0x51, 0x04, 0x11, 0xfc, 0x10, 0x00, 0x13, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x10, 0x20, 0x17, 0xff, 0x00, 0x00 },
{ 0xfc, 0xca, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x19, 0x04, 0x55, 0xfc, 0x54, 0x22, 0x51, 0x22, 0x50, 0xa4, 0x10, 0xa8, 0x17, 0xff, 0x10, 0x50, 0x10, 0x50, 0x10, 0x91, 0x11, 0x11, 0x16, 0x1e, 0x00, 0x00 },
{ 0xfc, 0xcb, 0x10, 0x84, 0x13, 0xff, 0x10, 0x84, 0x58, 0x20, 0x57, 0xff, 0x55, 0x00, 0x51, 0x00, 0x10, 0xfe, 0x10, 0x00, 0x11, 0x24, 0x11, 0x24, 0x11, 0x24, 0x11, 0x25, 0x12, 0x25, 0x14, 0x27, 0x00, 0x00 },
{ 0xfc, 0xcc, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x80, 0x08, 0x88, 0x04, 0x90, 0x7f, 0xff, 0x02, 0x20, 0x02, 0x20, 0x04, 0x21, 0x18, 0x21, 0x60, 0x1f, 0x00, 0x00 },
{ 0xfc, 0xcd, 0x00, 0x20, 0x02, 0x22, 0x7a, 0x22, 0x49, 0x24, 0x49, 0x24, 0x48, 0x20, 0x7b, 0xff, 0x48, 0x90, 0x48, 0x90, 0x48, 0x90, 0x48, 0x90, 0x79, 0x10, 0x01, 0x11, 0x02, 0x11, 0x04, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xce, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x79, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x38, 0x20, 0x35, 0x24, 0x34, 0xa8, 0x57, 0xff, 0x50, 0x90, 0x10, 0x90, 0x11, 0x12, 0x12, 0x12, 0x1c, 0x0e, 0x00, 0x00 },
{ 0xfc, 0xcf, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x02, 0x02, 0x42, 0x02, 0x22, 0x02, 0x12, 0x02, 0x03, 0xfe, 0x00, 0x90, 0x10, 0x90, 0x10, 0x90, 0x21, 0x10, 0x21, 0x11, 0x42, 0x11, 0x44, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xd0, 0x20, 0x20, 0x10, 0x40, 0x09, 0xfe, 0x01, 0x02, 0x41, 0xfe, 0x21, 0x02, 0x11, 0xfe, 0x00, 0x00, 0x03, 0xff, 0x10, 0x20, 0x10, 0x20, 0x21, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xfc, 0xd1, 0x20, 0x00, 0x13, 0xfe, 0x0a, 0x02, 0x03, 0xfe, 0x42, 0x02, 0x23, 0xfe, 0x12, 0x22, 0x01, 0x24, 0x00, 0x20, 0x17, 0xff, 0x10, 0x90, 0x20, 0x90, 0x21, 0x11, 0x42, 0x11, 0x4c, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xd2, 0x20, 0x88, 0x13, 0xfe, 0x08, 0x88, 0x40, 0xf8, 0x20, 0x00, 0x17, 0xff, 0x00, 0x20, 0x01, 0xfc, 0x01, 0x24, 0x11, 0xfc, 0x11, 0x24, 0x21, 0xfc, 0x20, 0x00, 0x41, 0x04, 0x46, 0x02, 0x00, 0x00 },
{ 0xfc, 0xd3, 0x10, 0x20, 0x10, 0x40, 0x11, 0xfe, 0x55, 0x02, 0x59, 0xfe, 0x51, 0x02, 0x51, 0x02, 0x11, 0xfe, 0x10, 0x00, 0x11, 0xfe, 0x28, 0x20, 0x25, 0xfe, 0x20, 0x20, 0x40, 0x20, 0x43, 0xff, 0x00, 0x00 },
{ 0xfc, 0xd4, 0x00, 0x44, 0x7d, 0xff, 0x10, 0x44, 0x10, 0x7c, 0x10, 0x00, 0x7d, 0xff, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x1c, 0x92, 0x70, 0xfe, 0x00, 0x00, 0x00, 0x82, 0x03, 0x01, 0x00, 0x00 },
{ 0xfc, 0xd5, 0x00, 0x80, 0x01, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfc, 0xd6, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x41, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfc, 0xd7, 0x10, 0x20, 0x1f, 0x3f, 0x24, 0x48, 0x42, 0x84, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x07, 0xf0, 0x00, 0x00, 0x7f, 0xff, 0x08, 0x88, 0x0f, 0xf8, 0x08, 0x88, 0x0f, 0xf8, 0x38, 0x0e, 0x00, 0x00 },
{ 0xfc, 0xd8, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x08, 0x89, 0x10, 0x89, 0x60, 0x87, 0x00, 0x00 },
{ 0xfc, 0xd9, 0x10, 0x10, 0x10, 0x20, 0x10, 0xfe, 0x7c, 0x82, 0x54, 0xfe, 0x54, 0x82, 0x54, 0x82, 0x54, 0xfe, 0x54, 0x00, 0x7c, 0xfe, 0x10, 0x10, 0x14, 0xfe, 0x14, 0x10, 0x1a, 0x10, 0x61, 0xff, 0x00, 0x00 },
{ 0xfc, 0xda, 0x20, 0x20, 0x11, 0xfc, 0x01, 0x04, 0x41, 0xfc, 0x21, 0x04, 0x01, 0xfc, 0x00, 0x00, 0x03, 0xfe, 0x70, 0x20, 0x11, 0xfc, 0x10, 0x20, 0x13, 0xfe, 0x10, 0x00, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfc, 0xdb, 0x7c, 0x40, 0x45, 0xfc, 0x45, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x51, 0x04, 0x49, 0xfc, 0x48, 0x00, 0x44, 0x00, 0x47, 0xfe, 0x44, 0x20, 0x59, 0xfc, 0x40, 0x20, 0x40, 0x20, 0x47, 0xff, 0x00, 0x00 },
{ 0xfc, 0xdc, 0x04, 0x10, 0x04, 0x10, 0x3f, 0xfe, 0x04, 0x10, 0x04, 0x10, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x00, 0x0c, 0x1c, 0x70, 0x03, 0x00, 0x00 },
{ 0xfc, 0xdd, 0x3f, 0xff, 0x20, 0x00, 0x28, 0x48, 0x24, 0x90, 0x21, 0xfe, 0x28, 0x90, 0x24, 0xfc, 0x20, 0x90, 0x22, 0xfc, 0x22, 0x90, 0x24, 0x90, 0x24, 0xfe, 0x28, 0x00, 0x20, 0x00, 0x3f, 0xff, 0x00, 0x00 },
{ 0xfc, 0xde, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x23, 0xe2, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0xe2, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xdf, 0x79, 0xfe, 0x09, 0x02, 0x11, 0x02, 0x11, 0x7a, 0x21, 0x4a, 0x39, 0x4a, 0x49, 0x4a, 0x09, 0x4a, 0x29, 0x7a, 0x29, 0x02, 0x29, 0x02, 0x11, 0xfe, 0x18, 0x00, 0x26, 0x00, 0x41, 0xff, 0x00, 0x00 },
{ 0xfc, 0xe0, 0x08, 0x00, 0x0b, 0xfe, 0x12, 0x02, 0x22, 0x02, 0x4a, 0x02, 0x0a, 0xf2, 0x12, 0x92, 0x12, 0x92, 0x32, 0x92, 0x52, 0x92, 0x12, 0xf2, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x13, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xe1, 0x10, 0x80, 0x10, 0x80, 0x13, 0xff, 0x58, 0x80, 0x54, 0x88, 0x54, 0xa9, 0x50, 0xa9, 0x11, 0x2a, 0x11, 0x4a, 0x11, 0x48, 0x11, 0x14, 0x12, 0x14, 0x12, 0x22, 0x12, 0x42, 0x14, 0x81, 0x00, 0x00 },
{ 0xfc, 0xe2, 0x11, 0x00, 0x11, 0x00, 0x13, 0xff, 0x5a, 0x00, 0x54, 0x00, 0x55, 0xfc, 0x51, 0x44, 0x11, 0x24, 0x17, 0xff, 0x11, 0x44, 0x11, 0x24, 0x11, 0x24, 0x13, 0xff, 0x12, 0x04, 0x10, 0x18, 0x00, 0x00 },
{ 0xfc, 0xe3, 0x10, 0x20, 0x13, 0xff, 0x18, 0x00, 0x55, 0xfe, 0x55, 0x52, 0x51, 0xfe, 0x50, 0x20, 0x13, 0xa7, 0x10, 0x20, 0x13, 0xa7, 0x10, 0x50, 0x13, 0x92, 0x10, 0x8c, 0x10, 0xe4, 0x13, 0x83, 0x00, 0x00 },
{ 0xfc, 0xe4, 0x00, 0x80, 0x00, 0x80, 0x79, 0xff, 0x49, 0x00, 0x4a, 0x00, 0x48, 0xfe, 0x48, 0xa2, 0x78, 0x92, 0x4b, 0xff, 0x48, 0xa2, 0x48, 0x92, 0x48, 0x92, 0x79, 0xff, 0x01, 0x02, 0x00, 0x1c, 0x00, 0x00 },
{ 0xfc, 0xe5, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x18, 0x0c, 0x67, 0xf3, 0x00, 0x00, 0x3f, 0xfe, 0x28, 0x8a, 0x24, 0x92, 0x3f, 0xfe, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00 },
{ 0xfc, 0xe6, 0x10, 0x30, 0x10, 0x48, 0x10, 0x84, 0x7d, 0xfe, 0x12, 0x01, 0x11, 0xfe, 0x39, 0x6a, 0x39, 0x22, 0x35, 0xfe, 0x54, 0x00, 0x50, 0xfc, 0x50, 0x84, 0x10, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x00, 0x00 },
{ 0xfc, 0xe7, 0x20, 0x88, 0x10, 0x88, 0x09, 0x10, 0x01, 0x10, 0x43, 0xff, 0x23, 0x10, 0x15, 0x10, 0x01, 0xfe, 0x01, 0x10, 0x11, 0x10, 0x11, 0xfe, 0x21, 0x10, 0x21, 0x10, 0x41, 0x10, 0x41, 0xff, 0x00, 0x00 },
{ 0xfc, 0xe8, 0x20, 0x30, 0x10, 0x48, 0x08, 0x84, 0x41, 0x7a, 0x22, 0x01, 0x11, 0xfe, 0x01, 0x6a, 0x09, 0x22, 0x09, 0xfe, 0x10, 0x00, 0x10, 0xfc, 0x20, 0x84, 0x20, 0xfc, 0x40, 0x84, 0x40, 0xfc, 0x00, 0x00 },
{ 0xfc, 0xe9, 0x08, 0x00, 0x08, 0x00, 0x7f, 0xff, 0x08, 0x00, 0x08, 0x20, 0x09, 0x21, 0x09, 0x22, 0x12, 0x24, 0x12, 0x50, 0x10, 0x50, 0x10, 0x88, 0x20, 0x88, 0x21, 0x04, 0x22, 0x02, 0x4c, 0x01, 0x00, 0x00 },
{ 0xfc, 0xea, 0x04, 0x10, 0x44, 0x28, 0x28, 0xc6, 0x13, 0x79, 0x30, 0x00, 0x51, 0xff, 0x09, 0x55, 0x09, 0x11, 0x19, 0xff, 0x28, 0x00, 0x48, 0xfe, 0x08, 0x82, 0x08, 0xfe, 0x08, 0x82, 0x30, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xeb, 0x10, 0x10, 0x10, 0x28, 0x24, 0x44, 0x45, 0xbb, 0x28, 0x00, 0x11, 0xff, 0x11, 0x11, 0x25, 0x55, 0x7d, 0xff, 0x14, 0x00, 0x50, 0xfe, 0x54, 0x82, 0x54, 0xfe, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xec, 0x00, 0x10, 0x3c, 0x28, 0x24, 0xc6, 0x25, 0x7d, 0x24, 0x00, 0x3d, 0xff, 0x25, 0x55, 0x25, 0x11, 0x25, 0xff, 0x3c, 0x00, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x44, 0x82, 0x4c, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xed, 0x02, 0x20, 0x7f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x3f, 0xfe, 0x20, 0x02, 0x20, 0x02, 0x27, 0xf2, 0x24, 0x12, 0x24, 0x12, 0x24, 0x12, 0x27, 0xf2, 0x20, 0x02, 0x20, 0x02, 0x3f, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xee, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x7c, 0x82, 0x54, 0x82, 0x54, 0xba, 0x54, 0xaa, 0x54, 0xaa, 0x54, 0xaa, 0x7c, 0xaa, 0x10, 0xba, 0x14, 0x82, 0x14, 0x82, 0x1a, 0x82, 0x62, 0xfe, 0x00, 0x00 },
{ 0xfc, 0xef, 0x00, 0x40, 0x3c, 0x40, 0x00, 0xff, 0x7e, 0x80, 0x01, 0x00, 0x3c, 0x7e, 0x00, 0x52, 0x3c, 0x4a, 0x01, 0xff, 0x00, 0x52, 0x3c, 0x4a, 0x24, 0x82, 0x24, 0xff, 0x24, 0x82, 0x3c, 0x0c, 0x00, 0x00 },
{ 0xfc, 0xf0, 0x00, 0x20, 0x3c, 0x20, 0x25, 0xff, 0x24, 0x40, 0x3c, 0x40, 0x24, 0x7e, 0x24, 0xc2, 0x3c, 0xc2, 0x25, 0x7e, 0x24, 0x42, 0x24, 0x42, 0x3c, 0x7e, 0x00, 0x42, 0x24, 0x42, 0x42, 0x4e, 0x00, 0x00 },
{ 0xfc, 0xf1, 0x04, 0x01, 0x3f, 0x89, 0x04, 0x89, 0x7f, 0xe9, 0x04, 0x89, 0x3f, 0x89, 0x04, 0x09, 0x7f, 0xc9, 0x24, 0x89, 0x3f, 0x89, 0x24, 0x89, 0x3f, 0x81, 0x00, 0x01, 0x03, 0xc1, 0x7c, 0x07, 0x00, 0x00 },
{ 0xfc, 0xf2, 0x04, 0x48, 0x47, 0xff, 0x28, 0x48, 0x10, 0x90, 0x30, 0xfe, 0x51, 0x90, 0x0a, 0xfe, 0x08, 0x90, 0x18, 0xfe, 0x28, 0x90, 0x4b, 0xff, 0x08, 0x84, 0x08, 0x48, 0x08, 0x30, 0x33, 0xcf, 0x00, 0x00 },
{ 0xfc, 0xf3, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0x11, 0x01, 0x10, 0x01, 0x10, 0x1f, 0x10, 0x10, 0x20, 0x10, 0x20, 0x3f, 0x24, 0x21, 0x42, 0x01, 0x4e, 0x01, 0xf2, 0x0e, 0x00, 0x00, 0x00 },
{ 0xfc, 0xf4, 0x10, 0x48, 0x13, 0xff, 0x10, 0x48, 0x7c, 0x78, 0x10, 0x00, 0x13, 0xff, 0x30, 0x20, 0x39, 0xfe, 0x35, 0x22, 0x55, 0xfe, 0x51, 0x22, 0x11, 0xfe, 0x10, 0x00, 0x10, 0xcc, 0x13, 0x03, 0x00, 0x00 },
{ 0xfc, 0xf5, 0x18, 0x88, 0x17, 0xfe, 0x24, 0x88, 0x20, 0xf8, 0x7c, 0x00, 0x13, 0xff, 0x10, 0x20, 0x7d, 0xfc, 0x11, 0x24, 0x55, 0xfc, 0x55, 0x24, 0x51, 0xfc, 0x1c, 0x88, 0x71, 0x04, 0x02, 0x04, 0x00, 0x00 },
{ 0xfc, 0xf6, 0x00, 0x20, 0x00, 0x22, 0x79, 0xfa, 0x48, 0x24, 0x48, 0x28, 0x4b, 0xff, 0x48, 0x10, 0x49, 0xfe, 0x48, 0x44, 0x48, 0x98, 0x79, 0x10, 0x06, 0xff, 0x00, 0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x00 },
{ 0xfc, 0xf7, 0x00, 0x88, 0x77, 0xff, 0x50, 0x88, 0x50, 0x20, 0x57, 0xff, 0x50, 0x00, 0x51, 0xfc, 0x51, 0x04, 0x51, 0xfc, 0x50, 0x00, 0x77, 0xff, 0x04, 0x01, 0x04, 0xf9, 0x04, 0x89, 0x04, 0xfb, 0x00, 0x00 },
{ 0xfc, 0xf8, 0x00, 0x82, 0x00, 0x84, 0x1f, 0xe8, 0x00, 0x90, 0x00, 0xa0, 0x7f, 0xff, 0x00, 0x80, 0x03, 0xf8, 0x0c, 0x10, 0x70, 0x60, 0x00, 0x40, 0x7f, 0xff, 0x00, 0x40, 0x00, 0x40, 0x01, 0xc0, 0x00, 0x00 },
{ 0xfc, 0xf9, 0x08, 0x20, 0x08, 0x20, 0x7f, 0x40, 0x00, 0x7f, 0x24, 0x84, 0x23, 0x44, 0x40, 0x44, 0x04, 0x44, 0x44, 0x28, 0x24, 0x28, 0x18, 0x10, 0x08, 0x10, 0x14, 0x28, 0x22, 0x44, 0x41, 0x83, 0x00, 0x00 },
{ 0xfc, 0xfa, 0x35, 0x88, 0x48, 0x88, 0x75, 0x8f, 0x54, 0x88, 0x69, 0x88, 0x54, 0x88, 0x7f, 0xfe, 0x40, 0xa2, 0x1f, 0x22, 0x02, 0x14, 0x04, 0x14, 0x3f, 0x08, 0x04, 0x08, 0x04, 0x14, 0x1c, 0x63, 0x00, 0x00 },
{ 0xfc, 0xfb, 0x00, 0x20, 0x01, 0xfe, 0x78, 0x20, 0x4b, 0xff, 0x49, 0x04, 0x4b, 0xdf, 0x79, 0x04, 0x49, 0xc4, 0x4b, 0x1f, 0x48, 0x00, 0x4b, 0xff, 0x78, 0x90, 0x00, 0x90, 0x01, 0x11, 0x06, 0x0f, 0x00, 0x00 },
{ 0xfc, 0xfc, 0x01, 0x00, 0x02, 0x00, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xf8, 0x10, 0x08, 0x1f, 0xfe, 0x10, 0x00, 0x1f, 0xfe, 0x00, 0x02, 0x00, 0x84, 0x7f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x70, 0x87, 0x00, 0x00 },
{ 0xfc, 0xfd, 0x20, 0x20, 0x10, 0x21, 0x09, 0xfa, 0x40, 0x24, 0x20, 0x28, 0x13, 0xff, 0x00, 0x10, 0x09, 0xfe, 0x08, 0x44, 0x10, 0x98, 0x11, 0x10, 0x26, 0xff, 0x20, 0x10, 0x40, 0x10, 0x40, 0x70, 0x00, 0x00 },
{ 0xfc, 0xfe, 0x20, 0x04, 0x10, 0xc8, 0x08, 0x30, 0x00, 0xc8, 0x43, 0x24, 0x20, 0x40, 0x17, 0xff, 0x00, 0x80, 0x01, 0xfc, 0x11, 0x04, 0x13, 0xfc, 0x25, 0x04, 0x21, 0xfc, 0x41, 0x04, 0x41, 0x1c, 0x00, 0x00 },
{ 0xfd, 0xa1, 0x18, 0x08, 0x06, 0x10, 0x01, 0xa0, 0x00, 0x60, 0x01, 0x90, 0x06, 0x0c, 0x38, 0x02, 0x02, 0x10, 0x06, 0x10, 0x09, 0x20, 0x01, 0x20, 0x00, 0xc0, 0x03, 0x20, 0x0c, 0x18, 0x70, 0x07, 0x00, 0x00 },
{ 0xfd, 0xa2, 0x1c, 0x06, 0x03, 0x98, 0x00, 0x70, 0x03, 0x8c, 0x3c, 0x82, 0x01, 0x00, 0x7f, 0xff, 0x02, 0x00, 0x07, 0xfc, 0x1c, 0x04, 0x67, 0xfc, 0x04, 0x04, 0x07, 0xfc, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00 },
{ 0xfd, 0xa3, 0x00, 0x10, 0x7f, 0x11, 0x14, 0x7d, 0x14, 0x12, 0x7f, 0x14, 0x55, 0xff, 0x55, 0x10, 0x55, 0x20, 0x67, 0x3e, 0x41, 0x44, 0x41, 0x08, 0x7d, 0x7f, 0x41, 0x08, 0x41, 0x08, 0x7f, 0x18, 0x00, 0x00 },
{ 0xfd, 0xa4, 0x00, 0x10, 0x3e, 0x7e, 0x28, 0x10, 0x3e, 0xff, 0x28, 0x44, 0x3e, 0xef, 0x28, 0x44, 0x28, 0x64, 0x3e, 0xcf, 0x02, 0x00, 0x52, 0xff, 0x52, 0x24, 0x44, 0x25, 0x04, 0x45, 0x19, 0x87, 0x00, 0x00 },
{ 0xfd, 0xa5, 0x08, 0x00, 0x09, 0xf8, 0x10, 0x08, 0x10, 0x08, 0x37, 0xff, 0x31, 0x00, 0x51, 0x00, 0x13, 0xfe, 0x14, 0x20, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x10, 0x50, 0x11, 0x8c, 0x16, 0x03, 0x00, 0x00 },
{ 0xfd, 0xa6, 0x08, 0x00, 0x08, 0xfc, 0x10, 0x04, 0x14, 0x04, 0x35, 0xff, 0x34, 0x40, 0x54, 0x40, 0x14, 0xfe, 0x15, 0x10, 0x14, 0x10, 0x15, 0xff, 0x14, 0x10, 0x14, 0x28, 0x10, 0x44, 0x11, 0x83, 0x00, 0x00 },
{ 0xfd, 0xa7, 0x1f, 0xff, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x12, 0x02, 0x13, 0xfe, 0x10, 0x00, 0x13, 0xfc, 0x10, 0x08, 0x10, 0x30, 0x27, 0xff, 0x20, 0x20, 0x40, 0x20, 0x00, 0xe0, 0x00, 0x00 },
{ 0xfd, 0xa8, 0x00, 0x1e, 0x1f, 0xe0, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1f, 0xff, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x13, 0xfe, 0x12, 0x02, 0x12, 0x02, 0x22, 0x02, 0x22, 0x02, 0x43, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xa9, 0x00, 0x08, 0x03, 0xe8, 0x78, 0x28, 0x48, 0x48, 0x48, 0x88, 0x48, 0x88, 0x48, 0xa8, 0x48, 0xc8, 0x49, 0x88, 0x4a, 0x88, 0x78, 0x88, 0x00, 0x88, 0x00, 0x89, 0x00, 0x89, 0x03, 0x8f, 0x00, 0x00 },
{ 0xfd, 0xaa, 0x00, 0x80, 0x00, 0xbe, 0x78, 0x82, 0x49, 0x02, 0x49, 0x7f, 0x4b, 0x00, 0x4d, 0x20, 0x49, 0x3e, 0x49, 0x48, 0x49, 0x08, 0x49, 0x7f, 0x49, 0x08, 0x79, 0x14, 0x01, 0x22, 0x01, 0x41, 0x00, 0x00 },
{ 0xfd, 0xab, 0x00, 0x20, 0x00, 0x40, 0x79, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x49, 0x02, 0x49, 0xfe, 0x48, 0x28, 0x48, 0x24, 0x7b, 0xff, 0x00, 0x50, 0x01, 0x8c, 0x06, 0x03, 0x00, 0x00 },
{ 0xfd, 0xac, 0x10, 0x80, 0x10, 0xbc, 0x10, 0x84, 0x7d, 0x04, 0x55, 0x7f, 0x57, 0x20, 0x57, 0x20, 0x55, 0x3f, 0x55, 0x48, 0x55, 0x08, 0x59, 0x7f, 0x11, 0x08, 0x11, 0x14, 0x11, 0x22, 0x10, 0x41, 0x00, 0x00 },
{ 0xfd, 0xad, 0x08, 0x20, 0x0a, 0x48, 0x11, 0x88, 0x20, 0x90, 0x48, 0x64, 0x08, 0x42, 0x10, 0x8d, 0x13, 0xf1, 0x30, 0x40, 0x50, 0xfc, 0x11, 0x84, 0x12, 0x48, 0x10, 0x30, 0x10, 0xcc, 0x17, 0x03, 0x00, 0x00 },
{ 0xfd, 0xae, 0x10, 0x00, 0x13, 0xff, 0x10, 0x20, 0x7c, 0x20, 0x10, 0x40, 0x10, 0x40, 0x38, 0xfe, 0x38, 0x82, 0x34, 0x82, 0x54, 0x02, 0x50, 0x02, 0x50, 0x02, 0x10, 0x04, 0x10, 0x04, 0x10, 0x38, 0x00, 0x00 },
{ 0xfd, 0xaf, 0x00, 0x40, 0x3c, 0x40, 0x24, 0xfe, 0x24, 0x82, 0x25, 0x02, 0x3c, 0xf2, 0x24, 0x92, 0x24, 0x92, 0x24, 0xf2, 0x3c, 0x02, 0x00, 0x1c, 0x00, 0x00, 0x12, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xb0, 0x00, 0x00, 0x7d, 0xfe, 0x10, 0x66, 0x10, 0x66, 0x10, 0xaa, 0x7d, 0x32, 0x10, 0x22, 0x10, 0x66, 0x10, 0x66, 0x10, 0xaa, 0x1d, 0x32, 0x70, 0x22, 0x00, 0x22, 0x00, 0xee, 0x00, 0x00, 0x00, 0x00 },
{ 0xfd, 0xb1, 0x20, 0x0e, 0x11, 0xf0, 0x01, 0x00, 0x41, 0x00, 0x21, 0xff, 0x01, 0x00, 0x01, 0x00, 0x01, 0x7e, 0x71, 0x42, 0x12, 0x42, 0x12, 0x42, 0x14, 0x42, 0x10, 0x7e, 0x2c, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfd, 0xb2, 0x1f, 0x08, 0x11, 0x08, 0x11, 0x08, 0x1f, 0x08, 0x00, 0x7f, 0x3f, 0x89, 0x20, 0x89, 0x3f, 0x89, 0x20, 0x89, 0x3f, 0x91, 0x20, 0x91, 0x3f, 0x91, 0x0a, 0x21, 0x11, 0x21, 0x60, 0xce, 0x00, 0x00 },
{ 0xfd, 0xb3, 0x07, 0x10, 0x78, 0x10, 0x08, 0x10, 0x7f, 0x90, 0x08, 0x7e, 0x7f, 0x12, 0x5b, 0x12, 0x49, 0x12, 0x7f, 0x12, 0x08, 0x12, 0x7f, 0x12, 0x08, 0x12, 0x7f, 0xa2, 0x55, 0x22, 0x55, 0x4c, 0x00, 0x00 },
{ 0xfd, 0xb4, 0x10, 0x00, 0x10, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x7c, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x11, 0xfe, 0x11, 0x02, 0x1d, 0xfe, 0x71, 0x02, 0x01, 0xfe, 0x00, 0x48, 0x00, 0x84, 0x03, 0x03, 0x00, 0x00 },
{ 0xfd, 0xb5, 0x10, 0x0e, 0x13, 0xf0, 0x10, 0x20, 0x13, 0xff, 0x7c, 0x20, 0x13, 0xfe, 0x12, 0xaa, 0x12, 0x22, 0x13, 0xfe, 0x1c, 0x20, 0x71, 0xfe, 0x00, 0x20, 0x03, 0xff, 0x02, 0x92, 0x04, 0x49, 0x00, 0x00 },
{ 0xfd, 0xb6, 0x0f, 0xf8, 0x01, 0x08, 0x7f, 0xff, 0x01, 0x08, 0x0f, 0xf8, 0x02, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x14, 0x04, 0x64, 0x04, 0x07, 0xfc, 0x00, 0x00, 0x12, 0x24, 0x11, 0x12, 0x21, 0x12, 0x00, 0x00 },
{ 0xfd, 0xb7, 0x00, 0xf8, 0x1f, 0x00, 0x01, 0x00, 0x7f, 0xfe, 0x01, 0x00, 0x1f, 0xf8, 0x19, 0x28, 0x15, 0x48, 0x1f, 0xf8, 0x01, 0x00, 0x3f, 0xfc, 0x01, 0x00, 0x7f, 0xfe, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xb8, 0x10, 0x1c, 0x10, 0xe0, 0x10, 0x20, 0x57, 0xff, 0x58, 0x20, 0x53, 0xfe, 0x52, 0xaa, 0x12, 0x22, 0x13, 0xfe, 0x10, 0x20, 0x29, 0xfe, 0x24, 0x20, 0x23, 0xff, 0x42, 0x92, 0x44, 0x49, 0x00, 0x00 },
{ 0xfd, 0xb9, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0xfc, 0x3f, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x12, 0xa4, 0x1f, 0xfc, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x7f, 0xff, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xba, 0x00, 0x00, 0x3c, 0x41, 0x00, 0x49, 0x7e, 0x49, 0x00, 0x49, 0x3c, 0x49, 0x00, 0x49, 0x3c, 0x49, 0x00, 0x49, 0x00, 0x49, 0x3c, 0x49, 0x24, 0x49, 0x24, 0x89, 0x24, 0x81, 0x3d, 0x01, 0x00, 0x00 },
{ 0xfd, 0xbb, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x10, 0x04, 0x7f, 0xff, 0x40, 0x81, 0x5f, 0xfd, 0x10, 0x84, 0x1f, 0xfc, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00 },
{ 0xfd, 0xbc, 0x04, 0x20, 0x7f, 0xff, 0x04, 0x20, 0x1f, 0xfc, 0x12, 0x44, 0x1f, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0x40, 0x01, 0x5f, 0xfd, 0x04, 0x40, 0x0f, 0x4c, 0x35, 0x70, 0x06, 0x42, 0x38, 0x3e, 0x00, 0x00 },
{ 0xfd, 0xbd, 0x00, 0x10, 0x00, 0x10, 0x79, 0xff, 0x49, 0x01, 0x49, 0x7d, 0x48, 0x00, 0x48, 0xfe, 0x48, 0x82, 0x48, 0x82, 0x48, 0xfe, 0x48, 0x82, 0x78, 0x82, 0x00, 0xfe, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00 },
{ 0xfd, 0xbe, 0x00, 0x20, 0x00, 0x20, 0x7b, 0xff, 0x4a, 0x01, 0x4a, 0x01, 0x48, 0xfc, 0x78, 0x00, 0x48, 0xfc, 0x48, 0x84, 0x48, 0xfc, 0x48, 0x84, 0x78, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00 },
{ 0xfd, 0xbf, 0x10, 0x20, 0x10, 0x20, 0x11, 0xfe, 0x15, 0x02, 0x54, 0x00, 0x58, 0xfc, 0x50, 0x00, 0x10, 0xfc, 0x10, 0x84, 0x10, 0xfc, 0x18, 0x84, 0x24, 0x84, 0x24, 0xfc, 0x20, 0x00, 0x43, 0xff, 0x00, 0x00 },
{ 0xfd, 0xc0, 0x04, 0x10, 0x7f, 0xff, 0x04, 0x10, 0x00, 0x80, 0x7f, 0xff, 0x40, 0x01, 0x4f, 0xf9, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00 },
{ 0xfd, 0xc1, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x08, 0x08, 0x7f, 0xff, 0x08, 0x08, 0x08, 0x08, 0x10, 0x08, 0x10, 0x08, 0x20, 0x08, 0x40, 0x08, 0x00, 0x00 },
{ 0xfd, 0xc2, 0x00, 0x40, 0x00, 0xf8, 0x78, 0x88, 0x49, 0xf8, 0x48, 0x10, 0x4f, 0xff, 0x48, 0x40, 0x49, 0xa2, 0x48, 0x24, 0x48, 0xd8, 0x4b, 0x38, 0x78, 0x54, 0x01, 0x92, 0x06, 0x11, 0x00, 0x60, 0x00, 0x00 },
{ 0xfd, 0xc3, 0x08, 0x00, 0x33, 0x3c, 0x21, 0x24, 0x37, 0x24, 0x21, 0x25, 0x21, 0x45, 0x3f, 0x43, 0x00, 0x00, 0x00, 0x7e, 0x7f, 0x22, 0x08, 0x24, 0x08, 0x14, 0x0b, 0x18, 0x1c, 0x64, 0x61, 0x83, 0x00, 0x00 },
{ 0xfd, 0xc4, 0x02, 0x00, 0x03, 0xf0, 0x04, 0x20, 0x3f, 0xff, 0x00, 0x00, 0x7f, 0xff, 0x48, 0x89, 0x4f, 0xf9, 0x08, 0x88, 0x0f, 0xf8, 0x00, 0x80, 0x3f, 0xff, 0x02, 0xa0, 0x0c, 0x98, 0x30, 0x87, 0x00, 0x00 },
{ 0xfd, 0xc5, 0x11, 0x08, 0x15, 0x48, 0x25, 0x48, 0x27, 0xdf, 0x49, 0x12, 0x0a, 0x22, 0x14, 0xd2, 0x13, 0x12, 0x32, 0x54, 0x57, 0xd4, 0x11, 0x08, 0x15, 0x48, 0x15, 0x54, 0x15, 0x22, 0x11, 0x41, 0x00, 0x00 },
{ 0xfd, 0xc6, 0x10, 0x00, 0x11, 0xff, 0x11, 0x01, 0x10, 0x10, 0x7d, 0xff, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x92, 0x1c, 0xfe, 0x70, 0x92, 0x10, 0xfe, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x30, 0x10, 0x00, 0x00 },
{ 0xfd, 0xc7, 0x00, 0x00, 0x7b, 0xff, 0x4a, 0x01, 0x48, 0x20, 0x49, 0xfe, 0x48, 0x20, 0x79, 0xfc, 0x49, 0x24, 0x49, 0xfc, 0x49, 0x24, 0x49, 0xfc, 0x78, 0x20, 0x03, 0xff, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00 },
{ 0xfd, 0xc8, 0x10, 0x00, 0x11, 0xff, 0x11, 0x01, 0x15, 0x11, 0x54, 0xfe, 0x58, 0x10, 0x50, 0xfe, 0x10, 0x92, 0x10, 0xfe, 0x10, 0x92, 0x28, 0xfe, 0x24, 0x10, 0x25, 0xff, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xfd, 0xc9, 0x00, 0x10, 0x3c, 0x10, 0x00, 0xfc, 0x7e, 0x24, 0x01, 0xff, 0x3c, 0x00, 0x00, 0x7e, 0x3c, 0x42, 0x00, 0x7e, 0x00, 0x08, 0x3c, 0xfe, 0x24, 0x48, 0x25, 0xff, 0x24, 0x08, 0x3c, 0x08, 0x00, 0x00 },
{ 0xfd, 0xca, 0x08, 0x00, 0x08, 0xff, 0x4a, 0x81, 0x2a, 0x10, 0x2a, 0xff, 0x08, 0x10, 0x7f, 0x7e, 0x14, 0x52, 0x14, 0x7e, 0x14, 0x52, 0x15, 0x7e, 0x16, 0x10, 0x24, 0xff, 0x20, 0x10, 0x40, 0x10, 0x00, 0x00 },
{ 0xfd, 0xcb, 0x00, 0x40, 0x3f, 0xff, 0x22, 0x08, 0x2f, 0xbf, 0x22, 0x08, 0x2a, 0xaa, 0x2a, 0xab, 0x32, 0x00, 0x20, 0x3c, 0x27, 0xc0, 0x20, 0x7e, 0x2f, 0xc0, 0x40, 0x7e, 0x4f, 0xc1, 0x00, 0x7f, 0x00, 0x00 },
{ 0xfd, 0xcc, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x10, 0x20, 0x37, 0xff, 0x30, 0x20, 0x50, 0x70, 0x10, 0x70, 0x10, 0xa8, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x14, 0x21, 0x10, 0x20, 0x10, 0x20, 0x00, 0x00 },
{ 0xfd, 0xcd, 0x10, 0x48, 0x10, 0xff, 0x11, 0x88, 0x7e, 0xfe, 0x10, 0x88, 0x10, 0xfe, 0x10, 0x88, 0x1c, 0xff, 0x70, 0x00, 0x11, 0xfe, 0x10, 0x44, 0x10, 0x4f, 0x10, 0x91, 0x11, 0x01, 0x32, 0x0e, 0x00, 0x00 },
{ 0xfd, 0xce, 0x08, 0x20, 0x08, 0x20, 0x10, 0x20, 0x17, 0xff, 0x30, 0x20, 0x50, 0x70, 0x10, 0xa8, 0x11, 0x24, 0x12, 0x22, 0x14, 0x21, 0x10, 0x20, 0x00, 0x00, 0x12, 0x44, 0x21, 0x22, 0x41, 0x21, 0x00, 0x00 },
{ 0xfd, 0xcf, 0x00, 0x10, 0x7c, 0x10, 0x54, 0xfe, 0x54, 0x10, 0x54, 0x10, 0x7c, 0x10, 0x55, 0xff, 0x54, 0x00, 0x54, 0x10, 0x54, 0x10, 0x7c, 0xfe, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x03, 0xff, 0x00, 0x00 },
{ 0xfd, 0xd0, 0x04, 0x00, 0x07, 0xbe, 0x04, 0x08, 0x3f, 0x88, 0x24, 0x88, 0x3e, 0x3f, 0x24, 0x90, 0x27, 0x90, 0x2a, 0x1e, 0x3f, 0xa2, 0x2a, 0x22, 0x2f, 0x82, 0x2a, 0x02, 0x4a, 0x04, 0x4f, 0x98, 0x00, 0x00 },
{ 0xfd, 0xd1, 0x10, 0x20, 0x10, 0x20, 0x18, 0x40, 0x55, 0xfe, 0x55, 0x52, 0x51, 0x52, 0x51, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x52, 0x11, 0x52, 0x13, 0xff, 0x00, 0x00 },
{ 0xfd, 0xd2, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x24, 0x7e, 0x18, 0x01, 0xff, 0x3c, 0x29, 0x00, 0x4a, 0x3d, 0x98, 0x00, 0xff, 0x00, 0xa9, 0x3c, 0xcf, 0x24, 0xbd, 0x24, 0xa5, 0x24, 0xbd, 0x3c, 0x83, 0x00, 0x00 },
{ 0xfd, 0xd3, 0x00, 0x10, 0x7e, 0x7e, 0x12, 0x42, 0x0c, 0x7e, 0x7f, 0x42, 0x15, 0x7e, 0x26, 0x40, 0x4c, 0x7f, 0x7f, 0x40, 0x55, 0x7f, 0x63, 0x01, 0x5d, 0x55, 0x55, 0x55, 0x5d, 0x81, 0x43, 0x06, 0x00, 0x00 },
{ 0xfd, 0xd4, 0x00, 0x20, 0x2c, 0x24, 0x23, 0x44, 0x20, 0x84, 0x21, 0x44, 0x26, 0x24, 0x38, 0x14, 0x20, 0x04, 0x3f, 0xfc, 0x04, 0x40, 0x04, 0x40, 0x08, 0x40, 0x08, 0x42, 0x10, 0x42, 0x60, 0x3e, 0x00, 0x00 },
{ 0xfd, 0xd5, 0x00, 0x00, 0x40, 0x12, 0x48, 0x12, 0x44, 0x22, 0x42, 0x22, 0x41, 0x42, 0x40, 0x82, 0x40, 0xc2, 0x41, 0x22, 0x42, 0x22, 0x44, 0x12, 0x58, 0x12, 0x40, 0x02, 0x40, 0x02, 0x7f, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xd6, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0f, 0xfe, 0x10, 0x02, 0x20, 0x82, 0x48, 0x82, 0x25, 0x22, 0x22, 0x22, 0x23, 0x22, 0x24, 0xa2, 0x28, 0xa2, 0x3f, 0xe4, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00 },
{ 0xfd, 0xd7, 0x21, 0x00, 0x11, 0x00, 0x0a, 0x00, 0x03, 0xfe, 0x44, 0x02, 0x24, 0x02, 0x10, 0x42, 0x01, 0x52, 0x04, 0x92, 0x14, 0x92, 0x15, 0x52, 0x24, 0x12, 0x27, 0xf4, 0x40, 0x04, 0x40, 0x18, 0x00, 0x00 },
{ 0xfd, 0xd8, 0x00, 0x40, 0x3c, 0x40, 0x24, 0xff, 0x24, 0x81, 0x25, 0x01, 0x3c, 0x51, 0x25, 0x55, 0x25, 0x25, 0x25, 0x55, 0x3d, 0x55, 0x25, 0x05, 0x25, 0xfd, 0x24, 0x01, 0x44, 0x01, 0x4c, 0x0e, 0x00, 0x00 },
{ 0xfd, 0xd9, 0x1f, 0xfc, 0x10, 0x84, 0x14, 0x94, 0x12, 0xa4, 0x12, 0xa4, 0x10, 0x84, 0x1f, 0xfc, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xda, 0x00, 0x0e, 0x7c, 0xf0, 0x44, 0x80, 0x44, 0x80, 0x44, 0x80, 0x44, 0xff, 0x7c, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x44, 0x88, 0x7c, 0x88, 0x01, 0x08, 0x01, 0x08, 0x02, 0x08, 0x00, 0x00 },
{ 0xfd, 0xdb, 0x06, 0x40, 0x38, 0x40, 0x20, 0x40, 0x20, 0xff, 0x20, 0x91, 0x3f, 0x92, 0x24, 0x90, 0x25, 0x10, 0x24, 0x10, 0x24, 0x28, 0x24, 0x28, 0x24, 0x44, 0x44, 0x44, 0x44, 0x82, 0x45, 0x01, 0x00, 0x00 },
{ 0xfd, 0xdc, 0x10, 0x0e, 0x10, 0xf0, 0x10, 0x80, 0x14, 0x80, 0x54, 0x80, 0x58, 0xff, 0x50, 0x88, 0x50, 0x88, 0x10, 0x88, 0x10, 0x88, 0x18, 0x88, 0x24, 0x88, 0x25, 0x08, 0x21, 0x08, 0x42, 0x08, 0x00, 0x00 },
{ 0xfd, 0xdd, 0x00, 0x40, 0x00, 0x40, 0x1f, 0xff, 0x10, 0x00, 0x53, 0xfc, 0x32, 0x04, 0x13, 0xfc, 0x12, 0x04, 0x33, 0xfc, 0x52, 0x20, 0x12, 0x22, 0x12, 0x14, 0x22, 0x08, 0x23, 0xc4, 0x4e, 0x03, 0x00, 0x00 },
{ 0xfd, 0xde, 0x00, 0x40, 0x00, 0x40, 0x78, 0xff, 0x49, 0x00, 0x4a, 0x00, 0x48, 0x00, 0x49, 0xfc, 0x48, 0x08, 0x48, 0x10, 0x48, 0x20, 0x48, 0x40, 0x78, 0x80, 0x01, 0x01, 0x01, 0x01, 0x00, 0xff, 0x00, 0x00 },
{ 0xfd, 0xdf, 0x10, 0x40, 0x10, 0x40, 0x10, 0x40, 0x54, 0xff, 0x54, 0x80, 0x55, 0x00, 0x54, 0xfc, 0x54, 0x04, 0x54, 0x08, 0x54, 0x10, 0x54, 0x20, 0x54, 0x40, 0x7c, 0x81, 0x00, 0x81, 0x00, 0x7f, 0x00, 0x00 },
{ 0xfd, 0xe0, 0x08, 0x40, 0x10, 0x40, 0x20, 0x40, 0x44, 0xfe, 0x28, 0x80, 0x11, 0x00, 0x24, 0xfc, 0x7c, 0x08, 0x14, 0x10, 0x10, 0x20, 0x58, 0x20, 0x54, 0x42, 0x54, 0x82, 0x10, 0x82, 0x10, 0x7e, 0x00, 0x00 },
{ 0xfd, 0xe1, 0x00, 0x10, 0x3e, 0x10, 0x00, 0x20, 0x7f, 0x3f, 0x00, 0x40, 0x3e, 0x80, 0x00, 0x7e, 0x3e, 0x02, 0x00, 0x04, 0x00, 0x08, 0x3e, 0x10, 0x22, 0x20, 0x22, 0x41, 0x22, 0x41, 0x3e, 0x3f, 0x00, 0x00 },
{ 0xfd, 0xe2, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xff, 0x10, 0x81, 0x10, 0x82, 0x20, 0x84, 0x40, 0x88, 0x00, 0x80, 0x01, 0x40, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x60, 0x03, 0x00, 0x00 },
{ 0xfd, 0xe3, 0x18, 0x40, 0x24, 0x40, 0x40, 0x40, 0x00, 0x7f, 0x7c, 0x91, 0x10, 0x92, 0x11, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x14, 0x28, 0x54, 0x28, 0x30, 0x44, 0x10, 0x44, 0x1c, 0x82, 0x61, 0x01, 0x00, 0x00 },
{ 0xfd, 0xe4, 0x08, 0x40, 0x08, 0x40, 0x7f, 0x40, 0x24, 0x7f, 0x14, 0x92, 0x14, 0x92, 0x7f, 0x14, 0x00, 0x10, 0x3e, 0x10, 0x22, 0x28, 0x22, 0x28, 0x3e, 0x44, 0x22, 0x44, 0x22, 0x82, 0x3f, 0x01, 0x00, 0x00 },
{ 0xfd, 0xe5, 0x00, 0x00, 0x03, 0xfc, 0x78, 0x84, 0x48, 0x84, 0x48, 0x88, 0x48, 0x88, 0x48, 0xfe, 0x49, 0x42, 0x49, 0x42, 0x79, 0x24, 0x01, 0x24, 0x02, 0x18, 0x02, 0x18, 0x04, 0x64, 0x09, 0x83, 0x00, 0x00 },
{ 0xfd, 0xe6, 0x10, 0x10, 0x10, 0x28, 0x10, 0x44, 0x58, 0x82, 0x55, 0x01, 0x54, 0xfe, 0x50, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xfe, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xe7, 0x20, 0x30, 0x10, 0x48, 0x08, 0x84, 0x01, 0x02, 0x42, 0x01, 0x21, 0xfe, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xfe, 0x11, 0x02, 0x21, 0x02, 0x21, 0x02, 0x41, 0x02, 0x41, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xe8, 0x00, 0x80, 0x01, 0x40, 0x06, 0x30, 0x1b, 0xec, 0x60, 0x03, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x3f, 0x7e, 0x09, 0x12, 0x33, 0x66, 0x05, 0x0a, 0x39, 0x72, 0x03, 0x06, 0x00, 0x00 },
{ 0xfd, 0xe9, 0x10, 0x00, 0x27, 0xf6, 0x24, 0x12, 0x25, 0xd2, 0x34, 0x16, 0x25, 0xd2, 0x25, 0x52, 0x35, 0x56, 0x25, 0xd2, 0x24, 0x12, 0x7f, 0xff, 0x00, 0x00, 0x04, 0x18, 0x18, 0x06, 0x60, 0x01, 0x00, 0x00 },
{ 0xfd, 0xea, 0x08, 0x20, 0x0b, 0xfe, 0x10, 0x20, 0x11, 0xfc, 0x20, 0x00, 0x31, 0xfc, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x88, 0x10, 0x50, 0x17, 0xff, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xfd, 0xeb, 0x00, 0x00, 0x47, 0xde, 0x25, 0x12, 0x05, 0x12, 0x17, 0xd2, 0x14, 0x5e, 0x27, 0xd0, 0x25, 0x11, 0x45, 0x11, 0x47, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xec, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x04, 0x10, 0x02, 0x20, 0x7f, 0xff, 0x00, 0x00, 0x1f, 0xfc, 0x10, 0x04, 0x1f, 0xfc, 0x00, 0x00 },
{ 0xfd, 0xed, 0x00, 0x20, 0x7b, 0xfe, 0x48, 0x88, 0x48, 0x50, 0x4f, 0xff, 0x48, 0x00, 0x49, 0xfc, 0x49, 0x04, 0x49, 0xfc, 0x49, 0x04, 0x79, 0xfc, 0x00, 0x22, 0x02, 0x91, 0x02, 0x85, 0x04, 0x7c, 0x00, 0x00 },
{ 0xfd, 0xee, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x3e, 0x3e, 0x00, 0x00, 0x3e, 0x3e, 0x22, 0x22, 0x3e, 0x3e, 0x08, 0x08, 0x7f, 0x7f, 0x08, 0x08, 0x3e, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x3e, 0x00, 0x00 },
{ 0xfd, 0xef, 0x10, 0x00, 0x10, 0xff, 0x10, 0x88, 0x7c, 0x88, 0x24, 0x88, 0x24, 0xae, 0x24, 0xa2, 0x24, 0xa2, 0x44, 0xa2, 0x68, 0xa2, 0x58, 0xae, 0x08, 0x88, 0x14, 0x88, 0x22, 0x88, 0x40, 0xff, 0x00, 0x00 },
{ 0xfd, 0xf0, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x7c, 0xfe, 0x24, 0x00, 0x24, 0xfe, 0x24, 0x82, 0x24, 0xfe, 0x44, 0x44, 0x68, 0x28, 0x59, 0xff, 0x08, 0x00, 0x14, 0xfe, 0x22, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xf1, 0x00, 0x08, 0x0f, 0x10, 0x00, 0xe0, 0x03, 0x18, 0x1c, 0x84, 0x00, 0x80, 0x7f, 0xff, 0x02, 0x40, 0x04, 0x40, 0x0f, 0xfc, 0x14, 0x44, 0x64, 0x44, 0x04, 0x44, 0x04, 0x5c, 0x00, 0x40, 0x00, 0x00 },
{ 0xfd, 0xf2, 0x00, 0x80, 0x7f, 0xff, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x20, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x82, 0x24, 0x49, 0x47, 0xf9, 0x00, 0x00 },
{ 0xfd, 0xf3, 0x10, 0x20, 0x17, 0xff, 0x10, 0x20, 0x1b, 0xfe, 0x54, 0x00, 0x55, 0xfc, 0x51, 0x04, 0x51, 0xfc, 0x10, 0x88, 0x17, 0xff, 0x10, 0x00, 0x11, 0xfc, 0x11, 0x04, 0x11, 0x04, 0x11, 0xfc, 0x00, 0x00 },
{ 0xfd, 0xf4, 0x04, 0x10, 0x07, 0x92, 0x04, 0x11, 0x3f, 0xd0, 0x24, 0x57, 0x3f, 0x38, 0x24, 0x92, 0x27, 0x92, 0x20, 0x14, 0x35, 0x4c, 0x3d, 0xc8, 0x25, 0x09, 0x45, 0xd5, 0x5e, 0x23, 0x40, 0x41, 0x00, 0x00 },
{ 0xfd, 0xf5, 0x00, 0x04, 0x00, 0xc8, 0x78, 0x30, 0x48, 0xc8, 0x4b, 0x24, 0x48, 0x40, 0x4f, 0xff, 0x78, 0x90, 0x49, 0x10, 0x4a, 0xfe, 0x4c, 0x92, 0x48, 0x92, 0x78, 0x92, 0x00, 0x96, 0x00, 0x10, 0x00, 0x00 },
{ 0xfd, 0xf6, 0x01, 0x10, 0x07, 0xfe, 0x70, 0x40, 0x53, 0xf8, 0x50, 0x40, 0x5f, 0xfe, 0x50, 0x80, 0x77, 0x14, 0x51, 0x10, 0x5f, 0xff, 0x55, 0x90, 0x59, 0x54, 0x77, 0x89, 0x04, 0x95, 0x01, 0xe3, 0x00, 0x00 },
{ 0xfd, 0xf7, 0x00, 0x00, 0x3f, 0xbe, 0x22, 0x22, 0x22, 0x22, 0x2f, 0xa2, 0x28, 0xbe, 0x2f, 0xa0, 0x22, 0x20, 0x22, 0x21, 0x3f, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x12, 0x22, 0x21, 0x11, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xf8, 0x00, 0x80, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x00, 0x0f, 0xf8, 0x08, 0x08, 0x0f, 0xf8, 0x02, 0x20, 0x7f, 0xff, 0x08, 0x08, 0x0f, 0xf8, 0x00, 0x00, 0x22, 0x22, 0x41, 0x11, 0x00, 0x00 },
{ 0xfd, 0xf9, 0x10, 0x10, 0x11, 0xff, 0x10, 0x10, 0x14, 0xfe, 0x54, 0x00, 0x58, 0xfe, 0x50, 0x82, 0x50, 0xfe, 0x10, 0x44, 0x10, 0x28, 0x19, 0xff, 0x24, 0x00, 0x24, 0xfe, 0x20, 0x82, 0x40, 0xfe, 0x00, 0x00 },
{ 0xfd, 0xfa, 0x08, 0x88, 0x2b, 0xff, 0x28, 0x20, 0x29, 0xfe, 0x3c, 0x20, 0x4b, 0xff, 0x48, 0x8a, 0x0b, 0xff, 0x0d, 0xc8, 0x1a, 0xaa, 0x6d, 0xca, 0x09, 0x04, 0x09, 0xe5, 0x0a, 0x2b, 0x08, 0xd1, 0x00, 0x00 },
{ 0xfd, 0xfb, 0x00, 0x10, 0x3e, 0xff, 0x00, 0x10, 0x00, 0x7e, 0x7f, 0x00, 0x08, 0x7e, 0x08, 0x42, 0x2a, 0x7e, 0x2a, 0x24, 0x2a, 0x28, 0x2a, 0xff, 0x4a, 0x00, 0x48, 0x7e, 0x08, 0x42, 0x08, 0x7e, 0x00, 0x00 },
{ 0xfd, 0xfc, 0x0c, 0xc2, 0x70, 0x34, 0x10, 0x1c, 0x10, 0x62, 0x7d, 0x91, 0x10, 0x10, 0x19, 0xff, 0x38, 0x20, 0x34, 0x48, 0x54, 0xff, 0x51, 0x49, 0x52, 0x49, 0x10, 0x49, 0x10, 0x4b, 0x10, 0x08, 0x00, 0x00 },
{ 0xfd, 0xfd, 0x04, 0x10, 0x3f, 0xfe, 0x00, 0x80, 0x1f, 0xfc, 0x00, 0x80, 0x7f, 0xff, 0x14, 0x24, 0x7f, 0xff, 0x15, 0x20, 0x24, 0xa2, 0x7f, 0x12, 0x10, 0x14, 0x3f, 0x09, 0x21, 0x15, 0x0e, 0x23, 0x00, 0x00 },
{ 0xfd, 0xfe, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x7d, 0xff, 0x00, 0x10, 0x3c, 0x10, 0x00, 0x10, 0x3c, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0x24, 0x82, 0x24, 0x82, 0x24, 0x82, 0x3c, 0xfe, 0x00, 0x00 },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\cred.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    NT LM Security Support Provider client stubs.

Author:

    Cliff Van Dyke (CliffV) 29-Jun-1993

Environment:  User Mode

Revision History:

--*/
#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#include <stddef.h>
#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>
#include <debug.h>

PSSP_CREDENTIAL
SspCredentialAllocateCredential(
    IN ULONG CredentialUseFlags
    )
{
    PSSP_CREDENTIAL Credential;

    //
    // Allocate a credential block and initialize it.
    //

    Credential = (PSSP_CREDENTIAL) SspAlloc (sizeof(SSP_CREDENTIAL));

    if ( Credential == NULL ) {
        return (NULL);
    }

    Credential->References = 1;

    Credential->CredentialUseFlags = CredentialUseFlags;

    Credential->Username = NULL;

    Credential->Domain = NULL;

    SspPrint(( SSP_API_MORE, "Added Credential 0x%lx\n", Credential ));

    return (Credential);
}


PSSP_CREDENTIAL
SspCredentialReferenceCredential(
    IN PCredHandle CredentialHandle,
    IN BOOLEAN RemoveCredential
    )

/*++

Routine Description:

    This routine checks to see if the Credential is from a currently
    active client, and references the Credential if it is valid.

    The caller may optionally request that the client's Credential be
    removed from the list of valid Credentials - preventing future
    requests from finding this Credential.

    For a client's Credential to be valid, the Credential value
    must be on our list of active Credentials.


Arguments:

    CredentialHandle - Points to the CredentialHandle of the Credential
        to be referenced.

    RemoveCredential - This boolean value indicates whether the caller
        wants the logon process's Credential to be removed from the list
        of Credentials.  TRUE indicates the Credential is to be removed.
        FALSE indicates the Credential is not to be removed.


Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

{
    PSSP_CREDENTIAL Credential;

    //
    // Sanity check
    //

    if ( CredentialHandle->dwLower != 0 ) {
        return NULL;
    }

    Credential = (SSP_CREDENTIAL *) CredentialHandle->dwUpper;

    Credential->References++;

    return Credential;
}


void
SspCredentialDereferenceCredential(
    PSSP_CREDENTIAL Credential
    )

/*++

Routine Description:

    This routine decrements the specified Credential's reference count.
    If the reference count drops to zero, then the Credential is deleted

Arguments:

    Credential - Points to the Credential to be dereferenced.


Return Value:

    None.

--*/

{
    ASSERT(Credential != NULL);

    //
    // Decrement the reference count
    //

    ASSERT( Credential->References >= 1 );

    Credential->References--;

    //
    // If the count dropped to zero, then run-down the Credential
    //

    if ( Credential->References == 0) {

        SspPrint(( SSP_API_MORE, "Deleting Credential 0x%lx\n",
                   Credential ));

#ifdef BL_USE_LM_PASSWORD
        if (Credential->LmPassword != NULL) {
            SspFree(Credential->LmPassword);
        }
#endif

        if (Credential->NtPassword != NULL) {
            SspFree(Credential->NtPassword);
        }

        if (Credential->Username != NULL) {
            SspFree(Credential->Username);
        }

        if (Credential->Domain != NULL) {
            SspFree(Credential->Domain);
        }

        if (Credential->Workstation != NULL) {
            SspFree(Credential->Workstation);
        }

        SspFree( Credential );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\crc32.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.g

Abstract:

    CRC-32 alogorithm prototypes and constants

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/



//////////////////////////////////////////////////////////////
//
// Function prototypes for CRC-32
//
//////////////////////////////////////////////////////////////


void
Crc32(  unsigned long crc,
        unsigned long cbBuffer,
        LPVOID pvBuffer,
        unsigned long SEC_FAR * pNewCrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

//
// init.c will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT          0x00000001 // Initialization
#define SSP_MISC          0x00000002 // Misc debug
#define SSP_API           0x00000004 // API processing
#define SSP_LPC           0x00000008 // LPC
#define SSP_CRITICAL      0x00000100 // Only real important errors

//
// Very verbose bits
//

#define SSP_API_MORE      0x04000000 // verbose API
#define SSP_LPC_MORE      0x08000000 // verbose LPC

//
// Control bits.
//

#define SSP_TIMESTAMP     0x20000000 // TimeStamp each output line
#define SSP_REQUEST_TARGET 0x40000000 // Force client to ask for target name
#define SSP_USE_OEM       0x80000000 // Force client to use OEM character set


//
// Name and directory of log file
//

#ifdef DEBUGRPC

#define ASSERT(con) \
    if (!(con)) \
	SspPrint((SSP_MISC, "Assert %s(%d): "#con"\n", __FILE__, __LINE__));

EXTERN DWORD SspGlobalDbflag;

#define IF_DEBUG(Function) \
     if (SspGlobalDbflag & SSP_ ## Function)

#define SspPrint(_x_) SspPrintRoutine _x_

void
SspPrintRoutine(
    IN ULONG DebugFlag,
    IN PCHAR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

#else

#define ASSERT(con)

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.

#define SspPrint(_x_)

#endif // DEBUGRPC

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\descrypt.h ===
#include <ntlmsspi.h>

#define ENCRYPT   0
#define DECRYPT   1

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0

unsigned FAR _cdecl
DES_CBC(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);


unsigned FAR _cdecl
DES_CBC_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);

unsigned FAR _cdecl
DES_ECB(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

unsigned FAR _cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\crypt.h ===
/*

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#define IN
#define OUT


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    char    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    char    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    char    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    unsigned long   Length;         // Number of valid bytes in buffer
    unsigned long   MaximumLength;  // Number of bytes pointed to by Buffer
    void *   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef char *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;

//
// NT password types.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;

#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;

#define NT_SESSION_KEY_LENGTH       (2 * CLEAR_BLOCK_LENGTH)



//
// Define the index type used to encrypt OWF Passwords
//

typedef long                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

BOOL
EncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

BOOL
DecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

BOOL
EncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

BOOL
EncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

BOOL
DecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Password hashing functions (One Way Function)
//

BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// OWF password comparison functions
//

BOOL
EqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

BOOL
CalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );

BOOL
CalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );

BOOL
CalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

BOOL
CalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
BOOL
EncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
BOOL
EncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

//
// Encrypt OwfPassword using an index as the key
//
BOOL
EncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\cred.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    cred.h

Abstract:

    SSP Credential.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSP_CRED_INCLUDED_
#define _NTLMSSP_CRED_INCLUDED_

#define SECPKG_CRED_OWF_PASSWORD        0x00000010

//
// Description of a credential.
//

typedef struct _SSP_CREDENTIAL {

    //
    // Global list of all Credentials.
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //

    WORD References;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    PCHAR Username;

    PCHAR Domain;

    PCHAR Workstation;

#ifdef BL_USE_LM_PASSWORD
    PLM_OWF_PASSWORD LmPassword;
#endif
    
    PNT_OWF_PASSWORD NtPassword;

} SSP_CREDENTIAL, *PSSP_CREDENTIAL;

PSSP_CREDENTIAL
SspCredentialAllocateCredential(
    IN ULONG CredentialUseFlags
    );

PSSP_CREDENTIAL
SspCredentialReferenceCredential(
    IN PCredHandle CredentialHandle,
    IN BOOLEAN RemoveCredential
    );

void
SspCredentialDereferenceCredential(
    PSSP_CREDENTIAL Credential
    );

#endif // ifndef _NTLMSSP_CRED_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\ntlmssp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    NT LM Security Support Provider client stubs.

Author:

    Cliff Van Dyke (CliffV) 29-Jun-1993

Environment:  User Mode

Revision History:

--*/

#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#ifdef WIN
#include <windows.h>
#include <ctype.h>
#endif

#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <ntlmssp.h>
#include <cred.h>
#include <context.h>
#include <debug.h>
#include <string.h>
#include <memory.h>
#include <cache.h>
#include <persist.h>
#include <rpc.h>
#include "crc32.h"
#include <md5.h>


#if 0
static SecurityFunctionTable FunctionTable =
{
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackages,
    0, // QueryCredentialsAttributes
    AcquireCredentialsHandle,
    FreeCredentialsHandle,
    0,
    InitializeSecurityContext,
    0,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributes,
    0,
    0,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfo,
    SealMessage,
    UnsealMessage
};


PSecurityFunctionTable SEC_ENTRY
InitSecurityInterface(
    )

/*++

Routine Description:

    RPC calls this function to get the addresses of all the other functions
    that it might call.

Arguments:

    None.

Return Value:

    A pointer to our static SecurityFunctionTable.  The caller need
    not deallocate this table.

--*/

{
    CacheInitializeCache();

    return &FunctionTable;
}
#endif   // 0

BOOL
__loadds
GetPassword(
    PSSP_CREDENTIAL Credential,
    int NeverPrompt
    )
{
#ifdef BL_USE_LM_PASSWORD
    if ((Credential->LmPassword != NULL) && (Credential->NtPassword != NULL)) {
        return (TRUE);
    }
#else
    if (Credential->NtPassword != NULL) {
        return (TRUE);
    }
#endif

    if (CacheGetPassword(Credential) == TRUE) {
        return (TRUE);
    }

    return (FALSE);
}


#if 0
BOOLEAN
SspTimeHasElapsed(
    IN DWORD StartTime,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds have elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started
    (in millisecond units).

    Timeout - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since StartTime.

--*/
{
    DWORD TimeNow;
    DWORD ElapsedTime;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //
    //

    if ( Timeout == 0xffffffff ) {
        return FALSE;
    }

    TimeNow = SspTicks();

    ElapsedTime = TimeNow - StartTime;

    if (ElapsedTime > Timeout) {
        return (TRUE);
    }

    return (FALSE);
}
#endif


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfo(
    IN SEC_CHAR SEC_FAR * PackageName,
    OUT PSecPkgInfo SEC_FAR *PackageInfo
    )

/*++

Routine Description:

    This API is intended to provide basic information about Security
    Packages themselves.  This information will include the bounds on sizes
    of authentication information, credentials and contexts.

    ?? This is a local routine rather than the real API call since the API
    call has a bad interface that neither allows me to allocate the
    buffer nor tells me how big the buffer is.  Perhaps when the real API
    is fixed, I'll make this the real API.

Arguments:

     PackageName - Name of the package being queried.

     PackageInfo - Returns a pointer to an allocated block describing the
        security package.  The allocated block must be freed using
        FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    SEC_CHAR *Where;

    //
    // Ensure the correct package name was passed in.
    //

    if ( _fstrcmp( PackageName, NTLMSP_NAME ) != 0 ) {
        return SEC_E_PACKAGE_UNKNOWN;
    }

    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) SspAlloc (sizeof(SecPkgInfo) +
                                           sizeof(NTLMSP_NAME) +
                                           sizeof(NTLMSP_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = NTLMSP_CAPABILITIES;
    (*PackageInfo)->wVersion = NTLMSP_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_WINNT;
    (*PackageInfo)->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

    Where = (SEC_CHAR *)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    _fstrcpy( Where, NTLMSP_NAME);
    Where += _fstrlen(Where) + 1;


    (*PackageInfo)->Comment = Where;
    _fstrcpy( Where, NTLMSP_COMMENT);
    Where += _fstrlen(Where) + 1;

    return SEC_E_OK;
}


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo * PackageInfo
    )

/*++

Routine Description:

    This API returns a list of Security Packages available to client (i.e.
    those that are either loaded or can be loaded on demand).  The caller
    must free the returned buffer with FreeContextBuffer.  This API returns
    a list of all the security packages available to a service.  The names
    returned can then be used to acquire credential handles, as well as
    determine which package in the system best satisfies the requirements
    of the caller.  It is assumed that all available packages can be
    included in the single call.

    This is really a dummy API that just returns information about this
    security package.  It is provided to ensure this security package has the
    same interface as the multiplexer DLL does.

Arguments:

     PackageCount - Returns the number of packages supported.

     PackageInfo - Returns an allocate array of structures
        describing the security packages.  The array must be freed
        using FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    SECURITY_STATUS SecStatus;

    //
    // Get the information for this package.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME,
                                              PackageInfo );

    if ( SecStatus != SEC_E_OK ) {
        return SecStatus;
    }

    *PackageCount = 1;

    return (SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandle(
    IN SEC_CHAR * PrincipalName,
    IN SEC_CHAR * PackageName,
    IN ULONG CredentialUseFlags,
    IN PLUID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    )

/*++

Routine Description:

    This API allows applications to acquire a handle to pre-existing
    credentials associated with the user on whose behalf the call is made
    i.e. under the identity this application is running.  These pre-existing
    credentials have been established through a system logon not described
    here.  Note that this is different from "login to the network" and does
    not imply gathering of credentials.

    Note for DOS we will ignore the previous note.  On DOS we will gather
    logon credentials through the AuthData parameter.

    This API returns a handle to the credentials of a principal (user, client)
    as used by a specific security package.  This handle can then be used
    in subsequent calls to the Context APIs.  This API will not let a
    process obtain a handle to credentials that are not related to the
    process; i.e. we won't allow a process to grab the credentials of
    another user logged into the same machine.  There is no way for us
    to determine if a process is a trojan horse or not, if it is executed
    by the user.

Arguments:

    PrincipalName - Name of the principal for whose credentials the handle
        will reference.  Note, if the process requesting the handle does
        not have access to the credentials, an error will be returned.
        A null string indicates that the process wants a handle to the
        credentials of the user under whose security it is executing.

     PackageName - Name of the package with which these credentials will
        be used.

     CredentialUseFlags - Flags indicating the way with which these
        credentials will be used.

        #define     CRED_INBOUND        0x00000001
        #define     CRED_OUTBOUND       0x00000002
        #define     CRED_BOTH           0x00000003
        #define     CRED_OWF_PASSWORD   0x00000010

        The credentials created with CRED_INBOUND option can only be used
        for (validating incoming calls and can not be used for making accesses.
        CRED_OWF_PASSWORD means that the password in AuthData has already
        been through the OWF function.

    LogonId - Pointer to NT style Logon Id which is a LUID.  (Provided for
        file system ; processes such as network redirectors.)

    CredentialHandle - Returned credential handle.

    Lifetime - Time that these credentials expire. The value returned in
        this field depends on the security package.

Return Value:

    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
    SEC_E_NOT_OWNER -- caller does not own the specified credentials
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CREDENTIAL Credential = NULL;

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspAcquireCredentialHandle Entered\n" ));
#endif

    //
    // Validate the arguments
    //

    if ( _fstrcmp( PackageName, NTLMSP_NAME ) != 0 ) {
        return (SEC_E_PACKAGE_UNKNOWN);
    }

    if ( (CredentialUseFlags & SECPKG_CRED_OUTBOUND) &&
         ARGUMENT_PRESENT(PrincipalName) && *PrincipalName != L'\0' ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(LogonId) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(GetKeyArgument) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    //
    // Ensure at least one Credential use bit is set.
    //

    if ( (CredentialUseFlags & (SECPKG_CRED_INBOUND|SECPKG_CRED_OUTBOUND)) == 0 ) {
        SspPrint(( SSP_API,
            "SspAcquireCredentialHandle: invalid credential use.\n" ));
        SecStatus = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }

    //
    // Allocate a credential block and initialize it.
    //

    Credential = SspCredentialAllocateCredential(CredentialUseFlags);

    if ( Credential == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    SecStatus = CacheSetCredentials( AuthData, Credential );
    if (SecStatus != SEC_E_OK)
        goto Cleanup;

    //
    // Return output parameters to the caller.
    //

    CredentialHandle->dwUpper = (ULONG_PTR)Credential;

    CredentialHandle->dwLower = 0;
    Lifetime->HighPart = 0;
    Lifetime->LowPart = 0xffffffffL;

    SecStatus = SEC_E_OK;

    //
    // Free and locally used resources.
    //
Cleanup:

    if ( SecStatus != SEC_E_OK ) {

        if ( Credential != NULL ) {
            SspFree( Credential );
        }

    }

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspAcquireCredentialHandle returns 0x%x\n", SecStatus ));
#endif
    return SecStatus;
}



SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:

    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CREDENTIAL Credential;

    //
    // Initialization
    //

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspFreeCredentialHandle Entered\n" ));
#endif

    //
    // Find the referenced credential and delink it.
    //

    Credential = SspCredentialReferenceCredential(CredentialHandle, TRUE);

    if ( Credential == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    SspCredentialDereferenceCredential( Credential );
    SspCredentialDereferenceCredential( Credential );

    SecStatus = SEC_E_OK;

Cleanup:

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspFreeCredentialHandle returns 0x%x\n", SecStatus ));
#endif
    return SecStatus;
}


BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    OUT PVOID * TokenBuffer,
    OUT PULONG * TokenSize,
    IN BOOLEAN ReadonlyOK
    )

/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
        token. If not specified, TokenBuffer and TokenSize will be returned
        as NULL.

    TokenBuffer - Returns a pointer to the buffer for the token.

    TokenSize - Returns a pointer to the location of the size of the buffer.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

{
    ULONG i;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        *TokenSize = NULL;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != 0 ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_READONLY)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( !ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY) ) {
                return FALSE;
            }

            //
            // Return the requested information
            //

            *TokenBuffer = Buffer->pvBuffer;
            *TokenSize = &Buffer->cbBuffer;
            return TRUE;
        }

    }

    return FALSE;
}


SECURITY_STATUS
SspHandleFirstCall(
    IN PCredHandle CredentialHandle,
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the First Call part of InitializeSecurityContext.

Arguments:

    All arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS -- All OK
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;

    NEGOTIATE_MESSAGE NegotiateMessage;

    //
    // Initialization
    //

    *ContextAttributes = 0;

    //
    // Get a pointer to the credential
    //

    Credential = SspCredentialReferenceCredential(
                    CredentialHandle,
                    FALSE );

    if ( Credential == NULL ) {
        SspPrint(( SSP_API,
            "SspHandleFirstCall: invalid credential handle.\n" ));
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_OUTBOUND) == 0 ) {
        SspPrint(( SSP_API, "SspHandleFirstCall: invalid credential use.\n" ));
        SecStatus = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }


    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext();

    if ( Context == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    ContextHandle->dwUpper = (ULONG_PTR) Context;
    ContextHandle->dwLower = 0;

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & (ISC_REQ_ALLOCATE_MEMORY |
                            ISC_REQ_PROMPT_FOR_CREDS |
                            ISC_REQ_USE_SUPPLIED_CREDS )) != 0 ) {

        SspPrint(( SSP_API,
                   "SspHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    //
    // If this is the first call,
    //  build a Negotiate message.
    //
    // Offer to talk Oem character set.
    //

    _fstrcpy( NegotiateMessage.Signature, NTLMSSP_SIGNATURE );
    NegotiateMessage.MessageType = (ULONG)NtLmNegotiate;
    NegotiateMessage.NegotiateFlags = NTLMSSP_NEGOTIATE_OEM |
                                      NTLMSSP_NEGOTIATE_NTLM |
                                      NTLMSSP_NEGOTIATE_ALWAYS_SIGN;

    if (Credential->Domain == NULL) {
        NegotiateMessage.NegotiateFlags |= NTLMSSP_REQUEST_TARGET;
    }

    if ( *OutputTokenSize < sizeof(NEGOTIATE_MESSAGE) ) {
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    if (ContextReqFlags & (ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT)) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
        NegotiateMessage.NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN |
                                           NTLMSSP_NEGOTIATE_NT_ONLY;
    }

    if (ContextReqFlags & ISC_REQ_CONFIDENTIALITY) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
        NegotiateMessage.NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL |
                                            NTLMSSP_NEGOTIATE_NT_ONLY;
    }

    swaplong(NegotiateMessage.NegotiateFlags) ;
    swaplong(NegotiateMessage.MessageType) ;
    _fmemcpy(OutputToken, &NegotiateMessage, sizeof(NEGOTIATE_MESSAGE));

    *OutputTokenSize = sizeof(NEGOTIATE_MESSAGE);

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    Context->Credential = SspCredentialReferenceCredential(
                                                           CredentialHandle,
                                                           FALSE);


    SecStatus = SEC_I_CALLBACK_NEEDED;
    Context->State = NegotiateSentState;

    //
    // Free locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {

        if (SecStatus != SEC_I_CALLBACK_NEEDED) {
            SspContextDereferenceContext( Context );
        }
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    return SecStatus;

    UNREFERENCED_PARAMETER( InputToken );
    UNREFERENCED_PARAMETER( InputTokenSize );
}


SECURITY_STATUS
SspHandleChallengeMessage(
    IN PLUID LogonId,
    IN PCredHandle CredentialHandle,
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the Challenge message part of InitializeSecurityContext.

Arguments:

    LogonId -- LogonId of the calling process.

    All other arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    ULONG AuthenticateMessageSize;
    PCHAR Where;
#ifdef BL_USE_LM_PASSWORD
    LM_RESPONSE LmResponse;
#endif
    NT_RESPONSE NtResponse;
    PSTRING pString;

    //
    // Initialization
    //

    *ContextAttributes = 0;

    //
    // Find the currently existing context.
    //

    Context = SspContextReferenceContext( ContextHandle, FALSE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // If we have already sent the authenticate message, then this must be
    // RPC calling Initialize a third time to re-authenticate a connection.
    // This happens when a new interface is called over an existing
    // connection.  What we do here is build a NULL authenticate message
    // that the server will recognize and also ignore.
    //

    if ( Context->State == AuthenticateSentState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        //
        // To make sure this is the intended meaning of the call, check
        // that the input token is NULL.
        //

        if ( (InputTokenSize != 0) || (InputToken != NULL) ) {

            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if ( *OutputTokenSize < sizeof(NullMessage) ) {

            SecStatus = SEC_E_BUFFER_TOO_SMALL;

        } else {

            _fstrcpy( NullMessage.Signature, NTLMSSP_SIGNATURE );
            NullMessage.MessageType = NtLmAuthenticate;
            swaplong(NullMessage.MessageType) ;

            _fmemset(&NullMessage.LmChallengeResponse, 0, 5*sizeof(STRING));
            *OutputTokenSize = sizeof(NullMessage);
            _fmemcpy(OutputToken, &NullMessage, sizeof(NullMessage));
            SecStatus = SEC_E_OK;
        }

        goto Cleanup;

    }


    if ( Context->State != NegotiateSentState ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "Context not in NegotiateSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & (ISC_REQ_ALLOCATE_MEMORY |
                            ISC_REQ_PROMPT_FOR_CREDS |
                            ISC_REQ_USE_SUPPLIED_CREDS )) != 0 ) {

        SspPrint(( SSP_API,
                   "SspHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    if (ContextReqFlags & (ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT)) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;

    }

    if (ContextReqFlags & ISC_REQ_CONFIDENTIALITY) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
    }
    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    //  the credential is implied by the Context.
    //  We could double check that the Credential Handle is either NULL or
    //  correct.  However, our implementation doesn't maintain a close
    //  association between the two (actually no association) so checking
    //  would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    ASSERT(Context->Credential != NULL);

    Credential = Context->Credential;

    //
    // Get the ChallengeMessage.
    //

    if ( InputTokenSize < sizeof(CHALLENGE_MESSAGE) ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( InputTokenSize > NTLMSSP_MAX_MESSAGE_SIZE ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "InputTokenSize > NTLMSSP_MAX_MESSAGE_SIZE\n" ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    ChallengeMessage = (PCHALLENGE_MESSAGE) InputToken;
    swaplong(ChallengeMessage->MessageType) ;
    swaplong(ChallengeMessage->NegotiateFlags) ;

    if ( _fstrncmp( ChallengeMessage->Signature,
                  NTLMSSP_SIGNATURE,
                  sizeof(NTLMSSP_SIGNATURE)) != 0 ||
        ChallengeMessage->MessageType != NtLmChallenge ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "InputToken has invalid NTLMSSP signature\n" ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Only negotiate OEM
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (UNICODE) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Check whether the server negotiated ALWAYS_SIGN
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    }

    //
    // Only negotiate NTLM
    //

    if ( ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE ) &&
        !( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (NETWARE) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

#if 0
    //
    // Make sure that if we are signing or sealing we only have to use the
    // LM key
    //

    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL)) &&
        !(ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY))
    {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (Sign or Seal but no LM key) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }
#endif

    if (Credential->Domain == NULL) {

        ASSERT(ChallengeMessage->TargetName.Length != 0);

        Credential->Domain = SspAlloc(ChallengeMessage->TargetName.Length + 1);
        if (Credential->Domain == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        pString = &ChallengeMessage->TargetName;

#if defined(_WIN64)
        _fmemcpy(Credential->Domain, (PCHAR)ChallengeMessage + (ULONG)((__int64)pString->Buffer), pString->Length);
#else
        _fmemcpy(Credential->Domain, (PCHAR)ChallengeMessage + (ULONG)pString->Buffer, pString->Length);
#endif

        Credential->Domain[pString->Length] = '\0';
    }

    if (GetPassword(Credential, 0) == FALSE) {
        SecStatus = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

#ifdef BL_USE_LM_PASSWORD
    if (CalculateLmResponse((PLM_CHALLENGE)ChallengeMessage->Challenge, Credential->LmPassword, &LmResponse) == FALSE) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }
#endif

    if (CalculateNtResponse((PNT_CHALLENGE)ChallengeMessage->Challenge, Credential->NtPassword, &NtResponse) == FALSE) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Allocate an authenticate message. Change this #if 0 and the next one
    // to send an LM challenge response also.
    //

#ifdef BL_USE_LM_PASSWORD
    AuthenticateMessageSize = sizeof(*AuthenticateMessage)+LM_RESPONSE_LENGTH+NT_RESPONSE_LENGTH;
#else
    AuthenticateMessageSize = sizeof(*AuthenticateMessage)+NT_RESPONSE_LENGTH;
#endif

    if (Credential->Domain != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Domain);
    }
    if (Credential->Username != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Username);
    }
    if (Credential->Workstation != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Workstation);
    }

    if ( AuthenticateMessageSize > *OutputTokenSize ) {
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE) SspAlloc ((int)AuthenticateMessageSize );

    if ( AuthenticateMessage == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Build the authenticate message
    //

    _fstrcpy( AuthenticateMessage->Signature, NTLMSSP_SIGNATURE );
    AuthenticateMessage->MessageType = NtLmAuthenticate;
    swaplong(AuthenticateMessage->MessageType) ;

    Where = (PCHAR)(AuthenticateMessage+1);

#ifdef BL_USE_LM_PASSWORD
    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->LmChallengeResponse,
                         (PCHAR)&LmResponse,
                         LM_RESPONSE_LENGTH,
                         &Where);
#else
    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->LmChallengeResponse,
                         NULL,
                         0,
                         &Where);
#endif

    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->NtChallengeResponse,
                         (PCHAR)&NtResponse,
                         NT_RESPONSE_LENGTH,
                         &Where);

    if (Credential->Domain != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->DomainName,
                             Credential->Domain,
                             _fstrlen(Credential->Domain),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->DomainName,
                             NULL, 0, &Where);
    }

    if (Credential->Username != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->UserName,
                             Credential->Username,
                             _fstrlen(Credential->Username),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->UserName,
                             NULL, 0, &Where);
    }

    if (Credential->Workstation != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->Workstation,
                             Credential->Workstation,
                             _fstrlen(Credential->Workstation),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->Workstation,
                             NULL, 0, &Where);
    }

    _fmemcpy(OutputToken, AuthenticateMessage, (int)AuthenticateMessageSize);

    *OutputTokenSize = AuthenticateMessageSize;

    //
    // The session key is the password, so convert it to a rc4 key.
    //

    if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |
                                   NTLMSSP_NEGOTIATE_SEAL)) {

#ifdef BL_USE_LM_PASSWORD
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) {

            LM_RESPONSE SessionKey;
            LM_OWF_PASSWORD LmKey;
            UCHAR Key[LM_SESSION_KEY_LENGTH];

            //
            // The session key is the first 8 bytes of the challenge response,
            // re-encrypted with the password with the second 8 bytes set to 0xbd
            //

            _fmemcpy(&LmKey,Credential->LmPassword,LM_SESSION_KEY_LENGTH);

            _fmemset(   (PUCHAR)(&LmKey) + LM_SESSION_KEY_LENGTH,
                        0xbd,
                        LM_OWF_PASSWORD_LENGTH - LM_SESSION_KEY_LENGTH);

            if (CalculateLmResponse(    (PLM_CHALLENGE) &LmResponse,
                                        &LmKey,
                                        &SessionKey) == FALSE) {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

            _fmemcpy(Key,&SessionKey,5);

            ASSERT(LM_SESSION_KEY_LENGTH == 8);

            //
            // Put a well-known salt at the end of the key to limit
            // the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;

            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, LM_SESSION_KEY_LENGTH, Key);
            Context->Nonce = 0;

        } else
#endif
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NT_ONLY) {

            MD5_CTX Md5Context;
            USER_SESSION_KEY UserSessionKey;

            if (AuthenticateMessage->NtChallengeResponse.Length != NT_RESPONSE_LENGTH) {
                SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            CalculateUserSessionKeyNt(
                &NtResponse,
                Credential->NtPassword,
                &UserSessionKey);

            //
            // The NT session key is made by MD5'ing the challenge response,
            // user name, domain name, and nt user session key together.
            //
            _fmemset(&Md5Context, 0, sizeof(MD5_CTX));

            MD5Init(
                &Md5Context
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)&NtResponse,
                NT_RESPONSE_LENGTH
                );
            MD5Update(
                &Md5Context,
                Credential->Username,
                _fstrlen(Credential->Username)
                );
            MD5Update(
                &Md5Context,
                Credential->Domain,
                _fstrlen(Credential->Domain)
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)&UserSessionKey,
                NT_SESSION_KEY_LENGTH
                );
            MD5Final(
                &Md5Context
                );
            ASSERT(MD5DIGESTLEN == NT_SESSION_KEY_LENGTH);

            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, NT_SESSION_KEY_LENGTH, Md5Context.digest);
            Context->Nonce = 0;

        } else {
            USER_SESSION_KEY UserSessionKey;

            if (AuthenticateMessage->NtChallengeResponse.Length != NT_RESPONSE_LENGTH) {
                SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            CalculateUserSessionKeyNt(
                &NtResponse,
                Credential->NtPassword,
                &UserSessionKey);
            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, NT_SESSION_KEY_LENGTH, (PUCHAR) &UserSessionKey);
            Context->Nonce = 0;

        }

    }

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    SecStatus = SEC_E_OK;

    //
    // Free and locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {
        //
        // Don't allow this context to be used again.
        //
        if ( SecStatus == SEC_E_OK ) {
            Context->State = AuthenticateSentState;
        } else {
            Context->State = IdleState;
        }
        SspContextDereferenceContext( Context );
    }

    if ( AuthenticateMessage != NULL ) {
        SspFree( AuthenticateMessage );
    }

    return SecStatus;
}


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN SEC_CHAR * TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    This routine initiates the outbound security context from a credential
    handle.  This results in the establishment of a security context
    between the application and a remote peer.  The routine returns a token
    which must be passed to the remote peer which in turn submits it to the
    local security implementation via the AcceptSecurityContext() call.
    The token generated should be considered opaque by all callers.

    This function is used by a client to initialize an outbound context.
    For a two leg security package, the calling sequence is as follows: The
    client calls the function with OldContextHandle set to NULL and
    InputToken set either to NULL or to a pointer to a security package
    specific data structure.  The package returns a context handle in
    NewContextHandle and a token in OutputToken.  The handle can then be
    used for message APIs if desired.

    The OutputToken returned here is sent across to target server which
    calls AcceptSecuirtyContext() with this token as an input argument and
    may receive a token which is returned to the initiator so it can call
    InitializeSecurityContext() again.

    For a three leg (mutual authentication) security package, the calling
    sequence is as follows: The client calls the function as above, but the
    package will return SEC_I_CALLBACK_NEEDED.  The client then sends the
    output token to the server and waits for the server's reply.  Upon
    receipt of the server's response, the client calls this function again,
    with OldContextHandle set to the handle that was returned from the
    first call.  The token received from the server is supplied in the
    InputToken parameter.  If the server has successfully responded, then
    the package will respond with success, or it will invalidate the
    context.

    Initialization of security context may require more than one call to
    this function depending upon the underlying authentication mechanism as
    well as the "choices" indicated via ContextReqFlags.  The
    ContextReqFlags and ContextAttributes are bit masks representing
    various context level functions viz.  delegation, mutual
    authentication, confidentiality, replay detection and sequence
    detection.

    When ISC_REQ_PROMPT_FOR_CREDS flag is set the security package always
    prompts the user for credentials, irrespective of whether credentials
    are present or not.  If user indicated that the supplied credentials be
    used then they will be stashed (overwriting existing ones if any) for
    future use.  The security packages will always prompt for credentials
    if none existed, this optimizes for the most common case before a
    credentials database is built.  But the security packages can be
    configured to not do that.  Security packages will ensure that they
    only prompt to the interactive user, for other logon sessions, this
    flag is ignored.

    When ISC_REQ_USE_SUPPLIED_CREDS flag is set the security package always
    uses the credentials supplied in the InitializeSecurityContext() call
    via InputToken parameter.  If the package does not have any credentials
    available it will prompt for them and record it as indicated above.

    It is an error to set both these flags simultaneously.

    If the ISC_REQ_ALLOCATE_MEMORY was specified then the caller must free
    the memory pointed to by OutputToken by calling FreeContextBuffer().

    For example, the InputToken may be the challenge from a LAN Manager or
    NT file server.  In this case, the OutputToken would be the NTLM
    encrypted response to the challenge.  The caller of this API can then
    take the appropriate response (case-sensitive v.  case-insensitive) and
    return it to the server for an authenticated connection.


Arguments:

   CredentialHandle - Handle to the credentials to be used to
       create the context.

   OldContextHandle - Handle to the partially formed context, if this is
       a second call (see above) or NULL if this is the first call.

   TargetName - String indicating the target of the context.  The name will
       be security package specific.  For example it will be a fully
       qualified Cairo name for Kerberos package and can be UNC name or
       domain name for the NTLM package.

   ContextReqFlags - Requirements of the context, package specific.

      #define ISC_REQ_DELEGATE           0x00000001
      #define ISC_REQ_MUTUAL_AUTH        0x00000002
      #define ISC_REQ_REPLAY_DETECT      0x00000004
      #define ISC_REQ_SEQUENCE_DETECT    0x00000008
      #define ISC_REQ_CONFIDENTIALITY    0x00000010
      #define ISC_REQ_USE_SESSION_KEY    0x00000020
      #define ISC_REQ_PROMT_FOR__CREDS   0x00000040
      #define ISC_REQ_USE_SUPPLIED_CREDS 0x00000080
      #define ISC_REQ_ALLOCATE_MEMORY    0x00000100
      #define ISC_REQ_USE_DCE_STYLE      0x00000200

   Reserved1 - Reserved value, MBZ.

   TargetDataRep - Long indicating the data representation (byte ordering, etc)
        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
        by the transport indicating that the native format is in use.

   InputToken - Pointer to the input token.  In the first call this
       token can either be NULL or may contain security package specific
       information.

   Reserved2 - Reserved value, MBZ.

   NewContextHandle - New context handle.  If this is a second call, this
       can be the same as OldContextHandle.

   OutputToken - Buffer to receive the output token.

   ContextAttributes -Attributes of the context established.

      #define ISC_RET_DELEGATE             0x00000001
      #define ISC_RET_MUTUAL_AUTH          0x00000002
      #define ISC_RET_REPLAY_DETECT        0x00000004
      #define ISC_RET_SEQUENCE_DETECT      0x00000008
      #define ISC_REP_CONFIDENTIALITY      0x00000010
      #define ISC_REP_USE_SESSION_KEY      0x00000020
      #define ISC_REP_USED_COLLECTED_CREDS 0x00000040
      #define ISC_REP_USED_SUPPLIED_CREDS  0x00000080
      #define ISC_REP_ALLOCATED_MEMORY     0x00000100
      #define ISC_REP_USED_DCE_STYLE       0x00000200

   ExpirationTime - Expiration time of the context.

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;

    PVOID InputTokenBuffer;
    PULONG InputTokenSize;
    ULONG LocalInputTokenSize;

    PVOID OutputTokenBuffer;
    PULONG OutputTokenSize;

    SspPrint((SSP_API, "SspInitializeSecurityContext Entered\n"));

    //
    // Check argument validity
    //

    if (!ARGUMENT_PRESENT(OutputToken)) {
        return (ERROR_BAD_ARGUMENTS);
    }

#ifdef notdef  // ? RPC passes 0x10 or 0 here depending on attitude
    if ( TargetDataRep != SECURITY_NATIVE_DREP ) {
        return (STATUS_INVALID_PARAMETER);
    }
#else // notdef
    UNREFERENCED_PARAMETER( TargetDataRep );
#endif // notdef

    if ( !SspGetTokenBuffer( InputToken,
                             &InputTokenBuffer,
                             &InputTokenSize,
                             TRUE ) ) {
        return (SEC_E_INVALID_TOKEN);
    }

    if ( InputTokenSize == 0 ) {
        InputTokenSize = &LocalInputTokenSize;
        LocalInputTokenSize = 0;
    }

    if ( !SspGetTokenBuffer( OutputToken,
                             &OutputTokenBuffer,
                             &OutputTokenSize,
                             FALSE ) ) {
        return (SEC_E_INVALID_TOKEN);
    }

    //
    // If no previous context was passed in this is the first call.
    //

    if ( !ARGUMENT_PRESENT( OldContextHandle ) ) {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            return (SEC_E_INVALID_HANDLE);
        }

        return SspHandleFirstCall(
                                   CredentialHandle,
                                   NewContextHandle,
                                   ContextReqFlags,
                                   *InputTokenSize,
                                   InputTokenBuffer,
                                   OutputTokenSize,
                                   OutputTokenBuffer,
                                   ContextAttributes,
                                   ExpirationTime );

        //
        // If context was passed in, continue where we left off.
        //

    } else {

        *NewContextHandle = *OldContextHandle;

        return SspHandleChallengeMessage(
                                         NULL,
                                         CredentialHandle,
                                         NewContextHandle,
                                         ContextReqFlags,
                                         *InputTokenSize,
                                         InputTokenBuffer,
                                         OutputTokenSize,
                                         OutputTokenBuffer,
                                         ContextAttributes,
                                         ExpirationTime );
    }

    return (SecStatus);
}

#if 0

SECURITY_STATUS SEC_ENTRY
QueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    This API allows a customer of the security services to determine
    certain attributes of the context.  These are: sizes, names, and
    lifespan.

Arguments:

    ContextHandle - Handle to the context to query.

    Attribute - Attribute to query.

        #define SECPKG_ATTR_SIZES    0
        #define SECPKG_ATTR_NAMES    1
        #define SECPKG_ATTR_LIFESPAN 2

    Buffer - Buffer to copy the data into.  The buffer must be large enough
        to fit the queried attribute.

Return Value:

    SEC_E_OK - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_UNSUPPORTED_FUNCTION -- Function code is not supported

--*/

{
    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+20];
    PSecPkgContext_Names ContextNames;
    int ContextNamesSize;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    PSSP_CONTEXT Context = NULL;


    //
    // Initialization
    //

    SspPrint(( SSP_API, "SspQueryContextAttributes Entered\n" ));

    //
    // Find the currently existing context.
    //

    Context = SspContextReferenceContext( ContextHandle,
                                          FALSE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Handle each of the various queried attributes
    //

    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes.cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL ))
        {
            ContextSizes.cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes.cbMaxSignature = 0;
        }

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
        {
            ContextSizes.cbBlockSize = 1;
            ContextSizes.cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes.cbBlockSize = 0;
            ContextSizes.cbSecurityTrailer = 0;
        }

        _fmemcpy(Buffer, &ContextSizes, sizeof(ContextSizes));

        break;

    //
    // No one uses the function so don't go to the overhead of maintaining
    // the username in the context structure.
    //

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names)Buffer;
        ContextNames->sUserName = (SEC_CHAR *) SspAlloc(1);

        if (ContextNames->sUserName == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        *ContextNames->sUserName = '\0';

        break;

    case SECPKG_ATTR_LIFESPAN:

        // Use the correct times here
        ContextLifespan.tsStart = SspContextGetTimeStamp( Context, FALSE );
        ContextLifespan.tsExpiry = SspContextGetTimeStamp( Context, TRUE );

        _fmemcpy(Buffer, &ContextLifespan, sizeof(ContextLifespan));

        break;

    default:
        SecStatus = SEC_E_NOT_SUPPORTED;
        break;
    }


    //
    // Free local resources
    //
Cleanup:

    if ( Context != NULL ) {
        SspContextDereferenceContext( Context );
    }

    SspPrint(( SSP_API, "SspQueryContextAttributes returns 0x%x\n", SecStatus ));
    return SecStatus;
}
#endif

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext (
    PCtxtHandle ContextHandle
    )

/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context and generates a token which is passed to a remote peer
    so it too can remove the corresponding security context.

    This API terminates a context on the local machine, and optionally
    provides a token to be sent to the other machine.  The OutputToken
    generated by this call is to be sent to the remote peer (initiator or
    acceptor).  If the context was created with the I _REQ_ALLOCATE_MEMORY
    flag, then the package will allocate a buffer for the output token.
    Otherwise, it is the responsibility of the caller.

Arguments:

    ContextHandle - Handle to the context to delete

    TokenLength - Size of the output token (if any) that should be sent to
        the process at the other end of the session.

    Token - Pointer to the token to send.

Return Value:

    SEC_E_OK - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;

    //
    // Initialization
    //

    SspPrint(( SSP_API, "SspDeleteSecurityContext Entered\n" ));

    //
    // Find the currently existing context (and delink it).
    //

    Context = SspContextReferenceContext( ContextHandle,
                                          TRUE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto cleanup;
    } else {
        SspContextDereferenceContext( Context );
        SecStatus = SEC_E_OK;
    }

cleanup:

    if (Context != NULL) {

        SspContextDereferenceContext(Context);

        Context = NULL;
    }

    SspPrint(( SSP_API, "SspDeleteSecurityContext returns 0x%x\n", SecStatus ));
    return SecStatus;
}


SECURITY_STATUS SEC_ENTRY
FreeContextBuffer (
    void * ContextBuffer
    )

/*++

Routine Description:

    This API is provided to allow callers of security API such as
    InitializeSecurityContext() for free the memory buffer allocated for
    returning the outbound context token.

Arguments:

    ContextBuffer - Address of the buffer to be freed.

Return Value:

    SEC_E_OK - Call completed successfully

--*/

{
    //
    // The only allocated buffer that NtLmSsp currently returns to the caller
    // is from EnumeratePackages.  It uses LocalAlloc to allocate memory.  If
    // we ever need memory to be allocated by the service, we have to rethink
    // how this routine distinguishes between to two types of allocated memory.
    //

    SspFree( ContextBuffer );

    return (SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
ApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    )
{
#ifdef DEBUGRPC
    SspPrint(( SSP_API, "ApplyContextToken Called\n" ));
#endif // DEBUGRPC
    return SEC_E_UNSUPPORTED_FUNCTION;
    UNREFERENCED_PARAMETER( ContextHandle );
    UNREFERENCED_PARAMETER( Input );
}

void
SsprGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )
{
    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}

SECURITY_STATUS SEC_ENTRY
MakeSignature(
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    int Signature;
    ULONG i;

    pContext = SspContextReferenceContext(ContextHandle,FALSE);

    if (!pContext ||
        (pContext->Rc4Key == NULL && !(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)))
    {
        return(SEC_E_INVALID_HANDLE);
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN))
    {
        _fmemset(pSig,0,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLMSSP_SIGN_VERSION;
        swaplong(pSig->Version) ; // MACBUG
        SspContextDereferenceContext(pContext);
        return(SEC_E_OK);
    }
    //
    // required by CRC-32 algorithm
    //

    pSig->CheckSum = 0xffffffff;

    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], pSig);
        }
    }

    //
    // Required by CRC-32 algorithm
    //

    pSig->CheckSum ^= 0xffffffff;

    pSig->Nonce = pContext->Nonce++;
    pSig->Version = NTLMSSP_SIGN_VERSION; // MACBUG

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;
    swaplong(pSig->Version) ;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char SEC_FAR *) &pSig->RandomPad);
    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);


    SspContextDereferenceContext(pContext);
    return(SEC_E_OK);


}

SECURITY_STATUS SEC_ENTRY
VerifySignature(
    IN OUT PCtxtHandle ContextHandle,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    int Signature;
    ULONG i;


    UNREFERENCED_PARAMETER(pfQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle,FALSE);

    if (!pContext ||
        (pContext->Rc4Key == NULL && !(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)))
    {
        return(SEC_E_INVALID_HANDLE);
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;
    swaplong(pSig->Version) ;

    //
    // Check if this is just a trailer and not a real signature
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN))
    {
        SspContextDereferenceContext(pContext);
        _fmemset(&Sig,0,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        Sig.Version = NTLMSSP_SIGN_VERSION;
        if (!_fmemcmp(&Sig,pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE))
        {
            return(SEC_E_OK);
        }
        return(SEC_E_MESSAGE_ALTERED);
    }

    Sig.CheckSum = 0xffffffff;
    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], &Sig);
        }
    }

    Sig.CheckSum ^= 0xffffffff;
    Sig.Nonce = pContext->Nonce++;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char SEC_FAR *) &pSig->RandomPad);

    SspContextDereferenceContext(pContext);

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;

    if (pSig->CheckSum != Sig.CheckSum)
    {
        return(SEC_E_MESSAGE_ALTERED);
    }

    if (pSig->Nonce != Sig.Nonce)
    {
        return(SEC_E_OUT_OF_SEQUENCE);
    }

    return(SEC_E_OK);
}

SECURITY_STATUS SEC_ENTRY
SealMessage(
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    int Signature;
    ULONG i;

    UNREFERENCED_PARAMETER(fQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle, FALSE);

    if (!pContext || pContext->Rc4Key == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    //
    // required by CRC-32 algorithm
    //

    pSig->CheckSum = 0xffffffff;

    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], pSig);
            if (pMessage->pBuffers[i].cbBuffer) // rc4 fails with zero byte buffers
                {
                rc4(pContext->Rc4Key,
                    (int) pMessage->pBuffers[i].cbBuffer,
                    (PUCHAR) pMessage->pBuffers[i].pvBuffer );
                }
        }
    }

    //
    // Required by CRC-32 algorithm
    //

    pSig->CheckSum ^= 0xffffffff;

    pSig->Nonce = pContext->Nonce++;
    pSig->Version = NTLMSSP_SIGN_VERSION; // MACBUG

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;
    swaplong(pSig->Version) ;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (PUCHAR) &pSig->RandomPad);
    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    SspContextDereferenceContext(pContext);

    return(SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
UnsealMessage(
    IN OUT PCtxtHandle ContextHandle,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    int Signature;
    ULONG i;

    UNREFERENCED_PARAMETER(pfQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle, FALSE);

    if (!pContext || !pContext->Rc4Key)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    Sig.CheckSum = 0xffffffff;
    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            if (pMessage->pBuffers[i].cbBuffer)
                {
                rc4(pContext->Rc4Key,
                    (int) pMessage->pBuffers[i].cbBuffer,
                    (unsigned char *) pMessage->pBuffers[i].pvBuffer );
                }
            SsprGenCheckSum(&pMessage->pBuffers[i], &Sig);
        }
    }

    Sig.CheckSum ^= 0xffffffff;
    Sig.Nonce = pContext->Nonce++;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char *) &pSig->RandomPad);

    SspContextDereferenceContext(pContext);

    swaplong(pSig->Nonce) ;
    swaplong(pSig->CheckSum) ;

    if (pSig->Nonce != Sig.Nonce)
    {
        return(SEC_E_OUT_OF_SEQUENCE);
    }

    if (pSig->CheckSum != Sig.CheckSum)
    {
        return(SEC_E_MESSAGE_ALTERED);
    }

    return(SEC_E_OK);
}

#if 0
SECURITY_STATUS SEC_ENTRY
CompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    )
{
#ifdef DEBUGRPC
    SspPrint(( SSP_API, "CompleteAuthToken Called\n" ));
#endif // DEBUGRPC
    return SEC_E_UNSUPPORTED_FUNCTION;
    UNREFERENCED_PARAMETER( ContextHandle );
    UNREFERENCED_PARAMETER( BufferDescriptor );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\persist.h ===
/*****************************************************************/
/**		  Microsoft Windows for Workgroups		**/
/**	      Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/


/*
    persist.c
    Persistent Password caching support in the winnet driver (WfW) prototypes

    FILE HISTORY:

        davidar 12/30/93        Created

*/

BOOL
PersistIsCacheSupported(
    );

BOOL
PersistGetPassword(
    PSSP_CREDENTIAL Credential
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\boot\alloc.c ===
#include <bootdefs.h>

#define USE_BlAllocateHeap 1

extern    
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );
VOID DbgBreakPoint(VOID);

#if USE_BlAllocateHeap

PVOID
BlAllocateHeap (
    ULONG Size
    );

PVOID
SspAlloc(
    int Size
    )
{
    return BlAllocateHeap( Size );
}

void
SspFree(
    PVOID Buffer
    )
{
    //
    // Loader heap never frees.
    //
}

#else // USE_BlAllocateHeap

//
// Do a memory allocator out of a static buffer, because the Bl memory
// system gets reinitialized.
//

#define MEMORY_BUFFER_SIZE 2048
#define MEMORY_BLOCK_SIZE 8    // must be power of 2
#define MEMORY_BLOCK_MASK (((ULONG)-1) - (MEMORY_BLOCK_SIZE-1))

static UCHAR MemoryBuffer[MEMORY_BUFFER_SIZE];
static PUCHAR CurMemoryLoc = MemoryBuffer;

PVOID
SspAlloc(
    int Size
    )
{
    int RoundedUpSize = (Size + (MEMORY_BLOCK_SIZE-1)) & MEMORY_BLOCK_MASK;
    PVOID NewAlloc;

    if (((CurMemoryLoc + RoundedUpSize) - MemoryBuffer) > MEMORY_BUFFER_SIZE) {
        DbgPrint("!!! SspAlloc: Could not allocate %d bytes !!!\n", Size);
        return NULL;
    }

    NewAlloc = CurMemoryLoc;

    CurMemoryLoc += RoundedUpSize;
    
    return NewAlloc;
}

void
SspFree(
    PVOID Buffer
    )
{
    //
    // Should eventually really free things for reallocation!
    //
}

#endif // else USE_BlAllocateHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\sspstrng.c ===
#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#include <stddef.h>
#include <ntlmsspi.h>
#include <debug.h>
#include <memory.h>
#include <string.h>

#if 0
PSTRING
SspAllocateStringBlock(
    PVOID Value,
    int Length
    )
{
    PSTRING String;

    String = (PSTRING) SspAlloc (sizeof(STRING));
    if (String == NULL) {
        return (NULL);
    }

    String->Buffer = (PCHAR) SspAlloc (Length);
    if (String->Buffer == NULL) {
        SspFree (String);
        return (NULL);
    }

    String->Length = String->MaximumLength = Length;

    _fmemcpy(String->Buffer, Value, Length);

    return (String);
}

PSTRING
SspAllocateString(
    PVOID Value
    )
{
    int Length;

    Length = _fstrlen(Value);
    return (SspAllocateStringBlock(Value, Length));
}

void
SspFreeString(
    PSTRING * String
    )
{
    if (*String == NULL) {
        return;
    }

    if ((*String)->MaximumLength) {
        SspFree ((*String)->Buffer);
    }

    SspFree (*String);

    *String = NULL;
}


void
SspCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where,
    IN BOOLEAN Absolute
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.  The
    descriptor 'address' is an offset from the MessageBuffer unless 'Absolute'
    is TRUE.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer.

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

    Absolute - If TRUE, OutString->Buffer will be set to the actual buffer
        address rather than an offset.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString->Buffer != NULL ) {
        _fmemcpy( *Where, InString->Buffer, InString->Length );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = InString->Length;
    if ( Absolute ) {
        OutString->Buffer = *Where;
    } else {
        *(unsigned long *) &OutString->Buffer = *Where - ((PCHAR)MessageBuffer);
    }

    //
    // Update Where to point past the copied data.
    //

    *Where += InString->Length;
}
#endif   // 0

void
SspCopyStringFromRaw(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PCHAR InString,
    IN int InStringLength,
    IN OUT PCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.  The
    descriptor 'address' is an offset from the MessageBuffer.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer. (Always a relative Out).

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString != NULL ) {
        _fmemcpy( *Where, InString, InStringLength );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = (USHORT)InStringLength;
	swapshort(OutString->Length) ;
	swapshort(OutString->MaximumLength) ;

    *(unsigned long *) &OutString->Buffer = (ULONG)(*Where - ((PCHAR)MessageBuffer));
	swaplong(*(unsigned long *) &OutString->Buffer) ; //MACBUG: this is weird !!

    //
    // Update Where to point past the copied data.
    //

    *Where += InStringLength;
}







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\ntlmsspi.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmsspi.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSPI_INCLUDED_
#define _NTLMSSPI_INCLUDED_


#ifdef MAC
#define SEC_FAR
#define FAR
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fmemset memset
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrncmp strncmp
#endif

#ifdef DOS
#ifndef FAR
#define FAR far
#endif
#ifndef SEC_FAR
#define SEC_FAR FAR
#endif
#endif

//#include <sysinc.h>

#define MSV1_0_CHALLENGE_LENGTH 8

#ifndef IN
#define IN
#define OUT
#define OPTIONAL
#endif

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#define UNREFERENCED_PARAMETER(P)

#ifdef MAC
#define swaplong(Value) \
      	  Value =  (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8) \
             | (((Value) & 0x0000FF00) << 8) \
             | (((Value) & 0x000000FF) << 24))
#else
#define swaplong(Value)
#endif

#ifdef MAC
#define swapshort(Value) \
   Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))
#else
#define swapshort(Value)
#endif

#ifndef TRUE
typedef int BOOL;
#define FALSE 0
#define TRUE 1
#endif

typedef unsigned long ULONG, DWORD, *PULONG;
typedef unsigned long SEC_FAR *LPULONG;
typedef unsigned short USHORT, WORD;
typedef char CHAR, *PCHAR;
typedef unsigned char UCHAR, *PUCHAR;
typedef unsigned char SEC_FAR *LPUCHAR;
typedef void SEC_FAR *PVOID, *LPVOID;
typedef unsigned char BOOLEAN;
#ifndef BLDR_KERNEL_RUNTIME
typedef long LUID, *PLUID;
#endif

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

//
// Counted String
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    ULONG  Buffer;
} STRING, *PSTRING;

#ifndef BLDR_KERNEL_RUNTIME
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY;
#endif

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


//
// Maximum lifetime of a context
//
//#define NTLMSSP_MAX_LIFETIME (2*60*1000)L    // 2 minutes
#define NTLMSSP_MAX_LIFETIME 120000L    // 2 minutes


////////////////////////////////////////////////////////////////////////
//
// Opaque Messages passed between client and server
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_SIGNATURE "NTLMSSP"

//
// MessageType for the following messages.
//

typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate
} NTLM_MESSAGE_TYPE;

//
// Valid values of NegotiateFlags
//

#define NTLMSSP_NEGOTIATE_UNICODE 0x01      // Text strings are in unicode
#define NTLMSSP_NEGOTIATE_OEM     0x02      // Text strings are in OEM
#define NTLMSSP_REQUEST_TARGET    0x04      // Server should return its
                                            // authentication realm

#define NTLMSSP_NEGOTIATE_SIGN    0x10      // request message signing
#define NTLMSSP_NEGOTIATE_SEAL    0x20      // request message encrypting
#define NTLMSSP_RESERVED          0x40      // reserved for past use
#define NTLMSSP_NEGOTIATE_LM_KEY  0x80      // use LM session key

#define NTLMSSP_NEGOTIATE_NETWARE 0x100     // NetWare authentication
#define NTLMSSP_NEGOTIATE_NTLM    0x200     // NTLM authentication
#define NTLMSSP_NEGOTIATE_NT_ONLY 0x400     // NT authentication only (no LM)

#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED   0x1000  // Domain name supplied
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED 0x2000 // Workstation name supplied
#define NTLMSSP_NEGOTIATE_LOCAL_CALL  0x4000 // Indicates client/server are same machine
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN 0x8000 // Sign for all security leveles


#define NTLMSSP_NEGOTIATE_56                    0x10000000  // negotiate 56 bit encryption
#define NTLMSSP_NEGOTIATE_128                   0x20000000  // negotiate 128 bit encryption


//
// Valid target types returned by the server in Negotiate Flags
//

#define NTLMSSP_TARGET_TYPE_DOMAIN 0x10000  // TargetName is a domain name
#define NTLMSSP_TARGET_TYPE_SERVER 0x20000  // TargetName is a server name
#define NTLMSSP_TARGET_TYPE_SHARE  0x40000  // TargetName is a share name

//
// Opaque message returned from first call to InitializeSecurityContext
//
typedef struct _NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    ULONG NegotiateFlags;
} NEGOTIATE_MESSAGE, *PNEGOTIATE_MESSAGE;

//
// Opaque message returned from first call to AcceptSecurityContext
//
typedef struct _CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    STRING TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
} CHALLENGE_MESSAGE, *PCHALLENGE_MESSAGE;

//
// Opaque message returned from second call to InitializeSecurityContext
//
typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

//
// Size of the largest message
//  (The largest message is the AUTHENTICATE_MESSAGE)
//

#define NTLMSSP_MAX_MESSAGE_SIZE (sizeof(AUTHENTICATE_MESSAGE) + \
                                  8 + \
                                  (15 + 1) + \
                                  (20 + 1) + \
                                  (15 + 1) )

//
// Signature structure
//

typedef struct _NTLMSSP_MESSAGE_SIGNATURE {
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, * PNTLMSSP_MESSAGE_SIGNATURE;

#define NTLMSSP_MESSAGE_SIGNATURE_SIZE sizeof(NTLMSSP_MESSAGE_SIGNATURE)

#define NTLMSSP_SIGN_VERSION 1

#define NTLMSSP_KEY_SALT 0xbd

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

PVOID
SspAlloc(
    int Size
    );

void
SspFree(
    PVOID Buffer
    );

PSTRING
SspAllocateString(
    PVOID Value
    );

PSTRING
SspAllocateStringBlock(
    PVOID Value,
    int Length
    );

void
SspFreeString(
    PSTRING * String
    );

void
SspCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where,
    IN BOOLEAN Absolute
    );

void
SspCopyStringFromRaw(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PCHAR InString,
    IN int InStringLength,
    IN OUT PCHAR *Where
    );

DWORD
SspTicks(
    );

#endif // ifndef _NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\response.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        CalculateLmResponse


Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for RPC SSP)


Revision History:

--*/

#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#include <ntlmsspi.h>
#include <descrypt.h>
#include <crypt.h>
#include <string.h>

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



BOOL
CalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    TRUE - The function completed successfully. The response
                     is in LmResponse.

    FALSE - Something failed. The LmResponse is undefined.
--*/

{
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[0])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[1])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    if (DES_ECB_LM(ENCR_KEY,
                   (const char *)&Key,
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[2])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    return(TRUE);
}



BOOL
CalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )

/*++

Routine Description:

    Calculates the NT challenge response. Currently just calls the
    LM function.

--*/

{
    return CalculateLmResponse(
               (PLM_CHALLENGE)NtChallenge,
               (PLM_OWF_PASSWORD)NtOwfPassword,
               (PLM_RESPONSE)NtResponse);
}


BOOL
CalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    BOOL Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    Status = CalculateNtOwfPassword( &NtPassword,
                                     (PNT_OWF_PASSWORD)UserSessionKey
                                     );
    if (!Status) {
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (!_fmemcmp(UserSessionKey, &ErrorSessionKey, sizeof(*UserSessionKey))) {

        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

    }

    return(TRUE);

    UNREFERENCED_PARAMETER(LmResponse);
}



BOOL
CalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    return(CalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                     (PLM_OWF_PASSWORD)NtOwfPassword,
                                     UserSessionKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\ntlmssp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ntlmssp.h

Abstract:

    Externally visible definition of the NT Lanman Security Support Provider
    (NtLmSsp) Service.

Author:

    Cliff Van Dyke (cliffv) 01-Jul-1993

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Borrowed from the Cairo's ntlmssp.h by PeterWi.

--*/

#ifndef _NTLMSSP_
#define _NTLMSSP_

#include <security.h>
#include <spseal.h>
//
// Defines for SecPkgInfo structure returned by QuerySecurityPackageInfo
//

#undef NTLMSP_NAME
#define NTLMSP_NAME             "NTLM"
#define NTLMSP_COMMENT          "NTLM Security Package"

#define NTLMSP_CAPABILITIES     (SECPKG_FLAG_TOKEN_ONLY | \
                                 SECPKG_FLAG_INTEGRITY | \
                                 SECPKG_FLAG_PRIVACY | \
                                 SECPKG_FLAG_MULTI_REQUIRED | \
                                 SECPKG_FLAG_CONNECTION)

#define NTLMSP_VERSION          1
#define NTLMSP_MAX_TOKEN_SIZE 0x300

// includes that should go elsewhere.

//
// Move to secscode.h
//

#define SEC_E_PRINCIPAL_UNKNOWN SEC_E_UNKNOWN_CREDENTIALS
#define SEC_E_PACKAGE_UNKNOWN SEC_E_SECPKG_NOT_FOUND
#define SEC_E_BUFFER_TOO_SMALL SEC_E_INSUFFICIENT_MEMORY
#define SEC_I_CALLBACK_NEEDED SEC_I_CONTINUE_NEEDED
#define SEC_E_INVALID_CONTEXT_REQ SEC_E_NOT_SUPPORTED
#define SEC_E_INVALID_CREDENTIAL_USE SEC_E_NOT_SUPPORTED

//
// Move to security.h
//


#endif // _NTLMSSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\boot\cache.c ===
#include <bootdefs.h>
#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>
#include <rpc.h>

#define toupper(_c) ( ((_c) >= 'a' && (_c) <= 'z') ? ( (_c)-'a'+'A' ) : (_c) )

BOOL
SspGetWorkstation(
    PSSP_CREDENTIAL Credential
    );

static PSSP_CREDENTIAL Cache = NULL;

void
CacheInitializeCache(
    )
{
}

BOOL
CacheGetPassword(
    PSSP_CREDENTIAL Credential
    )
{
    if (Cache == NULL) {
        return (FALSE);
    }

#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword = SspAlloc (sizeof(LM_OWF_PASSWORD));
    if (Credential->LmPassword == NULL) {
        return (FALSE);
    }
#endif
    Credential->NtPassword = SspAlloc (sizeof(NT_OWF_PASSWORD));
    if (Credential->NtPassword == NULL) {
        return (FALSE);
    }
#ifdef BL_USE_LM_PASSWORD
    _fmemcpy((PCHAR)Credential->LmPassword, (PCHAR)Cache->LmPassword, sizeof(LM_OWF_PASSWORD));
#endif
    _fmemcpy((PCHAR)Credential->NtPassword, (PCHAR)Cache->NtPassword, sizeof(NT_OWF_PASSWORD));

    return (TRUE);
}

SECURITY_STATUS
CacheSetCredentials(
    IN PVOID        AuthData,
    PSSP_CREDENTIAL Credential
    )
{
    SEC_WINNT_AUTH_IDENTITY *Identity = AuthData;
    char                     TmpText[CLEAR_BLOCK_LENGTH*2];
    NT_PASSWORD              TmpNtPassword;
    WCHAR                    TmpUnicodeText[CLEAR_BLOCK_LENGTH*2];
    int                      Length;
    int                      i;

    if (Identity->Domain == NULL)
        return SEC_E_UNKNOWN_CREDENTIALS;

    Credential->Username    = NULL;
    Credential->Domain      = NULL;
#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword  = NULL;
#endif
    Credential->NtPassword  = NULL;
    Credential->Workstation = NULL;

    // If no identity is passed and there is no cached identity, give up.
    if (AuthData == NULL)
    {
      if (Cache == NULL)
        return SEC_E_UNKNOWN_CREDENTIALS;
    }

    // Save the latest authentication information.
    else
    {

      // If an old cache entry exists, release its strings.
      if (Cache != NULL)
      {
        if (Cache->Username != NULL)
            SspFree(Cache->Username);
        if (Cache->Domain != NULL)
            SspFree(Cache->Domain);
        if (Cache->Workstation != NULL)
            SspFree(Cache->Workstation);
#ifdef BL_USE_LM_PASSWORD
        if (Cache->LmPassword != NULL)
            SspFree(Cache->LmPassword);
#endif
        if (Cache->NtPassword != NULL)
            SspFree(Cache->NtPassword);
      }

      // Otherwise, allocate a cache entry
      else
      {
        Cache = (PSSP_CREDENTIAL) SspAlloc (sizeof(SSP_CREDENTIAL));
        if (Cache == NULL) {
          return (SEC_E_INSUFFICIENT_MEMORY);
        }
      }

      Cache->Username    = NULL;
      Cache->Domain      = NULL;
#ifdef BL_USE_LM_PASSWORD
      Cache->LmPassword  = NULL;
#endif
      Cache->NtPassword  = NULL;
      Cache->Workstation = NULL;

      Cache->Username = SspAlloc(_fstrlen(Identity->User) + 1);
      if (Cache->Username == NULL) {
          goto cache_failure;
      }
      _fstrcpy(Cache->Username, Identity->User);

      Cache->Domain = SspAlloc(_fstrlen(Identity->Domain) + 1);
      if (Cache->Domain == NULL) {
          goto cache_failure;
      }
      _fstrcpy(Cache->Domain, Identity->Domain);

      // If netbios won't tell us the workstation name, make one up.
      if (!SspGetWorkstation(Cache))
      {
        Cache->Workstation = SspAlloc(_fstrlen("none") + 1);
        if (Cache->Workstation == NULL) {
            goto cache_failure;
        }
        _fstrcpy(Cache->Workstation, "none");
      }

#ifdef BL_USE_LM_PASSWORD
      Cache->LmPassword = SspAlloc (sizeof(LM_OWF_PASSWORD));
      if (Cache->LmPassword == NULL) {
          goto cache_failure;
      }
#endif
 
      Cache->NtPassword = SspAlloc (sizeof(NT_OWF_PASSWORD));
      if (Cache->NtPassword == NULL) {
          goto cache_failure;
      }
 
#ifdef ALLOW_NON_OWF_PASSWORD
      if ( (Credential->CredentialUseFlags & SECPKG_CRED_OWF_PASSWORD) == 0 ) {

        if (Identity->Password == NULL)
          Length = 0;
        else
          Length = _fstrlen(Identity->Password);
        if (Length  > CLEAR_BLOCK_LENGTH * 2)
          goto cache_failure;

        // Allow NULL and "\0" passwords by prefilling TmpText with and
        // empty string.
        if (Length == 0)
          TmpText[0] = 0;
        else
          for (i = 0; i <= Length; i++) {
            TmpText[i] = toupper(Identity->Password[i]);
            TmpUnicodeText[i] = (WCHAR)(Identity->Password[i]);
          }

#ifdef BL_USE_LM_PASSWORD
        CalculateLmOwfPassword((PLM_PASSWORD)TmpText, Cache->LmPassword);
#endif

        TmpNtPassword.Buffer = TmpUnicodeText;
        TmpNtPassword.Length = Length * sizeof(WCHAR);
        TmpNtPassword.MaximumLength = sizeof(TmpUnicodeText);
        CalculateNtOwfPassword(&TmpNtPassword, Cache->NtPassword);

      } else
#endif
      {

        //
        // In this case the passed-in password is the LM and NT OWF
        // passwords concatenated together.
        //

#ifdef BL_USE_LM_PASSWORD
        _fmemcpy(Cache->LmPassword, Identity->Password, sizeof(LM_OWF_PASSWORD));
#endif
        _fmemcpy(Cache->NtPassword, Identity->Password + sizeof(LM_OWF_PASSWORD), sizeof(NT_OWF_PASSWORD));

      }

    }

    // Copy the credentials for the caller.
    Credential->Username = SspAlloc(_fstrlen(Cache->Username) + 1);
    if (Credential->Username == NULL) {
        goto out_failure;
    }
    _fstrcpy(Credential->Username, Cache->Username);

    if (_fstrcmp(Cache->Domain, "WORKGROUP") != 0) {
        Credential->Domain = SspAlloc(_fstrlen(Cache->Domain) + 1);
        if (Credential->Domain == NULL) {
            goto out_failure;
        }
        _fstrcpy(Credential->Domain, Cache->Domain);
    }

    Credential->Workstation = SspAlloc(_fstrlen(Cache->Workstation) + 1);
    if (Credential->Workstation == NULL) {
        goto out_failure;
    }
    _fstrcpy(Credential->Workstation, Cache->Workstation);

#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword = SspAlloc(sizeof(LM_OWF_PASSWORD));
    if (Credential->LmPassword == NULL) {
        goto out_failure;
    }
    _fmemcpy(Credential->LmPassword, Cache->LmPassword, sizeof(LM_OWF_PASSWORD));
#endif

    Credential->NtPassword = SspAlloc(sizeof(NT_OWF_PASSWORD));
    if (Credential->NtPassword == NULL) {
        goto out_failure;
    }
    _fmemcpy(Credential->NtPassword, Cache->NtPassword, sizeof(NT_OWF_PASSWORD));

    return (SEC_E_OK);

cache_failure:

    if (Cache->Username != NULL) {
        SspFree(Cache->Username);
    }

    if (Cache->Domain != NULL) {
        SspFree(Cache->Domain);
    }

    if (Cache->Workstation != NULL) {
        SspFree(Cache->Workstation);
    }

#ifdef BL_USE_LM_PASSWORD
    if (Cache->LmPassword != NULL) {
        SspFree(Cache->LmPassword);
    }
#endif

    if (Cache->NtPassword != NULL) {
        SspFree(Cache->NtPassword);
    }

    SspFree(Cache);
    Cache = NULL;

out_failure:

    if (Credential->Username != NULL) {
        SspFree(Credential->Username);
        Credential->Username = NULL;
    }

    if (Credential->Domain != NULL) {
        SspFree(Credential->Domain);
        Credential->Domain = NULL;
    }

    if (Credential->Workstation != NULL) {
        SspFree(Credential->Workstation);
        Credential->Workstation = NULL;
    }

#ifdef BL_USE_LM_PASSWORD
    if (Credential->LmPassword != NULL) {
        SspFree(Credential->LmPassword);
        Credential->LmPassword = NULL;
    }
#endif

    if (Credential->NtPassword != NULL) {
        SspFree(Credential->NtPassword);
        Credential->NtPassword = NULL;
    }

    return (SEC_E_INSUFFICIENT_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        CalculateLmOwfPassword

Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for WfW RPC SSP)

Revision History:

--*/
#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#include <ntlmsspi.h>
#include <descrypt.h>
#include <crypt.h>
#include <md4.h>
#include <string.h>


BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
    password is in LmOwfPassword.

    FALSE - Something failed. The LmOwfPassword is undefined.
--*/

{
    char StdEncrPwd[] = "KGS!@#$%";
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[0],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[0]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[1],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[1]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(TRUE);
}



BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);

    if (sizeof(*NtOwfPassword) != sizeof(MD4_Context.digest)) {
        return(FALSE);
    }

    memcpy((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest, sizeof(*NtOwfPassword));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\boot\ticks.c ===
#include <bootdefs.h>

DWORD
SspTicks(
    )
{
    // Seems good enough, it claims to be in seconds.

    return ArcGetRelativeTime();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootssp\boot\getuser.c ===
#include <bootdefs.h>
#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>

BOOL
SspGetWorkstation(
    PSSP_CREDENTIAL Credential
    )
{
    //
    // We don't necessarily know this during boot. The NTLMSSP
    // package will use "none" if we return FALSE here.
    //

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=bootvid

TARGETNAME=bootvid
TARGETPATH=obj
TARGETTYPE=HAL
PASS1_PUBLISH={$(O)\bootvid.lib=$(PROJECT_LIB_PATH)\bootvid.lib}


TARGETLIBS=$(DDK_LIB_PATH)\hal.lib

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=..\..\..\ntos\inc;$(DDK_INC_PATH);$(HALKIT_INC_PATH)

SOURCES=..\bootvid.rc    \
        ..\bootvid.c     \
        ..\bootdata.c    \
        ..\vga.c

DLLDEF=..\bootvid.def

!if $(AXP64)
HALBASE=0xFFFFFFFF80010000
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\bootvid.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    bootvid.c

Abstract:

    This is the device independent portion of the graphical boot dll.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

#include <nthal.h>
#include <hal.h>
#include "cmdcnst.h"
#include <bootvid.h>
#include "vga.h"

extern USHORT VGA_640x480[];
extern USHORT AT_Initialization[];
extern int curr_x;
extern int curr_y;

PUCHAR VgaBase;
PUCHAR VgaRegisterBase;

NTSTATUS
InitBusCallback(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
{
    return STATUS_SUCCESS;
}

BOOLEAN
VidInitialize(
    BOOLEAN SetMode
    )

/*++

Routine Description:

    This routine checks for the existance of a VGA chip, and initializes
    it.

Arguments:

    SetMode - Set to true if you want this routine to initialize mode.

Return Value:

    TRUE  - if the boot driver found vga and initialized correctly,
    FALSE - otherwise.

--*/

{
    PHYSICAL_ADDRESS IoAddress;
    PHYSICAL_ADDRESS MemoryAddress;
    ULONG AddressSpace;
    PHYSICAL_ADDRESS TranslatedAddress;
    PUCHAR mappedAddress;
    ULONG_PTR TranslateContext;

    //
    // Saftey check.  Allows migration from old HalDisplayString
    // support to bootvid, if the HAL didn't supply the routine
    //
    //   HALPDISPATCH->HalFindBusAddressTranslation
    //
    // this routine cannot succeed.
    //

    if (!HALPDISPATCH->HalFindBusAddressTranslation) {

        return FALSE;
    }

    //
    // Start search with "no previous" context.
    //

    TranslateContext = 0;

    //
    // Set up the addresses we need to translate.
    //

    IoAddress.LowPart = 0x0;
    IoAddress.HighPart = 0;
    MemoryAddress.LowPart = 0xa0000;
    MemoryAddress.HighPart = 0;

    //
    // While there are more busses to examine try to map the VGA
    // registers.
    //

    while (TRUE) {

        AddressSpace = 1;       // we are requesting IO space.

        if (!HALPDISPATCH->HalFindBusAddressTranslation(
                               IoAddress,
                               &AddressSpace,
                               &TranslatedAddress,
                               &TranslateContext,
                               TRUE)) {

            //
            // Failed to find a bus with the VGA device on it.
            //

            return FALSE;
        }

        //
        // We were able to translate the address.  Now, map the
        // translated address.
        //

        if (AddressSpace & 0x1) {

            VgaRegisterBase = (PUCHAR)(DWORD_PTR) TranslatedAddress.QuadPart;

        } else {

            VgaRegisterBase = (PUCHAR) MmMapIoSpace(TranslatedAddress,
                                                    0x400,
                                                    FALSE);
        }
    
        //
        // Now that we have the VGA I/O ports, check to see if a VGA
        // device is present.
        //
    
        if (!VgaIsPresent()) {
    
            if (!(AddressSpace & 0x1)) {
    
                MmUnmapIoSpace(VgaRegisterBase, 0x400);
            }
    
            //
            // Continue on next bus that has this IO address.
            //

            continue;
        }
    
        //
        //
        // Map the frame buffer.
        //
    
        AddressSpace = 0;  // we are requesting memory not IO.
    
        //
        // Map the video memory so that we can write to the screen after
        // setting a mode.
        //
        // Note: We assume the memory will be on the same bus as the IO.
        //
    
        if (HALPDISPATCH->HalFindBusAddressTranslation(
                              MemoryAddress,
                              &AddressSpace,
                              &TranslatedAddress,
                              &TranslateContext,
                              FALSE)) {
    
            //
            // We were able to translate the address.  Now, map the
            // translated address.
            //
    
            if (AddressSpace & 0x1) {
    
                VgaBase = (PUCHAR)(DWORD_PTR) TranslatedAddress.QuadPart;
    
            } else {
    
                VgaBase = (PUCHAR) MmMapIoSpace(TranslatedAddress,
                                                0x20000, // 128k
                                                FALSE);
            }

            //
            // Life is good.
            //

            break;
        }
    }
    
    //
    // Initialize the display
    //

    if (SetMode) {
        curr_x = curr_y = 0;

        HalResetDisplay();

        VgaInterpretCmdStream(AT_Initialization);
    }

    return TRUE;
}

VOID
VidResetDisplay(
    BOOLEAN SetMode
    )
{
    curr_x = curr_y = 0;

    if (SetMode) {
        HalResetDisplay();
    }        

    VgaInterpretCmdStream(AT_Initialization);

    InitializePalette();

    VidSolidColorFill(0,0,639,479,0);
}

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG_PTR ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG_PTR ulBase;

    if (pusCmdStream == NULL) {

        //KdPrint(("VgaInterpretCmdStream: pusCmdStream == NULL\n"));
        return TRUE;
    }

    ulBase = (ULONG_PTR) VgaRegisterBase;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            WRITE_PORT_USHORT((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            WRITE_PORT_BUFFER_USHORT((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = READ_PORT_USHORT((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            WRITE_PORT_USHORT((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        WRITE_PORT_UCHAR((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()

BOOLEAN
VgaIsPresent(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = READ_PORT_UCHAR(VgaRegisterBase +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    WRITE_PORT_UCHAR(VgaRegisterBase +
        GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((READ_PORT_UCHAR(VgaRegisterBase +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = READ_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (READ_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((READ_PORT_UCHAR(VgaRegisterBase +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = READ_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (READ_PORT_UCHAR(VgaRegisterBase +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            WRITE_PORT_UCHAR(VgaRegisterBase +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            WRITE_PORT_UCHAR(VgaRegisterBase +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            WRITE_PORT_UCHAR(VgaRegisterBase +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (READ_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        WRITE_PORT_UCHAR(VgaRegisterBase +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT, originalReadMap);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_DATA_PORT, originalBitMask);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = READ_PORT_UCHAR(VgaRegisterBase +
            SEQ_ADDRESS_PORT);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((READ_PORT_UCHAR(VgaRegisterBase +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = READ_PORT_UCHAR(VgaRegisterBase +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    WRITE_PORT_USHORT((PUSHORT)(VgaRegisterBase +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    WRITE_PORT_UCHAR(VgaRegisterBase +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    WRITE_PORT_UCHAR(VgaRegisterBase +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (READ_PORT_UCHAR(VgaRegisterBase +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        WRITE_PORT_USHORT((PUSHORT) (VgaRegisterBase +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        WRITE_PORT_USHORT((PUSHORT)(VgaRegisterBase +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        WRITE_PORT_UCHAR(VgaRegisterBase +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\bootdata.c ===
#include <ntddk.h>
#include "cmdcnst.h"
#include "vga.h"

//
// We don't need this table anymore, since we now use int10 even on ia64
//

#if 0

//
// MODE TABLE TO PUT VGA INTO MODE 12
//

USHORT VGA_640x480[] = {
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0f02,0x0003,0x0604,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xe3,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x28,0x0,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    //0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

#endif

//
// Initialize AT registers
//

USHORT AT_Initialization[] = {

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    16,                             // count
    0,                              // start index
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD

};

UCHAR FontData[] = {
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 0
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 1
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 2
	0x18,	0x24,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 3
	0x14,	0x28,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 4
	0x00,	0x24,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 5
	0x24,	0x18,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 6
	0x10,	0x28,	0x10,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 7
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x10,	0x10,	0x10, // char # 8
	0x14,	0x28,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 9
	0x28,	0x10,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 10
	0x10,	0x20,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 11
	0x10,	0x08,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 12
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x10,	0x10, // char # 13
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 14
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 15
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 16
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 17
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 18
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 19
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 20
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 21
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 22
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 23
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 24
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 25
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 26
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 27
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 28
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 29
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 30
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 31
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 32
	0x00,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x00,	0x00,	0x10,	0x00,	0x00,	0x00, // char # 33
	0x24,	0x24,	0x24,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 34
	0x00,	0x14,	0x14,	0x14,	0x7f,	0x28,	0xfe,	0x50,	0x50,	0x50,	0x00,	0x00,	0x00, // char # 35
	0x10,	0x3c,	0x50,	0x50,	0x70,	0x38,	0x1c,	0x14,	0x14,	0x78,	0x10,	0x00,	0x00, // char # 36
	0x00,	0x61,	0x92,	0x94,	0x68,	0x18,	0x16,	0x29,	0x49,	0x86,	0x00,	0x00,	0x00, // char # 37
	0x00,	0x18,	0x24,	0x24,	0x38,	0x71,	0x89,	0x8e,	0xc6,	0x7e,	0x00,	0x00,	0x00, // char # 38
	0x10,	0x10,	0x10,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 39
	0x06,	0x08,	0x10,	0x30,	0x20,	0x20,	0x20,	0x20,	0x30,	0x10,	0x08,	0x06,	0x00, // char # 40
	0x60,	0x10,	0x08,	0x04,	0x04,	0x04,	0x04,	0x04,	0x04,	0x08,	0x10,	0x60,	0x00, // char # 41
	0x00,	0x10,	0x52,	0x24,	0x3c,	0x24,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 42
	0x00,	0x00,	0x00,	0x10,	0x10,	0x10,	0xfe,	0x10,	0x10,	0x10,	0x00,	0x00,	0x00, // char # 43
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x30,	0x30,	0x10,	0x20,	0x00, // char # 44
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x7e,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 45
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x30,	0x30,	0x00,	0x00,	0x00, // char # 46
	0x01,	0x02,	0x02,	0x04,	0x08,	0x08,	0x10,	0x10,	0x20,	0x40,	0x40,	0x80,	0x00, // char # 47
	0x00,	0x18,	0x24,	0x42,	0x42,	0x42,	0x42,	0x42,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 48
	0x00,	0x30,	0xd0,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xfe,	0x00,	0x00,	0x00, // char # 49
	0x00,	0x78,	0x04,	0x04,	0x04,	0x08,	0x10,	0x20,	0x40,	0x7c,	0x00,	0x00,	0x00, // char # 50
	0x00,	0x78,	0x04,	0x04,	0x08,	0x30,	0x0c,	0x04,	0x04,	0x78,	0x00,	0x00,	0x00, // char # 51
	0x00,	0x08,	0x18,	0x28,	0x28,	0x48,	0x88,	0xfc,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 52
	0x00,	0x3c,	0x20,	0x20,	0x38,	0x04,	0x04,	0x04,	0x04,	0x38,	0x00,	0x00,	0x00, // char # 53
	0x00,	0x1c,	0x20,	0x40,	0x5c,	0x62,	0x42,	0x42,	0x22,	0x1c,	0x00,	0x00,	0x00, // char # 54
	0x00,	0x7e,	0x02,	0x04,	0x08,	0x08,	0x10,	0x10,	0x20,	0x20,	0x00,	0x00,	0x00, // char # 55
	0x00,	0x3c,	0x42,	0x42,	0x24,	0x3c,	0x46,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 56
	0x00,	0x38,	0x44,	0x42,	0x42,	0x46,	0x3a,	0x02,	0x04,	0x38,	0x00,	0x00,	0x00, // char # 57
	0x00,	0x00,	0x00,	0x18,	0x18,	0x00,	0x00,	0x00,	0x18,	0x18,	0x00,	0x00,	0x00, // char # 58
	0x00,	0x00,	0x00,	0x30,	0x30,	0x00,	0x00,	0x00,	0x30,	0x30,	0x10,	0x20,	0x00, // char # 59
	0x00,	0x00,	0x00,	0x02,	0x0c,	0x10,	0x60,	0x10,	0x0c,	0x02,	0x00,	0x00,	0x00, // char # 60
	0x00,	0x00,	0x00,	0x00,	0x00,	0x7e,	0x00,	0x7e,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 61
	0x00,	0x00,	0x00,	0x40,	0x30,	0x08,	0x06,	0x08,	0x30,	0x40,	0x00,	0x00,	0x00, // char # 62
	0x00,	0x7c,	0x42,	0x02,	0x04,	0x08,	0x10,	0x00,	0x00,	0x10,	0x00,	0x00,	0x00, // char # 63
	0x00,	0x3c,	0x62,	0xde,	0xb2,	0xa2,	0xa6,	0x9b,	0x44,	0x3c,	0x00,	0x00,	0x00, // char # 64
	0x00,	0x00,	0x18,	0x18,	0x24,	0x24,	0x24,	0x7e,	0x42,	0x81,	0x00,	0x00,	0x00, // char # 65
	0x00,	0x00,	0x7c,	0x42,	0x42,	0x7c,	0x42,	0x42,	0x42,	0x7c,	0x00,	0x00,	0x00, // char # 66
	0x00,	0x00,	0x3e,	0x40,	0x80,	0x80,	0x80,	0x80,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 67
	0x00,	0x00,	0x78,	0x44,	0x42,	0x42,	0x42,	0x42,	0x44,	0x78,	0x00,	0x00,	0x00, // char # 68
	0x00,	0x00,	0x7e,	0x40,	0x40,	0x40,	0x7c,	0x40,	0x40,	0x7e,	0x00,	0x00,	0x00, // char # 69
	0x00,	0x00,	0x7e,	0x40,	0x40,	0x40,	0x7c,	0x40,	0x40,	0x40,	0x00,	0x00,	0x00, // char # 70
	0x00,	0x00,	0x3e,	0x40,	0x80,	0x80,	0x8e,	0x82,	0x42,	0x3e,	0x00,	0x00,	0x00, // char # 71
	0x00,	0x00,	0x42,	0x42,	0x42,	0x7e,	0x42,	0x42,	0x42,	0x42,	0x00,	0x00,	0x00, // char # 72
	0x00,	0x00,	0x7c,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x7c,	0x00,	0x00,	0x00, // char # 73
	0x00,	0x00,	0x3c,	0x04,	0x04,	0x04,	0x04,	0x04,	0x04,	0x78,	0x00,	0x00,	0x00, // char # 74
	0x00,	0x00,	0x42,	0x44,	0x48,	0x70,	0x50,	0x48,	0x44,	0x42,	0x00,	0x00,	0x00, // char # 75
	0x00,	0x00,	0x40,	0x40,	0x40,	0x40,	0x40,	0x40,	0x40,	0x7e,	0x00,	0x00,	0x00, // char # 76
	0x00,	0x00,	0xc6,	0xc6,	0xaa,	0xaa,	0xaa,	0x92,	0x82,	0x82,	0x00,	0x00,	0x00, // char # 77
	0x00,	0x00,	0x42,	0x62,	0x52,	0x52,	0x4a,	0x4a,	0x46,	0x42,	0x00,	0x00,	0x00, // char # 78
	0x00,	0x00,	0x38,	0x44,	0x82,	0x82,	0x82,	0x82,	0x44,	0x38,	0x00,	0x00,	0x00, // char # 79
	0x00,	0x00,	0x7c,	0x42,	0x42,	0x42,	0x7c,	0x40,	0x40,	0x40,	0x00,	0x00,	0x00, // char # 80
	0x00,	0x00,	0x38,	0x44,	0x82,	0x82,	0x82,	0x82,	0x44,	0x38,	0x06,	0x03,	0x00, // char # 81
	0x00,	0x00,	0x78,	0x44,	0x44,	0x44,	0x78,	0x48,	0x44,	0x42,	0x00,	0x00,	0x00, // char # 82
	0x00,	0x00,	0x3e,	0x40,	0x40,	0x38,	0x04,	0x02,	0x02,	0x7c,	0x00,	0x00,	0x00, // char # 83
	0x00,	0x00,	0xfe,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x00,	0x00,	0x00, // char # 84
	0x00,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 85
	0x00,	0x00,	0x81,	0x42,	0x42,	0x44,	0x24,	0x28,	0x38,	0x10,	0x00,	0x00,	0x00, // char # 86
	0x00,	0x00,	0x81,	0x81,	0x92,	0x5a,	0x5a,	0x6a,	0x66,	0x24,	0x00,	0x00,	0x00, // char # 87
	0x00,	0x00,	0x81,	0x42,	0x24,	0x18,	0x18,	0x24,	0x42,	0x81,	0x00,	0x00,	0x00, // char # 88
	0x00,	0x00,	0x82,	0x44,	0x28,	0x28,	0x10,	0x10,	0x10,	0x10,	0x00,	0x00,	0x00, // char # 89
	0x00,	0x00,	0xfe,	0x02,	0x04,	0x08,	0x10,	0x20,	0x40,	0xfe,	0x00,	0x00,	0x00, // char # 90
	0x1e,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x1e,	0x00, // char # 91
	0x80,	0x40,	0x40,	0x20,	0x10,	0x10,	0x08,	0x08,	0x04,	0x02,	0x02,	0x01,	0x00, // char # 92
	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x78,	0x00, // char # 93
	0x00,	0x08,	0x08,	0x18,	0x14,	0x24,	0x24,	0x42,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 94
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x00,	0x00, // char # 95
	0x10,	0x08,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 96
	0x00,	0x00,	0x00,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 97
	0x40,	0x40,	0x40,	0x5c,	0x62,	0x42,	0x42,	0x42,	0x62,	0x5c,	0x00,	0x00,	0x00, // char # 98
	0x00,	0x00,	0x00,	0x1e,	0x20,	0x40,	0x40,	0x40,	0x20,	0x1e,	0x00,	0x00,	0x00, // char # 99
	0x02,	0x02,	0x02,	0x3a,	0x46,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 100
	0x00,	0x00,	0x00,	0x3c,	0x22,	0x42,	0x7e,	0x40,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 101
	0x1e,	0x20,	0x20,	0xfe,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00, // char # 102
	0x00,	0x00,	0x00,	0x3a,	0x46,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x02,	0x02,	0x3c, // char # 103
	0x40,	0x40,	0x40,	0x5c,	0x62,	0x42,	0x42,	0x42,	0x42,	0x42,	0x00,	0x00,	0x00, // char # 104
	0x18,	0x18,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 105
	0x18,	0x18,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x70, // char # 106
	0x40,	0x40,	0x40,	0x44,	0x48,	0x50,	0x60,	0x50,	0x48,	0x44,	0x00,	0x00,	0x00, // char # 107
	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 108
	0x00,	0x00,	0x00,	0xb6,	0xda,	0x92,	0x92,	0x92,	0x92,	0x92,	0x00,	0x00,	0x00, // char # 109
	0x00,	0x00,	0x00,	0x5c,	0x62,	0x42,	0x42,	0x42,	0x42,	0x42,	0x00,	0x00,	0x00, // char # 110
	0x00,	0x00,	0x00,	0x3c,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 111
	0x00,	0x00,	0x00,	0x5c,	0x62,	0x42,	0x42,	0x42,	0x62,	0x5c,	0x40,	0x40,	0x40, // char # 112
	0x00,	0x00,	0x00,	0x3a,	0x46,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x02,	0x02,	0x02, // char # 113
	0x00,	0x00,	0x00,	0x5c,	0x64,	0x40,	0x40,	0x40,	0x40,	0x40,	0x00,	0x00,	0x00, // char # 114
	0x00,	0x00,	0x00,	0x3c,	0x40,	0x60,	0x18,	0x04,	0x04,	0x78,	0x00,	0x00,	0x00, // char # 115
	0x00,	0x00,	0x20,	0xfc,	0x20,	0x20,	0x20,	0x20,	0x20,	0x1c,	0x00,	0x00,	0x00, // char # 116
	0x00,	0x00,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 117
	0x00,	0x00,	0x00,	0x82,	0x44,	0x44,	0x44,	0x28,	0x28,	0x10,	0x00,	0x00,	0x00, // char # 118
	0x00,	0x00,	0x00,	0x81,	0x91,	0x5a,	0x5a,	0x6a,	0x24,	0x24,	0x00,	0x00,	0x00, // char # 119
	0x00,	0x00,	0x00,	0x42,	0x24,	0x18,	0x18,	0x18,	0x24,	0x42,	0x00,	0x00,	0x00, // char # 120
	0x00,	0x00,	0x00,	0x81,	0x42,	0x42,	0x24,	0x24,	0x18,	0x18,	0x10,	0x30,	0xe0, // char # 121
	0x00,	0x00,	0x00,	0x7e,	0x02,	0x04,	0x08,	0x10,	0x20,	0x7e,	0x00,	0x00,	0x00, // char # 122
	0x1c,	0x10,	0x10,	0x10,	0x10,	0x60,	0x10,	0x10,	0x10,	0x10,	0x10,	0x0c,	0x00, // char # 123
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x00, // char # 124
	0x30,	0x08,	0x08,	0x08,	0x08,	0x06,	0x08,	0x08,	0x08,	0x08,	0x08,	0x30,	0x00, // char # 125
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x71,	0x8e,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 126
	0x00,	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x3c,	0x00,	0x00,	0x00, // char # 127
	0x00,	0x00,	0x3e,	0x40,	0x80,	0x80,	0x80,	0x80,	0x40,	0x3e,	0x04,	0x02,	0x06, // char # 128
	0x00,	0x24,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 129
	0x08,	0x10,	0x00,	0x3c,	0x22,	0x42,	0x7e,	0x40,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 130
	0x18,	0x24,	0x00,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 131
	0x00,	0x24,	0x00,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 132
	0x10,	0x08,	0x00,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 133
	0x10,	0x28,	0x10,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 134
	0x00,	0x00,	0x00,	0x1e,	0x20,	0x40,	0x40,	0x40,	0x20,	0x1e,	0x08,	0x04,	0x0c, // char # 135
	0x18,	0x24,	0x00,	0x3c,	0x22,	0x42,	0x7e,	0x40,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 136
	0x00,	0x12,	0x00,	0x3c,	0x22,	0x42,	0x7e,	0x40,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 137
	0x10,	0x08,	0x00,	0x3c,	0x22,	0x42,	0x7e,	0x40,	0x40,	0x3e,	0x00,	0x00,	0x00, // char # 138
	0x00,	0x24,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 139
	0x18,	0x24,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 140
	0x10,	0x08,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 141
	0x24,	0x00,	0x18,	0x18,	0x24,	0x24,	0x24,	0x7e,	0x42,	0x81,	0x00,	0x00,	0x00, // char # 142
	0x10,	0x28,	0x10,	0x28,	0x28,	0x24,	0x44,	0x7e,	0x42,	0x81,	0x00,	0x00,	0x00, // char # 143
	0x08,	0x10,	0x7e,	0x40,	0x40,	0x40,	0x7c,	0x40,	0x40,	0x7e,	0x00,	0x00,	0x00, // char # 144
	0x00,	0x00,	0x00,	0xfc,	0x12,	0x12,	0x7e,	0x90,	0x90,	0x6e,	0x00,	0x00,	0x00, // char # 145
	0x00,	0x00,	0x0f,	0x18,	0x18,	0x28,	0x2e,	0x78,	0x48,	0x8f,	0x00,	0x00,	0x00, // char # 146
	0x18,	0x24,	0x00,	0x3c,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 147
	0x00,	0x24,	0x00,	0x3c,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 148
	0x20,	0x10,	0x00,	0x3c,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 149
	0x18,	0x24,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 150
	0x20,	0x10,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 151
	0x00,	0x24,	0x00,	0x81,	0x42,	0x42,	0x24,	0x24,	0x18,	0x18,	0x10,	0x30,	0xe0, // char # 152
	0x24,	0x00,	0x38,	0x44,	0x82,	0x82,	0x82,	0x82,	0x44,	0x38,	0x00,	0x00,	0x00, // char # 153
	0x24,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 154
	0x00,	0x08,	0x1c,	0x28,	0x48,	0x48,	0x48,	0x68,	0x1c,	0x08,	0x00,	0x00,	0x00, // char # 155
	0x00,	0x0e,	0x10,	0x10,	0x10,	0x38,	0x10,	0x10,	0x20,	0x3e,	0x00,	0x00,	0x00, // char # 156
	0x00,	0x81,	0x42,	0x24,	0x18,	0x7c,	0x10,	0x7c,	0x10,	0x10,	0x00,	0x00,	0x00, // char # 157
	0x00,	0xe0,	0x90,	0x90,	0xe0,	0x96,	0xbc,	0x94,	0x92,	0x9e,	0x00,	0x00,	0x00, // char # 158
	0x0e,	0x10,	0x10,	0x3c,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xe0, // char # 159
	0x08,	0x10,	0x00,	0x38,	0x04,	0x04,	0x3c,	0x44,	0x44,	0x3e,	0x00,	0x00,	0x00, // char # 160
	0x08,	0x10,	0x00,	0x78,	0x08,	0x08,	0x08,	0x08,	0x08,	0x08,	0x00,	0x00,	0x00, // char # 161
	0x08,	0x10,	0x00,	0x3c,	0x42,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 162
	0x08,	0x10,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x46,	0x3a,	0x00,	0x00,	0x00, // char # 163
	0x14,	0x28,	0x00,	0x5c,	0x62,	0x42,	0x42,	0x42,	0x42,	0x42,	0x00,	0x00,	0x00, // char # 164
	0x14,	0x28,	0x42,	0x62,	0x52,	0x52,	0x4a,	0x4a,	0x46,	0x42,	0x00,	0x00,	0x00, // char # 165
	0x00,	0x78,	0x08,	0x38,	0x48,	0x7c,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 166
	0x00,	0x38,	0x44,	0x44,	0x44,	0x38,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 167
	0x00,	0x00,	0x00,	0x08,	0x00,	0x00,	0x08,	0x10,	0x20,	0x40,	0x42,	0x3e,	0x00, // char # 168
	0x00,	0x00,	0x00,	0x00,	0x00,	0x7e,	0x40,	0x40,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 169
	0x00,	0x00,	0x00,	0x00,	0x00,	0xfe,	0x02,	0x02,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 170
	0x00,	0xc4,	0x48,	0x48,	0x50,	0x37,	0x21,	0x43,	0x44,	0x87,	0x00,	0x00,	0x00, // char # 171
	0x00,	0xc4,	0x48,	0x48,	0x50,	0x22,	0x26,	0x4a,	0x4f,	0x82,	0x00,	0x00,	0x00, // char # 172
	0x00,	0x00,	0x00,	0x10,	0x00,	0x00,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x00, // char # 173
	0x00,	0x00,	0x00,	0x00,	0x12,	0x24,	0x48,	0x24,	0x12,	0x00,	0x00,	0x00,	0x00, // char # 174
	0x00,	0x00,	0x00,	0x00,	0x48,	0x24,	0x12,	0x24,	0x48,	0x00,	0x00,	0x00,	0x00, // char # 175
	0x94,	0x00,	0x00,	0x94,	0x00,	0x94,	0x00,	0x00,	0x94,	0x00,	0x94,	0x00,	0x00, // char # 176
	0x49,	0x94,	0x00,	0x49,	0x94,	0x49,	0x00,	0x94,	0x49,	0x94,	0x49,	0x00,	0x94, // char # 177
	0xff,	0x94,	0x94,	0xff,	0x94,	0xff,	0x94,	0x94,	0xff,	0x94,	0xff,	0x94,	0x94, // char # 178
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 179
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xf0,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 180
	0x10,	0x10,	0x10,	0x10,	0x10,	0xf0,	0x10,	0xf0,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 181
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0xf4,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 182
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xfc,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 183
	0x00,	0x00,	0x00,	0x00,	0x00,	0xf0,	0x10,	0xf0,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 184
	0x14,	0x14,	0x14,	0x14,	0x14,	0xf4,	0x04,	0xf4,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 185
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 186
	0x00,	0x00,	0x00,	0x00,	0x00,	0xfc,	0x04,	0xf4,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 187
	0x14,	0x14,	0x14,	0x14,	0x14,	0xf4,	0x04,	0xfc,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 188
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0xfc,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 189
	0x10,	0x10,	0x10,	0x10,	0x10,	0xf0,	0x10,	0xf0,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 190
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xf0,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 191
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x1f,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 192
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 193
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 194
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x1f,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 195
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 196
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xff,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 197
	0x10,	0x10,	0x10,	0x10,	0x10,	0x1f,	0x10,	0x1f,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 198
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x17,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 199
	0x14,	0x14,	0x14,	0x14,	0x14,	0x17,	0x10,	0x1f,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 200
	0x00,	0x00,	0x00,	0x00,	0x00,	0x1f,	0x10,	0x17,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 201
	0x14,	0x14,	0x14,	0x14,	0x14,	0xf7,	0x00,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 202
	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x00,	0xf7,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 203
	0x14,	0x14,	0x14,	0x14,	0x14,	0x17,	0x10,	0x17,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 204
	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x00,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 205
	0x14,	0x14,	0x14,	0x14,	0x14,	0xf7,	0x00,	0xf7,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 206
	0x10,	0x10,	0x10,	0x10,	0x10,	0xff,	0x00,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 207
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 208
	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x00,	0xff,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 209
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 210
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0x1f,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 211
	0x10,	0x10,	0x10,	0x10,	0x10,	0x1f,	0x10,	0x1f,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 212
	0x00,	0x00,	0x00,	0x00,	0x00,	0x1f,	0x10,	0x1f,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 213
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x1f,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 214
	0x14,	0x14,	0x14,	0x14,	0x14,	0x14,	0xff,	0x14,	0x14,	0x14,	0x14,	0x14,	0x14, // char # 215
	0x10,	0x10,	0x10,	0x10,	0x10,	0xff,	0x10,	0xff,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 216
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0xf0,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 217
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x1f,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 218
	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff, // char # 219
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff, // char # 220
	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0,	0xf0, // char # 221
	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f,	0x0f, // char # 222
	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 223
	0x00,	0x00,	0x00,	0x31,	0x49,	0x86,	0x84,	0x84,	0x8a,	0x71,	0x00,	0x00,	0x00, // char # 224
	0x38,	0x48,	0x48,	0x50,	0x50,	0x58,	0x44,	0x42,	0x42,	0x5c,	0x00,	0x00,	0x00, // char # 225
	0x00,	0x00,	0x3f,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00, // char # 226
	0x00,	0x00,	0x00,	0x7f,	0x24,	0x24,	0x24,	0x24,	0x24,	0x24,	0x00,	0x00,	0x00, // char # 227
	0x00,	0x00,	0xff,	0x40,	0x20,	0x10,	0x10,	0x20,	0x40,	0xff,	0x00,	0x00,	0x00, // char # 228
	0x00,	0x00,	0x00,	0x7f,	0x84,	0x84,	0x84,	0x84,	0x84,	0x78,	0x00,	0x00,	0x00, // char # 229
	0x00,	0x00,	0x00,	0x42,	0x42,	0x42,	0x42,	0x42,	0x66,	0x5a,	0x40,	0x40,	0x40, // char # 230
	0x00,	0x00,	0x00,	0xfe,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x00,	0x00,	0x00, // char # 231
	0x00,	0x00,	0x10,	0x7c,	0x92,	0x92,	0x92,	0x92,	0x7c,	0x10,	0x00,	0x00,	0x00, // char # 232
	0x00,	0x00,	0x38,	0x44,	0x82,	0xba,	0x82,	0x82,	0x44,	0x38,	0x00,	0x00,	0x00, // char # 233
	0x00,	0x00,	0x7c,	0xc6,	0x82,	0x82,	0x82,	0x84,	0x44,	0xee,	0x00,	0x00,	0x00, // char # 234
	0x38,	0x40,	0x60,	0x18,	0x24,	0x42,	0x42,	0x42,	0x42,	0x3c,	0x00,	0x00,	0x00, // char # 235
	0x00,	0x00,	0x00,	0x00,	0x66,	0x99,	0x99,	0x99,	0x66,	0x00,	0x00,	0x00,	0x00, // char # 236
	0x10,	0x10,	0x10,	0x7c,	0x92,	0x91,	0x91,	0x91,	0x92,	0x7c,	0x10,	0x10,	0x10, // char # 237
	0x00,	0x00,	0x00,	0x1e,	0x20,	0x40,	0x7c,	0x40,	0x60,	0x1e,	0x00,	0x00,	0x00, // char # 238
	0x00,	0x00,	0x00,	0x38,	0x44,	0x82,	0x82,	0x82,	0x82,	0x82,	0x00,	0x00,	0x00, // char # 239
	0x00,	0x00,	0x00,	0x00,	0x7e,	0x00,	0x7e,	0x00,	0x7e,	0x00,	0x00,	0x00,	0x00, // char # 240
	0x00,	0x00,	0x00,	0x10,	0x10,	0xfe,	0x10,	0x10,	0x00,	0xfe,	0x00,	0x00,	0x00, // char # 241
	0x00,	0x00,	0x40,	0x30,	0x08,	0x06,	0x08,	0x30,	0x40,	0x00,	0x7e,	0x00,	0x00, // char # 242
	0x00,	0x00,	0x02,	0x0c,	0x10,	0x60,	0x10,	0x0c,	0x02,	0x00,	0x7e,	0x00,	0x00, // char # 243
	0x0c,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10, // char # 244
	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x10,	0x60, // char # 245
	0x00,	0x00,	0x00,	0x10,	0x00,	0x00,	0xfe,	0x00,	0x00,	0x10,	0x00,	0x00,	0x00, // char # 246
	0x00,	0x00,	0x00,	0x00,	0x72,	0x4e,	0x00,	0x72,	0x4e,	0x00,	0x00,	0x00,	0x00, // char # 247
	0x00,	0x10,	0x28,	0x10,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 248
	0x00,	0x00,	0x00,	0x00,	0x18,	0x3c,	0x3c,	0x18,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 249
	0x00,	0x00,	0x00,	0x00,	0x18,	0x3c,	0x3c,	0x18,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 250
	0x01,	0x01,	0x02,	0x02,	0x02,	0x04,	0x04,	0xc4,	0x28,	0x28,	0x18,	0x10,	0x00, // char # 251
	0x00,	0x3c,	0x24,	0x24,	0x24,	0x24,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 252
	0x00,	0x3c,	0x04,	0x18,	0x3c,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00, // char # 253
	0x00,	0x00,	0x00,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0xff,	0x00,	0x00,	0x00, // char # 254
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00 // char # 255
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\vga.h ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    vga.h

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03b4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03b5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03bA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03bA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x03c0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03c0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x03c1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03c2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03c2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03c3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03c4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03c5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03c6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03c7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03c7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03c8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03c9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03cA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03cC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03cE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03cF  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x03d4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03d5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03dA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03dA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// prototypes
//

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    );

BOOLEAN
VgaIsPresent(
    VOID
    );

#define BI_RLE4 2

#pragma pack(1)

typedef struct _BITMAPFILEHEADER {

    USHORT bfType;
    ULONG bfSize;
    USHORT bfReserved1;
    USHORT bfReserved2;
    ULONG bfOffBits;
} BITMAPFILEHEADER, *PBITMAPFILEHEADER;

typedef struct _BITMAPINFOHEADER {

    ULONG biSize;
    LONG biWidth;
    LONG biHeight;
    USHORT biPlanes;
    USHORT biBitCount;
    ULONG biCompression;
    ULONG biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    ULONG biClrUsed;
    ULONG biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct _RGBQUAD {

    UCHAR rgbBlue;
    UCHAR rgbGreen;
    UCHAR rgbRed;
    UCHAR rgbReserved;
} RGBQUAD, *PRGBQUAD;

#pragma pack()

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    );

VOID
DisplayCharacter(
    UCHAR c,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    );

VOID
DisplayStringXY(
    PUCHAR s,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    );

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    );

VOID
VgaScroll(
    ULONG CharHeight
    );

VOID
PreserveRow(
    ULONG y,
    ULONG CharHeight,
    BOOLEAN bRestore
    );

VOID
SetPaletteEntry(
    ULONG index,
    ULONG RGB
    );

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    );

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    );

VOID
InitializePalette(
    VOID
    );

VOID
WaitForVsync(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootvid\vga.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    boot.c

Abstract:

    This is the device dependent portion of the graphical boot dll.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

//
// vga routines
//

#include <ntddk.h>
#include <bootvid.h>
#include "vga.h"

extern PUCHAR VgaBase;
extern PUCHAR VgaRegisterBase;
extern UCHAR FontData[];

#define FONT_HEIGHT (13)
#define STRING_HEIGHT (14)

typedef struct _RECT
{
    ULONG x1;
    ULONG y1;
    ULONG x2;
    ULONG y2;
} RECT, *PRECT;

//
// globals to track screen position
//


ULONG curr_x=0;
ULONG curr_y=0;
RECT ScrollRegion = {0, 0, 639, 479};  // 53 lines of 9 pixel height text.
ULONG TextColor = 15;

#define DELTA 80L

UCHAR lMaskTable[8] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};
UCHAR rMaskTable[8] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
UCHAR PixelMask[8]  = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

ULONG lookup[16] =
{
    0x00000000,
    0x00000100,
    0x00001000,
    0x00001100,
    0x00000001,
    0x00000101,
    0x00001001,
    0x00001101,
    0x00000010,
    0x00000110,
    0x00001010,
    0x00001110,
    0x00000011,
    0x00000111,
    0x00001011,
    0x00001111
};

void __outpw(int p, int v)
{
    WRITE_PORT_USHORT((PUSHORT)(p+VgaRegisterBase), (USHORT)v);
}

void __outpb(int p, int v)
{
    WRITE_PORT_UCHAR((PUCHAR)(p+VgaRegisterBase), (UCHAR)v);
}

VOID
ReadWriteMode(
    ULONG mode
    )
{
    UCHAR value;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3ce), 5);
    value = READ_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf));

    value &= 0xf4;
    value |= mode;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf), value);
}

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG  bank;

    bank = x >> 3;

    pDst = (char *)(VgaBase + y * DELTA + bank);

    ReadWriteMode(0x8 | 0x2);
    __outpw(0x3c4, 0x0f02); // enable all write planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero
    __outpw(0x3ce, (PixelMask[x & 0x7] << 8) | 8);

    WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & ((UCHAR)color)));
}

VOID
VidSolidColorFill(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG x, y;
    ULONG bank1, bank2, count;
    ULONG lMask, rMask;

    lMask = (lMaskTable[x1 & 0x7] << 8) | 8;
    rMask = (rMaskTable[x2 & 0x7] << 8) | 8;

    bank1 = x1 >> 3;
    bank2 = x2 >> 3;
    count = bank2 - bank1;

    if (!count) {
        lMask = lMask & rMask;
    }

    ReadWriteMode(0x8 | 0x2);

    __outpw(0x3c4, 0x0f02); // enable writing to all color planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero

    //
    // Do the left edge
    //

    pDst = (char *)(VgaBase + y1 * DELTA + bank1);

    __outpw(0x3ce, lMask);

    for (y=y1; y<=y2; y++) {

        WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
        pDst += DELTA;
    }

    if (count) {

        //
        // Do the right edge
        //

        pDst = (char *)(VgaBase + y1 * DELTA + bank2);
        count--;
        __outpw(0x3ce, rMask);

        for (y=y1; y<=y2; y++) {
            WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
            pDst += DELTA;
        }

        //
        // Do the center section
        //

        if (count) {

            pDst = (char *)(VgaBase + y1 * DELTA + bank1 + 1);
            __outpw(0x3ce, 0xff08);

            for (y=y1; y<=y2; y++) {

                for (x=0; x<count; x++) {
                    WRITE_REGISTER_UCHAR(pDst++,  (unsigned char) color);
                }
                pDst += DELTA - count;
            }

        }
    }
}

VOID
DisplayCharacter(
    UCHAR c,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    )
{
    ULONG i, j;
    ULONG xx, yy;

    UCHAR *BitPattern = &FontData[(int)c * FONT_HEIGHT];

    yy = y;
    for (j=0; j<FONT_HEIGHT; j++) {

        xx = x;
        for (i=128; i>0; i >>= 1) {

            if (i & *BitPattern) {

                SetPixel(xx, yy, fore_color);

            } else if (back_color < 16) {

                SetPixel(xx, yy, back_color);
            }

            xx++;
        }

        BitPattern++;
        yy++;
    }

    //
    // That is 8x8.  But we will want to put a blank line
    // such that the font is 8x9.  This will allow some room
    // between characters, and still allow for 53 lines of text.
    //
    // We only draw this blank line if not transparent text.

}

ULONG
VidSetTextColor(
    ULONG Color
    )

/*++

Routine Description:

    Modifies the text drawing color.

Arguments:

    Color - Palette index of new text color.

Returns:

    Previous text color.

--*/

{
    ULONG ulRet = TextColor;
    TextColor = Color;
    return ulRet;
}

VOID
VidDisplayString(
    PUCHAR str
    )
{
    static BOOLEAN bRestore = FALSE;

    while (*str) {

        switch(*str) {
        case '\n':

            curr_y += STRING_HEIGHT;

            if (curr_y >= ScrollRegion.y2) {

                VgaScroll(STRING_HEIGHT);
                curr_y = curr_y - STRING_HEIGHT;
                PreserveRow(curr_y, STRING_HEIGHT, TRUE);  // restore the row
            }

            curr_x = ScrollRegion.x1;
            PreserveRow(curr_y, STRING_HEIGHT, FALSE);
            break;

        case '\r':

            curr_x = ScrollRegion.x1;

            //
            // If we are doing a CR, but not a LF also, then
            // we must be returing to the beginning of a row
            // to display text again.  So we'll need to
            // restore the original contents of the row.
            //

            if (*(str+1) != '\n') {
                bRestore = TRUE;
            }
            break;

        default:

            if (bRestore) {
                PreserveRow(curr_y, STRING_HEIGHT, TRUE);
                bRestore = FALSE;
            }

            DisplayCharacter(*str, curr_x, curr_y, TextColor, 16);
            curr_x += 8;

            if (curr_x > ScrollRegion.x2) {
                curr_y += STRING_HEIGHT;

                if (curr_y > ScrollRegion.y2) {

                    VgaScroll(STRING_HEIGHT);
                    curr_y = curr_y - STRING_HEIGHT;
                    PreserveRow(curr_y, STRING_HEIGHT, TRUE);
                }
                curr_x = ScrollRegion.x1;
            }
        }

        str++;
    }
}

VOID
VidDisplayStringXY(
    PUCHAR s,
    ULONG x,
    ULONG y,
    BOOLEAN Transparent
    )
{
    DisplayStringXY(s, x, y, 12, Transparent ? 16 : 14);
}

VOID
DisplayStringXY(
    PUCHAR s,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    )
{
    while (*s) {

        DisplayCharacter(*s, x, y, fore_color, back_color);
        s++;
        x += 8;
    }
}

VOID
RleBitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer
    )

/*++

Routine Description:

    This routine displays an RLE 4 bitmap.

Arguments:

    x, y - location at which to display the bitmap.

    width, height - height of the bitmap

    Buffer - Pointer to the compressed bitmap data.

--*/

{
    BOOLEAN Done = FALSE;
    PUCHAR p = Buffer;
    ULONG RunLength;
    LONG RunExtra;
    ULONG curr_x, curr_y;
    ULONG Color1, Color2;

    curr_x = x;
    curr_y = y + height - 1;

    while (!Done) {

        if (*p) {

            RunLength = (ULONG) *p++;

            //
            // Make sure we don't draw past end of scan.
            //

            if ((curr_x + RunLength) > (x + width))
                RunLength -= (curr_x + RunLength) - (width + x);

            Color1 = (*p   & 0xf0) >> 4;
            Color2 = (*p++ & 0x0f);

            if (Color1 == Color2) {

                ULONG end_x = curr_x + RunLength - 1;

                VidSolidColorFill(curr_x,
                                  curr_y,
                                  end_x,
                                  curr_y,
                                  Color1);

                curr_x += RunLength;

            } else {

                while (RunLength > 1) {
                    SetPixel(curr_x++, curr_y, Color1);
                    SetPixel(curr_x++, curr_y, Color2);
                    RunLength -= 2;
                }

                if (RunLength) {
                    SetPixel(curr_x, curr_y, Color1);
                    curr_x++;
                }
            }

        } else {

            p++;

            switch (*p) {

            case 0:  curr_x = x;
                     curr_y--;
                     p++;
                     break;

            case 1:  Done = TRUE;
                     p++;
                     break;

            case 2:  p++;
                     curr_x += (ULONG) *p++;
                     curr_y -= (ULONG) *p++;
                     break;

            default: RunLength = (ULONG) *p++;

                     //
                     // Make sure we don't draw past end of scan.
                     //

                     if ((curr_x + RunLength) > (x + width)) {
                         RunExtra = (curr_x + RunLength) - (width + x);
                         RunLength -= RunExtra;
                     } else {
                         RunExtra = 0;
                     }

                     while (RunLength > 1) {

                         Color1 = (*p   & 0xf0) >> 4;
                         Color2 = (*p++ & 0x0f);

                         SetPixel(curr_x++, curr_y, Color1);
                         SetPixel(curr_x++, curr_y, Color2);

                         RunLength -= 2;
                     }

                     if (RunLength) {
                         Color1 = (*p++ & 0xf0) >> 4;
                         SetPixel(curr_x++, curr_y, Color1);
                         RunExtra--;
                     }

                     //
                     // Read any remaining "extra" run data.
                     //

                     while (RunExtra > 0) {
                         p++;
                         RunExtra -= 2;
                     }

                     if ((ULONG_PTR)p & 1) p++;  // make sure we are word aligned

                     break;
            }
        }
    }
}

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    )
{
    ULONG i, j;
    ULONG color=8;

    if (bpp == 4) {

        UCHAR Plane[81];
        ULONG lMask, rMask, count;
        ULONG bank1, bank2, bank;
        ULONG bRightEdge = FALSE, bCenterSection = FALSE;
        UCHAR value;
        ULONG plane;
        UCHAR Mask;
        ULONG toggle;
        PUCHAR pSrc, pSrcTemp;
        PUCHAR pDst, pDstTemp;
        UCHAR PlaneMask;

        lMask = lMaskTable[x & 0x7];
        rMask = rMaskTable[(x + width - 1) & 0x7];

        bank1 = x >> 3;
        bank2 = (x + width - 1) >> 3;

        count = bank2 - bank1;

        if (bank1 == bank2) {

            lMask = lMask & rMask;

        }

        if (count) {

            bRightEdge = TRUE;

            count--;

            if (count) {

                bCenterSection = TRUE;
            }
        }

        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));
        pSrc = Buffer;

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            for (plane=0; plane<4; plane++) {

                pSrcTemp = pSrc;
                pDstTemp = pDst;

                PlaneMask = 1 << plane;

                //
                // Convert the packed bitmap data into planar data
                // for this plane.
                //

                bank = bank1;
                Plane[bank] = 0;
                Mask = PixelMask[x & 0x7];
                toggle = 0;

                for (i=0; i<width; i++) {

                    if (toggle++ & 0x1) {

                        if (*pSrcTemp & PlaneMask) {
                            Plane[bank] |= Mask;
                        }

                        pSrcTemp++;

                    } else {

                        if (((*pSrcTemp) >> 4) & PlaneMask) {
                            Plane[bank] |= Mask;
                        }
                    }

                    Mask >>= 1;

                    if (!Mask) {

                        bank++;
                        Plane[bank] = 0;
                        Mask = 0x80;
                    }
                }

                //
                // Set up the vga so that we see the correct bit plane.
                //

                __outpw(0x3c4, (1 << (plane + 8)) | 2);

                //
                // bank will go from bank1 to bank2
                //

                bank = bank1;
                pDstTemp = pDst;


                //
                // Set Bitmask for left edge.
                //

                __outpw(0x3ce, (lMask << 8) | 8);

                value = READ_REGISTER_UCHAR(pDstTemp);

                value &= ~lMask;
                value |= Plane[bank++];

                WRITE_REGISTER_UCHAR(pDstTemp++, value);

                if (bCenterSection) {

                    __outpw(0x3ce, 0xff08);  // enable writing to all bits

                    for (i=0; i<count; i++) {

                        WRITE_REGISTER_UCHAR(pDstTemp++, Plane[bank++]);
                    }
                }

                if (bRightEdge) {

                    //
                    // Set bitmask for right edge.
                    //

                    __outpw(0x3ce, (rMask << 8) | 8);

                    value = READ_REGISTER_UCHAR(pDstTemp);

                    value &= ~rMask;
                    value |= Plane[bank];

                    WRITE_REGISTER_UCHAR(pDstTemp, value);
                }
            }

            pDst += DELTA;
            pSrc += ScanWidth;
        }

    } else {

        PUCHAR pDst, pDstTemp;
        PUCHAR pSrc, pSrcTemp;
        ULONG count;
        UCHAR Value;
        ULONG lMask, rMask;
        ULONG bank1, bank2;
        ULONG plane;
        UCHAR colorMask;

        bank1 = x >> 8;
        bank2 = (x + width - 1) >> 8;

        lMask = lMaskTable[x & 7];
        rMask = rMaskTable[(x + width - 1) & 7];

        if (bank1 == bank2) {

            lMask &= rMask;
        }

        lMask = ~lMask;
        rMask = ~rMask;

        pSrc = Buffer;
        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            plane = 1;
            for (i=0; i<4; i++) {

                pDstTemp = pDst;
                pSrcTemp = pSrc;

                __outpw(0x3c4, (plane << 8) | 2);

                colorMask = (UCHAR)((color & plane) ? 0xff : 0x00);

                plane <<= 1;  // bump up each time through loop

                count = width;

                //
                // non aligned case
                //

                if (x & 7) {

                    //
                    // Left Edge.
                    //

                    Value = READ_REGISTER_UCHAR(pDstTemp);

                    Value &= lMask;
                    Value |= (*pSrcTemp >> x) & colorMask;

                    WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                    count -= (8 - x);

                    //
                    // Now do center section
                    //

                    while (count > 7) {

                        Value = (*pSrcTemp << (8 - x)) | (*(pSrcTemp+1) >> x);
                        Value &= colorMask;

                        WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                        pSrcTemp++;
                        count -= 8;
                    }

                    //
                    // Now do the right edge.
                    //

                    if (count) {

                        Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp << (8 - x) & colorMask;

                        WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }

                } else {

                    //
                    // Aligned case.
                    //

                    ULONG  ulColorMask = colorMask ? 0xffffffff : 0x00000000;
                    USHORT usColorMask = colorMask ? 0xffff : 0x0000;

                    while (count > 31) {

                        WRITE_REGISTER_ULONG(((PULONG)pDstTemp)++, (ULONG)((*((PULONG)pSrcTemp)++) & ulColorMask));
                        count -= 32;
                    }

                    while (count > 15) {

                        WRITE_REGISTER_USHORT(((PUSHORT)pDstTemp)++, (USHORT)((*((PUSHORT)pSrcTemp)++) & usColorMask));
                        count -= 16;
                    }

                    if (count > 7) {

                        WRITE_REGISTER_UCHAR(pDstTemp++, (UCHAR)(*pSrcTemp++ & colorMask));
                        count -= 8;
                    }

                    //
                    // Now do any remaining bits.
                    //

                    if (count) {

                        Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp & colorMask;

                        WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }
                }
            }

            pSrc += ScanWidth;
            pDst += DELTA;
        }
    }
}

VOID
VidBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    )

/*++

Routine Description:

    This routine takes a bitmap resource and displays it at a given
    location.

Arguments:

    Buffer - Pointer to the bitmap resource.

    x, y - The position at which to display the bitmap.

--*/

{
    PBITMAPINFOHEADER bih;
    PRGBQUAD          Palette;

    LONG lDelta;
    PUCHAR pBuffer;
    LONG cbScanLine;

    bih = (PBITMAPINFOHEADER) Buffer;

    Palette = (PRGBQUAD)(((PUCHAR)bih) + bih->biSize);
    InitPaletteWithTable(Palette, bih->biClrUsed ? bih->biClrUsed : 16);

    //
    // Make sure this is a 1bpp or 4bpp bitmap.
    //

    if ((bih->biBitCount * bih->biPlanes) <= 4) {

        cbScanLine = (((bih->biWidth * bih->biBitCount) + 31) & ~31) >> 3;

        pBuffer = (PUCHAR)(Buffer + sizeof(BITMAPINFOHEADER) + 64);

        if (bih->biCompression == BI_RLE4) {

            if (bih->biWidth && bih->biHeight) {
                RleBitBlt(x,
                          y,
                          bih->biWidth,
                          bih->biHeight,
                          pBuffer);
            }

        } else {

            if (bih->biHeight < 0) {

                // top down bitmap
                lDelta = cbScanLine;
                bih->biHeight = -bih->biHeight;

            } else {

                // bottom up bitmap
                pBuffer += cbScanLine * (bih->biHeight - 1);
                lDelta = -cbScanLine;
            }

            if (bih->biWidth && bih->biHeight) {
                BitBlt(x,
                       y,
                       bih->biWidth,
                       bih->biHeight,
                       pBuffer,
                       bih->biBitCount,
                       lDelta);
            }
        }

    } else {

        //
        // We don't support this type of bitmap.
        //

        ASSERT((bih->biBitCount * bih->biPlanes) <= 4);
    }
}

VOID
VgaScroll(
    ULONG CharHeight
    )
{
    ULONG i, j;
    PUCHAR pDst, pSrc;
    PUCHAR pDstTemp, pSrcTemp;

    pDst = (PUCHAR)(VgaBase + ScrollRegion.y1 * DELTA + (ScrollRegion.x1 >> 3));
    pSrc = (PUCHAR)(pDst + DELTA * CharHeight);

    __outpw(0x3c4, 0x0f02);  // enable write to all planes
    __outpw(0x3ce, 0xff08);  // enable write to all bits in plane

    ReadWriteMode(0x0 | 0x1);  // set read mode = 0, write mode = 1

    for (i=ScrollRegion.y1; i<=ScrollRegion.y2; i++) {

        pDstTemp = pDst;
        pSrcTemp = pSrc;

        for (j=(ScrollRegion.x1 >> 3); j<=(ScrollRegion.x2 >> 3); j++) {
            WRITE_REGISTER_UCHAR(pDstTemp++, READ_REGISTER_UCHAR(pSrcTemp++));
        }

        pDst += DELTA;
        pSrc += DELTA;
    }
}

VOID
PreserveRow(
    ULONG y,
    ULONG CharHeight,
    BOOLEAN bRestore
    )
{
    PUCHAR pDst, pSrc;
    ULONG count;

    __outpw(0x3c4, 0x0f02);  // enable write to all planes
    __outpw(0x3ce, 0xff08);  // enable write to all bits in plane

    ReadWriteMode(0x0 | 0x1);  // set read mode = 0, write mode = 1

    if (bRestore) {
        pDst = (PUCHAR)(VgaBase + DELTA * y);
        pSrc = (PUCHAR)(VgaBase + DELTA * 480);
    } else {
        pDst = (PUCHAR)(VgaBase + DELTA * 480);
        pSrc = (PUCHAR)(VgaBase + DELTA * y);
    }

    count = CharHeight * DELTA;

    while (count--) {
        WRITE_REGISTER_UCHAR(pDst++, READ_REGISTER_UCHAR(pSrc++));
    }
}

VOID
VidScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    Upon completion, the video memory image will be in system memory.  Each
    plane of the image are stored seperately, so the first scan line of
    plane 0 will be followed by the first scan line of plane 1, etc.  Then
    the second scan of plane 0, plane 1, and so on.

--*/

{
    ULONG Plane, i, j, BankStart, BankEnd;
    PUCHAR pSrc, pSrcTemp, pDst;
    PULONG pulDstTemp;
    UCHAR Val1, Val2;
    ULONG Shift1, Shift2;
    UCHAR ucCombined;
    ULONG ulCombined;

    BankStart = x >> 3;
    BankEnd = (x + width - 1) >> 3;
    Shift1 = x & 7;
    Shift2 = 8 - Shift1;

    //
    // Zero initialize the buffer so we can or in the bits later!
    //

    pDst = Buffer;
    memset(pDst, 0, lDelta * height);

    for (Plane=0; Plane<4; Plane++) {

        pSrc = (PUCHAR)(VgaBase + (DELTA * y) + BankStart);
        pDst = Buffer;

        ReadWriteMode(0x0 | 0x0);            // set read mode 0
        __outpw(0x3ce, (Plane << 8) | 0x04); // read from given plane

        for (j=0; j<height; j++) {

            pSrcTemp = pSrc;
            pulDstTemp = (PULONG)pDst;

            Val1 = READ_REGISTER_UCHAR(pSrcTemp++);

            for (i=BankStart; i<=BankEnd; i++) {

                Val2 = READ_REGISTER_UCHAR(pSrcTemp++);

                ucCombined = (Val1 << Shift1) | (Val2 >> Shift2);
                ulCombined = ((lookup[(ucCombined & 0x0f) >> 0] << 16) |
                               lookup[(ucCombined & 0xf0) >> 4]) << Plane;


                *pulDstTemp++ |= ulCombined;

                Val1 = Val2;
            }

            pSrc += DELTA;   // go to next video memory scan line
            pDst += lDelta;  // go to next scan for this plane in buffer
        }
    }
}

void VidBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied
             from.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    This routine will allow you to blt from a buffer filled by
    VidScreenToBufferBlt.

--*/

{
    if (width && height) {
        BitBlt(x,
               y,
               width,
               height,
               Buffer,
               4,
               lDelta);
    }
}

VOID
SetPaletteEntry(
    ULONG index,
    ULONG RGB
    )
{
    __outpb(0x3c8, index);

    __outpb(0x3c9, RGB & 0xff);
    RGB >>= 8;
    __outpb(0x3c9, RGB & 0xff);
    RGB >>= 8;
    __outpb(0x3c9, RGB & 0xff);
}

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    )
{
    __outpb(0x3c8, index);
    __outpb(0x3c9, rgb.rgbRed   >> 2);
    __outpb(0x3c9, rgb.rgbGreen >> 2);
    __outpb(0x3c9, rgb.rgbBlue  >> 2);
}

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    )
{
    ULONG i;

    for (i=0; i<count; i++) {

        SetPaletteEntryRGB(i, *Palette++);
    }
}

VOID
InitializePalette(
    VOID
    )
{
    ULONG Palette[] =
    {
        0x00000000,
        0x00000020,
        0x00002000,
        0x00002020,
        0x00200000,
        0x00200020,
        0x00202000,
        0x00202020,
        0x00303030,
        0x0000003f,
        0x00003f00,
        0x00003f3f,
        0x003f0000,
        0x003f003f,
        0x003f3f00,
        0x003f3f3f,
    };
    ULONG i;

    for (i=0; i<16; i++) {

        SetPaletteEntry(i, Palette[i]);
    }

}

VOID
WaitForVsync(
    VOID
    )

/*++

Routine Description:

    Wait for a v-sync

--*/

{
    //
    // Check to see if vsync's are being generated.
    //

    WRITE_PORT_UCHAR((VgaRegisterBase+0x3c4), 00);

    if (READ_PORT_UCHAR(VgaRegisterBase+0x3c5) & 0x2) {

        ULONG MaxDelay;

        //
        // Slight delay.  Wait for one vsync.
        //

        MaxDelay = 100000;
        while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x08) && MaxDelay--);
        MaxDelay = 100000;
        while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x00) && MaxDelay--);
    }
}

VOID
VidSetScrollRegion(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2
    )

/*++

Routine Description:

    Controls the portion of the screen which is used for text.

Arguments:

    x1, y1, x2, y2 - coordinates of scroll rectangle.

Notes:

    x1 and x2 must be multiples of 8.

--*/

{
    ASSERT((x1 & 0x7) == 0);
    ASSERT((x2 & 0x7) == 7);

    ScrollRegion.x1 = x1;
    ScrollRegion.y1 = y1;
    ScrollRegion.x2 = x2;
    ScrollRegion.y2 = y2;

    curr_x = ScrollRegion.x1;
    curr_y = ScrollRegion.y1;
}

VOID
VidCleanUp(
    VOID
    )

/*++

Routine Description:

    This routine is called when the boot driver has lost ownership
    of the display.  This gives us to restore any vga registers which
    may need to be put back into a known state.

--*/

{
    //
    // Set the bit mask register to its default state.
    //

    WRITE_PORT_UCHAR((VgaRegisterBase+0x3ce), 0x08);
    WRITE_PORT_UCHAR((VgaRegisterBase+0x3cf), 0xff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\chk\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT ntdetect.chk
#
# Created:
#               14-Feb-1992
#
# Author:
#               Shie-Lin Tzong
#

.SUFFIXES:      .com .exe .obj .lst .c .asm .def .lnk .inc

!IF $(IA64)

OD= $(O)
DETECT_DEBUG= -DDBG=1

LINK=link
LIBS=$(SDK_LIB_PATH)\libcntpr.lib $(PROJECT_ROOT)\ntos\rtl\boot\$(O)\bldrrtl.lib

LIB=lib

OBJ= $(OD)\comlptc.obj \
     $(OD)\display.obj $(OD)\diskc.obj $(OD)\hwdetect.obj \
     $(OD)\hwheap.obj \
     $(OD)\hwvbiosc.obj \
     $(OD)\keybdc.obj $(OD)\mousec.obj \
     $(OD)\hwpbiosc.obj

$(OD)\ntdetect.chk: $(OBJ)

$(OD)\hwapm.obj    $(OD)\hwapm.cod:    ..\ia64\hwapm.c
$(OD)\display.obj  $(OD)\display.cod:  ..\ia64\display.c ..\ia64\types.h
$(OD)\diska.obj    $(OD)\diska.cod:    ..\ia64\diska.c
$(OD)\hwheap.obj   $(OD)\hwheap.cod:   ..\ia64\hwheap.c ..\ia64\hwdetect.h
$(OD)\hwdetect.obj $(OD)\hwdetect.cod: ..\ia64\hwdetect.c ..\ia64\hwdetect.h
$(OD)\keybdc.obj   $(OD)\keybdc.cod:   ..\ia64\keybdc.c ..\ia64\hwdetect.h
$(OD)\comlptc.obj  $(OD)\comlptc.cod:  ..\ia64\comlptc.c ..\ia64\hwdetect.h
$(OD)\mousec.obj   $(OD)\mousec.cod:   ..\ia64\mousec.c ..\ia64\hwdetect.h
$(OD)\diskc.obj    $(OD)\diskc.cod:    ..\ia64\diskc.c ..\ia64\hwdetect.h ..\ia64\disk.h
$(OD)\hweisac.obj  $(OD)\hweisac.cod:  ..\ia64\hweisac.c ..\ia64\hwdetect.h
$(OD)\hwvbiosc.obj $(OD)\hwvbiosc.cod: ..\ia64\hwvbiosc.c ..\ia64\hwdetect.h ..\ia64\hwvbios.h
$(OD)\hwpbiosc.obj $(OD)\hwpbiosc.cod: ..\ia64\hwpbiosc.c ..\ia64\hwdetect.h ..\ia64\pnpbios.h

$(OD)\ntdetect.chk: $(OBJ) $(DOBJ) $(LIBS)
  $(LINK) \
  -machine:IA64            \
  -out:$(OD)\ntdetect.chk  \
  -entry:HardwareDetection \
  -base:0x10000            \
  -nodefaultlib            \
  -debug:notmapped         \
  -debugtype:coff          \
  -force:multiple          \
  -fixed:no                \
  -subsystem:native,5.00   \
  $(OBJ)                   \
  $(LIBS)

  binplace -R $(_NTTREE) $(OD)\ntdetect.chk

!ELSE

PATH= $(PATH_TOOLS16);$(PATH)

OD= $(O)
DETECT_DEBUG= -DDBG=1

CC=     cl16
CFLAGS= -WX -W3 -G2s -Zelp $(DETECT_DEBUG) $(ALT_PROJECT_TEMPD) $(BLFLAGS) -nologo
CINCSX=.;$(PROJECT_ROOT)\ntos\inc;$(SDK_INC_PATH);..\i386;$(BASE_INC_PATH);$(HALKIT_INC_PATH)

#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx -z $(DETECT_DEBUG) $(ALT_PROJECT_TEMPD) $(GAFLAGS)
AINCSX= $(SDK_INC_PATH);..\i386

#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16
LIBS=..\i386\long.lib ..\i386\slibce.lib ..\i386\llibce.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{..\i386\}.asm{$(OD)}.obj:
        set include=$(AINCSX)
        $(ASM) $(AFLAGS) $<, $@;

{..\i386\}.asm{$(OD)}.lst:
        set include=$(AINCSX)
        $(ASM) -l -n $(AFLAGS) $<, $*.obj, $@;

{..\i386\}.c{$(OD)}.obj:
        set include=$(CINCSX)
        @echo $(CC) $(CFLAGS)  -c -Fo$@ $<
        @$(CC) $(CFLAGS)  -c -Fo$@ $< | findstr /v C4011

{..\i386\}.c{$(OD)}.cod:
        set include=$(CINCSX)
        $(CC) $(CFLAGS)  -c -Fc$@ $<

#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(OD)\main.obj $(OD)\comlptc.obj $(OD)\diska.obj \
     $(OD)\display.obj $(OD)\diskc.obj $(OD)\hwdetect.obj $(OD)\hweisaa.obj \
     $(OD)\hweisac.obj $(OD)\hwheap.obj \
     $(OD)\hwmisca.obj $(OD)\hwvbiosc.obj $(OD)\keybda.obj \
     $(OD)\keybdc.obj $(OD)\mousea.obj $(OD)\mousec.obj $(OD)\videoa.obj \
     $(OD)\hwpcia.obj $(OD)\hwapm.obj $(OD)\hwpbiosc.obj \
     $(OD)\hwpmbios.obj $(OD)\pccarda.obj $(OD)\pccardc.obj $(OD)\pcibios.obj $(OD)\pcienum.obj

#
#       Dependencies
#       ~~~~~~~~~~~~

$(OD)\ntdetect.chk: $(OBJ)

$(OD)\hweisaa.obj  $(OD)\hweisaa.cod:  ..\i386\hweisa.inc ..\i386\hweisaa.asm
$(OD)\hwpcia.obj   $(OD)\hwpcia.cod:   ..\i386\hwpci.inc ..\i386\hwpcia.asm
$(OD)\hwapm.obj    $(OD)\hwapm.cod:    ..\i386\hwapm.c
$(OD)\main.obj     $(OD)\main.lst:     ..\i386\main.asm ..\i386\main.inc
$(OD)\display.obj  $(OD)\display.cod:  ..\i386\display.c ..\i386\types.h
$(OD)\diska.obj    $(OD)\diska.lst:    ..\i386\diska.asm
$(OD)\hwheap.obj   $(OD)\hwheap.cod:   ..\i386\hwheap.c ..\i386\hwdetect.h
$(OD)\hwdetect.obj $(OD)\hwdetect.cod: ..\i386\hwdetect.c ..\i386\hwdetect.h
$(OD)\hwmisca.obj  $(OD)\hwmisca.lst:  ..\i386\hwmisca.asm
$(OD)\videoa.obj   $(OD)\videoa.lst:   ..\i386\videoa.asm
$(OD)\keybdc.obj   $(OD)\keybdc.cod:   ..\i386\keybdc.c ..\i386\hwdetect.h
$(OD)\keybda.obj   $(OD)\keybda.lst:   ..\i386\keybda.asm
$(OD)\comlptc.obj  $(OD)\comlptc.cod:  ..\i386\comlptc.c ..\i386\hwdetect.h
$(OD)\mousea.obj   $(OD)\mousea.lst:   ..\i386\mousea.asm ..\i386\mouse.inc
$(OD)\mousec.obj   $(OD)\mousec.cod:   ..\i386\mousec.c ..\i386\hwdetect.h
$(OD)\diskc.obj    $(OD)\diskc.cod:    ..\i386\diskc.c ..\i386\hwdetect.h ..\i386\disk.h
$(OD)\hweisac.obj  $(OD)\hweisac.cod:  ..\i386\hweisac.c ..\i386\hwdetect.h
$(OD)\hwpbiosc.obj $(OD)\hwpbiosc.cod: ..\i386\hwpbiosc.c  ..\i386\hwdetect.h ..\i386\pnpbios.h
$(OD)\hwvbiosc.obj $(OD)\hwvbiosc.cod: ..\i386\hwvbiosc.c ..\i386\hwdetect.h ..\i386\hwvbios.h
$(OD)\hwpmbios.obj $(OD)\hwpmbios.cod: ..\i386\hwpmbios.c ..\i386\hwdetect.h ..\i386\acpibios.h
$(OD)\pccarda.obj  $(OD)\pccarda.lst:  ..\i386\pccarda.asm ..\i386\pccard.inc
$(OD)\pccardc.obj  $(OD)\pccardc.cod:  ..\i386\pccardc.c ..\i386\hwdetect.h ..\i386\pccard.h
$(OD)\pcibios.obj  $(OD)\pcibios.cod:  ..\i386\pcibios.c ..\i386\hwdetect.h ..\i386\pcibios.h
$(OD)\pcienum.obj  $(OD)\pcienum.cod:  ..\i386\pcienum.c ..\i386\hwdetect.h ..\i386\pcienum.h

$(OD)\ntdetect.chk: $(OBJ) $(DOBJ) $(LIBS)
  $(LINK) @<<
  /tiny /nod /noi /map /onerror:noexe $(OD)\main $(OD)\hweisaa $(OD)\display +
    $(OD)\hwheap $(OD)\hwdetect $(OD)\hwmisca $(OD)\videoa +
    $(OD)\keybda $(OD)\keybdc $(OD)\comlptc $(OD)\mousea $(OD)\mousec +
    $(OD)\diskc $(OD)\diska $(OD)\hweisac +
    $(OD)\hwvbiosc $(OD)\hwpcia $(OD)\hwapm +
    $(OD)\hwpbiosc $(OD)\hwpmbios $(OD)\pccarda $(OD)\pccardc $(OD)\pcibios $(OD)\pcienum
  $(OD)\ntdetect.chk,
  $(OD)\ntdetect.map,
  $(LIBS);
<<
  binplace -R $(_NTTREE) $(OD)\ntdetect.chk

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\chk\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=detect

TARGETNAME=ntdetect.chk
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);$(PROJECT_ROOT)\ntos\inc;$(PROJECT_ROOT)\boot\inc;

SOURCES=

i386_SOURCES=..\i386\hweisaa.asm    \
             ..\i386\hweisac.c      \
             ..\i386\hwpcia.asm     \
             ..\i386\main.asm       \
             ..\i386\display.c      \
             ..\i386\diska.asm      \
             ..\i386\diskc.c        \
             ..\i386\hwheap.c       \
             ..\i386\hwdetect.c     \
             ..\i386\hwmisca.asm    \
             ..\i386\videoa.asm     \
             ..\i386\keybdc.c       \
             ..\i386\keybda.asm     \
             ..\i386\comlptc.c      \
             ..\i386\mousea.asm     \
             ..\i386\mousec.c       \
             ..\i386\hwpbiosc.c     \
             ..\i386\hwvbiosc.c     \
             ..\i386\pccarda.asm    \
             ..\i386\pccardc.c      \
             ..\i386\pcibios.c

!if $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\ntdetect.chk
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\fre\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT ntdetect.com
#
# Created:
#               14-Feb-1992
#
# Author:
#               Shie-Lin Tzong
#

.SUFFIXES:      .com .exe .obj .lst .c .asm .def .lnk .inc

!IF $(IA64)

OD= $(O)
DETECT_DEBUG= -DDBG=0

LINK=link
LIBS=$(SDK_LIB_PATH)\libcntpr.lib $(PROJECT_ROOT)\ntos\rtl\boot\$(O)\bldrrtl.lib

LIB=lib

OBJ= $(OD)\comlptc.obj \
     $(OD)\display.obj $(OD)\diskc.obj $(OD)\hwdetect.obj \
     $(OD)\hwheap.obj \
     $(OD)\hwvbiosc.obj \
     $(OD)\keybdc.obj $(OD)\mousec.obj \
     $(OD)\hwpbiosc.obj

$(OD)\ntdetect.exe: $(OBJ)

$(OD)\hwapm.obj    $(OD)\hwapm.cod:    ..\ia64\hwapm.c
$(OD)\display.obj  $(OD)\display.cod:  ..\ia64\display.c ..\ia64\types.h
$(OD)\diska.obj    $(OD)\diska.cod:    ..\ia64\diska.c
$(OD)\hwheap.obj   $(OD)\hwheap.cod:   ..\ia64\hwheap.c ..\ia64\hwdetect.h
$(OD)\hwdetect.obj $(OD)\hwdetect.cod: ..\ia64\hwdetect.c ..\ia64\hwdetect.h
$(OD)\keybdc.obj   $(OD)\keybdc.cod:   ..\ia64\keybdc.c ..\ia64\hwdetect.h
$(OD)\comlptc.obj  $(OD)\comlptc.cod:  ..\ia64\comlptc.c ..\ia64\hwdetect.h
$(OD)\mousec.obj   $(OD)\mousec.cod:   ..\ia64\mousec.c ..\ia64\hwdetect.h
$(OD)\diskc.obj    $(OD)\diskc.cod:    ..\ia64\diskc.c ..\ia64\hwdetect.h ..\ia64\disk.h
$(OD)\hweisac.obj  $(OD)\hweisac.cod:  ..\ia64\hweisac.c ..\ia64\hwdetect.h
$(OD)\hwvbiosc.obj $(OD)\hwvbiosc.cod: ..\ia64\hwvbiosc.c ..\ia64\hwdetect.h ..\ia64\hwvbios.h
$(OD)\hwpbiosc.obj $(OD)\hwpbiosc.cod: ..\ia64\hwpbiosc.c ..\ia64\hwdetect.h ..\ia64\pnpbios.h

$(OD)\ntdetect.exe: $(OBJ) $(DOBJ) $(LIBS)
  $(LINK) \
  -machine:IA64            \
  -out:$(OD)\ntdetect.exe  \
  -entry:HardwareDetection \
  -base:0x10000            \
  -nodefaultlib            \
  -debugtype:coff          \
  -force:multiple          \
  -fixed:no                \
  -subsystem:native,5.00   \
  $(OBJ)                   \
  $(LIBS)

!ELSE

PATH= $(PATH_TOOLS16);$(PATH)

OD= $(O)
DETECT_DEBUG= -DDBG=0

CC=     cl16
CFLAGS= -WX -W3 -G2s -Zelp $(DETECT_DEBUG) $(ALT_PROJECT_TEMPD) $(BLFLAGS) -nologo
CINCSX=.;$(PROJECT_ROOT)\ntos\inc;$(SDK_INC_PATH);..\i386;$(BASE_INC_PATH);$(HALKIT_INC_PATH)

#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx -z $(DETECT_DEBUG) $(ALT_PROJECT_TEMPD) $(GAFLAGS)
AINCSX= $(SDK_INC_PATH);..\i386

#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16
LIBS=..\i386\long.lib ..\i386\slibce.lib ..\i386\llibce.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{..\i386\}.asm{$(OD)}.obj:
        set include=$(AINCSX)
        $(ASM) $(AFLAGS) $<, $@;

{..\i386\}.asm{$(OD)}.lst:
        set include=$(AINCSX)
        $(ASM) -l -n $(AFLAGS) $<, $*.obj, $@;

{..\i386\}.c{$(OD)}.obj:
        set include=$(CINCSX)
        @echo $(CC) $(CFLAGS)  -c -Fo$@ $<
        @$(CC) $(CFLAGS)  -c -Fo$@ $< | findstr /v C4011

{..\i386\}.c{$(OD)}.cod:
        set include=$(CINCSX)
        $(CC) $(CFLAGS)  -c -Fc$@ $<

#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(OD)\main.obj $(OD)\comlptc.obj $(OD)\diska.obj \
     $(OD)\display.obj $(OD)\diskc.obj $(OD)\hwdetect.obj $(OD)\hweisaa.obj \
     $(OD)\hweisac.obj $(OD)\hwheap.obj \
     $(OD)\hwmisca.obj $(OD)\hwvbiosc.obj $(OD)\keybda.obj \
     $(OD)\keybdc.obj $(OD)\mousea.obj $(OD)\mousec.obj $(OD)\videoa.obj \
     $(OD)\hwpcia.obj $(OD)\hwapm.obj $(OD)\hwpbiosc.obj \
     $(OD)\hwpmbios.obj $(OD)\pccarda.obj $(OD)\pccardc.obj $(OD)\pcibios.obj $(OD)\pcienum.obj

#
#       Dependencies
#       ~~~~~~~~~~~~

$(OD)\ntdetect.com: $(OBJ)

$(OD)\hweisaa.obj  $(OD)\hweisaa.cod:  ..\i386\hweisa.inc ..\i386\hweisaa.asm
$(OD)\hwpcia.obj   $(OD)\hwpcia.cod:   ..\i386\hwpci.inc ..\i386\hwpcia.asm
$(OD)\hwapm.obj    $(OD)\hwapm.cod:    ..\i386\hwapm.c
$(OD)\main.obj     $(OD)\main.lst:     ..\i386\main.asm ..\i386\main.inc
$(OD)\display.obj  $(OD)\display.cod:  ..\i386\display.c ..\i386\types.h
$(OD)\diska.obj    $(OD)\diska.lst:    ..\i386\diska.asm
$(OD)\hwheap.obj   $(OD)\hwheap.cod:   ..\i386\hwheap.c ..\i386\hwdetect.h
$(OD)\hwdetect.obj $(OD)\hwdetect.cod: ..\i386\hwdetect.c ..\i386\hwdetect.h
$(OD)\hwmisca.obj  $(OD)\hwmisca.lst:  ..\i386\hwmisca.asm
$(OD)\videoa.obj   $(OD)\videoa.lst:   ..\i386\videoa.asm
$(OD)\keybdc.obj   $(OD)\keybdc.cod:   ..\i386\keybdc.c ..\i386\hwdetect.h
$(OD)\keybda.obj   $(OD)\keybda.lst:   ..\i386\keybda.asm
$(OD)\comlptc.obj  $(OD)\comlptc.cod:  ..\i386\comlptc.c ..\i386\hwdetect.h
$(OD)\mousea.obj   $(OD)\mousea.lst:   ..\i386\mousea.asm ..\i386\mouse.inc
$(OD)\mousec.obj   $(OD)\mousec.cod:   ..\i386\mousec.c ..\i386\hwdetect.h
$(OD)\diskc.obj    $(OD)\diskc.cod:    ..\i386\diskc.c ..\i386\hwdetect.h ..\i386\disk.h
$(OD)\hweisac.obj  $(OD)\hweisac.cod:  ..\i386\hweisac.c ..\i386\hwdetect.h
$(OD)\hwpbiosc.obj $(OD)\hwpbiosc.cod: ..\i386\hwpbiosc.c  ..\i386\hwdetect.h ..\i386\pnpbios.h
$(OD)\hwvbiosc.obj $(OD)\hwvbiosc.cod: ..\i386\hwvbiosc.c ..\i386\hwdetect.h ..\i386\hwvbios.h
$(OD)\hwpmbios.obj $(OD)\hwpmbios.cod: ..\i386\hwpmbios.c ..\i386\hwdetect.h ..\i386\acpibios.h
$(OD)\pccarda.obj  $(OD)\pccarda.lst:  ..\i386\pccarda.asm ..\i386\pccard.inc
$(OD)\pccardc.obj  $(OD)\pccardc.cod:  ..\i386\pccardc.c ..\i386\hwdetect.h ..\i386\pccard.h
$(OD)\pcibios.obj  $(OD)\pcibios.cod:  ..\i386\pcibios.c ..\i386\hwdetect.h ..\i386\pcibios.h
$(OD)\pcienum.obj  $(OD)\pcienum.cod:  ..\i386\pcienum.c ..\i386\hwdetect.h ..\i386\pcienum.h

$(OD)\ntdetect.com: $(OBJ) $(DOBJ) $(LIBS)
  $(LINK) @<<
  /tiny /nod /noi /map /onerror:noexe $(OD)\main $(OD)\hweisaa $(OD)\display +
    $(OD)\hwheap $(OD)\hwdetect $(OD)\hwmisca $(OD)\videoa +
    $(OD)\keybda $(OD)\keybdc $(OD)\comlptc $(OD)\mousea $(OD)\mousec +
    $(OD)\diskc $(OD)\diska $(OD)\hweisac +
    $(OD)\hwvbiosc $(OD)\hwpcia $(OD)\hwapm +
    $(OD)\hwpbiosc $(OD)\hwpmbios $(OD)\pccarda $(OD)\pccardc $(OD)\pcibios $(OD)\pcienum
  $(OD)\ntdetect.com,
  $(OD)\ntdetect.map,
  $(LIBS);
<<

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\acpibios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpibios.h

Abstract:

    ACPI BIOS  spec related definitions

Author:

    Jake Oshins (jakeo) Feb 6, 1997

Revision History:

--*/

//
// Acpi BIOS Installation check
//

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, far *FPACPI_BIOS_INSTALLATION_CHECK;

typedef struct {
    PHYSICAL_ADDRESS    Base;
    LARGE_INTEGER       Length;
    ULONG               Type;
    ULONG               Reserved;
} ACPI_E820_ENTRY, far *FPACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONG               Count;
    ULONG               Reserved;       // don't use this.  W2K depends on it being zero - oops
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE, far *FPACPI_BIOS_MULTI_NODE;
                    
#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16

typedef struct {
    USHORT  Signature;
    USHORT  CommandPortAddress;
    USHORT  EventPortAddress;
    USHORT  PollInterval;
    UCHAR   CommandDataValue;
    UCHAR   EventPortBitmask;
    UCHAR   MaxLevelAc;
    UCHAR   MaxLevelDc;
} LEGACY_GEYSERVILLE_INT15, *PLEGACY_GEYSERVILLE_INT15;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\fre\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=detect

TARGETNAME=ntdetect.com
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);$(PROJECT_ROOT)\ntos\inc;$(PROJECT_ROOT)\boot\inc;

SOURCES=

i386_SOURCES=..\i386\hweisaa.asm    \
             ..\i386\hweisac.c      \
             ..\i386\hwpcia.asm     \
             ..\i386\main.asm       \
             ..\i386\display.c      \
             ..\i386\diska.asm      \
             ..\i386\diskc.c        \
             ..\i386\hwheap.c       \
             ..\i386\hwdetect.c     \
             ..\i386\hwmisca.asm    \
             ..\i386\videoa.asm     \
             ..\i386\keybdc.c       \
             ..\i386\keybda.asm     \
             ..\i386\comlptc.c      \
             ..\i386\mousea.asm     \
             ..\i386\mousec.c       \
             ..\i386\hwpbiosc.c     \
             ..\i386\hwvbiosc.c     \
             ..\i386\pccarda.asm    \
             ..\i386\pccardc.c      \
             ..\i386\pcibios.c

!if $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\ntdetect.com
MISCFILES=$(_OBJ_DIR)\i386\ntdetect.com

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file declares the constants, structures, and functions
*       used for accessing and using various BIOS interfaces.
*
****/

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT       0       /* init serial port */
#define _COM_SEND       1       /* send character */
#define _COM_RECEIVE    2       /* receive character */
#define _COM_STATUS     3       /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7       2       /* 7 bits characters */
#define _COM_CHR8       3       /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1      0       /* 1 stop bit */
#define _COM_STOP2      4       /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0       /* no parity */
#define _COM_ODDPARITY  8       /* odd parity */
#define _COM_EVENPARITY 24      /* even parity */

/*  baud rate initializers */

#define _COM_110        0       /* 110 baud */
#define _COM_150        32      /* 150 baud */
#define _COM_300        64      /* 300 baud */
#define _COM_600        96      /* 600 baud */
#define _COM_1200       128     /* 1200 baud */
#define _COM_2400       160     /* 2400 baud */
#define _COM_4800       192     /* 4800 baud */
#define _COM_9600       224     /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET     0       /* reset disk controller */
#define _DISK_STATUS    1       /* get disk status */
#define _DISK_READ      2       /* read disk sectors */
#define _DISK_WRITE     3       /* write disk sectors */
#define _DISK_VERIFY    4       /* verify disk sectors */
#define _DISK_FORMAT    5       /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void _far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ            0       /* read next character from keyboard */
#define _KEYBRD_READY           1       /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS     2       /* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ           0x10    /* read next character from keyboard */
#define _NKEYBRD_READY          0x11    /* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0       /* write character to printer */
#define _PRINTER_INIT   1       /* intialize printer */
#define _PRINTER_STATUS 2       /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0       /* get current clock count */
#define _TIME_SETCLOCK  1       /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _bios_disk(unsigned, struct diskinfo_t *);
unsigned _bios_equiplist(void);
unsigned _bios_keybrd(unsigned);
unsigned _bios_memsize(void);
unsigned _bios_printer(unsigned, unsigned, unsigned);
unsigned _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _bios_timeofday(unsigned, long *);
int int86(int, union REGS *, union REGS *);
int int86x(int, union REGS *, union REGS *, struct SREGS *);

#endif /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\comlpt.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for comport detection code.
    The code is extracted from NT Hal for kernel debugger.

Author:

    Shie-Lin Tzong (shielint) Dec-23-1991.

Revision History:

--*/

#define MAX_COM_PORTS   4           // Max. number of comports detectable
#define MAX_LPT_PORTS   3           // Max. number of LPT ports detectable

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT
#define COM4_PORT

#define BAUD_RATE_9600_MSB  0x0
#define BAUD_RATE_9600_LSB  0xC
#define IER_TEST_VALUE 0xF

//
// Offsets from the base register address of the
// various registers for the 8250 family of UARTS.
//
#define RECEIVE_BUFFER_REGISTER         (0x00u)
#define TRANSMIT_HOLDING_REGISTER       (0x00u)
#define INTERRUPT_ENABLE_REGISTER       (0x01u)
#define INTERRUPT_IDENT_REGISTER        (0x02u)
#define FIFO_CONTROL_REGISTER           (0x02u)
#define LINE_CONTROL_REGISTER           (0x03u)
#define MODEM_CONTROL_REGISTER          (0x04u)
#define LINE_STATUS_REGISTER            (0x05u)
#define MODEM_STATUS_REGISTER           (0x06u)
#define DIVISOR_LATCH_LSB               (0x00u)
#define DIVISOR_LATCH_MSB               (0x01u)
#define SERIAL_REGISTER_LENGTH          (7)

//
// These masks define access to the line control register.
//

//
// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
//
#define SERIAL_LCR_DLAB     0x80

//
// This defines the bit used to control whether the device is sending
// a break.  When this bit is set the device is sending a space (logic 0).
//
// Most protocols will assume that this is a hangup.
//
#define SERIAL_LCR_BREAK    0x40


//
// This macro writes to the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ModemControl - The control bits to send to the modem control.
//
//

#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)          \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+MODEM_CONTROL_REGISTER,                  \
        (ModemControl)                                         \
        );                                                     \
} while (0)

//
// This macro reads the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_CONTROL(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_CONTROL_REGISTER))

//
// This macro reads the interrupt identification register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Note that this routine potententially quites a transmitter
// empty interrupt.  This is because one way that the transmitter
// empty interrupt is cleared is to simply read the interrupt id
// register.
//
//
#define READ_INTERRUPT_ID_REG(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_IDENT_REGISTER))



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\comlptc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    comport.c

Abstract:

    This module contains C code to determine comport and LPT configuration in
    syste.

Author:

    Shie-Lin Tzong (shielint) Dec-23-1991

Revision History:

--*/

#include "hwdetect.h"
#include "comlpt.h"
#include "bios.h"
#include "string.h"

#define LOWEST_IRQ 3
#define MASTER_IRQ_MASK_BITS 0xf8
#define SLAVE_IRQ_MASK_BITS 0xfe

//
// ComPortAddress[] is a global array to remember which comports have
// been detected and their I/O port addresses.
//

USHORT   ComPortAddress[MAX_COM_PORTS] = {0, 0, 0, 0};

VOID
SerialInterruptRequest (
    PUCHAR PortAddress
    )

/*++

Routine Description:

    This routine generates an interrupt on the interrupt line for
    com port.

Arguments:

    PortAddress - the port address of the desired com port.

Return Value:

    None.
--*/

{

    USHORT i;
    UCHAR Temp;

    WRITE_PORT_UCHAR(
        PortAddress + MODEM_CONTROL_REGISTER,
        8
        );

    WRITE_PORT_UCHAR(
        PortAddress + INTERRUPT_ENABLE_REGISTER,
        0
        );

    WRITE_PORT_UCHAR(
        PortAddress + INTERRUPT_ENABLE_REGISTER,
        0xf
        );

    //
    // Add some delay
    //

    for (i = 0; i < 5 ; i++ ) {
        Temp = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
        Temp = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);
    }
}
VOID
SerialInterruptDismiss (
    PUCHAR PortAddress
    )

/*++

Routine Description:

    This routine dismisses an interrupt on the interrupt line for
    com port.

Arguments:

    PortAddress - the port address of the desired com port.

Return Value:

    None.
--*/

{
    USHORT i;
    UCHAR Temp;

    Temp = READ_PORT_UCHAR(
                PortAddress + INTERRUPT_IDENT_REGISTER
                );

    WRITE_PORT_UCHAR(
                PortAddress + INTERRUPT_ENABLE_REGISTER,
                0
                );

    //
    // Add some delay
    //

    for (i = 0; i < 5 ; i++ ) {
        Temp = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
        Temp = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);
    }
}

BOOLEAN
DoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine examines several of what might be the serial device
    registers.  It ensures that the bits that should be zero are zero.
    It will then attempt to set the device to 19200 baud.  If the
    will then attempt to read that baud.  If it is still 19200 then
    we can feel pretty safe that this is a serial device.

    NOTE: If there is indeed a serial port at the address specified
          it will absolutely have interrupts inhibited upon return
          from this routine.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.  Party on.

    FALSE - Port doesn't exist.  Don't use it.

History:
    7/23/97 a-paulbr fixed bug 95050.  Init LineControl to 0x00

--*/

{

    UCHAR IerContents;
    UCHAR BaudRateMsb, BaudRateLsb;
    BOOLEAN ReturnValue = FALSE;
    UCHAR LineControl = 0x00;
    UCHAR LineControl_Save;
    UCHAR Temp;

    //
    // Save the original LCR, so we can restore it later
    // We won't use it, because the port could be handing us
    // a bad initial value.  We will use 0x00 instead.
    //

    LineControl_Save = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER);

    //
    // Read original baud rate divisor and save it.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );
    BaudRateMsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);
    BaudRateLsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);

    //
    // Change baud rate to 9600.
    //

    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_MSB, BAUD_RATE_9600_MSB);
    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_LSB, BAUD_RATE_9600_LSB);

    //
    // Read IER and save it away.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );
    IerContents = READ_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER
        );

    WRITE_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER,
        IER_TEST_VALUE
        );

    //
    // Read baud rate divisor.  The values we read should be equal to the
    // values we set earlier.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );
    Temp = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);
    if (Temp != BAUD_RATE_9600_MSB) {
        goto AllDone;
    }
    Temp = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);
    if (Temp != BAUD_RATE_9600_LSB) {
        goto AllDone;
    }

    //
    // Read IER and it should be equal to the value we set earlier.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );
    Temp = READ_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER
        );
    if (Temp != IER_TEST_VALUE) {
        goto AllDone;
    }
    ReturnValue = TRUE;

AllDone:

    //
    // Restore registers which we destroyed .
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );

    WRITE_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER,
        IerContents
        );

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );

    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_MSB, BaudRateMsb);
    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_LSB, BaudRateLsb);

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        LineControl_Save
        );

    return ReturnValue;
}

BOOLEAN
HwInterruptDetection(
    IN PUCHAR BasePort,
    IN VOID (*InterruptRequestRoutine)(PUCHAR),
    IN VOID (*InterruptDismissRoutine)(PUCHAR),
    OUT PUSHORT Vector
    )

/*++

Routine Description:

    This routine attempts to locate the interrupt vector for which
    the device is configured.  The allowable vectors are
    3 - 7, and 9 - 15.  If no interrupt vector is found, or more than
    one is found, the routine returns FALSE.  Otherwise, TRUE is returned.

    Note that we diddle the i8259 interrupt controllers here.

Arguments:

    BasePort - the I/O port base for the device.

    InterruptRequestRoutine - A pointer to a routine to generate
                desired interrupt.

    InterruptDismissRoutine - A pointer to a routine to dismiss the interrupt
                generated by InterruptRequestRoutine.

    Vector - Pointer to the location to store the mouse interrupt vector.

Return Value:

    Returns TRUE if the Inport interrupt vector was located; otherwise,
    FALSE is returned.

--*/

{
    UCHAR OldMasterMask, OldSlaveMask;
    UCHAR MasterMask, SlaveMask;
    UCHAR InterruptBits;
    UCHAR PossibleInterruptBits;
    int i;
    int NumberOfIRQs;
    BOOLEAN VectorFound = FALSE;

    //
    // Get the i8259 interrupt masks.
    //

    OldMasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
    OldSlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

    //
    // Raise IRQL to the highest priority IRQL the inport would use.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) 0xff ^ ((UCHAR)(1 << LOWEST_IRQ) - 1)
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        (UCHAR) 0xfe
        );

    //
    // Get the master i8259 interrupt mask.
    //

    MasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);

    //
    // Disable potential device interrupts.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) (MasterMask | MASTER_IRQ_MASK_BITS)
        );

    //
    // Attempt to locate the interrupt line on the master i8259.
    // Why try this 10 times?  It's magic...
    //

    PossibleInterruptBits = MASTER_IRQ_MASK_BITS;
    for (i = 0; i < 10; i++) {


        //
        // Generate a 0 on the master 8259 interrupt line
        //

        (*InterruptDismissRoutine)(BasePort);

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 3 - 7 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        _asm {cli}
        WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);
        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        _asm {sti}
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        InterruptBits ^= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;
        if (!PossibleInterruptBits) {
            break;
        }

        //
        // Generate an interrupt from the desired device.
        //

        (*InterruptRequestRoutine)(BasePort);

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 3 - 7 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        _asm {cli}
        WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);
        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        _asm {sti}
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits) {
            break;
        }
    }

    if (PossibleInterruptBits) {

        //
        // We found at least one IRQ on the master i8259 that could belong
        // to the Inport mouse.  Count how many we found.  If there is
        // more than one, we haven't found the vector.  Otherwise, we've
        // successfully located the Inport interrupt vector on the master
        // i8259 (provided the interrupt vector is 3, 4, 5, or 7).
        //

        PossibleInterruptBits >>= 3;
        NumberOfIRQs = 0;
        for (i = 3; i <= 7; i++) {
            if (PossibleInterruptBits & 1) {
                NumberOfIRQs += 1;
                *Vector = (CCHAR) i;
            }
            PossibleInterruptBits >>= 1;
        }
        if (NumberOfIRQs == 1) {
            VectorFound = TRUE;
        }
    }

    //
    // If we didn't locate the interrupt vector on the master i8259, attempt
    // to locate it on the slave i8259.
    //

    if (!VectorFound) {

        //
        // Get the slave i8259 interrupt mask.
        //

        SlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

        //
        // Attempt to locate the interupt line on the slave i8259.
        // Why try this 20 times?  It's magic...
        //

        PossibleInterruptBits = SLAVE_IRQ_MASK_BITS;
        for (i = 0; i < 20; i++) {

            //
            // Generate a 0 on the Inport IRQ on the slave i8259.
            //

            (*InterruptDismissRoutine)(BasePort);

            //
            // Read the interrupt bits off the slave i8259.
            // Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            _asm {cli}
            WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);
            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            _asm {sti}
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            InterruptBits ^= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;
            if (!PossibleInterruptBits) {
                break;
            }

            //
            // Generate a 1 on the Inport IRQ on the slave i8259.
            //

            (*InterruptRequestRoutine)(BasePort);

            //
            // Read the interrupt bits off the slave i8259.
            // Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            _asm {cli}
            WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);
            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            _asm {sti}
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits) {
                break;
            }

        }

        if (PossibleInterruptBits) {

            //
            // We found at least one IRQ on the slave i8259 that could belong
            // to the device.  Count how many we found.  If there is
            // more than one, we haven't found the vector.  Otherwise, we've
            // successfully located the device interrupt vector on the slave
            // i8259.
            //

            PossibleInterruptBits >>= 1;
            NumberOfIRQs = 0;
            for (i = 9; i <= 15; i++) {
                if (PossibleInterruptBits & 1) {
                    NumberOfIRQs += 1;
                    *Vector = (CCHAR) i;
                }
                PossibleInterruptBits >>= 1;
            }
            if (NumberOfIRQs == 1) {
                VectorFound = TRUE;
            }
        }

        //
        // Restore the i8259 slave.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_ISR);

        //
        // Restore the i8259 slave interrupt mask.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT1, SlaveMask);
    }

    //
    // Dismiss interrupt on the device
    //

    (*InterruptDismissRoutine)(BasePort);

    //
    // Restore the i8259 master.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_ISR);

    //
    // Restore the i8259 master interrupt mask.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT1, MasterMask);

    //
    // Restore the previous IRQL.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        OldMasterMask
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        OldSlaveMask
        );

    return(VectorFound);
}

FPFWCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the comports information
    for the system.  The information includes port address, irq
    level.

    Note that this routine can only detect up to 4 comports and
    it assumes that if MCA, COM3 and COM4 use irq 4.  Otherwise,
    COM3 uses irq 4 and COM4 uses irq 3.  Also, the number of ports
    for COMPORT is set to 8 (for example, COM2 uses ports 2F8 - 2FF)

Arguments:

    None.

Return Value:

    A pointer to a stucture of type FWCONFIGURATION_COMPONENT_DATA
    which is the root of comport component list.
    If no comport exists, a value of NULL is returned.

--*/

{

    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstComport = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR i, j, z;
    SHORT Port;
    UCHAR ComportName[] = "COM?";
    CM_SERIAL_DEVICE_DATA SerialData;
    ULONG BaudClock = 1843200;
    USHORT Vector;
    BOOLEAN PortExist;
    USHORT IoPorts[MAX_COM_PORTS] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};


    //
    // BIOS DATA area 40:0 is the port address of the first valid COM port
    //

    USHORT far *pPortAddress = (USHORT far *)0x00400000;

    //
    // Initialize serial device specific data
    //

    SerialData.Version = 0;
    SerialData.Revision = 0;
    SerialData.BaudClock = 1843200;

    //
    // Initialize default COM port address.
    // Some BIOS puts incorrect comport address to the 40:0 area.
    // To cope with this problem, we test the port address supplied
    // by BIOS first.  If it fail, we try our default port.
    //

    for (i = 0; i < MAX_COM_PORTS; i++) {
        for (j = 0; j < MAX_COM_PORTS; j++) {
            if (IoPorts[i] == *(pPortAddress + j)) {
                IoPorts[i] = 0;
                break;
            }
        }
    }

    for (i = 0; i < MAX_COM_PORTS; i++) {

        PortExist = FALSE;

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // Load the port address from the BIOS data area, if it exists
        //

        Port = *(pPortAddress + i);

        //
        // Determine if the port exists
        //

        if (Port != 0) {
            if (DoesPortExist((PUCHAR)Port)) {
                PortExist = TRUE;
            }
        }
        if (!PortExist && (Port = IoPorts[i])) {
            if (PortExist = DoesPortExist((PUCHAR)Port)) {
                IoPorts[i] = 0;
                *(pPortAddress+i) = (USHORT)Port;
            }
        }
        if (PortExist) {

            //
            // Remember the port address in our global variable
            // such that other detection code (e.g. Serial Mouse) can
            // get the information.
            //

            ComPortAddress[i] = Port;

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
            if (!FirstComport) {
                FirstComport = CurrentEntry;
            }
            Component = &CurrentEntry->ComponentEntry;

            Component->Class = ControllerClass;
            Component->Type = SerialController;
            Component->Flags.ConsoleOut = 1;
            Component->Flags.ConsoleIn = 1;
            Component->Flags.Output = 1;
            Component->Flags.Input = 1;
            Component->Version = 0;
            Component->Key = i;
            Component->AffinityMask = 0xffffffff;

            //
            // Set up type string.
            //

            ComportName[3] = i + (UCHAR)'1';

            //
            // Set up Port information
            //

            ControlData.NumberPortEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_PORT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
            ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
            ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)Port;
            ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
            ControlData.DescriptorList[z].u.Port.Length = 7;
            z++;

            //
            // Set up Irq information
            //

            ControlData.NumberIrqEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareUndetermined;
            if (HwBusType == MACHINE_TYPE_MCA) {
                ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
                if (i == 0) { // COM1 - irql4; COM2 - COM3 - irq3
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                }
            } else {

                //
                // For EISA the LevelTriggered is temporarily set to FALSE.
                // COM1 and COM3 use irq 4; COM2 and COM4 use irq3
                //

                ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                if (Port == 0x3f8 || Port == 0x3e8) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else if (Port == 0x2f8 || Port == 0x2e8) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                } else if (i == 0 || i == 2) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                }
            }

            ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;

            //
            // Try to determine the interrupt vector.  If we success, the
            // new vector will be used to replace the default value.
            //

            if (HwInterruptDetection((PUCHAR)Port,
                                     SerialInterruptRequest,
                                     SerialInterruptDismiss,
                                     &Vector)) {

                ControlData.DescriptorList[z].u.Interrupt.Level =
                                     (ULONG)Vector;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                     (ULONG)Vector;
            }

            //
            // Since the com port interrupt detection destryed some
            // of the com port registers, here we do the clean up.
            //

            WRITE_PORT_UCHAR ((PUCHAR)(Port + INTERRUPT_ENABLE_REGISTER), 0);
            WRITE_PORT_UCHAR ((PUCHAR)(Port + MODEM_CONTROL_REGISTER), 0);

            CurrentEntry->ConfigurationData =
                            HwSetUpResourceDescriptor(Component,
                                                      ComportName,
                                                      &ControlData,
                                                      sizeof(SerialData),
                                                      (PUCHAR)&SerialData
                                                      );
            if (PreviousEntry) {
                PreviousEntry->Sibling = CurrentEntry;
            }
            PreviousEntry = CurrentEntry;
        }
    }
    return(FirstComport);
}

FPFWCONFIGURATION_COMPONENT_DATA
GetLptInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the parallel printer port
    information for the system.  The information includes port address,
    irq level.

    Note if this code is run after user established NETWORK LPT
    connection.  The Network LPT will be counted as regular parallel
    port.

Arguments:

    None.

Return Value:

    A pointer to a stucture of type PONENT_DATA
    which is the root of Parallel component list.
    If no comport exists, a value of NULL is returned.

--*/

{

    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstLptPort = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR LptPortName[] = "PARALLEL?";
    USHORT i, z;
    USHORT LptStatus;
    ULONG Port;

    //
    // BIOS DATA area 40:8 is the port address of the first valid COM port
    //

    USHORT far *pPortAddress = (USHORT far *)0x00400008;

    for (i = 0; i < MAX_LPT_PORTS; i++) {

        Port = (ULONG)*(pPortAddress + i);
        if (Port == 0) {
            continue;
        } else {

            //
            // If we think we have a lpt, we will initialize it to
            // a known state.   In order to make printing work under
            // nt, the arbitration level must be disabled.  The BIOS
            // init function seems to do the trick.
            //

            _asm {
                    mov     ah, 1
                    mov     dx, i
                    int     17h
            }
        }

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // Determine if the port exists
        //

        LptStatus = _bios_printer(_PRINTER_STATUS, i , 0);
        if (!(LptStatus & 6)){
            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
            if (!FirstLptPort) {
                FirstLptPort = CurrentEntry;
            }
            Component = &CurrentEntry->ComponentEntry;

            Component->Class = ControllerClass;
            Component->Type = ParallelController;
            Component->Flags.Output = 1;
            Component->Version = 0;
            Component->Key = i;
            Component->AffinityMask = 0xffffffff;

            //
            // Set up type string.
            //

            LptPortName[8] = (UCHAR)i + (UCHAR)'1';

            //
            // Set up Port information
            //

            Port = (ULONG)*(pPortAddress + i);
            ControlData.NumberPortEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_PORT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
            ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
            ControlData.DescriptorList[z].u.Port.Start.LowPart = Port;
            ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
            ControlData.DescriptorList[z].u.Port.Length = 3;
            z++;

            //
            // Set up Irq information
            //

            ControlData.NumberIrqEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareUndetermined;
            ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
            if (i ==0) {
                ControlData.DescriptorList[z].u.Interrupt.Level = 7;
                ControlData.DescriptorList[z].u.Interrupt.Vector = 7;
            } else {
                ControlData.DescriptorList[z].u.Interrupt.Level = 5;
                ControlData.DescriptorList[z].u.Interrupt.Vector = 5;
            }

            if (HwBusType == MACHINE_TYPE_MCA) {
                ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
            } else {

                //
                // For EISA the LevelTriggered is temporarily set to FALSE.
                //

                ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
            }

            CurrentEntry->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          LptPortName,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

            if (PreviousEntry) {
                PreviousEntry->Sibling = CurrentEntry;
            }
            PreviousEntry = CurrentEntry;
        }
    }
    return(FirstLptPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include cpu.inc
        .list

;
; constant for i386 32-bit multiplication test
;

MULTIPLIER            equ     00000081h
MULTIPLICAND          equ     0417a000h
RESULT_HIGH           equ     00000002h
RESULT_LOW            equ     0fe7a000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

.386p

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING


;++
;
; USHORT
; HwGetProcessorType (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines type of processor (80486, 80386, 80286,
;    and even 8086/8088).  it relies on Intel-approved code that takes
;    advantage of the documented behavior of the high nibble of the flag
;    word in the REAL MODE of the various processors.
;
;    For completeness, the code also checks for 8088/8086.  But, it won't
;    work.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = x86h or 0 if unrecongnized processor.
;
;--

.8086

        public  _HwGetProcessorType
_HwGetProcessorType      proc    near

        pushf                           ; save entry flags

;
;    The MSB (bit 15) is always a one on the 8086 and 8088 and a zero on
;    the 286, 386 and 486.
;

        pushf
        pop     ax
        and     ax, NOT 08000h          ; clear bit 15 of flags
        push    ax
        popf                            ; try to put that in the flags
        pushf
        pop     ax                      ; look at what really went into flags

        test    ax,08000h               ; Was high bit set ?
        jnz     short x_86              ; if nz, still set, goto x_86

;
;    Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are always zero on
;    the 286, but can be set on the 386 and 486.
;

        or      ax,07000h               ; Try to set the NT/IOPL bits
        push    ax
        popf                            ; Put in to the flags
        sti                             ; (for VDMM/IOPL0)
        pushf
        pop     ax                      ; look at actual flags
        test    ax,07000h               ; Any high bits set ?
        jz      short x_286             ; if z, no, goto x_286

.386p

;
;    The Alignment Check bit in flag can be set on 486 and is always zero
;    on 386.
;

        mov     eax,cr0                 ; test for 486 processor
        push    eax                     ; save CR0 value
        and     eax,not CR0_AM          ; disable alignment check
        mov     cr0,eax
        db      ADDRESS_OVERRIDE
        pushfd                          ; save original EFLAGS
        db      ADDRESS_OVERRIDE
        pushfd                          ; try to set alignment check
        or      dword ptr [esp],EFLAGS_AC ;           bit in EFLAGS
        db      ADDRESS_OVERRIDE
        popfd
        db      ADDRESS_OVERRIDE
        pushfd                          ; copy new flags into ECX
        pop     ecx                     ; [ecx] = new flags word
        db      ADDRESS_OVERRIDE
        popfd                           ; restore original EFLAGS
        pop     eax                     ; restore original CR0 value
        mov     cr0,eax
        and     ecx, EFLAGS_AC          ; did AC bit get set?
        jz      short x_386             ; if z, no, goto x_386

        mov     eax, 4h                 ; if nz, we have a 486 processor

.286p

        jmp     short hpt99

x_286:
        mov     ax, 2h                  ; Return 286 processor type.
        jmp     short hpt99

x_86:
        mov     ax, 0h                  ; Return 86h for 8088/8086 CPU type.
        jmp     short hpt99

x_386:
        mov     ax, 3h                  ; Return 386 processor type.
hpt99:
        popf                            ; restore flags
        ret

_HwGetProcessorType      endp

.386p

;++
;
; USHORT
; HwGetCpuStepping (
;    UHSORT CpuType
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for the specified CPU type.
;
;    Currently, this routine only determine stepping for 386 and 486.
;
; Arguments:
;
;    CpuType - The Cpu type which its stepping information will be returned.
;              The input value MUST be either 386 or 486.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

HgcsCpuType     equ     [esp + 2]

        public  _HwGetCpuStepping
_HwGetCpuStepping        proc

        mov     ax, HgcsCpuType         ; [ax] = CpuType
        cmp     ax, 3h                  ; Is cpu = 386?
        jz      short Hgcs00            ; if z, yes, go Hgcs00

        call    Get486Stepping          ; else, check for 486 stepping
        jmp     short Hgcs90            ; [ax] = Stepping information

Hgcs00:
        call    Get386Stepping          ; [ax] = Stepping information

Hgcs90:
        ret

_HwGetCpuStepping        endp

;++
;
; USHORT
; Get386Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i386 CPU stepping.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;    [ax] = 0 means bad CPU and stepping is not important.
;
;--

        public  Get386Stepping
Get386Stepping  proc

        call    MultiplyTest            ; Perform mutiplication test
        jnc     short G3s00             ; if nc, muttest is ok
        mov     ax, 0
        ret
G3s00:
        call    Check386B0              ; Check for B0 stepping
        jnc     short G3s05             ; if nc, it's B1/later
        mov     ax, 0B0h                ; It is B0/earlier stepping
        ret

G3s05:
        call    Check386D1              ; Check for D1 stepping
        jc      short G3s10             ; if c, it is NOT D1
        mov     ax, 0D1h                ; It is D1/later stepping
        ret

G3s10:
        mov     ax, 0B1h                ; assume it is B1 stepping
        ret

Get386Stepping  endp

;++
;
; USHORT
; Get486Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i486 CPU type.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

        public  Get486Stepping
Get486Stepping          proc

        call    Check486AStepping       ; Check for A stepping
        jnc     short G4s00             ; if nc, it is NOT A stepping

        mov     ax, 0A0h                ; set to A stepping
        ret

G4s00:  call    Check486BStepping       ; Check for B stepping
        jnc     short G4s10             ; if nc, it is NOT a B stepping

        mov     ax, 0B0h                ; set to B stepping
        ret

;
; Before we test for 486 C/D step, we need to make sure NPX is present.
; Because the test uses FP instruction to do the detection.
;

G4s10:  call    _IsNpxPresent           ; Check if cpu has coprocessor support?
        cmp     ax, 0
        jz      short G4s15             ; it is actually 486sx

        call    Check486CStepping       ; Check for C stepping
        jnc     short G4s20             ; if nc, it is NOT a C stepping
G4s15:
        mov     ax, 0C0h                ; set to C stepping
        ret

G4s20:  mov     ax, 0D0h                ; Set to D stepping
        ret

Get486Stepping          endp

;++
;
; BOOLEAN
; Check486AStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 A Stepping.
;
;    It takes advantage of the fact that on the A-step of the i486
;    processor, the ET bit in CR0 could be set or cleared by software,
;    but was not used by the hardware.  On B or C -step, ET bit in CR0
;    is now hardwired to a "1" to force usage of the 386 math coprocessor
;    protocol.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B or later stepping.
;    Carry Flag set if A or earlier stepping.
;
;--
        public  Check486AStepping
Check486AStepping       proc    near
.386p
        mov     eax, cr0                ; reset ET bit in cr0
        and     eax, NOT CR0_ET
        mov     cr0, eax

        mov     eax, cr0                ; get cr0 back
        test    eax, CR0_ET             ; if ET bit still set?
        jnz     short cas10             ; if nz, yes, still set, it's NOT A step
        stc
        ret

cas10:  clc
        ret

        ret
Check486AStepping       endp

;++
;
; BOOLEAN
; Check486BStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 B Stepping.
;
;    On the i486 processor, the "mov to/from DR4/5" instructions were
;    aliased to "mov to/from DR6/7" instructions.  However, the i486
;    B or earlier steps generate an Invalid opcode exception when DR4/5
;    are used with "mov to/from special register" instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if C or later stepping.
;    Carry Flag set if B stepping.
;
;--
        public  Check486BStepping
Check486BStepping       proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset Temporary486Int6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

c4bs50: db      0fh, 21h, 0e0h            ; mov eax, DR4
        nop
        nop
        nop
        nop
        nop
        clc                             ; it is C step
        jmp     short c4bs70
c4bs60: stc                             ; it's B step
c4bs70: pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

        ret

Check486BStepping       endp

;++
;
; BOOLEAN
; Temporary486Int6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an mov to/from DR4/5 instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

Temporary486Int6        proc

        mov     word ptr [esp].IretIp,offset c4bs60 ; set IP to stc instruction
        iret

Temporary486Int6        endp

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        fwait
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp

;++
;
; BOOLEAN
; Check386B0 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 B0 or earlier stepping.
;
;    It takes advantage of the fact that the bit INSERT and
;    EXTRACT instructions that existed in B0 and earlier versions of the
;    386 were removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--


    ASSUME ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386B0      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     ax,ax
        mov     dx,ax
        mov     cx,0ff00h               ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jcxz    short b1c70             ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     word ptr [esp].IretIp,offset b1c60 ; set IP to clc instruction
        iret

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occuu each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386D1      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,1*4
        push    dword ptr [bx]          ; save old int 1 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt1
        mov     word ptr [bx].VectorSegment,cs ; set vector to new int 1 handler

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     sp,4                    ; make room for target of movsb
        xor     si,si                   ; (ds:si) = 0:0
        push    ss                      ; (es:di) = ss:sp-4
        pop     es
        mov     di,sp
        mov     cx,2                    ; 2 iterations
        pushf
        or      word ptr [esp], EFLAGS_TF
        popf                            ; cause a single step trap
        rep movsb

d1c60:  add     sp,4                    ; clean off stack
        pop     dword ptr [bx]          ; restore old int 1 vector
        stc                             ; assume B1
        jcxz    short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     bx
        pop     ds
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     word ptr [esp].IretFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     word ptr [esp].IretIp,offset d1c60     ; set IP to next instruction
        iret

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.  If yes, the ET bit in CR0 will be set; otherwise
;     it will be reset.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

        public  _IsNpxPresent
_IsNpxPresent   proc    near

        push    bp                      ; Save caller's bp
.386p
        mov     eax, cr0
        and     eax, NOT CR0_ET         ; Assume no NPX
        mov     edx, 0
.287
        fninit                          ; Initialize NPX
        mov     cx, 5A5Ah               ; Put non-zero value
        push    cx                      ;   into the memory we are going to use
        mov     bp, sp
        fnstsw  word ptr [bp]           ; Retrieve status - must use non-wait
        cmp     byte ptr [bp], 0        ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1
Inp10:
        mov     cr0, eax
        pop     ax                      ; clear scratch value
        pop     bp                      ; Restore caller's bp
        mov     eax, edx
        ret

_IsNpxPresent   endp

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\diska.asm ===
title  "Int13 Drive parameter information detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    diska.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to detect/collect
;    harddisk paramter information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 22-Feb-1992
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p

;
; Standard int 13 drive parameters.
;   The parameters returned from int 13 function 8
;

Int13DriveParameters    struc

        DriveSelect     dw      0
        MaxCylinders    dd      0
        SectorsPerTrack dw      0
        MaxHeads        dw      0
        NumberDrives    dw      0

Int13DriveParameters    ends

SIZE_OF_PARAMETERS      equ     12

;
; Extended int 13 drive parameters
;   The Drive Parameters returned from int 13 function 48h
;

ExInt13DriveParameters  struc

        ExBufferSize      dw      0
        ExFlags           dw      0
        ExCylinders       dd      0
        ExHeads           dd      0
        ExSectorsPerTrack dd      0
        ExSectorsPerDrive dd      0
                          dd      0
        ExSectorSize      dw      0
        ExReserved        dw      0

ExInt13DriveParameters    ends

SIZE_OF_EXTENDED_PARAMETERS       equ     28

;
; Structure used by nt kernel Configuration Manager
;

CmDiskGeometryDeviceData struc

        CmBytesPerSector    dd      0
        CmNumberOfCylinders dd      0
        CmSectorsPerTrack   dd      0
        CmNumberOfHeads     dd      0

CmDiskGeometryDeviceData ends

SIZE_OF_CM_DISK_DATA     EQU      16

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _NumberBiosDisks
_NumberBiosDisks dw      0

RomChain        db      8 * SIZE_OF_PARAMETERS dup(?)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING

;++
;
; VOID
; GetInt13DriveParamters (
;    OUT PUCHAR Buffer,
;    OUT PUSHORT Size
;    )
;
; Routine Description:
;
;    This function calls real mode int 13h function 8 to get drive
;    parameters for drive 80h - 87h.
;
; Arguments:
;
;    Buffer - Supplies a pointer to a buffer to receive the drive paramter
;       information.
;
;    Size - Supplies a pointer to a USHORT to receive the size of the drive
;       parameter information returned.
;
; Return Value:
;
;    None.
;
;--

        Public _GetInt13DriveParameters
_GetInt13DriveParameters        proc

        push    bp
        mov     bp, sp
        push    si
        push    bx

        mov     dx, 80h         ; Starting from drive 80h
        mov     cx, 0           ; count
        mov     si, offset RomChain ; [si]->Buffer
gidp00:
        push    cx              ; save count
        push    dx              ; save drive select

;
; First check if drive is present.  It turns out function returns drive
; parameters even when the drive is not present.
;

        mov     ah, 15h
        int     13h             ; Get type of drive
        jc      short gidp99

        cmp     ah, 0           ; if ah=0 drive is not present
        jz      gidp99

        pop     dx
        pop     cx
        push    cx
        push    dx

        mov     ah, 8           ; int 13 function 8
        int     13h             ; call int 13
        jc      short gidp99    ; if c, fail, go exit

        inc     _NumberBiosDisks
        mov     al, cl
        and     al, 3fh         ; Only want bit 0 - 5
        mov     ah, 0
        mov     [si].SectorsPerTrack, ax
        shr     cl, 6
        xchg    cl, ch
        mov     word ptr [si].MaxCylinders, cx
        mov     word ptr [si + 2].MaxCylinders, 0
        mov     byte ptr [si].MaxHeads, dh
        mov     byte ptr [si + 1].MaxHeads, 0
        mov     byte ptr [si].NumberDrives, dl
        mov     byte ptr [si + 1].NumberDrives, 0
        pop     dx              ; get back current drive number
        mov     [si].DriveSelect, dx
        inc     dx
        pop     cx              ; get back count
        inc     cx              ; increase table count
        cmp     dx, 88h         ; Are we done? (dx == 88h)
        je      short gidp100

        add     si, SIZE_OF_PARAMETERS
        jmp     gidp00

gidp99: pop     dx
        pop     cx
gidp100:
        mov     ax, offset RomChain
        mov     si, [bp + 4]    ; [si]-> variable to receive buffer addr
        mov     [si], ax        ; return buffer address
        mov     si, [bp + 6]    ; [si]-> variable to receive buffer size
        mov     ax, cx
        mov     cl, SIZE_OF_PARAMETERS
        mul     cl
        mov     [si], ax        ; return buffer size

        pop     bx
        pop     si
        pop     bp
        ret

_GetInt13DriveParameters        endp

;++
;
; BOOLEAN
; IsExtendedInt13Available
;    USHORT DriveNumber
;    )
;
; Routine Description:
;
;    This function checks if extended int13 functions available.
;
; Arguments:
;
;    DriveNumber - the drive number to check for.
;
; Return Value:
;
;    TRUE if extended int 13 service is available.  Otherwise a value of
;    FALSE is returned.
;
;--

        Public _IsExtendedInt13Available
_IsExtendedInt13Available       proc

        push    bp
        mov     bp, sp
        push    bx

        mov     dl, [bp+4]     ; get DriveNumber parameter
        mov     ah, 41h
        mov     bx, 55aah
        int     13h
        jc      short Ieda90

        cmp     bx, 0AA55h
        jne     short Ieda90

        test    cx, 1           ; bit 0 = Extended disk access is supported
        jz      short Ieda90

        mov     ax, 1
        jmp     short IedaExit
Ieda90:
        xor     eax, eax
IedaExit:
        pop     bx
        pop     bp
        ret

_IsExtendedInt13Available       endp

;++
;
; USHORT
; GetExtendedDriveParameters
;    USHORT DriveNumber,
;    FPCM_DISK_GEOMETRY_DEVICE_DATA DeviceData
;    )
;
; Routine Description:
;
;    This function use extended int13 service function 48h to get
;    drive parameters.
;
; Arguments:
;
;    DriveNumber - the drive number to get the drive parameters.
;
;    DeviceData - supplies a far pointer to a buffer to receive the parameters.
;
;
; Return Value:
;
;    Size of DeviceData.  If the extended int 13 service is not available,
;    a zero value will be returned.
;
;--

        Public _GetExtendedDriveParameters
_GetExtendedDriveParameters     proc

        push    bp
        mov     bp, sp
        push    si
        push    bx
        sub     sp, SIZE_OF_EXTENDED_PARAMETERS

        mov     dl, [bp+4]      ; get DriveNumber parameter
        mov     si, sp          ; [si]-> Local buffer
        mov     word ptr [si].ExBufferSize, SIZE_OF_EXTENDED_PARAMETERS
        mov     ah, 48h
        int     13h
        jc      short Gedp90

        or      ah, ah          ; Make sure there is no error
        jnz     short Gedp90    ; if error, exit

        cmp     [si].ExBufferSize, ExReserved
        jl      short Gedp90    ; the retruned data is too small to be useful

        mov     bx, [bp+6]
        mov     ax, [bp+8]
        mov     es, ax          ; (es:bx)->Caller's buffer
        ASSUME  es:NOTHING

        mov     eax, [si].ExCylinders
        mov     es:[bx].CmNumberOfCylinders, eax
        mov     eax, [si].ExHeads
        mov     es:[bx].CmNumberOfHeads, eax
        mov     eax, [si].ExSectorsPerTrack
        mov     es:[bx].CmSectorsPerTrack, eax
        xor     eax, eax
        mov     ax, [si].ExSectorSize
        mov     es:[bx].CmBytesPerSector, eax
        mov     ax, SIZE_OF_CM_DISK_DATA
        jmp     short GedpExit
Gedp90:
        xor     eax, eax
GedpExit:
        add     sp, SIZE_OF_EXTENDED_PARAMETERS
        pop     bx
        pop     si
        pop     bp
        ret

_GetExtendedDriveParameters     endp
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\cpu.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;   Author:
;
;       Shie-Lin (shielint) 1-Oct-1991
;
;   Revision History:
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h


;
; define the structure type for real mode interrupt vectore
;

RealModeVector  struc

VectorOffset    dw      0
VectorSegment   dw      0

RealModeVector  ends

;
; Define the iret frame
;

IretFrame       struc

IretIp         dw      0
IretCs         dw      0
IretFlags      dw      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\disk.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    flo_data.h

Abstract:

    This file includes data and hardware declarations for the BIOS
    disk and floppy.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Notes:

--*/



//
// CMOS related definitions and macros
//

#define CMOS_CONTROL_PORT 0x70          // cmos command port
#define CMOS_DATA_PORT 0x71             // cmos data port
#define CMOS_FLOPPY_CONFIG_BYTE 0x10

//
// The length of CBIOS floppy parameter table
//

#define FLOPPY_PARAMETER_TABLE_LENGTH 28

//
// The CM_FLOPPY_DEVICE_DATA we use here is the newly updated one.
// To distinguish this, we set the version number in the CM_FLOPPY_DEVICE_DATA
// to 2. (Otherwise, it should be < 2)
//

#define CURRENT_FLOPPY_DATA_VERSION 2

extern USHORT NumberBiosDisks;

//
// External References
//

extern
BOOLEAN
IsExtendedInt13Available (
    IN USHORT DriveNumber
    );

extern
USHORT
GetExtendedDriveParameters (
    IN USHORT DriveNumber,
    IN CM_DISK_GEOMETRY_DEVICE_DATA far *DeviceData
    );

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

VOID
GetDiskId(
    USHORT Drive,
    PUCHAR Identifier
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\diskc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    diskc.c

Abstract:

    This is the NEC PD756 (aka AT, aka ISA, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette detection code for NT.  This file also
    collect BIOS disk drive parameters.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Revision History:


Notes:

--*/

//
// Include files.
//

#include "hwdetect.h"
#include "disk.h"
#include <string.h>


FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
                    VOID
                    )

/*++

Routine Description:

    This routine tries to get floppy configuration information.

Arguments:

    None.

Return Value:

    A pointer to a FPCONFIGURATION_COMPONENT_DATA is returned.  It is
    the head of floppy component tree root.

--*/

{
    UCHAR DriveType;
    FPUCHAR ParameterTable;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstController = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR FloppyNumber = 0;
    UCHAR FloppySkipped = 0;
    UCHAR DiskName[30];
    UCHAR FloppyParmTable[FLOPPY_PARAMETER_TABLE_LENGTH];
    FPUCHAR fpString;
    USHORT Length, z;
    ULONG MaxDensity = 0;
    CM_FLOPPY_DEVICE_DATA far *FloppyData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    USHORT FloppyDataVersion;

    for (z = 0; z < FLOPPY_PARAMETER_TABLE_LENGTH; z++ ) {
        FloppyParmTable[z] = 0;
    }

    //
    // Initialize Controller data
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;

    //
    // Allocate space for Controller component and initialize it.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                    sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    FirstController = CurrentEntry;
    Component = &CurrentEntry->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = DiskController;
    Component->Flags.Removable = 1;
    Component->Flags.Input = 1;
    Component->Flags.Output = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)0x3f0;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = (ULONG)0;
    ControlData.DescriptorList[z].u.Port.Length = 8;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareUndetermined;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {
        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }
    ControlData.DescriptorList[z].u.Interrupt.Level = 6;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 6;
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    z++;

    //
    // Set up DMA information. Only set channel number.  Timming and
    // transferSize are defaulted - 8 bits and ISA compatible.
    //

    ControlData.NumberDmaEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_DMA;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareUndetermined;
    ControlData.DescriptorList[z].Flags = 0;
    ControlData.DescriptorList[z].u.Dma.Channel = (ULONG)2;
    ControlData.DescriptorList[z].u.Dma.Port = 0;
    z++;

    CurrentEntry->ConfigurationData =
    HwSetUpResourceDescriptor(Component,
                              NULL,
                              &ControlData,
                              0,
                              NULL
                             );

    //
    // Collect disk peripheral data
    //
    while (1) {
        _asm {
            push   es

            mov    DriveType, 0
            mov    FloppyDataVersion, CURRENT_FLOPPY_DATA_VERSION

            mov    ah, 15h
            mov    dl, FloppyNumber
            int    13h
            jc     short CmosTest

            cmp    ah, 0
            je     short Exit

            cmp    ah, 2                   ; make sure this is floppy
            ja     short Exit

            mov    ah, 8
            mov    dl, FloppyNumber
            lea    di, word ptr FloppyParmTable ; use 'word ptr' to quiet compiler
            push   ds
            pop    es                      ; (es:di)->dummy FloppyParmTable
            int    13h
            jc     short CmosTest

            mov    DriveType, bl
            mov    ax, es
            mov    word ptr ParameterTable + 2, ax
            mov    word ptr ParameterTable, di
            jmp    short Exit

            CmosTest:

            ;
            ; ifint 13 fails, we know that floppy drive is present.
                ;So, we tryto get the Drive Type from CMOS.
            ;

            mov     al, CMOS_FLOPPY_CONFIG_BYTE
            mov     dx, CMOS_CONTROL_PORT   ; address port
            out     dx, al
            jmp     short delay1            ; I/O DELAY
            delay1:
            mov     dx, CMOS_DATA_PORT      ; READ IN REQUESTED CMOS DATA
            in      al, dx
            jmp     short delay2            ; I/O DELAY
            delay2:
            cmp     FloppyNumber, 0
            jne     short CmosTest1

            and     al, 0xf0
            shr     al, 4
            jmp     short Test2Cmos

            CmosTest1:
            cmp     FloppyNumber, 1
            jne     short Exit

            and     al, 0xf
            Test2Cmos:
            mov     DriveType, al
            mov     FloppyDataVersion, 0

            Exit:
            pop     es
        }

        if (DriveType) {

            //
            // Allocate space for first pripheral component and initialize it.
            //

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                            sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

            Component = &CurrentEntry->ComponentEntry;

            Component->Class = PeripheralClass;
            Component->Type = FloppyDiskPeripheral;
            Component->Version = 0;
            Component->Key = FloppyNumber - FloppySkipped;
            Component->AffinityMask = 0xffffffff;
            Component->ConfigurationDataLength = 0;

            //
            // Set up type string.
            //

            strcpy(DiskName, "FLOPPYx");
            DiskName[6] = FloppyNumber - FloppySkipped + (UCHAR)'1';
            Length = strlen(DiskName) + 1;
            fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
            _fstrcpy(fpString, DiskName);
            Component->IdentifierLength = Length;
            Component->Identifier = fpString;

            //
            // Set up floppy device specific data
            //

            switch (DriveType) {
                case 1:
                    MaxDensity = 360;
                    break;
                case 2:
                    MaxDensity = 1200;
                    break;
                case 3:
                    MaxDensity = 720;
                    break;
                case 4:
                    MaxDensity = 1440;
                    break;
                case 5:
                case 6:
                    MaxDensity = 2880;
                    break;
                case 0x10:
                    //
                    // Mark a removable atapi as a super floppy.
                    // Enable it to work around the problem of not having
                    // a floppy but only a LS-120
                    //
                    //N.B we can ONLY get away with using the high bit on the
                    // superfloppy. SFLOPPY doesn't use this field
                    // fdc does, but isn't loaded on these devices!
                    //
                    MaxDensity=(2880 | 0x80000000);
                    break;

                default:
                    MaxDensity = 0;
                    break;
            }
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                Length = sizeof(CM_FLOPPY_DEVICE_DATA);
            } else {
                Length = (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime);
            }
            DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                                                         Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST),
                                                                         TRUE);
            CurrentEntry->ConfigurationData = DescriptorList;
            Component->ConfigurationDataLength =
            Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
            DescriptorList->Count = 1;
            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
            Length;
            FloppyData = (CM_FLOPPY_DEVICE_DATA far *)(DescriptorList + 1);
            FloppyData->MaxDensity = MaxDensity;
            FloppyData->Version = FloppyDataVersion;
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                _fmemcpy((FPCHAR)&FloppyData->StepRateHeadUnloadTime,
                         ParameterTable,
                         sizeof(CM_FLOPPY_DEVICE_DATA) -
                         (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime)
                        );
            }
            if ((FloppyNumber - FloppySkipped) == 0) {
                FirstController->Child = CurrentEntry;
            } else {
                PreviousEntry->Sibling = CurrentEntry;
            }
            CurrentEntry->Parent = FirstController;
            PreviousEntry = CurrentEntry;
            FloppyNumber++;
        } else {

            //
            // This is a *hack* for ntldr.  Here we create a arc name for
            // each bios disks such that ntldr can open them.
            //

            if (NumberBiosDisks != 0) {

                for (z = 0; z < NumberBiosDisks; z++) {

                    //
                    // Allocate space for disk peripheral component
                    //

                    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                                    sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

                    Component = &CurrentEntry->ComponentEntry;

                    Component->Class = PeripheralClass;
                    Component->Type = DiskPeripheral;
                    Component->Flags.Input = 1;
                    Component->Flags.Output = 1;
                    Component->Version = 0;
                    Component->Key = z;
                    Component->AffinityMask = 0xffffffff;

                    //
                    // Set up identifier string = 8 digit signature - 8 digit checksum
                    // for example: 00fe964d-005467dd
                    //

                    GetDiskId(0x80 + z, DiskName);
                    
                    if (DiskName[0] == (UCHAR)NULL) {
                        strcpy(DiskName, "BIOSDISKx");
                        DiskName[8] = (UCHAR)z + (UCHAR)'1';
                    }

                    Length = strlen(DiskName) + 1;
                    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
                    _fstrcpy(fpString, DiskName);
                    Component->IdentifierLength = Length;
                    Component->Identifier = fpString;

                    //
                    // Set up BIOS disk device specific data.
                    // (If extended int 13 drive parameters are supported by
                    //  BIOS, we will collect them and store them here.)
                    //

                    if (IsExtendedInt13Available(0x80+z)) {
                        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                                                                     sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                                                                     sizeof(CM_DISK_GEOMETRY_DEVICE_DATA),
                                                                                     TRUE);
                        Length = GetExtendedDriveParameters(
                                                           0x80 + z,
                                                           (CM_DISK_GEOMETRY_DEVICE_DATA far *)(DescriptorList + 1)
                                                           );
                        if (Length) {
                            CurrentEntry->ConfigurationData = DescriptorList;
                            Component->ConfigurationDataLength =
                            Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
                            DescriptorList->Count = 1;
                            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
                            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                            Length;
                        } else {
                            HwFreeHeap(sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                       sizeof(CM_DISK_GEOMETRY_DEVICE_DATA));
                        }
                    }

                    if (PreviousEntry == NULL) {
                        FirstController->Child = CurrentEntry;
                    } else {
                        PreviousEntry->Sibling = CurrentEntry;
                    }
                    CurrentEntry->Parent = FirstController;
                    PreviousEntry = CurrentEntry;
                }
            }
            return (FirstController);
        }
    }
}


#pragma warning(4:4146)     // unary minus operator applied to unsigned type (checksum on line 733)
VOID
GetDiskId(
         USHORT Disk,
         PUCHAR Identifier
         )

/*++

Routine Description:

    This routine reads the master boot sector of the specified harddisk drive,
    compute the checksum of the sector to form a drive identifier.

    The identifier will be set to "8-digit-checksum"+"-"+"8-digit-signature"
    For example:  00ff6396-6549071f

Arguments:

    Disk - supplies the BIOS drive number, i.e. 80h - 87h

    Identifier - Supplies a buffer to receive the disk id.

Return Value:

    None.  In the worst case, the Identifier will be empty.

--*/

{
    UCHAR Sector[512];
    ULONG Signature, Checksum;
    USHORT i, Length;
    PUCHAR BufferAddress;
    BOOLEAN Fail;

    Identifier[0] = 0;
    BufferAddress = &Sector[0];
    Fail = FALSE;

    //
    // Read in the first sector
    //

    _asm {
        push    es
        mov     ax, 0x201
        mov     cx, 1
        mov     dx, Disk
        push    ss
        pop     es
        mov     bx, BufferAddress
        int     0x13
        pop     es
        jnc     Gdixxx

        mov     Fail, 1
        Gdixxx:
    }

    if (Fail) {
#if DBG
        // could not get the sector, so return NULL DiskID
        BlPrint("Failed to read sector -- returning NULL DiskId\n");
#endif
        return;
    }

    Signature = ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];

    //
    // compute the checksum
    //

    Checksum = 0;
    for (i = 0; i < 128; i++) {
        Checksum += ((PULONG)Sector)[i];
    }
    Checksum = -Checksum;

    //
    // Zero the identifier
    //

    for (i=0; i < 30; i++) {
        Identifier[i]='0';
    }

    //
    // Put the dashes in the right places.
    //

    Identifier[8] = '-';
    Identifier[17] = '-';

    //
    // If the boot sector has a valid partition table signature,
    // attach an 'A.'  Otherwise we use 'X.'
    //

    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        Identifier[18]='X';
    } else {
        Identifier[18]='A';
    }

    //
    // Reuse sector buffer to build checksum string.
    //

    ultoa(Checksum, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[7-i] = Sector[Length-i-1];
    }

    //
    // Reuse sector buffer to build signature string.
    //

    ultoa(Signature, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[16-i] = Sector[Length-i-1];
    }

    //
    // Terminate string.
    //

    Identifier[19] = 0;

#if DBG
    BlPrint("%s\n", Identifier);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _BTEISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT PhysicalAddress_LSW;
    UCHAR PhysicalAddress_MSB;
    USHORT MemorySize;
} BTEISA_MEMORY_CONFIGURATION, *PBTEISA_MEMORY_CONFIGURATION;

//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _BTEISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} BTEISA_IRQ_CONFIGURATION, *PBTEISA_IRQ_CONFIGURATION;

//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIG_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIG_BYTE0;

typedef struct _DMA_CONFIG_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIG_BYTE1;

typedef struct _BTEISA_DMA_CONFIGURATION {
    DMA_CONFIG_BYTE0 ConfigurationByte0;
    DMA_CONFIG_BYTE1 ConfigurationByte1;
} BTEISA_DMA_CONFIGURATION, *PBTEISA_DMA_CONFIGURATION;

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *TEISA_PORT_DESCRIPTOR;

typedef struct _BTEISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} BTEISA_PORT_CONFIGURATION, *PBTEISA_PORT_CONFIGURATION;

typedef struct _BTEISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} BTEISA_SLOT_INFORMATION, *PBTEISA_SLOT_INFORMATION,
  far *FPBTEISA_SLOT_INFORMATION;

typedef struct _BTEISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    BTEISA_MEMORY_CONFIGURATION EisaMemory[9];
    BTEISA_IRQ_CONFIGURATION EisaIrq[7];
    BTEISA_DMA_CONFIGURATION EisaDma[4];
    BTEISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} BTEISA_FUNCTION_INFORMATION, *PBTEISA_FUNCTION_INFORMATION,
  far *FPBTEISA_FUNCTION_INFORMATION;

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwapm.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwapm.c

Abstract:

Author:


Environment:

    Real mode.

Revision History:

--*/


#include "hwdetect.h"
#include <string.h>


#include "apm.h"
#include <ntapmsdk.h>

ULONG
HwWriteLog(
    PUCHAR  p,
    UCHAR   loc,
    ULONG  data
    );

UCHAR   DetName[] = "DETLOG1";

VOID Int15 (PULONG, PULONG, PULONG, PULONG, PULONG);

BOOLEAN
HwGetApmSystemData(
    PVOID   Buf
    )
{
    PAPM_REGISTRY_INFO  ApmEntry;
    ULONG       RegEax, RegEbx, RegEcx, RegEdx, CyFlag;
    UCHAR       ApmMajor, ApmMinor;
    PUCHAR      lp, p;

    ApmEntry = Buf;

    ApmEntry->Signature[0] = 'A';
    ApmEntry->Signature[1] = 'P';
    ApmEntry->Signature[2] = 'M';

    ApmEntry->Valid = 0;

    lp = &(ApmEntry->DetectLog[0]);
    p = DetName;

    while (*p != '\0') {
        *lp = *p;
        p++;
        lp++;
    }

    //
    // Perform APM installation check
    //
    RegEax = APM_INSTALLATION_CHECK;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag ||
        (RegEbx & 0xff) != 'M'  ||
        ((RegEbx >> 8) & 0xff) != 'P') {

        //
        // this is a case where int15 says apm just isn't there,
        // so tell the caller to not even create the node
        //
        return FALSE;
    }

    //
    // If we get here, we have an APM bios.  If we just call it,
    // we may get grief.  So we will connect in real mode, then
    // set our version to whatever the driver says it is, or 1.2,
    // whichever is LESS.  Then query options again.
    //

    ApmMajor = (UCHAR) (RegEax >> 8) & 0xff;
    ApmMinor = (UCHAR) RegEax & 0xff;

    if (ApmMajor > 1) ApmMajor = 1;
    if (ApmMinor > 2) ApmMinor = 2;

    //
    // Connect to Real mode interface
    //
    RegEax = APM_REAL_MODE_CONNECT;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'A', RegEax);
        return TRUE;
    }

    //
    // Call APM Driver Version in real mode, and set the driver
    // version to be MIN(v1.2, apm version of the machine)
    //
    RegEax = APM_DRIVER_VERSION;
    RegEbx = APM_DEVICE_BIOS;
    RegEcx = ((ApmMajor << 8) | ApmMinor) & 0xffff;

    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'B', RegEax);
        return TRUE;
    }


    //
    // Perform APM installation check again
    //
    RegEax = APM_INSTALLATION_CHECK;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'C', RegEax);
        return TRUE;
    }

    ApmEntry->ApmRevMajor = (UCHAR) (RegEax >> 8) & 0xff;
    ApmEntry->ApmRevMinor = (UCHAR) RegEax & 0xff;
    ApmEntry->ApmInstallFlags = (USHORT) RegEcx;

    //
    // Disconnect from real mode interface
    //
    RegEax = APM_DISCONNECT;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'D', RegEax);
        return TRUE;
    }

    //
    // If we get this far, there's an APM bios in the machine,
    // and we've told it that we're the latest version we think
    // it and we like, so now, in theory, things should just work....
    //


    if (ApmEntry->ApmInstallFlags & APM_MODE_16BIT) {

        //
        // Connect to 16 bit interface
        //
        RegEax = APM_PROTECT_MODE_16bit_CONNECT;
        RegEbx = APM_DEVICE_BIOS;
        Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

        if (CyFlag) {
            lp += HwWriteLog(lp, 'E', RegEax);
            return TRUE;
        }

        ApmEntry->Code16BitSegment       = (USHORT) RegEax;
        ApmEntry->Code16BitOffset        = (USHORT) RegEbx;
        ApmEntry->Data16BitSegment       = (USHORT) RegEcx;

        //
        // On most bioses, the following call just works.
        // On some, it doesn't, and their authors point at the spec.
        // And finally, most bioses don't seem to need this call
        // in the first place.
        // We cannot do it in ntapm.sys because it's on the loader's
        // hibernate resume path as well as here.
        //
        // SO> make the call, report any error, but IGNORE it.
        //

        RegEax = APM_DRIVER_VERSION;
        RegEbx = APM_DEVICE_BIOS;
        RegEcx = ((ApmMajor << 8) | ApmMinor) & 0xffff;

        Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

        if (CyFlag) {
            lp += HwWriteLog(lp, 'F', RegEax);
            ApmEntry->Valid = 1;  // pretend it worked....
            return TRUE;
        }

        ApmEntry->Valid = 1;
        return TRUE;
    }

    HwWriteLog(lp, 'H', ApmEntry->ApmInstallFlags);
    return TRUE;
}

ULONG
HwWriteLog(
    PUCHAR  p,
    UCHAR   loc,
    ULONG   data
    )
{
    p[0] = loc;
    p[1] = (UCHAR)(data & 0xff);
    p[2] = (UCHAR)((data & 0xff00) >> 8);
    return 4;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "hwdetect.h"

#if DBG

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))


#define ROWS 25
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

//
// Internal routines
//

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
BlPuts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;



//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    BlPuts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID BlPuts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)SCREEN_START;
    a = REVERSE_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

#else

VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
}

VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwdetect.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwdetect.c

Abstract:

    This is the main hardware detection module.  Its main function is
    to detect various system hardware and build a configuration tree.

    N.B. The configuration built in the detection module will needs to
    be adjusted later before we switch to FLAT mode.  The is because
    all the "POINTER" is a far pointer instead of a flat pointer.

Author:

    Shie-Lin Tzong (shielint) 16-Jan-92


Environment:

    Real mode.

Revision History:

    Kenneth Ray     (kenray)   Jan-1998
      - Add: get docking station info from PnP BIOS and add to firmware tree

--*/

#include "hwdetect.h"
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
typedef PVOID PDEVICE_OBJECT;
#include "pci.h"
#include <string.h>
#include "apm.h"
#include <ntapmsdk.h>
#include "pcibios.h"
#include "pcienum.h"

#if DBG

PUCHAR TypeName[] = {
    "ArcSystem",
    "CentralProcessor",
    "FloatingPointProcessor",
    "PrimaryICache",
    "PrimaryDCache",
    "SecondaryICache",
    "SecondaryDCache",
    "SecondaryCache",
    "EisaAdapter",
    "TcaAdapter",
    "ScsiAdapter",
    "DtiAdapter",
    "MultifunctionAdapter",
    "DiskController",
    "TapeController",
    "CdRomController",
    "WormController",
    "SerialController",
    "NetworkController",
    "DisplayController",
    "ParallelController",
    "PointerController",
    "KeyboardController",
    "AudioController",
    "OtherController",
    "DiskPeripheral",
    "FloppyDiskPeripheral",
    "TapePeripheral",
    "ModemPeripheral",
    "MonitorPeripheral",
    "PrinterPeripheral",
    "PointerPeripheral",
    "KeyboardPeripheral",
    "TerminalPeripheral",
    "OtherPeripheral",
    "LinePeripheral",
    "NetworkPeripheral",
    "SystemMemory",
    "DockingInformation",
    "RealModeIrqRoutingTable",
    "RealModePCIEnumeration",
    "MaximumType"
    };

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     );

extern
USHORT
HwGetKey(
    VOID
    );
#endif

VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     );

//
// HwBusType - defines the BUS type of the machine.
//     This variable is used by detection code only.
//

USHORT HwBusType = 0;

//
// AdapterEntry is the Configuration_Component_data for the bus adapter
//

FPFWCONFIGURATION_COMPONENT_DATA  AdapterEntry = NULL;

//
// FpRomBlock - A far pointer to our Rom Block
//

FPUCHAR FpRomBlock = NULL;
USHORT RomBlockLength = 0;

//
// HwEisaConfigurationData - A far pointer to the EISA configuration
//   data on EISA machine.
//

FPUCHAR HwEisaConfigurationData = NULL;
ULONG HwEisaConfigurationSize = 0L;

//
// DisableSerialMice - A bit flags to indicate the comports whose serial
//     mouse detection should be skipped.
//

USHORT DisableSerialMice = 0x0;

//
// FastDetect - A boolean value indicating if we should skip detection of
//      unsupported devices or devices that are detected by NT proper
//
UCHAR FastDetect = 0x0;

//
// DisablePccardIrqScan - A boolean value indicating if we should skip
//      detection of usable IRQs connected to pccard controllers
//
UCHAR DisablePccardIrqScan = 0;

//
// NoIRQRouting - Skip calling PCI BIOS to get IRQ routing options.
//

UCHAR NoIRQRouting = 0;

//
// PCIEnum - Enumerating the devices on the PCI Buses. Off by default.
//

UCHAR PCIEnum = 0;

//
// NoLegacy - Skip keyboard and all of the above.
//

UCHAR NoLegacy = 0;

//
// Internal references and definitions.
//

typedef enum _RELATIONSHIP_FLAGS {
    Child,
    Sibling,
    Parent
} RELATIONSHIP_FLAGS;


VOID
HardwareDetection(
     ULONG HeapStart,
     ULONG HeapSize,
     ULONG ConfigurationTree,
     ULONG HeapUsed,
     ULONG OptionString,
     ULONG OptionStringLength
     )
/*++

Routine Description:

    Main entrypoint of the HW recognizer test.  The routine builds
    a configuration tree and leaves it in the hardware heap.

Arguments:

    HeapStart - Supplies the starting address of the configuaration heap.

    HeapSize - Supplies the size of the heap in byte.

    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
        receive the hardware configuration tree.

    HeapUsed - Supplies a 32 bit FLAT address of the variable to receive
        the actual heap size in used.

    OptionString - Supplies a 32 bit FLAT address of load option string.

    OptionStringLength - Supplies the length of the OptionString

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    FPFWCONFIGURATION_COMPONENT_DATA FirstCom = NULL, FirstLpt = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    FPFWCONFIGURATION_COMPONENT_DATA AcpiAdapterEntry = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    RELATIONSHIP_FLAGS NextRelationship;
    CHAR Identifier[256];
    USHORT BiosYear, BiosMonth, BiosDay;
    PUCHAR MachineId;
    USHORT Length, InitialLength, i, Count = 0;
    USHORT PnPBiosLength, SMBIOSLength;
    FPCHAR IdentifierString;
    PMOUSE_INFORMATION MouseInfo = 0;
    USHORT KeyboardId = 0;
    ULONG VideoAdapterType = 0;
    FPULONG BlConfigurationTree = NULL;
    FPULONG BlHeapUsed = NULL;
    FPCHAR BlOptions, EndOptions;
    PUCHAR RomChain;
    FPUCHAR FpRomChain = NULL, ConfigurationData, EndConfigurationData;
    SHORT FreeSize;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    PCI_REGISTRY_INFO PciEntry;
    APM_REGISTRY_INFO ApmEntry;
    USHORT nDevIt;
    USHORT PCIDeviceCount = 0;


    DOCKING_STATION_INFO DockInfo = { 0, 0, 0, FW_DOCKINFO_BIOS_NOT_CALLED };
    FPPCI_IRQ_ROUTING_TABLE IrqRoutingTable;

    //
    // First initialize our hardware heap.
    //

    HwInitializeHeap(HeapStart, HeapSize);

    MAKE_FP(BlConfigurationTree, ConfigurationTree);
    MAKE_FP(BlHeapUsed, HeapUsed);
    MAKE_FP(BlOptions, OptionString);

    //
    // Parse OptionString to look for various ntdetect options
    //
    if (BlOptions && OptionStringLength <= 0x1000L && OptionStringLength > 0L) {
        EndOptions = BlOptions + OptionStringLength;

        if (*EndOptions == '\0') {

            if (_fstrstr(BlOptions, "NOIRQSCAN")) {
                DisablePccardIrqScan = 1;
            }

            if (_fstrstr(BlOptions, "NOIRQROUTING")) {
                NoIRQRouting = 1;
            }

            if (_fstrstr(BlOptions, "PCIENUM") ||
                _fstrstr(BlOptions, "RDBUILD") ) {
                PCIEnum = 1; // enable PCI enumeration
            }

            if (_fstrstr(BlOptions, "NOLEGACY")) {
                DisableSerialMice = 0xffff;
                FastDetect = 0x1;
                NoLegacy = 1;
            }

            if (_fstrstr(BlOptions, "FASTDETECT")) {
                DisableSerialMice = 0xffff;
                FastDetect = 0x1;
            } else {
                do {
                    if (BlOptions = _fstrstr(BlOptions, "NOSERIALMICE")) {
                        BlOptions += strlen("NOSERIALMICE");
                        while ((*BlOptions == ' ') || (*BlOptions == ':') ||
                               (*BlOptions == '=')) {
                            BlOptions++;
                        }

                        if (*BlOptions == 'C' && BlOptions[1] == 'O' &&
                            BlOptions[2] == 'M') {
                            BlOptions += 3;
                            while (TRUE) {
                                while (*BlOptions != '\0' && (*BlOptions == ' ' ||
                                       *BlOptions == ',' || *BlOptions == ';' ||
                                       *BlOptions == '0')) {
                                    BlOptions++;
                                }
                                if (*BlOptions >= '0' && *BlOptions <= '9') {
                                    if (BlOptions[1] < '0' || BlOptions[1] > '9') {
                                        DisableSerialMice |= 1 << (*BlOptions - '0');
                                        BlOptions++;
                                    } else {
                                        BlOptions++;
                                        while (*BlOptions && *BlOptions <= '9' &&
                                               *BlOptions >= '0') {
                                               BlOptions++;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                        } else {
                            DisableSerialMice = 0xffff;
                            break;
                        }
                    }
                } while (BlOptions && *BlOptions && (BlOptions < EndOptions)); // double checking
            }

        }
    }

    //
    // Determine bus type
    //

    if (HwIsEisaSystem()) {
        HwBusType = MACHINE_TYPE_EISA;
    } else {
        HwBusType = MACHINE_TYPE_ISA;
    }

    //
    // Allocate heap space for System component and initialize it.
    // Also make the System component the root of configuration tree.
    //

#if DBG
    clrscrn ();
    BlPrint("Detecting System Component ...\n");
#endif

    ConfigurationRoot = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                        sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    Component = &ConfigurationRoot->ComponentEntry;

    Component->Class = SystemClass;
    Component->Type = MaximumType;          // NOTE should be IsaCompatible
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0;
    Component->ConfigurationDataLength = 0;
    MachineId = "AT/AT COMPATIBLE";
    if (MachineId) {
        Length = strlen(MachineId) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, MachineId);
        Component->Identifier = IdentifierString;
        Component->IdentifierLength = Length;
    } else {
        Component->Identifier = 0;
        Component->IdentifierLength = 0;
    }
    NextRelationship = Child;
    PreviousEntry = ConfigurationRoot;

#if DBG
    BlPrint("Reading BIOS date ...\n");
#endif

    HwGetBiosDate (0xF0000, 0xFFFF, &BiosYear, &BiosMonth, &BiosDay);

#if DBG
    BlPrint("Done reading BIOS date (%d/%d/%d)\n",
                BiosMonth, BiosDay, BiosYear);

    BlPrint("Detecting PCI Bus Component ...\n");
#endif

    if (BiosYear > 1992 ||  (BiosYear == 1992  &&  BiosMonth >= 11) ) {

        // Bios date valid for pci presence check..
        HwGetPciSystemData((PVOID) &PciEntry, TRUE);

    } else {

        // Bios date not confirmed...
        HwGetPciSystemData((PVOID) &PciEntry, FALSE);
    }

    // If this is a PCI machine, we may need to get the IRQ routing table...
    //
    if (PciEntry.NoBuses)
    {
        // Add a PCI BIOS entry under the multi function key.
        // This will hold the irq routing table if it can be retrieved.
        //
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA) HwAllocateHeap (
                sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PCI BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        //
        // Add it to the tree
        //

        if (NextRelationship == Sibling) {
             PreviousEntry->Sibling = AdapterEntry;
             AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
             PreviousEntry->Child = AdapterEntry;
             AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;

        //
        // Now deal with the IRQ routing table if we need to.
        //

        if (NoIRQRouting) {
#if DBG
        BlPrint("\nSkipping calling PCI BIOS to get IRQ routing table...\n");
#endif
        } else {

            //
            // Add RealMode IRQ Routing Table to the tree
            //
#if DBG
        BlPrint("\nCalling PCI BIOS to get IRQ Routing table...\n");
#endif // DBG

            IrqRoutingTable = HwGetRealModeIrqRoutingTable();
            if (IrqRoutingTable)
            {
                CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                      sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
                strcpy (Identifier, "PCI Real-mode IRQ Routing Table");
                i = strlen(Identifier) + 1;
                IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
                _fstrcpy(IdentifierString, Identifier);

                Component = &CurrentEntry->ComponentEntry;
                Component->Class = PeripheralClass;
                Component->Type = RealModeIrqRoutingTable;
                Component->Version = 0;
                Component->Key = 0;
                Component->AffinityMask = 0xffffffff;
                Component->IdentifierLength = i;
                Component->Identifier = IdentifierString;

                Length = IrqRoutingTable->TableSize + DATA_HEADER_SIZE;
                CurrentEntry->ConfigurationData =
                    (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

                Component->ConfigurationDataLength = Length;
                _fmemcpy((FPUCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE,
                         IrqRoutingTable,
                         Length - DATA_HEADER_SIZE);

                HwSetUpFreeFormDataHeader(
                        (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                        0,
                        0,
                        0,
                        Length - DATA_HEADER_SIZE
                        );

                //
                // Add it to tree
                //

                AdapterEntry->Child = CurrentEntry;
                CurrentEntry->Parent = AdapterEntry;
            }
#if DBG
        BlPrint("Getting IRQ Routing table from PCI BIOS complete...\n");
#endif // DBG
        }
    }

    //
    // Add a registry entry for each PCI bus
    //

    for (i=0; i < PciEntry.NoBuses; i++) {

        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PCI");
        Length = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = Length;
        Component->Identifier = IdentifierString;

        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

        if (i == 0) {
            //
            // For the first PCI bus include the PCI_REGISTRY_INFO
            //

            Length = sizeof(PCI_REGISTRY_INFO) + DATA_HEADER_SIZE;
            ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

            Component->ConfigurationDataLength = Length;
            AdapterEntry->ConfigurationData = ConfigurationData;

            _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                       (FPVOID) &PciEntry, sizeof (PCI_REGISTRY_INFO));

            HwSetUpFreeFormDataHeader(
                    (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                    0,
                    0,
                    0,
                    Length - DATA_HEADER_SIZE
                    );
        }

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;
    }

#if DBG
    BlPrint("Detecting PCI Bus Component completes ...\n");
#endif

    //
    // Enumerate the PCI Devices.
    //

    if (PCIEnum == 0 || PciEntry.NoBuses == 0) {
#if DBG
    BlPrint("\nSkipping enumeration of PCI devices...\n");
#endif
    } else {
        //
        // Enumerate PCI Devices
        //
#if DBG
        clrscrn ();
        BlPrint("\nEnumerating PCI Devices...\n");
#endif // DBG

        PciInit(&PciEntry);

        //
        // Count the devices
        //

        for (nDevIt = 0; (nDevIt = PciFindDevice(0, 0, nDevIt)) != 0;) {
            PCIDeviceCount++;
        }

#if DBG
        BlPrint("Found %d PCI devices\n", PCIDeviceCount );
#endif 

        CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
        strcpy (Identifier, "PCI Devices");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component = &CurrentEntry->ComponentEntry;
        Component->Class = PeripheralClass;
        Component->Type = RealModePCIEnumeration;
        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        Length = (( sizeof( USHORT ) + sizeof( PCI_COMMON_CONFIG )) * PCIDeviceCount) + DATA_HEADER_SIZE;
        CurrentEntry->ConfigurationData =
            (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

#if DBG
        if (CurrentEntry->ConfigurationData == NULL ) {
            BlPrint("Failed to allocate %d bytes for PCI Devices\n", Length );
        }
#endif

        Component->ConfigurationDataLength = Length;

        //        
        // Fill in Device Information
        //
        PCIDeviceCount = 0;
        
        for (nDevIt = 0; (nDevIt = PciFindDevice(0, 0, nDevIt)) != 0;) {
            FPUCHAR pCurrent;
            PCI_COMMON_CONFIG config;

            PciReadConfig(nDevIt, 0, (UCHAR*)&config, sizeof(config));

            pCurrent = (FPUCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE + ( PCIDeviceCount * ( sizeof( USHORT) + sizeof ( PCI_COMMON_CONFIG ) ) );

            *(FPUSHORT)pCurrent = nDevIt;
            
            _fmemcpy(pCurrent + sizeof( USHORT ),
                     &config,
                     sizeof ( USHORT ) + sizeof ( PCI_COMMON_CONFIG ) );
#if DBG
            {
                USHORT x = (config.BaseClass << 8) + config.SubClass;
                
                BlPrint("%d: %x %d.%d.%d: PCI\\VEN_%x&DEV_%x&SUBSYS_%x%x&REV_%x&CC_%x", 
                    PCIDeviceCount,
                    nDevIt,
                    PCI_ITERATOR_TO_BUS(nDevIt), 
                    PCI_ITERATOR_TO_DEVICE(nDevIt), 
                    PCI_ITERATOR_TO_FUNCTION(nDevIt), 
                    config.VendorID, 
                    config.DeviceID, 
                    config.u.type0.SubSystemID, 
                    config.u.type0.SubVendorID, 
                    config.RevisionID,
                    x );

                if ( (config.HeaderType & (~PCI_MULTIFUNCTION) ) == PCI_BRIDGE_TYPE) {
                    BlPrint(" Brdg %d->%d\n", 
                        config.u.type1.PrimaryBus,
                        config.u.type1.SecondaryBus );
                } else {
                    BlPrint("\n");
                }
            }
#endif
            PCIDeviceCount++;
        }

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //

        AdapterEntry->Child = CurrentEntry;
        CurrentEntry->Parent = AdapterEntry;

#if DBG
        BlPrint("Enumerating PCI devices complete...\n");
        while ( ! HwGetKey ());
        clrscrn();
#endif // DBG
    }

    if (!NoLegacy) {
#if DBG
        BlPrint("Detecting APM Bus Component ...\n");
#endif

        if (HwGetApmSystemData((PVOID) &ApmEntry)) {
            AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

            Component = &AdapterEntry->ComponentEntry;
            Component->Class = AdapterClass;
            Component->Type = MultiFunctionAdapter;

            strcpy (Identifier, "APM");
            Length = strlen(Identifier) + 1;
            IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
            _fstrcpy(IdentifierString, Identifier);

            Component->Version = 0;
            Component->Key = 0;
            Component->AffinityMask = 0xffffffff;
            Component->IdentifierLength = Length;
            Component->Identifier = IdentifierString;

            AdapterEntry->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;

            //

            Length = sizeof(APM_REGISTRY_INFO) + DATA_HEADER_SIZE;
            ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

            Component->ConfigurationDataLength = Length;
            AdapterEntry->ConfigurationData = ConfigurationData;

            _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                       (FPVOID) &ApmEntry, sizeof (APM_REGISTRY_INFO));

            HwSetUpFreeFormDataHeader(
                    (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                    0,
                    0,
                    0,
                    Length - DATA_HEADER_SIZE
                    );

            //
            // Add it to tree
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = AdapterEntry;
                AdapterEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = AdapterEntry;
                AdapterEntry->Parent = PreviousEntry;
            }

            NextRelationship = Sibling;
            PreviousEntry = AdapterEntry;
        }
#if DBG
    BlPrint("APM Data collection complete...\n");
#endif // DBG
    }


#if DBG
    BlPrint("Detecting PnP BIOS Bus Component ...\n");
#endif

    if (HwGetPnpBiosSystemData(&ConfigurationData,
                               &PnPBiosLength,
                               &SMBIOSLength,
                               &DockInfo)) {
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = PnPBiosLength +
                                             SMBIOSLength +
                                             DATA_HEADER_SIZE +
                                        sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PNP BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                1,
                0,
                PnPBiosLength
                );
        ((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData)->Count = 2;

        //
        // Setup SMBIOS PartialDescriptor
        Descriptor = (FPHWPARTIAL_RESOURCE_DESCRIPTOR)(ConfigurationData +
                                                        PnPBiosLength +
                                                        DATA_HEADER_SIZE);
        Descriptor->Type = RESOURCE_DEVICE_DATA;
        Descriptor->ShareDisposition = 0;
        Descriptor->Flags = 0;
        Descriptor->u.DeviceSpecificData.DataSize = SMBIOSLength;
        Descriptor->u.DeviceSpecificData.Reserved1 = 0;
        Descriptor->u.DeviceSpecificData.Reserved2 = 0;


        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;

        //
        // Add Docking Information to tree
        //

        CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        strcpy (Identifier, "Docking State Information");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component = &CurrentEntry->ComponentEntry;
        Component->Class = PeripheralClass;
        Component->Type = DockingInformation;
        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        Length = sizeof (DockInfo) + DATA_HEADER_SIZE;
        CurrentEntry->ConfigurationData =
            (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

        Component->ConfigurationDataLength = Length;
        _fmemcpy((FPCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE,
                 &DockInfo,
                 Length - DATA_HEADER_SIZE);

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        AdapterEntry->Child = CurrentEntry;
        CurrentEntry->Parent = AdapterEntry;

    }
#if DBG
    BlPrint("PnP BIOS Data collection complete...\n");
#endif // DBG

    //
    // Allocate heap space for Bus component and initialize it.
    //

#if DBG
    BlPrint("Detecting Bus/Adapter Component ...\n");
#endif

    AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &AdapterEntry->ComponentEntry;

    Component->Class = AdapterClass;

    //
    // The assumption here is that the machine has only one
    // type of IO bus.  If a machine has more than one types of
    // IO buses, it will not use this detection code anyway.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        //
        // Note We don't collect EISA config data here.  Because we may
        // exhaust the heap space.  We will collect the data after all
        // the other components are detected.
        //

        Component->Type = EisaAdapter;
        strcpy(Identifier, "EISA");
        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

    } else {

        //
        // If not EISA, it must be ISA
        //

        Component->Type = MultiFunctionAdapter;
        strcpy(Identifier, "ISA");
    }
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    //
    // Make Adapter component System's child
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

    //
    // Collect BIOS information for ConfigurationRoot component.
    // This step is done here because we need data collected in
    // adapter component.  The ConfigurationData is:
    //      HWRESOURCE_DESCRIPTOR_LIST header
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Parameter Table
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Rom Blocks.
    // (Note DATA_HEADER_SIZE contains the size of the first partial
    //  descriptor already.)
    //

#if DBG
    BlPrint("Collecting Disk Geometry...\n");
#endif

    GetInt13DriveParameters((PVOID)&RomChain, &Length);
    InitialLength = (USHORT)(Length + RESERVED_ROM_BLOCK_LIST_SIZE + DATA_HEADER_SIZE +
                    sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    ConfigurationData = (FPUCHAR)HwAllocateHeap(InitialLength, FALSE);
    EndConfigurationData = ConfigurationData + DATA_HEADER_SIZE;
    if (Length != 0) {
        FpRomChain = EndConfigurationData;
        _fmemcpy(FpRomChain, (FPVOID)RomChain, Length);
    }
    EndConfigurationData += (sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                             Length);
    HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              Length
                              );

    //
    // Scan ROM to collect all the ROM blocks, if possible.
    //

#if DBG
    BlPrint("Detecting ROM Blocks...\n");
#endif

    FpRomBlock = EndConfigurationData;
    GetRomBlocks(FpRomBlock, &Length);
    RomBlockLength = Length;
    if (Length != 0) {
        EndConfigurationData += Length;
    } else {
        FpRomBlock = NULL;
    }

    //
    // We have both RomChain and RomBlock information/Headers.
    //

    DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData;
    DescriptorList->Count = 2;
    Descriptor = (FPHWPARTIAL_RESOURCE_DESCRIPTOR)(
                 EndConfigurationData - Length -
                 sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    Descriptor->Type = RESOURCE_DEVICE_DATA;
    Descriptor->ShareDisposition = 0;
    Descriptor->Flags = 0;
    Descriptor->u.DeviceSpecificData.DataSize = (ULONG)Length;
    Descriptor->u.DeviceSpecificData.Reserved1 = 0;
    Descriptor->u.DeviceSpecificData.Reserved2 = 0;

    Length = (USHORT)(MAKE_FLAT_ADDRESS(EndConfigurationData) -
             MAKE_FLAT_ADDRESS(ConfigurationData));
    ConfigurationRoot->ComponentEntry.ConfigurationDataLength = Length;
    ConfigurationRoot->ConfigurationData = ConfigurationData;
    FreeSize = InitialLength - Length;

    HwFreeHeap((ULONG)FreeSize);

    //
    // Set up device information structure for Keyboard.
    //

#if DBG
    BlPrint("Detecting Keyboard Component ...\n");
#endif
    if (NoLegacy) {
        //
        // Do not touch the hardware because there may not be a ports 60/64 on
        // the machine and we will hang if we try to touch them
        //
        KeyboardId = UNKNOWN_KEYBOARD;
    }
    else {
        //
        // Touch the hardware to try to determine an ID
        //
        KeyboardId = GetKeyboardId();
    }

    CurrentEntry = SetKeyboardConfigurationData(KeyboardId);

    //
    // Make display component the child of Adapter component.
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;

    if (!NoLegacy) {
        //
        // Set up device information for com port (Each COM component
        // is treated as a controller class.)
        //

#if DBG
    BlPrint("Detecting ComPort Component ...\n");
#endif

        if (CurrentEntry = GetComportInformation()) {

            FirstCom = CurrentEntry;

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
            } else {
                PreviousEntry->Child = CurrentEntry;
            }
            while (CurrentEntry) {
                CurrentEntry->Parent = AdapterEntry;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

        //
        // Set up device information for parallel port.  (Each parallel
        // is treated as a controller class.)
        //

#if DBG
    BlPrint("Detecting Parallel Component ...\n");
#endif

        if (CurrentEntry = GetLptInformation()) {

            FirstLpt = CurrentEntry;

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

        //
        // Set up device information structure for Mouse.
        //

#if DBG
    BlPrint("Detecting Mouse Component ...\n");
#endif

        if (CurrentEntry = GetMouseInformation()) {

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }
    }

        //
        // Set up device information for floppy drives. (The returned information
        // is a tree structure.)
        //

#if DBG
    BlPrint("Detecting Floppy Component ...\n");
#endif

        if (CurrentEntry = GetFloppyInformation()) {

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
            } else {
                PreviousEntry->Child = CurrentEntry;
            }
            while (CurrentEntry) {
                CurrentEntry->Parent = AdapterEntry;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

#if DBG
    BlPrint("Detecting PcCard ISA IRQ mapping ...\n");
#endif
        if (CurrentEntry = GetPcCardInformation()) {
            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

#if DBG
    BlPrint("Detecting ACPI Bus Component ...\n");
#endif

    if (HwGetAcpiBiosData(&ConfigurationData, &Length)) {
        AcpiAdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                          sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AcpiAdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AcpiAdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = Length;

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "ACPI BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //
        // Big hack here.  This code inserts the ACPI node in
        // the tree one level higher than the ISA devices in
        // the code right above.  But this doesn't work in
        // the NoLegacy case because these devices haven't
        // been added to the tree.
        //
        // Ideally, this code would just be moved above the ISA
        // device detection code.  That would be simpler.  But
        // That causes current ACPI machines to fail to dual-boot
        // because their ARC paths would change.
        //

    //  if (NoLegacy) {
    //
    //      if (NextRelationship == Sibling) {
    //          PreviousEntry->Sibling = AcpiAdapterEntry;
    //          AcpiAdapterEntry->Parent = PreviousEntry->Parent;
    //      } else {
    //          PreviousEntry->Child = AdapterEntry;
    //          AdapterEntry->Parent = PreviousEntry;
    //      }
    //
    //      PreviousEntry = AdapterEntry;
    //
    //  } else {

            if (NextRelationship == Sibling) {
                PreviousEntry->Parent->Sibling = AcpiAdapterEntry;
                AcpiAdapterEntry->Parent = PreviousEntry->Parent->Parent;
            }
    //  }

        NextRelationship = Sibling;
    }

#if DBG
    BlPrint("ACPI BIOS Data collection complete...\n");
#endif // DBG

#if DBG
    BlPrint("Detection done. Press a key to display hardware info ...\n");
    while ( ! HwGetKey ());
    clrscrn ();
#endif

    //
    // Misc. supports.  Note, the information collected here will NOT be
    // written to hardware registry.
    //
    // 1. Collect video font information for vdm
    //

    GetVideoFontInformation();

    //
    // After all the components are detected, we collect EISA config data.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        Component = &AdapterEntry->ComponentEntry;
        GetEisaConfigurationData(&AdapterEntry->ConfigurationData,
                                 &Component->ConfigurationDataLength);
        if (Component->ConfigurationDataLength) {
            HwEisaConfigurationData = (FPUCHAR)AdapterEntry->ConfigurationData +
                                           DATA_HEADER_SIZE;
            HwEisaConfigurationSize = Component->ConfigurationDataLength -
                                           DATA_HEADER_SIZE;

            //
            // Misc. detections based on Eisa config data
            //
            // Update Lpt and com controllers' irq information by examining
            //   the EISA configuration data.
            //

            GetIrqFromEisaData(FirstLpt, ParallelController);
            GetIrqFromEisaData(FirstCom, SerialController);
        }
    }


#if DBG
    CheckConfigurationTree(ConfigurationRoot);
#endif

    //
    // Update all the far pointers in the tree to flat 32 bit pointers
    //

    UpdateConfigurationTree(ConfigurationRoot);

    //
    // Set up returned values:
    //   Size of Heap space which should be preserved for configuration tree
    //   Pointer to the root of the configuration tree.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap(0, FALSE);
    *BlHeapUsed = MAKE_FLAT_ADDRESS(CurrentEntry) -
                  MAKE_FLAT_ADDRESS(ConfigurationRoot);
    *BlConfigurationTree = (ULONG)MAKE_FLAT_ADDRESS(ConfigurationRoot);

}

VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     )
/*++

Routine Description:

    This routine updates all irq information for ControllerType components
    in the controllerList by examinine the eisa configuration data.

Arguments:

    ControllerList - Supplies a pointer to a component entry whoes irq will
        be updated.

    ControllerType - Supplies the controller type whoes irq will be searched
        for.

Returns:

    None.

--*/
{

     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry;
     FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
     FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
     USHORT i, Port;
     UCHAR Irq, Trigger;

     CurrentEntry = ControllerList;
     while (CurrentEntry &&
            CurrentEntry->ComponentEntry.Type == ControllerType) {
         if (CurrentEntry->ConfigurationData) {
             DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)
                              CurrentEntry->ConfigurationData;
             Port = 0;
             for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                 Descriptor = &DescriptorList->PartialDescriptors[i];
                 if (Descriptor->Type == CmResourceTypePort) {
                     Port = (USHORT)Descriptor->u.Port.Start.LowPart;
                     break;
                 }
             }
             if (Port != 0) {
                 for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                     Descriptor = &DescriptorList->PartialDescriptors[i];
                     if (Descriptor->Type == CmResourceTypeInterrupt) {
                         if (HwEisaGetIrqFromPort(Port, &Irq, &Trigger)) {
                             if (Trigger == 0) {  // EISA EDGE_TRIGGER
                                 Descriptor->Flags = EDGE_TRIGGERED;
                             } else {
                                 Descriptor->Flags = LEVEL_SENSITIVE;
                             }
                             Descriptor->u.Interrupt.Level = Irq;
                             Descriptor->u.Interrupt.Vector = Irq;
                             break;
                         }
                     }
                 }
             }
         }
         CurrentEntry = CurrentEntry->Sibling;
     }
}


VOID
UpdateComponentPointers(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine updates all the "far" pointer to 32 bit flat addresses
    for a component entry.

Arguments:

    CurrentEntry - Supplies a pointer to a component entry which will
        be updated.

Returns:

    None.

--*/
{
    FPULONG UpdatePointer;
    FPVOID NextEntry;
    ULONG FlatAddress;

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    UpdatePointer = (FPULONG)&CurrentEntry->Child;
    NextEntry = (FPVOID)CurrentEntry->Child;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->Parent;
    NextEntry = (FPVOID)CurrentEntry->Parent;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->Sibling;
    NextEntry = (FPVOID)CurrentEntry->Sibling;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->ComponentEntry.Identifier;
    NextEntry = (FPVOID)CurrentEntry->ComponentEntry.Identifier;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->ConfigurationData;
    NextEntry = (FPVOID)CurrentEntry->ConfigurationData;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

}



VOID
UpdateConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine traverses loader configuration tree and changes
    all the "far" pointer to 32 bit flat addresses.

Arguments:

    CurrentEntry - Supplies a pointer to a loader configuration
        tree or subtree.

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA TempEntry;
    
    while (CurrentEntry)
    {
        //
        // Spin down finding the deepest child
        //
        while (CurrentEntry->Child) {
            CurrentEntry = CurrentEntry->Child;
        }

        //
        // Now we need to either move to the next sibling.  If we
        // don't have a sibling we need to walk up through the parents
        // until we find an entry with a sibling.  We have to save
        // off the current entry since after we update the entry the
        // pointer are no longer useable.
        //
        while (CurrentEntry) {
            TempEntry = CurrentEntry;
            
            if (CurrentEntry->Sibling != NULL) {
                CurrentEntry = CurrentEntry->Sibling;
                UpdateComponentPointers(TempEntry);
                break;
            } else {
                CurrentEntry = CurrentEntry->Parent;
                UpdateComponentPointers(TempEntry);
            }
        }
    }
}

FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    )

/*++

Routine Description:

    This routine allocates space from far heap , puts the caller's controller
    information to the space and sets up CONFIGURATION_COMPONENT
    structure for the caller.

Arguments:

    Component - Supplies the address the component whose configuration data
                should be set up.

    Identifier - Suppies a pointer to the identifier to identify the controller

    ControlData - Supplies a point to a structure which describes
                controller information.

    SpecificDataLength - size of the device specific data.  Device specific
                data is the information not defined in the standard format.

    SpecificData - Supplies a pointer to the device specific data.


Return Value:

    Returns a far pointer to the Configuration data.

--*/

{
    FPCHAR fpIdentifier;
    FPHWRESOURCE_DESCRIPTOR_LIST fpDescriptor = NULL;
    USHORT Length;
    SHORT Count, i;
    FPUCHAR fpSpecificData;

    //
    // Set up Identifier string for hardware component, if necessary.
    //

    if (Identifier) {
        Length = strlen(Identifier) + 1;
        Component->IdentifierLength = Length;
        fpIdentifier = (FPUCHAR)HwAllocateHeap(Length, FALSE);
        Component->Identifier = fpIdentifier;
        _fstrcpy(fpIdentifier, Identifier);
    } else {
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;
    }

    //
    // Set up configuration data for hardware component, if necessary
    //

    Count = ControlData->NumberPortEntries + ControlData->NumberIrqEntries +
            ControlData->NumberMemoryEntries + ControlData->NumberDmaEntries;

    if (SpecificDataLength) {

        //
        // if we have device specific data, we need to increment the count
        // by one.
        //

        Count++;
    }

    if (Count >0) {
        Length = (USHORT)(Count * sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                 FIELD_OFFSET(HWRESOURCE_DESCRIPTOR_LIST, PartialDescriptors) +
                 SpecificDataLength);
        fpDescriptor = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(Length, TRUE);
        fpDescriptor->Count = Count;

        //
        // Copy all the partial descriptors to the destination descriptors
        // except the last one. (The last partial descriptor may be a device
        // specific data.  It requires special handling.)
        //

        for (i = 0; i < (Count - 1); i++) {
            fpDescriptor->PartialDescriptors[i] =
                                        ControlData->DescriptorList[i];
        }

        //
        // Set up the last partial descriptor.  If it is a port, memory, irq or
        // dma entry, we simply copy it.  If the last one is for device specific
        // data, we set up the length and copy the device spcific data to the end
        // of the decriptor.
        //

        if (SpecificData) {
            fpDescriptor->PartialDescriptors[Count - 1].Type =
                            RESOURCE_DEVICE_DATA;
            fpDescriptor->PartialDescriptors[Count - 1].Flags = 0;
            fpDescriptor->PartialDescriptors[Count - 1].u.DeviceSpecificData.DataSize =
                            SpecificDataLength;
            fpSpecificData = (FPUCHAR)&(fpDescriptor->PartialDescriptors[Count]);
            _fmemcpy(fpSpecificData, SpecificData, SpecificDataLength);
        } else {
            fpDescriptor->PartialDescriptors[Count - 1] =
                            ControlData->DescriptorList[Count - 1];
        }
        Component->ConfigurationDataLength = Length;
    }
    return(fpDescriptor);
}
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    )

/*++

Routine Description:

    This routine initialize free formed data header.  Note this routine
    sets the the Header and initialize the FIRST PartialDescriptor only.
    If the header contains more than one descriptor, the caller must handle
    it itself.

Arguments:

    Header - Supplies a pointer to the header to be initialized.

    Version - Version number for the header.

    Revision - Revision number for the header.

    Flags - Free formed data flags.  (Currently, it is undefined and
                should be zero.)

    DataSize - Size of the free formed data.


Return Value:

    None.

--*/

{

    Header->Version = Version;
    Header->Revision = Revision;
    Header->Count = 1;
    Header->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    Header->PartialDescriptors[0].ShareDisposition = 0;
    Header->PartialDescriptors[0].Flags = Flags;
    Header->PartialDescriptors[0].u.DeviceSpecificData.DataSize = DataSize;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
}
#if DBG

VOID
CheckComponentNode(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    FPUCHAR NextEntry, DataPointer;
    ULONG FlatAddress;
    ULONG Length;
    UCHAR IdString[40];
    USHORT Count, i;
    UCHAR Type;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    FlatAddress = MAKE_FLAT_ADDRESS(CurrentEntry);
    clrscrn ();
    BlPrint("\n");
    BlPrint("Current Node: %lx\n", FlatAddress);
    BlPrint("  Type = %s\n", TypeName[CurrentEntry->ComponentEntry.Type]);

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    NextEntry = (FPUCHAR)CurrentEntry->Child;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Child = %lx\n", FlatAddress);
    } else {
        BlPrint("\tChild = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Parent;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Parent = %lx\n", FlatAddress);
    } else {
        BlPrint("\tParent = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Sibling;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Sibling = %lx\n", FlatAddress);
    } else {
        BlPrint("\tSibling = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->ConfigurationData;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: ConfigurationData = %lx\n", FlatAddress);
    } else {
        BlPrint("\tConfigurationData = %lx\n", FlatAddress);
    }

    Length = CurrentEntry->ComponentEntry.IdentifierLength;
    BlPrint("IdentifierLength = %lx\n", CurrentEntry->ComponentEntry.IdentifierLength);
    if (Length > 0) {
        _fstrcpy(IdString, CurrentEntry->ComponentEntry.Identifier);
        BlPrint("Identifier = %s\n", IdString);
    }

    Length = CurrentEntry->ComponentEntry.ConfigurationDataLength;
    BlPrint("ConfigdataLength = %lx\n", Length);

    if (Length > 0) {

        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)CurrentEntry->ConfigurationData;
        BlPrint("Version = %x, Revision = %x\n", DescriptorList->Version,
                 DescriptorList->Revision);
        Count = (USHORT)DescriptorList->Count;
        Descriptor = &DescriptorList->PartialDescriptors[0];
        BlPrint("Count = %x\n", Count);
        while (Count > 0) {
            Type = Descriptor->Type;
            if (Type == RESOURCE_PORT) {
                BlPrint("Type = Port");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("PortFlags = %x\n", Descriptor->Flags);
                BlPrint("PortStart = %x", Descriptor->u.Port.Start);
                BlPrint("\tPortLength = %x\n", Descriptor->u.Port.Length);
            } else if (Type == RESOURCE_DMA) {
                BlPrint("Type = Dma");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("DmaFlags = %x\n", Descriptor->Flags);
                BlPrint("DmaChannel = %x", Descriptor->u.Dma.Channel);
                BlPrint("\tDmaPort = %lx\n", Descriptor->u.Dma.Port);
            } else if (Type == RESOURCE_INTERRUPT) {
                BlPrint("Type = Interrupt");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("InterruptFlags = %x\n", Descriptor->Flags);
                BlPrint("Level = %x", Descriptor->u.Interrupt.Level);
                BlPrint("\tVector = %x\n", Descriptor->u.Interrupt.Vector);
            } else if (Type == RESOURCE_MEMORY) {
                BlPrint("Type = Memory");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("MemoryFlags = %x\n", Descriptor->Flags);
                BlPrint("Start1 = %lx", (ULONG)Descriptor->u.Memory.Start.LowPart);
                BlPrint("\tStart2 = %lx", (ULONG)Descriptor->u.Memory.Start.HighPart);
                BlPrint("\tLength = %lx\n", Descriptor->u.Memory.Length);
            } else {
                BlPrint("Type = Device Data\n");
                Length = Descriptor->u.DeviceSpecificData.DataSize;
                BlPrint("Size = %lx\n", Length);
                DataPointer = (FPUCHAR)(Descriptor+1);
                for (i = 0; (i < (USHORT)Length) && (i < 64); i++) {
                    BlPrint("%x ", *DataPointer);
                    DataPointer++;
                }
                break;
            }
            Count--;
            Descriptor++;
        }
    }
    while (HwGetKey() == 0) {
    }
}

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    FPFWCONFIGURATION_COMPONENT_DATA TempEntry;
    
    while (CurrentEntry)
    {
        //
        // Spin down finding the deepest child
        //
        while (CurrentEntry->Child) {
            CurrentEntry = CurrentEntry->Child;
        }

        //
        // Now we need to either move to the next sibling.  If we
        // don't have a sibling we need to walk up through the parents
        // until we find an entry with a sibling.  We have to save
        // off the current entry since after we update the entry the
        // pointer are no longer useable.
        //
        while (CurrentEntry) {
            TempEntry = CurrentEntry;
            
            if (CurrentEntry->Sibling != NULL) {
                CurrentEntry = CurrentEntry->Sibling;
                CheckComponentNode(TempEntry);
                break;
            } else {
                CurrentEntry = CurrentEntry->Parent;
                CheckComponentNode(TempEntry);
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwdetect.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    detect.h

Abstract:

    This module is a global C include file for all the detection
    modules.

Author:

    Shie-Lin Tzong (shielint) 27-Dec-1991

Revision History:

--*/

#define i386
#define _X86_
#define __stdcall
#pragma warning (4:4103)
#include "types.h"
#include "ntmisc.h"
#include <ntconfig.h>
#include <arc.h>

#define X86_REAL_MODE           // must precede include of dockinfo.h
#include "..\..\inc\dockinfo.h"

//
// Machine type definitions.
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

//
// Interrupt controller register addresses.
//

#define PIC1_PORT0 0x20         // master PIC
#define PIC1_PORT1 0x21
#define PIC2_PORT0 0x0A0        // slave PIC
#define PIC2_PORT1 0x0A1

//
// Commands for interrupt controller
//

#define OCW3_READ_ISR 0xb
#define OCW3_READ_IRR 0xa

//
// Definitions for the data stored in the first page 0x700 area
// The 0x700 is the place vdm loads MS-DOS.  It should be very safe
// to pass the data required by vdm.
//

#define DOS_BEGIN_SEGMENT 0x70   // DOS loaded segment address

#define VIDEO_FONT_OFFSET 0      // Video font ptrs stored at 0x700
#define VIDEO_FONT_DATA_SIZE 0x40

#define EBIOS_INFO_OFFSET 0x40   // Extended bios infor:
                                 //   EBIOS data area address 4 bytes
                                 //   EBIOS data area size 4 byte
#define EBIOS_INFO_SIZE   0x8

//
// Mouse information structure
// N.B. This *must* match the one defined in mouse.inc
//

typedef struct _MOUSE_INFORMATION {
        UCHAR MouseType;
        UCHAR MouseSubtype;
        USHORT MousePort;       // if serial mouse, 1 for com1, 2 for com2 ...
        USHORT MouseIrq;
        USHORT DeviceIdLength;
        UCHAR  DeviceId[10];
} MOUSE_INFORMATION, *PMOUSE_INFORMATION;

//
// Mouse Type definitions
//

#define UNKNOWN_MOUSE   0
#define NO_MOUSE        0x100             // YES! it is 0x100 *NOT* 0x10000

#define MS_MOUSE        0x200             // MS regular mouses
#define MS_BALLPOINT    0x300             // MS ballpoint mouse
#define LT_MOUSE        0x400             // Logitec Mouse

//
// note last 4 bits of the subtype are reserved subtype specific use
//

#define PS_MOUSE        0x1
#define SERIAL_MOUSE    0x2
#define INPORT_MOUSE    0x3
#define BUS_MOUSE       0x4
#define PS_MOUSE_WITH_WHEEL     0x5
#define SERIAL_MOUSE_WITH_WHEEL 0x6

//#define MOUSE_RESERVE_MASK  0xfffffff

//
// Definitions for the keyboard type returned from
// the detect keyboard function.
//

#define UNKNOWN_KEYBOARD  0
#define OLI_83KEY         1
#define OLI_102KEY        2
#define OLI_86KEY         3
#define OLI_A101_102KEY   4
#define XT_83KEY          5
#define ATT_302           6
#define PCAT_ENHANCED     7
#define PCAT_86KEY        8
#define PCXT_84KEY        9

//
// Redefine the configuration component structures to use FAR pointer type.
//
// Since ntdetect.com running at 16 bit real mode, it has to use FAR pointers
// to access loader heap.  Before returning to ntldr, ntdetect must convert
// these far pointers to 32 bit flat addresses such that kernel can acess the
// configuration tree.
//

typedef struct _FWCONFIGURATION_COMPONENT {
    CONFIGURATION_CLASS Class;
    USHORT Reserved0;
    CONFIGURATION_TYPE Type;
    USHORT Reserverd1;
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
    ULONG ConfigurationDataLength;
    ULONG IdentifierLength;
    FPCHAR Identifier;
} FWCONFIGURATION_COMPONENT, far *FPFWCONFIGURATION_COMPONENT;

typedef struct _FWCONFIGURATION_COMPONENT_DATA {
    struct _FWCONFIGURATION_COMPONENT_DATA far *Parent;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Child;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Sibling;
    FWCONFIGURATION_COMPONENT ComponentEntry;
    FPVOID ConfigurationData;
} FWCONFIGURATION_COMPONENT_DATA, far *FPFWCONFIGURATION_COMPONENT_DATA;

//
// defined the MicroChannel POS data structure
//

typedef CM_MCA_POS_DATA MCA_POS_DATA, far *FPMCA_POS_DATA;

//
// Rom Block Definition
//

typedef CM_ROM_BLOCK ROM_BLOCK, far *FPROM_BLOCK;
#define RESERVED_ROM_BLOCK_LIST_SIZE (((0xf0000 - 0xc0000)/512) * sizeof(ROM_BLOCK))

//
// Other type redefinitions
//

typedef CM_PARTIAL_RESOURCE_DESCRIPTOR HWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR *PHWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR far *FPHWPARTIAL_RESOURCE_DESCRIPTOR;

typedef CM_PARTIAL_RESOURCE_LIST HWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST *PHWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST far *FPHWRESOURCE_DESCRIPTOR_LIST;

typedef CM_EISA_SLOT_INFORMATION EISA_SLOT_INFORMATION, *PEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION far *FPEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION EISA_FUNCTION_INFORMATION, *PEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION far *FPEISA_FUNCTION_INFORMATION;

#define LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define EDGE_TRIGGERED CM_RESOURCE_INTERRUPT_LATCHED
#define RESOURCE_PORT 1
#define RESOURCE_INTERRUPT 2
#define RESOURCE_MEMORY 3
#define RESOURCE_DMA 4
#define RESOURCE_DEVICE_DATA 5
#define ALL_PROCESSORS 0xffffffff

//
// Note the DATA_HEADER_SIZE counts ONE partial descriptor only.
// if the resource list has more than one descriptors, you must add
// the size of extra descriptors to this value.
//

#define DATA_HEADER_SIZE sizeof(CM_PARTIAL_RESOURCE_LIST)

//
// Defines the structure to store controller information
// (used by ntdetect internally)
//

#define MAXIMUM_DESCRIPTORS 10

typedef struct _HWCONTROLLER_DATA {
    UCHAR NumberPortEntries;
    UCHAR NumberIrqEntries;
    UCHAR NumberMemoryEntries;
    UCHAR NumberDmaEntries;
    HWPARTIAL_RESOURCE_DESCRIPTOR DescriptorList[MAXIMUM_DESCRIPTORS];
} HWCONTROLLER_DATA, *PHWCONTROLLER_DATA;

//
// Macro definitions for conversion between far and fat pointers
//

#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

//
// I/O Port read and write routines.
//

extern
VOID
WRITE_PORT_UCHAR (
    PUCHAR  PortAddress,
    UCHAR   Value
    );

extern
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

extern
VOID
WRITE_PORT_USHORT (
    PUSHORT PortAddress,
    USHORT  Value
    );

extern
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

extern
VOID
WRITE_PORT_ULONG (
    PUSHORT PortAddress,
    ULONG  Value
    );

extern
ULONG
READ_PORT_ULONG(
    PUSHORT Port
    );

//
// prototype definitions for Heap management routines
//

extern
BOOLEAN
HwInitializeHeap (
    ULONG HeapStart,
    ULONG HeapSize
    );

extern
FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    );

extern
VOID
HwFreeHeap(
    ULONG Size
    );

//
// Misc. prototype definitions
//

extern
FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    );

extern
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    );

USHORT
HwGetKey(
    VOID
    );

extern
BOOLEAN
IsEnhancedKeyboard (
    VOID
    );

extern
SHORT
GetKeyboardIdBytes (
   PCHAR IdBuffer,
   SHORT Length
   );

extern
USHORT
GetKeyboardId(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    IN USHORT KeyboardId
    );

#if 0 // Remove video detection
extern
ULONG
GetVideoAdapterType (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetVideoConfigurationData (
    IN ULONG VideoType
    );
#endif // Remove video detection

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetLptInformation (
    VOID
    );

extern
PMOUSE_INFORMATION
GetMouseId (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetAtDiskInformation(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetPcCardInformation(
    VOID
    );

extern
BOOLEAN
HwIsMcaSystem(
    VOID
    );

extern
BOOLEAN
HwIsEisaSystem(
    VOID
    );

extern
BOOLEAN
IsNpxPresent(
    VOID
    );

extern
USHORT
HwGetProcessorType(
    VOID
    );

extern
USHORT
HwGetCpuStepping(
    USHORT
    );

extern
VOID
GetMcaPosData(
    FPVOID Entry,
    FPULONG DataLength
    );

extern
VOID
GetEisaConfigurationData(
    FPVOID Entry,
    FPULONG DataLength
    );

extern
VOID
UpdateConfigurationTree(
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
    );

extern
PUCHAR
GetMachineId(
    VOID
    );

extern
VOID
HwGetEisaSlotInformation (
    PEISA_SLOT_INFORMATION SlotInformation,
    UCHAR Slot
    );

extern
UCHAR
HwGetEisaFunctionInformation (
    PEISA_FUNCTION_INFORMATION FunctionInformation,
    UCHAR Slot,
    UCHAR Function
    );

extern
VOID
GetBiosSystemEnvironment (
    PUCHAR Buffer
    );

extern
VOID
GetInt13DriveParameters (
    PUCHAR Buffer,
    PUSHORT Size
    );

extern
VOID
GetRomBlocks(
    FPUCHAR ReservedBuff,
    PUSHORT Size
    );

extern
VOID
GetVideoFontInformation(
    VOID
    );

extern
BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    );

VOID
HwGetPciSystemData(
    PVOID,
    BOOLEAN
    );

UCHAR
HwGetPciIrqRoutingOptions(
    VOID far *RouteBuffer,
    PUSHORT ExclusiveIRQs
    );

VOID
HwGetBiosDate(
    ULONG source,
    USHORT  Length,
    PUSHORT BiosYear,
    PUSHORT BiosMonth,
    PUSHORT BiosDay
    );

BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT PnPBiosLength,
    OUT PUSHORT SMBIOSLength,
    IN OUT FPDOCKING_STATION_INFO DockInfo
    );

BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    );

#if DBG
extern
VOID
BlPrint(
    IN PCHAR,
    ...
    );

extern
VOID
clrscrn (
    VOID
    );

#endif // DBG

BOOLEAN HwGetApmSystemData(PVOID);

//
// External declarations for global variables
//

extern USHORT HwBusType;

extern FPFWCONFIGURATION_COMPONENT_DATA AdapterEntry;

extern FPMCA_POS_DATA HwMcaPosData;

extern FPUCHAR FpRomBlock;

extern USHORT RomBlockLength;

extern FPUCHAR HwEisaConfigurationData;

extern ULONG HwEisaConfigurationSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hweisa.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;   eisa.inc
;
;   Abstract:
;
;   This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;   Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends

;
; Structure definitions for INT 15 E980
;

E980Info struc
        Signature               dw      ?
        CommandPortAddress      dw      ?
        EventPortAddress        dw      ?
        PollInterval            dw      ?
        CommandDataValue        db      ?
        EventPortBitmask        db      ?
        MaxLevelAc              db      ?
        MaxLevelDc              db      ?
E980Info ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwheap.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This is a very simple Heap Manager for NT OS Hardware recognizer.
    This module provides functions to allocate memory in byte-unit
    from a permanent heap.

Author:

    Shie-Lin Tzong (shielint) 18-Oct-91


Environment:

    Kernel Mode


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

VOID
GrowHeapSpace(
    ULONG
    );

VOID
HeapCheck(
    PVOID
    );

//
// Heap management variables.
//

ULONG HwHeapBase = 0;           // Current virtual address of base of heap
ULONG HwHeapPointer = 0;        // Pointer to the end of available heap
ULONG  HwHeapSize = 0;          // Size of Heap
ULONG  HwAvailableHeap = 0;     // Currently available heap space

#if DBG
ULONG HwPreviousAllocSize = 0;
#endif

BOOLEAN
HwResizeHeap (
    ULONG NewHeapSize
    )

/*++

Routine Description:

    The routine grows current heap to the specified size.
    It reallocates the heap, copies the data in current heap to
    the new heap, updates heap variables, updates heap pointers
    in hardware data structures and finally frees the old heap.

Arguments:

    NewHeapSize - Specifies the size of the new heap.

Returns:

    TRUE - if operation is done sucessfully.  Else it returns FALSE.

--*/

{
    //
    // Not implemented yet.
    //

    return(FALSE);
}

BOOLEAN
HwInitializeHeap(
    ULONG HeapStart,
    ULONG HeapSize
    )

/*++

Routine Description:

    The routine allocates heap and initializes some vital heap
    variables.

Arguments:

    None

Returns:

    FALSE - if unable to allocate initial heap.  Else it returns TRUE.

--*/

{

    HwHeapBase = HeapStart;
    HwHeapPointer = HwHeapBase;
    HwHeapSize = HeapSize;
    HwAvailableHeap = HwHeapSize;
    return(TRUE);

}

FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    )

/**

Routine Description:

    Allocates memory from the hardware recognizer's heap.

    The heap begins with a default size. If a request exhausts heap space,
    the heap will be grown to accomodate the request. The heap can grow
    up to any size limited by NTLDR.  If we run out of heap space and are
    unable to allocate more memory, a value of NULL will be returned.

Arguments:

    RequestSize - Size of block to allocate.

    ZeroInitialized - Specifies if the heap should be zero initialized.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{
    FPVOID ReturnPointer;

    if (RequestSize > HwAvailableHeap) {

        //
        // We're out of heap.  Try to grow current heap to satisfy the
        // request.
        //

        if (!HwResizeHeap(HwHeapSize + RequestSize)) {
#if DBG
            BlPrint("Unable to grow heap\n");
#endif
            return(NULL);
        }
    }

    //
    // Set our return value to the new Heap pointer then
    // update the remaining space and heap pointer.
    //

    MAKE_FP(ReturnPointer, HwHeapPointer);
    HwHeapPointer += RequestSize;
#if DBG
    HwPreviousAllocSize = RequestSize;
#endif
    HwAvailableHeap -= RequestSize;
    if (ZeroInitialized) {
        _fmemset(ReturnPointer, 0, (USHORT)RequestSize);
    }
    return (ReturnPointer);
}

VOID
HwFreeHeap(
    ULONG Size
    )

/**

Routine Description:

    Unallocates memory from the hardware recognizer's heap.

    The unallocation is very basic.  It simply moves heap pointer
    back by the size specified and increases the heap size by the
    specified size.  The routine should be used only when previous
    allocateHeap allocated too much memory.

Arguments:

    RequestSize - Size of block to allocate.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{

#if DBG
    if (Size > HwPreviousAllocSize) {
        BlPrint("Invalid heap deallocation ...\n");
    } else {
        HwPreviousAllocSize -= Size;
    }
#endif

    HwHeapPointer -= Size;
    HwAvailableHeap += Size;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwpbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpbiosc.c

Abstract:

    This modules contains PnP BIOS C supporting routines

Author:

    Shie-Lin Tzong (shielint) 20-Apr-1995

Environment:

    Real mode.

Revision History:

    Doug Fritz     (dfritz)   02-Oct-1997
      - Add: get docking station info from PnP BIOS and pass to NTLDR
          
    Alan Warwick   (alanwar)  10-Feb-1998
      - Add: get SMBIOS tables from PnP BIOS and pass to NTLDR

--*/

#include "hwdetect.h"
#include <string.h>
#include "smbios.h"
#include "pnpbios.h"

//
// Some global variables referenced by other routines
//
BOOLEAN SystemHas8259 = FALSE;
BOOLEAN SystemHas8253 = FALSE;

USHORT HwSMBIOSStructureLength(
    FPSMBIOS_STRUCT_HEADER StructHeader,
    USHORT MaxStructLen
    )
{
    USHORT length;
    UCHAR type;
    FPUCHAR stringPtr;
    
    type = StructHeader->Type;
    length = StructHeader->Length;

    //
    // The length of an SMBIOS structure can be computed by adding the size
    // specified in the structure header plus the space used by the string
    // table that immediately follows the structure header. The size of the
    // string table is determined by scanning for a double NUL. A problem is
    // that those structures that do not contain strings do not have a 
    // double NUL to indicate an empty string table. However since we do 
    // initialize the entire buffer to 0 before calling the bios there 
    // will always be a double nul at the end regardless of how the bios
    // fills writes the structure. 
        
    stringPtr = (FPUCHAR)StructHeader + StructHeader->Length;
            
    //
    // Loop one byte at a time until double NUL is found
    while ((*((FPUSHORT)stringPtr) != 0) && (length < MaxStructLen))
    {
        stringPtr++;
        length++;
    }
 
#if DBG
    if (length == MaxStructLen)
    {
        BlPrint("HwSMBIOSStructureLength: structure overflow 0x%x\n", length);
    }
#endif
    
    return(length);
}


USHORT HwGetSMBIOSInfo(
    ENTRY_POINT BiosEntry,
    USHORT RealModeDataBaseAddress,
    USHORT StructBufferSize,
    FPUCHAR StructBuffer
    )
/*++

Routine Description:

    This routine determine if SMBIOS information is available in the system
    and if so then collect the size needed for all of the information and
    actually collect the information.
        
    The SMBIOS tables are packed into a buffer end to end. The length of each
    SMBIOS table is determined by the length in the structure header plus 
    any memory used by the stirng space immediately after the fixed portion
    of the structure. The string space is terminated by a double NUL. However
    some structure types do not contain strings and thus do not have a
    string space so the length of the structure is simply the length specified
    in the structure header. However this routine will append a double NUL
    to those structures anyway so that the total length of each structure
    within the buffer can be determined by finding the first double NUL after 
    the length declared in the structure header.
    

Arguments:

    BiosEntry is the real mode entrypoint to the PnP bios
        
    RealModeDataBaseAddress
        
    StructBufferSize is the maximum number of bytes available to write in 
        StructBuffer
            
    StructBuffer is the buffer in which to write the SMBIOS data. If this is
        NULL then only the size needed to write the data is determined.

Return Value:

    Size of SMBIOS structures

--*/
{
    USHORT retCode;
    USHORT numberStructures;
    USHORT maxStructSize;
    ULONG dmiStorageBase;
    USHORT dmiStorageSize;
    UCHAR dmiBiosRevision;
    ULONG romAddr, romEnd;
    FPSMBIOS_EPS_HEADER header;
    FPDMIBIOS_EPS_HEADER dmiHeader;
    FPUCHAR current;
    UCHAR sum;
    USHORT j;
    USHORT structCount;
    USHORT structNumber;
    USHORT dmiStorageSegment;
    USHORT totalStructSize = 0;
    USHORT checkLength;
    FPSMBIOS_STRUCT_HEADER structHeader;
    USHORT length, lengthNeeded;
    FPUCHAR tempStructBuffer;
    
#if DBG
    BlPrint("GetSMBIOSInfo: Determining SMBIOS - Try for table\n");
#endif

    MAKE_FP(current, PNP_BIOS_START);
    romAddr = PNP_BIOS_START;
    romEnd  = PNP_BIOS_END;

    checkLength = 0;
    while (romAddr < romEnd) {
        header = (FPSMBIOS_EPS_HEADER)current;
        dmiHeader = (FPDMIBIOS_EPS_HEADER)current;
    
        if ((dmiHeader->Signature2[0] == '_') &&
            (dmiHeader->Signature2[1] == 'D') &&
            (dmiHeader->Signature2[2] == 'M') &&
            (dmiHeader->Signature2[3] == 'I') &&
            (dmiHeader->Signature2[4] == '_')) {
#if DBG
            BlPrint("GetSMBIOSInfo: found _DMI_ anchor string installation %lx\n",
                    dmiHeader);
#endif
            checkLength = sizeof(DMIBIOS_EPS_HEADER);
        } else if (header->Signature[0] == '_' && 
                   header->Signature[1] == 'S' &&
                   header->Signature[2] == 'M' && 
                   header->Signature[3] == '_' &&
                   header->Length >= sizeof(SMBIOS_EPS_HEADER) &&
                   header->Signature2[0] == '_' && 
                   header->Signature2[1] == 'D' &&
                   header->Signature2[2] == 'M' && 
                   header->Signature2[3] == 'I' &&
                   header->Signature2[4] == '_' ) {
#if DBG
            BlPrint("GetSMBIOSInfo: found _SM_ anchor string installation %lx\n",
                    header);
#endif
            checkLength = header->Length;
            dmiHeader = (FPDMIBIOS_EPS_HEADER)&header->Signature2[0];
        }

        if (checkLength != 0)
        {
            sum = 0;
            for (j = 0; j < checkLength; j++) {
                sum += current[j];
            }
        
            if (sum == 0) {            
                break;
            }
#if DBG
            BlPrint("GetSMBIOSInfo: Checksum fails\n");
#endif
            checkLength = 0;
        }
        
        romAddr += PNP_BIOS_HEADER_INCREMENT;
        MAKE_FP(current, romAddr);        
    }
  
    if (romAddr >= romEnd) {
        //
        // We could not find the table so try the calling method
        dmiBiosRevision = 0;
        numberStructures = 0;
        retCode = BiosEntry(GET_DMI_INFORMATION,
                            (FPUCHAR)&dmiBiosRevision,
                            (FPUSHORT)&numberStructures,
                            (FPUSHORT)&maxStructSize,
                            (FPULONG)&dmiStorageBase,
                            (FPUSHORT)&dmiStorageSize,
                            RealModeDataBaseAddress);
            
        if ((retCode != DMI_SUCCESS) ||
            (dmiBiosRevision < 0x20))
        {
#if DBG
            BlPrint("GetSMBIOSInfo: GET_DMI_INFORMATION failed %x\n", retCode);
#endif
        return(0);
#if DBG
        } else {
            BlPrint("GetSMBIOSInfo: GET_DMI_INFORMATION\n");
            BlPrint("    BiosRevision %x      Number Structures %x     Structure Size %x\n", dmiBiosRevision, numberStructures, maxStructSize);
            BlPrint("    StorageBase %lx       StorageSize %x\n", dmiStorageBase, dmiStorageSize);
#endif        
        }    
    
        maxStructSize += 3;
        tempStructBuffer = HwAllocateHeap(maxStructSize, FALSE);
        if (tempStructBuffer == NULL)
        {
#if DBG
            BlPrint("GetSMBIOSInfo: HwAllocateHeap(structureSize = 0x%x\n",
                    maxStructSize);
#endif
            return(0);
        }
        
        //
        // Loop calling Get_DMI_STRUCTURE to get next structure until we
        // hit the end of structure or receive an error.
        structCount = 0;
        structNumber = 0;
        dmiStorageSegment = (USHORT)(dmiStorageBase >> 4);
        while ((structCount < numberStructures) && 
               (retCode == DMI_SUCCESS) && 
               (structNumber != 0xffff))
        {
            _fmemset(tempStructBuffer, 0, maxStructSize);
            retCode = BiosEntry(GET_DMI_STRUCTURE,
                                (FPUSHORT)&structNumber,
                                (FPUCHAR)tempStructBuffer,
                                dmiStorageSegment,
                                RealModeDataBaseAddress
                                );
#if DBG
            BlPrint("GetSMBIOSInfo: GET_DMI_STRUCTURE --> %x\n", retCode);
#endif
            if (retCode == DMI_SUCCESS)
            {                                   
                structCount++;
                structHeader = (FPSMBIOS_STRUCT_HEADER)tempStructBuffer;
        
                length = HwSMBIOSStructureLength(structHeader, maxStructSize);
                
                lengthNeeded = length + 2;
                if (StructBuffer != NULL)
                {
                    //
                    // if caller wants the data then lets copy into it buffer
                    if (StructBufferSize >= lengthNeeded)
                    {
                        _fmemcpy(StructBuffer, 
                                 tempStructBuffer,
                                 length);
             
                        *((FPUSHORT)&StructBuffer[length]) = 0;
            
                        StructBufferSize -= lengthNeeded;
                        StructBuffer += lengthNeeded;
                        totalStructSize += lengthNeeded;
#if DBG
                    } else {
                        BlPrint("GetSMBIOSInfo: Struct too large 0x%x bytes left\n",
                                 StructBufferSize);
#endif
                    }
                } else {
                    //
                    // Caller is only interested in length required
                    totalStructSize += lengthNeeded;
                }
                
#if DBG
                BlPrint("GetSMBIOSInfo: Number 0x%x Type 0x%x Length 0x%x/0x%x Handle 0x%x\n",
                        structNumber,
                        structHeader->Type,
                        structHeader->Length,
                        length,
                        structHeader->Handle);
                for (j = 0; j < structHeader->Length; j = j + 16)
                {
                    BlPrint("              %x %x %x %x %x %x %x %x\n              %x %x %x %x %x %x %x %x\n",
                            structHeader->Data[j],
                            structHeader->Data[j+1],
                            structHeader->Data[j+2],
                            structHeader->Data[j+3],
                            structHeader->Data[j+4],
                            structHeader->Data[j+5],
                            structHeader->Data[j+6],
                            structHeader->Data[j+7],
                            structHeader->Data[j+8],
                            structHeader->Data[j+9],
                            structHeader->Data[j+10],
                            structHeader->Data[j+11],
                            structHeader->Data[j+12],
                            structHeader->Data[j+13],
                            structHeader->Data[j+14],
                            structHeader->Data[j]+15);
                }
                
                for (j = structHeader->Length; j < length; j++)
                {
                    BlPrint("%c", structHeader->Data[j-sizeof(SMBIOS_STRUCT_HEADER)]);
                    if (structHeader->Data[j-sizeof(SMBIOS_STRUCT_HEADER)] == 0)
                    {
                        BlPrint("\n");
                    }
                }
                BlPrint("\n");
#endif                    
            }
#if DBG
            while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
        }
        HwFreeHeap(maxStructSize);
#if DBG
        BlPrint("GetSMBIOSInfo: %x/%x structures read, total size 0x%x\n",
                 structCount, numberStructures, totalStructSize);
#endif
        
#if DBG
    } else {
        if ((FPVOID)dmiHeader != (FPVOID)header)
        {
            BlPrint("GetSMBIOSInfo: _SM_ Structure Table\n");
            BlPrint("    Length   %x    MajorVersion   %x    MinorVersion   %x\n",
                         header->Length, header->MajorVersion, header->MinorVersion);
            BlPrint("    MaximumStructureSize %x    EntryPointRevision %x    StructureTableLength %x\n",
                header->MaximumStructureSize, header->EntryPointRevision, header->StructureTableLength);
            BlPrint("    StructureTableAddress %x    NumberStructures %x    Revision %x\n",
                         header->StructureTableAddress, header->NumberStructures, header->Revision);
        } else {
            BlPrint("GetSMBIOSInfo: _DMI_ Structure Table\n");
            BlPrint("    StructureTableLength %x\n",
                         dmiHeader->StructureTableLength);
            BlPrint("    StructureTableAddress %x    NumberStructures %x    Revision %x\n",
                         dmiHeader->StructureTableAddress, dmiHeader->NumberStructures, dmiHeader->Revision);
        }
#endif
    }

#if DBG
    while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
                            
    return(totalStructSize);                        
}
    

#if 0
VOID
HwDisablePnPBiosDevnode(
    ENTRY_POINT biosEntry,
    FPPNP_BIOS_INSTALLATION_CHECK header,
    UCHAR node,
    FPPNP_BIOS_DEVICE_NODE deviceNode
    )
{
    USHORT control = GET_CURRENT_CONFIGURATION;
    USHORT retCode;
    FPUCHAR buffer;
    USHORT i;
    UCHAR code;
#if 0
    BlPrint("DisablePnPBiosDevnode: found it\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    
    buffer = (FPUCHAR)deviceNode;
    
    for (i = 0; i < deviceNode->Size; i++) {
        BlPrint("%x ", *buffer++);
        if ( ((i+1)%16) == 0) {
            BlPrint("\n");
        }
    }
    BlPrint("\n");
#endif    

    //
    // Zero out allocated resources
    //        
    buffer = (FPUCHAR)(deviceNode+1);

    if (deviceNode->Size <= sizeof(PNP_BIOS_DEVICE_NODE)) {
        return;
    }
    
    for (i = 0; i < (deviceNode->Size - sizeof(PNP_BIOS_DEVICE_NODE)); i++) {
     
        code = *buffer;
#define PNP_BIOS_END_TAG 0x79
        if (code == PNP_BIOS_END_TAG) {
            //
            // found END TAG
            // write checksum
            //
            *(++buffer) = (UCHAR) (0 - PNP_BIOS_END_TAG);
            break;
        }
        *buffer++ = 0;
    }                
    
    
#if 0
    buffer = (FPUCHAR)deviceNode;
    
    for (i = 0; i < deviceNode->Size; i++) {
        BlPrint("%x ", *buffer++);
        if ( ((i+1)%16) == 0) {
            BlPrint("\n");
        }
    }
    BlPrint("\n");
    
    while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif    

    retCode = biosEntry(PNP_BIOS_SET_DEVICE_NODE,
                        node,
                        deviceNode,
                        control,
                        header->RealModeDataBaseAddress
                        );

#if DBG
    if (retCode != 0) {
        BlPrint("HwDisablePnPBiosDevnode: PnP Bios func 2 returns failure = %x.\n", retCode);
    }
#endif
}
#endif

//
// Global Variable within NTDETECT
//   - structure definition in dockinfo.h
//   - extern declaration in hwdetect.h
//   - used in hwpbios.c and hwdetect.c
//


BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT PnPBiosLength,
    OUT PUSHORT SMBIOSLength,
    IN OUT FPDOCKING_STATION_INFO DockInfo
    )
/*++

Routine Description:

    This routine checks if PNP BIOS is present in the machine.  If yes, it
    also create a registry descriptor to collect the BIOS data.

Arguments:

    Configuration - Supplies a variable to receive the PNP BIOS data.

    PnPBiosLength - Supplies a variable to receive the size of the PnP Bios 
                    data (Does not include HEADER)
                
    SMBIOSBiosLength - Supplies a variable to receive the size of the SMBIOS
                       data (Does not include HEADER). Total size of buffer
                       returned is in *Configuration is (*PnPBiosLength + 
                       *SMBIOSLength + 2 * DATA_HEADER_SIZE)
                   
    DockInfo - 

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/
{
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPPNP_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    UCHAR currentNode;
    USHORT i, totalSize = 0, nodeSize, numberNodes, retCode;
    ENTRY_POINT biosEntry;
    FPPNP_BIOS_DEVICE_NODE deviceNode;
    USHORT control = GET_CURRENT_CONFIGURATION;
    USHORT sMBIOSBufferSize;
    FPUCHAR sMBIOSBuffer;

    //
    // Perform PNP BIOS installation Check
    //

    MAKE_FP(current, PNP_BIOS_START);
    romAddr = PNP_BIOS_START;
    romEnd  = PNP_BIOS_END;

    while (romAddr < romEnd) {
        header = (FPPNP_BIOS_INSTALLATION_CHECK)current;
        if (header->Signature[0] == '$' && header->Signature[1] == 'P' &&
            header->Signature[2] == 'n' && header->Signature[3] == 'P' &&
            header->Length >= sizeof(PNP_BIOS_INSTALLATION_CHECK)) {
#if DBG
            BlPrint("GetPnpBiosData: find Pnp installation\n");
#endif
            sum = 0;
            for (i = 0; i < header->Length; i++) {
                sum += current[i];
            }
            if (sum == 0) {
                break;
            }
#if DBG
            BlPrint("GetPnpBiosData: Checksum fails\n");
#endif
        }
        romAddr += PNP_BIOS_HEADER_INCREMENT;
        MAKE_FP(current, romAddr);
    }
    if (romAddr >= romEnd) {
        return FALSE;
    }

#if DBG
    BlPrint("PnP installation check at %lx\n", romAddr);
#endif


    //
    // Determine how much space we will need and allocate heap space
    //

    totalSize += sizeof(PNP_BIOS_INSTALLATION_CHECK);
    biosEntry = *(ENTRY_POINT far *)&header->RealModeEntryOffset;

    //
    // Determine size needed for SMBIOS data 
    sMBIOSBufferSize = HwGetSMBIOSInfo(biosEntry,
                                           header->RealModeDataBaseAddress,
                                           0,
                                           NULL);
                                      
    if (sMBIOSBufferSize > MAXSMBIOS20SIZE)
    {
#if DBG
        BlPrint("GetPnpBiosData: SMBIOS data structures are too large 0x%x bytes\n",
                 sMBIOSBufferSize);
        while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
        sMBIOSBufferSize = 0;
    }
                   
    retCode = biosEntry(PNP_BIOS_GET_NUMBER_DEVICE_NODES,
                        (FPUSHORT)&numberNodes,
                        (FPUSHORT)&nodeSize,
                        header->RealModeDataBaseAddress
                        );
    if (retCode != 0) {
#if DBG
        BlPrint("GetPnpBiosData: PnP Bios GetNumberNodes func returns failure %x.\n", retCode);
#endif
        return FALSE;
    }

#if DBG
    BlPrint("GetPnpBiosData: Pnp Bios GetNumberNodes returns %x nodes\n", numberNodes);
#endif
    deviceNode = (FPPNP_BIOS_DEVICE_NODE) HwAllocateHeap(nodeSize, FALSE);
    if (!deviceNode) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    while (node != 0xFF) {
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios GetDeviceNode func returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)nodeSize);
            return FALSE;
        }
#if DBG
        BlPrint("GetPnpBiosData: PnpBios GetDeviceNode returns nodesize %x for node %x\n", deviceNode->Size, node);
#endif
        totalSize += deviceNode->Size;
    }

#if DBG
    BlPrint("GetPnpBiosData: PnpBios total size of nodes %x\n", totalSize);
#endif

    HwFreeHeap((ULONG)nodeSize);       // Free temporary buffer


    *PnPBiosLength = totalSize;
    *SMBIOSLength = sMBIOSBufferSize;
    
    
    //
    // Allocate enough room for 2 HWPARTIAL_RESOURCE_DESCRIPTORS (one for 
    // PnP bios and one for SMBios) plus room to keep the data.
    totalSize +=  sMBIOSBufferSize +  DATA_HEADER_SIZE + sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);            
    current = (FPUCHAR) HwAllocateHeap(totalSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect PnP Bios installation check data and device node data.
    //

    _fmemcpy (current + DATA_HEADER_SIZE,
              (FPUCHAR)header,
              sizeof(PNP_BIOS_INSTALLATION_CHECK)
              );
    deviceNode = (FPPNP_BIOS_DEVICE_NODE)(current + DATA_HEADER_SIZE +
                                          sizeof(PNP_BIOS_INSTALLATION_CHECK));
    node = 0;
    while (node != 0xFF) {
        currentNode = node;
    
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios func 1 returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)totalSize);
            return FALSE;
        }

        //
        // Record the existance of certain devices for the benefit of other
        // routines in ntdetect. For example, the pccard irq detection code
        // uses the PIC and an 8237... this insures that we actually have
        // those devices.
        //
        
        if (deviceNode->ProductId == 0xd041) {  // PNP0000
            SystemHas8259 = TRUE;
        } else if (deviceNode->ProductId == 0x1d041) {  // PNP0100
            SystemHas8253 = TRUE;
        }
        
        deviceNode = (FPPNP_BIOS_DEVICE_NODE)((FPUCHAR)deviceNode + deviceNode->Size);
    }

    //
    // Collect SMBIOS Data, skipping over PartialDescriptor which is filled in
    // by the caller of this routine
    if (sMBIOSBufferSize != 0)
    {
        
        sMBIOSBuffer = (FPUCHAR)deviceNode;
        sMBIOSBuffer += sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);
        retCode = HwGetSMBIOSInfo(biosEntry,
                                  header->RealModeDataBaseAddress,
                                  sMBIOSBufferSize,
                                  sMBIOSBuffer);
#if DBG
        BlPrint("SMBIOS asked for 0x%x bytes and filled 0x%x bytes into %lx\n",
            sMBIOSBufferSize, retCode, sMBIOSBuffer);
#endif           
    }
    
    
    *Configuration = current;

    //
    // call PnP BIOS to get docking station information
    //

    DockInfo->ReturnCode = biosEntry(PNP_BIOS_GET_DOCK_INFORMATION,
                                    (FPUCHAR) DockInfo,
                                    header->RealModeDataBaseAddress
                                    );

#if DBG
    BlPrint("\npress any key to continue...\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    clrscrn();
    BlPrint("*** DockInfo - BEGIN ***\n\n");

    BlPrint("ReturnCode= 0x%x (Other fields undefined if ReturnCode != 0)\n",
            DockInfo->ReturnCode
            );
    BlPrint("  0x0000 = SUCCESS (docked)\n");
    BlPrint("  0x0082 = FUNCTION_NOT_SUPPORTED\n");
    BlPrint("  0x0087 = SYSTEM_NOT_DOCKED\n");
    BlPrint("  0x0089 = UNABLE_TO_DETERMINE_DOCK_CAPABILITIES\n\n");

    BlPrint("DockID = 0x%lx\n", DockInfo->DockID);
    BlPrint("  0xFFFFFFFF if product has no identifier (DockID)\n\n");

    BlPrint("SerialNumber = 0x%lx\n", DockInfo->SerialNumber);
    BlPrint("  0 if docking station has no SerialNumber\n\n");

    BlPrint("Capabilities = 0x%x\n" , DockInfo->Capabilities);
    BlPrint("  Bits 15:3 - reserved (0)\n");
    BlPrint("  Bits  2:1 - docking: 00=cold, 01=warm, 10=hot, 11=reserved\n");
    BlPrint("  Bit     0 - docking/undocking: 0=surprise style, 1=vcr style\n\n");

    BlPrint("*** DockInfo - END ***\n\n");

    BlPrint("press any key to continue...\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    clrscrn();
#endif // DBG


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hweisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include hweisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; HwGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

HgesSlotInformation     equ     [bp + 4]
HgesSlot                equ     [bp + 6]

        public  _HwGetEisaSlotInformation
_HwGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, HgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, HgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_HwGetEisaSlotInformation       endp

;++
;
; UCHAR
; HwGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

HgefFunctionInformation equ     [bp + 4]
HgefSlot                equ     [bp + 6]
HgefFunction            equ     [bp + 8]

        public  _HwGetEisaFunctionInformation
_HwGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, HgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, HgefFunction
        mov     si, HgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_HwGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; HwIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _HwIsEisaSystem
_HwIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short hies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short hies10

hies00:
        mov     ax, 0
hies10:
        pop     bx
        pop     es
        ret
_HwIsEisaSystem endp

;++
;
; VOID
; Int15 (
;   PULONG  eax,
;   PULONG  ebx,
;   PULONG  ecx,
;   PULONG  edx,
;   PULONG  CyFlag
;   )
;
; Routine Description:
;
;   Calls Int15 with the requesed registers and returns the result
;
;--

        public _Int15
_Int15 proc
        push    bp
        mov     bp, sp
        push    esi
        push    edi
        push    ebx

        mov     si, [bp+4]          ; pointer to eax
        mov     eax, [si]

        mov     si, [bp+6]          ; pointer to ebx
        mov     ebx, [si]

        mov     si, [bp+8]          ; pointer to ecx
        mov     ecx, [si]

        mov     si, [bp+10]         ; pointer to edx
        mov     edx, [si]

        int     15h                 ; do it

        mov     si, [bp+4]          ; pointer to eax
        mov     [si], eax

        mov     si, [bp+6]          ; pointer to ebx
        mov     [si], ebx

        mov     si, [bp+8]          ; pointer to ecx
        mov     [si], ecx

        mov     si, [bp+10]         ; pointer to edx
        mov     [si], edx

        sbb     eax, eax
        mov     si, [bp+12]         ; pointer CyFlag
        mov     [si], eax

        pop     ebx
        pop     edi
        pop     esi
        pop     bp
        ret
_Int15 endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

;++
;
; BOOLEAN
; Int15E980 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets Geyserville information by calling INT 15 E980h
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E980
_Int15E980 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     eax, 0E980h
        mov     edx, 47534943h          ; (edx) = signature 'GSIC'

        INT     15h

        sbb     eax, eax                ; eax = -1 if carry, else 0
        not     eax

        ;
        ; Pass back the information that the caller wanted
        ;
        
        mov     [bp].CommandPortAddress, bx
        shr     ebx, 16
        mov     [bp].CommandDataValue, bl
        mov     [bp].EventPortAddress, cx
        shr     ecx, 16
        mov     [bp].EventPortBitmask, cl
        mov     [bp].MaxLevelAc, dh
        mov     [bp].MaxLevelDc, dl
        shr     edx, 16
        mov     [bp].PollInterval, dx

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E980 endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwpci.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;     hwpci.inc
;
; Abstract:
;
; Author:
;
; Revision History:
;
;--

;
;  PCI_INTERFACE_INT interrupt is the PCI BIOS entry point
;  PCI_BIOS_PRESENT AX function code for PCI BIOS entry point
;

PCI_INTERFACE_INT           EQU  01AH
PCI_BIOS_PRESENT            EQU  0B101h


; Down level bios checl

PCI10_BIOS_PRESENT            EQU  0B001h

;
;  Structure for PCI System Data - it is passed to the system
;  through the register to inform it what type of PCI support,
;  if any, is present.
;


PCI_SYSTEM_DATA     struc

    MajorRevision       db      0
    MinorRevision       db      0
    NoBuses             db      0
    HwMechanism         db      0

PCI_SYSTEM_DATA     ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwmisca.asm ===
title  "Misc. Support Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    misca.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Shie-Lin Tzong (shielint) Dec-23-1991
;
; Environment:
;
;    x86 real mode.
;
; Revision History:
;
;--

.386p

SIZE_OF_INT15_C0_BUFFER equ     10


_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING

;++
;
; I/O port space read and write functions.
;
;--


;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_UCHAR
_READ_PORT_UCHAR proc

        push    bp
        mov     bp, sp
        mov     dx, [bp+4]
        in      al,dx
        pop     bp
        ret

_READ_PORT_UCHAR endp



;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_USHORT
_READ_PORT_USHORT proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]              ; (dx) = Port
        in      ax,dx
        pop     bp
        ret

_READ_PORT_USHORT endp


;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_ULONG
_READ_PORT_ULONG proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]              ; (dx) = Port
        in      eax,dx				   ; eax = Value
        mov     edx, eax
        shr     edx, 16
        pop     bp
        ret

_READ_PORT_ULONG endp



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value
;
;--
        public  _WRITE_PORT_UCHAR
_WRITE_PORT_UCHAR proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        mov     al,[bp+6]               ; (al) = Value
        out     dx,al
        pop     bp
        ret

_WRITE_PORT_UCHAR endp

;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value
;
;--
        public  _WRITE_PORT_USHORT
_WRITE_PORT_USHORT proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        mov     ax,[bp+6]               ; (ax) = Value
        out     dx,ax
        pop     bp
        ret

_WRITE_PORT_USHORT endp


;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PUSHORT Port,
;       ULONG  Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value (LSW)
;       (sp+6) = Value (MSW)
;
;--
        public  _WRITE_PORT_ULONG
_WRITE_PORT_ULONG proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        xor		eax, eax
        mov     ax,[bp+8]               ; (ax) = Value MSW
        shl     eax, 16
        mov     ax,[bp+6]               ; (ax) = Value LSW
        out     dx,eax
        pop     bp
        ret

_WRITE_PORT_ULONG endp



;++
;
;   VOID
;   GetBiosSystemEnvironment(
;       PUCHAR Buffer
;       )
;
;   Description:
;
;       This function performs int 15h C0H function to get System
;       Environment supplied by BIOS ROM.
;
;   Arguments:
;
;       Buffer - Supplies a pointer to a buffer to receive the BIOS
;                System Environment. Caller must ensure that the buffer
;                is big enough.
;
;--

GbseBuffer      equ     [bp + 4]

        public _GetBiosSystemEnvironment
_GetBiosSystemEnvironment       proc    near

        push    bp
        mov     bp, sp

        push    bx
        push    es
        push    ds
        push    si
        push    di

        mov     ah, 0c0h
        int     15h
        mov     ax, es          ; exchange es and ds
        mov     cx, ds
        mov     ds, ax
        mov     es, cx
        mov     si, bx          ; [ds:si] -> ROM buffer (source)
        mov     di, GbseBuffer  ; [es:di] -> caller's buffer (destination)
        mov     cx, SIZE_OF_INT15_C0_BUFFER
        rep     movsb

        pop     di
        pop     si
        pop     ds
        pop     es
        pop     bx
        mov     sp, bp
        pop     bp
        ret

_GetBiosSystemEnvironment       endp

;++
;
;   BOOLEAN
;   HwRomCompare(
;       ULONG Source,
;       ULONG Destination
;       ULONG Size
;       )
;
;   Description:
;
;       This function performs ROM comparison between the Source ROM
;       block and Destination ROM block.
;
;   Arguments:
;
;       Source - Supplies the physical address of source ROM block.
;
;       Destination - Supplies the physical address of destination ROM block.
;
;       Size - The size of the comparison.  Must be <= 64k.
;
;   Return:
;
;       0 - if the contents of Source and destination are the same.
;
;       != 0 if the contents are different.
;--

HfSource        equ     [bp + 4]
HfDestination   equ     [bp + 8]
HfSize          equ     [bp + 12]

        public _HwRomCompare
_HwRomCompare   proc    near

        push    bp
        mov     bp, sp
        push    esi
        push    edi
        push    ds
        push    es
        cld

        mov     ecx, HfSize
        cmp     ecx, 10000h
        ja      HfNotTheSame

        mov     eax, HfSource
        add     eax, ecx
        cmp     eax, 100000h
        ja      short HfNotTheSame

        mov     edx, HfDestination
        add     edx, ecx
        cmp     edx, 100000h
        ja      short HfNotTheSame

        mov     eax, HfSource
        shr     eax, 4
        mov     es, ax
        mov     edi, HfSource
        and     edi, 0fh

        mov     eax, HfDestination
        shr     eax, 4
        mov     ds, ax
        mov     esi, HfDestination
        and     esi, 0fh

        shr     ecx, 2
        repe    cmpsd

        jnz     short HfNotTheSame
        mov     ax, 0
        jmp     short HfExit

HfNotTheSame:
        mov     ax, 1
HfExit:
        pop     es
        pop     ds
        pop     edi
        pop     esi
        pop     bp
        ret

_HwRomCompare   endp

;++
;
;   VOID
;   HwGetKey(
;       VOID
;       )
;
;   Description:
;
;       This function waits for a key to be pressed.
;
;   Arguments:
;       None.
;
;--

        public _HwGetKey
_HwGetkey proc

        mov     ax,0100h
        int     16h

        mov     ax,0
        jz      short Hgk99

;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;

        int     16h

Hgk99:
        ret
_HwGetKey endp

;++
;
;   VOID
;   HwPushKey(
;       USHORT Key
;       )
;
;   Description:
;
;       This function pushes a character and scan code to keyboard
;       type-ahead buffer.
;
;   Arguments:
;
;       Key - Supplies the key to be push back.
;             bit 0 - 7 : Character
;             bit 8 - 15: Scan Code
;
;--

        public _HwPushKey
_HwPushkey      proc

        mov     cx, [esp + 2]           ; character and scan code
        mov     ah, 05h
        int     16h

;
; I don't care if the function call is successful.
;

        ret
_HwPushKey      endp
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hweisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1992

Environment:

    16-bit real mode.


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

typedef EISA_PORT_CONFIGURATION far *FPEISA_PORT_CONFIGURATION;

extern CM_EISA_FUNCTION_INFORMATION FunctionInformation;


VOID
GetEisaConfigurationData (
    FPVOID Buffer,
    FPULONG Size
    )

/*++

Routine Description:

    This routine collects all the eisa slot information, function
    information and stores it in the caller supplied Buffer and
    returns the size of the data.

Arguments:


    Buffer - A pointer to a PVOID to recieve the address of configuration
        data.

    Size - a pointer to a ULONG to receive the size of the configuration
        data.

Return Value:

    None.

--*/

{
    UCHAR Slot=0;
    UCHAR Function=0, SlotFunctions = 0, ReturnCode;
    EISA_SLOT_INFORMATION  SlotInformation;
    FPUCHAR ConfigurationData, CurrentData;
    FPEISA_SLOT_INFORMATION FarSlotInformation;
    ULONG TotalSize = DATA_HEADER_SIZE;
    BOOLEAN Overflowed = FALSE;

    HwGetEisaSlotInformation(&SlotInformation, Slot);

    TotalSize += sizeof(EISA_SLOT_INFORMATION);
    ConfigurationData = (FPVOID)HwAllocateHeap(TotalSize, FALSE);
    CurrentData = ConfigurationData + DATA_HEADER_SIZE;

    _fmemcpy(CurrentData, (FPVOID)&SlotInformation, sizeof(EISA_SLOT_INFORMATION));
    FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;

    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // Ensure that the slot is not empty and collect all the function
        // information for the slot.
        //

        if (SlotInformation.ReturnCode != EISA_EMPTY_SLOT) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = HwGetEisaFunctionInformation(
                                         &FunctionInformation, Slot, Function);
                Function++;

                //
                // if function call succeeds and the function contains usefull
                // information or this is the last function for the slot and
                // there is no function information collected for the slot, we
                // will save this function information to our heap.
                //

                if (!ReturnCode) {
                    if (((FunctionInformation.FunctionFlags & 0x7f) != 0) ||
                        (SlotInformation.NumberFunctions == Function &&
                         SlotFunctions == 0)) {
                        CurrentData = (FPVOID)HwAllocateHeap(
                                      sizeof(EISA_FUNCTION_INFORMATION), FALSE);
                        if (CurrentData == NULL) {
                            Overflowed = TRUE;
                            break;
                        }
                        SlotFunctions++;
                        TotalSize += sizeof(EISA_FUNCTION_INFORMATION);
                        _fmemcpy(CurrentData,
                                (FPVOID)&FunctionInformation,
                                sizeof(EISA_FUNCTION_INFORMATION));
                    }
                }
            }
            FarSlotInformation->NumberFunctions = SlotFunctions;
        }
        if (Overflowed) {
            break;
        }
        Slot++;
        Function = 0;
        HwGetEisaSlotInformation(&SlotInformation, Slot);
        CurrentData = (FPVOID)HwAllocateHeap(
                                  sizeof(EISA_SLOT_INFORMATION), FALSE);
        if (CurrentData == NULL) {
            Overflowed = TRUE;
            break;
        }
        TotalSize += sizeof(EISA_SLOT_INFORMATION);
        _fmemcpy(CurrentData,
                (FPVOID)&SlotInformation,
                sizeof(EISA_SLOT_INFORMATION));
        FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;
        SlotFunctions = 0;
    }

    //
    // Free the last EISA_SLOT_INFORMATION space which contains the slot
    // information for IVALID SLOT
    //

    if (Overflowed != TRUE) {
        HwFreeHeap(sizeof(EISA_SLOT_INFORMATION));
        TotalSize -= sizeof(EISA_SLOT_INFORMATION);
    }

    //
    // Check if we got any EISA information.  If nothing, we release
    // the space for data header and return.
    //

    if (TotalSize == DATA_HEADER_SIZE) {
        HwFreeHeap(DATA_HEADER_SIZE);
        *(FPULONG)Buffer = (ULONG)0;
        *Size = (ULONG)0;
    } else {
        HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                                  0,
                                  0,
                                  0,
                                  TotalSize - DATA_HEADER_SIZE
                                  );
        *(FPULONG)Buffer = (ULONG)ConfigurationData;
        *Size = TotalSize;
    }
}

BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    )

/*++

Routine Description:

    This routine scans EISA configuration data to match the I/O port address.
    The IRQ information is returned from the matched EISA function information.

Arguments:

    Port - The I/O port address to scan for.

    Irq - Supplies a pointer to a variable to receive the irq information.

    TriggerMethod - Supplies a pointer to a variable to receive the
                    EISA interrupt trigger method.

Return Value:

    TRUE - if the Irq information is found.  Otherwise a value of FALSE is
    returned.

--*/

{
    UCHAR Function, i, j;
    FPEISA_SLOT_INFORMATION SlotInformation;
    FPEISA_FUNCTION_INFORMATION Buffer;
    UCHAR FunctionFlags;
    ULONG SizeToScan = 0L;
    EISA_PORT_CONFIGURATION PortConfig;
    EISA_IRQ_DESCRIPTOR IrqConfig;
    SlotInformation = (FPEISA_SLOT_INFORMATION)HwEisaConfigurationData;

    //
    // Scan through all the EISA configuration data.
    //

    while (SizeToScan < HwEisaConfigurationSize) {
        if (SlotInformation->ReturnCode != EISA_EMPTY_SLOT) {

            //
            // Make sure this slot contains PORT_RANGE and IRQ information.
            //

            if ((SlotInformation->FunctionInformation & EISA_HAS_PORT_RANGE) &&
                (SlotInformation->FunctionInformation & EISA_HAS_IRQ_ENTRY)) {

                Buffer = (FPEISA_FUNCTION_INFORMATION)(SlotInformation + 1);

                //
                // For each function of the slot, if it contains both the IRQ
                // and PORT information, we then check for its PORT address.
                //

                for (Function = 0; Function < SlotInformation->NumberFunctions; Function++) {
                    FunctionFlags = Buffer->FunctionFlags;
                    if ((FunctionFlags & EISA_HAS_IRQ_ENTRY) &&
                        (FunctionFlags & EISA_HAS_PORT_RANGE)) {
                        for (i = 0; i < 20 ; i++ ) {
                            PortConfig = Buffer->EisaPort[i];
                            if ((Port >= PortConfig.PortAddress) &&
                                (Port <= (PortConfig.PortAddress +
                                 PortConfig.Configuration.NumberPorts))) {

                                //
                                // If there is only one IRQ entry, that's the
                                // one we want.  (This is the normal case and
                                // correct usage of EISA function data.)  Otherwise,
                                // we try to get the irq from the same index
                                // number as port entry.  (This is ALR's incorrect
                                // way of packing functions into one function
                                // data.)
                                //

                                IrqConfig = Buffer->EisaIrq[0].ConfigurationByte;
                                if (IrqConfig.MoreEntries == 0) {
                                    *Irq = IrqConfig.Interrupt;
                                    *TriggerMethod = IrqConfig.LevelTriggered;
                                    return(TRUE);
                                } else if (i >= 7) {
                                    return(FALSE);
                                }

                                for (j = 0; j <= i; j++) {
                                    if (j == i) {
                                        *Irq = IrqConfig.Interrupt;
                                        *TriggerMethod = IrqConfig.LevelTriggered;
                                        return(TRUE);
                                    }
                                    if (!IrqConfig.MoreEntries) {
                                        return(FALSE);
                                    }
                                    IrqConfig =
                                        Buffer->EisaIrq[j+1].ConfigurationByte;
                                }
                                return(FALSE);
                            }
                            if (!PortConfig.Configuration.MoreEntries) {
                                break;
                            }
                        }
                    }
                    Buffer++;
                }
            }

            //
            // Move on to next slot
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION) +
                          sizeof(EISA_FUNCTION_INFORMATION) *
                          SlotInformation->NumberFunctions;
            SlotInformation = (FPEISA_SLOT_INFORMATION)(HwEisaConfigurationData +
                                                        SizeToScan);
        } else {

            //
            // This is a empty slot.  We simply skip it.
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION);
            SlotInformation++;
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwpcia.asm ===
title  "PCI bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    hwpcia.asm
;
; Abstract:
;
;   Calls the PCI rom function to determine what type of PCI
;   support is prsent, if any.
;
;   Base code provided by Intel
;
; Author:
;
;--


.386p
        .xlist
include hwpci.inc
        .list

if DBG
        extrn   _BlPrint:PROC
endif

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

if DBG
cr  equ 11

PciBIOSSig          db  'PCI: Scanning for "PCI "', cr, 0
PciBIOSSigNotFound  db  'PCI: BIOS "PCI " not found', cr, 0


PciInt              db  'PCI: Calling PCI_BIOS_PRESENT', cr, 0
PciIntFailed        db  'PCI: PCI_BIOS_PRESENT returned carry', cr, 0
PciIntAhFailed      db  'PCI: PCI_BIOS_PRESENT returned bad AH value', cr, 0
PciIDFailed         db  'PCI: PCI_BIOS_PRESENT invalid PCI id', cr, 0
PciInt10IdFailed    db  'PCI: PCI10_BIOS_PRESENT invalid PCI id', cr, 0

PciFound            db  'PCI BUS FOUND', cr, 0
endif

_DATA   ends


_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; BOOLEAN
; HwGetPciSystemData (
;    PPCI_SYSTEM_DATA PciSystemData
;    )
;
; Routine Description:
;
;    This function retrieves the PCI System Data
;
; Arguments:
;
;    PciSystemData - Supplies a pointer to the structure which will
;                      receive the PCI System Data.
;
; Return Value:
;
;    True - PCI System Detected and System Data valid
;    False - PCI System Not Detected
;
;--

SystemInfoPointer     equ     [bp + 4]
BiosDateFound         equ     [bp + 6]

        public  _HwGetPciSystemData
_HwGetPciSystemData       proc
        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx
;
; Set for no PCI buses present
;

        mov     bx, SystemInfoPointer
        mov     byte ptr [bx].NoBuses, 0

;
; Is the BIOS date >= 11/01/92?   If so, make the int-1a call
;
        push    ds
        cmp     byte ptr [BiosDateFound], 0
        jnz     gpci00

;
; A valid BIOS date was not found, check for "PCI " in bios code.
;

if DBG
        push    offset PciBIOSSig
        call    _BlPrint
        add     sp, 2
endif
        mov     bx, 0f000h
        mov     ds, bx
        mov     bx, 0fffch

spci05: cmp     dword ptr ds:[bx], ' ICP'   ; 'PCI ' found at this addr?
        je      short gpci00                ; found

        dec     bx                          ; next location
        jnz     short spci05                ; loop
        jmp     spci_notfound               ; wrapped, all done - not found

gpci00:
        pop     ds

if DBG
        push    offset PciInt
        call    _BlPrint
        add     sp, 2
endif
;
; Check for a PCI system.  Issue the PCI Present request.
;

        mov     ax, PCI_BIOS_PRESENT        ; Real Mode Presence Request
        int     PCI_INTERFACE_INT           ; Just Do It!

        jc      gpci10                      ; Carry Set => No PCI

        cmp     ah, 0                       ; If PCI Present AH == 0
        jne     gpci12                      ; AH != 0 => No PCI

        cmp     edx, " ICP"                 ; "PCI" Backwards (with a trailing space)
        jne     gpci14                      ; PCI Signature in EDX => PCI Exists

;
; Found PCI BIOS Version > 1.0
;
; The only thing left to do is squirrel the data away for the caller
;

        mov     dx, bx                              ; Save revision level
        mov     bx, SystemInfoPointer               ; Get caller's Pointer

        mov     byte ptr [bx].MajorRevision, dh
        mov     byte ptr [bx].MinorRevision, dl
        inc     cl                                  ; NoBuses = LastBus+1

if 0
;
; Some PIC BIOS returns very large number of NoBuses.  As a work-
; around we mask the value to 16, unless the BIOS also return CH as
; neg cl then we believe it.
;

        cmp     cl, 16
        jbe     short @f

        neg     ch
        inc     ch
        cmp     cl, ch
        je      short @f

        mov     cl, 16
@@:
endif


        mov     byte ptr [bx].NoBuses, cl
        mov     byte ptr [bx].HwMechanism, al
        jmp     Done                                ; We're done

if DBG
gpci10: mov     ax, offset PciIntFailed
        jmp     short gpci_oldbios

gpci12: mov     ax, offset PciIntAhFailed
        jmp     short gpci_oldbios

gpci14: mov     ax, offset PciIDFailed
gpci_oldbios:
        push    ax
        call    _BlPrint
        add     sp, 2

else

gpci10:
gpci12:
gpci14:

endif


    ;
    ; Look for BIOS Version 1.0,  This has a different function #
    ;

        mov     ax, PCI10_BIOS_PRESENT      ; Real Mode Presence Request
        int     PCI_INTERFACE_INT           ; Just Do It!

    ; Version 1.0 has "PCI " in dx and cx, the Version number in ax, and the
    ; carry flag cleared.  These are all the indications available.
    ;

        cmp     dx, "CP"                    ; "PC" Backwards
        jne     gpci50                      ; PCI Signature not in DX & CX => No PCI

        cmp     cx, " I"                    ; "I " Backwards
        jne     gpci50                      ; PCI Signature not in EDX => No PCI

;
; Found PCI BIOS Version 1.0
;
; The only thing left to do is squirrel the data away for the caller
;

        mov     bx, SystemInfoPointer       ; Get caller's Pointer

        mov     byte ptr [bx].MajorRevision, ah
        mov     byte ptr [bx].MinorRevision, al

    ;
    ;  The Version 1.0 BIOS is only on early HW that had couldn't support
    ;  Multi Function devices or multiple bus's.  So without reading any
    ;  device data, mark it as such.
    ;

        mov     byte ptr [bx].HwMechanism, 2
        mov     byte ptr [bx].NoBuses, 1
        jmp     Done


spci_notfound:
        pop     ds                      ; restore ds
if DBG
        push    offset PciBIOSSigNotFound
        call    _BlPrint
        add     sp, 2
endif
        jmp     gpci_exit


if DBG
gpci50: push    offset PciInt10IdFailed
        jmp     Done10

Done:   push    offset PciFound
Done10: call    _BlPrint
        add     sp, 2

else

; non-debug no prints
gpci50:
Done:

endif

gpci_exit:
        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_HwGetPciSystemData       endp

RouteBuffer     equ     [bp + 4]
ExclusiveIRQs   equ     [bp + 8]

        public  _HwGetPciIrqRoutingOptions
_HwGetPciIrqRoutingOptions       proc
                push            bp
                mov             bp, sp                                  ; Create 'C' stack frame.

                push            ebx
                push            edi
                push            esi                                             ; Save registers used.

                push            es                                              
                push            ds

                xor             edi, edi
                
                les             di, RouteBuffer
                mov             bx, 0f000h
                mov             ds, bx
                xor             ebx, ebx
                mov             ax, 0B10Eh                

                int             PCI_INTERFACE_INT

                pop             ds
                pop             es                                              

                mov             di, ExclusiveIRQs       
                mov             [di], bx                                                

                mov             al, ah

                pop             esi                                             ; Restore registers.
                pop             edi
                pop             ebx
                
                pop             bp
                ret

_HwGetPciIrqRoutingOptions endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwvbios.h ===
//
// Defines for machine models
//

#define          PS2_AT     0xF819      // PS/2 non-micro channel
#define          PS2_L40    0xF823      // PS/2 non-micro channel
#define          PS1_386    0xF830      // 386 non-microchannel     // 6.13

#define        PS2_PORT     0x0001      // PS/2 specific port
#define        ISA_PORT     0x0002      // AT specific port
#define     HYBRID_PORT     0x0004      // PS/2 non-micro channel specific port

//
//  Bios int 15h C0h buffer definition
//

struct BIOS_INT15_C0_BUFFER {
    USHORT Size;
    USHORT Model;
    UCHAR BiosRevision;
    UCHAR ConfigurationFlags;
    UCHAR Reserved[4];
} BiosSystemEnvironment;

typedef struct _TEMPORARY_ROM_BLOCK {
    ROM_BLOCK RomBlock;
    struct _TEMPORARY_ROM_BLOCK far *Next;
} TEMPORARY_ROM_BLOCK, far * FPTEMPORARY_ROM_BLOCK;

#define POS_MAX_SLOT 8

#define ROMBIOS_START   0xF0000
#define ROMBIOS_LEN     0x10000

#define PS2BIOS_START   0xE0000
#define PS2BIOS_LEN     0x20000

#define EXTROM_START    0xC0000         // where and how far to
#define EXTROM_LEN      0x40000         // search for external adapter ROMs

#define EBIOSDATA_START 0x9FC00
#define EBIOSDATA_LEN   0x00400

#define NUMBER_VECTORS  0x80
#define VGA_PARAMETER_POINTER   0x4A8
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// ROM format
//

#define ROM_HEADER_SIGNATURE    0xAA55
#define ROM_HEADER_INCREMENT    0x800
#define BLOCKSIZE       512

typedef struct _ROM_HEADER {
    USHORT Signature;                   // should be ROMHDR_SIGNATURE
    UCHAR NumberBlocks;                 // # of ROM blocks
    UCHAR Filler[ROM_HEADER_INCREMENT - 3];
} ROM_HEADER, far *FPROM_HEADER;

//
// External References
//

extern
BOOLEAN
HwRomCompare (
    ULONG Source,
    ULONG Destination,
    ULONG Size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwvbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This module goes through ROM area and tries to pick up all the ROM
    blocks.

Author:

    Shie-Lin Tzong (shielint) 21-Jan-92


Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include "hwvbios.h"

FPTEMPORARY_ROM_BLOCK BlockHead;
FPTEMPORARY_ROM_BLOCK BlockPointer;

BOOLEAN
AddRomBlock (
    ULONG RomAddress,
    ULONG RomSize
    )

/*++

Routine Description:

    This routine adds a ROM/RAM block to our ROM list.

Arguments:

    RomAddress - the starting address of the ROM/RAM block to be added.

    RomSize - the size of the ROM/RAM block (in byte).

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/

{
    LONG AddSize;
    ULONG AddAddress;
    FPTEMPORARY_ROM_BLOCK pCurrentBlock, pNextBlock;
    ULONG CurrentBlock, NextBlock, AddBlock;
    ULONG EndAddBlock, EndCurrentBlock, EndNextBlock;
    BOOLEAN  fOverlap=FALSE;

    pCurrentBlock = NULL;
    pNextBlock = NULL;
    AddSize = RomSize;
    AddAddress = RomAddress;
    AddBlock = RomAddress;

    //
    // If there are other blocks, make sure there is no overlap with them
    //

    if (BlockHead) {

        pCurrentBlock = BlockHead;
        pNextBlock = pCurrentBlock->Next;
        CurrentBlock = pCurrentBlock->RomBlock.Address;
        EndCurrentBlock = CurrentBlock + pCurrentBlock->RomBlock.Size;
        EndAddBlock = RomAddress + RomSize;

        while (pCurrentBlock!=NULL) {

            //
            // calculate location of next block (if it's there)
            //

            if(pNextBlock) {
                NextBlock = pNextBlock->RomBlock.Address;
                EndNextBlock = NextBlock + pNextBlock->RomBlock.Size;
            }

            //
            // if overlapping with current block, then stop and
            // resolve overlap
            //

            if((RomAddress < EndCurrentBlock)&& (RomAddress >= CurrentBlock)){
                fOverlap = TRUE;
                break;
            }

            //
            // if add block is lower than the current one,
            // or there is not a next block, then no need to search further
            //

            if((EndAddBlock <= CurrentBlock) || (pNextBlock == NULL)) {
                break;
            }

            //
            // if block is lower than next one, but greater than current
            // one, we have found the right area
            //

            if ((EndAddBlock <= NextBlock) && (AddBlock >= EndCurrentBlock)) {
                break;
            }

            //
            // if conflicting with next block, stop searching and
            // resolve conflict after this loop
            //

            if((EndAddBlock > NextBlock) && (EndAddBlock <= EndNextBlock)) {
                fOverlap = TRUE;
                break;
            }

            pCurrentBlock = pNextBlock;
            pNextBlock = pCurrentBlock->Next;
            CurrentBlock = NextBlock;
            EndCurrentBlock = EndNextBlock;
        }
    }

    //
    // if we have reached this point, there may be a conflict
    // with the current block.
    //

    if(fOverlap) {
        if(AddBlock < EndCurrentBlock) {
            AddAddress = EndCurrentBlock;
            AddSize = EndAddBlock - EndCurrentBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
        if((pNextBlock != NULL) && (EndAddBlock > NextBlock)) {
            AddSize = NextBlock - AddBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
    }

    BlockPointer->RomBlock.Address = AddAddress;
    BlockPointer->RomBlock.Size = AddSize;

    //
    // Put it on the list.
    // if it belongs on top, put it there
    //

    if ((pCurrentBlock == NULL)||
       ((pCurrentBlock == BlockHead) && (CurrentBlock > AddBlock))) {
        BlockPointer->Next = pCurrentBlock;
        BlockHead = BlockPointer;
    } else {

        //
        // else add to middle or bottom depending on NextBlock
        //

        BlockPointer->Next = pNextBlock;
        pCurrentBlock->Next = BlockPointer;
    }
    BlockPointer++;                         // Note that this works because
                                            // we know the offset part of
                                            // the addr is always < 64k.
    return TRUE;
}

BOOLEAN
ScanRomBlocks(
    VOID
    )

/*++

Routine Description:

    This routine scans the ROM IO area and checks for 55AA at every
    512 bytes for valid ROM blocks.


    NOTES:

                -------------
                |           |
                |           |
           ------------------100000
             ^  |           |
             |  |           |
             |  -------------f0000  (ROMBIOS_START)              ---
             |  |           |                                     ^
             |  |           |                                     |
     EXTROM_LEN -------------e0000  (PS2BIOS_START)  ---          |
             |  |           |                         ^    Search |
             |  |           |                  Search |    Range  |
             |  -------------d0000             Range  |    on AT  |
             |  |           |                  on PS/2|           |
             V  |           |                         V           V
           ------------------c0000 (EXTROM_START)    ---         ---

        ON AT:
          Scan through EXTROM_START-effff for ROM Blocks
        ON PS2
          Scan through EXTROM_START-dffff for ROM Blocks

Arguments:


    None.

Return Value:

    None.

--*/

{
    ULONG BlockSize;
    BOOLEAN Success = TRUE;
    FPUCHAR Current;
    ULONG RomAddr, RomEnd;

    //
    // As per the machine type restrict the search range
    //

    MAKE_FP(Current, EXTROM_START);
    RomAddr = EXTROM_START;

    if ((HwBusType == MACHINE_TYPE_MCA) ||
        (BiosSystemEnvironment.Model == PS2_L40) ||
        (BiosSystemEnvironment.Model == PS1_386) ||
        (BiosSystemEnvironment.Model == PS2_AT)) {

        RomEnd = PS2BIOS_START;
    } else {
        RomEnd = ROMBIOS_START;
    }

    while (RomAddr < RomEnd) {

        if (((FPROM_HEADER)Current)->Signature == ROM_HEADER_SIGNATURE) {

            BlockSize = (ULONG)((FPROM_HEADER)Current)->NumberBlocks * BLOCKSIZE;

            if ((RomAddr + BlockSize) > RomEnd) {
                BlockSize = RomEnd - RomAddr;
            }

            //
            // V7 VRAM card does not correctly report its BlockSize.  Since
            // this is a very popular video card, we provide a workaround
            // for it.
            //

            if ((RomAddr == 0xC0000) && (BlockSize < 0x8000)) {
                BlockSize = 0x8000;
            }
            if (BlockSize != 0) {
                if (!AddRomBlock(RomAddr, BlockSize)) {
                    Success = FALSE;
                    break;
                }
                RomAddr += BlockSize;
                RomAddr = ALIGN_UP(RomAddr, ROM_HEADER_INCREMENT);
                MAKE_FP(Current, RomAddr);
                continue;
            }
        }
        RomAddr += ROM_HEADER_INCREMENT;
        MAKE_FP(Current, RomAddr);
    }

    //
    // Last but not least, add the system ROM to the list
    //

    if (Success) {

        RomAddr = ROMBIOS_START;
        BlockSize = ROMBIOS_LEN;
        if ((HwBusType == MACHINE_TYPE_MCA) ||
            (BiosSystemEnvironment.Model == PS2_L40) ||
            (BiosSystemEnvironment.Model == PS1_386) ||
            (BiosSystemEnvironment.Model == PS2_AT)) {
            RomAddr = PS2BIOS_START;
            BlockSize = PS2BIOS_LEN;
        }

        if (!AddRomBlock(RomAddr, BlockSize)) {
            Success = FALSE;
        }
    }

    return Success;
}

FPTEMPORARY_ROM_BLOCK
MatchRomBlock (
    ULONG PhysicalAddr
    )

/*++

Routine Description:

    This routine finds the ROM block which the 'PhysicalAddr' is in.

Arguments:

    PhysicalAddr - the physical address ...

Return Value:

    A pointer to the detected ROM block.

--*/

{
    FPTEMPORARY_ROM_BLOCK CurrentBlock;
    ROM_BLOCK RomBlock;

    CurrentBlock = BlockHead;
    while (CurrentBlock) {
        RomBlock = CurrentBlock->RomBlock;
        if (RomBlock.Address <= PhysicalAddr &&
            RomBlock.Address +  RomBlock.Size > PhysicalAddr) {
            break;
        } else {
            CurrentBlock = CurrentBlock->Next;
        }
    }
    return(CurrentBlock);
}

BOOLEAN
IsSameRomBlock (
    FPTEMPORARY_ROM_BLOCK Source,
    FPTEMPORARY_ROM_BLOCK Destination
    )

/*++

Routine Description:

    This routine checks if the passed in ROM blocks contain the same
    information.  This ususally happens when the two ROM blocks are for
    video ROM and shadowed video ROM.

Arguments:

    Source - the source ROM block.

    Destination - the ROM block to compare with.

Return Value:

    BOOLEAN TRUE if the two ROM blocks are the same else FALSE is returned.

--*/

{

    if (Source == NULL || Destination == NULL) {
        return(FALSE);
    }

    //
    // First make sure their sizes are the same.
    //

    if (Source->RomBlock.Size == Destination->RomBlock.Size) {
        if (!HwRomCompare(Source->RomBlock.Address,
                          Destination->RomBlock.Address,
                          Source->RomBlock.Size)){
            return(TRUE);
        }
    }
    return(FALSE);

}

VOID
CheckVideoRom (
    VOID
    )

/*++

Routine Description:

    This routine checks if the int 10h video handler is in the video
    ROM block detected by us.  If not, the video ROM must have been
    remapped/shadowed to other area (usually 0xE0000.)

    NOTE: In this function, I commented out the code which removes the
          Video ROM block if it has been shadowed.  I found out
          machine POST code does not modify ALL the VIDEO ROM related
          pointers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Vector, Handler, VectorAddr = 0x10 * sizeof(ULONG);
    FPULONG pVectorAddr;
    FPTEMPORARY_ROM_BLOCK RomBlock, VideoRomBlock;
    ULONG Size;

    MAKE_FP(pVectorAddr, VectorAddr);
    Vector = *pVectorAddr;
    Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
    RomBlock = MatchRomBlock(Handler);

    //
    // Check if the int 10h handler falls in one of our ROM blocks.
    //

    if (RomBlock) {
        if (RomBlock->RomBlock.Address >= 0xC0000 &&
            RomBlock->RomBlock.Address < 0xC8000) {

            //
            // if int 10h handler is in the standard video ROM area, we simply
            // return.  Either the video ROM is not shadowed or it
            // is a in-place shadow.
            //

            return;
        } else {

            //
            // The ROM block associated with the int 10h handler is not in
            // standard video bios ROM area.  It must have been mapped to
            // the current location.  We now need to make sure we have the
            // ROM block which contains the 40:a8 VGA parameter.
            //

            VectorAddr = VGA_PARAMETER_POINTER;
            MAKE_FP(pVectorAddr, VectorAddr);
            Vector = *pVectorAddr;
            Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
            VideoRomBlock = MatchRomBlock(Handler);
            if (VideoRomBlock == NULL) {

                //
                // We did not find the Video ROM associated with the
                // VGA parameters.  Try detect it.
                //

                //
                // In the following memory comparison, we skip the first 16 bytes.
                // Because most likely the reason we did not find the standard
                // Video ROM is because the signature word is missing.
                //

                Handler = (Handler & 0xF0000) +
                              (RomBlock->RomBlock.Address & 0xFFFF);
                if (!HwRomCompare(RomBlock->RomBlock.Address + 0x10,
                                  Handler + 0x10,
                                  RomBlock->RomBlock.Size - 0x10)) {
                    //
                    // Note:  The old code looked like this for many years:
                    //

                    /*
                    if ((Handler & 0xFFFF == 0) && (RomBlock->RomBlock.Size < 0x8000)){
                        Size = 0x8000;
                    } else {
                        Size = RomBlock->RomBlock.Size;
                    }
                    */

                    //
                    // But (Handler & 0xFFFF == 0) is always false.  So 
                    // Size always equals RomBlock->RomBlock.Size.  Rather than
                    // fix the comparison, which might cause machines to break,
                    // I'm going to assume that it's fine to just make the code
                    // do what it's always done.  -  JakeO  8/9/00
                    //

                    Size = RomBlock->RomBlock.Size;

                    AddRomBlock(Handler, Size);
                }
            }
        }
    } else {

        //
        // There is no ROM block associated with the int 10h handler.
        // We can find the shadowed video ROM block if:
        //   We detected the original video ROM in 0xC0000 - 0xC8000 range
        //

        VideoRomBlock = MatchRomBlock((Handler & 0xFFFF) + 0xC0000);
        if (VideoRomBlock != NULL) {

            //
            // In the following memory comparison, we skip the first 16 bytes.
            // Because most likely the reason we did not find the shadow rom
            // is the signature word is missing.
            //

            if (!HwRomCompare(VideoRomBlock->RomBlock.Address + 0x10,
                              (Handler & 0xF0000) +
                                (VideoRomBlock->RomBlock.Address & 0xFFFF) + 0x10,
                              VideoRomBlock->RomBlock.Size - 0x10)) {

                AddRomBlock((VideoRomBlock->RomBlock.Address & 0xFFFF) +
                                (Handler & 0xF0000),
                            VideoRomBlock->RomBlock.Size);
            }
        }
    }
}

VOID
GetRomBlocks(
    FPUCHAR ReservedBuffer,
    PUSHORT Size
    )

/*++

Routine Description:

    This routine scans the ROM IO area and collects all the ROM blocks.

Arguments:

    ReservedBuffer - Supplies a far pointer to the buffer.

    Size - Supplies a near pointer to a variable to receive the size
           of the ROM block.

Return Value:

    None.

--*/

{

    FPTEMPORARY_ROM_BLOCK Source;
    ULONG StartAddr, EndAddr;
    FPUSHORT TestAddr;
    FPROM_BLOCK Destination;
    USHORT BufferSize;
    ULONG EBiosAddress = 0, EBiosLength = 0;
    ULONG far *EBiosInformation = (ULONG far *)
                          ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET);

    //
    // First we reserve the max space needed and build our temporary rom
    // block list in the heap space below the space reservedand.  After
    // the temporary list is built, we then copy it to the caller supplied
    // reserved space.
    //

    BlockPointer = (FPTEMPORARY_ROM_BLOCK)HwAllocateHeap(0, FALSE);
    BlockHead = NULL;
    *Size = 0;

    GetBiosSystemEnvironment((PUCHAR)&BiosSystemEnvironment);
    if (BiosSystemEnvironment.ConfigurationFlags & 0x4) {

        //
        // If extened BIOS data area is allocated, we will find out its
        // location and size and save in ROM blocks.
        //

        _asm {
              push   es
              mov    ah, 0xC1
              int    15h
              jc     short Exit

              cmp    ah, 0x86
              je     short Exit

              mov    bx, 0
              mov    dx, 0
              mov    ax, 0
              mov    al, es:[bx]
              shl    ax, 10
              mov    word ptr EBiosLength, ax
              mov    ax, es
              mov    dx, es
              shl    ax, 4
              shr    dx, 12
              mov    word ptr EBiosAddress, ax
              mov    word ptr EBiosAddress + 2, dx
        Exit:
              pop    es
        }
    }

    //
    // Save the Extended BIOS data area address and size at 700:40
    //

    if (EBiosLength) {
        *EBiosInformation++ = EBiosAddress;
        *EBiosInformation = EBiosLength;
    } else {
        *EBiosInformation++ = 0L;
        *EBiosInformation = 0L;
    }
    if (!ScanRomBlocks()) {
        return;
    }

    //
    // On some machines, when they shadow video ROM from 0xC0000 to
    // 0xE0000, they copy code only (no signature.)  So, we need
    // special code to work around the problem.
    //

    CheckVideoRom();

    //
    // Now do our special hack for IBM.  On SOME IBM PCs, they use
    // E0000-FFFFF for system BIOS (even on non PS/2 machines.) Since
    // system BIOS has no ROM header, it is very hard to know the starting
    // address of system ROM.  So we:
    //
    // 1. Make sure there is no ROM block in E0000-EFFFF area.
    // 2. and E0000-EFFFF contains valid data.
    //
    // If both 1 and 2 are true, we assume E0000-EFFFF is part of system
    // ROM.
    //

    Source = BlockHead;
    while (Source) {
        StartAddr = Source->RomBlock.Address;
        EndAddr = StartAddr + Source->RomBlock.Size - 1;
        if ((StartAddr < 0xE0000 && EndAddr < 0xE0000) ||
            (StartAddr >= 0xF0000)) {
            Source = Source->Next;
        } else {
            break;
        }
    }
    if (Source == NULL) {
        for (StartAddr = 0xE0000; StartAddr < 0xF0000; StartAddr += 0x800) {
            MAKE_FP(TestAddr, StartAddr);
            if (*TestAddr != 0xffff) {
                AddRomBlock(0xE0000, 0x10000);
                break;
            }
        }
    }

    //
    // Now copy the rom block list to our reserved space and release
    // the extra space we reserved.
    //

    Source = BlockHead;
    Destination = (FPROM_BLOCK)ReservedBuffer;
    BufferSize = 0;
    while (Source) {
        *Destination = *((FPROM_BLOCK)&Source->RomBlock);
        BufferSize += sizeof(ROM_BLOCK);
        Source = Source->Next;
        Destination++;
    }
    *Size = BufferSize;
}

VOID
HwGetBiosDate(
    ULONG   StartingAddress,
    USHORT  Length,
    PUSHORT Year,
    PUSHORT Month,
    PUSHORT Day
    )
/*++

Routine Description:

    Scans the specified area for the most recent date of the
    form xx/xx/xx.

Arguments:

    StartingAddress - First address to scan
    Length          - Length of area to scan

Return Value:

    Year            - If non-zero, the year of the date  (1991, 1992, ...)
    Month           - If non-zero, then month of the date found
    Day             - If non-zero, the day of the date found


--*/
{
    FPUCHAR fp, date;
    USHORT  y, m, d;
    UCHAR   c;
    ULONG   i, temp;

    //
    // Zero return values
    //

    *Year  = 0;
    *Month = 0;
    *Day   = 0;

    //
    // Search for date with the format MM/DD/YY or M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
    //

    MAKE_FP(fp, StartingAddress);   //  initialize fp pointer
    while (Length > 8) {

        c = fp[7];
        if ((c < '0' ||  c > '9')  &&  (c != '/'  &&  c != '-')) {
            // these 8 bytes are not a date, next location

            fp     += 8;
            Length -= 8;
            continue;
        }

        date = fp;                  // check for date at this pointer
        fp += 1;                    // skip to next byte
        Length -= 1;

        //
        // Check for date of the form MM/DD/YY
        //

        y = 0;
        if (date[0] >= '0'  &&  date[0] <= '9'  &&
            date[1] >= '0'  &&  date[1] <= '9'  &&
           (date[2] == '/'  ||  date[2] == '-') &&
            date[3] >= '0'  &&  date[3] <= '9'  &&
            date[4] >= '0'  &&  date[4] <= '9'  &&
           (date[5] == '/'  ||  date[5] == '-') &&
            date[6] >= '0'  &&  date[6] <= '9'  &&
            date[7] >= '0'  &&  date[7] <= '9' ) {


            //
            // A valid looking date field at date, crack it
            //

            y = (date[6] - '0') * 10 + date[7] - '0' + 1900;
            m = (date[0] - '0') * 10 + date[1] - '0';
            d = (date[3] - '0') * 10 + date[4] - '0';
        }

        //
        // Check for date of the form M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
        //

        if (Length >= 15 &&
            date[ 0] >= '0'  &&  date[ 0] <= '9'  &&  date[ 0] == date[ 1]  &&
            date[ 2] >= '0'  &&  date[ 2] <= '9'  &&  date[ 2] == date[ 3]  &&
           (date[ 4] == '/'  ||  date[ 4] == '-') &&  date[ 4] == date[ 5]  &&
            date[ 6] >= '0'  &&  date[ 6] <= '9'  &&  date[ 6] == date[ 7]  &&
            date[ 8] >= '0'  &&  date[ 8] <= '9'  &&  date[ 8] == date[ 9]  &&
           (date[10] == '/'  ||  date[10] == '-') &&  date[10] == date[11]  &&
            date[12] >= '0'  &&  date[12] <= '9'  &&  date[12] == date[13]  &&
            date[14] >= '0'  &&  date[14] <= '9'  &&  date[14] == date[15]) {

            //
            // A valid looking date field at date, crack it
            //

            y = (date[12] - '0') * 10 + date[14] - '0' + 1900;
            m = (date[ 0] - '0') * 10 + date[ 2] - '0';
            d = (date[ 6] - '0') * 10 + date[ 8] - '0';
        }

        if (y != 0) {
            if (m < 1  ||  m > 12  ||  d < 1  ||  d > 31) {
                y = 0;          // bad field in date, skip it
            } else {
                if (y < 1980) {

                    //
                    // Roll to next century.
                    //

                    y += 100;
                }
            }
        }

        //
        // Check for date of the form 19xx or 20xx
        //
        // First, check the 5th character is not a digit.
        //

#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))

        if (!IS_DIGIT(date[4])) {
            for (i = 0, temp = 0; i < 4; i++) {
                if (!IS_DIGIT(date[i])) {
                    temp = 0;
                    break;
                }
                temp = (temp * 10) + date[i] - '0';
            }
            if ((temp >= 1980) && (temp < 2599)) {

                //
                // Looks like a reasonable date, use it.
                //

                y = (USHORT)temp;
                m = 0;
                d = 0;
            }
        }
         
        if (!y) {
            // not a date - skip it
            continue;
        }

        if ((y >  *Year) ||
            (y == *Year  &&  m >  *Month)  ||
            (y == *Year  &&  m == *Month  &&  d > *Day) ) {

            //
            // This date is more recent
            //

            *Year  = y;
            *Month = m;
            *Day   = d;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\hwpmbios.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpmbiosc.c

Abstract:

    This modules contains ACPI BIOS C supporting routines

Author:

    Jake Oshins (jakeo) 6-Feb-1997

Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include <string.h>
#include "acpibios.h"

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );

BOOLEAN
Int15E980 (
    PLEGACY_GEYSERVILLE_INT15 Info
    );


BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    )
/*++

Routine Description:

    This routine checks to see if an ACPI BIOS is present.  If it is,
    then it returns the ACPI Root System Description Pointer.

Arguments:
    
    Configuration - structure that holds ACPI pointer
    Length        - length of that structure

Return Value:

    TRUE if ACPI BIOS is present, FALSE otherwise

--*/
{
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPULONG EbdaAddr;
    FPACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, nodeSize;
    USHORT numE820Blocks, e820BlockIndex;
    BOOLEAN complete;
    FPACPI_E820_ENTRY e820Blocks;
    E820Frame Frame;
    LEGACY_GEYSERVILLE_INT15 geyservilleInfo;
    BOOLEAN geyservillePresent;

    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the 
    // Root System Description Table structure. 
    //
    
    for (pass = PASS1; pass < MAX_PASSES; pass++) {
        
        if (pass == PASS1) {
            // 
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.
            //

            //
            // Earlier, we stored the address of the EBDA in address
            // DOS_BEGIN_SEGMENT << 4 : EBIOS_INFO_OFFSET
            //
            MAKE_FP(EbdaAddr, ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET));
            MAKE_FP(current, *EbdaAddr);

            if (*EbdaAddr == 0) {
                continue;
            }

            romAddr = *EbdaAddr;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000 
            // to 0xF0000.
            
            MAKE_FP(current, ACPI_BIOS_START);
            romAddr = ACPI_BIOS_START;
            romEnd  = ACPI_BIOS_END;
        }

        while (romAddr < romEnd) {
    
            header = (FPACPI_BIOS_INSTALLATION_CHECK)current;
            
            //
            // Signature to match is the string "RSD PTR".
            //
            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {
                
                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum += current[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
#if DBG
                BlPrint("GetAcpiBiosData: Checksum fails\n");
#endif
            }
            romAddr += ACPI_BIOS_HEADER_INCREMENT;
            MAKE_FP(current, romAddr);
        }
    }
    
    if (romAddr >= romEnd) {
#if DBG
            BlPrint("GetAcpiBiosData: RSDT pointer not found\n");
#endif
        return FALSE;
    }

    
    //
    // Now header points at the RSDP.  So we can move on to collecting the 
    // E820 blocks.
    //

    numE820Blocks = 20;
    
    while (TRUE) {
        
        e820Blocks = 
            (FPACPI_E820_ENTRY)HwAllocateHeap(
                sizeof(ACPI_E820_ENTRY) * numE820Blocks,
                FALSE);

        if (!e820Blocks) {
#if DBG
            BlPrint("GetAcpiBiosData: Out of heap space.\n");
#endif
            return FALSE;
        }

        e820BlockIndex = 0;
        Frame.Key = 0;
        complete = FALSE;

        while (!complete) {

#if DBG
            BlPrint("Searching for E820 block # %d.\n", e820BlockIndex);
#endif
            
            if (e820BlockIndex == numE820Blocks) {
                HwFreeHeap(sizeof(ACPI_E820_ENTRY) * numE820Blocks);
                numE820Blocks += 20;
                break;
            }
            
            //
            // Set up the context.
            //
            
            Frame.Size = sizeof (Frame.Descriptor);

            Int15E820 (&Frame);

            if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {

                //
                // The BIOS just didn't do it.
                //

#if DBG
                BlPrint("The BIOS failed the E820 call\n");
#endif
                complete = TRUE;
                break;
            }

            //
            // Copy the data from the Frame into the array.
            //

            e820Blocks[e820BlockIndex].Base.LowPart = Frame.Descriptor.BaseAddrLow;
            e820Blocks[e820BlockIndex].Base.HighPart = Frame.Descriptor.BaseAddrHigh;
            e820Blocks[e820BlockIndex].Length.LowPart = Frame.Descriptor.SizeLow;
            e820Blocks[e820BlockIndex].Length.HighPart = Frame.Descriptor.SizeHigh;
            e820Blocks[e820BlockIndex].Type = Frame.Descriptor.MemoryType;
            e820Blocks[e820BlockIndex].Reserved = 0;
            
#if DBG
            BlPrint("Base: %x%x  Len: %x%x  Type: %x\n",
                    (USHORT)(Frame.Descriptor.BaseAddrLow >> 16),
                    (USHORT)(Frame.Descriptor.BaseAddrLow & 0xffff),
                    (USHORT)(Frame.Descriptor.SizeLow >> 16),
                    (USHORT)(Frame.Descriptor.SizeLow & 0xffff),
                    (USHORT)(Frame.Descriptor.MemoryType));
#endif

            e820BlockIndex++;
            
            if (Frame.Key == 0) {
                
                //
                // This was the last descriptor
                //
                complete = TRUE;
                break;
            }
        }

        if (complete) {
            break;
        }
    }

#if DBG
    BlPrint("Finished with %d E820 descriptors\n", e820BlockIndex);
#endif
    
    //
    // Check for Geyserville
    //

    if (geyservillePresent = Int15E980(&geyservilleInfo)) {
        geyservilleInfo.Signature = 'GS';
    }

#if DBG
        BlPrint("GetAcpiBiosData: Geyserville is %s present.\n",
                geyservillePresent ? "" : "not");
        
        if (geyservillePresent) {
            BlPrint("GetAcpiBiosData: Geyserville command port: %x.\n",
                    geyservilleInfo.CommandPortAddress);
        }
#endif

    //
    // Now we know how big the lump of data is going to be.
    //
    
    nodeSize = sizeof(ACPI_BIOS_MULTI_NODE) + DATA_HEADER_SIZE +
               (sizeof(ACPI_E820_ENTRY) * (e820BlockIndex - 1)) +
               (geyservillePresent ? sizeof(LEGACY_GEYSERVILLE_INT15) : 0);

    current = (FPUCHAR) HwAllocateHeap(nodeSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetAcpiBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect ACPI Bios installation check data and device node data.
    //

    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->RsdtAddress.HighPart = 0;
    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->RsdtAddress.LowPart = 
        header->RsdtAddress;

    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->Count = e820BlockIndex;
    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->Reserved = 0;

    _fmemcpy (&(((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->E820Entry[0]),
              (FPUCHAR)e820Blocks,
              sizeof(ACPI_E820_ENTRY) * e820BlockIndex
              );
    
    if (geyservillePresent) {
        
        //
        // Append Geyserville information to the end of the block.
        //

        _fmemcpy(&(((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->E820Entry[e820BlockIndex]),
                 &geyservilleInfo,
                 sizeof(geyservilleInfo));
    }

    *Configuration = current;
    *Length = nodeSize;

#if DBG
    BlPrint("ACPI BIOS found at 0x%x:%x.  RdstAddress is 0x%x:%x\n", 
            (USHORT)(romAddr >> 16), 
            (USHORT)(romAddr),
            (USHORT)(header->RsdtAddress >> 16),
            (USHORT)(header->RsdtAddress)
            );
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\main.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    main.asm
;
; Abstract:
;
;    This file implements the main entry code for x86 hardware detection
;    module. This assembly file is required in order to link C modules
;    into a "/TINY" (single segment) memory module.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 15-Feb-1992.
;        The code is extracted from NTLDR su.asm.
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where the detection module
; is loaded, the paragraph (shifted right four bits) offset of DGROUP from
; _TEXT must be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
;--

.386p

include main.inc

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Define double wrod to save caller's (ntldr's) stack pointer
;

NtldrStack      df      0               ; saved area for ss:esp

                dw      2048 dup (0)
DetectionStack  equ     $

_DATA   ends

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
; VOID
; DetectionMain (
;    ULONG HeapStart,
;    ULONG HeapSize,
;    ULONG ConfigurationTree,
;    ULONG HeapUsed,
;    ULONG LoadOptions,
;    ULONG LoadOptionsLength
;    )
;
; Routine Description:
;
;    This is the entry point of the detection module.
;    Memory from HeapStart to (HeapStart + HeapSize) is allocated for detection
;    module to store the hardware configuration tree.
;    Note that detection module loaded address will be resued by loader after
;    the control is passed back to ntldr.
;
; Arguments:
;
;    HeapStart - supplies a 32 bit FLAT starting addr of the heap
;
;    HeapSize - Supplies the size of the useable heap
;
;    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
;               receive the configuration tree.
;
;    HeapUsed - Supplies a 32 bit FLAT address of the variable to receive
;               the size of heap we acually used.
;
;    LoadOptions - Supplies a 32 bit FLAT address of the load options string.
;
;    LoadOptionsLength - Supplies the length of the LoadOptions string. Note,
;        this is for sanity check to make sure the LoadOptions string is valid.
;        (in case use usews Nt 1.0 ntldr with the new ntdetect.com.)
;
; Return Value:
;
;    None.
;
;--
;

;
; Run-time fixups for stack and data segment
;

        public  DetectionMain
DetectionMain:

;
; Save all the registers we need to preserved on NTLDR's stack
;

        push    ebp
        mov     ebp, esp
        and     ebp, 0ffffh
        push    ds
        push    es
        push    ebx
        push    esi
        push    edi

;
; Compute the paragraph needed for DS
;

        mov     cx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     cx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,cx                   ; add paragraph offset to data

;
; Make DS point to the paragraph address of DGROUP
;

        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax

;
; Save old stack pointer and set up our own stack.
;

        mov     ecx, esp
        mov     dword ptr NtldrStack, ecx
        mov     cx, ss
        mov     word ptr NtldrStack + 4, cx

        mov     ebx, [bp + 8]           ; [ebx] = Heap Start
        mov     ecx, [bp + 12]          ; [ecx] = Heap Size
        mov     esi, [bp + 16]          ; [esi] -> addr of ConfigurationTree
        mov     edi, [bp + 20]          ; [edi] -> Addr of HeapUsed variable
        mov     edx, [bp + 24]          ; [edx]-> Addr of LoadOptions string
        mov     ebp, [bp + 28]          ; [ebp] = length of LoadOptions

        mov     ss,ax
        mov     esp,offset DGROUP:DetectionStack ; (ss:esp) = top of internal stack

;
; Set up parameters and invoke real detection code to collect hardware
; information.
;

        push    ebp
        push    edx
        push    edi
        push    esi
        push    ecx
        push    ebx
        
        xor     eax, eax        
        xor     ebx, ebx
        xor     ecx, ecx
        xor     edx, edx
        xor     esi, esi
        xor     edi, edi
        
        call    _HardwareDetection

;
; The hardware detection is done.  We need to switch to ntldr's stack,
; restore registers and return back to ntldr.
;

        lss     esp, NtldrStack

        pop     edi                      ; retore registers
        pop     esi
        pop     ebx
        pop     es
        pop     ds
        pop     ebp

        retf

_TEXT   ends

        end     DetectionMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\keybdc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abiosc.c

Abstract:

    This module implements keybaord detection C routines.

Author:

    Shie-Lin Tzong (shielint) 18-Dec-1991

Environment:

    Real Mode.


Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

extern
UCHAR
GetKeyboardFlags (
    VOID
    );

extern
USHORT
HwGetKey (
    VOID
    );

extern UCHAR NoLegacy;

//
// SavedKey is used to save the key left in the keyboard type-ahead buffer
//   before we start our keyboard/mouse tests.  The key will be push back
//   to the type-ahead buffer once the mouse detection is done.
//

USHORT   SavedKey = 0;

BOOLEAN NoBiosKbdCheck=FALSE;

//
// String table to map keyboard id to an ascii string.
//

PUCHAR KeyboardIdentifier[] = {
    "UNKNOWN_KEYBOARD",
    "OLI_83KEY",
    "OLI_102KEY",
    "OLI_86KEY",
    "OLI_A101_102KEY",
    "XT_83KEY",
    "ATT_302",
    "PCAT_ENHANCED",
    "PCAT_86KEY",
    "PCXT_84KEY"
    };

UCHAR KeyboardType[] = {
    255,
    1,
    2,
    3,
    4,
    1,
    1,
    4,
    3,
    1
    };

UCHAR KeyboardSubtype[] = {
    255,
    0,
    1,
    10,
    4,
    42,
    4,
    0,
    0,
    0
    };

USHORT
GetKeyboardId(
    VOID
    )

/*++

Routine Description:

    This routine determines the Id of the keyboard.  It calls GetKeyboardIdBytes
    to complete the task.

Arguments:

    None.

Return Value:

    Keyboard ID.

--*/

{
    char KeybID_Bytes[5];
    int  Num_ID_Bytes;
    int  keytype = UNKNOWN_KEYBOARD;

    SavedKey = HwGetKey();

    keytype = UNKNOWN_KEYBOARD;

    if (!NoBiosKbdCheck) {
        if (IsEnhancedKeyboard()) {
            keytype = PCAT_ENHANCED;
        }
    }

    if (keytype == UNKNOWN_KEYBOARD) {

        Num_ID_Bytes = GetKeyboardIdBytes(KeybID_Bytes, 0xf2);

        if (Num_ID_Bytes > 0) {

            if ((KeybID_Bytes[0] & 0x00ff) == 0xfa) {

                keytype = PCAT_86KEY;

            } else if ((KeybID_Bytes[0] & 0x00ff) == 0xfe) {

                keytype = PCAT_86KEY;

            } else if (Num_ID_Bytes >= 3 &&
                      ((KeybID_Bytes[1] & 0x00ff) == 0xAB) &&
                      ((KeybID_Bytes[2] & 0x00ff) == 0x41)) {

                keytype = PCAT_ENHANCED;

            } else {

                keytype = UNKNOWN_KEYBOARD;
            }
            
        } else {

            keytype = UNKNOWN_KEYBOARD;
        }
    }

    return keytype;
}

FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    USHORT KeyboardId
    )

/*++

Routine Description:

    This routine maps Keyboard Id information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    KeyboardId - Supplies a USHORT which describes the keyboard id information.

    Buffer - Supplies a pointer to a buffer where to put the ascii.

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CM_KEYBOARD_DEVICE_DATA far *KeyboardData;
    USHORT z, Length;

    //
    // Set up Keyboard Controller component
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                 sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = KeyboardController;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Only fill this on a machine which is not legacy free
    //
    if (!NoLegacy) {
        //
        // Set up Port information
        //

        ControlData.NumberPortEntries = 2;
        ControlData.DescriptorList[z].Type = RESOURCE_PORT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareDeviceExclusive;
        ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    #if defined(NEC_98)
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x41;
    #else // PC98
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x60;
    #endif // PC98
        ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
        ControlData.DescriptorList[z].u.Port.Length = 1;
        z++;
        ControlData.DescriptorList[z].Type = RESOURCE_PORT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareDeviceExclusive;
        ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    #if defined(NEC_98)
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x43;
    #else // PC98
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x64;
    #endif // PC98
        ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
        ControlData.DescriptorList[z].u.Port.Length = 1;
        z++;

        //
        // Set up Irq information
        //

        ControlData.NumberIrqEntries = 1;
        ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareUndetermined;
        ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
        ControlData.DescriptorList[z].u.Interrupt.Level = 1;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 1;
        if (HwBusType == MACHINE_TYPE_MCA) {
            ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
        } else {

            //
            // For EISA the LevelTriggered is temporarily set to FALSE.
            //

            ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
        }

        Controller->ConfigurationData =
                            HwSetUpResourceDescriptor(Component,
                                                      NULL,
                                                      &ControlData,
                                                      0,
                                                      NULL
                                                      );
    }

    //
    // Set up Keyboard peripheral component
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = KeyboardPeripheral;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = (FPVOID)NULL;
    Length = strlen(KeyboardIdentifier[KeyboardId]) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = HwAllocateHeap(Length, FALSE);
    _fstrcpy(Component->Identifier, KeyboardIdentifier[KeyboardId]);

    //
    // If we are running on a legacy free machine, we still want to report the
    // KeyboardFlags to NTOS
    //
    if (KeyboardId != UNKNOWN_KEYBOARD || NoLegacy) {

        Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                 sizeof(CM_KEYBOARD_DEVICE_DATA);
        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                    Length,
                                    TRUE);
        CurrentEntry->ConfigurationData = DescriptorList;
        Component->ConfigurationDataLength = Length;
        DescriptorList->Count = 1;
        DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
        DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                    sizeof(CM_KEYBOARD_DEVICE_DATA);
        KeyboardData = (CM_KEYBOARD_DEVICE_DATA far *)(DescriptorList + 1);
        KeyboardData->KeyboardFlags = GetKeyboardFlags();
        KeyboardData->Type = KeyboardType[KeyboardId];
        KeyboardData->Subtype = KeyboardSubtype[KeyboardId];
    }

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;
    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\main.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    main.inc
;
; Abstract:
;
;    This module defines the segment for the detection module.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 16-Feb-1992.
;
; Revision History:
;
;
;--

.386

;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA

;
; Define the stack location for detection module.
;

DETECTION_STACK_SP      EQU     0fffch

;
; External references
;

extrn   _HardwareDetection: near
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\keybda.asm ===
title  "Keyboard Detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    keyboard.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 16-Dec-1991.  Most of the code is extracted
;    from Win31 Setup.
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

extrn           _READ_PORT_UCHAR:proc

;
; Now define the needed equates.
;

TRUE                equ         -1
FALSE               equ         0

;
; equates for ports -- these are used in the keyboard detection module.
;

ack_port        equ     20h     ; 8259 acknowledge port
eoi             equ     20h     ; 8259 end of interrupt

kb_data         equ     60h
kb_ctl          equ     61h
kb_command      equ     64h     ;
kb_status       equ     64h     ; status port -- bit 1: ok to write

ENABLE_KEYBOARD_COMMAND         EQU     0AEH
DISABLE_KEYBOARD_COMMAND        EQU     0ADH

.386

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING


;++
;
; BOOLEAN
; IsEnhancedKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    Function looks at bios data area 40:96 to see if an enhanced keyboard
;    is present.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE if Enhanced keyboard is present.  Else a value of FALSE is returned.
;
;--

        Public  _IsEnhancedKeyboard
_IsEnhancedKeyboard     proc    near

        push    es

        mov     ax,40h
        mov     es,ax
        xor     ax,ax
        mov     al,byte ptr es:[96h]
        and     al,00010000b

        pop     es
        ret

_IsEnhancedKeyboard     endp


;++
;
; SHORT
; GetKeyboardIdBytes (
;    PCHAR IdBuffer,
;    SHORT Length
;    )
;
; Routine Description:
;
;    This routine returns keyboard identification bytes.
;
;    Note that this function accepts one argument. The arg is a pointer to a
;    character buffer allocated to hold five (five) bytes. Upon return from
;    this function the buffer will contain between 1 and 5 bytes of keyboard
;    ID information. The number of valid ID bytes in the buffer is returned
;    in AX as a C proc return value.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Id bytes are stored in IdBuffer and the length of Id bytes is returned.
;
;--

KeybID  EQU     [bp + 4]              ; parameters
ReqByte EQU     [bp + 6]

nKeyID  EQU     [bp - 2]              ; Local variables
AckByte EQU     [bp - 3]

        public  _GetKeyboardIdBytes
_GetKeyboardIdBytes     proc    near

        push    bp
        mov     bp, sp
        sub     sp, 4                 ; space for local variables
        push    bx
        push    es

;
; First I initialize needed local vars.  Next I find out if machine is AT
; type or non AT type for the purpose of selecting proper acknowledgement
; byte so I can talk to the interrupt controler.
;

        mov     bx, KeybID            ; Initialize base pointer to buffer.
        mov     word ptr nKeyID, 0    ; Initialize count to zero.
        mov     byte ptr AckByte, 20h ; for all but AT-like. acknowledge for
                                      ; interrupt controller. 61h for AT's.
        mov     ax, 0fff0h            ; look into 0FFF0:0FE location.
        mov     es, ax                ; this is where the model byte is.
        mov     al, byte ptr es:[0feh]
        cmp     al, 0fch              ; is it AT-like?
        jne     UnlikeAT
        mov     byte ptr AckByte, 61h
        call    _Empty8042
if 0
        ;
        ; Disable keyboard is a right thing to do.  But, it turned out
        ; this causes some keyboards to fail GetId.
        ;

        call    DisableKeyboard
endif

UnlikeAT:

;
; Now, let's see if we can get some ID bytes from the keyboard controler.
;

        mov     ah, ReqByte           ; AT: send second command.
        mov     dx, 60h               ; write to data port
        call    Write8042             ; Output command byte to keyboard, bytes in AH
        call    ReadKeyboard          ; Get byte from keyboard, byte in AL if No CF
        jc      gotNoByte
        mov     [bx], al              ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID
        call    ReadKeyboard          ; Get byte from keyboard, byte in AL if No CF
        jc      gotNoByte
        mov     [bx]+1, al            ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID
        call    ReadKeyboard          ; check for extra bytes.
        jc      gotNoByte
        mov     [bx]+2, al            ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID

gotNoByte:
        mov     al, AckByte
        out     ack_port, al
        call    EnableKeyboard
        call    _Empty8042
        mov     ax, nKeyID            ; Return number of valid ID bytes obtained.

        pop     es
        pop     bx
        mov     sp, bp
        pop     bp
        ret
_GetKeyboardIdBytes     endp

;++
;
; UCHAR
; ReadKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine reads character from keyboard.
;
;    It is assumed that a command (05H or 0F2H) has been set to request
;    that the keyboard send an identification byte.
;    It is also assumed that interrupts are disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    If a character is returned, the carry bit is reset.
;    If no character is returned,  the carry bit is set.
;
;--

        public  ReadKeyboard
ReadKeyboard    proc     near

        push    cx
        push    bx
        mov     bx, 2             ; set outer timeout for double nested.
        cli

inner_timeout:
        xor     cx, cx            ; set inner timeout for double nested.

kbiwait:
        in      al, kb_status     ; wait for port ready
        test    al, 1             ; ready?
        jnz     kbiAvailable
        loop    kbiwait

        dec     bx                ; decrement outer timeout loop.
        jnz     inner_timeout     ; zero out inner loop again.
        stc
        jmp     short no_byte

kbiAvailable:                       ; we received a byte.
        mov     cx,100

        ;
        ; We need to let some time elapse before we try to read the data
        ; because of a problem running this code in the DOS box under
        ; OS/2.
        ;

wait_for_data:
        loop    wait_for_data

        in      al, kb_data       ; get data byte.
        clc

no_byte:
        sti
        pop     bx
        pop     cx
        ret

ReadKeyboard    endp


;++
;
; UCHAR
; Write8042 (
;    USHORT Port,
;    UCHAR Command
;    )
;
; Routine Description:
;
;    This routine writes command byte to keyboard.
;
;    It is assumed that a command (05H or 0F2H) has been set to request
;    that the keyboard send an identification byte.
;    It is also assumed that interrupts are disabled.
;
; Arguments:
;
;    Port (dx) - Port to write data to
;    Command (ah) - to be written to keyboard.
;
; Return Value:
;
;    None.
;
;--
                public  Write8042
Write8042       proc     near

        push    cx
        push    bx
        mov     bx, 4             ; set outer timeout for double nested.
        cli

reset_inner:
        xor     cx, cx            ; set inner timeout for double dested.

koutwait:
        in      al, kb_status     ; get 8042 status
        test    al, 10b           ; can we output a byte?
        jz      ok_to_send
        loop    koutwait

        dec     bx                ; decrement outer timeout loop.
        jnz     reset_inner       ; zero out inner loop again.
        jmp     short nosiree     ; timeout expired, don't try to send.

ok_to_send:
        call    _Empty8042
        mov     al, ah            ; ok, send the byte
        out     dx, al

nosiree:
        sti
        pop     bx
        pop     cx
        ret

Write8042       endp

;++
;
; UCHAR
; GetKeyboardFlags (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the ROM BIOS flags byte that describes the state
;    of the various keyboard toggles and shift keys.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Keyboard ROM BIOS Flags byte.
;
;--

        public          _GetKeyboardFlags
_GetKeyboardFlags       proc     near

        mov     ah, 02
        int     16h
        ret

_GetKeyboardFlags       endp


;++
;
; VOID
; EnableKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine enables 8042 keyboard interface.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  EnableKeyboard
EnableKeyboard  proc     near

        mov     ah, ENABLE_KEYBOARD_COMMAND
        mov     dx, kb_command
        call    Write8042
        ret

EnableKeyboard  endp

;++
;
; VOID
; DisableKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables 8042 keyboard interface.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  DisableKeyboard
DisableKeyboard  proc     near

        mov     ah, DISABLE_KEYBOARD_COMMAND
        mov     dx, kb_command
        call    Write8042
        ret

DisableKeyboard  endp

;++
;
; VOID
; Empty8042 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine drains the i8042 controller's output buffer.  This gets
;    rid of stale data that may have resulted from the user hitting a key
;    or moving the mouse, prior to the execution of keyboard initialization.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  _Empty8042
_Empty8042      proc     near

        push    ax
        push    dx
        pushf
        cli
E8Check:
        in      al, kb_status     ; wait for port ready
        test    al, 1             ; ready?
        jz      E8Exit

        mov     dx, kb_data
        push    dx
        call    _READ_PORT_UCHAR  ; use this call to delay I/O
        add     sp, 2
        jmp     E8Check
E8Exit:
        popf
        pop     dx
        pop     ax
        ret

_Empty8042      endp

_TEXT   ends

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\mouse.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       mouse.inc
;
;   Abstract:
;
;       This file defines the hardware specific equates to be used in
;       the mouse detection code.
;
;   Author:
;
;       Shie-Lin (shielint) 22-Feb-1992
;
;   Revision History:
;
;--

;
; External references
;

IFDEF NEC_98
ELSE ; NEC_98
extrn   _InportMouseIrqDetection:proc
ENDIF ; NEC_98
extrn    _READ_PORT_UCHAR: proc
extrn    _WRITE_PORT_UCHAR: proc

;
; Internal Macros
;

IOdelay macro
         jmp       $+2
         jmp       $+2
endm

address macro StartAddr, EndAddr
         add   dx,StartAddr-EndAddr
endm

DelayIn   macro
          push  dx
          call  _READ_PORT_UCHAR        ; destroy AL
          add   sp, 2
endm

DelayOut  macro
          push  ax
          push  dx
          call  _WRITE_PORT_UCHAR       ; destroy AL
          add   sp, 4
endm

IFDEF NEC_98
MultiDelayOut8  macro
          push  di

          mov   di, ax
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut

          pop di
endm
ELSE ; NEC_98
ENDIF ; NEC_98
;
; Mouse information structure
; N.B. This must match the one defined in hwdetect.h
;

MouseInformation        struc
        MouseType       db      0
        MouseSubtype    db      0
        MousePort       dw      0       ; if serial mouse, 1 for com1, 2 for com2 ...
        MouseIrq        dw      0
        DeviceIdLength  dw      0
        DeviceId        db      10 dup(?); Pnp device id if any
MouseInformation        ends


;
; Mouse ID's returned by GetMouseType().
;

UNKNOWN_MOUSE  equ    0         ; Don't know whether or not a mouse is
                                ; installed...
NO_MOUSE       equ    100H      ; No mouse installed.
MS_MOUSE       equ    200H      ; MS Regular mouse
MS_BALLPOINT   equ    300H      ; MS Ballpoint mouse
LT_MOUSE       equ    400H      ; LogTec mouse

IFDEF NEC_98
NEC_MOUSE      equ    500H      ; NEC PC-9800 Series Mouse
PC98BUS_MOUSE  equ    7h
ENDIF ; NEC_98
PS2_MOUSE      equ    1h        ; Connect to 8042 mouse port
SERIAL_MOUSE   equ    2h
INPORT_MOUSE   equ    3h
BUS_MOUSE      equ    4h
PS2_MOUSE_WITH_WHEEL    equ 5
SERIAL_MOUSE_WITH_WHEEL equ 6

TRUE           EQU    0ffh
FALSE          EQU    0

LW_ClockTickCount EQU    46Ch
HW_ClockTickCount EQU    46Eh

;************************************************************************
;               I N P O R T     D E F I N I T I O N S                   *
;************************************************************************

INP_ADDR        EQU     0               ; Inport addr register offset.
INP_DATA        EQU     1               ; Inport data register offset.
INP_ID          EQU     2               ; Inport ID register offset.
INP_TEST        EQU     3               ; Inport test register offset.

INPORT_ID       EQU     0DEh            ; InPort ID byte.

INP_STATUS_REG  EQU     0               ; Status register number.
INP_DATA1_REG   EQU     1               ; Internal data register 1.
INP_DATA2_REG   EQU     2               ; Internal data register 2.
INP_MODE_REG    EQU     7               ; Mode register number.

INP_RESET       EQU     10000000b       ; Value to reset InPort.

HZ0INTR0        EQU     00000000b       ; Value to select 0 Hz, INTR=0
HZ0INTR1        EQU     00000110b       ; Value to select 0 Hz, INTR=1
HZ30            EQU     00000001b       ; Value to select 30 Hz.
DATA_INT_ENAB   EQU     00001000b       ; Data int enable bit.
TIMER_INT_ENAB  EQU     00010000b       ; Timer int enable bit.
HOLD_BIT        EQU     00100000b       ; Hold bit.

BUTTON_1_BIT    EQU     00000100b       ; Bit indicating button 1.
BUTTON_3_BIT    EQU     00000001b       ; Bit indicating button 3.
MOVEMENT_BIT    EQU     01000000b       ; Bit indicating movement.

INPORT_FIRST_PORT EQU   23Ch            ; Address of primary InPort.
INPORT_LAST_PORT EQU    230h            ; Address of secondary InPort.

MACH20_IRQ      EQU     0Ch             ; IRQ used for Mach 20 InPort
                                        ; under Mach 20 OS/2.

;****************************************************************
;               B U S   D E F I N I T I O N S                   *
;****************************************************************
; Since the Adaptor for the bus mouse is based on an 8255A, we have to
;       program the 8255A properly in order to function. We need to select:
;
;       Mode 0 (for all ports).
;       Port A (input - this allows us to read information from the ALPS
;               chip and from the buttons)
;       Port B (output - this allows us to write a value there and then
;               read it back in. It is not connected to anything)
;       Port C, upper half (output - this allows us to send control
;               information to the ALPS chip)
;       Port C, lower half (input - this allows us to poll the current states
;               of IRQs 2, 3, 4, and 5)
;
; The value that does this is
;
;       10010001
;       ||||||||-----   Port C Lower is input
;       |||||||------   Port B is output
;       ||||||-------   Mode 0 for Group B (Port B and lower half of Port C)
;       |||||--------   Port C Upper is output
;       ||||---------   Port A is input
;       |------------   Mode 0 for Group A (Port A and upper half of Port C)
;       -------------   Mode set control word
;

BUS_MOUSE_BASE  EQU     023Ch           ; Base I/O addr of bus mouse.

BUS_DATA        EQU     BUS_MOUSE_BASE  ; Port where mouse data is read from.
BUS_SIG         EQU     BUS_MOUSE_BASE + 1 ; Port unused for mouse, used for de-
                                        ; termining existence of bus adaptor.
BUS_CONTROL     EQU     BUS_MOUSE_BASE + 2 ; Port used to control adaptor.
BUS_INIT        EQU     BUS_MOUSE_BASE + 3 ; Port used to init bus adaptor.

BUS_INIT_VALUE  EQU     10010001b       ; Value used to init bus adaptor.

LOW_X           EQU     090h            ; Cmd to read low 4 bits of delta X
HI_X            EQU     0B0h            ; Cmd to read high 2 bits of delta X
LOW_Y           EQU     0D0h            ; Cmd to read low 4 bits of delta Y
HI_Y            EQU     0F0h            ; Cmd to read high 2 bits of delta Y

;************************************************************************
;               S E R I A L     D E F I N I T I O N S                   *
;************************************************************************

SERIAL_PACKETSIZE       EQU     3       ; Bytes in a packet of data.

SYNC_BIT                EQU     40H     ; Bit 6 is the sync bit

;
; These are the offsets within the COM chip of the various registers.
;

TXB             EQU     0               ; Transmit buffer
RXB             EQU     0               ; Receive buffer
LATLSB          EQU     0               ; Divisor latch, LSB
LATMSB          EQU     1               ; Divisor latch, MSB
IER             EQU     1               ; Interrupt enable register
IIR             EQU     2               ; Interrupt identification register
LCR             EQU     3               ; Line control register
MCR             EQU     4               ; Modem control register
LSR             EQU     5               ; Line status register
MSR             EQU     6               ; Modem status register

IFDEF NEC_98
BASE_8251_NEC   EQU     30h             ; Base I/O address of 8251 serial controller
BASE_16550_NEC  EQU     238h            ; Base I/O address of 16550 serial controller

DATA_8251       EQU     BASE_8251_NEC       ; Port used to data read/write.
MODE_8251       EQU     BASE_8251_NEC + 2   ; Port used to set mode.
COMMAND_8251    EQU     BASE_8251_NEC + 2   ; Port used to write command.
STATUS_8251     EQU     BASE_8251_NEC + 2   ; Port used to read status.
SIGNAL_READ_8251 EQU    BASE_8251_NEC + 3   ; Port used to read signal.
MASK_8251       EQU     BASE_8251_NEC + 5   ; Port used to set mask.

BAUD_MODE_NEC   EQU     77h             ; Port used to set mode for baud rate.
BAUD_COUNT_NEC  EQU     75h             ; Port used to write baud rate.

SPEAKER_CONTROL_PORT EQU 37h
SPEAKER_OFF          EQU 07h
SPEAKER_ON           EQU 06h
WAIT1S               EQU 90000h
ENDIF ;NEC_98
;
; These give the number of milliseconds to wait while waiting for the serial
;       mouse to reset itself. We will first use the value given by SHORTDELAY
;       and if that fails, we will then use the value given by LONGDELAY.
;

SHORTDELAY      EQU     6        ; 350  msecs  = 350/55.5  = 6  clock ticks.
LONGDELAY       EQU     18       ; 1000 msecs  = 1000/55.5 = 18 clock ticks.

;
; These are the values that are written into the divisor latch for the
;       various baud rates. They are obtained by dividing the clock rate
;       (1.8432 MHz) by 16x the desired baud rate.
;

DIV_50          EQU     900h
DIV_75          EQU     600h
DIV_110         EQU     417h
DIV_150         EQU     300h
DIV_300         EQU     180h
DIV_600         EQU     0C0h
DIV_1200        EQU     060h
DIV_1800        EQU     040h
DIV_2000        EQU     03Ah
DIV_2400        EQU     030h
DIV_3600        EQU     020h
DIV_4800        EQU     018h
DIV_7200        EQU     010h
DIV_9600        EQU     00Ch

;
;** Interrupt enable masks
;

IE_RX           EQU     00000001b       ; read data available
IE_TX           EQU     00000010b       ; transmit buffer empty
IE_LX           EQU     00000100b       ; line status change
IE_MX           EQU     00001000b       ; modem status change

;
;** Line control masks
;

LC_BMASK        EQU     00000011b       ; data bits mask
LC_BITS5        EQU     00000000b       ; 5 data bits
LC_BITS6        EQU     00000001b       ; 6 data bits
LC_BITS7        EQU     00000010b       ; 7 data bits
LC_BITS8        EQU     00000011b       ; 8 data bits

LC_SMASK        EQU     00000100b       ; stop bits mask
LC_STOP1        EQU     00000000b       ; 1 stop bit
LC_STOP2        EQU     00000100b       ; 2 stop bits (1.5 if 5 data bits)

LC_PMASK        EQU     00111000b       ; parity mask
LC_PNONE        EQU     00000000b       ; none parity
LC_PODD         EQU     00001000b       ; odd parity
LC_PEVEN        EQU     00011000b       ; even parity
LC_PMARK        EQU     00101000b       ; mark parity
LC_PSPACE       EQU     00111000b       ; space parity

LC_BREAK        EQU     01000000b       ; transmit break
LC_DLAB         EQU     10000000b       ; divisor latch access bit
LC_MASK         EQU     01111111b       ; documented line control register bits

;
;** Modem control register masks
;

MC_DTR          EQU     00000001b       ; data terminal ready
MC_RTS          EQU     00000010b       ; request to send
MC_OUT1         EQU     00000100b       ; output 1
MC_OUT2         EQU     00001000b       ; output 2
MC_LOOP         EQU     00010000b       ; loopback mode

;
;** Line status register masks
;

LS_DR           EQU     00000001b       ; data ready
LS_OERR         EQU     00000010b       ; overrun error
LS_PERR         EQU     00000100b       ; parity error
LS_FERR         EQU     00001000b       ; framing error
LS_BI           EQU     00010000b       ; break interrupt
LS_THRE         EQU     00100000b       ; TX holding register empty
LS_TSRE         EQU     01000000b       ; TX shift register empty

;
;** Modem status register definitions:
;

MS_DCTS         EQU     00000001b       ; delta clear to send
MS_DDSR         EQU     00000010b       ; delta data set ready
MS_TERI         EQU     00000100b       ; trailing edge of ring indicator
MS_DDCD         EQU     00001000b       ; delta receiver line signal detect
MS_CTS          EQU     00010000b       ; clear to send
MS_DSR          EQU     00100000b       ; data set ready
MS_RI           EQU     01000000b       ; ring indicator
MS_DCD          EQU     10000000b       ; receiver line signal detect

;************************************************************************
;               8 2 5 9 A  D E F I N I T I O N S                        *
;************************************************************************

MASTER_MASK_ADDR EQU     021h            ; Master's mask register addr.
SLAVE_MASK_ADDR  EQU     0A1h            ; Slave's mask register addr.
IRQS_PER_8259    EQU     8               ; # IRQs on each 8259A.
SELECT_IRR       EQU     0Ah             ; Selects int request register.
SELECT_ISR       EQU     0Bh             ; Selects in service register.

;****************************************************************
;               P S / 2   D E F I N I T I O N S                 *
;****************************************************************

PS2_IRQ         EQU     0Ch             ; Always IRQ 12 for PS/2 mouse.
PS2_IRQ_MASK    EQU     00010000b       ; Bit mask for IRQ 12.
PS2_PACKETSIZE  EQU     3               ; Bytes in a packet of data.

DX_SIGN         EQU     00010000b       ; Bit 4 is dx sign bit in status byte
DY_SIGN         EQU     00100000b       ; Bit 5 is dy sign bit in status byte

PS2_25PPI       EQU     0               ; Value to set resolution to 25 ppi.
PS2_50PPI       EQU     1               ; Value to set resolution to 50 ppi.
PS2_100PPI      EQU     2               ; Value to set resolution to 100 ppi.
PS2_200PPI      EQU     3               ; Value to set resolution to 200 ppi.


MOUSE_RESET      EQU     0FFh            ; Reset mouse command
MOUSE_RESEND     EQU     0FEh            ; Resend data to mouse
MOUSE_DIAG_ERR   EQU     0FCh            ; Error on mouse diagnostics
MOUSE_ACK        EQU     0FAh            ; Acknowledge
MOUSE_DEFAULT    EQU     0F6h
MOUSE_DISABLE    EQU     0F5h            ; Disable Mouse command
MOUSE_ENABLE     EQU     0F4h            ; Enable Mouse command
MOUSE_RATE       EQU     0F3h            ; Set sampling rate
MOUSE_READ_TYPE  EQU     0F2h            ; Read device type
MOUSE_REMOTE     EQU     0F0h            ; Set remote mode
MOUSE_ECHO       EQU     0EEh            ; Set wrap mode
MOUSE_KILL_ECHO  EQU     0ECh            ; reset wrap mode
MOUSE_READDATA   EQU     0EBh            ; Read mouse data
MOUSE_STREAM     EQU     0EAh            ; Set stream mode
MOUSE_STATUS     EQU     0E9h            ; Status Request
MOUSE_RESOLUTION EQU     0E8h            ; Set Resolution
MOUSE_SCALE_2_1  EQU     0E7h            ; Set scaling 2 to 1
MOUSE_SCALE_1_1  EQU     0E6h            ; Set scaling 1 to 1
MOUSE_DIAG_OK    EQU     0AAh            ; Diagnostics ok
MOUSE_DIAG_ID    EQU     000h            ; Diagnostic ID number

;
; The following codes are specific to the Microsoft PS/2 mouse
;

MOUSE_MS_VERS    EQU     052h            ; Read current firmware version number
MOUSE_MS_INPORT  EQU     056h            ; Read raw InPort data
MOUSE_MS_DIAG    EQU     059h            ; enter MS diagnostices mode
MOUSE_MS_READRAM EQU     05Bh            ; read ram byte

;****************************************************************
;               8 0 4 2  D E F I N I T I O N S                  *
;****************************************************************

;
; 8042 port definitions.
;

DATA_8042       EQU     60h             ; Port where data is sent to/from 8042.
CONTROL_8042    EQU     64h             ; Port where commands are sent to 8042.
STATUS_8042     EQU     64h             ; Port where status is read from 8042.
CRT_DATA_SEG    EQU     40H             ; ROM BIOS CRT Data Segment Address

;
; Status register bit definitions.
;

OUTPUT_BUFFER_FULL      EQU     01h     ; 8042's output buffer is full.
INPUT_BUFFER_FULL       EQU     02h     ; 8042's input buffer is full.
AUX_OUTPUT_BUFFER_FULL  EQU     20h     ; 8042's aux output buffer is full.

;
; Command byte bit definitions.
;

AUX_DISABLED    EQU     20h             ; Auxiliary interface is disabled.
AUX_INT_ENABLE  EQU     02h             ; Auxiliary interrupts are enabled.
KBD_INT_ENABLE  EQU     01H             ; Keyboard interrupt enabled.
;
; 8042 commands.
;

CMD8042_READ_CMD EQU    020h            ; Read command byte.
CMD8042_WRITE_CMD EQU   060h            ; Write command byte.
CMD8042_DISABLE_AUX EQU 0A7h            ; Disable auxiliary interface.
CMD8042_ENABLE_AUX EQU  0A8h            ; Enable auxiliary interface.
CMD8042_TEST_AUX EQU    0A9h            ; Test auxiliary interface.
CMD8042_DISABLE_KBD EQU 0ADh            ; Disable keyboard.
CMD8042_ENABLE_KBD EQU  0AEh            ; Enable keyboard.
CMD8042_WRITE_AUX EQU   0D4h            ; Send data to auxiliary device.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\mousea.asm ===
title  "Mouse detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mouse.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    various mouse in the system.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 10-Dec-1991.
;    Most of the code is taken from win31 setup code(with modification.)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include mouse.inc
        .list

.386
extrn                _Empty8042:proc
extrn                Write8042:proc
extrn                ReadKeyboard:proc
extrn                _ComPortAddress:word
extrn                _DisableSerialMice:word
extrn                _FastDetect:byte

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

LATLSBSave           db  ?
LATMSBSave           db  ?
LCRSave              db  ?
MCRSave              db  ?
IERSave              db  ?
fSingle8259          db  0
DWFinalCount         dw  2 dup (0)
DWCurrCount          dw  2 dup (0)

NextComPort          dw      0               ; Offset into ComPortAddress[]
MouseInfo            MouseInformation        <0, 0, 0FFFFh, 0FFFFh, 0>

;
; MouseDetected is used to indicate if any mouse has been detected.
;

MouseDetected   dw      0               ; initialize to no
InPortIoBase    dw      0               ; The Base addr for inport mouse

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING


;++
;
; USHORT
; LookForPS2Mouse (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines mouse type in the system.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (eax): mouse Id.
;
;--

        public  _LookForPS2Mouse
_LookForPS2Mouse proc    near
        push    bx
        push    si
        push    di

        mov     si, offset MouseInfo
        lea     si, [si].DeviceId

        call    _Empty8042

        int     11h
        test    ax, 4                   ; is bit 2 set?
        jz      No_PS2_Mouse            ; No, no PS/2 mouse.

        xor     di, di

;
; Shortcut the rest of the detection and mouse reset if fast detect is set.
;

        cmp     _FastDetect, 0
        jne     short Is_PS2_Mouse

;
; Old Olivetti M400-60 and M400-40 will have trouble reading floppy
; and hard disk if the following call is made .
;

        mov     ax, 0c201h              ; reset PS/2 mouse
        int     15h
        jc      short No_PS2_Mouse
        jmp     short Is_PS2_Mouse

        mov     bh, 03                  ; Packet size = 3 bytes
        mov     ax, 0c205h              ; init point device interface
        int     15h
        jc      short No_PS2_Mouse

        mov     ax, 0c201h              ; reset PS/2 mouse
        int     15h
        jc      short No_PS2_Mouse

        call    _Empty8042

;
; The following sequence of Int 15h calls will determine if a Logitech
; PS/2 mouse is present.  This information was obtained from Logitech.
;

        mov     ax,0C203h               ; Set resolution to 1 cnt/mm
        mov     bh,0h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Get status
        mov     bh,0h
        int     15h
        jc      Is_PS2_Mouse

        or      cl,cl                   ; Is resolution 1 cnt/mm?
        jz      Is_PS2_Mouse               ; Yes, then not a Logitech.

;
; If cl is not zero (i.e. 1 cnt/mm) then it is the number of buttons
; and we've found a Logitech 3-button PS/2 mouse
;

LT_PS2_Mouse:
        mov     ax,LT_MOUSE + PS2_MOUSE
        jmp     short PS2MouseFound

Is_PS2_Mouse:
        mov     ax,MS_MOUSE + PS2_MOUSE
        jmp     short PS2MouseFound

No_PS2_Mouse:
        mov     bx, 0
        jmp     ExitPs2Mouse

PS2MouseFound:

;
; Set mouse type and subtype to mouse info structure
;

        mov     bx, offset MouseInfo
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MouseIrq, 12
        mov     [bx].MousePort, 0ffffh
        mov     [bx].DeviceIdLength, di
        mov     MouseDetected, bx

ExitPs2Mouse:

;
; Drain 8042 input buffer and leave leave pointing device disabled.
; We don't want user moves the mouse and hangs the system.
;

        call    _Empty8042
        mov     ax, bx
        pop     di
        pop     si
        pop     bx
        ret

_LookForPS2Mouse endp

;++
;
; USHORT
; LookForInportMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines mouse type in the system.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (eax): mouse Id.
;
;--

        public  _LookForInportMouse
_LookForInportMouse     proc    near

        push    bx
        mov     dx,INPORT_FIRST_PORT + 2 ; Get address of ID register.

inport_try_again:
        call    TestForInport           ; Does an InPort exist at this address?
        jnc     inport_found            ; No carry ! Inport found !

        sub     dx,4                    ; Nope, try the next possible port.
        cmp     dx,INPORT_LAST_PORT + 2
        jae     inport_try_again

        mov     ax, 0                   ; Fail to detect inport mouse
        jmp     short no_inport

inport_found:

;
; Set mouse type and subtype to mouse info structure
;

        mov     ax,MS_MOUSE + INPORT_MOUSE
        mov     cx, dx
        sub     cx, 2
        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, cx
        mov     InportIoBase, cx
        mov     MouseDetected, bx
        lea     ax, [bx].MouseIrq
        push    ax
        push    cx                      ; Current Port
        call    _InportMouseIrqDetection
        add     sp, 4
        mov     ax, offset MouseInfo

no_inport:
        pop     bx
        ret

_LookForInportMouse endp

;++
;
; USHORT
; LookForBusMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a bus mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

        public  _LookForBusMouse
_LookForBusMouse proc    near

;
; If We already found Inport mouse and its IO base is 23ch, it is
; impossible to have a BUS mouse.
;

        cmp     InportIoBase, BUS_MOUSE_BASE
        jne     short @f
        mov     ax, 0
        ret

@@:
        push    bx

;
; We determine if the bus mouse adaptor is present by attempting to
;       program the 8255A, and then seeing if we can write a value out to
;       Port B on the 8255A and get that value back. If we can, we assume
;       that we have a bus mouse adaptor.
;

        mov     dx,BUS_INIT             ; Get address of 8255A control port.
        mov     al,BUS_INIT_VALUE       ; Get proper value.
        DelayOut                        ; Set up 8255A.
        mov     ax,0A5A5h               ; Get a signature byte.
        address BUS_SIG BUS_INIT        ; Get address of Port B.
        DelayOut                        ; Set Port B with signature.
        DelayIn                         ; Read back Port B.

        cmp     al,ah                   ; Does it match signature byte?
        jne     No_Bus_Mouse            ; Nope - no bus mouse adaptor

        mov     ax,MS_MOUSE + BUS_MOUSE
        jmp     short Bus_Mouse_Found

No_Bus_Mouse:
        mov     ax, 0                   ; No Bus Mouse detected
        jmp     short Bus_Exit

Bus_Mouse_Found:

;
; Set mouse type and subtype to mouse info structure
;

        mov     dx, BUS_MOUSE_BASE
        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, dx
        mov     MouseDetected, bx
        call    BusMouseIrqDetection
        mov     [bx].MouseIrq, ax       ; if (ax) = 0xffff, no irq detected
        mov     ax, offset MouseInfo    ; return MouseInfor
Bus_Exit:
        pop     bx
        ret

_LookForBusMouse endp

;++
;
; USHORT
; BusMouseIrqDetection (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find the irq level associated with the
;    Bus mouse in the machine.
;
; Arguments:
;
;    (dx) = Bus mouse base I/O port.
;
; Return Value:
;
;    (ax) = Irq level.  if (ax)= 0xffff, detection failed.
;
;--

BusMouseIrqDetection    proc    near

        push    bx

        add     dx, 2                   ; use adaptor control port
        in      al,dx                   ; Get irq 2-5 states
        IOdelay
        mov     ah,al                   ; Save states
        mov     cx,10000                ; Set loop count
        xor     bh,bh                   ; Clear changes buffer

@@:
        in      al,dx                   ; Get current states of irq 2-5
        IOdelay
        xor     ah,al                   ; Compare with last state
        or      bh,ah                   ; Mark any changes
        mov     ah,al                   ; Previous := current state
        loop    @B                      ; Keep looking

        mov     ax, 0ffffh
        or      bh,bh                   ; Any irq found?
        jz      short BusIntExit        ; Branch if no interrupt was found

BusIntFound:
        mov     ax,5                    ; Assume irq5
        test    bh,0001b                        ; Is it off?
        jnz     short BusIntExit        ; Yes..have irq5
        mov     ax,2                    ; Assume irq2
        test    bh,1000b
        jnz     short BusIntExit
        inc     ax                      ; Try irq3
        test    bh,0100b
        jnz     short BusIntExit
        inc     ax                      ; Must be irq4

BusIntExit:                             ; ax contains the IRQ number
        pop     bx
        ret

BusMouseIrqDetection    endp


;++
;
; USHORT
; LookForSerialMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a serial mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

        public  _LookForSerialMouse
_LookForSerialMouse     proc    near

        push    di
        push    bx

        mov     di, NextComPort         ; Get untested comport
        cmp     di, 8                   ; Have we over the comport limit?
        jae     short No_Serial_Mouse   ; if above or e, yes, exit

serial_try_again:
        mov     cx, di
        mov     al, 1
        shr     cx, 1
        inc     cx
        shl     ax, cl
        test    _DisableSerialMice, ax  ; Should we skip this com port?
        jnz     short serial_next_port  ; yes, try next one.

        mov     dx, _ComPortAddress[di] ; Get base address of COM port to test.
        or      dx,dx                   ; Does this port exist?
        jz      serial_next_port        ; No, try next one.

serial_test_port:

;
; The comport address is initialized by com detection routine.  if the port
; value is not zero, it means that the port exist.
;

        call    TestForSerial           ; Is a serial mouse attached to port?
        cmp     ax,NO_MOUSE
        jne     Serial_Mouse_Found      ; Yes! found a serial mouse

serial_next_port:                       ; No serial mouse on this COM port.
        add     di,2                    ; move to the next possible port
        cmp     di,8                    ; Are we over com limit?
        jb      serial_try_again        ; if b, no, go test it.

        mov     NextComport, di
No_Serial_Mouse:
        mov     ax, 0                   ; No serial mouse detected
        jmp     short SerialMouseExit

Serial_Mouse_Found:
        mov     NextComport, di
        add     NextComport, 2          ; Next comport to test

        shr     di, 1                   ; divide di by 2

;
; Set mouse type and subtype to mouse info structure
;

        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        cmp     ax, MS_MOUSE + SERIAL_MOUSE_WITH_WHEEL
        jnz     short @f

        mov     [bx].DeviceIdLength, 7
@@:
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, di
        mov     [bx].MouseIrq, 0ffffh
        mov     MouseDetected, bx
        mov     ax, bx

SerialMouseExit:
        pop     bx
        pop     di
        ret

_LookForSerialMouse endp


;++
;
; BOOLEAN
; TestForInport (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find an InPort mouse at the given base
;    I/O address. Note that if an InPort is found, it will be left
;    in a state where it will not be generating any interrupts.
;
; Arguments:
;
;    Port (DX) - I/O address of Inport identification register.
;
; Return Value:
;
;    NC - An Inport was found
;    CY - No Inport was found
;
;--

TestForInport   PROC    NEAR

        push    bx
        push    si

;
; Since the identification register alternates between returning back
;       the Inport chip signature and the version/revision, if we have an
;       InPort chip, the chip signature will be read in one of the following
;       two reads. If it isn't, we do not have an InPort chip.
;

        mov     bl,INPORT_ID
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Is value the InPort chip signature?
        je      possible_inport         ; Yes, go make sure we have an InPort.
        in      al,dx                   ; Read ID register again.
        cmp     al,bl                   ; Is value the InPort chip signature?
        jne     inport_not_found        ; No, return error

;
; At this point, we managed to read the InPort chip signature, so we have
;       a possible InPort chip. The next read from the ID register will
;       return the version/revision. We then make sure that the ID register
;       alternates between the chip signature and this version/revision. If
;       it does, we have an InPort chip.
;

possible_inport:
        in      al,dx                   ; Read version/revision.
        mov     ah,al                   ; Save it.
        mov     cx,5                    ; Test ID register 5 times.

inport_check:
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Make sure it is the chip signature.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        in      al,dx                   ; Read ID register.
        cmp     al,ah                   ; Make sure version/revision is same.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        loop    inport_check            ; Test desired number of times.

        clc
        pop     si
        pop     bx
        ret
;
; At this point, we know we have an InPort chip.
;

inport_not_found:                       ; We don't have an InPort chip.
        stc                             ; Show failure.
        pop     si
        pop     bx
        ret                             ; Return to caller.

TestForInport   ENDP


;++
;
; BOOLEAN
; TestForSerial (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a serial mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    (dx) = Port Address.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

TestForSerial   PROC    NEAR

      call      SaveCOMSetting

      call      SetupCOMForMouse        ; Set up COM port to talk to mouse.

      mov       cx,SHORTDELAY           ; Use a short delay time.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

;
; If a mouse has been detected, most likely there won't be second mouse.
; so we don't test for LONGDELAY to save some time
;

      cmp       MouseDetected, 0
      jne       short @f

      mov       cx,LONGDELAY            ; Maybe the mouse is just slow.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

@@:
      call      TestForLogitechSerial   ; Maybe it's a Logitech Series C

TFS_Found:
      push      ax                      ; Save return value
      call      RestoreCOMSetting
      pop       ax
      ret

TestForSerial   ENDP


;++
;
; VOID
; SaveCOMSetting (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will save the current state of the COM port given.
;
; Arguments:
;
;    Port (DX) - Base address of COM port.
;
; Return Value:
;
;    None.
;
;--

SaveCOMSetting  PROC    NEAR

        push    dx                      ; Save base I/O address.
        address LCR RXB                 ; Get address of Line Control Register.
        DelayIn                         ; Get current contents.
        mov     [LCRSave],al            ; Save them.
        or      al,LC_DLAB              ; Set up to access divisor latches.
        DelayOut
        address LATMSB LCR              ; Get address of high word of divisor
        DelayIn                         ; latch and save its current contents.
        mov     [LATMSBSave],al
        address LATLSB LATMSB           ; Get address of low word of divisor
        DelayIn                         ; latch and save its current contents.
        mov     [LATLSBSave],al
        address LCR LATLSB              ; Get address of Line Control Register
        mov     al,[LCRSave]            ; and disable access to divisor.
        and     al,NOT LC_DLAB
        DelayOut
        address MCR LCR                 ; Get address of Modem Control Register
        DelayIn                         ; and save its current contents.
        mov     [MCRSave],al
        address IER MCR                 ; Get address of Interrupt Enable Reg-
        DelayIn                         ; ister and save its current contents.
        mov     [IERSave],al
        pop     dx                      ; Restore base I/O address.
        ret

SaveCOMSetting  ENDP


;++
;
; VOID
; RestoreCOMSetting (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will restore the current state of the COM port given.
;
; Arguments:
;
;    Port (DX) - Base address of COM port.
;
; Return Value:
;
;    None.
;
;--

RestoreCOMSetting       PROC    NEAR

      push      dx                      ; Save base I/O address.
      address   LCR RXB                 ; Get address of Line Control Register.
      mov       al,LC_DLAB              ; Set up to access divisor latches.
      DelayOut
      address   LATMSB LCR              ; Get address of high word of divisor
      mov       al,[LATMSBSave]         ; and restore it.
      DelayOut
      address   LATLSB LATMSB           ; Get address of low word of divisor
      mov       al,[LATLSBSave]         ; and restore it.
      DelayOut
      address   LCR LATLSB              ; Get address of Line Control Register
      mov       al,[LCRSave]            ; and restore it, disabling access to
      and       al,NOT LC_DLAB          ; the divisor latches.
      DelayOut
      address   MCR LCR                 ; Get addres of Modem Control Register
      mov       al,[MCRSave]            ; and restore it.
      DelayOut
      address   IER MCR                 ; Get address of Interrupt Enable Reg-
      mov       al,[IERSave]            ; ister and restore it.
      DelayOut
      pop       dx                      ; Restore base I/O address.
      ret

RestoreCOMSetting       ENDP


;++
;
; VOID
; SetupCOMForMouse (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will set up the given COM port so that it can talk to
;    a serial mouse.
;
; Arguments:
;
;    Port (DX) - Base address of COM port to set up.
;
; Return Value:
;
;    COM port set up, all interrupts disabled at COM port
;
;--

SetupCOMForMouse        PROC    NEAR

        push    dx                      ; Save base I/O address.
        mov     cx, 60h
        call    SetBaudRate

        address LCR RXB
        mov     al,LC_BITS7 + LC_STOP1 + LC_PNONE
        DelayOut                        ; Set 7,n,1; disable access to divisor.
        address IER LCR                 ; Get address of Int. Enable Register
        xor     al,al                   ; Disable all interrupts at the COM
        DelayOut                        ; port level.
        address LSR IER                 ; Get address of Line Status Reg.
        DelayIn                         ; Read it to clear any errors.
        pop     dx                      ; Restore base I/O address
        ret

SetupCOMForMouse        ENDP


;++
;
; USHORT
; ResetSerialMouse (
;    USHORT Port,
;    USHORT Delay
;    )
;
; Routine Description:
;
;    This procedure will reset a serial mouse on the given COM port and will
;    return an indication of whether a mouse responded or not.
;
;    The function now also checks for the presence of a 'B' as well as an
;    'M' to determine the presence of a pointing device.  Also, if the 'M' is
;    followed by a '3' the serial mouse is a Logitech.
;
;    Mouse     returns M
;    Ballpoint returns B
;
; Arguments:
;
;    Port (DX) - Base I/O address of COM port to use
;    Delay (CX) - Number of msecs to use for delays
;
; Return Value:
;
;    (ax) = Mouse Type.
;
;--

ResetSerialMouse PROC NEAR

      push      dx                  ; Save environment.
      push      si
      push      di
      push      es

      address   IER RXB             ; Get address of Interrupt Enable Reg.
      DelayIn                       ; Get current contents of IER and
      push      ax                  ; save them.
      push      dx                  ; Save address of IER.
      xor       al,al               ; Disable all interrupts at the
      DelayOut                      ; COM port level.

      address   MCR IER             ; Get address of Modem Control Reg.
      mov       al,MC_DTR           ; Set DTR active; RTS, OUT1, and OUT2
      DelayOut                      ; inactive. This powers down mouse.

      push      cx                  ; Save amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.

      address   RXB MCR             ; Get address of Receive Buffer.

;
; Now, we wait the specified amount of time, throwing away any stray
; data that we receive. This gives the mouse time to properly reset
; itself.
;

rsm_waitloop:
      in        al, dx              ; Read and ignore any stray data.
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       rsm_waitloop        ; If not, keep waiting.

;
; Wait is over.
;

      address   LSR RXB             ; Get address of Line Status Reg.
      DelayIn                       ; Read it to clear any errors.
      address   MCR LSR             ; Get address of Modem COntrol Reg.
      mov       al,MC_DTR+MC_RTS    ; Set DTR, RTS, and OUT2 active
                                         ; OUT1 inactive.
      DelayOut                      ; This powers up the mouse.

      pop       cx                  ; Get amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; the upcoming delay loop.

;
; We give the mouse the specified amount of time to respond by sending
; us an M. If it doesn't, or we get more than 5 characters that aren't
; an M, we return a failure indication.
;

      address   LSR MCR             ; Get address of Line Status Reg.
      mov       si, 5               ; Read up to 5 chars from port.
      mov       bl,'3'              ; '3' will follow 'M' on Logitech.
      mov       bh,'B'              ; 'B' for BALLPOINT
      mov       ah,'M'              ; Get an M. (We avoid doing a cmp al,M
                                    ; because the M could be left floating
                                    ; due to capacitance.)
rsm_getchar:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar         ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_getchar         ; Haven't timed out; keep looking.

      mov       bx,NO_MOUSE
      jmp       rsm_leave           ; Timed out. Leave with NO_MOUSE.

rsm_gotchar:

      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,ah               ; Is it an M?
      jne       check_for_b

;
; We received an 'M', now wait for next character to see if it is a '3'.
;

      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
      address   LSR RXB

rsm_waitfor3:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar3        ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_waitfor3        ; Haven't timed out; keep looking.

;
; Not a Logitech - must be a standard Microsoft compatible serial mouse.
;

      jmp       rsm_notLT

rsm_gotchar3:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,bl               ; Is it a 3?
      jne       short rsm_check_for_z

      mov       bx,LT_MOUSE + SERIAL_MOUSE ; Yes, we've found a Logitech M+
      jmp       rsm_leave           ;   series, 3 button mouse

rsm_check_for_z:

;
; Determine if this is Microsoft mouse with wheel.
; 'M', 'Z', 0x40, 0x00, 0x00, 0x00, PnP String
;
      cmp       al, 'Z'
      jnz       rsm_notLT

;
; Check for 0x40, 0x00, 0x00, 0x00
;

      mov       ebx, 040h
      mov       cx, 4
      address   LSR RXB
rsm_get_byte:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,bl               ; Is it a MS wheel?
      jnz       rsm_notMZ

      shr       ebx, 8
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte

;
; Next read PnP string for the MS wheel mouse
; First skip 3 bytes: 08 + 2-byte Rev number
;

      mov       cx, 3
rsm_get_byte1:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte1

;
; Next read 7 bytes PnpDevice id

      mov       si, offset MouseInfo
      lea       si, [si].DeviceId

      mov       cx, 7
rsm_get_byte2:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      mov       [si], al
      inc       si
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte2

      mov       byte ptr [si], 0    ; add device id terminated null
      mov       bx, MS_MOUSE + SERIAL_MOUSE_WITH_WHEEL
      jmp       short rsm_leave     ; We still have a standard serial mouse.

rsm_notMZ:
      pop       cx
rsm_notLT:
      mov       bx,MS_MOUSE + SERIAL_MOUSE ; We didn't get the '3' after the 'M'
      jmp       short rsm_leave     ; We still have a standard serial mouse.

check_for_b:
      cmp       al,bh               ; Is it a B?
      jne       rsm_next_char

      mov       bx,MS_BALLPOINT + SERIAL_MOUSE ; We've found a BallPoint Mouse
      jmp       short rsm_leave

rsm_next_char:
      address   LSR RXB             ; Oh well. Get address of LSR again.
      dec       si                  ; Have we read 5 chars yet?
      jnz       rsm_getchar         ; Nope, we'll give him another try.

;
; We've read many characters - No a single 'M' or 'B' in the lot.
;

      mov       bx,NO_MOUSE

rsm_leave:
      pop       dx                  ; Get address of IER.
      pop       ax                  ; Get old value of IER.
      DelayOut                      ; Restore IER.

      pop       es                  ; Restore environment.
      assume    es:nothing
      pop       di
      pop       si
      pop       dx
      mov       ax,bx               ; Set return value.
      ret

ResetSerialMouse        ENDP


;++
;
; VOID
; SetupForWait (
;    USHORT WaitTime
;    )
;
; Routine Description:
;
;    This procedure accepts the number of milliseconds that we will want
;    to delay for and will set things up for the wait.
;
; Arguments:
;
;    (CX) = Number of clock ticks to wait for.
;
; Return Value:
;
;    None.
;
;--

SetupForWait    PROC    NEAR

      push      ax                  ; Do your saving !
      push      es

      xor       ax,ax
      mov       es,ax               ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount+2]
      mov       [DWFinalCount+2],ax       ; Save ending time (HiWord)
      mov       ax,es:[LW_ClockTickCount] ; Get tick count in AX.
      sti

      add       ax,cx               ; [Current + delay] = delay ends.
      mov       [DWFinalCount],ax   ; Save ending time (LoWord)
      jnc       SFW_End

      inc       [DWFinalCount+2]

SFW_End:
      pop       es                  ; Restore now !
      pop       ax

      ret

SetupForWait    ENDP


;++
;
; BOOLEAN
; IsWaitOver (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure accepts the current time and the ending time and
;    return and indication of whether the current time is past
;    the ending time.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    carry clear     Current time is not past ending time
;    carry set       Current time is past ending time
;
;--

IsWaitOver PROC NEAR

if 0
      push      ax                            ; Preserve AX
      push      es                            ; Preserve ES
      xor       ax,ax
      mov       es,ax                         ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount]
      mov       [DWCurrCount],ax              ; Save current time (LoWord)
      mov       ax,es:[LW_ClockTickCount+2]   ; Get tick count in AX.
      sti

      cmp       [DWFinalCount+2],ax           ; Compare HiWords
      ja        WaitNotOver                   ; Carry will be clear if wait
                                              ;   is not over.
      mov       ax,es:[LW_ClockTickCount]     ; Compare Lowords
      cmp       [DWFinalCount],ax             ; This will set CY accordingly

WaitNotOver:
      pop       es                            ; Restore ES
      pop       ax                            ; Restore AX
      ret

else

      push      ax                            ; Preserve AX
      push      es                            ; Preserve ES
      xor       ax,ax
      mov       es,ax                         ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount]
      mov       [DWCurrCount],ax              ; Save current time (LoWord)
      mov       ax,es:[LW_ClockTickCount+2]   ; Get tick count in AX.
      sti

      cmp       [DWFinalCount+2],ax           ; Compare HiWords
      jb        WaitExit                      ; Time is up

      jne       WaitRollCheck                 ; If not equal check for

WaitLowCheck:
      mov       ax,[DWCurrCount]              ; Compare Lowords
      cmp       [DWFinalCount],ax             ; This will set CY accordingly

WaitExit:
      pop       es                            ; Restore ES
      pop       ax                            ; Restore AX
      ret


WaitRollCheck:

; If the current time is less than the wait time we must check for
; roll over.  There are 18.2 * 60 * 60 * 24 or 0x1800b0 clock ticks in
; a day.  At midnight the counter rolls over to zero.

      cmp       ax,0
      jne       WaitExit                      ; If current HiWord is not 0,
                                              ;  no roll over.  Exit with
                                              ;  carry clear.

      cmp       [DWFinalCount+2],18h          ; Is Final HiWord 0x18
      je        short @f                      ; Yes, check LoWord for wrap.
      clc                                     ; No, no roll over.  Exit with
                                              ;  carry clear.
      jmp       WaitExit

@@:
      mov       ax,[DWFinalCount]             ; Get final LoWord
      sub       ax, 0b0h                      ; Check for wrap
      jb        WaitExit                      ; No, no roll over.  Exit with
                                              ;  cary set

; At this point we have determined that we have wrapped and that the
; ending time is into the next day.  Update the ending time

      mov       [DWFinalCount],ax             ; Set final LoWord
      xor       ax,ax
      mov       [DWFinalCount+2],ax           ; Zero final HiWord
      jmp       WaitLowCheck                  ; Check LoWord

endif

IsWaitOver ENDP


;++
;
; USHORT
; TestForLogitechSerial (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will detect the presence of a Logitech Series C
;    serial mouse is present
;
; Arguments:
;
;    (edx) = Port Address
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--


TestForLogitechSerial PROC NEAR

      push      di
      push      bx
      sub       sp, 10
      mov       bx, sp
      mov       word ptr [bx], 60h     ; baud = 1200
      mov       word ptr [bx + 2], 30h ; baud = 2400
      mov       word ptr [bx + 4], 18h ; baud = 4800
      mov       word ptr [bx + 6], 0ch ; baud = 9600
      mov       word ptr [bx + 8], 0

;
; Power up the C series mouse.
;
; Set both DTR and RTS to an active state
; If DTR and RTS are already on, the power is on for at least 500ms
; due to the MM serial mouse detection.
;

      address   MCR RXB             ; Get address of Modem Control Reg.
      DelayIn                       ; Get modem control byte

      and       al, MC_DTR + MC_RTS ; Check DTR and RTS
      cmp       al, MC_DTR + MC_RTS
      je        short @f            ; the lines are high already

      mov       al, MC_DTR + MC_RTS ; Set DTR and RTS to an active state
      DelayOut                      ; and ...

      mov       cx,9                ; wait for 1/2 second to pwrup mouse
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.
                                    ; ask for current baud rate
lt_waitloop1:
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       short lt_waitloop1

@@:
;
; Set the line control register to a format that the mouse can
; understand (see below: the line is set after the report rate).
;

      address   LCR  MCR            ; Get address of Line Control Reg.
      mov       al,LC_BITS8 + LC_STOP1 + LC_PODD
      DelayOut


;
; Cycle through the different baud rates to detect the mouse.
;

      mov       di, 0
      address   RXB LCR

Tfs_Next_Baud:
      mov       cx, [bx + di]
      cmp       cx, 0
      je        Tfs110              ; Reach the end of table

      call      SetBaudRate         ; Set baud rate

;
; Put the mouse in prompt mode.
;

      mov       cl, 'D'
      call      CSerWriteChar


;
; Set the MM protocol. This way we get the mouse to talk to us in a
; specific format. This avoids receiving errors from the line
; register.
;

      mov       cl, 'S'
      call      CSerWriteChar

      address   LCR  RXB            ; Get address of Line Control Reg.
      mov       al,LC_BITS8 + LC_STOP1 + LC_PODD
      DelayOut


;
; Try to get the status byte.
;

      address   RXB LCR
      mov       cl, 's'
      call      CSerWriteChar

;
; Read back the status character.
;

      mov       cx,2                 ; Wait at least 55.5 ms for response.
      call      SetupForWait
      assume    es:nothing
      address   LSR RXB

lt_waitloop2:                       ; (dx) = LSR reg
      DelayIn
      test      al, LS_DR           ; Is receiving buffer full?
      jnz       short @f            ; Yes, go read it.

lt_waitloop21:                      ; (dx) = LSR reg
      call      IsWaitOver
      jnc       short lt_waitloop2

      address   RXB LSR
      jmp       short Tfs50

@@:
      address   RXB LSR
      DelayIn
      cmp       al, 04fh            ; al = 4Fh means command understood
      je        short Tfs100

      address   LSR RXB
      jmp       short lt_waitloop21

Tfs50:
      add       di, 2
      jmp       Tfs_Next_Baud

Tfs100:

;
; Found the C series mouse.  Put the mouse back in a default mode.
; The protocol is already set.
;

;
; Set to default baud rate 1200
;

      mov       cl, '*'
      call      CSerWriteChar
      mov       cl, 'n'
      call      CSerWriteChar

;
; Wait for TX buffer empty
;

      mov       cx, 1
      call      SetupForWait
      address   LSR RXB
@@:
      DelayIn
      and       al, LS_THRE + LS_TSRE
      cmp       al, LS_THRE + LS_TSRE
      je        short @f            ; Wait for TX buffer empty
      call      IsWaitOver
      jnc       short @b

@@:
      address   RXB LSR
      mov       cx, 60h             ; Set baud rate to 1200
      call      SetBaudRate

;
; Set mouse to default report rate
;

      mov       cl, 'N'
      call      CSerWriteChar

      mov       ax,LT_MOUSE + SERIAL_MOUSE
      jmp       short lt_leave

Tfs110:
      mov       ax,NO_MOUSE

lt_leave:
      add       sp, 10              ; clear stack
      pop       bx
      pop       di
      ret

TestForLogitechSerial ENDP


;++
;
; VOID
; SetBaudRate (
;    USHORT Port,
;    USHORT BaudRate
;    )
;
; Routine Description:
;
;    This procedure will set up the given COM port so that it can talk to
;    a Logitech C series serial mouse.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;    (CX) = Baud Rate
;
; Return Value:
;
;    None.
;
;--

SetBaudRate PROC    NEAR
        push  dx
        address LCR RXB         ; Get address of Line Control Reg.
        DelayIn
        or      al,LC_DLAB      ; Set up to access divisor latches.
        DelayOut

        address LATMSB  LCR     ; Get address of high word of divisor
        mov     al, ch          ; latch and set it with value for
        DelayOut                ; specified baud.
        address LATLSB LATMSB   ; Get address of low word of divisor
        mov     al, cl          ; latch and set it with value for
        DelayOut                ; specified baud.

        address LCR LATLSB      ; Get address of Line Control Reg.
        DelayIn
        and     al, NOT LC_DLAB ; Disable access divisor latches.
        DelayOut

        mov   cx, 1
        call  SetupForWait
@@:
        call  IsWaitOver
        jnc   short @b

        pop   dx
        ret

SetBaudRate ENDP


;++
;
; VOID
; CSerWriteChar (
;    USHORT Port,
;    UCHAR Command
;    )
;
; Routine Description:
;
;    This procedure will write a char/command to logitech C series mouse.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;    (CL) = Command
;
; Return Value:
;
;    None.
;
;--

CserWriteChar   proc    near

      push      cx
      mov       cx, 1
      call      SetupForWait
      address   LSR RXB
@@:
      DelayIn
      and       al, LS_THRE + LS_TSRE
      cmp       al, LS_THRE + LS_TSRE
      je        short @f            ; Wait for TX buffer empty

      call      IsWaitOver
      jnc       short @b

@@:
      address   TXB LSR
      pop       ax                  ; Send command
      DelayOut
      ret
CserWriteChar   endp

if 0


;++
;
; VOID
; FlushReceiveBuffer (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will flush receive buffer or until time out.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;
; Return Value:
;
;    None.
;
;--

FlushReceiveBuffer      proc    near

      mov       cx, 5
      call      SetupForWait
@@:
      address   LSR RXB
      DelayIn
      test      al, LS_DR
      jz        short @f

      address   RXB LSR
      DelayIn
      call      IsWaitOver
      jnc       short @b

      ret
@@:
      address   RXB LSR
      ret
FlushReceiveBuffer      endp

endif
_TEXT   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID
#define KPROCESSOR_STATE ULONG
#define WCHAR USHORT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\mousec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hwdata.c

Abstract:

    This module contains the C code to set up mouse configuration data.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1991

Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

//
// External References
//

extern PMOUSE_INFORMATION
LookForPS2Mouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForInportMouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForSerialMouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForBusMouse (
    VOID
    );

extern VOID
Empty8042 (
    VOID
    );

extern USHORT
HwGetKey (
    VOID
    );

extern VOID
HwPushKey (
    USHORT Key
    );

extern USHORT SavedKey;
extern UCHAR  FastDetect;

//
// Define the master and slave i8259 IRQ bitmask.
//

#define MASTER_IRQ_MASK_BITS 0xB8
#define SLAVE_IRQ_MASK_BITS  0x02

//
// Define the lowest i8259 IRQ that the Inport mouse can reside on.  This
// has the highest NT priority.
//

#define INPORT_LOWEST_IRQ 0x03

//
// Define the Inport chip reset value.
//

#define INPORT_RESET 0x80

//
// Define the data registers (pointed to by the Inport address register).
//

#define INPORT_DATA_REGISTER_1 1
#define INPORT_DATA_REGISTER_2 2

//
// Define the Inport mouse mode register and mode bits.
//

#define INPORT_MODE_REGISTER           7
#define INPORT_MODE_0                  0x00 // 0 HZ - INTR = 0
#define INPORT_MODE_30HZ               0x01
#define INPORT_MODE_50HZ               0x02
#define INPORT_MODE_100HZ              0x03
#define INPORT_MODE_200HZ              0x04
#define INPORT_MODE_1                  0x06 // 0 HZ - INTR = 1
#define INPORT_DATA_INTERRUPT_ENABLE   0x08
#define INPORT_TIMER_INTERRUPT_ENABLE  0x10
#define INPORT_MODE_HOLD               0x20
#define INPORT_MODE_QUADRATURE         0x00

//
// Video adaptor type identifiers.
//

PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH"
    };

PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL"
    };


//
// The following table translates keyboard make code to
// ascii code.  Note, only 0-9 and A-Z are translated.
// Everything else is translated to '?'
//

UCHAR MakeToAsciiTable[] = {
    0x3f, 0x3f, 0x31, 0x32, 0x33,      // ?, ?, 1, 2, 3,
    0x34, 0x35, 0x36, 0x37, 0x38,      // 4, 5, 6, 7, 8,
    0x39, 0x30, 0x3f, 0x3f, 0x3f,      // 9, 0, ?, ?, ?,
    0x3f, 0x51, 0x57, 0x45, 0x52,      // ?, Q, W, E, R,
    0x54, 0x59, 0x55, 0x49, 0x4f,      // T, Y, U, I, O,
    0x50, 0x3f, 0x3f, 0x3f, 0x3f,      // P, ?, ?, ?, ?,
    0x41, 0x53, 0x44, 0x46, 0x47,      // A, S, D, F, G,
    0x48, 0x4a, 0x4b, 0x4c, 0x3f,      // H, J, K, L, ?,
    0x3f, 0x3f, 0x3f, 0x3f, 0x5a,      // ?, ?, ?, ?, Z,
    0x58, 0x43, 0x56, 0x42, 0x4e,      // X, C, V, B, N,
    0x4d};                             // W
#define MAX_MAKE_CODE_TRANSLATED 0x32

static ULONG MouseControllerKey = 0;

FPFWCONFIGURATION_COMPONENT_DATA
SetMouseConfigurationData (
    PMOUSE_INFORMATION MouseInfo,
    FPFWCONFIGURATION_COMPONENT_DATA MouseList
    )

/*++

Routine Description:

    This routine fills in mouse configuration data.

Arguments:

    MouseInfo - Supplies a pointer to the MOUSE_INFOR structure

    MouseList - Supplies a pointer to the existing mouse component list.

Returns:

    Returns a pointer to our mice controller list.

--*/
{
    UCHAR i = 0;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, Controller, PeripheralEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    USHORT z, Length;
    FPUCHAR fpString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // If it is not SERIAL_MOUSE, set up controller component
        //

        Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                     sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &Controller->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = PointerController;
        Component->Flags.Input = 1;
        Component->Version = 0;
        Component->Key = MouseControllerKey;
        MouseControllerKey++;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;

        //
        // If we have mouse irq or port information, allocate configuration
        // data space for mouse controller component to store these information
        //

        if (MouseInfo->MouseIrq != 0xffff || MouseInfo->MousePort != 0xffff) {

            //
            // Set up port and Irq information
            //

            if (MouseInfo->MousePort != 0xffff) {
                ControlData.NumberPortEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareDeviceExclusive;
                ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                ControlData.DescriptorList[z].u.Port.Start.LowPart =
                                        (ULONG)MouseInfo->MousePort;
                ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                ControlData.DescriptorList[z].u.Port.Length = 4;
                z++;
            }
            if (MouseInfo->MouseIrq != 0xffff) {
                ControlData.NumberIrqEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareUndetermined;
                ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
                ControlData.DescriptorList[z].u.Interrupt.Level =
                                        (ULONG)MouseInfo->MouseIrq;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                        (ULONG)MouseInfo->MouseIrq;
                if (HwBusType == MACHINE_TYPE_MCA) {
                    ControlData.DescriptorList[z].Flags =
                                                        LEVEL_SENSITIVE;
                } else {

                    //
                    // For EISA the LevelTriggered is temporarily set to FALSE.
                    //

                    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                }
            }
            Controller->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          NULL,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

        } else {

            //
            // Otherwise, we don't have configuration data for the controller
            //

            Controller->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;
        }
    }

    //
    // Set up Mouse peripheral component
    //

    PeripheralEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &PeripheralEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = PointerPeripheral;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    PeripheralEntry->ConfigurationData = (FPVOID)NULL;

    //
    // If Mouse PnP device id is found, translate it to ascii code.
    // (The mouse device id is presented to us by keyboard make code.)
    //

    Length = 0;
    if (MouseInfo->DeviceIdLength != 0) {
        USHORT i;

        if (MouseInfo->MouseSubtype == PS_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                if (MouseInfo->DeviceId[i] > MAX_MAKE_CODE_TRANSLATED) {
                    MouseInfo->DeviceId[i] = '?';
                } else {
                    MouseInfo->DeviceId[i] = MakeToAsciiTable[MouseInfo->DeviceId[i]];
                }
            }
        } else if (MouseInfo->MouseSubtype == SERIAL_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                MouseInfo->DeviceId[i] += 0x20;
            }
        }
        Length = MouseInfo->DeviceIdLength + 3;
    }
    Length += strlen(MouseIdentifier[MouseInfo->MouseType]) +
              strlen(MouseSubidentifier[MouseInfo->MouseSubtype]) + 1;
    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
    if (MouseInfo->DeviceIdLength != 0) {
        _fstrcpy(fpString, MouseInfo->DeviceId);
        _fstrcat(fpString, " - ");
        _fstrcat(fpString, MouseIdentifier[MouseInfo->MouseType]);
    } else {
        _fstrcpy(fpString, MouseIdentifier[MouseInfo->MouseType]);
    }
    _fstrcat(fpString, MouseSubidentifier[MouseInfo->MouseSubtype]);
    Component->IdentifierLength = Length;
    Component->Identifier = fpString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {
        Controller->Child = PeripheralEntry;
        PeripheralEntry->Parent = Controller;
        if (MouseList) {

            //
            // Put the current mouse component to the beginning of the list
            //

            Controller->Sibling = MouseList;
        }
        return(Controller);
    } else {
        CurrentEntry = AdapterEntry->Child; // AdapterEntry MUST have child
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Type == SerialController) {
                if (MouseInfo->MousePort == (USHORT)CurrentEntry->ComponentEntry.Key) {

                    //
                    // For serial mouse, the MousePort field contains
                    // COM port number.
                    //

                    PeripheralEntry->Parent = CurrentEntry;
                    CurrentEntry->Child = PeripheralEntry;
                    break;
                }
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
        return(NULL);
    }
}

FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    )

/*++

Routine Description:

    This routine is the entry for mouse detection routine.  It will invoke
    lower level routines to detect ALL the mice in the system.

Arguments:

    None.

Returns:

    A pointer to a mouse component structure, if mouse/mice is detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PMOUSE_INFORMATION MouseInfo;
    FPFWCONFIGURATION_COMPONENT_DATA MouseList = NULL;

    //
    // Check if there is a key in keyboard look ahead buffer.  If yes and
    // we have not saved any, we will read it and remember it.
    //

    if (SavedKey == 0) {
        SavedKey = HwGetKey();
    }
    if (MouseInfo = LookForPS2Mouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }
    if (MouseInfo = LookForInportMouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    while (MouseInfo = LookForSerialMouse()) {
        SetMouseConfigurationData(MouseInfo, MouseList);
    }

    if (!FastDetect && (MouseInfo = LookForBusMouse())) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    //
    // Finally drain 8042 output buffer again before we leave
    //

    Empty8042();

    //
    // If we have a keystroke before the mouse/keyboard detection, we
    // needs to push the key back to the keyboard look ahead buffer such
    // that ntldr can read it.
    //

    if (SavedKey) {
       HwPushKey(SavedKey);
    }
    return(MouseList);
}

BOOLEAN
InportMouseIrqDetection(
    IN USHORT CurrentPort,
    OUT PUSHORT Vector
    )

/*++

Routine Description:

    This routine attempts to locate the interrupt vector for which
    the Inport mouse is configured.  The allowable vectors are
    3, 4, 5, 7, and 9.  If no interrupt vector is found, or more than
    one is found, the routine returns FALSE.  Otherwise, TRUE is returned.

    Note that we diddle the i8259 interrupt controllers here.

Arguments:

    CurrentPort - I/O port to use for the mouse.

    Vector - Pointer to the location to store the mouse interrupt vector.

Return Value:

    Returns TRUE if the Inport interrupt vector was located; otherwise,
    FALSE is returned.

--*/

{
    UCHAR OldMasterMask, OldSlaveMask;
    UCHAR MasterMask, SlaveMask;
    UCHAR InterruptBits;
    UCHAR PossibleInterruptBits;
    int i;
    int NumberOfIRQs;
    BOOLEAN VectorFound = FALSE;

    //
    // Get the i8259 interrupt masks.
    //

    OldMasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
    OldSlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

    //
    // Raise IRQL to the highest priority IRQL the inport would use.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) 0xff ^ ((UCHAR)(1<<INPORT_LOWEST_IRQ) - 1)
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        (UCHAR) 0xff
        );

    //
    // Get the master i8259 interrupt mask.
    //

    MasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);

    //
    // Reset the Inport chip.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_RESET);

    //
    // Select the Inport mode register for use as the current data register.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_MODE_REGISTER);

    //
    // Disable potential Inport mouse interrupts.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) (MasterMask | MASTER_IRQ_MASK_BITS)
        );

    //
    // Select the i8259 Interrupt Request Register.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);

    //
    // Attempt to locate the Inport interrupt line on the master i8259.
    // Why try this 10 times?  It's magic...
    //

    PossibleInterruptBits = MASTER_IRQ_MASK_BITS;
    for (i = 0; i < 10; i++) {

        //
        // Generate a 0 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        InterruptBits ^= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;

        //
        // Generate a 1 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;
    }

    if (PossibleInterruptBits) {

        //
        // We found at least one IRQ on the master i8259 that could belong
        // to the Inport mouse.  Count how many we found.  If there is
        // more than one, we haven't found the vector.  Otherwise, we've
        // successfully located the Inport interrupt vector on the master
        // i8259 (provided the interrupt vector is 3, 4, 5, or 7).
        //

        PossibleInterruptBits >>= 3;
        NumberOfIRQs = 0;
        for (i = 3; i <= 7; i++) {
            if (PossibleInterruptBits & 1) {
                NumberOfIRQs += 1;
                *Vector = (CCHAR) i;
            }
            PossibleInterruptBits >>= 1;
        }
        if (NumberOfIRQs == 1) {
            VectorFound = TRUE;
        } else {
            *Vector = 0xffff;
        }
    }

    //
    // If we didn't locate the interrupt vector on the master i8259, attempt
    // to locate it on the slave i8259.
    //

    if (!VectorFound) {

        //
        // Get the slave i8259 interrupt mask.
        //

        SlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

        //
        // Disable potential Inport mouse interrupts.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR) PIC2_PORT1,
            (UCHAR) (SlaveMask | SLAVE_IRQ_MASK_BITS)
            );

        //
        // Select the i8259 Interrupt Request Register.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);

        //
        // Attempt to locate the Inport interrupt line on the slave i8259.
        // Why try this 10 times?  It's magic...
        //

        PossibleInterruptBits = SLAVE_IRQ_MASK_BITS;
        for (i = 0; i < 10; i++) {

            //
            // Generate a 0 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            InterruptBits ^= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

            //
            // Generate a 1 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

        }

        //
        // We may have found the Inport IRQ.  If it's not 2 on slave (really
        // 9, overall) then we have NOT found the Inport interrupt vector.
        // Otherwise, we have successfully located the Inport vector on
        // the slave i8259.
        //

        if (PossibleInterruptBits == 2) {
            *Vector = 9;
            VectorFound = TRUE;
        } else {
           *Vector = 0xffff;
        }

        //
        // Restore the i8259 slave.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_ISR);

        //
        // Restore the i8259 slave interrupt mask.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT1, SlaveMask);
    }

    //
    // Tri-state the Inport IRQ line.
    //

    WRITE_PORT_UCHAR((PUCHAR) (CurrentPort + INPORT_DATA_REGISTER_1), 0);

    //
    // Restore the i8259 master.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_ISR);

    //
    // Restore the i8259 master interrupt mask.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT1, MasterMask);

    //
    // Restore the previous IRQL.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        OldMasterMask
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        OldSlaveMask
        );

    return(VectorFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pccard.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pccard.h

Abstract:

    This module contains the C code to set up PcCard (pcmcia, cardbus)
    configuration data.

Author:

    Neil Sandlin (neilsa) 16-Dec-1998

Revision History:

--*/

#define PCCARD_POSSIBLE_IRQS 0xCEB8                

//
// PIC hardware
//
#define PIC1_IMR    0x21
#define PIC2_IMR    0xa1
#define PIC1_OCW3   0x20
#define PIC2_OCW3   0xa0
#define PIC_RD_IR   0x0a
#define SYSCTRL_B   0x61

//
// Internal defs
//

#define DEVTYPE_GENERIC_PCIC 0
#define DEVTYPE_GENERIC_CARDBUS 1
#define DEVTYPE_CL_PD6832   2
#define DEVTYPE_CL_PD6834   3
#define DEVTYPE_CL_PD6833   4
#define DEVTYPE_TI_PCI1130  5
#define DEVTYPE_TI_PCI1131  6
#define DEVTYPE_TI_PCI1031  7


#define BCTRL_CL_CSCIRQROUTING_ENABLE   0x0800
#define CDGC_SW_DET_INT                 0x20

#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_SECONDARY_BUS          0x19
#define CFGSPACE_SUBORDINATE_BUS        0x1a
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_LEGACY_MODE_BASE_ADDR  0x44
#define CFGSPACE_CL_CFGMISC1            0x98
#define CFGSPACE_TI_DEV_CTRL            0x92

#define CL_CFGMISC1_ISACSC              0x02
#define CSCFG_CD_ENABLE                 0x08

#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_MASK            0x06

#define EXCAREG_IDREV                   0x00
#define EXCAREG_INT_GENCTRL             0x03
#define EXCAREG_CARD_STATUS             0x04
#define EXCAREG_CSC_CFG                 0x05
#define EXCAREG_CARDDET_GENCTRL         0x16

#define IGC_PCCARD_RESETLO              0x40

#define PCIC_REVISION                   0x82
#define PCIC_REVISION2                  0x83
#define PCIC_REVISION3                  0x84


#define PCI_TYPE1_ADDR_PORT     ((PULONG) 0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC
#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_BRIDGE_TYPE                 0x01
#define PCI_CARDBUS_BRIDGE_TYPE         0x02

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


typedef struct _PCCARD_INFORMATION {
    PCI_TYPE1_CFG_BITS PciCfg1;
    ULONG  DeviceId;
    UCHAR  Flags;
    UCHAR  ErrorCode;
    UCHAR  bDevType;
    UCHAR  Reserved;
    USHORT IoBase;
    USHORT wValidIRQs;
    UCHAR abIRQMap[16];
} PCCARD_INFORMATION, *PPCCARD_INFORMATION;

typedef struct _CARDBUS_BRIDGE_DEVTYPE {
    ULONG DeviceId;
    UCHAR bDevType;
} CARDBUS_BRIDGE_DEVTYPE, *PCARDBUS_BRIDGE_DEVTYPE;

//
// Prototypes
//


USHORT
DetectIRQMap(
    PPCCARD_INFORMATION pa
    );

USHORT
GetPICIRR(
    VOID
    );
    
USHORT
ToggleIRQLine(
    PPCCARD_INFORMATION pa,
    UCHAR bIRQ
    );

UCHAR
PcicReadSocket(
    PPCCARD_INFORMATION pa,
    USHORT Offset
    );
    
VOID
PcicWriteSocket(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    UCHAR value
    );

VOID
GetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID Buffer,
    USHORT Length
    );
    
VOID
SetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID Buffer,
    USHORT Length
    );

VOID
Clear_IR_Bits(
    USHORT BitMask
    );    

VOID
GetPCIType1Data(
    ULONG address,
    USHORT IoOffset,
    PVOID Buffer,
    USHORT Size    
    );

VOID
SetPCIType1Data(
    ULONG address,
    USHORT IoOffset,
    PVOID Buffer,
    USHORT Size    
    );

VOID
TimeOut(
    USHORT Ticks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pccarda.asm ===
title  "PcCard IRQ detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pccarda.asm
;
; Abstract:
;
;    This module implements the assembly code necessary to support the
;    scanning of ISA IRQ's for cardbus controllers.
;
; Author:
;
;    Neil Sandlin (neilsa) 10-Dec-1991.
;    The "Clear_IR" routines were taken from win9x code (vpicd)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include pccard.inc
        .list
        .386

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'
_DATA   ENDS

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING
        

;++
;
;   clr_ir_int_proc
;
; Routine Description:
;
;    Interrupt handler for clearing IR bit.  Just EOIs the PICs.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--        
Clr_IR_Int      dw      0               ; Current int # being processed

        public  clr_ir_int_proc
clr_ir_int_proc proc far
        push    ax

        mov     ax, Clr_IR_Int
        cmp     ax, 8                   ; Q: is int on the master PIC?
        jb      CIP_eoi                 ;    Y: only eoi master PIC

        sub     ax, 8                   ; AL = int on slave PIC
        or      al, PIC_SPEC_EOI
        out     PIC_A0, al              ; EOI the specific interrupt

        mov     al, 2                   ; EOI the master PIC
CIP_eoi:
        or      al, PIC_SPEC_EOI
        out     PIC_20, al              ; EOI the specific interrupt

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_A1, al
        out     PIC_21, al
        pop     ax
        iret
clr_ir_int_proc endp


;++
;
;   clr_ir_enable_int
;
; Routine Description:
;
;
; Arguments:
;
;       EAX = interrupt to hook and enable.
;       Interrupts must be disabled on entry.
;
; Return Value:
;
;    None.
;
;--        

clr_ir_enable_int proc near
        push    bx
        push    esi
        ; Hook interrupt so it can be handled.

        mov     Clr_IR_Int, ax          ; Set current interrupt being processed
        cmp     ax, 8                   ; Q: is int on the master PIC?
        jb      CIEI_master             ;   Y: based at 8
        add     ax, 68h                 ;   N: based at 70h
        jmp     CIEI_vector
CIEI_master:
        add     ax, 8
CIEI_vector:
        mov     bx, ax
        shl     bx, 2                   ; IVT vector offset
        
        push    ds
        mov     ax, 0
        mov     ds, ax
        ASSUME  DS:NOTHING
        
        mov     si, offset clr_ir_int_proc
        xchg    word ptr [bx], si       ; LSW
        ror     esi, 16
        push    cs
        pop     si
        xchg    word ptr [bx+2], si     ; MSW
        ror     esi, 16                 ; ESI = old handler offset
        pop     ds
        ASSUME  DS:_DATA

        sti

        nop                             ; allow interrupt to occur
        nop
        nop

        cli

        ; UnHook interrupt.

        push    ds
        mov     ax, 0
        mov     ds, ax
        ASSUME  DS:NOTHING
        mov     word ptr [bx], si       ; Restore LSW
        ror     esi, 16
        mov     word ptr [bx+2], si     ; Restore MSW
        pop     ds
        ASSUME  DS:_DATA
        
        pop     esi
        pop     bx
        ret
clr_ir_enable_int endp


;++
;
;   _Clear_IR_Bits
;
; Routine Description:
;
;    This routine and its support routines were copied (and munged) from
;    win9x's vxd\vpicd\vpicserv.asm.
;
;    Clears the desired Interrupt Request bits in the PIC.
;    Interrupt must be masked at the PIC on entry.
;
; Arguments:
;
;       [ESP+4] = bit mask of bits to clear
;       Interrupts must be disabled on entry.
;
; Return Value:
;
;    None.
;
;--        

        public _Clear_IR_Bits
_Clear_IR_Bits proc near
        push    bp
        mov     bp, sp
BitMask equ     [bp+4]        

        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     bx, BitMask             ; BX = mask to clear
        or      bx, bx                  ; Are there any bits to clear?
        jz      CIB_exit                ;  no, return

        pushfd
        cli
        in      al, PIC_A1
        mov     ah, al
        in      al, PIC_21
        push    eax
        mov     al, 0FFh
        out     PIC_A1, al

        ; Walk each bit from the lowest bit to highest on each controller.

        mov     ecx, 01h                ; CL = test mask
CIB_loop20:
        test    bl, cl
        jz      CIB_next20

        mov     al, cl
        not     al
        out     PIC_21, al              ; Unmask the specific interrupt

        bsf     eax, ecx
        call    clr_ir_enable_int       ; Hook interrupt and enable it

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_21, al
CIB_next20:
        shl     cl, 1
        jnz     CIB_loop20              ; Clear next bit

        ; Setup for second PIC.  Handle the second controller by setting
        ; up both PICs, since they are chained.

        mov     bl, bh                  ; BL = second PICs mask to clear
        mov     cl, 01h                 ; CL = test mask
CIB_loopA0:
        test    bl, cl
        jz      CIB_nextA0

        mov     al, 0FBh                ; Mask for chained master PIC
        out     PIC_21, al              ; Unmask the specific interrupt

        mov     al, cl
        not     al
        out     PIC_A1, al              ; Unmask the specific interrupt

        xchg    cl, ch
        bsf     eax, ecx
        call    clr_ir_enable_int       ; Hook interrupt and enable it
        xchg    cl, ch

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_A1, al
        out     PIC_21, al
CIB_nextA0:
        shl     cl, 1
        jnz     CIB_loopA0              ; Clear next bit

        pop     eax
        out     PIC_21, al
        mov     al, ah
        out     PIC_A1, al
        popfd

CIB_exit:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        mov     sp, bp
        pop     bp        
        ret

_Clear_IR_Bits endp


;++
;
;   GetPCIType1Data
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--        
        public  _GetPCIType1Data
_GetPCIType1Data proc near
        push    bp
        mov     bp, sp      
        push    bx
        push    di
gpd_addr   equ    [bp+4]
gpd_offset equ    [bp+8]
gpd_buffer equ  [bp+10]
gpd_width equ   [bp+12]        

        mov     dx, PCI_TYPE1_ADDR_PORT
        mov     eax, gpd_addr
        out     dx, eax

        mov     bx, gpd_buffer        
        mov     dx, gpd_offset
        add     dx, PCI_TYPE1_DATA_PORT
        mov     di, gpd_width
        
        cmp     di, 1
        jnz     @f
        in      al, dx
        mov     [bx], al
        jmp     gpd_exit
@@:        
        cmp     di, 2
        jnz     @f
        in      ax, dx
        mov     [bx], al
        mov     [bx+1], ah
        jmp     gpd_exit
@@:        
        
        cmp     di, 4
        jnz     gpd_exit
        in      eax, dx
        mov     [bx], al
        mov     [bx+1], ah
        shr     eax, 16
        mov     [bx+2], al
        mov     [bx+3], ah

gpd_exit:        
        pop     di
        pop     bx
        mov     sp, bp
        pop     bp        
        ret
_GetPCIType1Data endp

;++
;
;   SetPCIType1Data
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--        
        public  _SetPCIType1Data
_SetPCIType1Data proc near
        push    bp
        mov     bp, sp      
        push    bx
        push    di
spd_addr   equ    [bp+4]
spd_offset equ    [bp+8]
spd_buffer equ  [bp+10]
spd_width equ   [bp+12]        

        mov     dx, PCI_TYPE1_ADDR_PORT
        mov     eax, spd_addr
        out     dx, eax

        mov     bx, spd_buffer        
        mov     dx, spd_offset
        add     dx, PCI_TYPE1_DATA_PORT
        mov     di, spd_width
        
        cmp     di, 1
        jnz     @f
        mov     al, [bx]
        out     dx, al
        jmp     spd_exit
@@:        
        cmp     di, 2
        jnz     @f
        mov     al, [bx]
        mov     ah, [bx+1]
        out     dx, ax
        jmp     spd_exit
@@:        
        
        cmp     di, 4
        jnz     spd_exit
        mov     al, [bx+2]
        mov     ah, [bx+3]
        shl     eax, 16
        mov     al, [bx]
        mov     ah, [bx+1]
        out     dx, eax

spd_exit:        
        pop     di
        pop     bx
        mov     sp, bp
        pop     bp        
        ret
_SetPCIType1Data endp

;++
;
;   TimeOut
;
; Routine Description:
;
;   This routine implements a stall for waiting on hardware. It uses the
;   PC timer hardware (8237). The caller needs to insure that this hardware
;   exists on the machine before calling this function.
;
;   The function will take as input the count, and decrement the count
;   matching the timer hardware's count. It returns when the count reaches
;   zero. The caller must insure that the clock is programmed at the
;   desired rate.
;
; Arguments:
;
;   Count - number of clock ticks to wait (approx 840ns per tick)
;
; Return Value:
;
;    None.
;
;--        
        public  _TimeOut
_TimeOut proc near

TMCTRL_LATCHCNT0 equ 0d2h
TIMERPORT_CONTROL equ 43h
TIMERPORT_CNT0    equ 40h

        push    bp
        mov     bp, sp      
        push    cx
        push    si
        push    di
        
to_count  equ    [bp+4]

        mov     dx, TIMERPORT_CONTROL
        mov     al, TMCTRL_LATCHCNT0
        out     dx, al

        mov     dx, TIMERPORT_CNT0
        in      al, dx
        mov     ah, al
        in      al, dx
        xchg    ah, al
        mov     si, ax
        xor     cx, cx

;       si = prevtime
;       cx = ExpireTime

timeloop:
        mov     dx, TIMERPORT_CONTROL
        mov     al, TMCTRL_LATCHCNT0
        out     dx, al
        mov     dx, TIMERPORT_CNT0
        in      al, dx
        mov     ah, al
        in      al, dx
        xchg    ah, al
        mov     di, ax

        cmp     ax, si
        jbe     @f
        ; wrapped
        neg     ax
        add     ax, si
        add     cx, ax        
        jmp     timeincr
@@:
        sub     si, ax
        add     cx, si
timeincr:
        mov     si, di
        cmp     cx, to_count
        jb      timeloop

        pop     di
        pop     si
        pop     cx
        mov     sp, bp
        pop     bp        
        ret
_TimeOut endp


_TEXT   ends


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pccard.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       pccard.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for the pccard IRQ detection mechanism.
;
;   Author:
;
;       Neil Sandlin (neilsa) 11-Dec-1998
;
;   Revision History:
;
;--

ifndef NEC_98
PIC1_OCW3    equ 20h
PIC1_IMR    equ 21h

PIC2_OCW3     equ 0A0h
PIC2_IMR     equ 0A1h        
else
PIC1_IMR    equ 2
PIC2_IMR    equ 0ah
PIC1_OCW3   equ 0
PIC2_OCW3   equ 8
endif

ifdef NEC_98
PIC_20          EQU     000h
PIC_21          EQU     002h
PIC_A0          EQU     008h
PIC_A1          EQU     00Ah
else ;NEC_98
PIC_20          EQU     020h
PIC_21          EQU     021h
PIC_A0          EQU     0A0h
PIC_A1          EQU     0A1h
endif ;NEC_98
PIC_RD_IR       EQU     00Ah
PIC_SPEC_EOI    EQU     060h
PIC_LEVEL_MSK   EQU     007h                 


PCIC_IDENT             equ 00
PCIC_STATUS            equ 01
PCIC_PWR_RST           equ 02
PCIC_INTERRUPT         equ 03
PCIC_CARD_CHANGE       equ 04
PCIC_CARD_INT_CONFIG   equ 05
IGC_PCCARD_RESETLO     equ 40h
CSCFG_CD_ENABLE        equ 8
PCIC_CARD_DETECT       equ 16h
CDGC_SW_DET_INT        equ 20h


PCI_TYPE1_ADDR_PORT    equ 0CF8h
PCI_TYPE1_DATA_PORT    equ 0CFCh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pccardc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pccardc.c

Abstract:

    This module contains the C code to set up PcCard (pcmcia, cardbus)
    configuration data.

Author:

    Neil Sandlin (neilsa) 16-Dec-1998
       (DetectIRQMap, ToggleIRQLine were copied from win9x)

Revision History:

--*/

#include "hwdetect.h"
#include "pccard.h"
#include <string.h>

extern UCHAR DisablePccardIrqScan;
extern BOOLEAN SystemHas8259;
extern BOOLEAN SystemHas8253;

CARDBUS_BRIDGE_DEVTYPE CBTable[] = {
        {0x11101013, DEVTYPE_CL_PD6832},
        {0x11121013, DEVTYPE_CL_PD6834},
        {0x11111013, DEVTYPE_CL_PD6833},
        {0xAC12104C, DEVTYPE_TI_PCI1130},
        {0xAC15104C, DEVTYPE_TI_PCI1131},
        {0xAC13104C, DEVTYPE_TI_PCI1031},
        {0,0}};
        


FPFWCONFIGURATION_COMPONENT_DATA ControllerList = NULL;

#define LEGACY_BASE_LIST_SIZE 10
USHORT LegacyBaseList[LEGACY_BASE_LIST_SIZE] = {0};
USHORT LegacyBaseListCount = 0;



VOID
SetPcCardConfigurationData(
    PPCCARD_INFORMATION PcCardInfo
    )
/*++

Routine Description:

    This routine creates a structure containing the result of the
    irq detection, and links it onto our running list. This list
    eventually will show up in the registry under hardware
    descriptions.

Arguments:

    PcCardInfo - Structure containing the results of detection

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry;
    static FPFWCONFIGURATION_COMPONENT_DATA PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CHAR Identifier[32];
    FPCHAR IdentifierString;
    USHORT Length;       
    CM_PCCARD_DEVICE_DATA far *PcCardData;
    
    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                            sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    if (!ControllerList) {
        ControllerList = CurrentEntry;
    }
    Component = &CurrentEntry->ComponentEntry;
    
    Component->Class = ControllerClass;
    Component->Type = OtherController;

    strcpy (Identifier, "PcCardController");
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);        

    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;
    
    Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) + sizeof(CM_PCCARD_DEVICE_DATA);
    DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                Length,
                                TRUE);
                                
    CurrentEntry->ConfigurationData = DescriptorList;
    Component->ConfigurationDataLength = Length;
    
    DescriptorList->Count = 1;
    DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                                            sizeof(CM_PCCARD_DEVICE_DATA);
                                            
    PcCardData = (CM_PCCARD_DEVICE_DATA far *)(DescriptorList + 1);
    PcCardData->Flags             = PcCardInfo->Flags;
    PcCardData->ErrorCode         = PcCardInfo->ErrorCode;
    PcCardData->DeviceId          = PcCardInfo->DeviceId;
    PcCardData->LegacyBaseAddress = (ULONG) PcCardInfo->IoBase;

    if (PcCardInfo->Flags & PCCARD_DEVICE_PCI) {
        PcCardData->BusData = PcCardInfo->PciCfg1.u.bits.BusNumber |
                              PcCardInfo->PciCfg1.u.bits.DeviceNumber << 8 |
                              PcCardInfo->PciCfg1.u.bits.FunctionNumber << 16;
    }
    
    _fmemcpy(PcCardData->IRQMap, PcCardInfo->abIRQMap, 16);
    
    if (PreviousEntry) {
        PreviousEntry->Sibling = CurrentEntry;
    }
    PreviousEntry = CurrentEntry;
}


BOOLEAN
IsOnLegacyBaseList(
    USHORT IoBase
    )
/*++

Routine Description:

    This routine runs our list of legacy base addresses to see if we
    have looked at the address before.

Arguments:

    IoBase = base address to map

Returns:

    TRUE if the base address is already on the list

--*/
{
    USHORT i;

    for (i = 0; i<LegacyBaseListCount; i++) {
        if (IoBase == LegacyBaseList[i]) {
            return TRUE;
        }
    }
    return FALSE;
}    


BOOLEAN
SetLegacyBaseList(
    USHORT IoBase
    )
/*++

Routine Description:

    This routine remembers the legacy base addresses that we have looked
    at so far so we don't keep mapping the same address.

    NOTE: We are using a DUMB mechanism that only builds the list in a
    fixed array. We could write some generic code which creates
    a linked list, but since the heap routines in ntdetect are also
    dumb, it makes it not possible to free the list. It's just not worth 
    it.
    
Arguments:

    IoBase = base address to map

Returns:

    TRUE if the base address is unique to this point
    FALSE if the base address already exists on the list

--*/
{
    
    if (IsOnLegacyBaseList(IoBase)) {
        return FALSE;
    }

    if (LegacyBaseListCount < LEGACY_BASE_LIST_SIZE) {
        LegacyBaseList[LegacyBaseListCount++] = IoBase;    
    }
    // note, we return true even if we overflow the list
    return TRUE;
}    


VOID
MapPcCardController(
    PPCCARD_INFORMATION PcCardInfo
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PcCard
    controllers.

Arguments:

    PcCardInfo - Structure defining the device to run detection on

Returns:

    None.

--*/
{
    USHORT wDetected;
    USHORT i;

    PcCardInfo->ErrorCode = 0;
    for (i=0; i<16; i++) {
        PcCardInfo->abIRQMap[i]=0;
    }                    
        
    if (!PcCardInfo->IoBase) {
    
        PcCardInfo->Flags |= PCCARD_MAP_ERROR;
        PcCardInfo->ErrorCode = PCCARD_NO_LEGACY_BASE;
        
    } else if (!SetLegacyBaseList(PcCardInfo->IoBase)) {
    
        PcCardInfo->Flags |= PCCARD_MAP_ERROR;
        PcCardInfo->ErrorCode = PCCARD_DUP_LEGACY_BASE;
        
    } 
        
    if (!(PcCardInfo->Flags & PCCARD_MAP_ERROR)) {
        PcCardInfo->wValidIRQs = PCCARD_POSSIBLE_IRQS;
        
#if DBG    
        BlPrint("Going to detect...\n");
#endif        
        //
        // Do the IRQ detection
        //
        wDetected = DetectIRQMap(PcCardInfo);
#if DBG    
        BlPrint("Detect IRQ Map returns %x on iobase %x\n", wDetected, PcCardInfo->IoBase);
#endif        
    
        if (!wDetected) {
            PcCardInfo->ErrorCode = PCCARD_MAP_ZERO;
        }
    }
    
#if DBG    
    if (PcCardInfo->Flags & PCCARD_MAP_ERROR) {
        BlPrint("Error mapping device, code=%x\n", PcCardInfo->ErrorCode);
    }
#endif
    
    //
    // Report the results
    //
    SetPcCardConfigurationData(PcCardInfo);
}    
    

VOID
LookForPciCardBusBridges(
    USHORT BusStart,
    USHORT BusEnd,
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PCI-based
    cardbus controllers.

Arguments:

    Bus = PCI Bus number to scan

Returns:

    None.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    USHORT Device, Function;
    UCHAR HeaderType;
    UCHAR SecBus, SubBus;
    USHORT VendorId;
    USHORT DeviceId;
    ULONG LegacyBaseAddress;
    USHORT i;
    USHORT Bus;

#if DBG            
    BlPrint("LookForPciCardBusBridges %x-%x\n", BusStart, BusEnd);
#endif            

    for (Bus = BusStart; Bus <= BusEnd; Bus++) {

        PcCardInfo.PciCfg1.u.AsULONG = 0;
        PcCardInfo.PciCfg1.u.bits.BusNumber = Bus;
        PcCardInfo.PciCfg1.u.bits.Enable = TRUE;        
        
        for (Device = 0; Device < PCI_MAX_DEVICES; Device++) {
            PcCardInfo.PciCfg1.u.bits.DeviceNumber = Device;

            for (Function = 0; Function < PCI_MAX_FUNCTION; Function++) {
                PcCardInfo.PciCfg1.u.bits.FunctionNumber = Function;
                
                VendorId = 0xffff;
                GetPciConfigSpace(&PcCardInfo, CFGSPACE_VENDOR_ID, &VendorId, sizeof(VendorId));
    
                if ((VendorId == 0xffff) || (VendorId == 0)) {
                    if (Function == 0) {
                        break;
                    } else {                        
                        continue;
                    }                        
                }                    

                GetPciConfigSpace(&PcCardInfo, CFGSPACE_DEVICE_ID, &DeviceId, sizeof(DeviceId));
                GetPciConfigSpace(&PcCardInfo, CFGSPACE_HEADER_TYPE, &HeaderType, sizeof(HeaderType));
                
                switch(HeaderType & 0x7f) {
                case PCI_CARDBUS_BRIDGE_TYPE:
                
#if DBG            
                    BlPrint("%x.%x.%x : DeviceID = %lx (CardBus Bridge)\n", Bus, Device, Function, DeviceId);
#endif            
                    PcCardInfo.DeviceId = (ULONG) (VendorId << 16) | DeviceId;
                    PcCardInfo.Flags = PCCARD_DEVICE_PCI;
                    //
                    // See if this is a special cased controller
                    //
                    PcCardInfo.bDevType = DEVTYPE_GENERIC_CARDBUS;
                    i = 0;
                    while (CBTable[i].DeviceId != 0) {
                        if (DeviceId == CBTable[i].DeviceId) {
                            PcCardInfo.bDevType = CBTable[i].bDevType;
                            break;
                        }
                        i++;
                    }
            
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_LEGACY_MODE_BASE_ADDR, &LegacyBaseAddress, 4);
                    PcCardInfo.IoBase = (USHORT) (LegacyBaseAddress & ~1);
                    
                    MapPcCardController(&PcCardInfo);
                    break;

                case PCI_BRIDGE_TYPE:
#if DBG            
                    BlPrint("%x.%x.%x : DeviceID = %lx (Pci-Pci Bridge)\n", Bus, Device, Function, DeviceId);
#endif            
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_SECONDARY_BUS, &SecBus, sizeof(SecBus));
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_SUBORDINATE_BUS, &SubBus, sizeof(SubBus));
                    
                    if ((SecBus <= Bus) || (SubBus <= Bus) || (SubBus < SecBus)) {
                        break;
                    }

                    //
                    // Be conservative on stack space, only look one level deep
                    //
                    if (Bus > 0) {
                        break;
                    }
                    
                    LookForPciCardBusBridges(SecBus, SubBus);                    
                    break;
                }
            }
        }
    }        
}


VOID
LookForPcicControllers(
    VOID
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PCIC
    controllers.

Arguments:

    None.

Returns:

    None.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    USHORT IoBase;
    UCHAR id;

    for (IoBase = 0x3e0; IoBase < 0x3e6; IoBase+=2) {
        if (IsOnLegacyBaseList(IoBase)) {
            continue;
        }
        PcCardInfo.Flags = 0;
        PcCardInfo.IoBase = IoBase;
        PcCardInfo.bDevType = DEVTYPE_GENERIC_PCIC;
        
        id = PcicReadSocket(&PcCardInfo, EXCAREG_IDREV);
        switch (id) {
        case PCIC_REVISION:
        case PCIC_REVISION2:
        case PCIC_REVISION3:        

#if DBG            
            BlPrint("Pcic Controller at base %x, rev(%x)\n", IoBase, id);
#endif            
            MapPcCardController(&PcCardInfo);
            break;
#if DBG            
        default:
            BlPrint("Not mapping base %x, return is (%x)\n", IoBase, id);
#endif            
        }
    }
}



FPFWCONFIGURATION_COMPONENT_DATA
GetPcCardInformation(
    VOID
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PcCard
    controllers.

Arguments:

    None.

Returns:

    A pointer to a pccard component structure, if IRQ's were properly detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    UCHAR ErrorCode = 0;

    //
    // Check for things which would prevent us from attempting
    // the irq detection
    //

    if (DisablePccardIrqScan == 1) {               
        ErrorCode = PCCARD_SCAN_DISABLED;
        
    } else if (!SystemHas8259) {
        ErrorCode = PCCARD_NO_PIC;
        
    } else if (!SystemHas8253) {
        ErrorCode = PCCARD_NO_TIMER;
        
    }

    //
    // If things look ok so far, do the detection
    //
    if (!ErrorCode) {
#if DBG
        BlPrint("press any key to continue...\n");
        while ( !HwGetKey() ) ; // wait until key pressed to continue
        clrscrn();
        BlPrint("Looking for PcCard Controllers...\n");
#endif
        //
        // Look first for cardbus
        //
        LookForPciCardBusBridges(0,0);
        //
        // Now check for regular pcic devices
        //
        LookForPcicControllers();
    
#if DBG
        BlPrint("press any key to continue...\n");
        while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif

        if (!ControllerList) {
            ErrorCode = PCCARD_NO_CONTROLLERS;
        }
    }

    if (ErrorCode) {
        //
        // Something when wrong, so write a single entry to
        // allow someone to see what the error was
        //
        PcCardInfo.Flags |= PCCARD_MAP_ERROR;
        PcCardInfo.ErrorCode = ErrorCode;
        SetPcCardConfigurationData(&PcCardInfo);
    }    

    return ControllerList;
}


USHORT
DetectIRQMap(
    PPCCARD_INFORMATION pa
    )
/*++

Routine Description:

    This routine detects the IRQ mapping of the specified cardbus controller.
    Note that the controller is in PCIC mode.

Arguments:

    pa -> ADAPTER structure

Returns:

    returns detected IRQ bit mask

--*/
{
    USHORT wRealIRQMask = 0;
    USHORT wData;
    UCHAR bData;

    BOOLEAN fTINMIBug = FALSE;

    UCHAR i;
    USHORT wIRQMask, wRealIRQ, w;

    if (pa->bDevType == DEVTYPE_CL_PD6832)
    {
        //enable CSC IRQ routing just for IRQ detection
        GetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
        wData |= BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
    }
    else if ((pa->bDevType == DEVTYPE_CL_PD6834) ||
             (pa->bDevType == DEVTYPE_CL_PD6833))
    {
        //enable CSC IRQ routing just for IRQ detection
        GetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
        bData |= CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
    }
    else if ((pa->bDevType == DEVTYPE_TI_PCI1130) ||
             (pa->bDevType == DEVTYPE_TI_PCI1131) ||
             (pa->bDevType == DEVTYPE_TI_PCI1031))
    {
        GetPciConfigSpace(pa, CFGSPACE_TI_DEV_CTRL, &wData, sizeof(wData));
        if ((wData & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_COMPAQ)
        {
            //
            // There is an errata on TI 1130, 1131 and 1031 in which if
            // the chip is programmed to use serial IRQ mode (i.e. COMPAQ
            // mode) and the SERIRQ pin is not pull up with a 1K resistor,
            // the SERIRQ line will rise too slowly after IRQ 15 is
            // deasserted so that it looks like NMI should be asserted.
            // This caused spurious NMI.  This is a hardware problem.
            // Unfortunately, there are a large number of machines with
            // this problem on the street already, so CBSS has to work
            // around the problem by temporarily disabling NMI before
            // doing ISA IRQ detection.
            //
            fTINMIBug = TRUE;
            _asm    in   al,SYSCTRL_B
            _asm    and  al,0x0f
            _asm    push ax
            //
            // Mask NMI
            //
            _asm    or   al,0x08
            _asm    out  SYSCTRL_B,al
        }
    }
    _asm pushf
    _asm cli                    //disable interrupt
    _asm in   al,PIC2_IMR       //save old IMRs
    _asm mov  ah,al
    _asm in   al,PIC1_IMR
    _asm push ax

    _asm mov  al,0xff           //mask all interrupt
    _asm out  PIC2_IMR,al
    _asm out  PIC1_IMR,al

    for (i = 0; i < 16; ++i)
    {
        w = (USHORT)(1 << i);
        if ((pa->wValidIRQs & w) &&
            ((wIRQMask = ToggleIRQLine(pa, i)) != 0))
        {
            _asm mov dx, wIRQMask
            _asm _emit 0x66
            _asm _emit 0x0f
            _asm _emit 0xbc
            _asm _emit 0xc2
            _asm mov wRealIRQ,ax
            pa->abIRQMap[wRealIRQ] = i;
            wRealIRQMask |= (USHORT)(1 << wRealIRQ);
        }
    }
    Clear_IR_Bits(wRealIRQMask);

    _asm pop  ax
    _asm out  PIC1_IMR,al
    _asm mov  al,ah
    _asm out  PIC2_IMR,al
    _asm popf

    if (fTINMIBug)
    {
        //
        // Restore NMI mask
        //
        _asm    pop  ax
        _asm    out  SYSCTRL_B,al
    }

    if (pa->bDevType == DEVTYPE_CL_PD6832)
    {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
        wData &= ~BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
    }
    else if ((pa->bDevType == DEVTYPE_CL_PD6834) ||
             (pa->bDevType == DEVTYPE_CL_PD6833))
    {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
        bData &= ~CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
    }

    return wRealIRQMask;
}       //DetectIRQMap



USHORT
ToggleIRQLine(
    PPCCARD_INFORMATION pa,
    UCHAR bIRQ
    )
/*++

Routine Description:

    This routine toggles the specified IRQ line from the adapter.

Arguments:

    pa -> ADAPTER structure
    bIRQ - IRQ line to toggle

Returns:

    returns the IRR mask from PIC

--*/
{
    UCHAR bOldIntCtrl, bOldIntCfg, bData;
    USHORT rc = 0, irr1, irr2, irr3;

    bOldIntCfg = PcicReadSocket(pa, EXCAREG_CSC_CFG);
    bOldIntCtrl = PcicReadSocket(pa, EXCAREG_INT_GENCTRL);

    //Set to a known state
    PcicWriteSocket(pa, EXCAREG_INT_GENCTRL, IGC_PCCARD_RESETLO);

    //Set irq number in interrupt control register and enable irq
    PcicWriteSocket(pa, EXCAREG_CSC_CFG, (UCHAR)((bIRQ << 4) | CSCFG_CD_ENABLE));

    //clear all pending interrupts
    bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
    irr1 = GetPICIRR();

    if (PcicReadSocket(pa, EXCAREG_IDREV) != 0x82)
    {
        //This is not an A stepping part, try the undocumented interrupt
        //register.  If this fails the other routine will be tried.
        PcicWriteSocket(pa, EXCAREG_CARDDET_GENCTRL, CDGC_SW_DET_INT);
        irr2 = GetPICIRR();

        //reset pending interrupt
        bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
        irr3 = GetPICIRR();
        rc = (USHORT)((irr1 ^ irr2) & (irr2 ^ irr3));
    }

    if (rc == 0)
    {
        //Generate interrupt by de-asserting IRQ line so the PIC can pull it
        //high
        PcicWriteSocket(pa, EXCAREG_CSC_CFG, 0);
        //if (pa->dwfAdapter & AF_TI_SERIALIRQ)
        //    TIReleaseSerialIRQ(pa, bIRQ);
        irr2 = GetPICIRR();

        //re-assert IRQ line
        PcicWriteSocket(pa, EXCAREG_CSC_CFG, (UCHAR)((bIRQ << 4) | CSCFG_CD_ENABLE));

        //reset pending interrupt
        bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
        irr3 = GetPICIRR();
        rc = (USHORT)((irr1 ^ irr2) & (irr2 ^ irr3));
    }

    PcicWriteSocket(pa, EXCAREG_CSC_CFG, bOldIntCfg);
    PcicWriteSocket(pa, EXCAREG_INT_GENCTRL, bOldIntCtrl);

    return rc;
}       //ToggleIRQLine


/***LP  GetPICIRR - Read PIC IRR
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      returns the IRR mask from PIC
 */

USHORT GetPICIRR(VOID)
{
    USHORT wData;

    //
    // Delay 2 usec before reading PIC because serial IRQ may be a bit slow.
    //
    TimeOut(4);

    _asm mov al,PIC_RD_IR
    _asm out PIC2_OCW3,al
    _asm in  al,PIC2_OCW3
    _asm mov ah,al

    _asm mov al,PIC_RD_IR
    _asm out PIC1_OCW3,al
    _asm in  al,PIC1_OCW3

    _asm mov  wData,ax

    return wData;
}       //GetPICIRR



UCHAR
PcicReadSocket(
    PPCCARD_INFORMATION pa,
    USHORT Reg
    )
{
    USHORT IoBase = pa->IoBase;
    UCHAR value;
    _asm {
      mov   dx, IoBase
      mov   ax, Reg
      out   dx, al
      inc   dx
      in    al, dx
      mov   value, al
      }
    return value;
}    
    
VOID
PcicWriteSocket(
    PPCCARD_INFORMATION pa,
    USHORT Reg,
    UCHAR value
    )
{
    USHORT IoBase = pa->IoBase;
    _asm {
      mov   dx, IoBase
      mov   ax, Reg
      out   dx, al
      inc   dx
      mov   al, value
      out   dx, al
      }
}    


UCHAR PCIDeref[4][4] = { {4,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };
    
VOID
SetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID pvBuffer,
    USHORT Length
    )
    
{
    USHORT                  IoSize;
    PUCHAR                  Buffer = (PUCHAR) pvBuffer;
    //
    // Read it
    //
    while (Length) {
        pa->PciCfg1.u.bits.RegisterNumber = Offset / sizeof(ULONG);

        IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        SetPCIType1Data (pa->PciCfg1.u.AsULONG,
                        (Offset % sizeof(ULONG)),
                         Buffer,
                         IoSize);

        Offset += IoSize;
        Buffer += IoSize;
        Length -= IoSize;
    }
}    



VOID
GetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID pvBuffer,
    USHORT Length
    )
{
    USHORT                  IoSize;
    USHORT                  i;
    PUCHAR                  Buffer = (PUCHAR) pvBuffer;
    
    //
    // Zap input buffer
    //

    for (i=0; i < Length; i++) {
        Buffer[i] = 0xff;
    }

    //
    // Read it
    //
    while (Length) {
        pa->PciCfg1.u.bits.RegisterNumber = Offset / sizeof(ULONG);

        IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        GetPCIType1Data (pa->PciCfg1.u.AsULONG,
                        (Offset % sizeof(ULONG)),
                         Buffer,
                         IoSize);

        Offset += IoSize;
        Buffer += IoSize;
        Length -= IoSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pcibios.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pcibios.h

Abstract:

    This module contains support routines for the Pci Irq Routing.

Author:

    Santosh Jodh (santoshj) 15-Sept-1998


Environment:

    Kernel mode

--*/

#include "hwdetect.h"
#include "pcibios.h"

#define SUCCESSFUL                  0x00
#define BUFFER_TOO_SMALL            0x89

#define PIRT_SIGNATURE              0x52495024  // $PIR little endian

#if DBG
#define DebugPrint(x)       \
    {                       \
        BlPrint x;          \
        BlPrint("...\n");    \
    }
#else
#define DebugPrint(x)
#endif

typedef struct
{
    USHORT      BufferSize;
    UCHAR far   *Buffer;
}IRQ_ROUTING_OPTIONS, far *FPIRQ_ROUTING_OPTIONS;

typedef SLOT_INFO far *FPSLOT_INFO;

FPPCI_IRQ_ROUTING_TABLE
HwGetRealModeIrqRoutingTable(
    VOID
    )
{
    IRQ_ROUTING_OPTIONS     routeBuffer;
    FPPCI_IRQ_ROUTING_TABLE irqRoutingTable = NULL;
    USHORT                  pciIrqMask;
    UCHAR                   returnCode;
    USHORT                  size;
#if DBG
    FPSLOT_INFO				slotInfo;
    FPSLOT_INFO				lastSlot;
#endif

    routeBuffer.BufferSize = 0;
    routeBuffer.Buffer = NULL;

    returnCode = HwGetPciIrqRoutingOptions( &routeBuffer,
                                            &pciIrqMask);

    if (returnCode == BUFFER_TOO_SMALL)
    {
        if (routeBuffer.BufferSize)
        {
            DebugPrint(("PCI BIOS returned 0x%x as the size of IRQ routing options buffer", routeBuffer.BufferSize));
            size = routeBuffer.BufferSize + sizeof(PCI_IRQ_ROUTING_TABLE);
            irqRoutingTable = HwAllocateHeap(size, TRUE);
            if (irqRoutingTable)
            {
                routeBuffer.Buffer = (UCHAR far *)irqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE);
                returnCode = HwGetPciIrqRoutingOptions( &routeBuffer,
                                                        &pciIrqMask);
                if (returnCode == SUCCESSFUL)
                {
                    irqRoutingTable->Signature = PIRT_SIGNATURE;
                    irqRoutingTable->TableSize = size;
                    irqRoutingTable->Version = 0x0100;
                }
                else
                {
                    HwFreeHeap(size);
                    irqRoutingTable = NULL;
                    DebugPrint(("PCI BIOS returned error code 0x%x while getting the PCI IRQ routing table", returnCode));
                }
            }
            else
            {
                DebugPrint(("Could not allocate %d bytes of memory to read PCI IRQ routing table", size));
            }
        }
        else
        {
            DebugPrint(("PCI BIOS returned 0 size for PCI IRQ Routint table"));
        }
    }
    else
    {
        DebugPrint(("PCI BIOS returned error code 0x%x while getting the PCI IRQ routing table size", returnCode));
    }

#if DBG

    if (irqRoutingTable)
    {
	    BlPrint("*** Real-mode PCI BIOS IRQ Routing Table - BEGIN ***\n\n");

		BlPrint("Exclusive PCI IRQ mask = 0x%x\n", pciIrqMask);
        BlPrint("----------------------------------------------------------------\n");
        BlPrint("Bus Device  LnkA  Mask  LnkB  Mask  LnkC  Mask  LnkD  Mask  Slot\n");
        BlPrint("----------------------------------------------------------------\n");	
		for (	slotInfo = (FPSLOT_INFO)((UCHAR far *)irqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE)),
					lastSlot = (FPSLOT_INFO)((UCHAR far *)irqRoutingTable + irqRoutingTable->TableSize);
				slotInfo < lastSlot;
				slotInfo++)
		{
			BlPrint("0x%x    0x%x     0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x\n",
                                    slotInfo->BusNumber,
                                    slotInfo->DeviceNumber >> 3,
                                    slotInfo->PinInfo[0].Link, slotInfo->PinInfo[0].InterruptMap,
                                    slotInfo->PinInfo[1].Link, slotInfo->PinInfo[1].InterruptMap,
                                    slotInfo->PinInfo[2].Link, slotInfo->PinInfo[2].InterruptMap,
                                    slotInfo->PinInfo[3].Link, slotInfo->PinInfo[3].InterruptMap,
                                    slotInfo->SlotNumber);
		}

	    BlPrint("\n*** Real-mode PCI BIOS IRQ Routing Table - END ***\n\n");

	    BlPrint("press any key to continue...\n");
	    while ( !HwGetKey() ) ; // wait until key pressed to continue
    }

#endif

    return (irqRoutingTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pcienum.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pcienum.h

Abstract:

    This module contains support routines for the Pci bus enumeration.

Author:

    Bassam Tabbara (bassamt) 05-Aug-2001


Environment:

    Real mode

--*/


#define PCI_ITERATOR_IS_VALID(i)        (i & 0x8000)
#define PCI_ITERATOR_TO_BUS(i)          (UCHAR)(((i) >> 8) & 0x7f)
#define PCI_ITERATOR_TO_DEVICE(i)       (UCHAR)(((i) >> 3) & 0x1f)
#define PCI_ITERATOR_TO_FUNCTION(i)     (UCHAR)(((i) >> 0) & 0x7)

#define PCI_TO_ITERATOR(b,d,f)          ((USHORT)(0x8000 | ((b)<<8) | ((d)<<3) | (f)))

//
// methods
//

ULONG PciReadConfig
(
    USHORT  nDevIt,
    ULONG   cbOffset,
    UCHAR * pbBuffer,
    ULONG   cbLength
);

ULONG PciWriteConfig
(
    USHORT  nDevIt,
    ULONG   cbOffset,
    UCHAR * pbBuffer,
    ULONG   cbLength
);

USHORT PciFindDevice
(
    USHORT   nVendorId,                                 // 0 = Wildcard
    USHORT   nDeviceId,                                 // 0 = Wildcard
    USHORT   nBegDevIt                                  // 0 = begin enumeration
);

BOOLEAN PciInit(PCI_REGISTRY_INFO *pPCIReg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pcibios.h ===
/*++                    

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pcibios.h

Abstract:

    This module contains support routines for the Pci Irq Routing.

Author:

    Santosh Jodh (santoshj) 15-Sept-1998
    
    
Environment:

    Kernel mode

--*/

#ifndef _PCIBIOS_

#define _PCIBIOS_

//
// Maximum number of interrupt pins possible on a single
// Pci device (CS offset 3D).
//

#define NUM_IRQ_PINS                        4

//
// Structure definitions for Pci Irq Routing.
//

#pragma pack(1)

//
// Structure of information for one link.
//

typedef struct _PIN_INFO {
    UCHAR   Link;
    USHORT  InterruptMap;
} PIN_INFO, *PPIN_INFO;

//
// Structure of information for one slot entry.
//

typedef struct _SLOT_INFO {
    UCHAR       BusNumber;
    UCHAR       DeviceNumber;
    PIN_INFO    PinInfo[NUM_IRQ_PINS];
    UCHAR       SlotNumber;
    UCHAR       Reserved[1];    
} SLOT_INFO, *PSLOT_INFO, far *FPSLOT_INFO;

//
// Structure of the $PIR table according to MS specification.
//

typedef struct _PCI_IRQ_ROUTING_TABLE {
    ULONG   Signature;
    USHORT  Version;
    USHORT  TableSize;
    UCHAR   RouterBus;
    UCHAR   RouterDevFunc;
    USHORT  ExclusiveIRQs;
    ULONG   CompatibleRouter;
    ULONG   MiniportData;
    UCHAR   Reserved0[11];
    UCHAR   Checksum;
} PCI_IRQ_ROUTING_TABLE, *PPCI_IRQ_ROUTING_TABLE, far *FPPCI_IRQ_ROUTING_TABLE;

//#pragma pack(pop)

//
// Calls PCI BIOS to get the IRQ Routing table.
//

FPPCI_IRQ_ROUTING_TABLE
HwGetRealModeIrqRoutingTable(
    VOID
    );

#endif  // _PCIBIOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pcienum.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pcienum.c

Abstract:

    This module contains support routines for the Pci bus enumeration.

Author:

    Bassam Tabbara (bassamt) 05-Aug-2001


Environment:

    Real mode

--*/

#include "hwdetect.h"
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
typedef PVOID PDEVICE_OBJECT;
#include "pci.h"
#include "pcienum.h"


#define PCI_FIXED_HDR_LENGTH                16          // Through BIST

#define UnusedParameter(x)  (void)x

#define X86_FLAG_IF     0x0200

#define TURN_INTERRUPTS_OFF(_s_) \
    __asm { \
        __asm pushf  \
        __asm pop ax  \
        __asm mov _s_,ax \
        __asm cli \
    }

#define RESTORE_INTERRUPTS(_s_) \
    do { \
        if ((_s_) & X86_FLAG_IF) { \
            __asm sti \
        } \
    } while (0)

//////////////////////////////////////////////////////////// PCI Mechanism #0.
//
static ULONG PciReadInt32_0(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg) 
{
    UnusedParameter(nBus);
    UnusedParameter(nDev);
    UnusedParameter(nFun);
    UnusedParameter(nReg);
    return ~0u;
}

static VOID PciWriteInt32_0(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    UnusedParameter(nBus);
    UnusedParameter(nDev);
    UnusedParameter(nFun);
    UnusedParameter(nReg);
    UnusedParameter(Data);
    return;
}

//////////////////////////////////////////////////////////// PCI Mechanism #1.
//
static ULONG PciReadInt32_1(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg) 
{
    USHORT fl;
    ULONG data = 0;
    PCI_TYPE1_CFG_BITS cfg;
    cfg.u.bits.Reserved1 = 0;
    cfg.u.bits.RegisterNumber = nReg >> 2;
    cfg.u.bits.FunctionNumber = nFun;
    cfg.u.bits.DeviceNumber = nDev;
    cfg.u.bits.BusNumber = nBus;
    cfg.u.bits.Reserved2 = 0;
    cfg.u.bits.Enable = 1;

    TURN_INTERRUPTS_OFF(fl);

    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_ADDR_PORT, (ULONG)cfg.u.AsULONG); // Select
    data = READ_PORT_ULONG((PUSHORT)PCI_TYPE1_DATA_PORT);       // Fetch

    RESTORE_INTERRUPTS(fl);

    return data;
}

static VOID PciWriteInt32_1(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    USHORT fl;
    PCI_TYPE1_CFG_BITS cfg;
    cfg.u.bits.Reserved1 = 0;
    cfg.u.bits.RegisterNumber = nReg >> 2;
    cfg.u.bits.FunctionNumber = nFun;
    cfg.u.bits.DeviceNumber = nDev;
    cfg.u.bits.BusNumber = nBus;
    cfg.u.bits.Reserved2 = 0;
    cfg.u.bits.Enable = 1;
            
    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_ADDR_PORT, cfg.u.AsULONG);  // Select
    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_DATA_PORT, Data);           // Write

    RESTORE_INTERRUPTS(fl);
}

//////////////////////////////////////////////////////////// PCI Mechanism #2.
//
static ULONG PciReadInt32_2(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg)
{
    USHORT fl;
    ULONG data = 0;
    PCI_TYPE2_CSE_BITS cse;
    PCI_TYPE2_ADDRESS_BITS adr;
    
    cse.u.bits.Enable = 1;
    cse.u.bits.FunctionNumber = nFun;
    cse.u.bits.Key = 0xf;

    adr.u.bits.RegisterNumber = nReg;
    adr.u.bits.Agent = nDev;
    adr.u.bits.AddressBase = PCI_TYPE2_ADDRESS_BASE;

    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_FORWARD_PORT, nBus);    // Select bus
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, cse.u.AsUCHAR);  // Select function & mapping
    data = READ_PORT_ULONG((PUSHORT)adr.u.AsUSHORT);              // Fetch
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, 0);            // Disable mapping.

    RESTORE_INTERRUPTS(fl);
    
    return data;
}

static VOID PciWriteInt32_2(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    USHORT fl;
    PCI_TYPE2_CSE_BITS cse;
    PCI_TYPE2_ADDRESS_BITS adr;
    
    cse.u.bits.Enable = 1;
    cse.u.bits.FunctionNumber = nFun;
    cse.u.bits.Key = 0xf;

    adr.u.bits.RegisterNumber = nReg;
    adr.u.bits.Agent = nDev;
    adr.u.bits.AddressBase = PCI_TYPE2_ADDRESS_BASE;

    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_FORWARD_PORT, nBus);    // Select bus
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, cse.u.AsUCHAR);  // Select function & mapping
    WRITE_PORT_ULONG((PUSHORT)adr.u.AsUSHORT, Data);              // Write
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, 0);            // Disable mapping.

    RESTORE_INTERRUPTS(fl);
}

/////////////////////////////////////////////////////////// PCI Configuration.
//
typedef ULONG (*PF_PCI_READ)(UCHAR nBus,
                              UCHAR nDev,
                              UCHAR nFun,
                              UCHAR nReg);
typedef VOID (*PF_PCI_WRITE)(UCHAR nBus,
                             UCHAR nDev,
                             UCHAR nFun,
                             UCHAR nReg,
                             ULONG Data);

static UCHAR            s_nPciMajorRevision = 0;
static UCHAR            s_nPciMinorRevision = 0;
static UCHAR            s_nPciNumberOfBuses = 0;
static PF_PCI_READ      s_pPciRead = PciReadInt32_0;
static PF_PCI_WRITE     s_pPciWrite = PciWriteInt32_0;

//////////////////////////////////////////////////////////////////////////////
//
ULONG PciReadConfig(USHORT nDevIt, ULONG cbOffset, UCHAR *pbData, ULONG cbData)
{
    ULONG cbDone;
    UCHAR nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nDevIt);
    UCHAR nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nDevIt);
    UCHAR nFun = (UCHAR)PCI_ITERATOR_TO_FUNCTION(nDevIt);
    
    // CONFIG space is a space of aligned DWORDs, according to specs.
    // Therefore, if Offset is not aligned the caller is confused.
    //
    if ((cbOffset & 0x3) || (cbData & 0x3)) {
#if DBG
        BlPrint("CPci::ReadConfig() called with Offset=x%x, Length=x%x\n", cbOffset, cbData);
#endif
        return 0;
    }

    for (cbDone = 0; cbDone < cbData; cbDone += sizeof(ULONG)) {
        *((ULONG*)pbData)++ = s_pPciRead(nBus, nDev, nFun,
                                           (UCHAR)(cbOffset + cbDone));
    }
    return cbDone;
}

ULONG PciWriteConfig(USHORT nDevIt, ULONG cbOffset, UCHAR *pbData, ULONG cbData)
{
    ULONG cbDone;
    UCHAR nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nDevIt);
    UCHAR nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nDevIt);
    UCHAR nFun = (UCHAR)PCI_ITERATOR_TO_FUNCTION(nDevIt);
    
    // CONFIG space is a space of aligned DWORDs, according to specs.
    // Therefore, if Offset is not aligned the caller is confused.
    //
    if ((cbOffset & 0x3) || (cbData & 0x3)) {
#if DBG
        BlPrint("CPci::ReadConfig() called with Offset=x%x, Length=x%x\n", cbOffset, cbData);
#endif
        return 0;
    }
    
    for (cbDone = 0; cbDone < cbData; cbDone += sizeof(ULONG)) {
        s_pPciWrite(nBus, nDev, nFun, (UCHAR)(cbOffset + cbDone),
                    *((ULONG*)pbData)++);
    }
    return cbDone;
}

USHORT PciFindDevice(USHORT VendorId, USHORT DeviceId, USHORT nBegDevIt)
{
    USHORT nDevIt;
    UCHAR nBus = 0;
    UCHAR nDev = 0;
    UCHAR nFun = 0;

    if (nBegDevIt != 0) {
        nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nBegDevIt);
        nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nBegDevIt);
        nFun = (UCHAR)(PCI_ITERATOR_TO_FUNCTION(nBegDevIt) + 1);
    }

    //
    // for each PCI bus     
    //
    for (; nBus < s_nPciNumberOfBuses; nBus++) {
        //
        // for each PCI Device on the bus
        //
        for (; nDev < PCI_MAX_DEVICES; nDev++) {

            BOOLEAN bIsMultiFunction;
            PCI_COMMON_CONFIG config;

            //
            // Check if we have a device on function 0
            //
            config.VendorID = PCI_INVALID_VENDORID;
            
            PciReadConfig( PCI_TO_ITERATOR(nBus, nDev, 0),
                           0, 
                           (UCHAR*)&config, 
                           PCI_FIXED_HDR_LENGTH );

            // No device on function 0, skip to next device
            if (config.VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            // check if the device is a multifunction device
            bIsMultiFunction = config.HeaderType & PCI_MULTIFUNCTION;
            
            for (; nFun < PCI_MAX_FUNCTION; nFun++) {

                // function numbers greater than zero
                // are only allowed on multifunction devices.
                if (nFun > 0 && !bIsMultiFunction) {
                    break;
                }

                // Read configuration header.
                //
                nDevIt = PCI_TO_ITERATOR(nBus, nDev, nFun);
                
                config.VendorID = PCI_INVALID_VENDORID;
                PciReadConfig(nDevIt, 0, (UCHAR*)&config, PCI_FIXED_HDR_LENGTH);

                // No function found, skip to next function
                if (config.VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }
                
                if (VendorId == 0 ||
                    (VendorId == config.VendorID &&
                     (DeviceId == 0 || DeviceId == config.DeviceID))) {
                    
                    return nDevIt;
                }
            }
            nFun = 0;
        }
        nDev = 0;
    }
    return 0;
}


BOOLEAN PciInit(PCI_REGISTRY_INFO *pPCIReg)
{
    s_nPciMajorRevision = pPCIReg->MajorRevision;
    s_nPciMinorRevision = pPCIReg->MinorRevision;
    s_nPciNumberOfBuses = pPCIReg->NoBuses;

    if ((pPCIReg->HardwareMechanism & 0x0F) == 1) {
        s_pPciRead = PciReadInt32_1;
        s_pPciWrite = PciWriteInt32_1;
    }
    else if ((pPCIReg->HardwareMechanism & 0x0F) == 2) {
        s_pPciRead = PciReadInt32_2;
        s_pPciWrite = PciWriteInt32_2;
    }
    else {
#if DBG
        BlPrint("Unknown PCI HW Mechanism!\n");
#endif
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file declares the constants, structures, and functions
*       used for accessing and using various BIOS interfaces.
*
****/

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT       0       /* init serial port */
#define _COM_SEND       1       /* send character */
#define _COM_RECEIVE    2       /* receive character */
#define _COM_STATUS     3       /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7       2       /* 7 bits characters */
#define _COM_CHR8       3       /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1      0       /* 1 stop bit */
#define _COM_STOP2      4       /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0       /* no parity */
#define _COM_ODDPARITY  8       /* odd parity */
#define _COM_EVENPARITY 24      /* even parity */

/*  baud rate initializers */

#define _COM_110        0       /* 110 baud */
#define _COM_150        32      /* 150 baud */
#define _COM_300        64      /* 300 baud */
#define _COM_600        96      /* 600 baud */
#define _COM_1200       128     /* 1200 baud */
#define _COM_2400       160     /* 2400 baud */
#define _COM_4800       192     /* 4800 baud */
#define _COM_9600       224     /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET     0       /* reset disk controller */
#define _DISK_STATUS    1       /* get disk status */
#define _DISK_READ      2       /* read disk sectors */
#define _DISK_WRITE     3       /* write disk sectors */
#define _DISK_VERIFY    4       /* verify disk sectors */
#define _DISK_FORMAT    5       /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void _far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ            0       /* read next character from keyboard */
#define _KEYBRD_READY           1       /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS     2       /* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ           0x10    /* read next character from keyboard */
#define _NKEYBRD_READY          0x11    /* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0       /* write character to printer */
#define _PRINTER_INIT   1       /* intialize printer */
#define _PRINTER_STATUS 2       /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0       /* get current clock count */
#define _TIME_SETCLOCK  1       /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _bios_disk(unsigned, struct diskinfo_t *);
unsigned _bios_equiplist(void);
unsigned _bios_keybrd(unsigned);
unsigned _bios_memsize(void);
unsigned _bios_printer(unsigned, unsigned, unsigned);
unsigned _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _bios_timeofday(unsigned, long *);
int int86(int, union REGS *, union REGS *);
int int86x(int, union REGS *, union REGS *, struct SREGS *);

#endif /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\pnpbios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosp.h

Abstract:

    PnP BIOS/ISA  sepc related definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, far *FPPNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, far *FPPNP_BIOS_INSTALLATION_CHECK;

//
// PnP BIOS ROM definitions
//

#define PNP_BIOS_START            0xF0000
#define PNP_BIOS_END              0xFFFFF
#define PNP_BIOS_HEADER_INCREMENT 16

//
// PnP BIOS API function codes
//

#define PNP_BIOS_GET_NUMBER_DEVICE_NODES 0
#define PNP_BIOS_GET_DEVICE_NODE 1
#define PNP_BIOS_SET_DEVICE_NODE 2
#define PNP_BIOS_GET_EVENT 3
#define PNP_BIOS_SEND_MESSAGE 4
#define PNP_BIOS_GET_DOCK_INFORMATION 5
// Function 6 is reserved.
#define PNP_BIOS_SELECT_BOOT_DEVICE 7
#define PNP_BIOS_GET_BOOT_DEVICE 8
#define PNP_BIOS_SET_OLD_ISA_RESOURCES 9
#define PNP_BIOS_GET_OLD_ISA_RESOURCES 0xA
#define PNP_BIOS_GET_ISA_CONFIGURATION 0x40


//
// SMBIOS function codes
#define GET_DMI_INFORMATION 0x50
#define GET_DMI_STRUCTURE 0x51
#define SET_DMI_STRUCTURE 0x52
#define GET_DMI_STRUCTURE_CHANGE_INFO 0x53
#define DMI_CONTROL 0x54
#define GET_GPNV_INFORMATION 0x55
#define READ_GPNV_DATA 0x56
#define WRITE_GPNV_DATA 0x57


typedef USHORT ( far * ENTRY_POINT) (int Function, ...);

//
// Control Flags for Get_Device_Node
//

#define GET_CURRENT_CONFIGURATION 1
#define GET_NEXT_BOOT_CONFIGURATION 2


//
// SMBIOS definitions

typedef SMBIOS_EPS_HEADER far *FPSMBIOS_EPS_HEADER;
typedef SMBIOS_STRUCT_HEADER far *FPSMBIOS_STRUCT_HEADER;
typedef DMIBIOS_EPS_HEADER far *FPDMIBIOS_EPS_HEADER;

//
// We cannot accomodate more than this amount of SMBIOS data to be passed 
// from NTDETECT to NTOSKRNL. 
#define MAXSMBIOS20SIZE 0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\comlpt.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for comport detection code.
    The code is extracted from NT Hal for kernel debugger.

Author:

    Shie-Lin Tzong (shielint) Dec-23-1991.

Revision History:

--*/

#define MAX_COM_PORTS   4           // Max. number of comports detectable
#define MAX_LPT_PORTS   3           // Max. number of LPT ports detectable

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT
#define COM4_PORT

#define BAUD_RATE_9600_MSB  0x0
#define BAUD_RATE_9600_LSB  0xC
#define IER_TEST_VALUE 0xF

//
// Offsets from the base register address of the
// various registers for the 8250 family of UARTS.
//
#define RECEIVE_BUFFER_REGISTER         (0x00u)
#define TRANSMIT_HOLDING_REGISTER       (0x00u)
#define INTERRUPT_ENABLE_REGISTER       (0x01u)
#define INTERRUPT_IDENT_REGISTER        (0x02u)
#define FIFO_CONTROL_REGISTER           (0x02u)
#define LINE_CONTROL_REGISTER           (0x03u)
#define MODEM_CONTROL_REGISTER          (0x04u)
#define LINE_STATUS_REGISTER            (0x05u)
#define MODEM_STATUS_REGISTER           (0x06u)
#define DIVISOR_LATCH_LSB               (0x00u)
#define DIVISOR_LATCH_MSB               (0x01u)
#define SERIAL_REGISTER_LENGTH          (7)

//
// These masks define access to the line control register.
//

//
// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
//
#define SERIAL_LCR_DLAB     0x80

//
// This defines the bit used to control whether the device is sending
// a break.  When this bit is set the device is sending a space (logic 0).
//
// Most protocols will assume that this is a hangup.
//
#define SERIAL_LCR_BREAK    0x40


//
// This macro writes to the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ModemControl - The control bits to send to the modem control.
//
//

#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)          \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+MODEM_CONTROL_REGISTER,                  \
        (ModemControl)                                         \
        );                                                     \
} while (0)

//
// This macro reads the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_CONTROL(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_CONTROL_REGISTER))

//
// This macro reads the interrupt identification register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Note that this routine potententially quites a transmitter
// empty interrupt.  This is because one way that the transmitter
// empty interrupt is cleared is to simply read the interrupt id
// register.
//
//
#define READ_INTERRUPT_ID_REG(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_IDENT_REGISTER))



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\disk.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    flo_data.h

Abstract:

    This file includes data and hardware declarations for the BIOS
    disk and floppy.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Notes:

--*/



//
// CMOS related definitions and macros
//

#define CMOS_CONTROL_PORT 0x70          // cmos command port
#define CMOS_DATA_PORT 0x71             // cmos data port
#define CMOS_FLOPPY_CONFIG_BYTE 0x10

//
// The length of CBIOS floppy parameter table
//

#define FLOPPY_PARAMETER_TABLE_LENGTH 28

//
// The CM_FLOPPY_DEVICE_DATA we use here is the newly updated one.
// To distinguish this, we set the version number in the CM_FLOPPY_DEVICE_DATA
// to 2. (Otherwise, it should be < 2)
//

#define CURRENT_FLOPPY_DATA_VERSION 2

extern USHORT NumberBiosDisks;

//
// External References
//

extern
BOOLEAN
IsExtendedInt13Available (
    IN USHORT DriveNumber
    );

extern
USHORT
GetExtendedDriveParameters (
    IN USHORT DriveNumber,
    IN CM_DISK_GEOMETRY_DEVICE_DATA far *DeviceData
    );

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

VOID
GetDiskId(
    USHORT Drive,
    PUCHAR Identifier
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif


#if (_MSC_VER <= 600)
#define __cdecl _cdecl
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* function prototypes */

void * _memccpy(void *, const void *, int, unsigned int);
void * memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
int _memicmp(const void *, const void *, unsigned int);
void * memcpy(void *, const void *, size_t);
void * memmove(void *, const void *, size_t);
void * memset(void *, int, size_t);
void _far * _far _fmemset(void _far *, int, size_t);
void _far * _far _fmemcpy(void _far *, const void _far *, size_t);
char * strcat(char *, const char *);
char * strchr(const char *, int);
int strcmp(const char *, const char *);
int _strcmpi(const char *, const char *);
int strcoll(const char *, const char *);
int _stricmp(const char *, const char *);
char * strcpy(char *, const char *);
char _far * _far _fstrcpy(char _far *, const char _far *);
size_t strcspn(const char *, const char *);
char * _strdup(const char *);
char * _strerror(const char *);
char * strerror(int);
size_t strlen(const char *);
char * _strlwr(char *);
char * strncat(char *, const char *, size_t);
char _far * _far _fstrcat(char _far *, const char _far *);
int strncmp(const char *, const char *, size_t);
int _strnicmp(const char *, const char *, size_t);
char * strncpy(char *, const char *, size_t);
char * _strnset(char *, int, size_t);
char * strpbrk(const char *, const char *);
char * strrchr(const char *, int);
char * _strrev(char *);
char * _strset(char *, int);
size_t strspn(const char *, const char *);
char * strstr(const char *, const char *);
char _far * _far _fstrstr(const char _far *, const char _far *);
char * strtok(char *, const char *);
char * _strupr(char *);
size_t strxfrm (char *, const char *, size_t);
char * itoa(int, char *, int);
char * ultoa(unsigned long, char *, int);

#if !__STDC__
/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup   _strdup
#define strlwr   _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev   _strrev
#define strset   _strset
#define strupr   _strupr
#endif

#ifdef __cplusplus
}
#endif

#define _INC_STRING
#endif  /* _INC_STRING */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 hardware detection.


Author

      Shie-Lin Tzong (shielint) Feb-15-1992

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const
#define POINTER_32
#define FIRMWARE_PTR POINTER_32

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef LONG LONG_PTR;
typedef LONG_PTR *PLONG_PTR;

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG ULONG_PTR;
typedef ULONG_PTR *PULONG_PTR;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\video.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    video.inc
;
; Abstract:
;
;    This module implements the assembley definitions necessary to determine
;    display adapter type.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 15-July-1991.
;    Most of the stuff is extracted from win31 setup code.
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

;
; Display type definitions.
;   BIT 16-31 Defines video adapter type
;   bit 0     0 - color; 1 - mono
;   bit 1-7   Reserved
;   bit 8-15  Adapter specific information.
;

VD_UNKNOWN              EQU     0
VD_COLOR                EQU     0
VD_MONO                 EQU     1
VD_VGA                  EQU     10000h
VD_COMPAQ_AVGA          EQU     20000H
VD_COMPAQ_QVIS          EQU     30000H
VD_8514                 EQU     40000H
VD_GENOA_VGA            EQU     50000H
VD_VIDEO7_VGA           EQU     60000H
VD_TRIDENT_VGA          EQU     70000H
VD_PARADISE_VGA         EQU     80000H
VD_ATI_VGA              EQU     90000H
VD_TSENGLAB_VGA         EQU     0A0000H
VD_CIRRUS_VGA           EQU     0B0000H
VD_DELL_DGX             EQU     0C0000H
VD_S3                   EQU     0D0000H
VD_NCR_77C22            EQU     0E0000H
VD_WD_90C               EQU     0F0000H
VD_XGA                  EQU     100000H
IFDEF NEC_98
VD_PC9801               EQU     010000h
ENDIF ; NEC_98

;
; Monitor type for 8514
; NOte, 0 is not used.
;

VF_MONITOR_VGA          EQU     100h            ; Stand VGA
VF_MONITOR_MONO_8503    EQU     200h            ; mono 8503
VF_MONITOR_GAD_8514     EQU     300h            ; 8514 type monitor

;
; Video 7 VGA specific flags
;

VF_V7_VRAM              EQU     100H
VF_V7_DRAM              EQU     200H

;
; NCR 77C2x specific flags
;

VF_NCR_77C22E           EQU     100H

;
; WD90Cxx specific flags
;

VF_WD_00                EQU     100H
VF_WD_30                EQU     200H
VF_WD_31                EQU     300H

;
; Trident VGA specific flags
;

VF_TVGA_9100            EQU     100h

;
; Paradise VGA specific flags
;

VF_PVGA_PROM            EQU     100h            ; with Paradise ROM
VF_PVGA_CHIP_1F         EQU     200h            ; with 1F chip

;
; ATI VGA  specific flags
;

VF_ATIVGA_WONDDER3      EQU     100h

;
; Tseng Lab VGA specific flags
;

VF_TLVGA_ET3000         EQU     0
VF_TLVGA_ET4000         EQU     100h

;
; Cirrus Logic VGA specific definitions
;

VF_CLVGA_REVC           EQU     100h            ; 610/620 rev C
;
; 070193 - adrianc
; Added the Cirrus chip detection for COMPAQ servers.
;
VF_CLVGA_5420r0         EQU     200h            ; COMPAQ Cirrus implementations
VF_CLVGA_5420r1         EQU     300h
VF_CLVGA_5428           EQU     400h
VF_CLVGA_542x           EQU     500h

;
; Equates for 8514 register ports.
;

ERR_TERM        equ     92e8h       ; 8514 error term register.
SUBSYS_STAT     equ     42e8h       ; 8514 Subsystem status register.

;
;  Video display register equates
;       ...Colr are for CGA and EGA color modes
;       ...Mono are for EGA/VGA monochrome modes
;
;NAMING CONVENTIONS
; pXXXXX is a I/O port definition
; fXXXXX is a bit mask
; bXXXXX is a bit number
; mXXXXX is a bit mask (multiple fXXXX)
; vXXXXX is a value to output/input to/from a port
; xXXXXX is a specific index

;
; CRT registers
;

pCRTCIndxColr   EQU     3D4h            ; CRTC index register
pCRTCIndxMono   EQU     3B4h

pCRTCDataColr   EQU     3D5h            ; CRTC data register
pCRTCDataMono   EQU     3B5h

; Status register
;

pStatColr       EQU     3DAh            ; Status register
pStatMono       EQU     3BAh
fStatEna        EQU     00000001b       ;   Video RAM access OK for processor
fStatLPTr       EQU     00000010b       ;   Light pen triggered
fStatLPSw       EQU     00000100b       ;   Light pen switch is "on"
fStatVRTC       EQU     00001000b       ;   Vertical retrace in progress
mStat_IVal      EQU     fStatEna+fStatVRTC  ; Initial value for pseudo status

;
; Feature control
;

pFeatColr       EQU     pStatColr       ; Feature control
pFeatMono       EQU     pStatMono
pFeatVGAIn      EQU     3CAh            ; VGA feature control read
fFeatFC0        EQU     00000001b       ;   FC0
fFeatFC1        EQU     00000010b       ;   FC1

;
; Light pen
;

pLPen1Colr      EQU     3DBh            ; Light pen latch clear
pLPen1Mono      EQU     3BBh
pLPen2Colr      EQU     3DCh            ; Light pen latch set
pLPen2Mono      EQU     3BCh

;
; Misc input/output
;

pMisc           EQU     3C2h            ; Miscellaneous output
pMiscIn         EQU     3CCh            ; VGA read Misc. output
fMiscPNum       EQU     00000001b       ;   3Dx port numbers(vs. 3Bx)
fMiscREna       EQU     00000010b       ;   Ram enable
fMiscDot        EQU     00001100b       ;   Dot clock select
fMiscOSrc       EQU     00010000b       ;   Output source
fMiscPage       EQU     00100000b       ;   Page bit for odd/even mode
fMiscHPol       EQU     01000000b       ;   Horizontal retrace polarity
fMiscVPol       EQU     10000000b       ;   Vertical retrace polarity
mMiscCRTC       EQU     fMiscREna+fMiscPage ; Mask for CRTC bits
mMiscMemC       EQU     0FFh - mMiscCRTC    ; Mask for MemC bits

;
; Misc. status
;

pStt0EGA        EQU     pMisc           ; Miscellaneous status
fStt0Swit       EQU     00010000b       ;   Switch sense(addr'd by dot clk sel)
fStt0FCI0       EQU     00100000b       ;   Feature card input 0
fStt0FCI1       EQU     01000000b       ;   Feature card input 1
fStt0VRTC       EQU     10000000b       ;   VRTC

;
; Attribute control
;

pAttr           EQU     3C0h            ; Attribute(palette) address/data
fVAI_Indx       EQU     10000000b       ; sign bit of Attribute index is
bVAI_Indx       EQU     7               ;   flag indicating port is index
fVAI_ScOn       EQU     00100000b       ; Indicates screen is on
bVAI_ScOn       EQU     5

;
; Sequencer
;

pSeqIndx        EQU     3C4h            ; Sequencer address
pSeqData        EQU     3C5h            ; Sequencer data
fSeq0ARst       EQU     00000001b       ;   0:Async reset
fSeq0SRst       EQU     00000010b       ;   0:Sync reset
fSeq1DPCh       EQU     00000001b       ;   1:Dots per character
fSeq1BWid       EQU     00000010b       ;   1:Band Width
fSeq1ShLd       EQU     00000100b       ;   1:Shift load(0=every char, 1=skip)
fSeq1DClk       EQU     00001000b       ;   1:Dot clock(=1 if halved)
mSeq2WMsk       EQU     00001111b       ;   2:Write mask
mSeq3ChrB       EQU     00000011b       ;   3:Char map B select(attr bit 3 = 0)
mSeq3ChrA       EQU     00001100b       ;   3:Char map A select(attr bit 3 = 1)
fSeq4Alph       EQU     00000001b       ;   4:Alpha mode(char gen enabled)
fSeq4ExtM       EQU     00000010b       ;   4:Extended memory installed
fSeq4SqAd       EQU     00000100b       ;   4:Seq'l mem addr'ing(vs. odd/even)
fSeq4Chain4     EQU     00001000b       ;   4:Chain 4 (double odd/even) for
                                        ;     256 color (mode 13)

fSeqF9extpgsel  EQU     00000001b       ;V7F9:Extended page select
fSeqFCext256m   EQU     00000010b       ;V7FC:Extended 256 color mode
fSeqFCext256e   EQU     00000100b       ;V7FC:Extended 256 color enable
fSeqFCseqChain4 EQU     00100000b       ;V7FC:Sequential Chain 4

;
; Graphic controller
;

pGrp1Pos        EQU     3CCh            ; Graphics posn 1(=0)
pGrp2Pos        EQU     3CAh            ; Graphics posn 2(=1)
pGrpIndx        EQU     3CEh            ; Graphics controller address
pGrpData        EQU     3CFh            ; Graphics controller data
fGrp0StV0       EQU     00000001b       ;   0:Value for plane 0 if enabled
fGrp0StV1       EQU     00000010b       ;   0:Value for plane 1 if enabled
fGrp0StV2       EQU     00000100b       ;   0:Value for plane 2 if enabled
fGrp0StV3       EQU     00001000b       ;   0:Value for plane 3 if enabled
fGrp1Ena0       EQU     00000001b       ;   1:Enable for plane 0
fGrp1Ena1       EQU     00000010b       ;   1:Enable for plane 1
fGrp1Ena2       EQU     00000100b       ;   1:Enable for plane 2
fGrp1Ena3       EQU     00001000b       ;   1:Enable for plane 3
mGrp2Colr       EQU     00001111b       ;   2:Color compare value
mGrp3RCnt       EQU     00000111b       ;   3:Rotate left count for mode 0
mGrp3Func       EQU     00011000b       ;   3:Function for modes 0 and 2
mGrp4RMsk       EQU     00000111b       ;   4:Read map select
mGrp5WMod       EQU     00000011b       ;   5:Write mode
fGrp5Test       EQU     00000100b       ;   5:Test condition
fGrp5RMod       EQU     00001000b       ;   5:Read mode(0=plane,1=compare)
fGrp5SqAd       EQU     00010000b       ;   5:Seq'l mem addr'ing(vs. odd/even)
fGrp5CGA        EQU     00100000b       ;   5:CGA 4 color mode addressing
fGrp6Char       EQU     00000001b       ;   6:Char or graphics
fGrp6Chain      EQU     00000010b       ;   6:Chain odd maps after even
mGrp6Addr       EQU     00001100b       ;   6:Processor view of VRAM start addr
                                        ;       00=A000 for 128kb
                                        ;       01=A000 for 64kb
                                        ;       10=B000 for 32kb
                                        ;       11=B800 for 32kb
bGrp6Addr       EQU          2          ;     First of 2 bits for start addr
mGrp7Colr       EQU     00001111b       ;   7:Color don't care for read compare
                                        ;   8:Mask: use latch value vs. data

;
; VGA subsystem enable
;

pVGAEna         EQU     3C3h            ; VGA enable register
fVGAEna         EQU     00000001b       ;   Enable access to VGA

;
; VGA DAC
;

pDACWindx       EQU     3C8h            ; DAC Write index(R/W)
pDACRindx       EQU     3C7h            ; DAC Read index(RO)
pDACState       EQU     pDACRindx       ; DAC state
pDACData        EQU     3C9h            ; DAC data(3 successive accesses)
pDACMask        EQU     3CAh            ; DAC mask

;
; VGA read access to write only registers
;

pMiscRead       EQU     3CCh            ; Port to read Misc output register
pFeatRead       EQU     3CAh            ; Port to read Feature output register

;
; 8514 DAC
;

p8514DACWindx   EQU     2ECh            ; DAC Write index(R/W)
p8514DACRindx   EQU     2EBh            ; DAC Read index(RO)
p8514DACState   EQU     pDACRindx       ; DAC state
p8514DACData    EQU     2EDh            ; DAC data(3 successive accesses)

;
; values returned from reads of port pDACState:
;

vDAC_Read_Mode  EQU     0
vDAC_Write_Mode EQU     3


xC_CTMiscRead   EQU     0Fh             ; CHIPS Misc output read index
xC_CTFeatRead   EQU     0Eh             ; CHIPS Feat output read index
xC_CT400        EQU     0F9h            ; CHIPS 400 line reg index
xC_CTTempFE     EQU     0FEh            ; CHIPS CRTC temp reg FEh
xG_CTCtl        EQU     0F7h            ; CHIPS control reg index

;

pCMode          EQU     3C6h            ; Control mode(Compaq specific)

ATiVGA_extended_reg     EQU     01ceh

TVGA_3C5_B_WrMode       equ     0
TVGA_3C5_B_RdMode       equ     1

;
; Definition for IBM XGA video adapter Id.
;

IBM_XGA_ID_LOW  EQU     8FD8h
IBM_XGA_ID_HIGH EQU     8FDBh
MCA_POS_DATA_SIZE EQU   6

;
; Misc. V7 VRAM definitions
;

VRAM2_ROM_ID_1          EQU     108h
VRAM2_ROM_ID_2          EQU     208h
VRAM2ERGO_ROM_ID        EQU     308h
V7_ID_OFFSET            EQU     86h     ; The offset to V7VGA ROM id

;
; WD extended registers
;

WD_EXT_IO_PORT          EQU     23C0h

;
; Misc. definitions
;

FONT_POINTERS   EQU     700h            ; physical addr to store font pointers
                                        ; This is also the DOS loaded area
VIDEO_SEG       EQU     0C000h          ; Video memory segment
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _BTEISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT PhysicalAddress_LSW;
    UCHAR PhysicalAddress_MSB;
    USHORT MemorySize;
} BTEISA_MEMORY_CONFIGURATION, *PBTEISA_MEMORY_CONFIGURATION;

//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _BTEISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} BTEISA_IRQ_CONFIGURATION, *PBTEISA_IRQ_CONFIGURATION;

//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIG_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIG_BYTE0;

typedef struct _DMA_CONFIG_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIG_BYTE1;

typedef struct _BTEISA_DMA_CONFIGURATION {
    DMA_CONFIG_BYTE0 ConfigurationByte0;
    DMA_CONFIG_BYTE1 ConfigurationByte1;
} BTEISA_DMA_CONFIGURATION, *PBTEISA_DMA_CONFIGURATION;

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *TEISA_PORT_DESCRIPTOR;

typedef struct _BTEISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} BTEISA_PORT_CONFIGURATION, *PBTEISA_PORT_CONFIGURATION;

typedef struct _BTEISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} BTEISA_SLOT_INFORMATION, *PBTEISA_SLOT_INFORMATION,
  far *FPBTEISA_SLOT_INFORMATION;

typedef struct _BTEISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    BTEISA_MEMORY_CONFIGURATION EisaMemory[9];
    BTEISA_IRQ_CONFIGURATION EisaIrq[7];
    BTEISA_DMA_CONFIGURATION EisaDma[4];
    BTEISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} BTEISA_FUNCTION_INFORMATION, *PBTEISA_FUNCTION_INFORMATION,
  far *FPBTEISA_FUNCTION_INFORMATION;

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\acpibios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpibios.h

Abstract:

    ACPI BIOS  spec related definitions

Author:

    Jake Oshins (jakeo) Feb 6, 1997

Revision History:

--*/

//
// Acpi BIOS Installation check
//

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT 
} ACPI_BIOS_INSTALLATION_CHECK, far *FPACPI_BIOS_INSTALLATION_CHECK;

#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\comlptc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    comport.c

Abstract:

    This module contains C code to determine comport and LPT configuration in
    syste.

Author:

    Shie-Lin Tzong (shielint) Dec-23-1991

Revision History:

--*/

#include "hwdetect.h"
#include "comlpt.h"
#include "bios.h"
#include "string.h"

#define LOWEST_IRQ 3
#define MASTER_IRQ_MASK_BITS 0xf8
#define SLAVE_IRQ_MASK_BITS 0xfe

//
// ComPortAddress[] is a global array to remember which comports have
// been detected and their I/O port addresses.
//

#if defined(NEC_98)

#define NEC_MAX_COM_PORTS     15
#define NEC_MAX_IO_PATTERN    38
#define FIFO_INT_ID_PRS1    0x40    
#define FIFO_INT_ID_PRS     0x60    

#define COUNTRY_JAPAN  81
#define NEC1500        0x1500   // Old mode
#define NEC1501        0x1501   // SuperIO
#define NEC1502        0x1502   // SuperIO2
#define NEC1503        0x1503   // 2ndCCU 16550 Controller
#define NEC8071        0x8071   // Extended Board of 1stCCU Compatibility Controller
#define NEC0C01        0x0C01   // Extended Board of 16550 Compatibility Controller
//
// PC-9801-94 ports
//
#define TOKI_CONTROL        0x549

#define READ_DIVISOR_LATCH( PDesiredDivisor )                     \
do                                                                \
{                                                                 \
    PUCHAR Address;                                               \
    PSHORT PDivisor = PDesiredDivisor;                            \
    UCHAR LineControl;                                            \
    UCHAR Lsb;                                                    \
    UCHAR Msb;                                                    \
    LineControl = READ_PORT_UCHAR( (PUCHAR)0x23b );               \
    WRITE_PORT_UCHAR((PUCHAR)0x23b,(UCHAR)0x80 );                 \
    Lsb = READ_PORT_UCHAR( (PUCHAR)0x238 );                       \
    Msb = READ_PORT_UCHAR( (PUCHAR)0x239 );                       \
    *PDivisor = Lsb;                                              \
    *PDivisor = *PDivisor | (((USHORT)Msb) << 8);                 \
    WRITE_PORT_UCHAR((PUCHAR)0x23b,(UCHAR)0x0 );                  \
} while (0)

#define WRITE_DIVISOR_LATCH(BaseAddress,DesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    SHORT Divisor = DesiredDivisor;                               \
    UCHAR LineControl;                                            \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_LSB,                                \
        (UCHAR)(Divisor & 0xff)                                   \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_MSB,                                \
        (UCHAR)((Divisor & 0xff00) >> 8)                          \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

#define NextComPortNumber(ComportName, PortNumber)       \
do                                                       \
{                                                        \
    if (PortNumber < 9){                                 \
        ComportName[3] = PortNumber + (UCHAR)'1';        \
        ComportName[4] = '\0';                           \
    }else{                                               \
        ComportName[3] = (UCHAR)'1';                     \
        ComportName[4] = (PortNumber - 10) + (UCHAR)'1'; \
        ComportName[5] = '\0';                           \
    }                                                    \
    ++PortNumber;                                        \
}while(0)                                                \

USHORT   ComPortAddress[NEC_MAX_COM_PORTS] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#else // NEC_98
USHORT   ComPortAddress[MAX_COM_PORTS] = {0, 0, 0, 0};
#endif // NEC_98

#if defined(NEC_98)
VOID
NEC2ndCCUInitialize (
        VOID
        )

/*++

Routine Description:

    
    We have to initialize 2ndCCU(NS16550A) after system reset.
    Because the initial value of this chip is instability.
    
Arguments:

    None.

Return Value:

    None.

--*/

{

        _asm { cli }
        WRITE_PORT_UCHAR( (PUCHAR)0x0411,(UCHAR)0x91 );
        IoDelay(1);
        WRITE_PORT_UCHAR( (PUCHAR)0x0413,(UCHAR)0x01 );
        IoDelay(1);

        //
        //  set baudrate.
        //
        WRITE_PORT_UCHAR( (PUCHAR)0x023B,(UCHAR)0x80 );
        IoDelay(1);
        WRITE_DIVISOR_LATCH( (PUCHAR)0x0238,(SHORT)0x0060 );
        IoDelay(1);
        WRITE_PORT_UCHAR( (PUCHAR)0x023B,(UCHAR)0x00 );
        IoDelay(1);

        WRITE_PORT_UCHAR( (PUCHAR)0x0413,(UCHAR)0x08 );

        //
        // wait 5 micro sec
        //
        IoDelay(5);
        WRITE_PORT_UCHAR( (PUCHAR)0x0413,(UCHAR)0x01 );
        IoDelay(1);
        _asm { sti }

        //
        // initialize - END
        //
}

BOOLEAN
FifoPresenceCheck (
        PUCHAR PortAddress
        )

/*++

Routine Description:

    This routine reports whether the resource have FIFO faculty. 

Arguments:

    None.

Return Value:

    Will return true if the resource have, otherwise it
    will return false.

--*/

{
    BOOLEAN FifoStatus = TRUE;
    USHORT cnt;
    UCHAR tmp;

    WRITE_PORT_UCHAR( (PUCHAR)(PortAddress - 0x1) , (UCHAR)(0x03) );

    IoDelay(10);
    tmp = READ_PORT_UCHAR( (PUCHAR)PortAddress );
    IoDelay(10);
    if ((tmp & FIFO_INT_ID_PRS1) == 0) {
        tmp = READ_PORT_UCHAR( (PUCHAR)PortAddress );
        IoDelay(10);
    }

    for (cnt = 0;cnt < 2;cnt++){
        tmp = READ_PORT_UCHAR( (PUCHAR)PortAddress );
        IoDelay(10);
        if ((tmp & FIFO_INT_ID_PRS) != 0){
            FifoStatus = FALSE;
            break;
        }
        tmp = READ_PORT_UCHAR( (PUCHAR)PortAddress );
        IoDelay(10);
        if ((tmp & FIFO_INT_ID_PRS) != 0x40){
            FifoStatus = FALSE;
            break;
        }
    }

    return(FifoStatus);
}

BOOLEAN
DoesPortExistNEC101(
    SHORT PortNumber,
    PUSHORT InterruptNumber,
    PUSHORT PortLength
    )
{
    BOOLEAN PortExist = FALSE;
    USHORT Port = PortNumber;
    USHORT NEC_y = 0;
    USHORT IsCommonInterrupt;
    USHORT temp1,temp2;
    USHORT Ch_2_IRQ_Tbl[4]   = {3,5,6,9};         
    USHORT Ch_3_IRQ_Tbl[4]   = {3,10,12,13};      
    USHORT COMMON_IRQ_Tbl[7] = {3,5,6,9,10,12,13};

    NEC_y = ( ( Port ) & (0x0f00) );  

    switch (Port & 0x00ff) {
        case 0x00b0:
            if ( READ_PORT_UCHAR((PUCHAR)(NEC_y | 0x00b3)) != 0xff ) {
                PortExist = TRUE;
            }
            break;
        case 0x00b2:
            if ( READ_PORT_UCHAR((PUCHAR)(NEC_y | 0x00bb)) != 0xff ) { 
                PortExist = TRUE;
            }
            break;
        default:
            break;
    }

    //
    // This check is necessary to know detecting PC-9861K is not support.
    //
    if (( PortExist == TRUE ) &&
        ( FifoPresenceCheck((PUCHAR)(Port | 0x0005)) == FALSE)){
        PortExist = FALSE;
    }

    if (PortExist == TRUE){
        IsCommonInterrupt = ( (0x04) & (READ_PORT_UCHAR((PUCHAR)(NEC_y | 0x00b8))) ); 
        IoDelay(10);

        if( IsCommonInterrupt ){
            temp1 = ( (0x03) & ( READ_PORT_UCHAR((PUCHAR)(NEC_y | Port))) ); 
            IoDelay(10);
            if( ( Port & (0x00ff) ) == 0x00b0 ){
                *InterruptNumber = Ch_2_IRQ_Tbl[temp1];
            }else{
                *InterruptNumber = Ch_3_IRQ_Tbl[temp1];
            }
        }else{
            temp1 = ( 0x01 & (READ_PORT_UCHAR((PUCHAR)(NEC_y | 0x00b0))) ); 
            IoDelay(10);
            temp2 = ( 0x03 & (READ_PORT_UCHAR((PUCHAR)(NEC_y | 0x00b2))) ); 
            IoDelay(10);
            *InterruptNumber = COMMON_IRQ_Tbl[(((temp1 << 2) | temp2) & 0x07)]; 
        }

        *PortLength = 1;
    }

    return(PortExist);

}

BOOLEAN
DoesPortExistNECFaxModem(
    SHORT PortNumber,
    PUSHORT InterruptNumber,
    PUSHORT PortLength
    )
{
    BOOLEAN PortExist = FALSE;
    USHORT Port = PortNumber;
    USHORT temp;


    temp = READ_PORT_UCHAR( (PUCHAR)(Port | 0x000f) );

    if ((temp & 0x0f0) == 0) {

        switch ( temp & 0x0f ) {
            case 0x01:
                *InterruptNumber = 3;
                break;
            case 0x02:
                *InterruptNumber = 5;
                break;
            case 0x04:
                *InterruptNumber = 6;
                break;
            case 0x08:
                *InterruptNumber = 12;
                break;
            default:
                break;
        }

        if (*InterruptNumber != 0) {
            PortExist = TRUE;
        }
        *PortLength = 8;
    }

    return(PortExist);

}
#endif // NEC_98

#if !defined(_GAMBIT_)
VOID
SerialInterruptRequest (
    PUCHAR PortAddress
    )

/*++

Routine Description:

    This routine generates an interrupt on the interrupt line for
    com port.

Arguments:

    PortAddress - the port address of the desired com port.

Return Value:

    None.
--*/

{

    USHORT i;
    UCHAR Temp;

    WRITE_PORT_UCHAR(
        PortAddress + MODEM_CONTROL_REGISTER,
        8
        );

    WRITE_PORT_UCHAR(
        PortAddress + INTERRUPT_ENABLE_REGISTER,
        0
        );

    WRITE_PORT_UCHAR(
        PortAddress + INTERRUPT_ENABLE_REGISTER,
        0xf
        );

    //
    // Add some delay
    //

    for (i = 0; i < 5 ; i++ ) {
        Temp = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
        Temp = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);
    }
}
VOID
SerialInterruptDismiss (
    PUCHAR PortAddress
    )

/*++

Routine Description:

    This routine dismisses an interrupt on the interrupt line for
    com port.

Arguments:

    PortAddress - the port address of the desired com port.

Return Value:

    None.
--*/

{
    USHORT i;
    UCHAR Temp;

    Temp = READ_PORT_UCHAR(
                PortAddress + INTERRUPT_IDENT_REGISTER
                );

    WRITE_PORT_UCHAR(
                PortAddress + INTERRUPT_ENABLE_REGISTER,
                0
                );

    //
    // Add some delay
    //

    for (i = 0; i < 5 ; i++ ) {
        Temp = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
        Temp = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);
    }
}

BOOLEAN
DoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine examines several of what might be the serial device
    registers.  It ensures that the bits that should be zero are zero.
    It will then attempt to set the device to 19200 baud.  If the
    will then attempt to read that baud.  If it is still 19200 then
    we can feel pretty safe that this is a serial device.

    NOTE: If there is indeed a serial port at the address specified
          it will absolutely have interrupts inhibited upon return
          from this routine.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.  Party on.

    FALSE - Port doesn't exist.  Don't use it.

History:
    7/23/97 a-paulbr fixed bug 95050.  Init LineControl to 0x00

--*/

{

    UCHAR IerContents;
    UCHAR BaudRateMsb, BaudRateLsb;
    BOOLEAN ReturnValue = FALSE;
    UCHAR LineControl = 0x00;
    UCHAR LineControl_Save;
    UCHAR Temp;

    //
    // Save the original LCR, so we can restore it later
    // We won't use it, because the port could be handing us
    // a bad initial value.  We will use 0x00 instead.
    //

    LineControl_Save = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER);

    //
    // Read original baud rate divisor and save it.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );
    BaudRateMsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);
    BaudRateLsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);

    //
    // Change baud rate to 9600.
    //

    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_MSB, BAUD_RATE_9600_MSB);
    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_LSB, BAUD_RATE_9600_LSB);

    //
    // Read IER and save it away.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );
    IerContents = READ_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER
        );

    WRITE_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER,
        IER_TEST_VALUE
        );

    //
    // Read baud rate divisor.  The values we read should be equal to the
    // values we set earlier.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );
    Temp = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);
    if (Temp != BAUD_RATE_9600_MSB) {
        goto AllDone;
    }
    Temp = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);
    if (Temp != BAUD_RATE_9600_LSB) {
        goto AllDone;
    }

    //
    // Read IER and it should be equal to the value we set earlier.
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );
    Temp = READ_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER
        );
    if (Temp != IER_TEST_VALUE) {
        goto AllDone;
    }
    ReturnValue = TRUE;

AllDone:

    //
    // Restore registers which we destroyed .
    //

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl & ~SERIAL_LCR_DLAB)
        );

    WRITE_PORT_UCHAR(
        Address + INTERRUPT_ENABLE_REGISTER,
        IerContents
        );

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)
        );

    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_MSB, BaudRateMsb);
    WRITE_PORT_UCHAR(Address+DIVISOR_LATCH_LSB, BaudRateLsb);

    WRITE_PORT_UCHAR(
        Address+LINE_CONTROL_REGISTER,
        LineControl_Save
        );

    return ReturnValue;
}

BOOLEAN
HwInterruptDetection(
    IN PUCHAR BasePort,
    IN VOID (*InterruptRequestRoutine)(),
    IN VOID (*InterruptDismissRoutine)(),
    OUT PUSHORT Vector
    )

/*++

Routine Description:

    This routine attempts to locate the interrupt vector for which
    the device is configured.  The allowable vectors are
    3 - 7, and 9 - 15.  If no interrupt vector is found, or more than
    one is found, the routine returns FALSE.  Otherwise, TRUE is returned.

    Note that we diddle the i8259 interrupt controllers here.

Arguments:

    BasePort - the I/O port base for the device.

    InterruptRequestRoutine - A pointer to a routine to generate
                desired interrupt.

    InterruptDismissRoutine - A pointer to a routine to dismiss the interrupt
                generated by InterruptRequestRoutine.

    Vector - Pointer to the location to store the mouse interrupt vector.

Return Value:

    Returns TRUE if the Inport interrupt vector was located; otherwise,
    FALSE is returned.

--*/

{
    UCHAR OldMasterMask, OldSlaveMask;
    UCHAR MasterMask, SlaveMask;
    UCHAR InterruptBits;
    UCHAR PossibleInterruptBits;
    int i;
    int NumberOfIRQs;
    BOOLEAN VectorFound = FALSE;

    //
    // Get the i8259 interrupt masks.
    //

    OldMasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
    OldSlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

    //
    // Raise IRQL to the highest priority IRQL the inport would use.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) 0xff ^ ((UCHAR)(1 << LOWEST_IRQ) - 1)
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        (UCHAR) 0xfe
        );

    //
    // Get the master i8259 interrupt mask.
    //

    MasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);

    //
    // Disable potential device interrupts.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) (MasterMask | MASTER_IRQ_MASK_BITS)
        );

    //
    // Attempt to locate the interrupt line on the master i8259.
    // Why try this 10 times?  It's magic...
    //

    PossibleInterruptBits = MASTER_IRQ_MASK_BITS;
    for (i = 0; i < 10; i++) {


        //
        // Generate a 0 on the master 8259 interrupt line
        //

        (*InterruptDismissRoutine)(BasePort);

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 3 - 7 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        _asm {cli}
        WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);
        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        _asm {sti}
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        InterruptBits ^= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;
        if (!PossibleInterruptBits) {
            break;
        }

        //
        // Generate an interrupt from the desired device.
        //

        (*InterruptRequestRoutine)(BasePort);

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 3 - 7 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        _asm {cli}
        WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);
        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        _asm {sti}
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits) {
            break;
        }
    }

    if (PossibleInterruptBits) {

        //
        // We found at least one IRQ on the master i8259 that could belong
        // to the Inport mouse.  Count how many we found.  If there is
        // more than one, we haven't found the vector.  Otherwise, we've
        // successfully located the Inport interrupt vector on the master
        // i8259 (provided the interrupt vector is 3, 4, 5, or 7).
        //

        PossibleInterruptBits >>= 3;
        NumberOfIRQs = 0;
        for (i = 3; i <= 7; i++) {
            if (PossibleInterruptBits & 1) {
                NumberOfIRQs += 1;
                *Vector = (CCHAR) i;
            }
            PossibleInterruptBits >>= 1;
        }
        if (NumberOfIRQs == 1) {
            VectorFound = TRUE;
        }
    }

    //
    // If we didn't locate the interrupt vector on the master i8259, attempt
    // to locate it on the slave i8259.
    //

    if (!VectorFound) {

        //
        // Get the slave i8259 interrupt mask.
        //

        SlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

        //
        // Attempt to locate the interupt line on the slave i8259.
        // Why try this 20 times?  It's magic...
        //

        PossibleInterruptBits = SLAVE_IRQ_MASK_BITS;
        for (i = 0; i < 20; i++) {

            //
            // Generate a 0 on the Inport IRQ on the slave i8259.
            //

            (*InterruptDismissRoutine)(BasePort);

            //
            // Read the interrupt bits off the slave i8259.
            // Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            _asm {cli}
            WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);
            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            _asm {sti}
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            InterruptBits ^= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;
            if (!PossibleInterruptBits) {
                break;
            }

            //
            // Generate a 1 on the Inport IRQ on the slave i8259.
            //

            (*InterruptRequestRoutine)(BasePort);

            //
            // Read the interrupt bits off the slave i8259.
            // Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            _asm {cli}
            WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);
            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            _asm {sti}
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits) {
                break;
            }

        }

        if (PossibleInterruptBits) {

            //
            // We found at least one IRQ on the slave i8259 that could belong
            // to the device.  Count how many we found.  If there is
            // more than one, we haven't found the vector.  Otherwise, we've
            // successfully located the device interrupt vector on the slave
            // i8259.
            //

            PossibleInterruptBits >>= 1;
            NumberOfIRQs = 0;
            for (i = 9; i <= 15; i++) {
                if (PossibleInterruptBits & 1) {
                    NumberOfIRQs += 1;
                    *Vector = (CCHAR) i;
                }
                PossibleInterruptBits >>= 1;
            }
            if (NumberOfIRQs == 1) {
                VectorFound = TRUE;
            }
        }

        //
        // Restore the i8259 slave.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_ISR);

        //
        // Restore the i8259 slave interrupt mask.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT1, SlaveMask);
    }

    //
    // Dismiss interrupt on the device
    //

    (*InterruptDismissRoutine)(BasePort);

    //
    // Restore the i8259 master.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_ISR);

    //
    // Restore the i8259 master interrupt mask.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT1, MasterMask);

    //
    // Restore the previous IRQL.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        OldMasterMask
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        OldSlaveMask
        );

    return(VectorFound);
}
#endif // _GAMBIT_

FPFWCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the comports information
    for the system.  The information includes port address, irq
    level.

    Note that this routine can only detect up to 4 comports and
    it assumes that if MCA, COM3 and COM4 use irq 4.  Otherwise,
    COM3 uses irq 4 and COM4 uses irq 3.  Also, the number of ports
    for COMPORT is set to 8 (for example, COM2 uses ports 2F8 - 2FF)

Arguments:

    None.

Return Value:

    A pointer to a stucture of type FWCONFIGURATION_COMPONENT_DATA
    which is the root of comport component list.
    If no comport exists, a value of NULL is returned.

--*/

{
#if defined(NEC_98)

    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstComport = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR i, j, z;
    SHORT Port;
    UCHAR ComportName[] = "COM??";
    CM_SERIAL_DEVICE_DATA SerialData;
    ULONG BaudClock = 1843200;
    USHORT Vector;
    BOOLEAN PortExist;
    USHORT IoPorts[NEC_MAX_IO_PATTERN] = {0x030,  0x238,
                                          0x00b0, 0x00b2, 0x01b0, 0x01b2, 0x02b0, 0x02b2,
                                          0x03b0, 0x03b2, 0x04b0, 0x04b2, 0x05b0, 0x05b2,
                                          0x06b0, 0x06b2, 0x07b0, 0x07b2, 0x08b0, 0x08b2,
                                          0x09b0, 0x09b2, 0x0ab0, 0x0ab2, 0x0bb0, 0x0bb2,
                                          0x0cb0, 0x0cb2, 0x0db0, 0x0db2, 0x0eb0, 0x0eb2,
                                          0x0fb0, 0x0fb2,
                                          0x8b0,  0x9b0,  0xab0,  0xbb0};
    USHORT PortLength;
    USHORT InterruptNumber;
    USHORT NEC_COM_number = 0;

    //
    // Check BIOS ROM data is right or not.
    // if not, we don't detect CCU.
    //
    if ( (COM_ID_L != 0x98) || (COM_ID_H != 0x21) ){
        return(FirstComport);
    }

    //
    // Initialize serial device specific data
    //

    SerialData.Version = COUNTRY_JAPAN;
    SerialData.Revision = NEC1500;
    SerialData.BaudClock = 153600;  

    for (i = 0; i < NEC_MAX_IO_PATTERN; i++) {

        PortExist = FALSE;

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // Load the port address from the BIOS data area, if it exists
        //

        Port = IoPorts[i];
        InterruptNumber = 0;

        switch(i){
            case 0:
                 //
                 // internal 1st CCU
                 //
                 if ( (ROM_FLAG7 & LOCKED_CCU1) == 0 ) {
                     PortExist = TRUE;
                     InterruptNumber = 4;
                     PortLength = 1;
                     SerialData.Revision = NEC1501;
                     if (ROM_FLAG5 & 0x10) {
                         SerialData.Revision = NEC1502;
                     }
                 }
                 break;

            case 1:
                 //
                 // internal 2nd CCU
                 //
                 if ( (ROM_FLAG5 & 0x08) && ((ROM_FLAG7 & LOCKED_CCU2) == 0) ) {
                     PortExist = DoesPortExist( (PUCHAR)Port );
                     InterruptNumber = 5;
                     PortLength = 7;
                     SerialData.Revision  = NEC1503;
                     SerialData.BaudClock = 1843200;
                 }
                 break;

            case 34:
            case 35:
            case 36:
            case 37:
                 //
                 // external FAX/Modem board
                 //
                 PortExist = DoesPortExistNECFaxModem(Port,&InterruptNumber,&PortLength);
                 SerialData.Revision  = NEC0C01;
                 SerialData.BaudClock = 1843200;
                 break;

            default:
                 //
                 // PC-9801-101 borad
                 //
                 PortExist = DoesPortExistNEC101(Port,&InterruptNumber,&PortLength);
                 SerialData.Revision  = NEC8071;
                 SerialData.BaudClock = 153600;  
                 break;
        }

        if (PortExist) {

            //
            // Remember the port address in our global variable
            // such that other detection code (e.g. Serial Mouse) can
            // get the information.
            //

            ComPortAddress[NEC_COM_number] = Port;

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
            if (!FirstComport) {
                FirstComport = CurrentEntry;
            }
            Component = &CurrentEntry->ComponentEntry;

            Component->Class = ControllerClass;
            Component->Type = SerialController;
            Component->Flags.ConsoleOut = 1;
            Component->Flags.ConsoleIn = 1;
            Component->Flags.Output = 1;
            Component->Flags.Input = 1;
            Component->Version = 0;
            Component->Key = NEC_COM_number;
            Component->AffinityMask = 0xffffffff;

            //
            // Set up type string.
            //

            NextComPortNumber(ComportName, NEC_COM_number);
//            ComportName[3] = NEC_COM_number + (UCHAR)'1';
//            NEC_COM_number++;

            //
            // Set up Port information
            //

            ControlData.NumberPortEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_PORT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
            ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
            ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)Port;
            ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
            ControlData.DescriptorList[z].u.Port.Length = PortLength;
            z++;

            //
            // Set up Irq information
            //

            ControlData.NumberIrqEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareUndetermined;
            ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;       
            ControlData.DescriptorList[z].u.Interrupt.Level  =  InterruptNumber;
            ControlData.DescriptorList[z].u.Interrupt.Vector =  InterruptNumber;

            ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;


            CurrentEntry->ConfigurationData =
                            HwSetUpResourceDescriptor(Component,
                                                      ComportName,
                                                      &ControlData,
                                                      sizeof(SerialData),
                                                      (PUCHAR)&SerialData
                                                      );
            if (PreviousEntry) {
                PreviousEntry->Sibling = CurrentEntry;
            }
            PreviousEntry = CurrentEntry;

            if (Port == 0x238){
                NEC2ndCCUInitialize ();
            }
        }
    }
    return(FirstComport);
#else // NEC_98

    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstComport = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR i, j, z;
    SHORT Port;
    UCHAR ComportName[] = "COM?";
    CM_SERIAL_DEVICE_DATA SerialData;
    ULONG BaudClock = 1843200;
    USHORT Vector;
    BOOLEAN PortExist;
    USHORT IoPorts[MAX_COM_PORTS] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};


#if !defined(_GAMBIT_)
    //
    // BIOS DATA area 40:0 is the port address of the first valid COM port
    //

    USHORT far *pPortAddress = (USHORT far *)0x00400000;
#endif

    //
    // Initialize serial device specific data
    //

    SerialData.Version = 0;
    SerialData.Revision = 0;
    SerialData.BaudClock = 1843200;

#if !defined(_GAMBIT_)
    //
    // Initialize default COM port address.
    // Some BIOS puts incorrect comport address to the 40:0 area.
    // To cope with this problem, we test the port address supplied
    // by BIOS first.  If it fail, we try our default port.
    //

    for (i = 0; i < MAX_COM_PORTS; i++) {
        for (j = 0; j < MAX_COM_PORTS; j++) {
            if (IoPorts[i] == *(pPortAddress + j)) {
                IoPorts[i] = 0;
                break;
            }
        }
    }
#endif

#if defined(_GAMBIT_)
    for (i = 0; i < 1; i++) {
#else
    for (i = 0; i < MAX_COM_PORTS; i++) {
#endif

        PortExist = FALSE;

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

#if _GAMBIT_
        Port = IoPorts[i];
        PortExist = TRUE;
#else
        //
        // Load the port address from the BIOS data area, if it exists
        //

        Port = *(pPortAddress + i);

        //
        // Determine if the port exists
        //

        if (Port != 0) {
            if (DoesPortExist((PUCHAR)Port)) {
                PortExist = TRUE;
            }
        }
        if (!PortExist && (Port = IoPorts[i])) {
            if (PortExist = DoesPortExist((PUCHAR)Port)) {
                IoPorts[i] = 0;
                *(pPortAddress+i) = (USHORT)Port;
            }
        }
#endif //_GAMBIT_
        if (PortExist) {

            //
            // Remember the port address in our global variable
            // such that other detection code (e.g. Serial Mouse) can
            // get the information.
            //

            ComPortAddress[i] = Port;

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
            if (!FirstComport) {
                FirstComport = CurrentEntry;
            }
            Component = &CurrentEntry->ComponentEntry;

            Component->Class = ControllerClass;
            Component->Type = SerialController;
            Component->Flags.ConsoleOut = 1;
            Component->Flags.ConsoleIn = 1;
            Component->Flags.Output = 1;
            Component->Flags.Input = 1;
            Component->Version = 0;
            Component->Key = i;
            Component->AffinityMask = 0xffffffff;

            //
            // Set up type string.
            //

            ComportName[3] = i + (UCHAR)'1';

            //
            // Set up Port information
            //

            ControlData.NumberPortEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_PORT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
            ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
            ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)Port;
            ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
            ControlData.DescriptorList[z].u.Port.Length = 7;
            z++;

            //
            // Set up Irq information
            //

            ControlData.NumberIrqEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareUndetermined;
            if (HwBusType == MACHINE_TYPE_MCA) {
                ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
                if (i == 0) { // COM1 - irql4; COM2 - COM3 - irq3
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                }
            } else {

                //
                // For EISA the LevelTriggered is temporarily set to FALSE.
                // COM1 and COM3 use irq 4; COM2 and COM4 use irq3
                //

                ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                if (Port == 0x3f8 || Port == 0x3e8) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else if (Port == 0x2f8 || Port == 0x2e8) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                } else if (i == 0 || i == 2) {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 4;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
                } else {
                    ControlData.DescriptorList[z].u.Interrupt.Level = 3;
                    ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
                }
            }

            ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;

            //
            // Try to determine the interrupt vector.  If we success, the
            // new vector will be used to replace the default value.
            //

#if !defined(_GAMBIT_)
            if (HwInterruptDetection((PUCHAR)Port,
                                     SerialInterruptRequest,
                                     SerialInterruptDismiss,
                                     &Vector)) {

                ControlData.DescriptorList[z].u.Interrupt.Level =
                                     (ULONG)Vector;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                     (ULONG)Vector;
            }

            //
            // Since the com port interrupt detection destryed some
            // of the com port registers, here we do the clean up.
            //

            WRITE_PORT_UCHAR ((PUCHAR)(Port + INTERRUPT_ENABLE_REGISTER), 0);
            WRITE_PORT_UCHAR ((PUCHAR)(Port + MODEM_CONTROL_REGISTER), 0);
#endif //_GAMBIT_

            CurrentEntry->ConfigurationData =
                            HwSetUpResourceDescriptor(Component,
                                                      ComportName,
                                                      &ControlData,
                                                      sizeof(SerialData),
                                                      (PUCHAR)&SerialData
                                                      );
            if (PreviousEntry) {
                PreviousEntry->Sibling = CurrentEntry;
            }
            PreviousEntry = CurrentEntry;
        }
    }
    return(FirstComport);
#endif // NEC_98
}

#if !defined(_GAMBIT_)
FPFWCONFIGURATION_COMPONENT_DATA
GetLptInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the parallel printer port
    information for the system.  The information includes port address,
    irq level.

    Note if this code is run after user established NETWORK LPT
    connection.  The Network LPT will be counted as regular parallel
    port.

Arguments:

    None.

Return Value:

    A pointer to a stucture of type PONENT_DATA
    which is the root of Parallel component list.
    If no comport exists, a value of NULL is returned.

--*/

{

    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstLptPort = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR LptPortName[] = "PARALLEL?";
    USHORT i, z;
    USHORT LptStatus;
    ULONG Port;

#if defined(NEC_98)
    ULONG Portnec;
    int   lptportnumnec;
    UCHAR level;
    UCHAR   j = 0;
    UCHAR   tmp;
    USHORT  PortAddress[MAX_LPT_PORTS] = { 0, 0, 0 };
    USHORT far *pPortAddress = &PortAddress;

    //
    // check the internal LPT port is locked.
    //

    if ( COM_ID_L == 0x98 && COM_ID_H == 0x21 &&
         ROM_FLAG7 & LOCKED_LPT ){

        // The LPT was locked .
        // skip the internal LPT port.

    } else {

        //
        // try to set full centro mode
        //
        _asm {
            push    ax
            mov     ah, 17h
            int     1Ah
            mov     tmp, ah
            pop     ax
        }

        if ( BIOS_FLAG5 & PRTMODE_FULL_CENTRO ){
            PortAddress[0] = 0x140;     // Full centro-mode
        } else {
            PortAddress[0] = 0x40;      // Old type.
        }
        j++;
    }

    //
    // check the external LPT ports.
    //
    // NOTE:
    //   There is check codes that external port is starting LPT1 or LPT2.
    //  at here in PC-98's old original source.
    //   It read 0x054F(Int Ch Read) port and check CAON (bit2).
    //  If the bit is clear, then the port is starting LPT1.
    //   I could not understand its raison d'e^tre.
    //

    tmp = READ_PORT_UCHAR( (PUCHAR)TOKI_CONTROL );
    if ( tmp == 0xFF ){
        //
        // There is no external LPT ports.
        //

        PortAddress[j]   = 0;
        PortAddress[j+1] = 0;
    } else {
        //
        // There is a extended card (PC-9801-94).
        // It has 2 LPT ports.
        // Change them to Full centro mode.
        //

        PortAddress[j]   = 0x540;
        WRITE_PORT_UCHAR( (PUCHAR)0x0549, (UCHAR)0x10 );
        WRITE_PORT_UCHAR( (PUCHAR)0x054E, (UCHAR)0x00 );
        WRITE_PORT_UCHAR( (PUCHAR)0x0542, (UCHAR)0x04 );

        PortAddress[j+1] = 0xD40;
        WRITE_PORT_UCHAR( (PUCHAR)0x0D49, (UCHAR)0x10 );
        WRITE_PORT_UCHAR( (PUCHAR)0x0D4E, (UCHAR)0x00 );
        WRITE_PORT_UCHAR( (PUCHAR)0x0D42, (UCHAR)0x04 );

        //
        // get int level
        //

        tmp = READ_PORT_UCHAR( (PUCHAR)0x54F );
        switch( tmp & 0x3 ){
            case    0x00:
                level = 3;  // Extended slot INT 0
                break;
            case    0x01:
                level = 5;  // Extended slot INT 1
                break;
            case    0x10:
                level = 6;  // Extended slot INT 2
                break;
            case    0x11:
                level = 13; // Extended slot INT 6
        }
    }

#else // NEC_98
    //
    // BIOS DATA area 40:8 is the port address of the first valid COM port
    //

    USHORT far *pPortAddress = (USHORT far *)0x00400008;
#endif // NEC_98

    for (i = 0; i < MAX_LPT_PORTS; i++) {

        Port = (ULONG)*(pPortAddress + i);
        if (Port == 0) {
            continue;
#if defined(NEC_98)
#else
        } else {

            //
            // If we think we have a lpt, we will initialize it to
            // a known state.   In order to make printing work under
            // nt, the arbitration level must be disabled.  The BIOS
            // init function seems to do the trick.
            //

            _asm {
                    mov     ah, 1
                    mov     dx, i
                    int     17h
            }
#endif
        }

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

#if defined(NEC_98)
        //
        // We do not have to determine if the port exists.
        // Because it was already done.
        //

        LptStatus = 0;
#else // NEC_98
        //
        // Determine if the port exists
        //

        LptStatus = _bios_printer(_PRINTER_STATUS, i , 0);
#endif // NEC_98
        if (!(LptStatus & 6)){
            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
            if (!FirstLptPort) {
                FirstLptPort = CurrentEntry;
            }
            Component = &CurrentEntry->ComponentEntry;

            Component->Class = ControllerClass;
            Component->Type = ParallelController;
            Component->Flags.Output = 1;
            Component->Version = 0;
            Component->Key = i;
            Component->AffinityMask = 0xffffffff;

            //
            // Set up type string.
            //

            LptPortName[8] = (UCHAR)i + (UCHAR)'1';

            //
            // Set up Port information
            //

            Port = (ULONG)*(pPortAddress + i);
#if defined(NEC_98)
            if (Port == 0x40){
                ControlData.NumberPortEntries = 4;
                for ( j = 0; j < ControlData.NumberPortEntries; j++ ){
                    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                    ControlData.DescriptorList[z].ShareDisposition =
                                                  CmResourceShareDeviceExclusive;
                    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                    ControlData.DescriptorList[z].u.Port.Start.LowPart = Port + (j * 2);
                    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                    ControlData.DescriptorList[z].u.Port.Length = 1;
                    z++;
                }
            }else{
#endif // NEC_98
            ControlData.NumberPortEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_PORT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
            ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
            ControlData.DescriptorList[z].u.Port.Start.LowPart = Port;
            ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
            ControlData.DescriptorList[z].u.Port.Length = 3;
            z++;
#if defined(NEC_98)
            }
#endif // NEC_98

            //
            // Set up Irq information
            //

            ControlData.NumberIrqEntries = 1;
            ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
            ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareUndetermined;
            ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
#if defined(NEC_98)
            if (i ==0) {
                ControlData.DescriptorList[z].u.Interrupt.Level = 14;
                ControlData.DescriptorList[z].u.Interrupt.Vector = 14;
            } else {
                ControlData.DescriptorList[z].u.Interrupt.Level = level;
                ControlData.DescriptorList[z].u.Interrupt.Vector = level;
            }
#else // NEC_98
            if (i ==0) {
                ControlData.DescriptorList[z].u.Interrupt.Level = 7;
                ControlData.DescriptorList[z].u.Interrupt.Vector = 7;
            } else {
                ControlData.DescriptorList[z].u.Interrupt.Level = 5;
                ControlData.DescriptorList[z].u.Interrupt.Vector = 5;
            }
#endif // NEC_98

            if (HwBusType == MACHINE_TYPE_MCA) {
                ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
            } else {

                //
                // For EISA the LevelTriggered is temporarily set to FALSE.
                //

                ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
            }

            CurrentEntry->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          LptPortName,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

            if (PreviousEntry) {
                PreviousEntry->Sibling = CurrentEntry;
            }
            PreviousEntry = CurrentEntry;
        }
    }
    return(FirstLptPort);
}
#endif //_GAMBIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\i386\videoa.asm ===
title  "Display Adapter type detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    video.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    various display chip sets.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 04-Dec-1991.
;    Most of the code is taken from Win31 vdd and setup code(with modification.)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

FONT_POINTERS   EQU     700h            ; physical addr to store font pointers
                                        ; This is also the DOS loaded area
.386


_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'


_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING

;++
;
; VOID
; GetVideoFontInformation (
;    VOID
;    )
;
; Routine Description:
;
;     This function does int 10h, function 1130 to get font information and
;     saves the pointers in the physical 700h addr.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
        ASSUME  DS:NOTHING
        public  _GetVideoFontInformation
_GetVideoFontInformation        proc    near

        push    ds
        push    es
        push    bp
        push    bx
        push    si

        mov     ax, FONT_POINTERS
        shr     ax, 4
        mov     ds, ax
        mov     si, FONT_POINTERS
        and     si, 0fh
        mov     bh, 2
@@:
        mov     ax, 1130h               ; Get font information
        int     10h

        mov     [si], bp
        add     si, 2
        mov     [si], es
        add     si, 2                   ; (si)= 8
        inc     bh
        cmp     bh, 8
        jb      short @b

        pop     si
        pop     bx
        pop     bp
        pop     es
        pop     ds
        ret

_GetVideoFontInformation        endp
_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\diskc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    diskc.c

Abstract:

    This is the NEC PD756 (aka AT, aka ISA, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette detection code for NT.  This file also
    collect BIOS disk drive parameters.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Revision History:


Notes:

--*/

//
// Include files.
//

#include "hwdetect.h"
#include "disk.h"
#if defined(NEC_98)
#include "string.h"
#else // PC98
#include <string.h>

#endif // PC98

FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
    VOID
    )

/*++

Routine Description:

    This routine tries to get floppy configuration information.

Arguments:

    None.

Return Value:

    A pointer to a FPCONFIGURATION_COMPONENT_DATA is returned.  It is
    the head of floppy component tree root.

--*/

{
    UCHAR DriveType;
    FPUCHAR ParameterTable;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstController = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR FloppyNumber = 0;
    UCHAR DiskName[30];
    UCHAR FloppyParmTable[FLOPPY_PARAMETER_TABLE_LENGTH];
    FPUCHAR fpString;
    USHORT Length, z;
    ULONG MaxDensity = 0;
    CM_FLOPPY_DEVICE_DATA far *FloppyData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    USHORT FloppyDataVersion;

#if defined(NEC_98)
    USHORT  DiskEquips;
    USHORT  Disk2HC;
    UCHAR   Counter = 0;
    BOOLEAN FdIoLocked = FALSE;
    UCHAR   status;
    UCHAR   driveExchange;

    DiskEquips = DISK_EQUIPS_FD;
    Disk2HC    = DISK_2HC;

    if ( (COM_ID_L == 0x98) && (COM_ID_H == 0x21) &&
         (ROM_FLAG7 & LOCKED_FD) ){

        FdIoLocked = TRUE;

    }
#endif // PC98
    for (z = 0; z < FLOPPY_PARAMETER_TABLE_LENGTH; z++ ) {
        FloppyParmTable[z] = 0;
    }

    //
    // Initialize Controller data
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;

    //
    // Allocate space for Controller component and initialize it.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    FirstController = CurrentEntry;
    Component = &CurrentEntry->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = DiskController;
    Component->Flags.Removable = 1;
    Component->Flags.Input = 1;
    Component->Flags.Output = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
#if defined(NEC_98)
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)0x90;
#else // PC98
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)0x3f0;
#endif // PC98
    ControlData.DescriptorList[z].u.Port.Start.HighPart = (ULONG)0;
    ControlData.DescriptorList[z].u.Port.Length = 8;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {
        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }
#if defined(NEC_98)
    ControlData.DescriptorList[z].u.Interrupt.Level = 11;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 0x13;
#else // PC98
    ControlData.DescriptorList[z].u.Interrupt.Level = 6;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 6;
#endif // PC98
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    z++;

    //
    // Set up DMA information. Only set channel number.  Timming and
    // transferSize are defaulted - 8 bits and ISA compatible.
    //

    ControlData.NumberDmaEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_DMA;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    ControlData.DescriptorList[z].Flags = 0;
    ControlData.DescriptorList[z].u.Dma.Channel = (ULONG)2;
    ControlData.DescriptorList[z].u.Dma.Port = 0;
    z++;

    CurrentEntry->ConfigurationData =
                    HwSetUpResourceDescriptor(Component,
                                              NULL,
                                              &ControlData,
                                              0,
                                              NULL
                                              );

#if _GAMBIT_
    //
    // Supply the DriveTypeValue that is supplied by the following IA
    // assembly programs.
    //
    DriveType = 0;
    FloppyDataVersion = 0;
    ParameterTable = NULL;
    
    //
    // Collect disk peripheral data
    //

    while (1) {
#else
#if defined(NEC_98)

        DriveType = 0;
        FloppyDataVersion = 0;
        driveExchange = 0;

        if ( DiskEquips & 0x0F ) {

            //
            // Check drive exchange.
            //
            status = READ_PORT_UCHAR((PUCHAR)0x94) & 0x04;

            if ( status == 0 ) {

                //
                // internal drive is #3/#4.
                //
                driveExchange = 1;
            }
        }

        if ( !(FdIoLocked) && Counter < 4 ){

            if ( DiskEquips & (1 << Counter ) ){

                //
                // Check internal drive or extension drive.
                //

                if ( (Counter / (UCHAR)2) == driveExchange ) {
                    if (Disk2HC & (1 << Counter)) {
                        //
                        // 1.44MB drive
                        //
                        DriveType = 4;

                    } else {
                        //
                        // 1.2MB drive
                        //
                        DriveType = 2;
                    }

                } else {
                    //
                    // 1.2MB extension drive.
                    //
                    DriveType = 7;
                }

                Counter++;

            } else {
                Counter++;
                continue;
            }
        }

#else // PC98
        _asm {
            push   es

            mov    DriveType, 0
            mov    FloppyDataVersion, CURRENT_FLOPPY_DATA_VERSION

            mov    ah, 15h
            mov    dl, FloppyNumber
            int    13h
            jc     short CmosTest

            cmp    ah, 0
            je     short Exit

            cmp    ah, 2                   ; make sure this is floppy
            ja     short Exit

            mov    ah, 8
            mov    dl, FloppyNumber
            lea    di, word ptr FloppyParmTable ; use 'word ptr' to quiet compiler
            push   ds
            pop    es                      ; (es:di)->dummy FloppyParmTable
            int    13h
            jc     short CmosTest

            mov    DriveType, bl
            mov    ax, es
            mov    word ptr ParameterTable + 2, ax
            mov    word ptr ParameterTable, di
            jmp    short Exit

        CmosTest:

            ;
            ; if int 13 fails, we know that floppy drive is present.
            ; So, we try to get the Drive Type from CMOS.
            ;

            mov     al, CMOS_FLOPPY_CONFIG_BYTE
            mov     dx, CMOS_CONTROL_PORT   ; address port
            out     dx, al
            jmp     $ + 2                   ; I/O DELAY
            mov     dx, CMOS_DATA_PORT      ; READ IN REQUESTED CMOS DATA
            in      al, dx
            jmp     $ + 2                   ; I/O DELAY

            cmp     FloppyNumber, 0
            jne     short CmosTest1

            and     al, 0xf0
            shr     al, 4
            jmp     short CmosTest2

        CmosTest1:
            cmp     FloppyNumber, 1
            jne     short Exit

            and     al, 0xf
        CmosTest2:
            mov     DriveType, al
            mov     FloppyDataVersion, 0
        Exit:
            pop     es
        }
#endif // PC98
#endif // _GAMBIT_

        if (DriveType) {

            //
            // Allocate space for first pripheral component and initialize it.
            //

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                           sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

            Component = &CurrentEntry->ComponentEntry;

            Component->Class = PeripheralClass;
            Component->Type = FloppyDiskPeripheral;
            Component->Version = 0;
            Component->Key = FloppyNumber;
            Component->AffinityMask = 0xffffffff;
            Component->ConfigurationDataLength = 0;

            //
            // Set up type string.
            //

            strcpy(DiskName, "FLOPPYx");
            DiskName[6] = FloppyNumber + (UCHAR)'1';
            Length = strlen(DiskName) + 1;
            fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
            _fstrcpy(fpString, DiskName);
            Component->IdentifierLength = Length;
            Component->Identifier = fpString;

            //
            // Set up floppy device specific data
            //

            switch (DriveType) {
            case 1:
                MaxDensity = 360;
                break;
            case 2:
                MaxDensity = 1200;
                break;
            case 3:
                MaxDensity = 720;
                break;
            case 4:
                MaxDensity = 1440;
                break;
            case 5:
            case 6:
                MaxDensity = 2880;
                break;
#if defined(NEC_98)
            case 7:
                MaxDensity = 1201;
                break;
#endif
            default:
                MaxDensity = 0;
                break;
            }
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                Length = sizeof(CM_FLOPPY_DEVICE_DATA);
            } else {
                Length = (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime);
            }
            DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                 Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST),
                                 TRUE);
            CurrentEntry->ConfigurationData = DescriptorList;
            Component->ConfigurationDataLength =
                             Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
            DescriptorList->Count = 1;
            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                        Length;
            FloppyData = (CM_FLOPPY_DEVICE_DATA far *)(DescriptorList + 1);
            FloppyData->MaxDensity = MaxDensity;
            FloppyData->Version = FloppyDataVersion;
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                _fmemcpy((FPCHAR)&FloppyData->StepRateHeadUnloadTime,
                         ParameterTable,
                         sizeof(CM_FLOPPY_DEVICE_DATA) -
                             (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime)
                         );
            }
            if (FloppyNumber == 0) {
                FirstController->Child = CurrentEntry;
            } else {
                PreviousEntry->Sibling = CurrentEntry;
            }
            CurrentEntry->Parent = FirstController;
            PreviousEntry = CurrentEntry;
            FloppyNumber++;
        } else {

            //
            // This is a *hack* for ntldr.  Here we create a arc name for
            // each bios disks such that ntldr can open them.
            //

            if (NumberBiosDisks != 0) {

                for (z = 0; z < NumberBiosDisks; z++) {

                    //
                    // Allocate space for disk peripheral component
                    //

                    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

                    Component = &CurrentEntry->ComponentEntry;

                    Component->Class = PeripheralClass;
                    Component->Type = DiskPeripheral;
                    Component->Flags.Input = 1;
                    Component->Flags.Output = 1;
                    Component->Version = 0;
                    Component->Key = z;
                    Component->AffinityMask = 0xffffffff;

                    //
                    // Set up identifier string = 8 digit signature - 8 digit checksum
                    // for example: 00fe964d-005467dd
                    //

                    GetDiskId((USHORT)(0x80 + z), DiskName);
                    if (DiskName[0] == (UCHAR)NULL) {
                        strcpy(DiskName, "BIOSDISKx");
                        DiskName[8] = (UCHAR)z + (UCHAR)'1';
                    }
                    Length = strlen(DiskName) + 1;
                    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
                    _fstrcpy(fpString, DiskName);
                    Component->IdentifierLength = Length;
                    Component->Identifier = fpString;

#if defined(NEC_98)
#else // PC98
#if !defined(_GAMBIT_)
                    //
                    // Set up BIOS disk device specific data.
                    // (If extended int 13 drive parameters are supported by
                    //  BIOS, we will collect them and store them here.)
                    //

                    if (IsExtendedInt13Available(0x80+z)) {
                        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                             sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                               sizeof(CM_DISK_GEOMETRY_DEVICE_DATA),
                                             TRUE);
                        Length = GetExtendedDriveParameters(
                                         0x80 + z,
                                         (CM_DISK_GEOMETRY_DEVICE_DATA far *)(DescriptorList + 1)
                                         );
                        if (Length) {
                            CurrentEntry->ConfigurationData = DescriptorList;
                            Component->ConfigurationDataLength =
                                         Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
                            DescriptorList->Count = 1;
                            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
                            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                                        Length;
                        } else {
                            HwFreeHeap(sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                       sizeof(CM_DISK_GEOMETRY_DEVICE_DATA));
                        }
                    }
#endif // _GAMBIT_
#endif // PC98

                    if (PreviousEntry == NULL) {
                        FirstController->Child = CurrentEntry;
                    } else {
                        PreviousEntry->Sibling = CurrentEntry;
                    }
                    CurrentEntry->Parent = FirstController;
                    PreviousEntry = CurrentEntry;
                }
            }
            return(FirstController);
        }
    }
}

VOID
GetDiskId(
    USHORT Disk,
    PUCHAR Identifier
    )

/*++

Routine Description:

    This routine reads the master boot sector of the specified harddisk drive,
    compute the checksum of the sector to form a drive identifier.

    The identifier will be set to "8-digit-checksum"+"-"+"8-digit-signature"
    For example:  00ff6396-6549071f

Arguments:

    Disk - supplies the BIOS drive number, i.e. 80h - 87h

    Identifier - Supplies a buffer to receive the disk id.

Return Value:

    None.  In the worst case, the Identifier will be empty.

--*/

{
#if defined(_GAMBIT_)
    Identifier = NULL;
#else
#if defined(NEC_98)
    USHORT BootRecordSignature;    // Boot Record Signature (0x55aa)
    UCHAR  diskNumber;
    UCHAR Sector[1024];
#else // PC98
    UCHAR Sector[512];
#endif // PC98
    ULONG Signature, Checksum;
    USHORT i, Length;
    PUCHAR BufferAddress;
    BOOLEAN Fail;

    Identifier[0] = 0;
    BufferAddress = &Sector[0];
    Fail = FALSE;

    //
    // Read in the first sector
    //

#if defined(NEC_98)
    //
    // We can't access over 4GB except relative access.
    // Therefore we use a relative(Sequential) access.
    //
    Disk &= 0x7F;
    diskNumber = (UCHAR)Disk;

    //
    //   Read sectors (NTFS Signature)
    //
    _asm {
          push    es
          mov     ah, 0x06             //  Disk read command
          mov     al, diskNumber       //  Disk No (00,01)
          mov     bx, 512              //  Data length
          mov     cx, 0x10             //  Sector LSW
          mov     dx, 0x00             //  Sector HSW
          push    ss
          pop     es
          push    bp
          mov     bp, BufferAddress    // ES:BP Buffer address
          int     0x1b
          pop     bp
          pop     es
          jnc     Gdi000

          mov     Fail, 1
    Gdi000:
    }
#else // PC98
    _asm {
          push    es
          mov     ax, 0x201
          mov     cx, 1
          mov     dx, Disk
          push    ss
          pop     es
          mov     bx, BufferAddress
          int     0x13
          pop     es
          jnc     Gdixxx

          mov     Fail, 1
    Gdixxx:
    }
#endif // PC98

    if (Fail) {
#if DBG
        // could not get the sector, so return NULL DiskID
        BlPrint("Failed to read sector -- returning NULL DiskId\n");
#endif        
        return;
    }

#if defined(NEC_98)
    //
    //  Get the NTFS Sinature
    //
    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        Signature = 0;
    } else {
        Signature = ((PULONG)Sector)[0];
    }
#else // PC98
    Signature = ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];
#endif // PC98

    //
    // compute the checksum
    //
#if defined(NEC_98)
    //
    //  Read No 0 and 1 sectors. (for Check Sum)
    //
    _asm {
        push    es
        mov     ah, 0x06              //  Disk read command
        mov     al, diskNumber        //  Disk No (00,01)
        mov     bx, 512 * 2           //  Data length
        mov     cx, 0x00              //  Sector LSW
        mov     dx, 0x00              //  Sector HSW
        push    ss
        pop     es
        push    bp
        mov     bp, BufferAddress     // ES:BP Buffer address
        int     1bh
        pop     bp
        pop     es
        jnc     Gdi001

        mov     Fail, 1
    Gdi001:
    }


    if (Fail) {
        return;
    }
#endif // PC98


    Checksum = 0;
    for (i = 0; i < 128; i++) {
#if defined(NEC_98)
        Checksum += ((PULONG)Sector)[ i + 512/4 ];
#else // PC98
        Checksum += ((PULONG)Sector)[i];
#endif // PC98
    }
    Checksum = -Checksum;

    //
    // Zero the identifier
    //

    for (i=0; i < 30; i++) {
        Identifier[i]='0';
    }

    //
    // Put the dashes in the right places.
    //

    Identifier[8] = '-';
    Identifier[17] = '-';

    //
    // If the boot sector has a valid partition table signature,
    // attach an 'A.'  Otherwise we use 'X.'
    //

    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
       Identifier[18]='X';
    } else {
       Identifier[18]='A';
    }

    //
    // Reuse sector buffer to build checksum string.
    //

    ultoa(Checksum, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[7-i] = Sector[Length-i-1];
    }

    //
    // Reuse sector buffer to build signature string.
    //

    ultoa(Signature, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[16-i] = Sector[Length-i-1];
    }

    //
    // Terminate string.
    //

    Identifier[19] = 0;

#if DBG
    BlPrint("%s\n", Identifier);
#endif

#endif // _GAMBIT_
}


#if defined(NEC_98)
//
//  This section was used to get some SCSI disks' information connecting to
//  SCSI board that is includeing boot up disk.
//
//  These information was very important when do FD-less setup.
//
//  When the HIPER SCSI BIOS for array disk is abailable, it is useing a
//  trick to show two scsi board as one scsi board accessing through BIOS
//  functions.
//
//  We must separete information per board from the two boards' information.
//

BOOLEAN
BootedFromScsiDisk(
    PUSHORT     pFakeScsiId,
    PUSHORT     pNumberScsiDisks,
    PUSHORT     pScsiDisksMap
    )
{

    USHORT      DauaBootedFrom;
    USHORT      StartPosition = 0;
    USHORT      EndPosition = SCSI_MAX_ID;
    USHORT      tmp, i;


    DauaBootedFrom = DAUA_BOOTED_FROM;

    *pFakeScsiId = 0;
    *pNumberScsiDisks = 0;
    *pScsiDisksMap = DISK_EQUIPS_SCSI;

    if (!(DauaBootedFrom & DASCSI)){
        return (FALSE);
    }


    if ((EQUIPS_47Ch == (USHORT)0) && ((*pScsiDisksMap & 0x80) == 0)) {
        //
        //  Array SCSI BIOS was available.
        //

        if (H_DISK_EQUIPS_L != (USHORT)0){      // we do not need high byte.

            tmp = H_EQUIPS;
            for ( i = 0; i < SCSI_MAX_ID; i++ ){
              if ( tmp & (1 << i)) (*pFakeScsiId)++;
            }

            if ( (DauaBootedFrom & UA_MASK) >= *pFakeScsiId ){
                //
                //  System was booted from disk connected array scsi card.
                //

                StartPosition = *pFakeScsiId;
                EndPosition = SCSI_MAX_ID;

            } else {
                //
                //  System was booted from disk connected normal scsi card.
                //

                StartPosition = 0;
                EndPosition = *pFakeScsiId;
                *pFakeScsiId = 0;       // Reset

            }
        }
    }

    for ( i = StartPosition; i < EndPosition; i++ ){
        if ( *pScsiDisksMap & (1 << i)) (*pNumberScsiDisks)++;
    }

    *pFakeScsiId |= 0xA0;

    return(TRUE);
}


FPFWCONFIGURATION_COMPONENT_DATA
GetScsiDiskInformation(
    VOID
    )

/*++

Routine Description:

    This routine tries to get SCSI Disk configuration information.

Arguments:

    None.

Return Value:

    A pointer to a FPCONFIGURATION_COMPONENT_DATA is returned.  It is
    the head of floppy component tree root.

--*/

{
    FPFWCONFIGURATION_COMPONENT_DATA ControllerEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA PeripheralEntry;
    FPFWCONFIGURATION_COMPONENT_DATA FirstController = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA AdapterEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    CHAR Identifier[256];
    UCHAR DiskName[30];
    FPUCHAR fpString;
    USHORT Length;
    FPCHAR IdentifierString;

    USHORT  DiskCount, Id;

    USHORT  FakeScsiId;
    USHORT  NumberScsiDisks;
    USHORT  ScsiDisksMap;


    if (!BootedFromScsiDisk( &FakeScsiId, &NumberScsiDisks, &ScsiDisksMap )){
        return (NULL);
    }

    //
    // Allocate space for Controller component and initialize it.
    //

    AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    FirstController = AdapterEntry;

    Component = &AdapterEntry->ComponentEntry;
    Component->Class = AdapterClass;
    Component->Type = ScsiAdapter;

    strcpy (Identifier, "SCSI");
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    AdapterEntry->ConfigurationData = NULL;
    Component->ConfigurationDataLength = 0;

    for ( DiskCount = 0, Id = 0; DiskCount < NumberScsiDisks && Id < 7 ; Id++ ) {

        if ( !(ScsiDisksMap & (1 << (FakeScsiId + Id)))){
            continue;
        }

        //
        // Allocate space for disk peripheral component
        //

        ControllerEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                        sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &ControllerEntry->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = DiskController;
        Component->Flags.Input = 1;
        Component->Flags.Output = 1;
        Component->Version = 0;
        Component->Key = Id;
        Component->AffinityMask = 0xffffffff;

        ControllerEntry->ConfigurationData = NULL;

        //
        // Set up identifier string = 8 digit signature - 8 digit checksum
        // for example: 00fe964d-005467dd
        //

        GetDiskId(FakeScsiId + Id, DiskName);
        if (DiskName[0] == (UCHAR)NULL) {
            strcpy(DiskName, "BIOSDISKx");
            DiskName[8] = (UCHAR)DiskCount + (UCHAR)'1';
        }
        Length = strlen(DiskName) + 1;
        fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(fpString, DiskName);
        Component->IdentifierLength = Length;
        Component->Identifier = fpString;


        //
        // Create Peripheral Entry
        //

        PeripheralEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                          sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &PeripheralEntry->ComponentEntry;
        Component->Class = PeripheralClass;
        Component->Type = DiskPeripheral;
        Component->Flags.Input = 1;
        Component->Flags.Output = 1;
        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;

        PeripheralEntry->ConfigurationData = NULL;

        Component->IdentifierLength = Length;
        Component->Identifier = fpString;

        PeripheralEntry->Parent = ControllerEntry;
        ControllerEntry->Child = PeripheralEntry;


        if (PreviousEntry == NULL) {
            FirstController->Child = ControllerEntry;
        } else {
            PreviousEntry->Sibling = ControllerEntry;
        }

        ControllerEntry->Parent = FirstController;
        PreviousEntry = ControllerEntry;

        DiskCount++;
    }

    return(FirstController);
}

#endif // PC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwapm.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwapm.c

Abstract:

Author:


Environment:

    Real mode.

Revision History:

--*/


#include "hwdetect.h"
#include <string.h>

#if defined(NEC_98)
#define _PNP_POWER_ 1
#endif
#if _PNP_POWER_

#include "apm.h"
#if defined(NEC_98)
//
// interface api numbers
//
#define PC98_APM_INSTALLATION_CHECK              0x9A00
#define PC98_APM_REAL_MODE_CONNECT               0x9A01
#define PC98_APM_PROTECT_MODE_16bit_CONNECT      0x9A02
#define PC98_APM_DISCONNECT                      0x9A04
#define PC98_APM_DRIVER_VERSION                  0x9A3E
#define APM_MODE_16BIT                           0x0001
#endif // PC98

VOID Int15 (PULONG, PULONG, PULONG, PULONG, PULONG);

BOOLEAN
HwGetApmSystemData(
    IN PAPM_REGISTRY_INFO   ApmEntry
    )
{
    ULONG       RegEax, RegEbx, RegEcx, RegEdx, CyFlag;

    //
    // Perform APM installation check
    //

#if defined(NEC_98)
    RegEax = PC98_APM_INSTALLATION_CHECK;
#else // PC98
    RegEax = APM_INSTALLATION_CHECK;
#endif // PC98
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag ||
        (RegEbx & 0xff) != 'M'  ||
        ((RegEbx >> 8) & 0xff) != 'P') {

        return FALSE;
    }

    ApmEntry->ApmRevMajor = (UCHAR) (RegEax >> 8) & 0xff;
    ApmEntry->ApmRevMinor = (UCHAR) RegEax & 0xff;
    ApmEntry->ApmInstallFlags = (USHORT) RegEcx;

    //
    // Connect to 32 bit interface
    //

#if defined(NEC_98)
    RegEax = PC98_APM_PROTECT_MODE_16bit_CONNECT;
#else // PC98
    RegEax = APM_PROTECT_MODE_16bit_CONNECT;
#endif // PC98
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        return FALSE;
    }

    ApmEntry->Code16BitSegmentBase   = (USHORT) RegEax;
    ApmEntry->Code16BitOffset        = (USHORT) RegEbx;
    ApmEntry->Data16BitSegment       = (USHORT) RegEcx;

    return TRUE;
}

#endif // _PNP_POWER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "hwdetect.h"

#if defined(_IA64_)
#undef DBG
#endif

#if DBG

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))


#define ROWS 25
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#if defined(NEC_98)
#define NORMAL_ATTRIB     0xe1
#define REVERSE_ATTRIB    0xe5
#define SCREEN_START      0xa0000
#define ATTROFFSET98      0x2000
#else // PC98
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000
#endif // PC98

#if defined(NEC_98)
#define IsANK(c) (!((c >= (UCHAR)0x81 && c <= (UCHAR)0x9f) || (c >= (UCHAR)0xe0 && c <= (UCHAR)0xfe)))
static BOOLEAN IsKanji2nd = FALSE;
static UCHAR   Kanji1st;
static int z = 25;

USHORT
HwGetKey(
    VOID
    );
#endif // PC98

//
// Internal routines
//

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
BlPuts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;



//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    BlPuts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID BlPuts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
#if defined(NEC_98)
                if ( z == 25 ){
                    HwGetKey();
                    z = 0;
                }
#endif // PC98
                scroll();
#if defined(NEC_98)
                z++;
#endif // PC98
            }
#if defined(NEC_98)
            if(IsKanji2nd) {
                IsKanji2nd = FALSE;

                //  Shift JIS -> JIS code exchange
                Kanji1st -= (UCHAR)((Kanji1st <= (UCHAR)0x9f) ? 0x71 : 0xb1);
                Kanji1st = Kanji1st * 2 + 1;

                if((UCHAR)c > (UCHAR)0x7f){
                    c--;
                }
                if((UCHAR)c >= (UCHAR)0x9e){
                    c -= 0x7d;
                    Kanji1st++;
                }else{
                    c -= 0x1f;
                }

                //  Create custom JIS code (to VRAM)
                Kanji1st += 0x60;

                *vp++ = Kanji1st - (CHAR)0x80;
                *vp++ = c;
                *vp++ = Kanji1st;
                *vp++ = c;
                lcnt +=2;
                Kanji1st = (UCHAR)0;
            } else if(!IsANK((UCHAR)c)) {
                IsKanji2nd = TRUE;
                Kanji1st = (UCHAR)c;
            } else {
                *vp++ = c;
                *vp++ = 0;
                ++lcnt;
            }
#else // PC98
            *vp = c;
            vp += 2;
            ++lcnt;
#endif // PC98
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

#if defined(NEC_98)
    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            {
                *(p1+ATTROFFSET98) = *(p2+ATTROFFSET98);
                *p1++ = *p2++;
            }

    for (i=0; i < SCREEN_WIDTH; i++) {
            *(p1+ATTROFFSET98) = REVERSE_ATTRIB;
            *p1++ = 0 + ' ';    // No KANJI support
    }
#else // PC98
    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';
#endif // PC98

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
#if defined(NEC_98)
    int i;

    vp = (FPUCHAR)SCREEN_START;
    ScreenStart = (FPUCHAR)SCREEN_START;

    for (i = SCREEN_SIZE*2 ; i ; i--)
        {
            *(vp+ATTROFFSET98) = NORMAL_ATTRIB;
            *vp++ = 0 + ' ';
            *vp++ = 0;
        }


#else // PC98
    int i,a;
    unsigned far *vwp = (unsigned far *)SCREEN_START;
    a = REVERSE_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;
#endif // PC98

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

#else

VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
}

VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
}
#endif
#if defined(NEC_98)
VOID CursorOn(
    VOID
    )

/*++

Routine Description:

Arguments:

    None

Returns:

    Nothing


--*/

{
             _asm {
                mov     ah,11h
                int     18h
        }
}

VOID CursorOff(
    VOID
    )

/*++

Routine Description:

Arguments:

    None

Returns:

    Nothing


--*/

{
        _asm {
                mov     ah,12h
                int     18h
        }
}
#endif // PC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwdetect.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwdetect.c

Abstract:

    This is the main hardware detection module.  Its main function is
    to detect various system hardware and build a configuration tree.

    N.B. The configuration built in the detection module will needs to
    be adjusted later before we switch to FLAT mode.  The is because
    all the "POINTER" is a far pointer instead of a flat pointer.

Author:

    Shie-Lin Tzong (shielint) 16-Jan-92


Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
typedef PVOID PDEVICE_OBJECT;
#include "pci.h"
#if defined(NEC_98)
#include "string.h"
#else // PC98
#include <string.h>
#endif // PC98
#include "apm.h"
#include <ntapmsdk.h>

#if defined(_GAMBIT_)
//
// Hard Disk Drive
//
#define SIZE_OF_PARAMETER    12     // size of disk params
#define MAX_DRIVE_NUMBER     8      // max number of drives

#pragma pack(1)
typedef struct _HARD_DISK_PARAMETERS {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} HARD_DISK_PARAMETERS, *PHARD_DISK_PARAMETERS;
#pragma pack()

USHORT NumberBiosDisks;
#endif // _GAMBIT_


#if DBG

PUCHAR TypeName[] = {
    "ArcSystem",
    "CentralProcessor",
    "FloatingPointProcessor",
    "PrimaryICache",
    "PrimaryDCache",
    "SecondaryICache",
    "SecondaryDCache",
    "SecondaryCache",
    "EisaAdapter",
    "TcaAdapter",
    "ScsiAdapter",
    "DtiAdapter",
#if defined(NEC_98)
    "MultifunctionAdapter",
#else // PC98
    "MultifunctionAapter",
#endif // PC98
    "DiskController",
    "TapeController",
    "CdRomController",
    "WormController",
    "SerialController",
    "NetworkController",
    "DisplayController",
    "ParallelController",
    "PointerController",
    "KeyboardController",
    "AudioController",
    "OtherController",
    "DiskPeripheral",
    "FloppyDiskPeripheral",
    "TapePeripheral",
    "ModemPeripheral",
    "MonitorPeripheral",
#if defined(NEC_98)
    "PrinterPeripheral",
#else // PC98
    "PrinterPeraipheral",
#endif // PC98
    "PointerPeripheral",
    "KeyboardPeripheral",
    "TerminalPeripheral",
    "OtherPeripheral",
    "LinePeripheral",
    "NetworkPeripheral",
    "SystemMemory",
    "MaximumType"
    };

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     );

extern
USHORT
HwGetKey(
    VOID
    );
#endif

VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     );

#if defined(NEC_98)
FPFWCONFIGURATION_COMPONENT_DATA
GetScsiDiskInformation(
    VOID
    );

FPFWCONFIGURATION_COMPONENT_DATA
GetArrayDiskInformation(
    VOID
    );

BOOLEAN
ArrayBootCheck(
    VOID
    );
#endif // PC98
//
// HwBusType - defines the BUS type of the machine.
//     This variable is used by detection code only.
//

USHORT HwBusType = 0;

//
// AdapterEntry is the Configuration_Component_data for the bus adapter
//

FPFWCONFIGURATION_COMPONENT_DATA  AdapterEntry = NULL;

//
// FpRomBlock - A far pointer to our Rom Block
//

FPUCHAR FpRomBlock = NULL;
USHORT RomBlockLength = 0;

//
// HwEisaConfigurationData - A far pointer to the EISA configuration
//   data on EISA machine.
//

FPUCHAR HwEisaConfigurationData = NULL;
ULONG HwEisaConfigurationSize = 0L;

//
// DisableSerialMice - A bit flags to indicate the comports whose serial
//     mouse detection should be skipped.
//

USHORT DisableSerialMice = 0x0;

//
// Internal references and definitions.
//

typedef enum _RELATIONSHIP_FLAGS {
    Child,
    Sibling,
    Parent
} RELATIONSHIP_FLAGS;

#if defined(NEC_98)
USHORT
Get0Seg(
    IN USHORT   OffsetAddress
    )
/*++
Routine Description:
    This routine have the function that get common data and return.

Arguments:
    OffsetAddress - Physical address 0:xxxx

Return Value:
        Return a common data.
++*/

{
    UCHAR           Data=0;
    _asm {
          push    es
          push    bx
          push    ax
          xor     ax,ax
          mov     es,ax
          mov     bx,word ptr OffsetAddress
          mov     al,es:[bx]
          mov     Data,al
          pop     ax
          pop     bx
          pop     es
    }
    return ((USHORT)Data);
}

USHORT
GetF8E8Seg(
    IN USHORT   OffsetAddress
    )
/*++
Routine Description:

    This routine have the function that get byte data in ROM system common aria.

Arguments:

    Offset - Physical address 0:xxxx

Return Value:

    Byte data

--*/

{
    UCHAR   Data=0;

    _asm {

        push    es
        push    bx
        push    ax

        mov     ax, 0F8E8h
        mov     es, ax
        mov     bx, word ptr OffsetAddress
        mov     al, es:[bx]

        mov     Data, al

        pop     ax
        pop     bx
        pop     es
    }

    return ((USHORT)Data);
}

VOID
IoDelay(
    USHORT counter
    )
/*++
    Routine Description:

        This routine is  IoDelay function.
        I think time of one "out 5f" is 0.6 micro second.

    Arguments:

--*/

{
    USHORT i;

    for (i = 1 ; i <= counter ; i++) {
        WRITE_PORT_UCHAR((PCHAR)0x5f,0);
    }
}
#endif

VOID
HardwareDetection(
     ULONG HeapStart,
     ULONG HeapSize,
     ULONG_PTR ConfigurationTree,
     ULONG_PTR HeapUsed,
     ULONG_PTR OptionString,
     ULONG OptionStringLength
     )
/*++

Routine Description:

    Main entrypoint of the HW recognizer test.  The routine builds
    a configuration tree and leaves it in the hardware heap.

Arguments:

    HeapStart - Supplies the starting address of the configuaration heap.

    HeapSize - Supplies the size of the heap in byte.

    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
        receive the hardware configuration tree.

    HeapUsed - Supplies a 32 bit FLAT address of the variable to receive
        the actual heap size in used.

    OptionString - Supplies a 32 bit FLAT address of load option string.

    OptionStringLength - Supplies the length of the OptionString

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    FPFWCONFIGURATION_COMPONENT_DATA FirstCom = NULL, FirstLpt = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    FPFWCONFIGURATION_COMPONENT_DATA AcpiAdapterEntry = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    RELATIONSHIP_FLAGS NextRelationship;
    CHAR Identifier[256];
    USHORT BiosYear, BiosMonth, BiosDay;
    PUCHAR MachineId;
    USHORT Length, InitialLength, i, Count = 0;
    FPCHAR IdentifierString;
    PMOUSE_INFORMATION MouseInfo = 0;
    USHORT KeyboardId = 0;
    ULONG VideoAdapterType = 0;
    PULONG_PTR BlConfigurationTree = NULL;
    FPULONG BlHeapUsed = NULL;
    FPCHAR BlOptions, EndOptions;
#if defined(_GAMBIT_)
    PHARD_DISK_PARAMETERS RomChain;
#else
    PUCHAR RomChain;
#endif
    FPUCHAR FpRomChain = NULL, ConfigurationData, EndConfigurationData;
    SHORT FreeSize;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    PCI_REGISTRY_INFO PciEntry;
#if defined(NEC_98)
    FPFWCONFIGURATION_COMPONENT_DATA ScsiAdapterEntry;
    USHORT BootID, Equips, Work;
#endif // PC98
    APM_REGISTRY_INFO ApmEntry;

    //
    // First initialize our hardware heap.
    //

    HwInitializeHeap(HeapStart, HeapSize);

    MAKE_FP(BlConfigurationTree, ConfigurationTree);
    MAKE_FP(BlHeapUsed, HeapUsed);
    MAKE_FP(BlOptions, OptionString);

    //
    // Parse OptionString and see if we need to disable serial mice detection.
    //

    if (BlOptions && OptionStringLength <= 0x1000L && OptionStringLength > 0L) {
        EndOptions = BlOptions + OptionStringLength;
        if (*EndOptions == '\0') {
            do {
                if (BlOptions = _fstrstr(BlOptions, "NOSERIALMICE")) {
                    BlOptions += strlen("NOSERIALMICE");
                    while ((*BlOptions == ' ') || (*BlOptions == ':') ||
                           (*BlOptions == '=')) {
                        BlOptions++;
                    }
                    if (*BlOptions == 'C' && BlOptions[1] == 'O' &&
                        BlOptions[2] == 'M') {
                        BlOptions += 3;
                        while (TRUE) {
                            while (*BlOptions != '\0' && (*BlOptions == ' ' ||
                                   *BlOptions == ',' || *BlOptions == ';' ||
                                   *BlOptions == '0')) {
                                BlOptions++;
                            }
                            if (*BlOptions >= '0' && *BlOptions <= '9') {
                                if (BlOptions[1] < '0' || BlOptions[1] > '9') {
                                    DisableSerialMice |= 1 << (*BlOptions - '0');
                                    BlOptions++;
                                } else {
                                    BlOptions++;
                                    while (*BlOptions && *BlOptions <= '9' &&
                                           *BlOptions >= '0') {
                                           BlOptions++;
                                    }
                                }
                            }else {
                                break;
                            }
                        }
                    } else {
                        DisableSerialMice = 0xffff;
                        break;
                    }
                }
            } while (BlOptions && *BlOptions && (BlOptions < EndOptions)); // double checking
        }
    }

    //
    // Determine bus type
    //

#if defined(NEC_98) || defined(_GAMBIT_)
    //
    // PC98 have only MACHINE_TYPE_ISA.
    //
    HwBusType = MACHINE_TYPE_ISA;
#else // PC98
    if (HwIsEisaSystem()) {
        HwBusType = MACHINE_TYPE_EISA;
    } else {
        HwBusType = MACHINE_TYPE_ISA;
    }
#endif // PC98 || _GAMBIT_

    //
    // Allocate heap space for System component and initialize it.
    // Also make the System component the root of configuration tree.
    //

#if DBG
    clrscrn ();
    BlPrint("Detecting System Component ...\n");
#endif

    ConfigurationRoot = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                        sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    Component = &ConfigurationRoot->ComponentEntry;

    Component->Class = SystemClass;
    Component->Type = MaximumType;          // NOTE should be IsaCompatible
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0;
    Component->ConfigurationDataLength = 0;
#if defined(NEC_98) || defined(_GAMBIT_)
    MachineId = "NEC PC-98";
#else // PC98 || _GAMBIT_
    MachineId = GetMachineId();
#endif // PC98 || _GAMBIT_
    if (MachineId) {
        Length = strlen(MachineId) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, MachineId);
        Component->Identifier = IdentifierString;
        Component->IdentifierLength = Length;
    } else {
        Component->Identifier = 0;
        Component->IdentifierLength = 0;
    }
    NextRelationship = Child;
    PreviousEntry = ConfigurationRoot;

#if DBG
    BlPrint("Reading BIOS date ...\n");
#endif

    HwGetBiosDate (0xF0000, 0xFFFF, &BiosYear, &BiosMonth, &BiosDay);

#if DBG
    BlPrint("Done reading BIOS date (%d/%d/%d)\n",
                BiosMonth, BiosDay, BiosYear);
#endif


#if DBG
    BlPrint("Detecting PCI Bus Component ...\n");
#endif

#if _GAMBIT_
    PciEntry.NoBuses = 1;
#else
    if (BiosYear > 1992 ||  (BiosYear == 1992  &&  BiosMonth >= 11) ) {

        // Bios date valid for pci presence check..
        HwGetPciSystemData((PVOID) &PciEntry, TRUE);

    } else {

        // Bios date not confirmed...
        HwGetPciSystemData((PVOID) &PciEntry, FALSE);
    }
#endif // _GAMBIT_

    //
    // Add a registry entry for each PCI bus
    //

    for (i=0; i < PciEntry.NoBuses; i++) {

        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PCI");
        Length = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = Length;
        Component->Identifier = IdentifierString;

        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

        if (i == 0) {
            //
            // For the first PCI bus include the PCI_REGISTRY_INFO
            //

            Length = sizeof(PCI_REGISTRY_INFO) + DATA_HEADER_SIZE;
            ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

            Component->ConfigurationDataLength = Length;
            AdapterEntry->ConfigurationData = ConfigurationData;

            _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                       (FPVOID) &PciEntry, sizeof (PCI_REGISTRY_INFO));

            HwSetUpFreeFormDataHeader(
                    (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                    0,
                    0,
                    0,
                    Length - DATA_HEADER_SIZE
                    );
        }

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;
    }

#if DBG
    BlPrint("Detecting PCI Bus Component completes ...\n");
#endif

#if defined(NEC_98)
#define _PNP_POWER_ 1
#endif
#if _PNP_POWER_

#if DBG
    BlPrint("Detecting APM Bus Component ...\n");
#endif

    if (HwGetApmSystemData((PVOID) &ApmEntry)) {
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "APM");
        Length = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = Length;
        Component->Identifier = IdentifierString;

        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

        //

        Length = sizeof(APM_REGISTRY_INFO) + DATA_HEADER_SIZE;
        ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

        Component->ConfigurationDataLength = Length;
        AdapterEntry->ConfigurationData = ConfigurationData;

        _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                   (FPVOID) &ApmEntry, sizeof (APM_REGISTRY_INFO));

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;
    }

#if DBG
    BlPrint("APM Data collection complete...\n");
#endif // DBG

#endif // _PNP_POWER_

#if DBG
    BlPrint("Detecting PnP BIOS Bus Component ...\n");
#endif

    if (HwGetPnpBiosSystemData(&ConfigurationData, &Length)) {
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = Length;

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PNP BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;
    }

#if DBG
    BlPrint("PnP BIOS Data collection complete...\n");
#endif // DBG

    //
    // Allocate heap space for Bus component and initialize it.
    //

#if DBG
    BlPrint("Detecting Bus/Adapter Component ...\n");
#endif

    AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &AdapterEntry->ComponentEntry;

    Component->Class = AdapterClass;

    //
    // The assumption here is that the machine has only one
    // type of IO bus.  If a machine has more than one types of
    // IO buses, it will not use this detection code anyway.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        //
        // Note We don't collect EISA config data here.  Because we may
        // exhaust the heap space.  We will collect the data after all
        // the other components are detected.
        //

        Component->Type = EisaAdapter;
        strcpy(Identifier, "EISA");
        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

    } else {

        //
        // If not EISA, it must be ISA
        //

        Component->Type = MultiFunctionAdapter;
        strcpy(Identifier, "ISA");
    }
#if defined(NEC_98)
    //
    // Some drivers for PC-98 want to get information of the BIOS Common aria.
    // So, enter them to the registry.
    // If evey drivers are changed to do not show them, then clear following codes
    // and (*) marked!
    //

    Component->Type = MultiFunctionAdapter;
    strcpy(Identifier, "ISA");
    AdapterEntry->ConfigurationData = HwAllocateHeap (DATA_HEADER_SIZE + 512 + 64, TRUE);           //921208
    _fmemcpy ((UCHAR far *) (AdapterEntry->ConfigurationData)+DATA_HEADER_SIZE,(unsigned far *) SYSTEM_SEGMENT, 512);
    _fmemcpy ((UCHAR far *) (AdapterEntry->ConfigurationData)+DATA_HEADER_SIZE+512,(unsigned far *) SYSTEM_SEGMENT_2, 64);
    Component->ConfigurationDataLength = DATA_HEADER_SIZE + 512 + 64;
    HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)(AdapterEntry->ConfigurationData),
                              0,
                              0,
                              0,
                              512 + 64
                              );
#endif // PC98
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    //
    // Make Adapter component System's child
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

    //
    // Collect BIOS information for ConfigurationRoot component.
    // This step is done here because we need data collected in
    // adapter component.  The ConfigurationData is:
    //      HWRESOURCE_DESCRIPTOR_LIST header
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Parameter Table
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Rom Blocks.
    // (Note DATA_HEADER_SIZE contains the size of the first partial
    //  descriptor already.)
    //

#if DBG
    BlPrint("Collecting Disk Geometry...\n");
#endif

#if defined(_GAMBIT_)
    RomChain = (PHARD_DISK_PARAMETERS)
               HwAllocateHeap(SIZE_OF_PARAMETER * MAX_DRIVE_NUMBER, FALSE);
    //
    // Just hardcode it:
    //      SscGetDriveParameters((PVOID)&RomChain, &Length);
    //
    RomChain[0].DriveSelect = 0x82;             // drive e:
    RomChain[0].MaxCylinders = 0;               // dummy value
    RomChain[0].SectorsPerTrack = 0;            // dummy value
    RomChain[0].MaxHeads = 0;                   // dummy value
    RomChain[0].NumberDrives = 1;               // Gambit only access 1 drive

    NumberBiosDisks = 1;                        // was defined in diska.asm
#else
    GetInt13DriveParameters((PVOID)&RomChain, &Length);
#endif // _GAMBIT_
    InitialLength = (USHORT)(Length + RESERVED_ROM_BLOCK_LIST_SIZE + DATA_HEADER_SIZE +
                    sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    ConfigurationData = (FPUCHAR)HwAllocateHeap(InitialLength, FALSE);
    EndConfigurationData = ConfigurationData + DATA_HEADER_SIZE;
    if (Length != 0) {
        FpRomChain = EndConfigurationData;
        _fmemcpy(FpRomChain, (FPVOID)RomChain, Length);
    }
    EndConfigurationData += (sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                             Length);
    HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              Length
                              );

    //
    // Scan ROM to collect all the ROM blocks, if possible.
    //

#if DBG
    BlPrint("Detecting ROM Blocks...\n");
#endif

    FpRomBlock = EndConfigurationData;
    GetRomBlocks(FpRomBlock, &Length);
    RomBlockLength = Length;
    if (Length != 0) {
        EndConfigurationData += Length;
    } else {
        FpRomBlock = NULL;
    }

    //
    // We have both RomChain and RomBlock information/Headers.
    //

    DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData;
    DescriptorList->Count = 2;
    Descriptor = (FPHWPARTIAL_RESOURCE_DESCRIPTOR)(
                 EndConfigurationData - Length -
                 sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    Descriptor->Type = RESOURCE_DEVICE_DATA;
    Descriptor->ShareDisposition = 0;
    Descriptor->Flags = 0;
    Descriptor->u.DeviceSpecificData.DataSize = (ULONG)Length;
    Descriptor->u.DeviceSpecificData.Reserved1 = 0;
    Descriptor->u.DeviceSpecificData.Reserved2 = 0;

    Length = (USHORT)(MAKE_FLAT_ADDRESS(EndConfigurationData) -
             MAKE_FLAT_ADDRESS(ConfigurationData));
    ConfigurationRoot->ComponentEntry.ConfigurationDataLength = Length;
    ConfigurationRoot->ConfigurationData = ConfigurationData;
    FreeSize = InitialLength - Length;

    HwFreeHeap((ULONG)FreeSize);

    //
    // Set up device information structure for Keyboard.
    //

#if DBG
    BlPrint("Detecting Keyboard Component ...\n");
#endif

    KeyboardId = GetKeyboardId();

    CurrentEntry = SetKeyboardConfigurationData(KeyboardId);

    //
    // Make display component the child of Adapter component.
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;

    //
    // Set up device information for com port (Each COM component
    // is treated as a controller class.)
    //

#if DBG
    BlPrint("Detecting ComPort Component ...\n");
#endif

    if (CurrentEntry = GetComportInformation()) {

        FirstCom = CurrentEntry;

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
        } else {
            PreviousEntry->Child = CurrentEntry;
        }
        while (CurrentEntry) {
            CurrentEntry->Parent = AdapterEntry;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }

    //
    // Set up device information for parallel port.  (Each parallel
    // is treated as a controller class.)
    //

#if DBG
    BlPrint("Detecting Parallel Component ...\n");
#endif

#if !defined(_GAMBIT_)
    if (CurrentEntry = GetLptInformation()) {

        FirstLpt = CurrentEntry;

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        PreviousEntry = CurrentEntry;
        CurrentEntry = CurrentEntry->Sibling;
        while (CurrentEntry) {
            CurrentEntry->Parent = PreviousEntry->Parent;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }
#endif // _GAMBIT_

    //
    // Set up device information structure for Mouse.
    //

#if DBG
    BlPrint("Detecting Mouse Component ...\n");
#endif

    if (CurrentEntry = GetMouseInformation()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        PreviousEntry = CurrentEntry;
        CurrentEntry = CurrentEntry->Sibling;
        while (CurrentEntry) {
            CurrentEntry->Parent = PreviousEntry->Parent;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }

    //
    // Set up device information for floppy drives. (The returned information
    // is a tree structure.)
    //

#if DBG
    BlPrint("Detecting Floppy Component ...\n");
#endif

    if (CurrentEntry = GetFloppyInformation()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
        } else {
            PreviousEntry->Child = CurrentEntry;
        }
        while (CurrentEntry) {
            CurrentEntry->Parent = AdapterEntry;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }

#if DBG
    BlPrint("Detecting ACPI Bus Component ...\n");
#endif

#if !defined(_GAMBIT_)
    if (HwGetAcpiBiosData(&ConfigurationData, &Length)) {
        AcpiAdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AcpiAdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AcpiAdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = Length;

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "ACPI BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPULONG) ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Parent->Sibling = AcpiAdapterEntry;
            AcpiAdapterEntry->Parent = PreviousEntry->Parent->Parent;
        }

        NextRelationship = Sibling;
    }

#if DBG
    BlPrint("ACPI BIOS Data collection complete...\n");
#endif // DBG
#endif // _GAMBIT_

    //
    // Set up device information structure for Video Display Adapter.
    //

#if DBG
    BlPrint("Detection done. Press a key to display hardware info ...\n");
#if !defined(_GAMBIT_)
    while ( ! HwGetKey ());
#endif
    clrscrn ();
//    BlPrint("Detecting Video Component ...\n");
#endif

#if 0 // Remove video detection
    if (VideoAdapterType = GetVideoAdapterType()) {

        CurrentEntry = SetVideoConfigurationData(VideoAdapterType);

        //
        // Make display component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }
#endif
#if defined(NEC_98)
#if DBG
    BlPrint("Detecting SCSI Component ...\n");
#endif

    if (CurrentEntry = GetScsiDiskInformation()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
        } else {
            PreviousEntry->Child = CurrentEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }

#endif // PC98
#if defined(NEC_98) || defined(_GAMBIT_)
#else // PC98 || _GAMBIT_

    //
    // Misc. supports.  Note, the information collected here will NOT be
    // written to hardware registry.
    //
    // 1. Collect video font information for vdm
    //

    GetVideoFontInformation();

    //
    // After all the components are detected, we collect EISA config data.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        Component = &AdapterEntry->ComponentEntry;
        GetEisaConfigurationData(&AdapterEntry->ConfigurationData,
                                 &Component->ConfigurationDataLength);
        if (Component->ConfigurationDataLength) {
            HwEisaConfigurationData = (FPUCHAR)AdapterEntry->ConfigurationData +
                                           DATA_HEADER_SIZE;
            HwEisaConfigurationSize = Component->ConfigurationDataLength -
                                           DATA_HEADER_SIZE;

            //
            // Misc. detections based on Eisa config data
            //
            // Update Lpt and com controllers' irq information by examining
            //   the EISA configuration data.
            //

            GetIrqFromEisaData(FirstLpt, ParallelController);
            GetIrqFromEisaData(FirstCom, SerialController);
        }
    }
#endif // PC98 || _GAMBIT_


#if DBG
    CheckConfigurationTree(ConfigurationRoot);
#endif

    //
    // Update all the far pointers in the tree to flat 32 bit pointers
    //

    UpdateConfigurationTree(ConfigurationRoot);

    //
    // Set up returned values:
    //   Size of Heap space which should be preserved for configuration tree
    //   Pointer to the root of the configuration tree.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap(0, FALSE);
    *BlHeapUsed = (ULONG) (MAKE_FLAT_ADDRESS(CurrentEntry) -
                  MAKE_FLAT_ADDRESS(ConfigurationRoot));
    *BlConfigurationTree = (ULONG_PTR)MAKE_FLAT_ADDRESS(ConfigurationRoot);
}

#if defined(NEC_98) || defined(_GAMBIT_)
#else
VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     )
/*++

Routine Description:

    This routine updates all irq information for ControllerType components
    in the controllerList by examinine the eisa configuration data.

Arguments:

    ControllerList - Supplies a pointer to a component entry whoes irq will
        be updated.

    ControllerType - Supplies the controller type whoes irq will be searched
        for.

Returns:

    None.

--*/
{

     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry;
     FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
     FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
     USHORT i, Port;
     UCHAR Irq, Trigger;

     CurrentEntry = ControllerList;
     while (CurrentEntry &&
            CurrentEntry->ComponentEntry.Type == ControllerType) {
         if (CurrentEntry->ConfigurationData) {
             DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)
                              CurrentEntry->ConfigurationData;
             Port = 0;
             for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                 Descriptor = &DescriptorList->PartialDescriptors[i];
                 if (Descriptor->Type == CmResourceTypePort) {
                     Port = (USHORT)Descriptor->u.Port.Start.LowPart;
                     break;
                 }
             }
             if (Port != 0) {
                 for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                     Descriptor = &DescriptorList->PartialDescriptors[i];
                     if (Descriptor->Type == CmResourceTypeInterrupt) {
                         if (HwEisaGetIrqFromPort(Port, &Irq, &Trigger)) {
                             if (Trigger == 0) {  // EISA EDGE_TRIGGER
                                 Descriptor->Flags = EDGE_TRIGGERED;
                             } else {
                                 Descriptor->Flags = LEVEL_SENSITIVE;
                             }
                             Descriptor->u.Interrupt.Level = Irq;
                             Descriptor->u.Interrupt.Vector = Irq;
                             break;
                         }
                     }
                 }
             }
         }
         CurrentEntry = CurrentEntry->Sibling;
     }
}
#endif

VOID
UpdateComponentPointers(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine updates all the "far" pointer to 32 bit flat addresses
    for a component entry.

Arguments:

    CurrentEntry - Supplies a pointer to a component entry which will
        be updated.

Returns:

    None.

--*/
{
    PULONG_PTR UpdatePointer;
    FPVOID NextEntry;
    ULONG_PTR FlatAddress;

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    UpdatePointer = (PULONG_PTR)&CurrentEntry->Child;
    NextEntry = (FPVOID)CurrentEntry->Child;
    FlatAddress = (ULONG_PTR)MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (PULONG_PTR)&CurrentEntry->Parent;
    NextEntry = (FPVOID)CurrentEntry->Parent;
    FlatAddress = (ULONG_PTR)MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (PULONG_PTR)&CurrentEntry->Sibling;
    NextEntry = (FPVOID)CurrentEntry->Sibling;
    FlatAddress = (ULONG_PTR)MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (PULONG_PTR)&CurrentEntry->ComponentEntry.Identifier;
    NextEntry = (FPVOID)CurrentEntry->ComponentEntry.Identifier;
    FlatAddress = (ULONG_PTR)MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (PULONG_PTR)&CurrentEntry->ConfigurationData;
    NextEntry = (FPVOID)CurrentEntry->ConfigurationData;
    FlatAddress = (ULONG_PTR)MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

}



VOID
UpdateConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine traverses loader configuration tree and changes
    all the "far" pointer to 32 bit flat addresses.

Arguments:

    CurrentEntry - Supplies a pointer to a loader configuration
        tree or subtree.

Returns:

    None.

--*/
{
    if (CurrentEntry) {
        UpdateConfigurationTree(CurrentEntry->Child);
        UpdateConfigurationTree(CurrentEntry->Sibling);
        UpdateComponentPointers(CurrentEntry);
    }
}

FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    )

/*++

Routine Description:

    This routine allocates space from far heap , puts the caller's controller
    information to the space and sets up CONFIGURATION_COMPONENT
    structure for the caller.

Arguments:

    Component - Supplies the address the component whose configuration data
                should be set up.

    Identifier - Suppies a pointer to the identifier to identify the controller

    ControlData - Supplies a point to a structure which describes
                controller information.

    SpecificDataLength - size of the device specific data.  Device specific
                data is the information not defined in the standard format.

    SpecificData - Supplies a pointer to the device specific data.


Return Value:

    Returns a far pointer to the Configuration data.

--*/

{
    FPCHAR fpIdentifier;
    FPHWRESOURCE_DESCRIPTOR_LIST fpDescriptor = NULL;
    USHORT Length;
    SHORT Count, i;
    FPUCHAR fpSpecificData;

    //
    // Set up Identifier string for hardware component, if necessary.
    //

    if (Identifier) {
        Length = strlen(Identifier) + 1;
        Component->IdentifierLength = Length;
        fpIdentifier = (FPUCHAR)HwAllocateHeap(Length, FALSE);
        Component->Identifier = fpIdentifier;
        _fstrcpy(fpIdentifier, Identifier);
    } else {
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;
    }

    //
    // Set up configuration data for hardware component, if necessary
    //

    Count = ControlData->NumberPortEntries + ControlData->NumberIrqEntries +
            ControlData->NumberMemoryEntries + ControlData->NumberDmaEntries;

    if (SpecificDataLength) {

        //
        // if we have device specific data, we need to increment the count
        // by one.
        //

        Count++;
    }

    if (Count >0) {
        Length = (USHORT)(Count * sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                 FIELD_OFFSET(HWRESOURCE_DESCRIPTOR_LIST, PartialDescriptors) +
                 SpecificDataLength);
        fpDescriptor = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(Length, TRUE);
        fpDescriptor->Count = Count;

        //
        // Copy all the partial descriptors to the destination descriptors
        // except the last one. (The last partial descriptor may be a device
        // specific data.  It requires special handling.)
        //

        for (i = 0; i < (Count - 1); i++) {
            fpDescriptor->PartialDescriptors[i] =
                                        ControlData->DescriptorList[i];
        }

        //
        // Set up the last partial descriptor.  If it is a port, memory, irq or
        // dma entry, we simply copy it.  If the last one is for device specific
        // data, we set up the length and copy the device spcific data to the end
        // of the decriptor.
        //

        if (SpecificData) {
            fpDescriptor->PartialDescriptors[Count - 1].Type =
                            RESOURCE_DEVICE_DATA;
            fpDescriptor->PartialDescriptors[Count - 1].Flags = 0;
            fpDescriptor->PartialDescriptors[Count - 1].u.DeviceSpecificData.DataSize =
                            SpecificDataLength;
            fpSpecificData = (FPUCHAR)&(fpDescriptor->PartialDescriptors[Count]);
            _fmemcpy(fpSpecificData, SpecificData, SpecificDataLength);
        } else {
            fpDescriptor->PartialDescriptors[Count - 1] =
                            ControlData->DescriptorList[Count - 1];
        }
        Component->ConfigurationDataLength = Length;
    }
    return(fpDescriptor);
}
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    )

/*++

Routine Description:

    This routine initialize free formed data header.  Note this routine
    sets the the Header and initialize the FIRST PartialDescriptor only.
    If the header contains more than one descriptor, the caller must handle
    it itself.

Arguments:

    Header - Supplies a pointer to the header to be initialized.

    Version - Version number for the header.

    Revision - Revision number for the header.

    Flags - Free formed data flags.  (Currently, it is undefined and
                should be zero.)

    DataSize - Size of the free formed data.


Return Value:

    None.

--*/

{

    Header->Version = Version;
    Header->Revision = Revision;
    Header->Count = 1;
    Header->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    Header->PartialDescriptors[0].ShareDisposition = 0;
    Header->PartialDescriptors[0].Flags = Flags;
    Header->PartialDescriptors[0].u.DeviceSpecificData.DataSize = DataSize;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
}
#if DBG

VOID
CheckComponentNode(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    FPUCHAR NextEntry, DataPointer;
    ULONG_PTR FlatAddress;
    ULONG Length;
    UCHAR IdString[40];
    USHORT Count, i;
    UCHAR Type;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    FlatAddress = MAKE_FLAT_ADDRESS(CurrentEntry);
    clrscrn ();
    BlPrint("\n");
    BlPrint("Current Node: %lx\n", FlatAddress);
    BlPrint("  Type = %s\n", TypeName[CurrentEntry->ComponentEntry.Type]);

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    NextEntry = (FPUCHAR)CurrentEntry->Child;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Child = %lx\n", FlatAddress);
    } else {
        BlPrint("\tChild = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Parent;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Parent = %lx\n", FlatAddress);
    } else {
        BlPrint("\tParent = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Sibling;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Sibling = %lx\n", FlatAddress);
    } else {
        BlPrint("\tSibling = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->ConfigurationData;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: ConfigurationData = %lx\n", FlatAddress);
    } else {
        BlPrint("\tConfigurationData = %lx\n", FlatAddress);
    }

    Length = CurrentEntry->ComponentEntry.IdentifierLength;
    BlPrint("IdentifierLength = %lx\n", CurrentEntry->ComponentEntry.IdentifierLength);
    if (Length > 0) {
        _fstrcpy(IdString, CurrentEntry->ComponentEntry.Identifier);
        BlPrint("Identifier = %s\n", IdString);
    }

    Length = CurrentEntry->ComponentEntry.ConfigurationDataLength;
    BlPrint("ConfigdataLength = %lx\n", Length);

    if (Length > 0) {

        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)CurrentEntry->ConfigurationData;
        BlPrint("Version = %x, Revision = %x\n", DescriptorList->Version,
                 DescriptorList->Revision);
        Count = (USHORT)DescriptorList->Count;
        Descriptor = &DescriptorList->PartialDescriptors[0];
        BlPrint("Count = %x\n", Count);
        while (Count > 0) {
            Type = Descriptor->Type;
            if (Type == RESOURCE_PORT) {
                BlPrint("Type = Port");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("PortFlags = %x\n", Descriptor->Flags);
                BlPrint("PortStart = %x", Descriptor->u.Port.Start);
                BlPrint("\tPortLength = %x\n", Descriptor->u.Port.Length);
            } else if (Type == RESOURCE_DMA) {
                BlPrint("Type = Dma");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("DmaFlags = %x\n", Descriptor->Flags);
                BlPrint("DmaChannel = %x", Descriptor->u.Dma.Channel);
                BlPrint("\tDmaPort = %lx\n", Descriptor->u.Dma.Port);
            } else if (Type == RESOURCE_INTERRUPT) {
                BlPrint("Type = Interrupt");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("InterruptFlags = %x\n", Descriptor->Flags);
                BlPrint("Level = %x", Descriptor->u.Interrupt.Level);
                BlPrint("\tVector = %x\n", Descriptor->u.Interrupt.Vector);
            } else if (Type == RESOURCE_MEMORY) {
                BlPrint("Type = Memory");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("MemoryFlags = %x\n", Descriptor->Flags);
                BlPrint("Start1 = %lx", (ULONG)Descriptor->u.Memory.Start.LowPart);
                BlPrint("\tStart2 = %lx", (ULONG)Descriptor->u.Memory.Start.HighPart);
                BlPrint("\tLength = %lx\n", Descriptor->u.Memory.Length);
            } else {
                BlPrint("Type = Device Data\n");
                Length = Descriptor->u.DeviceSpecificData.DataSize;
                BlPrint("Size = %lx\n", Length);
                DataPointer = (FPUCHAR)(Descriptor+1);
                for (i = 0; i < Length && i < 64; i++) {
                    BlPrint("%x ", *DataPointer);
                    DataPointer++;
                }
                break;
            }
            Count--;
            Descriptor++;
        }
    }
#if defined(NEC_98)
    HwGetKey ();
#elif !defined(_GAMBIT_)
    while (HwGetKey() == 0) {
    }
#endif // PC98 || _GAMBIT_
}

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    if (CurrentEntry) {
        CheckComponentNode(CurrentEntry);
        CheckConfigurationTree(CurrentEntry->Sibling);
        CheckConfigurationTree(CurrentEntry->Child);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwdetect.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    detect.h

Abstract:

    This module is a global C include file for all the detection
    modules.

Author:

    Shie-Lin Tzong (shielint) 27-Dec-1991

Revision History:

--*/

#if !defined(_IA64_)
#define i386
#define _X86_
#endif // _IA64_
#define __stdcall
#include "types.h"
#include "ntmisc.h"
#include <ntconfig.h>
#include <arc.h>

//
// Machine type definitions.
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

//
// Interrupt controller register addresses.
//

#define PIC1_PORT0 0x20         // master PIC
#define PIC1_PORT1 0x21
#define PIC2_PORT0 0x0A0        // slave PIC
#define PIC2_PORT1 0x0A1

//
// Commands for interrupt controller
//

#define OCW3_READ_ISR 0xb
#define OCW3_READ_IRR 0xa

//
// Definitions for the data stored in the first page 0x700 area
// The 0x700 is the place vdm loads MS-DOS.  It should be very safe
// to pass the data required by vdm.
//

#define DOS_BEGIN_SEGMENT 0x70   // DOS loaded segment address

#define VIDEO_FONT_OFFSET 0      // Video font ptrs stored at 0x700
#define VIDEO_FONT_DATA_SIZE 0x40

#define EBIOS_INFO_OFFSET 0x40   // Extended bios infor:
                                 //   EBIOS data area address 4 bytes
                                 //   EBIOS data area size 4 byte
#define EBIOS_INFO_SIZE   0x8

//
// Mouse information structure
// N.B. This *must* match the one defined in mouse.inc
//

typedef struct _MOUSE_INFORMATION {
        UCHAR MouseType;
        UCHAR MouseSubtype;
        USHORT MousePort;       // if serial mouse, 1 for com1, 2 for com2 ...
        USHORT MouseIrq;
        USHORT DeviceIdLength;
        UCHAR  DeviceId[10];
} MOUSE_INFORMATION, *PMOUSE_INFORMATION;

//
// Mouse Type definitions
//

#define UNKNOWN_MOUSE   0
#define NO_MOUSE        0x100             // YES! it is 0x100 *NOT* 0x10000

#define MS_MOUSE        0x200             // MS regular mouses
#define MS_BALLPOINT    0x300             // MS ballpoint mouse
#define LT_MOUSE        0x400             // Logitec Mouse

//
// note last 4 bits of the subtype are reserved subtype specific use
//

#define PS_MOUSE        0x1
#define SERIAL_MOUSE    0x2
#define INPORT_MOUSE    0x3
#define BUS_MOUSE       0x4
#define PS_MOUSE_WITH_WHEEL     0x5
#define SERIAL_MOUSE_WITH_WHEEL 0x6

//#define MOUSE_RESERVE_MASK  0xfffffff

//
// Definitions for the keyboard type returned from
// the detect keyboard function.
//

#define UNKNOWN_KEYBOARD  0
#define OLI_83KEY         1
#define OLI_102KEY        2
#define OLI_86KEY         3
#define OLI_A101_102KEY   4
#define XT_83KEY          5
#define ATT_302           6
#define PCAT_ENHANCED     7
#define PCAT_86KEY        8
#define PCXT_84KEY        9

//
// Redefine the configuration component structures to use FAR pointer type.
//
// Since ntdetect.com running at 16 bit real mode, it has to use FAR pointers
// to access loader heap.  Before returning to ntldr, ntdetect must convert
// these far pointers to 32 bit flat addresses such that kernel can acess the
// configuration tree.
//

typedef struct _FWCONFIGURATION_COMPONENT {
    CONFIGURATION_CLASS Class;
#if !defined(_IA64_)
    USHORT Reserved0;
#endif
    CONFIGURATION_TYPE Type;
#if !defined(_IA64_)
    USHORT Reserverd1;
#endif
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
    ULONG ConfigurationDataLength;
    ULONG IdentifierLength;
    FPCHAR Identifier;
} FWCONFIGURATION_COMPONENT, far *FPFWCONFIGURATION_COMPONENT;

typedef struct _FWCONFIGURATION_COMPONENT_DATA {
    struct _FWCONFIGURATION_COMPONENT_DATA far *Parent;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Child;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Sibling;
    FWCONFIGURATION_COMPONENT ComponentEntry;
    FPVOID ConfigurationData;
} FWCONFIGURATION_COMPONENT_DATA, far *FPFWCONFIGURATION_COMPONENT_DATA;

//
// defined the MicroChannel POS data structure
//

typedef CM_MCA_POS_DATA MCA_POS_DATA, far *FPMCA_POS_DATA;

//
// Rom Block Definition
//

typedef CM_ROM_BLOCK ROM_BLOCK, far *FPROM_BLOCK;
#define RESERVED_ROM_BLOCK_LIST_SIZE (((0xf0000 - 0xc0000)/512) * sizeof(ROM_BLOCK))

//
// Other type redefinitions
//

typedef CM_PARTIAL_RESOURCE_DESCRIPTOR HWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR *PHWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR far *FPHWPARTIAL_RESOURCE_DESCRIPTOR;

typedef CM_PARTIAL_RESOURCE_LIST HWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST *PHWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST far *FPHWRESOURCE_DESCRIPTOR_LIST;

#if defined(NEC_98)
#define SYSTEM_SEGMENT   0x00400000
#define SYSTEM_SEGMENT_2 0xf8e80000
#else // PC98
typedef CM_EISA_SLOT_INFORMATION EISA_SLOT_INFORMATION, *PEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION far *FPEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION EISA_FUNCTION_INFORMATION, *PEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION far *FPEISA_FUNCTION_INFORMATION;
#endif // PC98

#define LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define EDGE_TRIGGERED CM_RESOURCE_INTERRUPT_LATCHED
#define RESOURCE_PORT 1
#define RESOURCE_INTERRUPT 2
#define RESOURCE_MEMORY 3
#define RESOURCE_DMA 4
#define RESOURCE_DEVICE_DATA 5
#define ALL_PROCESSORS 0xffffffff

#if defined(NEC_98)
//
// BIOS_FLAG5
//
#define ENABLE_FULL_CENTRO  0x02
#define PRTMODE_FULL_CENTRO 0x04

//
// BIOS_FLAG7
//
#define LOCKED_LPT          0x01
#define LOCKED_CCU1         0x02
#define LOCKED_CCU2         0x04
#define LOCKED_FD           0x08
#define LOCKED_PD           0x10


#define SCSI_MAX_ID         7
#define DASCSI              0x20
#define UA_MASK             0x0F

#define COM_ID_L            ((USHORT)GetF8E8Seg(0x00))
#define COM_ID_H            ((USHORT)GetF8E8Seg(0x01))
#define ROM_FLAG5           ((USHORT)GetF8E8Seg(0x11))
#define ROM_FLAG7           ((USHORT)GetF8E8Seg(0x13))
#define ROM_REV             ((USHORT)GetF8E8Seg(0x3F))

#define BIOS_FLAG5          ((USHORT)Get0Seg(0x458))
#define EQUIPS_47Ch         ((USHORT)Get0Seg(0x47C))
#define H_EQUIPS            ((USHORT)Get0Seg(0x47D))
#define H_DISK_EQUIPS_L     ((USHORT)Get0Seg(0x47E))
#define H_DISK_EQUIPS_H     ((USHORT)Get0Seg(0x47F))
#define DISK_EQUIPS_SCSI    ((USHORT)Get0Seg(0x482))
#define DISK_EQUIPS_FD      ((USHORT)Get0Seg(0x55C))
#define DAUA_BOOTED_FROM    ((USHORT)Get0Seg(0x584))
#define DISK_2HC            ((USHORT)Get0Seg(0x5AE))


#endif // PC98
//
// Note the DATA_HEADER_SIZE counts ONE partial descriptor only.
// if the resource list has more than one descriptors, you must add
// the size of extra descriptors to this value.
//

#define DATA_HEADER_SIZE sizeof(CM_PARTIAL_RESOURCE_LIST)

//
// Defines the structure to store controller information
// (used by ntdetect internally)
//

#define MAXIMUM_DESCRIPTORS 10

typedef struct _HWCONTROLLER_DATA {
    UCHAR NumberPortEntries;
    UCHAR NumberIrqEntries;
    UCHAR NumberMemoryEntries;
    UCHAR NumberDmaEntries;
    HWPARTIAL_RESOURCE_DESCRIPTOR DescriptorList[MAXIMUM_DESCRIPTORS];
} HWCONTROLLER_DATA, *PHWCONTROLLER_DATA;

//
// Macro definitions for conversion between far and fat pointers
//

#if defined(_IA64_)
#define MAKE_FP(p,a)                 p = (VOID *)a
#define MAKE_FLAT_ADDRESS(fp)        (ULONG_PTR) (fp)
#else
#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )
#endif // _IA64_

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((ULONG_PTR)&(((type *)0)->field))

//
// I/O Port read and write routines.
//

extern
VOID
WRITE_PORT_UCHAR (
    PUCHAR  PortAddress,
    UCHAR   Value
    );

extern
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

extern
VOID
WRITE_PORT_USHORT (
    PUSHORT PortAddress,
    USHORT  Value
    );

extern
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

//
// prototype definitions for Heap management routines
//

extern
BOOLEAN
HwInitializeHeap (
    ULONG HeapStart,
    ULONG HeapSize
    );

extern
FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    );

extern
VOID
HwFreeHeap(
    ULONG Size
    );

//
// Misc. prototype definitions
//

extern
FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    );

extern
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    );

extern
BOOLEAN
IsEnhancedKeyboard (
    VOID
    );

extern
SHORT
GetKeyboardIdBytes (
   PCHAR IdBuffer,
   SHORT Length
   );

extern
USHORT
GetKeyboardId(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    IN USHORT KeyboardId
    );

#if 0 // Remove video detection
extern
ULONG
GetVideoAdapterType (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetVideoConfigurationData (
    IN ULONG VideoType
    );
#endif // Remove video detection

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetLptInformation (
    VOID
    );

extern
PMOUSE_INFORMATION
GetMouseId (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetAtDiskInformation(
    VOID
    );

extern
BOOLEAN
HwIsMcaSystem(
    VOID
    );

#if defined(NEC_98)
#else // PC98
extern
BOOLEAN
HwIsEisaSystem(
    VOID
    );
#endif // PC98

extern
BOOLEAN
IsNpxPresent(
    VOID
    );

extern
USHORT
HwGetProcessorType(
    VOID
    );

extern
USHORT
HwGetCpuStepping(
    USHORT
    );

extern
VOID
GetMcaPosData(
    FPVOID Entry,
    FPULONG DataLength
    );

#if defined(NEC_98)
#else // PC98
extern
VOID
GetEisaConfigurationData(
    FPVOID Entry,
    FPULONG DataLength
    );
#endif // PC98

extern
VOID
UpdateConfigurationTree(
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
    );

extern
PUCHAR
GetMachineId(
    VOID
    );

#if defined(NEC_98)
#else // PC98
extern
VOID
HwGetEisaSlotInformation (
    PEISA_SLOT_INFORMATION SlotInformation,
    UCHAR Slot
    );

extern
UCHAR
HwGetEisaFunctionInformation (
    PEISA_FUNCTION_INFORMATION FunctionInformation,
    UCHAR Slot,
    UCHAR Function
    );
#endif // PC98

extern
VOID
GetBiosSystemEnvironment (
    PUCHAR Buffer
    );

extern
VOID
GetInt13DriveParameters (
    PUCHAR Buffer,
    PUSHORT Size
    );

extern
VOID
GetRomBlocks(
    FPUCHAR ReservedBuff,
    PUSHORT Size
    );

extern
VOID
GetVideoFontInformation(
    VOID
    );

extern
BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    );

VOID
HwGetPciSystemData(
    PVOID,
    BOOLEAN
    );

VOID
HwGetBiosDate(
    ULONG source,
    USHORT  Length,
    PUSHORT BiosYear,
    PUSHORT BiosMonth,
    PUSHORT BiosDay
    );

BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    IN PUSHORT Length
    );

BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    );

#if defined(NEC_98)
USHORT
Get0Seg(
    IN USHORT   OffsetAddress
    );

USHORT
GetF8E8Seg(
    IN USHORT   OffsetAddress
    );

VOID
IoDelay(
    USHORT counter
    );
#endif // PC98
#if DBG
extern
VOID
BlPrint(
    IN PCHAR,
    ...
    );

extern
VOID
clrscrn (
    VOID
    );

#endif // DBG

//
// External declarations for global variables
//

extern USHORT HwBusType;

extern FPFWCONFIGURATION_COMPONENT_DATA AdapterEntry;

extern FPMCA_POS_DATA HwMcaPosData;

extern FPUCHAR FpRomBlock;

extern USHORT RomBlockLength;

extern FPUCHAR HwEisaConfigurationData;

extern ULONG HwEisaConfigurationSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\diska.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    diska.c

Abstract:

	This module implements the assembly code necessary to detect/collect
        hard disk parameter informat.

Author:

    Allen Kay	(akay)	15-Aug-97

--*/


USHORT NumberBiosDisks;

VOID
GetInt13DriveParameters(
    OUT PUCHAR Buffer;
    OUT PUSHORT Size
    )

/*++
  
Routine Description:
  
    This function calls int 13h function 8 to get drive parameters
    for drive 80h - 87h.
  
Arguments:
  
    Buffer - Supplies a pointer to a buffer to receive the drive parameter
             information.
  
    Size   - Supplies a pointer to a USHORT to receive the size of the dirve
             parameter information returned.

Return Value:
  
    None.
  
--*/

{
    IA32_BIOS_REGISTER_STATE IA32RegisterState;
    BIT32_AND_BIT16 IA32Register, Eax, Edx;
    UCHAR TempVal;
    USHORT DriveSelect;
    PINT13_DRIVE_PARAMETERS DriveParameters;

    DriveSelect = 0x80;                      // starting from drive 0x80
    DriveParameters = (PINT13_DRIVE_PARAMETERS) Buffer;

    while (DriveSelect <= 0x88) {
        NumberBiosDisks++;

        IA32Register.LowPart16 = DriveSelect;
        IA32Register.HighPart16 = 0;
        IA32RegisterState.edx = IA32Register.Part32;

        IA32Register.Byte0 = 0;
        IA32Register.Byte1 = 0x15;               // int 13h function 15h
        IA32Register.Byte2 = 0;
        IA32Register.Byte3 = 0;
        IA32RegisterState.eax = IA32Register.Part32;

        SAL_PROC(0x13,&IA32RegisterState,0,0,0,0,0,0);

        //
        // First get all the needed registers.
        //
        Eax.Part32 = IA32RegisterState.Eax;
        if ( ( IA32RegisterState.Eflags & CARRY_FLAG ) == 0) &&
            Eax.Byte1 != 0 ) {

            //
            // Call int 13h function 8h to read drive parameters.
            //
            IA32Register.Byte0 = 0;
            IA32Register.Byte1 = 0x8;             // int 0x13 function 0x8
            IA32Register.Byte2 = 0;
            IA32Register.Byte3 = 0;
            IA32RegisterState.eax = IA32Register.Part32;

            SAL_PROC(0x13,&IA32RegisterState,0,0,0,0,0,0);

            if ( ( IA32RegisterState.Eflags & CARRY_FLAG ) != 0) {
                return 0;
            }

            //
            // First setup of the registers we are going to use.
            //
            Ecx.Part32 = IA32RegisterState.Eax;
            Edx.Part32 = IA32RegisterState.Edx;

            //
            // Get the maximum usable sector number.
            //
            DriveParameters->SectorsPerTrack = Ecx.Part32 & 0x3f;

            //
            // Get the maximum cylinder number.
            //
            Ecx.Byte0 = Ecx.Byte0 >> 6;
            TmpVal = Ecx.Byte0;
            Ecx.Byte1 = Ecx.Byte0;
            Ecx.Byte0 = TmpVal;
            DriveParameters->MaxCylinders = Ecx.LowPart16;
        
            //
            // Get the maximum heads.
            //
            DriveParameters->MaxHeads = Edx.HighPart16;
        
            //
            // Get the number of drives.
            //
            DriveParameters->NumberDrives = Edx.Byte0;

            //
            // Set the drive select number;
            //
            DriveParameters->DriveSelect = DriveSelect++;

            DriveParameters++;
        }
    }
    Size = NumberOfDisks * sizeof (INT13_DRIVE_PARAMETERS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwheap.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This is a very simple Heap Manager for NT OS Hardware recognizer.
    This module provides functions to allocate memory in byte-unit
    from a permanent heap.

Author:

    Shie-Lin Tzong (shielint) 18-Oct-91


Environment:

    Kernel Mode


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

VOID
GrowHeapSpace(
    ULONG
    );

VOID
HeapCheck(
    PVOID
    );

//
// Heap management variables.
//

ULONG_PTR HwHeapBase = 0;        // Current virtual address of base of heap
ULONG_PTR HwHeapPointer = 0;     // Pointer to the end of available heap
ULONG  HwHeapSize = 0;          // Size of Heap
ULONG  HwAvailableHeap = 0;     // Currently available heap space

#if DBG
ULONG HwPreviousAllocSize = 0;
#endif

BOOLEAN
HwResizeHeap (
    ULONG NewHeapSize
    )

/*++

Routine Description:

    The routine grows current heap to the specified size.
    It reallocates the heap, copies the data in current heap to
    the new heap, updates heap variables, updates heap pointers
    in hardware data structures and finally frees the old heap.

Arguments:

    NewHeapSize - Specifies the size of the new heap.

Returns:

    TRUE - if operation is done sucessfully.  Else it returns FALSE.

--*/

{
    //
    // Not implemented yet.
    //

    return(FALSE);
}

BOOLEAN
HwInitializeHeap(
    ULONG HeapStart,
    ULONG HeapSize
    )

/*++

Routine Description:

    The routine allocates heap and initializes some vital heap
    variables.

Arguments:

    None

Returns:

    FALSE - if unable to allocate initial heap.  Else it returns TRUE.

--*/

{

    HwHeapBase = HeapStart;
    HwHeapPointer = HwHeapBase;
    HwHeapSize = HeapSize;
    HwAvailableHeap = HwHeapSize;
    return(TRUE);

}

FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    )

/**

Routine Description:

    Allocates memory from the hardware recognizer's heap.

    The heap begins with a default size. If a request exhausts heap space,
    the heap will be grown to accomodate the request. The heap can grow
    up to any size limited by NTLDR.  If we run out of heap space and are
    unable to allocate more memory, a value of NULL will be returned.

Arguments:

    RequestSize - Size of block to allocate.

    ZeroInitialized - Specifies if the heap should be zero initialized.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{
    FPVOID ReturnPointer;

    if (RequestSize > HwAvailableHeap) {

        //
        // We're out of heap.  Try to grow current heap to satisfy the
        // request.
        //

        if (!HwResizeHeap(HwHeapSize + RequestSize)) {
#if DBG
            BlPrint("Unable to grow heap\n");
#endif
            return(NULL);
        }
    }

    //
    // Set our return value to the new Heap pointer then
    // update the remaining space and heap pointer.
    //

    HwHeapPointer = (HwHeapPointer + 0xf) & ~0xf;
    MAKE_FP(ReturnPointer, HwHeapPointer);
    HwHeapPointer += (RequestSize + 0xf) & ~0xf;
#if DBG
    HwPreviousAllocSize = RequestSize;
#endif
    HwAvailableHeap -= RequestSize;
    if (ZeroInitialized) {
        _fmemset(ReturnPointer, 0, (USHORT)RequestSize);
    }
    return (ReturnPointer);
}

VOID
HwFreeHeap(
    ULONG Size
    )

/**

Routine Description:

    Unallocates memory from the hardware recognizer's heap.

    The unallocation is very basic.  It simply moves heap pointer
    back by the size specified and increases the heap size by the
    specified size.  The routine should be used only when previous
    allocateHeap allocated too much memory.

Arguments:

    RequestSize - Size of block to allocate.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{

#if DBG
    if (Size > HwPreviousAllocSize) {
        BlPrint("Invalid heap deallocation ...\n");
    } else {
        HwPreviousAllocSize -= Size;
    }
#endif

    Size = (Size + 0xf) & 0xfffffff0;   // align at 16-byte boundary
    HwHeapPointer -= Size;
    HwAvailableHeap += Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwmcac.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This is the Mca hardware detection module.  Its main function is
    to detect various mca related hardware.

Author:

    Shie-Lin Tzong (shielint) 21-Jan-92


Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"

//
// Define the size of POS data = ( slot 0 - 8 + VideoSubsystem) * (2 id bytes + 4 POS bytes)
//

#define POS_DATA_SIZE   (10 * 6)

#if !defined(_GAMBIT_)
extern
VOID
CollectPs2PosData (
    FPVOID Buffer
    );
#endif // _GAMBIT_

VOID
GetMcaPosData(
    FPVOID Buffer,
    FPULONG Size
    )

/*++

Routine Description:

    This routine collects all the mca slot POS and Id information
    and stores it in the caller supplied Buffer and
    returns the size of the data.

Arguments:


    Buffer - A pointer to a PVOID to recieve the address of configuration
        data.

    Size - a pointer to a ULONG to receive the size of the configuration
        data.

Return Value:

    None.

--*/

{
    FPUCHAR ConfigurationData;
    ULONG Length;

    Length = POS_DATA_SIZE + DATA_HEADER_SIZE;
    ConfigurationData = (FPVOID)HwAllocateHeap(Length, FALSE);
#if !defined(_GAMBIT_)
    CollectPs2PosData(ConfigurationData + DATA_HEADER_SIZE);
#endif
    HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              (ULONG)POS_DATA_SIZE
                              );
    *(FPULONG)Buffer = PtrToUlong(ConfigurationData);
    *Size = Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwpbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpbiosc.c

Abstract:

    This modules contains PnP BIOS C supporting routines

Author:

    Shie-Lin Tzong (shielint) 20-Apr-1995

Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include <string.h>
#if !defined(_GAMBIT_)
#include "pnpbios.h"
#endif

BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    )
/*++

Routine Description:

    This routine checks if PNP BIOS is present in the machine.  If yes, it
    also create a registry descriptor to collect the BIOS data.

Arguments:

    Configuration - Supplies a variable to receive the PNP BIOS data.

    Length - Supplies a variable to receive the size of the data + HEADER

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/
{
#if defined(_GAMBIT_)
    return FALSE;
#else
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPPNP_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, totalSize = 0, nodeSize, numberNodes, retCode;
    ENTRY_POINT biosEntry;
    FPPNP_BIOS_DEVICE_NODE deviceNode;
    USHORT control = GET_CURRENT_CONFIGURATION;

    //
    // Perform PNP BIOS installation Check
    //

    MAKE_FP(current, PNP_BIOS_START);
    romAddr = PNP_BIOS_START;
    romEnd  = PNP_BIOS_END;

    while (romAddr < romEnd) {
        header = (FPPNP_BIOS_INSTALLATION_CHECK)current;
        if (header->Signature[0] == '$' && header->Signature[1] == 'P' &&
            header->Signature[2] == 'n' && header->Signature[3] == 'P' &&
            header->Length >= sizeof(PNP_BIOS_INSTALLATION_CHECK)) {
#if DBG
            BlPrint("GetPnpBiosData: find Pnp installation\n");
#endif
            sum = 0;
            for (i = 0; i < header->Length; i++) {
                sum += current[i];
            }
            if (sum == 0) {
                break;
            }
#if DBG
            BlPrint("GetPnpBiosData: Checksum fails\n");
#endif
        }
        romAddr += PNP_BIOS_HEADER_INCREMENT;
        MAKE_FP(current, romAddr);
    }
    if (romAddr >= romEnd) {
        return FALSE;
    }

#if DBG
    BlPrint("PnP installation check at %lx\n", romAddr);
#endif
    //
    // Determine how much space we will need and allocate heap space
    //

    totalSize += sizeof(PNP_BIOS_INSTALLATION_CHECK) + DATA_HEADER_SIZE;
    biosEntry = *(ENTRY_POINT far *)&header->RealModeEntryOffset;

    retCode = biosEntry(PNP_BIOS_GET_NUMBER_DEVICE_NODES,
                        (FPUSHORT)&numberNodes,
                        (FPUSHORT)&nodeSize,
                        header->RealModeDataBaseAddress
                        );
    if (retCode != 0) {
#if DBG
        BlPrint("GetPnpBiosData: PnP Bios GetNumberNodes func returns failure %x.\n", retCode);
#endif
        return FALSE;
    }

#if DBG
    BlPrint("GetPnpBiosData: Pnp Bios GetNumberNodes returns %x nodes\n", numberNodes);
#endif
    deviceNode = (FPPNP_BIOS_DEVICE_NODE) HwAllocateHeap(nodeSize, FALSE);
    if (!deviceNode) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    while (node != 0xFF) {
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios GetDeviceNode func returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)nodeSize);
            return FALSE;
        }
#if DBG
        BlPrint("GetPnpBiosData: PnpBios GetDeviceNode returns nodesize %x for node %x\n", deviceNode->Size, node);
#endif
        totalSize += deviceNode->Size;
    }

#if DBG
    BlPrint("GetPnpBiosData: PnpBios total size of nodes %lx\n", totalSize);
#endif

    HwFreeHeap((ULONG)nodeSize);       // Free temporary buffer

    current = (FPUCHAR) HwAllocateHeap(totalSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect PnP Bios installation check data and device node data.
    //

    _fmemcpy (current + DATA_HEADER_SIZE,
              (FPUCHAR)header,
              sizeof(PNP_BIOS_INSTALLATION_CHECK)
              );
    deviceNode = (FPPNP_BIOS_DEVICE_NODE)(current + DATA_HEADER_SIZE +
                                          sizeof(PNP_BIOS_INSTALLATION_CHECK));
    node = 0;
    while (node != 0xFF) {
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios func 1 returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)totalSize);
            return FALSE;
        }
        deviceNode = (FPPNP_BIOS_DEVICE_NODE)((FPUCHAR)deviceNode + deviceNode->Size);
    }
    *Configuration = current;
    *Length = totalSize;
    return TRUE;
#endif // _GAMBIT_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hweisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1992

Environment:

    16-bit real mode.


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

#if defined(NEC_98)
#else // PC98
typedef EISA_PORT_CONFIGURATION far *FPEISA_PORT_CONFIGURATION;

extern CM_EISA_FUNCTION_INFORMATION FunctionInformation;


VOID
GetEisaConfigurationData (
    FPVOID Buffer,
    FPULONG Size
    )

/*++

Routine Description:

    This routine collects all the eisa slot information, function
    information and stores it in the caller supplied Buffer and
    returns the size of the data.

Arguments:


    Buffer - A pointer to a PVOID to recieve the address of configuration
        data.

    Size - a pointer to a ULONG to receive the size of the configuration
        data.

Return Value:

    None.

--*/

{
    UCHAR Slot=0;
    UCHAR Function=0, SlotFunctions = 0, ReturnCode;
    EISA_SLOT_INFORMATION  SlotInformation;
    FPUCHAR ConfigurationData, CurrentData;
    FPEISA_SLOT_INFORMATION FarSlotInformation;
    ULONG TotalSize = DATA_HEADER_SIZE;
    BOOLEAN Overflowed = FALSE;

    HwGetEisaSlotInformation(&SlotInformation, Slot);

    TotalSize += sizeof(EISA_SLOT_INFORMATION);
    ConfigurationData = (FPVOID)HwAllocateHeap(TotalSize, FALSE);
    CurrentData = ConfigurationData + DATA_HEADER_SIZE;

    _fmemcpy(CurrentData, (FPVOID)&SlotInformation, sizeof(EISA_SLOT_INFORMATION));
    FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;

    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // Ensure that the slot is not empty and collect all the function
        // information for the slot.
        //

        if (SlotInformation.ReturnCode != EISA_EMPTY_SLOT) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = HwGetEisaFunctionInformation(
                                         &FunctionInformation, Slot, Function);
                Function++;

                //
                // if function call succeeds and the function contains usefull
                // information or this is the last function for the slot and
                // there is no function information collected for the slot, we
                // will save this function information to our heap.
                //

                if (!ReturnCode) {
                    if (((FunctionInformation.FunctionFlags & 0x7f) != 0) ||
                        (SlotInformation.NumberFunctions == Function &&
                         SlotFunctions == 0)) {
                        CurrentData = (FPVOID)HwAllocateHeap(
                                      sizeof(EISA_FUNCTION_INFORMATION), FALSE);
                        if (CurrentData == NULL) {
                            Overflowed = TRUE;
                            break;
                        }
                        SlotFunctions++;
                        TotalSize += sizeof(EISA_FUNCTION_INFORMATION);
                        _fmemcpy(CurrentData,
                                (FPVOID)&FunctionInformation,
                                sizeof(EISA_FUNCTION_INFORMATION));
                    }
                }
            }
            FarSlotInformation->NumberFunctions = SlotFunctions;
        }
        if (Overflowed) {
            break;
        }
        Slot++;
        Function = 0;
        HwGetEisaSlotInformation(&SlotInformation, Slot);
        CurrentData = (FPVOID)HwAllocateHeap(
                                  sizeof(EISA_SLOT_INFORMATION), FALSE);
        if (CurrentData == NULL) {
            Overflowed = TRUE;
            break;
        }
        TotalSize += sizeof(EISA_SLOT_INFORMATION);
        _fmemcpy(CurrentData,
                (FPVOID)&SlotInformation,
                sizeof(EISA_SLOT_INFORMATION));
        FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;
        SlotFunctions = 0;
    }

    //
    // Free the last EISA_SLOT_INFORMATION space which contains the slot
    // information for IVALID SLOT
    //

    if (Overflowed != TRUE) {
        HwFreeHeap(sizeof(EISA_SLOT_INFORMATION));
        TotalSize -= sizeof(EISA_SLOT_INFORMATION);
    }

    //
    // Check if we got any EISA information.  If nothing, we release
    // the space for data header and return.
    //

    if (TotalSize == DATA_HEADER_SIZE) {
        HwFreeHeap(DATA_HEADER_SIZE);
        *(FPULONG)Buffer = (ULONG)0;
        *Size = (ULONG)0;
    } else {
        HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                                  0,
                                  0,
                                  0,
                                  TotalSize - DATA_HEADER_SIZE
                                  );
        *(FPULONG)Buffer = (ULONG)ConfigurationData;
        *Size = TotalSize;
    }
}

BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    )

/*++

Routine Description:

    This routine scans EISA configuration data to match the I/O port address.
    The IRQ information is returned from the matched EISA function information.

Arguments:

    Port - The I/O port address to scan for.

    Irq - Supplies a pointer to a variable to receive the irq information.

    TriggerMethod - Supplies a pointer to a variable to receive the
                    EISA interrupt trigger method.

Return Value:

    TRUE - if the Irq information is found.  Otherwise a value of FALSE is
    returned.

--*/

{
    UCHAR Function, i, j;
    FPEISA_SLOT_INFORMATION SlotInformation;
    FPEISA_FUNCTION_INFORMATION Buffer;
    UCHAR FunctionFlags;
    ULONG SizeToScan = 0L;
    EISA_PORT_CONFIGURATION PortConfig;
    EISA_IRQ_DESCRIPTOR IrqConfig;
    SlotInformation = (FPEISA_SLOT_INFORMATION)HwEisaConfigurationData;

    //
    // Scan through all the EISA configuration data.
    //

    while (SizeToScan < HwEisaConfigurationSize) {
        if (SlotInformation->ReturnCode != EISA_EMPTY_SLOT) {

            //
            // Make sure this slot contains PORT_RANGE and IRQ information.
            //

            if ((SlotInformation->FunctionInformation & EISA_HAS_PORT_RANGE) &&
                (SlotInformation->FunctionInformation & EISA_HAS_IRQ_ENTRY)) {

                Buffer = (FPEISA_FUNCTION_INFORMATION)(SlotInformation + 1);

                //
                // For each function of the slot, if it contains both the IRQ
                // and PORT information, we then check for its PORT address.
                //

                for (Function = 0; Function < SlotInformation->NumberFunctions; Function++) {
                    FunctionFlags = Buffer->FunctionFlags;
                    if ((FunctionFlags & EISA_HAS_IRQ_ENTRY) &&
                        (FunctionFlags & EISA_HAS_PORT_RANGE)) {
                        for (i = 0; i < 20 ; i++ ) {
                            PortConfig = Buffer->EisaPort[i];
                            if ((Port >= PortConfig.PortAddress) &&
                                (Port <= (PortConfig.PortAddress +
                                 PortConfig.Configuration.NumberPorts))) {

                                //
                                // If there is only one IRQ entry, that's the
                                // one we want.  (This is the normal case and
                                // correct usage of EISA function data.)  Otherwise,
                                // we try to get the irq from the same index
                                // number as port entry.  (This is ALR's incorrect
                                // way of packing functions into one function
                                // data.)
                                //

                                IrqConfig = Buffer->EisaIrq[0].ConfigurationByte;
                                if (IrqConfig.MoreEntries == 0) {
                                    *Irq = IrqConfig.Interrupt;
                                    *TriggerMethod = IrqConfig.LevelTriggered;
                                    return(TRUE);
                                } else if (i >= 7) {
                                    return(FALSE);
                                }

                                for (j = 0; j <= i; j++) {
                                    if (j == i) {
                                        *Irq = IrqConfig.Interrupt;
                                        *TriggerMethod = IrqConfig.LevelTriggered;
                                        return(TRUE);
                                    }
                                    if (!IrqConfig.MoreEntries) {
                                        return(FALSE);
                                    }
                                    IrqConfig =
                                        Buffer->EisaIrq[j+1].ConfigurationByte;
                                }
                                return(FALSE);
                            }
                            if (!PortConfig.Configuration.MoreEntries) {
                                break;
                            }
                        }
                    }
                    Buffer++;
                }
            }

            //
            // Move on to next slot
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION) +
                          sizeof(EISA_FUNCTION_INFORMATION) *
                          SlotInformation->NumberFunctions;
            SlotInformation = (FPEISA_SLOT_INFORMATION)(HwEisaConfigurationData +
                                                        SizeToScan);
        } else {

            //
            // This is a empty slot.  We simply skip it.
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION);
            SlotInformation++;
        }
    }
    return(FALSE);
}
#endif // PC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID
#define KPROCESSOR_STATE ULONG
#define WCHAR USHORT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwpmbios.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpmbiosc.c

Abstract:

    This modules contains ACPI BIOS C supporting routines

Author:

    Jake Oshins (jakeo) 6-Feb-1997

Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include <string.h>
#include "acpibios.h"


BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    )
/*++

Routine Description:

    This routine checks to see if an ACPI BIOS is present.  If it is,
    then it returns the ACPI Root System Description Pointer.

Arguments:
    
    Configuration - structure that holds ACPI pointer
    Length        - length of that structure

Return Value:

    TRUE if ACPI BIOS is present, FALSE otherwise

--*/
{
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPULONG EbdaAddr;
    FPACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, nodeSize;
    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the 
    // Root System Description Table structure. 
    //
#if defined(NEC_98)
    //
    // PC98, we search (physical) memory from 0xE8000
    // to 0xFFFFF.

    MAKE_FP(current, 0xE8000);
    romAddr = 0xE8000;
    romEnd  = ACPI_BIOS_END;
#else
    for (pass = PASS1; pass < MAX_PASSES; pass++) {
        
        if (pass == PASS1) {
            // 
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.
            //

            //
            // Earlier, we stored the address of the EBDA in address
            // DOS_BEGIN_SEGMENT << 4 : EBIOS_INFO_OFFSET
            //
            MAKE_FP(EbdaAddr, ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET));
            MAKE_FP(current, *EbdaAddr);

            if (*EbdaAddr == 0) {
                continue;
            }

            romAddr = *EbdaAddr;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000 
            // to 0xF0000.
            
            MAKE_FP(current, ACPI_BIOS_START);
            romAddr = ACPI_BIOS_START;
            romEnd  = ACPI_BIOS_END;
        }
#endif

        while (romAddr < romEnd) {
    
            header = (FPACPI_BIOS_INSTALLATION_CHECK)current;
            
            //
            // Signature to match is the string "RSD PTR".
            //
            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {
                
                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum += current[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
#if DBG
                BlPrint("GetAcpiBiosData: Checksum fails\n");
#endif
            }
            romAddr += ACPI_BIOS_HEADER_INCREMENT;
            MAKE_FP(current, romAddr);
        }
#if defined(NEC_98)
#else
    }
#endif
    if (romAddr >= romEnd) {
#if DBG
            BlPrint("GetAcpiBiosData: RSDT pointer not found\n");
#endif
        return FALSE;
    }

    nodeSize = sizeof(ACPI_BIOS_INSTALLATION_CHECK) + DATA_HEADER_SIZE;
    current = (FPUCHAR) HwAllocateHeap(nodeSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetAcpiBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect ACPI Bios installation check data and device node data.
    //

    _fmemcpy (current + DATA_HEADER_SIZE,
              (FPUCHAR)header,
              sizeof(ACPI_BIOS_INSTALLATION_CHECK)
              );
    
    *Configuration = current;
    *Length = nodeSize;

#if DBG
    BlPrint("ACPI BIOS found at 0x%x:%x.  RdstAddress is 0x%x:%x\n", 
            (USHORT)(romAddr >> 16), 
            (USHORT)(romAddr),
            (USHORT)(header->RsdtAddress >> 16),
            (USHORT)(header->RsdtAddress)
            );
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwvbios.h ===
#if defined(NEC_98)
    //
    // use for GetRomBlocks routine
    //
    #define     N_LIMIT         0x20            // N mode XROM area limit ; 4c0h+20h -> E8000H(E7FFFh)
    #define     H_LIMIT         0x30            // H mode XROM area limit ; 4c0h+30h -> F0000H(EFFFFh)
    #define     XROM_ID_SIZE(a) (a ? H_LIMIT : N_LIMIT) // XROM Control ID Table Size
    #define     XROM_ID_MASK    0xC0            // CHECK FOR XROM Control ID Table bit7,6
    #define     XROM_SIZE       0x1000          // XROM 1Block Size = 4k
    #define     XROM_USED       0xC0            // XROM Control ID Table bit7=on ,bit6=on
    #define     XROM_UNUSED     0x00            // XROM Control ID Table bit7=off,bit6=off
    #define     XROM_BELONG     0x80            // XROM Control ID Table bit7=on ,bit6=off
    #define     XROM_START      0xC0000L        // XROM Start Address
    #define     ID_TABLE_ADDR   0x04C0          // XROM Control ID Table Start Address
    #define     N_MODE_ROM_ADDR 0xE8000L
    #define     H_MODE_ROM_ADDR 0xF0000L
    #define     N_MODE_ROM_SIZE 0x18000L
    #define     H_MODE_ROM_SIZE 0x10000L
#else // PC98
//
// Defines for machine models
//

#define          PS2_AT     0xF819      // PS/2 non-micro channel
#define          PS2_L40    0xF823      // PS/2 non-micro channel
#define          PS1_386    0xF830      // 386 non-microchannel     // 6.13

#define        PS2_PORT     0x0001      // PS/2 specific port
#define        ISA_PORT     0x0002      // AT specific port
#define     HYBRID_PORT     0x0004      // PS/2 non-micro channel specific port

//
//  Bios int 15h C0h buffer definition
//

struct BIOS_INT15_C0_BUFFER {
    USHORT Size;
    USHORT Model;
    UCHAR BiosRevision;
    UCHAR ConfigurationFlags;
    UCHAR Reserved[4];
} BiosSystemEnvironment;

typedef struct _TEMPORARY_ROM_BLOCK {
    ROM_BLOCK RomBlock;
    struct _TEMPORARY_ROM_BLOCK far *Next;
} TEMPORARY_ROM_BLOCK, far * FPTEMPORARY_ROM_BLOCK;

#define POS_MAX_SLOT 8

#define ROMBIOS_START   0xF0000
#define ROMBIOS_LEN     0x10000

#define PS2BIOS_START   0xE0000
#define PS2BIOS_LEN     0x20000

#define EXTROM_START    0xC0000         // where and how far to
#define EXTROM_LEN      0x40000         // search for external adapter ROMs

#define EBIOSDATA_START 0x9FC00
#define EBIOSDATA_LEN   0x00400

#define NUMBER_VECTORS  0x80
#define VGA_PARAMETER_POINTER   0x4A8
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// ROM format
//

#define ROM_HEADER_SIGNATURE    0xAA55
#define ROM_HEADER_INCREMENT    0x800
#define BLOCKSIZE       512

typedef struct _ROM_HEADER {
    USHORT Signature;                   // should be ROMHDR_SIGNATURE
    UCHAR NumberBlocks;                 // # of ROM blocks
    UCHAR Filler[ROM_HEADER_INCREMENT - 3];
} ROM_HEADER, far *FPROM_HEADER;

//
// External References
//

extern
BOOLEAN
HwRomCompare (
    ULONG Source,
    ULONG Destination,
    ULONG Size
    );
#endif // PC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwvbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This module goes through ROM area and tries to pick up all the ROM
    blocks.

Author:

    Shie-Lin Tzong (shielint) 21-Jan-92


Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include "hwvbios.h"
#if defined(_GAMBIT_)
#include "ssc.h"
#endif

#if !defined(_GAMBIT_)
FPTEMPORARY_ROM_BLOCK BlockHead;
FPTEMPORARY_ROM_BLOCK BlockPointer;

BOOLEAN
AddRomBlock (
    ULONG RomAddress,
    ULONG RomSize
    )

/*++

Routine Description:

    This routine adds a ROM/RAM block to our ROM list.

Arguments:

    RomAddress - the starting address of the ROM/RAM block to be added.

    RomSize - the size of the ROM/RAM block (in byte).

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/

{
    LONG AddSize;
    ULONG AddAddress;
    FPTEMPORARY_ROM_BLOCK pCurrentBlock, pNextBlock;
    ULONG CurrentBlock, NextBlock, AddBlock;
    ULONG EndAddBlock, EndCurrentBlock, EndNextBlock;
    BOOLEAN  fOverlap=FALSE;

    pCurrentBlock = NULL;
    pNextBlock = NULL;
    AddSize = RomSize;
    AddAddress = RomAddress;
    AddBlock = RomAddress;

    //
    // If there are other blocks, make sure there is no overlap with them
    //

    if (BlockHead) {

        pCurrentBlock = BlockHead;
        pNextBlock = pCurrentBlock->Next;
        CurrentBlock = pCurrentBlock->RomBlock.Address;
        EndCurrentBlock = CurrentBlock + pCurrentBlock->RomBlock.Size;
        EndAddBlock = RomAddress + RomSize;

        while (pCurrentBlock!=NULL) {

            //
            // calculate location of next block (if it's there)
            //

            if(pNextBlock) {
                NextBlock = pNextBlock->RomBlock.Address;
                EndNextBlock = NextBlock + pNextBlock->RomBlock.Size;
            }

            //
            // if overlapping with current block, then stop and
            // resolve overlap
            //

            if((RomAddress < EndCurrentBlock)&& (RomAddress >= CurrentBlock)){
                fOverlap = TRUE;
                break;
            }

            //
            // if add block is lower than the current one,
            // or there is not a next block, then no need to search further
            //

            if((EndAddBlock <= CurrentBlock) || (pNextBlock == NULL)) {
                break;
            }

            //
            // if block is lower than next one, but greater than current
            // one, we have found the right area
            //

            if ((EndAddBlock <= NextBlock) && (AddBlock >= EndCurrentBlock)) {
                break;
            }

            //
            // if conflicting with next block, stop searching and
            // resolve conflict after this loop
            //

            if((EndAddBlock > NextBlock) && (EndAddBlock <= EndNextBlock)) {
                fOverlap = TRUE;
                break;
            }

            pCurrentBlock = pNextBlock;
            pNextBlock = pCurrentBlock->Next;
            CurrentBlock = NextBlock;
            EndCurrentBlock = EndNextBlock;
        }
    }

    //
    // if we have reached this point, there may be a conflict
    // with the current block.
    //

    if(fOverlap) {
        if(AddBlock < EndCurrentBlock) {
            AddAddress = EndCurrentBlock;
            AddSize = EndAddBlock - EndCurrentBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
        if((pNextBlock != NULL) && (EndAddBlock > NextBlock)) {
            AddSize = NextBlock - AddBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
    }

    BlockPointer->RomBlock.Address = AddAddress;
    BlockPointer->RomBlock.Size = AddSize;

    //
    // Put it on the list.
    // if it belongs on top, put it there
    //

    if ((pCurrentBlock == NULL)||
       ((pCurrentBlock == BlockHead) && (CurrentBlock > AddBlock))) {
        BlockPointer->Next = pCurrentBlock;
        BlockHead = BlockPointer;
    } else {

        //
        // else add to middle or bottom depending on NextBlock
        //

        BlockPointer->Next = pNextBlock;
        pCurrentBlock->Next = BlockPointer;
    }
    BlockPointer++;                         // Note that this works because
                                            // we know the offset part of
                                            // the addr is always < 64k.
    return TRUE;
}
VOID
AddPs2CardRomRam (
    VOID
    )

/*++

Routine Description:

    This routine adds ROM/RAM block to our ROM list for missed MCA Adapters.

    Notes:  This function was constructed to recognize
            PS/2 cards that normally are missed.  Without
            this code, VBIOS will not recognize certain adapters
            since they have no ROM header, or use RAM.

            POS ID    Adapter Name       ROM     RAM
            -------   ------------       ---     ---
            E000      Token Ring          x       x
            E001      Token Ring          x       x
            E04F      3119 Scanner                x
            E1FF      3270 Ver B                  x
            E7FF      3270 Ver A                  x

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;
    USHORT CardID;
    ULONG ROMAddr,RAMAddr;
    ULONG RAMSize, ROMSize;
    FPMCA_POS_DATA PosData;

    //
    // for every adapter slot, we search if the card is IBM Token Ring.
    // if yes, we will calculate RAM and ROM address from POS information
    // and add these blocks to our ROM BLOCK list.
    //

    for (i = 0L; i < POS_MAX_SLOT; i++) {

        ROMAddr = 0L;
        RAMAddr = 0L;
        RAMSize = 0L;
        ROMSize = 0L;

        //
        // get the POS ID of the card
        //

        PosData = HwMcaPosData + i;
        CardID = PosData->AdapterId;
        switch(CardID) {

        //
        // 4Mhz Token ring (0xE000) or 16/4Mhz Token ring (0xE001)
        //

        case 0xE000:
        case 0xE001:

            //
            // get ROM and RAM addresses of adapter
            //

            ROMAddr = ((ULONG)PosData->PosData3 & 0xfe)<<12;
            RAMAddr = ((ULONG)PosData->PosData1 & 0xfe)<<12;
            RAMSize = (ULONG) (1<<((PosData->PosData2 & 0x0c)>>2)) * 8192L;
            ROMSize = 8192L;
            break;

        //
        // 3119 Scanner
        // formula  (shl (and (not (shr POS[0] 4)) 0xf)  13) + 0xC0000
        //

        case 0xE04F:

            RAMAddr = (((~((ULONG)PosData->PosData1 >> 4)) & 0xf) << 13) + 0xC0000L;
            RAMSize = 0x2000L;              // size is fixed
            break;

        //
        // 3270 Version A
        //

        case 0xE7FF:

            RAMAddr = 0xCE000L;             // address is fixed
            RAMSize = 8192L;                // size is fixed
            break;

        //
        // 3270 Version B
        //

        case 0xE1FF:

            RAMAddr = ((ULONG)PosData->PosData2) << 12;
            RAMSize = 8192L;                // size is fixed
            break;

        default:
            break;
        }

        //
        // if adapter has ROM, then add it
        //

        if (ROMAddr) {
            AddRomBlock(ROMAddr, ROMSize);
        }

        //
        // if adapter has RAM, then add it
        //

        if (RAMAddr) {
            AddRomBlock(RAMAddr, RAMSize);
        }
    }
}

BOOLEAN
ScanRomBlocks(
    VOID
    )

/*++

Routine Description:

    This routine scans the ROM IO area and checks for 55AA at every
    512 bytes for valid ROM blocks.


    NOTES:

                -------------
                |           |
                |           |
           ------------------100000
             ^  |           |
             |  |           |
             |  -------------f0000  (ROMBIOS_START)              ---
             |  |           |                                     ^
             |  |           |                                     |
     EXTROM_LEN -------------e0000  (PS2BIOS_START)  ---          |
             |  |           |                         ^    Search |
             |  |           |                  Search |    Range  |
             |  -------------d0000             Range  |    on AT  |
             |  |           |                  on PS/2|           |
             V  |           |                         V           V
           ------------------c0000 (EXTROM_START)    ---         ---

        ON AT:
          Scan through EXTROM_START-effff for ROM Blocks
        ON PS2
          Scan through EXTROM_START-dffff for ROM Blocks

Arguments:


    None.

Return Value:

    None.

--*/

{
    ULONG BlockSize;
    BOOLEAN Success = TRUE;
    FPUCHAR Current;
    ULONG RomAddr, RomEnd;

    //
    // As per the machine type restrict the search range
    //

    MAKE_FP(Current, EXTROM_START);
    RomAddr = EXTROM_START;

    if ((HwBusType == MACHINE_TYPE_MCA) ||
        (BiosSystemEnvironment.Model == PS2_L40) ||
        (BiosSystemEnvironment.Model == PS1_386) ||
        (BiosSystemEnvironment.Model == PS2_AT)) {

        RomEnd = PS2BIOS_START;
    } else {
        RomEnd = ROMBIOS_START;
    }

    while (RomAddr < RomEnd) {

        if (((FPROM_HEADER)Current)->Signature == ROM_HEADER_SIGNATURE) {

            BlockSize = (ULONG)((FPROM_HEADER)Current)->NumberBlocks * BLOCKSIZE;

            if ((RomAddr + BlockSize) > RomEnd) {
                BlockSize = RomEnd - RomAddr;
            }

            //
            // V7 VRAM card does not correctly report its BlockSize.  Since
            // this is a very popular video card, we provide a workaround
            // for it.
            //

            if ((RomAddr == 0xC0000) && (BlockSize < 0x8000)) {
                BlockSize = 0x8000;
            }
            if (!AddRomBlock(RomAddr, BlockSize)) {
                Success = FALSE;
                break;
            }
            RomAddr += BlockSize;
            RomAddr = ALIGN_UP(RomAddr, ROM_HEADER_INCREMENT);
            MAKE_FP(Current, RomAddr);
            continue;
        }
        RomAddr += ROM_HEADER_INCREMENT;
        MAKE_FP(Current, RomAddr);
    }

    //
    // Last but not least, add the system ROM to the list
    //

    if (Success) {

        RomAddr = ROMBIOS_START;
        BlockSize = ROMBIOS_LEN;
        if ((HwBusType == MACHINE_TYPE_MCA) ||
            (BiosSystemEnvironment.Model == PS2_L40) ||
            (BiosSystemEnvironment.Model == PS1_386) ||
            (BiosSystemEnvironment.Model == PS2_AT)) {
            RomAddr = PS2BIOS_START;
            BlockSize = PS2BIOS_LEN;
        }

        if (!AddRomBlock(RomAddr, BlockSize)) {
            Success = FALSE;
        }
    }

    return Success;
}

FPTEMPORARY_ROM_BLOCK
MatchRomBlock (
    ULONG PhysicalAddr
    )

/*++

Routine Description:

    This routine finds the ROM block which the 'PhysicalAddr' is in.

Arguments:

    PhysicalAddr - the physical address ...

Return Value:

    A pointer to the detected ROM block.

--*/

{
    FPTEMPORARY_ROM_BLOCK CurrentBlock;
    ROM_BLOCK RomBlock;

    CurrentBlock = BlockHead;
    while (CurrentBlock) {
        RomBlock = CurrentBlock->RomBlock;
        if (RomBlock.Address <= PhysicalAddr &&
            RomBlock.Address +  RomBlock.Size > PhysicalAddr) {
            break;
        } else {
            CurrentBlock = CurrentBlock->Next;
        }
    }
    return(CurrentBlock);
}

BOOLEAN
IsSameRomBlock (
    FPTEMPORARY_ROM_BLOCK Source,
    FPTEMPORARY_ROM_BLOCK Destination
    )

/*++

Routine Description:

    This routine checks if the passed in ROM blocks contain the same
    information.  This ususally happens when the two ROM blocks are for
    video ROM and shadowed video ROM.

Arguments:

    Source - the source ROM block.

    Destination - the ROM block to compare with.

Return Value:

    BOOLEAN TRUE if the two ROM blocks are the same else FALSE is returned.

--*/

{

    if (Source == NULL || Destination == NULL) {
        return(FALSE);
    }

    //
    // First make sure their sizes are the same.
    //

    if (Source->RomBlock.Size == Destination->RomBlock.Size) {
        if (!HwRomCompare(Source->RomBlock.Address,
                          Destination->RomBlock.Address,
                          Source->RomBlock.Size)){
            return(TRUE);
        }
    }
    return(FALSE);

}

VOID
CheckVideoRom (
    VOID
    )

/*++

Routine Description:

    This routine checks if the int 10h video handler is in the video
    ROM block detected by us.  If not, the video ROM must have been
    remapped/shadowed to other area (usually 0xE0000.)

    NOTE: In this function, I commented out the code which removes the
          Video ROM block if it has been shadowed.  I found out
          machine POST code does not modify ALL the VIDEO ROM related
          pointers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Vector, Handler, VectorAddr = 0x10 * sizeof(ULONG);
    FPULONG pVectorAddr;
    FPTEMPORARY_ROM_BLOCK RomBlock, VideoRomBlock;
    ULONG Size;

    MAKE_FP(pVectorAddr, VectorAddr);
    Vector = *pVectorAddr;
    Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
    RomBlock = MatchRomBlock(Handler);

    //
    // Check if the int 10h handler falls in one of our ROM blocks.
    //

    if (RomBlock) {
        if (RomBlock->RomBlock.Address >= 0xC0000 &&
            RomBlock->RomBlock.Address < 0xC8000) {

            //
            // if int 10h handler is in the standard video ROM area, we simply
            // return.  Either the video ROM is not shadowed or it
            // is a in-place shadow.
            //

            return;
        } else {

            //
            // The ROM block associated with the int 10h handler is not in
            // standard video bios ROM area.  It must have been mapped to
            // the current location.  We now need to make sure we have the
            // ROM block which contains the 40:a8 VGA parameter.
            //

            VectorAddr = VGA_PARAMETER_POINTER;
            MAKE_FP(pVectorAddr, VectorAddr);
            Vector = *pVectorAddr;
            Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
            VideoRomBlock = MatchRomBlock(Handler);
            if (VideoRomBlock == NULL) {

                //
                // We did not find the Video ROM associated with the
                // VGA parameters.  Try detect it.
                //

                //
                // In the following memory comparison, we skip the first 16 bytes.
                // Because most likely the reason we did not find the standard
                // Video ROM is because the signature word is missing.
                //

                Handler = (Handler & 0xF0000) +
                              (RomBlock->RomBlock.Address & 0xFFFF);
                if (!HwRomCompare(RomBlock->RomBlock.Address + 0x10,
                                  Handler + 0x10,
                                  RomBlock->RomBlock.Size - 0x10)) {
                    if ( ( ( Handler & 0xFFFF ) == 0 ) && ( RomBlock->RomBlock.Size < 0x8000 ) ) {
                        Size = 0x8000;
                    } else {
                        Size = RomBlock->RomBlock.Size;
                    }
                    AddRomBlock(Handler, Size);
                }
            }
        }
    } else {

        //
        // There is no ROM block associated with the int 10h handler.
        // We can find the shadowed video ROM block if:
        //   We detected the original video ROM in 0xC0000 - 0xC8000 range
        //

        VideoRomBlock = MatchRomBlock((Handler & 0xFFFF) + 0xC0000);
        if (VideoRomBlock != NULL) {

            //
            // In the following memory comparison, we skip the first 16 bytes.
            // Because most likely the reason we did not find the shadow rom
            // is the signature word is missing.
            //

            if (!HwRomCompare(VideoRomBlock->RomBlock.Address + 0x10,
                              (Handler & 0xF0000) +
                                (VideoRomBlock->RomBlock.Address & 0xFFFF) + 0x10,
                              VideoRomBlock->RomBlock.Size - 0x10)) {

                AddRomBlock((VideoRomBlock->RomBlock.Address & 0xFFFF) +
                                (Handler & 0xF0000),
                            VideoRomBlock->RomBlock.Size);
            }
        }
    }
}
#endif // _GAMBIT_

VOID
GetRomBlocks(
    FPUCHAR ReservedBuffer,
    PUSHORT Size
    )

/*++

Routine Description:

    This routine scans the ROM IO area and collects all the ROM blocks.

Arguments:

    ReservedBuffer - Supplies a far pointer to the buffer.

    Size - Supplies a near pointer to a variable to receive the size
           of the ROM block.

Return Value:

    None.

--*/

{

#if defined(_GAMBIT_)
    *Size = 0;
#else
    FPTEMPORARY_ROM_BLOCK Source;
    ULONG StartAddr, EndAddr;
    FPUSHORT TestAddr;
    FPROM_BLOCK Destination;
    USHORT BufferSize;
    ULONG EBiosAddress = 0, EBiosLength = 0;
    ULONG far *EBiosInformation = (ULONG far *)
                          ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET);

    //
    // First we reserve the max space needed and build our temporary rom
    // block list in the heap space below the space reservedand.  After
    // the temporary list is built, we then copy it to the caller supplied
    // reserved space.
    //

    BlockPointer = (FPTEMPORARY_ROM_BLOCK)HwAllocateHeap(0, FALSE);
    BlockHead = NULL;
    *Size = 0;

    GetBiosSystemEnvironment((PUCHAR)&BiosSystemEnvironment);
    if (BiosSystemEnvironment.ConfigurationFlags & 0x4) {

        //
        // If extened BIOS data area is allocated, we will find out its
        // location and size and save in ROM blocks.
        //

        _asm {
              push   es
              mov    ah, 0xC1
              int    15h
              jc     short Exit

              cmp    ah, 0x86
              je     short Exit

              mov    bx, 0
              mov    dx, 0
              mov    ax, 0
              mov    al, es:[bx]
              shl    ax, 10
              mov    word ptr EBiosLength, ax
              mov    ax, es
              mov    dx, es
              shl    ax, 4
              shr    dx, 12
              mov    word ptr EBiosAddress, ax
              mov    word ptr EBiosAddress + 2, dx
        Exit:
              pop    es
        }
    }

    //
    // Save the Extended BIOS data area address and size at 700:40
    //

    if (EBiosLength) {
        *EBiosInformation++ = EBiosAddress;
        *EBiosInformation = EBiosLength;
    } else {
        *EBiosInformation++ = 0L;
        *EBiosInformation = 0L;
    }
    if (!ScanRomBlocks()) {
        return;
    }

    if (HwBusType == MACHINE_TYPE_MCA) {
        AddPs2CardRomRam();
    }

    //
    // On some machines, when they shadow video ROM from 0xC0000 to
    // 0xE0000, they copy code only (no signature.)  So, we need
    // special code to work around the problem.
    //

    CheckVideoRom();

    //
    // Now do our special hack for IBM.  On SOME IBM PCs, they use
    // E0000-FFFFF for system BIOS (even on non PS/2 machines.) Since
    // system BIOS has no ROM header, it is very hard to know the starting
    // address of system ROM.  So we:
    //
    // 1. Make sure there is no ROM block in E0000-EFFFF area.
    // 2. and E0000-EFFFF contains valid data.
    //
    // If both 1 and 2 are true, we assume E0000-EFFFF is part of system
    // ROM.
    //

    Source = BlockHead;
    while (Source) {
        StartAddr = Source->RomBlock.Address;
        EndAddr = StartAddr + Source->RomBlock.Size - 1;
        if ((StartAddr < 0xE0000 && EndAddr < 0xE0000) ||
            (StartAddr >= 0xF0000)) {
            Source = Source->Next;
        } else {
            break;
        }
    }
    if (Source == NULL) {
        for (StartAddr = 0xE0000; StartAddr < 0xF0000; StartAddr += 0x800) {
            MAKE_FP(TestAddr, StartAddr);
            if (*TestAddr != 0xffff) {
                AddRomBlock(0xE0000, 0x10000);
                break;
            }
        }
    }

    //
    // Now copy the rom block list to our reserved space and release
    // the extra space we reserved.
    //

    Source = BlockHead;
    Destination = (FPROM_BLOCK)ReservedBuffer;
    BufferSize = 0;
    while (Source) {
        *Destination = *((FPROM_BLOCK)&Source->RomBlock);
        BufferSize += sizeof(ROM_BLOCK);
        Source = Source->Next;
        Destination++;
    }
    *Size = BufferSize;
#endif // _GAMBIT_
}

VOID
HwGetBiosDate(
    ULONG   StartingAddress,
    USHORT  Length,
    PUSHORT Year,
    PUSHORT Month,
    PUSHORT Day
    )
/*++

Routine Description:

    Scans the specified area for the most recent date of the
    form xx/xx/xx.

Arguments:

    StartingAddress - First address to scan
    Length          - Length of area to scan

Return Value:

    Year            - If non-zero, the year of the date  (1991, 1992, ...)
    Month           - If non-zero, then month of the date found
    Day             - If non-zero, the day of the date found


--*/
{
    FPUCHAR fp, date;
    USHORT  y, m, d;
    UCHAR   c;
    ULONG   i, temp;

#if defined(_GAMBIT_)
    {
        SSC_TIME_FIELDS TimeFields;

        SscQueryRealTimeClock(&TimeFields);

        *Year  = (USHORT) TimeFields.Year;
        *Month = (USHORT) TimeFields.Month;
        *Day   = (USHORT) TimeFields.Day;
    }
#else
    //
    //
    // Zero return values
    //

    *Year  = 0;
    *Month = 0;
    *Day   = 0;

    //
    // Search for date with the format MM/DD/YY or M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
    //

    MAKE_FP(fp, StartingAddress);   //  initialize fp pointer
    while (Length > 8) {

        c = fp[7];
        if ((c < '0' ||  c > '9')  &&  (c != '/'  &&  c != '-')) {
            // these 8 bytes are not a date, next location

            fp     += 8;
            Length -= 8;
            continue;
        }

        date = fp;                  // check for date at this pointer
        fp += 1;                    // skip to next byte
        Length -= 1;

        //
        // Check for date of the form MM/DD/YY
        //

        y = 0;
        if (date[0] >= '0'  &&  date[0] <= '9'  &&
            date[1] >= '0'  &&  date[1] <= '9'  &&
           (date[2] == '/'  ||  date[2] == '-') &&
            date[3] >= '0'  &&  date[3] <= '9'  &&
            date[4] >= '0'  &&  date[4] <= '9'  &&
           (date[5] == '/'  ||  date[5] == '-') &&
            date[6] >= '0'  &&  date[6] <= '9'  &&
            date[7] >= '0'  &&  date[7] <= '9' ) {


            //
            // A valid looking date field at date, crack it
            //

            y = (date[6] - '0') * 10 + date[7] - '0' + 1900;
            m = (date[0] - '0') * 10 + date[1] - '0';
            d = (date[3] - '0') * 10 + date[4] - '0';
        }

        //
        // Check for date of the form M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
        //

        if (Length >= 15 &&
            date[ 0] >= '0'  &&  date[ 0] <= '9'  &&  date[ 0] == date[ 1]  &&
            date[ 2] >= '0'  &&  date[ 2] <= '9'  &&  date[ 2] == date[ 3]  &&
           (date[ 4] == '/'  ||  date[ 4] == '-') &&  date[ 4] == date[ 5]  &&
            date[ 6] >= '0'  &&  date[ 6] <= '9'  &&  date[ 6] == date[ 7]  &&
            date[ 8] >= '0'  &&  date[ 8] <= '9'  &&  date[ 8] == date[ 9]  &&
           (date[10] == '/'  ||  date[10] == '-') &&  date[10] == date[11]  &&
            date[12] >= '0'  &&  date[12] <= '9'  &&  date[12] == date[13]  &&
            date[14] >= '0'  &&  date[14] <= '9'  &&  date[14] == date[15]) {

            //
            // A valid looking date field at date, crack it
            //

            y = (date[12] - '0') * 10 + date[14] - '0' + 1900;
            m = (date[ 0] - '0') * 10 + date[ 2] - '0';
            d = (date[ 6] - '0') * 10 + date[ 8] - '0';
        }

        if (y != 0) {
            if (m < 1  ||  m > 12  ||  d < 1  ||  d > 31) {
                y = 0;          // bad field in date, skip it
            } else {
                if (y < 1980) {

                    //
                    // Roll to next century.
                    //

                    y += 100;
                }
            }
        }

        //
        // Check for date of the form 19xx or 20xx
        //
        // First, check the 5th character is not a digit.
        //

#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))

        if (!IS_DIGIT(date[4])) {
            for (i = 0, temp = 0; i < 4; i++) {
                if (!IS_DIGIT(date[i])) {
                    temp = 0;
                    break;
                }
                temp = (temp * 10) + date[i] - '0';
            }
            if ((temp >= 1980) || (temp < 2599)) {

                //
                // Looks like a reasonable date, use it.
                //

                y = temp;
                m = 0;
                d = 0;
            }
        }

        if (!y) {
            // not a date - skip it
            continue;
        }

        if ((y >  *Year) ||
            (y == *Year  &&  m >  *Month)  ||
            (y == *Year  &&  m == *Month  &&  d > *Day) ) {

            //
            // This date is more recent
            //

            *Year  = y;
            *Month = m;
            *Day   = d;
        }
    }
#endif // _GAMBIT_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\mousec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hwdata.c

Abstract:

    This module contains the C code to set up mouse configuration data.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1991

Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

#if !defined(_GAMBIT_)
#if defined(NEC_98)
extern PMOUSE_INFORMATION
LookFor98BusMouse (
    VOID
    );

#else
//
// External References
//

extern PMOUSE_INFORMATION
LookForPS2Mouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForInportMouse (
    VOID
    );

#endif 
extern PMOUSE_INFORMATION
LookForSerialMouse (
    VOID
    );

#if defined(NEC_98)
#else 
extern PMOUSE_INFORMATION
LookForBusMouse (
    VOID
    );

extern VOID
Empty8042 (
    VOID
    );

extern USHORT
HwGetKey (
    VOID
    );

extern VOID
HwPushKey (
    USHORT Key
    );
#endif 
#endif // _GAMBIT_

extern USHORT SavedKey;

//
// Define the master and slave i8259 IRQ bitmask.
//

#define MASTER_IRQ_MASK_BITS 0xB8
#define SLAVE_IRQ_MASK_BITS  0x02

//
// Define the lowest i8259 IRQ that the Inport mouse can reside on.  This
// has the highest NT priority.
//

#define INPORT_LOWEST_IRQ 0x03

//
// Define the Inport chip reset value.
//

#define INPORT_RESET 0x80

//
// Define the data registers (pointed to by the Inport address register).
//

#define INPORT_DATA_REGISTER_1 1
#define INPORT_DATA_REGISTER_2 2

//
// Define the Inport mouse mode register and mode bits.
//

#define INPORT_MODE_REGISTER           7
#define INPORT_MODE_0                  0x00 // 0 HZ - INTR = 0
#define INPORT_MODE_30HZ               0x01
#define INPORT_MODE_50HZ               0x02
#define INPORT_MODE_100HZ              0x03
#define INPORT_MODE_200HZ              0x04
#define INPORT_MODE_1                  0x06 // 0 HZ - INTR = 1
#define INPORT_DATA_INTERRUPT_ENABLE   0x08
#define INPORT_TIMER_INTERRUPT_ENABLE  0x10
#define INPORT_MODE_HOLD               0x20
#define INPORT_MODE_QUADRATURE         0x00

//
// Video adaptor type identifiers.
//

#if defined(NEC_98)
PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH",
    "NEC"
    };
#else   //
PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH"
    };
#endif

#if defined(NEC_98)
PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL",
    " PC-9800 BUS MOUSE",
    " N5200/E KB MOUSE"
    };
#else 
PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL"
    };
#endif

//
// The following table translates keyboard make code to
// ascii code.  Note, only 0-9 and A-Z are translated.
// Everything else is translated to '?'
//

UCHAR MakeToAsciiTable[] = {
    0x3f, 0x3f, 0x31, 0x32, 0x33,      // ?, ?, 1, 2, 3,
    0x34, 0x35, 0x36, 0x37, 0x38,      // 4, 5, 6, 7, 8,
    0x39, 0x30, 0x3f, 0x3f, 0x3f,      // 9, 0, ?, ?, ?,
    0x3f, 0x51, 0x57, 0x45, 0x52,      // ?, Q, W, E, R,
    0x54, 0x59, 0x55, 0x49, 0x4f,      // T, Y, U, I, O,
    0x50, 0x3f, 0x3f, 0x3f, 0x3f,      // P, ?, ?, ?, ?,
    0x41, 0x53, 0x44, 0x46, 0x47,      // A, S, D, F, G,
    0x48, 0x4a, 0x4b, 0x4c, 0x3f,      // H, J, K, L, ?,
    0x3f, 0x3f, 0x3f, 0x3f, 0x5a,      // ?, ?, ?, ?, Z,
    0x58, 0x43, 0x56, 0x42, 0x4e,      // X, C, V, B, N,
    0x4d};                             // W
#define MAX_MAKE_CODE_TRANSLATED 0x32

static ULONG MouseControllerKey = 0;

FPFWCONFIGURATION_COMPONENT_DATA
SetMouseConfigurationData (
    PMOUSE_INFORMATION MouseInfo,
    FPFWCONFIGURATION_COMPONENT_DATA MouseList
    )

/*++

Routine Description:

    This routine fills in mouse configuration data.

Arguments:

    MouseInfo - Supplies a pointer to the MOUSE_INFOR structure

    MouseList - Supplies a pointer to the existing mouse component list.

Returns:

    Returns a pointer to our mice controller list.

--*/
{
    UCHAR i = 0;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, Controller, PeripheralEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    USHORT z, Length;
    FPUCHAR fpString;

#if defined(NEC_98)
#if DBG
    BlPrint("98MousePORT=%x\n", MouseInfo->MousePort);
    BlPrint("98MouseMouseSubtype=%x\n", MouseInfo->MouseSubtype);
    BlPrint("98MouseVector=%x\n", MouseInfo->MouseIrq);
    BlPrint("98MouseMouseList=%x\n", MouseList);
#endif // DBG
#endif // defined(NEC_98)
    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // If it is not SERIAL_MOUSE, set up controller component
        //

        Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                     sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &Controller->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = PointerController;
        Component->Flags.Input = 1;
        Component->Version = 0;
        Component->Key = MouseControllerKey;
        MouseControllerKey++;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;

        //
        // If we have mouse irq or port information, allocate configuration
        // data space for mouse controller component to store these information
        //

        if (MouseInfo->MouseIrq != 0xffff || MouseInfo->MousePort != 0xffff) {

#if !defined(_GAMBIT_)
            //
            // Set up port and Irq information
            //

            if (MouseInfo->MousePort != 0xffff) {
                ControlData.NumberPortEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareDeviceExclusive;
                ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                ControlData.DescriptorList[z].u.Port.Start.LowPart =
                                        (ULONG)MouseInfo->MousePort;
                ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                ControlData.DescriptorList[z].u.Port.Length = 4;
                z++;
            }
            if (MouseInfo->MouseIrq != 0xffff) {
                ControlData.NumberIrqEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareUndetermined;
                ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
                ControlData.DescriptorList[z].u.Interrupt.Level =
                                        (ULONG)MouseInfo->MouseIrq;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                        (ULONG)MouseInfo->MouseIrq;
                if (HwBusType == MACHINE_TYPE_MCA) {
                    ControlData.DescriptorList[z].Flags =
                                                        LEVEL_SENSITIVE;
                } else {

                    //
                    // For EISA the LevelTriggered is temporarily set to FALSE.
                    //

                    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                }
            }
#endif // _GAMBIT_
            Controller->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          NULL,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

        } else {

            //
            // Otherwise, we don't have configuration data for the controller
            //

            Controller->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;
        }
    }

    //
    // Set up Mouse peripheral component
    //

    PeripheralEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &PeripheralEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = PointerPeripheral;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    PeripheralEntry->ConfigurationData = (FPVOID)NULL;

    //
    // If Mouse PnP device id is found, translate it to ascii code.
    // (The mouse device id is presented to us by keyboard make code.)
    //

    Length = 0;
    if (MouseInfo->DeviceIdLength != 0) {
        USHORT i;

        if (MouseInfo->MouseSubtype == PS_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                if (MouseInfo->DeviceId[i] > MAX_MAKE_CODE_TRANSLATED) {
                    MouseInfo->DeviceId[i] = '?';
                } else {
                    MouseInfo->DeviceId[i] = MakeToAsciiTable[MouseInfo->DeviceId[i]];
                }
            }
        } else if (MouseInfo->MouseSubtype == SERIAL_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                MouseInfo->DeviceId[i] += 0x20;
            }
        }
        Length = MouseInfo->DeviceIdLength + 3;
    }
    Length += strlen(MouseIdentifier[MouseInfo->MouseType]) +
              strlen(MouseSubidentifier[MouseInfo->MouseSubtype]) + 1;
    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
    if (MouseInfo->DeviceIdLength != 0) {
        _fstrcpy(fpString, MouseInfo->DeviceId);
        _fstrcat(fpString, " - ");
        _fstrcat(fpString, MouseIdentifier[MouseInfo->MouseType]);
    } else {
        _fstrcpy(fpString, MouseIdentifier[MouseInfo->MouseType]);
    }
    _fstrcat(fpString, MouseSubidentifier[MouseInfo->MouseSubtype]);
    Component->IdentifierLength = Length;
    Component->Identifier = fpString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {
        Controller->Child = PeripheralEntry;
        PeripheralEntry->Parent = Controller;
        if (MouseList) {

            //
            // Put the current mouse component to the beginning of the list
            //

            Controller->Sibling = MouseList;
        }
        return(Controller);
    } else {
        CurrentEntry = AdapterEntry->Child; // AdapterEntry MUST have child
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Type == SerialController) {
                if (MouseInfo->MousePort == (USHORT)CurrentEntry->ComponentEntry.Key) {

                    //
                    // For serial mouse, the MousePort field contains
                    // COM port number.
                    //

                    PeripheralEntry->Parent = CurrentEntry;
                    CurrentEntry->Child = PeripheralEntry;
                    break;
                }
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
        return(NULL);
    }
}

FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    )

/*++

Routine Description:

    This routine is the entry for mouse detection routine.  It will invoke
    lower level routines to detect ALL the mice in the system.

Arguments:

    None.

Returns:

    A pointer to a mouse component structure, if mouse/mice is detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PMOUSE_INFORMATION MouseInfo;
    FPFWCONFIGURATION_COMPONENT_DATA MouseList = NULL;

#if defined(_GAMBIT_)
    MouseInfo = (PMOUSE_INFORMATION)HwAllocateHeap (
                 sizeof(MOUSE_INFORMATION), TRUE);
    MouseInfo->MouseType = 2;    // Microsoft mouse
    MouseInfo->MouseSubtype = PS_MOUSE;    // PS2 mouse
    MouseInfo->MousePort = 0;    // Serial port 0
    MouseInfo->MouseIrq = 4;    // Interrupt request vector was 3 
    MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    return(MouseList);
#else
    //
    // Check if there is a key in keyboard look ahead buffer.  If yes and
    // we have not saved any, we will read it and remember it.
    //

#if defined(NEC_98)
    if (MouseInfo = LookFor98BusMouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    if (MouseInfo = LookForSerialMouse()) {
        SetMouseConfigurationData(MouseInfo, MouseList);
    }

#else 
    if (SavedKey == 0) {
        SavedKey = HwGetKey();
    }
    if (MouseInfo = LookForPS2Mouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }
    if (MouseInfo = LookForInportMouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    while (MouseInfo = LookForSerialMouse()) {
        SetMouseConfigurationData(MouseInfo, MouseList);
    }

    if (MouseInfo = LookForBusMouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    //
    // Finally drain 8042 output buffer again before we leave
    //

    Empty8042();

    //
    // If we have a keystroke before the mouse/keyboard detection, we
    // needs to push the key back to the keyboard look ahead buffer such
    // that ntldr can read it.
    //

    if (SavedKey) {
       HwPushKey(SavedKey);
    }
#endif 
#endif // _GAMBIT_
    return(MouseList);
}
#if defined(NEC_98) || defined(_GAMBIT_)
#else

BOOLEAN
InportMouseIrqDetection(
    IN USHORT CurrentPort,
    OUT PUSHORT Vector
    )

/*++

Routine Description:

    This routine attempts to locate the interrupt vector for which
    the Inport mouse is configured.  The allowable vectors are
    3, 4, 5, 7, and 9.  If no interrupt vector is found, or more than
    one is found, the routine returns FALSE.  Otherwise, TRUE is returned.

    Note that we diddle the i8259 interrupt controllers here.

Arguments:

    CurrentPort - I/O port to use for the mouse.

    Vector - Pointer to the location to store the mouse interrupt vector.

Return Value:

    Returns TRUE if the Inport interrupt vector was located; otherwise,
    FALSE is returned.

--*/

{
    UCHAR OldMasterMask, OldSlaveMask;
    UCHAR MasterMask, SlaveMask;
    UCHAR InterruptBits;
    UCHAR PossibleInterruptBits;
    int i;
    int NumberOfIRQs;
    BOOLEAN VectorFound = FALSE;

    //
    // Get the i8259 interrupt masks.
    //

    OldMasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
    OldSlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

    //
    // Raise IRQL to the highest priority IRQL the inport would use.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) 0xff ^ ((UCHAR)(1<<INPORT_LOWEST_IRQ) - 1)
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        (UCHAR) 0xff
        );

    //
    // Get the master i8259 interrupt mask.
    //

    MasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);

    //
    // Reset the Inport chip.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_RESET);

    //
    // Select the Inport mode register for use as the current data register.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_MODE_REGISTER);

    //
    // Disable potential Inport mouse interrupts.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) (MasterMask | MASTER_IRQ_MASK_BITS)
        );

    //
    // Select the i8259 Interrupt Request Register.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);

    //
    // Attempt to locate the Inport interrupt line on the master i8259.
    // Why try this 10 times?  It's magic...
    //

    PossibleInterruptBits = MASTER_IRQ_MASK_BITS;
    for (i = 0; i < 10; i++) {

        //
        // Generate a 0 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        InterruptBits ^= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;

        //
        // Generate a 1 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;
    }

    if (PossibleInterruptBits) {

        //
        // We found at least one IRQ on the master i8259 that could belong
        // to the Inport mouse.  Count how many we found.  If there is
        // more than one, we haven't found the vector.  Otherwise, we've
        // successfully located the Inport interrupt vector on the master
        // i8259 (provided the interrupt vector is 3, 4, 5, or 7).
        //

        PossibleInterruptBits >>= 3;
        NumberOfIRQs = 0;
        for (i = 3; i <= 7; i++) {
            if (PossibleInterruptBits & 1) {
                NumberOfIRQs += 1;
                *Vector = (CCHAR) i;
            }
            PossibleInterruptBits >>= 1;
        }
        if (NumberOfIRQs == 1) {
            VectorFound = TRUE;
        } else {
            *Vector = 0xffff;
        }
    }

    //
    // If we didn't locate the interrupt vector on the master i8259, attempt
    // to locate it on the slave i8259.
    //

    if (!VectorFound) {

        //
        // Get the slave i8259 interrupt mask.
        //

        SlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

        //
        // Disable potential Inport mouse interrupts.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR) PIC2_PORT1,
            (UCHAR) (SlaveMask | SLAVE_IRQ_MASK_BITS)
            );

        //
        // Select the i8259 Interrupt Request Register.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);

        //
        // Attempt to locate the Inport interrupt line on the slave i8259.
        // Why try this 10 times?  It's magic...
        //

        PossibleInterruptBits = SLAVE_IRQ_MASK_BITS;
        for (i = 0; i < 10; i++) {

            //
            // Generate a 0 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            InterruptBits ^= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

            //
            // Generate a 1 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

        }

        //
        // We may have found the Inport IRQ.  If it's not 2 on slave (really
        // 9, overall) then we have NOT found the Inport interrupt vector.
        // Otherwise, we have successfully located the Inport vector on
        // the slave i8259.
        //

        if (PossibleInterruptBits == 2) {
            *Vector = 9;
            VectorFound = TRUE;
        } else {
           *Vector = 0xffff;
        }

        //
        // Restore the i8259 slave.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_ISR);

        //
        // Restore the i8259 slave interrupt mask.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT1, SlaveMask);
    }

    //
    // Tri-state the Inport IRQ line.
    //

    WRITE_PORT_UCHAR((PUCHAR) (CurrentPort + INPORT_DATA_REGISTER_1), 0);

    //
    // Restore the i8259 master.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_ISR);

    //
    // Restore the i8259 master interrupt mask.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT1, MasterMask);

    //
    // Restore the previous IRQL.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        OldMasterMask
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        OldSlaveMask
        );

    return(VectorFound);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\keybdc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abiosc.c

Abstract:

    This module implements keybaord detection C routines.

Author:

    Shie-Lin Tzong (shielint) 18-Dec-1991

Environment:

    Real Mode.


Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

#if !defined(_GAMBIT_)
extern
UCHAR
GetKeyboardFlags (
    VOID
    );

extern
USHORT
HwGetKey (
    VOID
    );

extern BOOLEAN NoBiosKbdCheck;
#endif // _GAMBIT_
#if defined(NEC_98)
ULONG
GetKeyboard2ndIDNEC98(
    VOID
    );
//
// Definitions for the keyboard type returned from
// the detect keyboard function.
//

#define PC98_106KEY     10
#define PC98_NmodeKEY   11
#define PC98_HmodeKEY   12
#define PC98_LaptopKEY  13
#define PC98_N106KEY    14
#define N5200E_KEY      15

#define PC98_KEYBOARD_ID_FIRST_BYTE       0xA0
#define PC98_KEYBOARD_ID_2ND_BYTE_STD     0x80
#define PC98_KEYBOARD_ID_2ND_BYTE_N106    0x82
#define PC98_KEYBOARD_ID_2ND_BYTE_Win95   0x83
#define READ_KEYBOARD_2ND_ID              0x96
#define PC98_8251_BUFFER_EMPTY            0x01
#define PC98_8251_DATA_READY              0x02
#define ACKNOWLEDGE                       0xFA
#define RESEND                            0xFC

#define STATUS_SUCCESS                    0x00000000L // from ntstatus.h
#define STATUS_IO_TIMEOUT                 0xC00000B5L // from ntstatus.h
#define POLLING_ITERATION                 12000
#define RESEND_ITERATION                  3
#define KBD_COMMAND_STATUS_PORT           0x43
#define KBD_DATA_PORT                     0x41
#define PIC1_PORT1                        0x02
#endif // PC98

//
// SavedKey is used to save the key left in the keyboard type-ahead buffer
//   before we start our keyboard/mouse tests.  The key will be push back
//   to the type-ahead buffer once the mouse detection is done.
//

USHORT   SavedKey = 0;

//
// String table to map keyboard id to an ascii string.
//

PUCHAR KeyboardIdentifier[] = {
    "UNKNOWN_KEYBOARD",
    "OLI_83KEY",
    "OLI_102KEY",
    "OLI_86KEY",
    "OLI_A101_102KEY",
    "XT_83KEY",
    "ATT_302",
    "PCAT_ENHANCED",
    "PCAT_86KEY",
    "PCXT_84KEY"
#if defined(NEC_98)
    ,
    "PC98_106KEY",
    "PC98_NmodeKEY",
    "PC98_HmodeKEY",
    "PC98_LaptopKEY",
    "PC98_N106KEY",
    "N5200/E_KEY"
#endif // PC98
    };

UCHAR KeyboardType[] = {
    -1,
    1,
    2,
    3,
    4,
    1,
    1,
    4,
    3,
    1
#if defined(NEC_98)
    ,
    7,          //Japanese Keyboard Type
    7,          //Japanese Keyboard Type
    7,          //Japanese Keyboard Type
    7,          //Japanese Keyboard Type
    7,          //Japanese Keyboard Type
    7           //Japanese Keyboard Type
#endif // PC98
    };

UCHAR KeyboardSubtype[] = {
    -1,
    0,
    1,
    10,
    4,
    42,
    4,
    0,
    0,
    0
#if defined(NEC_98)
    ,
    1,             //10 PC-9800 Serise S/W Lock Keyboard
    2,             //11 PC-9801 VX/UX,PC-98XL/XL2 H/W Lock Keyboard
    3,             //12 PC-98XL/XL2 H/W Lock Keyboard
    4,             //13 PC-9800 Serise Laptop Keyboard
    5,             //14 PC-9801-116 Keyboard
    6              //15 N5200/E Serise Keyboard
#endif // PC98
    };

USHORT
GetKeyboardId(
    VOID
    )

/*++

Routine Description:

    This routine determines the Id of the keyboard.  It calls GetKeyboardIdBytes
    to complete the task.

Arguments:

    None.

Return Value:

    Keyboard ID.

--*/

{
#if defined(_GAMBIT_)
   return (7);          // PCAT_ENHANCED
#else
#if defined(NEC_98)
   char KeybID_Bytes[5];
   int  Num_ID_Bytes;
   ULONG  NEC2ndKeyID;
   int  keytype = UNKNOWN_KEYBOARD;

   Num_ID_Bytes = GetKeyboardIdBytes(KeybID_Bytes, 0x05);
   if (Num_ID_Bytes > 0) {
      switch(KeybID_Bytes[0] & 0x00ff) {

         case 0x80:
            keytype = PC98_NmodeKEY;
            break;

         case 0x88:
            keytype = PC98_HmodeKEY;
            break;

         case 0x40:
            NEC2ndKeyID = GetKeyboard2ndIDNEC98();
            if (NEC2ndKeyID == PC98_N106KEY) {
                keytype = PC98_N106KEY;
            }else{
                keytype = PC98_106KEY;
            }
            break;

         case 0x08:
         case 0x48:
            keytype = PC98_LaptopKEY;
            break;

         default:
            keytype = UNKNOWN_KEYBOARD;
            break;
      }
   } else {
      keytype = PCAT_ENHANCED;
   }

   return(keytype);
#else // PC98
   char KeybID_Bytes[5];
   int  Num_ID_Bytes;
   int  keytype = UNKNOWN_KEYBOARD;

   SavedKey = HwGetKey();

   Num_ID_Bytes = GetKeyboardIdBytes(KeybID_Bytes, 0x05);
   if (Num_ID_Bytes > 0) {
      switch(KeybID_Bytes[0] & 0x00ff) {
         case 0x02:
            keytype = OLI_83KEY;
            break;

         case 0x01:
            keytype = OLI_102KEY;
            break;

         case 0x10:
            keytype = OLI_86KEY;
            break;

         case 0x40:
            keytype = OLI_A101_102KEY;
            break;

         case 0x42:
            keytype = XT_83KEY;
            break;

         case 0x9c:
            keytype = PCXT_84KEY;
            break;

         case 0x04:
            keytype = ATT_302;
            break;

         case 0xfe:
            Num_ID_Bytes = GetKeyboardIdBytes(KeybID_Bytes, 0xf2);
            if (Num_ID_Bytes > 0) {
               if ((KeybID_Bytes[0] & 0x00ff) == 0xfa) {
                  keytype = PCAT_86KEY;
               } else if ((KeybID_Bytes[0] & 0x00ff) == 0xfe) {
                  keytype = PCAT_86KEY;
               } else if (Num_ID_Bytes >= 3 &&
                        ((KeybID_Bytes[1] & 0x00ff) == 0xAB) &&
                        ((KeybID_Bytes[2] & 0x00ff) == 0x41)) {
                  keytype = PCAT_ENHANCED;
               } else {
                  keytype = UNKNOWN_KEYBOARD;
               }
            } else {
               keytype = UNKNOWN_KEYBOARD;
            }
            break;

         default:
            keytype = UNKNOWN_KEYBOARD;
            break;
      }
   } else {
      keytype = PCXT_84KEY;
   }

   if (!NoBiosKbdCheck) {

       //
       // Sometimes enhanced keyboards get detected as 84/86 key keyboards
       // So we will look into the ROM DATA area (40:96) and see if the
       // Enhanced Keyboard bit is set.  If it is we will assume that the
       // detection failed to detect the presence of an enhanced keyb.
       //

       if ((keytype == PCXT_84KEY) ||
           (keytype == PCAT_86KEY) ||
           (keytype == UNKNOWN_KEYBOARD)) {

           if (IsEnhancedKeyboard()) {
             keytype = PCAT_ENHANCED;
          }
       }
   }
   return(keytype);
#endif // PC98
#endif // _GAMBIT_
}

FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    USHORT KeyboardId
    )

/*++

Routine Description:

    This routine maps Keyboard Id information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    KeyboardId - Supplies a USHORT which describes the keyboard id information.

    Buffer - Supplies a pointer to a buffer where to put the ascii.

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CM_KEYBOARD_DEVICE_DATA far *KeyboardData;
    USHORT z, Length;

    //
    // Set up Keyboard COntroller component
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                 sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = KeyboardController;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

#if !defined(_GAMBIT_)
    ControlData.NumberPortEntries = 2;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
#if defined(NEC_98)
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x41;
#else // PC98
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x60;
#endif // PC98
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
#if defined(NEC_98)
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x43;
#else // PC98
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x64;
#endif // PC98
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    ControlData.DescriptorList[z].u.Interrupt.Level = 1;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 1;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {

        //
        // For EISA the LevelTriggered is temporarily set to FALSE.
        //

        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }
#endif // _GAMBIT_

    Controller->ConfigurationData =
                        HwSetUpResourceDescriptor(Component,
                                                  NULL,
                                                  &ControlData,
                                                  0,
                                                  NULL
                                                  );

    //
    // Set up Keyboard peripheral component
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = KeyboardPeripheral;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = (FPVOID)NULL;
    Length = strlen(KeyboardIdentifier[KeyboardId]) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = HwAllocateHeap(Length, FALSE);
    _fstrcpy(Component->Identifier, KeyboardIdentifier[KeyboardId]);

    if (KeyboardId != UNKNOWN_KEYBOARD) {

        Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                 sizeof(CM_KEYBOARD_DEVICE_DATA);
        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                    Length,
                                    TRUE);
        CurrentEntry->ConfigurationData = DescriptorList;
        Component->ConfigurationDataLength = Length;
        DescriptorList->Count = 1;
        DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
        DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                    sizeof(CM_KEYBOARD_DEVICE_DATA);
        KeyboardData = (CM_KEYBOARD_DEVICE_DATA far *)(DescriptorList + 1);
#if defined(_GAMBIT_)
        KeyboardData->KeyboardFlags = 0;
#else
        KeyboardData->KeyboardFlags = GetKeyboardFlags();
#endif
        KeyboardData->Type = KeyboardType[KeyboardId];
        KeyboardData->Subtype = KeyboardSubtype[KeyboardId];
    }

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;
    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}
#if defined(NEC_98)
ULONG
KbdGetBytePolled(
    OUT PUCHAR Byte
    )

/*++
--*/

{
    ULONG i;
    UCHAR response;
    UCHAR desiredMask;

    i = 0;
    desiredMask = (UCHAR)PC98_8251_DATA_READY;

    IoDelay(34); // 20 micro second

    //
    // Poll until we get back a controller status value that indicates
    // the output buffer is full.  If we want to read a byte from the mouse,
    // further ensure that the auxiliary device output buffer full bit is
    // set.
    //

    while ((i < POLLING_ITERATION ) &&
           ((UCHAR)((response = READ_PORT_UCHAR((PUCHAR)KBD_COMMAND_STATUS_PORT))
            & desiredMask) != desiredMask)) {

        IoDelay(83); // 50 micro second
        i += 1;

    }
    if (i >= (ULONG)POLLING_ITERATION) {
        return(STATUS_IO_TIMEOUT);
    }

    IoDelay(34); // 20 micro second

    //
    // Grab the byte from the hardware, and return success.
    //

    *Byte = READ_PORT_UCHAR((PUCHAR)KBD_DATA_PORT);

    return(STATUS_SUCCESS);
}

ULONG
NEC98_KeyboardCommandByte(
    IN UCHAR KeyboardCommand
    )

/*++

Routine Description:

    This routine is command out routine for NEC_98 Keyboard controller

Arguments:

    KeyboardCommand - A command sent to keyboard.

Return Value:

    None.

--*/

{
    ULONG i,j;
    ULONG Status;

    WRITE_PORT_UCHAR( (PUCHAR)KBD_COMMAND_STATUS_PORT, (UCHAR)0x37 );

    IoDelay(17); // 10 micro second

    WRITE_PORT_UCHAR( (PUCHAR)KBD_DATA_PORT, (UCHAR)KeyboardCommand );

    IoDelay(75); // 45 micro second

    Status = STATUS_SUCCESS;
    for (j = 0; j < RESEND_ITERATION; j++) {

        //
        // Make sure the Input Buffer Full controller status bit is clear.
        // Time out if necessary.
        //

        i = 0;
        while ((i++ < POLLING_ITERATION) &&
               (READ_PORT_UCHAR((PUCHAR)KBD_COMMAND_STATUS_PORT)
                & PC98_8251_BUFFER_EMPTY) != PC98_8251_BUFFER_EMPTY) {

                IoDelay(83); // 50 micro second
        }
        if (i >= POLLING_ITERATION) {
            Status = STATUS_IO_TIMEOUT;
            break;
        }
    }

    WRITE_PORT_UCHAR( (PUCHAR)KBD_COMMAND_STATUS_PORT, (UCHAR)0x16 );

    IoDelay(167); // 100 micro second

    return(Status);
}

ULONG
KbdPutBytePolled(
    IN UCHAR Byte
    )

/*++

Routine Description:

    This routine sends a command or data byte to the controller or keyboard
    or mouse, in polling mode.  It waits for acknowledgment and resends
    the command/data if necessary.

Arguments:

    Byte - The byte to send to the hardware.

Return Value:

    STATUS_IO_TIMEOUT - The hardware was not ready for input or did not
    respond.

    STATUS_SUCCESS - The byte was successfully sent to the hardware.

--*/

{
    ULONG i,j;
    UCHAR response;
    ULONG status;
    BOOLEAN keepTrying;
    UCHAR byte, d;

    for (j=0;j < RESEND_ITERATION;j++) {

        //
        // Drain the i8042 output buffer to get rid of stale data.
        //

        while (d = READ_PORT_UCHAR((PUCHAR)KBD_COMMAND_STATUS_PORT) &
               PC98_8251_DATA_READY) {
            //
            // Eat the output buffer byte.
            //

            byte = READ_PORT_UCHAR((PUCHAR)KBD_DATA_PORT);
        }
        //
        // Send the byte to the appropriate (command/data) hardware register.
        //

        status = NEC98_KeyboardCommandByte( Byte );

        if (status != STATUS_SUCCESS){
            return(status);
        }

        //
        // Wait for an ACK back from the controller.  If we get an ACK,
        // the operation was successful.  If we get a RESEND, break out to
        // the for loop and try the operation again.  Ignore anything other
        // than ACK or RESEND.
        //

        keepTrying = FALSE;
        while ((status = KbdGetBytePolled(&response)) == STATUS_SUCCESS) {

            if (response == ACKNOWLEDGE) {
                break;
            } else if (response == RESEND) {
                keepTrying = TRUE;
                break;
            }

           //
           // Ignore any other response, and keep trying.
           //

        }

        if (!keepTrying)
            break;
    }
    //
    // Check to see if the number of allowable retries was exceeded.
    //

    if (j >= RESEND_ITERATION) {
        status = STATUS_IO_TIMEOUT;
    }

    return(status);
}

ULONG
GetKeyboard2ndIDNEC98(
    VOID
    )

/*++

Routine Description:

    This routine detects keyboard hardware for NEC_98.

Arguments:

Return Value:

    keyboard type(see i8042prt.h)

--*/

{
    UCHAR   IDStatus = 0;
    ULONG   KeyboardType;
    UCHAR   temp;

    KeyboardType = PC98_106KEY;  // default keyboard type.

    //
    // mask keyboard interrupt.
    //
    _asm{ cli }
    temp = READ_PORT_UCHAR((PUCHAR)PIC1_PORT1);
    WRITE_PORT_UCHAR((PUCHAR)PIC1_PORT1,(temp | 0x02));
    _asm{ sti }

    if (KbdPutBytePolled( (UCHAR)READ_KEYBOARD_2ND_ID) == STATUS_SUCCESS) {

        while( KbdGetBytePolled( &IDStatus ) != STATUS_SUCCESS);

        switch(IDStatus){
            case  PC98_KEYBOARD_ID_FIRST_BYTE:
                while ( KbdGetBytePolled( &IDStatus ) != STATUS_SUCCESS);

                switch(IDStatus){
                     case PC98_KEYBOARD_ID_2ND_BYTE_N106:
                         KeyboardType = PC98_N106KEY;
                         break;
                     case PC98_KEYBOARD_ID_2ND_BYTE_Win95:
                     default:
                         break;
                }
                break;
            default:
                break;
        }
    }

    //
    // unmask keyboard interrupt.
    //
    WRITE_PORT_UCHAR((PUCHAR)PIC1_PORT1,temp);

    return KeyboardType;
}
#endif // defined(NEC_98)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\hwpci.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    hwpcia.c

Abstract:

	Calls the PCI rom function to determine what type of PCI
        support is present, if any.

Author:

    Allen Kay	(akay)	15-Aug-97

--*/



BOOLEAN
HwGetPciSystemData(
    PPCI_SYSTEM_DATA PciSystemData,
    BOOLEAN BiosDateFound
    )

/*++
  
Routine Description:
  
    This function retrieves the PCI System Data
  
Arguments:
  
    PciSystemData - Supplies a pointer to the structure which will
                    receive the PCI System Data.
  
Return Value:
  
    True - PCI System Detected and System Data valid
    False - PCI System Not Detected
  
--*/

{
    IA32_BIOS_REGISTER_STATE IA32RegisterState;
    BIT32_AND_BIT16 IA32Register, Eax, Edx;
    ULONG NoBuses;

    if (BiosDateFound == 1) {
        IA32Register.LowPart16 = PCI_BIOS_PRESENT
        IA32Register.HighPart16 = 0;
        IA32RegisterState.eax = IA32Register.Part32;

        SAL_PROC(0x1a,&IA32RegisterState,0,0,0,0,0,0);

        //
        // First get all the needed registers.
        //
        Eax.Part32 = IA32RegisterState.Eax;
        Ebx.Part32 = IA32RegisterState.Ebx;
        Ecx.Part32 = IA32RegisterState.Ecx;
        Edx.Part32 = IA32RegisterState.Edx;

        if ( ( IA32RegisterState.Eflags & CARRY_FLAG ) == 0) &&
            Eax.Byte1 == 0 &&
            Edx.Byte0 == 'P' &&
            Edx.Byte1 == 'C' &&
            Edx.Byte2 == 'I' ) {

            //
            // Found PCI BIOS Version > 1.0
            //
            // The only thing left to do is squirrel the data away
            //
            PciSystemData->MajorRevision = Ebx.Byte1;
            PciSystemData->MinorRevision = Ebx.Byte0;

            PciSystemData->NoBuses = Ecx.Byte0 + 1;  // LastBus + 1
            PciSystemData->HwMechanism = Eax.Byte0;
        } else {
            //
            // Look for BIOS Version 1.0.  this has a different function #
            //

            IA32Register.LowPart16 = PCI10_BIOS_PRESENT
            IA32Register.HighPart16 = 0;
            IA32RegisterState.eax = IA32Register.Part32;

            SAL_PROC(0x1a,&IA32RegisterState,0,0,0,0,0,0);

            //
            // Version 1.0 has "PCI " in dx and cx, the Version number in ax,
            // and the carry flag cleared.  These are all the indications
            // available.
            //

            //
            // First get all the needed registers.
            //
            Eax.Part32 = IA32RegisterState.Eax;
            Ebx.Part32 = IA32RegisterState.Ebx;
            Ecx.Part32 = IA32RegisterState.Ecx;
            Edx.Part32 = IA32RegisterState.Edx;

            if (Edx.Byte0 == 'P' &&
                Edx.Byte1 == 'C' &&
                Ecx.Byte0 == 'I') {
                //
                // Found PCI BIOS Version 1.0
                //
                // The only thing left to do is squirrel the data away for
                // the caller.
                //
                PciSystemData->MajorRevision = Eax.Byte1;
                PciSystemData->MinorRevision = Eax.Byte0;

                //
                // The Version 1.0 BIOS is only early HW that couldn't
                // support multifunction  devices or multiple bus's.  So
                // without reading any device data, mark it as such.
                //
                PciSystemData->HwMechanism = 2;
                PciSystemData->NoBuses = 1;
            } else {
                //
                // PCI device not found.
                //
                return(FALSE);
            }               
        }
    } else {
        //
        // PCI device not found.
        //
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\pnpbios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosp.h

Abstract:

    PnP BIOS/ISA  sepc related definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, far *FPPNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, far *FPPNP_BIOS_INSTALLATION_CHECK;

//
// PnP BIOS ROM definitions
//

#define PNP_BIOS_START            0xF0000
#define PNP_BIOS_END              0xFFFFF
#define PNP_BIOS_HEADER_INCREMENT 16

//
// PnP BIOS API function codes
//

#define PNP_BIOS_GET_NUMBER_DEVICE_NODES 0
#define PNP_BIOS_GET_DEVICE_NODE 1
#define PNP_BIOS_SET_DEVICE_NODE 2
#define PNP_BIOS_GET_EVENT 3
#define PNP_BIOS_SEND_MESSAGE 4
#define PNP_BIOS_GET_DOCK_INFORMATION 5
// Function 6 is reserved.
#define PNP_BIOS_SELECT_BOOT_DEVICE 7
#define PNP_BIOS_GET_BOOT_DEVICE 8
#define PNP_BIOS_SET_OLD_ISA_RESOURCES 9
#define PNP_BIOS_GET_OLD_ISA_RESOURCES 0xA
#define PNP_BIOS_GET_ISA_CONFIGURATION 0x40

typedef USHORT ( far * ENTRY_POINT) (int Function, ...);

//
// Control Flags for Get_Device_Node
//

#define GET_CURRENT_CONFIGURATION 1
#define GET_NEXT_BOOT_CONFIGURATION 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 hardware detection.


Author

      Shie-Lin Tzong (shielint) Feb-15-1992

*/

#include "basetsd.h"

#if defined(_IA64_)
#define far
#define _far
#define _fstrcat strcat
#define _fstrcpy strcpy
#define _fstrstr strstr
#define _fmemcpy memcpy
#define _fmemset memset
#endif

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const

//
// Alpha firmware type referred to in arc.h, not needed here
//

#define POINTER_32
#define FIRMWARE_PTR POINTER_32

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// Large (64-bit) integer types and operations
//

#if defined(_IA64_)
typedef unsigned __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
typedef struct _FLOAT128 {
    __int64 Low;
    __int64 High;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;

typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef ULONGLONG KAFFINITY;

#else
typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif _IA64_

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\videoc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hwdata.c

Abstract:

    This module contains the C code to translate Video type to an
    ascii string.

Author:

    Shie-Lin Tzong (shielint) 6-Jan-1991

Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

//
// Video adaptor type identifiers.
//

PUCHAR VideoIdentifier[] = {
    "UNKNOWN",
#if defined(NEC_98)
    "PC-98"
#else // PC98
    "VGA",
    "COMPAQ AVGA",
    "COMPAQ QVIS",
    "8514",
    "GENOA VGA",
    "VIDEO7 VGA",
    "TRIDENT VGA",
    "PARADISE VGA",           // should be removed
    "ATI VGA",
    "TSENGLAB VGA",
    "CIRRUS VGA",
    "DELL DGX",
    "S3 VGA",
    "NCR 77C22",
    "WD90C",
    "XGA"
#endif // PC98
    };

#if defined(NEC_98)
PUCHAR PC98Specific[] = {
    " N_MODE"
    };
#else // PC98
//
// 8514 Monitor type
//

PUCHAR x8514Specific[] = {
    " MONITOR UNKNOWN",
    " VGA MONITOR",
    " 8503 MONO",
    " 8514 GAD"
    };

//
// NCR 77C22 specific vga
//

PUCHAR NcrSpecific[] = {
    "",
    "E"
    };

//
// Western Digital 90Cxx specific vga
//

PUCHAR WdSpecific[] = {
    "",
    "00",
    "30",
    "31"
    };

//
// Video 7 specific vga
//

PUCHAR Video7Specific[] = {
    "",
    " VRAM",
    " DRAM"
    };

//
// Trident vga specific
//

PUCHAR TridentSpecific[] = {
    "",
    " 9100"
    };

//
// Paradize specific vga
//

PUCHAR ParadiseSpecific[] = {
    "",
    " PROM",
    " CHIP 1F"
    };

//
// Ati specific vga
//

PUCHAR AtiSpecific[] = {
    "",
    " WONDDER3"
    };

//
// Tsenglab specific vga
//

PUCHAR TsenglabSpecific[] = {
    " ET3000",
    " ET4000"
    };

//
// Cirrus Logic specific
//

PUCHAR CirrusSpecific[] = {
    "",
    " 610-620 REVC",
    " 5420r0",
    " 5420r1",
    " 5428",
    " 542x"
    };
#endif // PC98

FPFWCONFIGURATION_COMPONENT_DATA
SetVideoConfigurationData (
    IN ULONG VideoType
    )

/*++

Routine Description:

    This routine maps VideoType information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    VideoType - Supplies a ULONG which describes the video type information.

        Display type definitions.
          bit 0     0 - color; 1 - mono
          bit 1-7   Reserved
          bit 8-15  Adapter specific information.
          BIT 16-31 Defines video adapter type

Returns:

    None.

--*/
{
    USHORT MajorType;
    USHORT SpecificType;
    USHORT MonitorType;
    FPFWCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    UCHAR TypeString[40];
    USHORT Length;

    //
    // Allocate configuration component space and initialize it.
    //

    Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                 sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = DisplayController;
    Component->Flags.ConsoleOut = 1;
    Component->Flags.Output = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Identifier string
    //

#if defined(NEC_98)
    MajorType = (USHORT)((VideoType >> 16) & 1);
    SpecificType = (USHORT)((VideoType >> 20) & 1);
#else // PC98
    MajorType = (USHORT)(VideoType >> 16);
    SpecificType = (USHORT)((VideoType & 0xffff) >> 8);
#endif // PC98
    MonitorType = (USHORT)(VideoType & 1);
    strcpy(TypeString, VideoIdentifier[MajorType]);
#if defined(NEC_98)
    strcat(TypeString, PC98Specific[SpecificType]);
#else // PC98
    switch (MajorType){
    case 6:                                 // Video 7
        strcat(TypeString, Video7Specific[SpecificType]);
        break;

    case 7:                                 // Trident
        strcat(TypeString, TridentSpecific[SpecificType]);
        break;

    case 8:                                 // Paradise
        strcat(TypeString, ParadiseSpecific[SpecificType]);
        break;

    case 9:                                 // ATI
        strcat(TypeString, AtiSpecific[SpecificType]);
        break;

    case 10:                                // TsengLab
        strcat(TypeString, TsenglabSpecific[SpecificType]);
        break;

    case 11:                                // Cirrus
        strcat(TypeString, CirrusSpecific[SpecificType]);
        break;

    case 14:                                // NCR
        strcat(TypeString, NcrSpecific[SpecificType]);
        break;

    case 15:                                // NCR
        strcat(TypeString, WdSpecific[SpecificType]);
        break;

    default:
        break;
    }
#endif // PC98

    //
    // Set up Identifier string for controller
    //

    Length = strlen(TypeString) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = (FPUCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(Component->Identifier, TypeString);
    Controller->ConfigurationData = NULL;
    Component->ConfigurationDataLength = 0;

    //
    // Set Up monitor peripheral
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = MonitorPeripheral;
    Component->Flags.ConsoleOut = 1;
    Component->Flags.Output = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = NULL;

    //
    // If major type is 8514 we need to further supply monitor information
    //

#if defined(NEC_98)
    if (MonitorType == 0) {
        strcpy(TypeString, "COLOR MONITOR");
    } else {
        strcpy(TypeString, "MONO MONITOR");
    }
#else // PC98
    if (MajorType == 4) {                   // 8514
        strcpy(TypeString, x8514Specific[SpecificType]);
    } else if (MonitorType == 0) {
        strcpy(TypeString, "COLOR MONITOR");
    } else {
        strcpy(TypeString, "MONO MONITOR");
    }
#endif // PC98

    //
    // Set up Identifier string for monitor peripheral.
    //

    Length = strlen(TypeString) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = (FPUCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(Component->Identifier, TypeString);

    //
    // Make monitor component be the child of video controller component
    //

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;

    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpidtct.c

Abstract:

    This module peruses the ACPI tables looking for specific
    entries.

Author:

    Matt Holle (matth)  (shamefully stolen from jakeo's x86 code)

Environment:


Revision History:
    

--*/
#include "stdlib.h"
#include "string.h"
#include "bldr.h"
#include "acpitabl.h"

extern PVOID AcpiTable;

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found
    
Note:

    This function is not capable of returning a pointer to
    a table with a signature of DSDT.  But that's never necessary
    in the loader.  If the loader ever incorporates an AML
    interpreter, this will have to be enhanced.    

--*/

{
    ULONG Signature;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    PXSDT xsdt = NULL;
    PRSDP rsdp = (PRSDP)AcpiTable;

    char buffer[20] = {0};
    //DbgPrint("Hunting for table %s\n", TableName);

    //
    // Sanity Check.
    //
    
    if (rsdp) {
        
        //DbgPrint("Looking through 2.0 RSDP: %p\n", rsdp20);
        xsdt = (PVOID)rsdp->XsdtAddress.QuadPart;
        if (xsdt->Header.Signature != XSDT_SIGNATURE) {
            
            //
            // Found ACPI 2.0 tables, but the signature
            // is garbage.
            //

            return NULL;
        }
    
    } else {
        
        //
        // Didn't find any tables at all.
        //

        return NULL;
    }

    
    Signature = *((ULONG UNALIGNED *)TableName);

    //
    // If they want the root table, we've already got that.
    //
    if (Signature == XSDT_SIGNATURE) {

        return(&xsdt->Header);

    } else {

        TableCount = NumTableEntriesFromXSDTPointer(xsdt);

        //DbgPrint("xSDT contains %d tables\n", TableCount);

        //
        // Sanity check.
        //
        if( TableCount > 0x100 ) {
            return(NULL);
        }

        //
        // Dig.
        //
        for (i=0;i<TableCount;i++) {

            Header = (PDESCRIPTION_HEADER)(xsdt->Tables[i].QuadPart);

            if (Header->Signature == Signature) {

                //DbgPrint("Table Address: %p\n", Header);
                return(Header);
            }
        }
    }

    //DbgPrint("Table not found\n");
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\detect\ia64\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif


#if (_MSC_VER <= 600)
#define __cdecl _cdecl
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* function prototypes */

void * _memccpy(void *, const void *, int, unsigned int);
void * memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
int _memicmp(const void *, const void *, unsigned int);
void * memcpy(void *, const void *, size_t);
void * memmove(void *, const void *, size_t);
void * memset(void *, int, size_t);
void _far * _far _fmemset(void _far *, int, size_t);
void _far * _far _fmemcpy(void _far *, const void _far *, size_t);
char * strcat(char *, const char *);
char * strchr(const char *, int);
int strcmp(const char *, const char *);
int _strcmpi(const char *, const char *);
int strcoll(const char *, const char *);
int _stricmp(const char *, const char *);
char * strcpy(char *, const char *);
char _far * _far _fstrcpy(char _far *, const char _far *);
size_t strcspn(const char *, const char *);
char * _strdup(const char *);
char * _strerror(const char *);
char * strerror(int);
size_t strlen(const char *);
char * _strlwr(char *);
char * strncat(char *, const char *, size_t);
char _far * _far _fstrcat(char _far *, const char _far *);
int strncmp(const char *, const char *, size_t);
int _strnicmp(const char *, const char *, size_t);
char * strncpy(char *, const char *, size_t);
char * _strnset(char *, int, size_t);
char * strpbrk(const char *, const char *);
char * strrchr(const char *, int);
char * _strrev(char *);
char * _strset(char *, int);
size_t strspn(const char *, const char *);
char * strstr(const char *, const char *);
char _far * _far _fstrstr(const char _far *, const char _far *);
char * strtok(char *, const char *);
char * _strupr(char *);
size_t strxfrm (char *, const char *, size_t);
char * itoa(int, char *, int);
char * ultoa(unsigned long, char *, int);

#if !__STDC__
/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup   _strdup
#define strlwr   _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev   _strrev
#define strset   _strset
#define strupr   _strupr
#endif

#ifdef __cplusplus
}
#endif

#define _INC_STRING
#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\biosdrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.c

Abstract:

    Provides the ARC emulation routines for I/O to a device supported by
    real-mode INT 13h BIOS calls.

Author:

    John Vert (jvert) 7-Aug-1991

Revision History:

    Allen Kay (akay)  19-May-1999

--*/

#include "arccodes.h"
#include "stdlib.h"
#include "string.h"

#if defined(_IA64_)
#include "bootia64.h"
#endif

#if defined(_X86_)
#include "bootx86.h"
#endif

#include "bootefi.h"
#include "biosdrv.h"

#include "efi.h"
#include "efip.h"
#include "flop.h"

//
// Externals
//

extern VOID FlipToVirtual();
extern VOID FlipToPhysical();
extern ULONGLONG CompareGuid();

extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern EFI_GUID EfiDiskIoProtocol;
extern EFI_GUID EfiLoadedImageProtocol;
extern EFI_GUID EfiFilesystemProtocol;

extern
ULONG GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif


//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// define for FloppyOpenMode
//
#define FloppyOpenMode 0xCDEFABCD

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    );

VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    );

#define DEVICE_NOT_FOUND    0xFEEBEE

#ifdef FORCE_CD_BOOT

EFI_HANDLE
GetCdTest(
    VOID
    );

#endif

ULONG
FindAtapiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG PrimarySecondary,
    ULONG SlaveMaster,
    ULONG Lun
    );

ULONG
FindScsiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG Pun,
    ULONG Lun
    );

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
PUCHAR LocalBuffer=NULL;

//
// There are two sorts of things we can open in this module, disk partitions,
// and raw disk devices.  The following device entry tables are
// used for these things.
//

BL_DEVICE_ENTRY_TABLE BiosPartitionEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosPartitionClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosPartitionOpen,
        (PARC_READ_ROUTINE)BiosPartitionRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosPartitionWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosPartitionGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };

BL_DEVICE_ENTRY_TABLE BiosDiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosDiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };

BL_DEVICE_ENTRY_TABLE BiosEDDSEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosElToritoDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };


ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(BiosDiskClose((ULONG)BlFileTable[FileId].u.PartitionContext.DiskId));
}


#define STR_PREFIX
#define DBG_PRINT(x)


ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the disk partition specified by OpenPath.  This routine will open
    floppy drives 0 and 1, and any partition on hard drive 0 or 1.

Arguments:

    OpenPath - Supplies a pointer to the name of the partition.  If OpenPath
               is "A:" or "B:" the corresponding floppy drive will be opened.
               If it is "C:" or above, this routine will find the corresponding
               partition on hard drive 0 or 1 and open it.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    ULONG DiskFileId;
    UCHAR PartitionNumber;
    ULONG Controller;
    ULONG Key;
    BOOLEAN IsEisa = FALSE;

    //
    // BIOS devices are always "multi(0)" (except for EISA flakiness
    // where we treat "eisa(0)..." like "multi(0)..." in floppy cases.
    //
    if(FwGetPathMnemonicKey(OpenPath,"multi",&Key)) {

        if(FwGetPathMnemonicKey(OpenPath,"eisa", &Key)) {
            return(EBADF);
        } else {
            IsEisa = TRUE;
        }
    }

    if (Key!=0) {
        return(EBADF);
    }

    //
    // If we're opening a floppy drive, there are no partitions
    // so we can just return the physical device.
    //

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 0, FloppyOpenMode, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 1, FloppyOpenMode, FileId));
    }

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)" ) == 0))
    {
         return(BiosDiskOpen( 0, FloppyOpenMode, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)" ) == 0))
    {
        return(BiosDiskOpen( 1, FloppyOpenMode, FileId));
    }

    //
    // We can't handle eisa(0) cases for hard disks.
    //
    if(IsEisa) {
        return(EBADF);
    }

    //
    // We can only deal with disk controller 0
    //

    if (FwGetPathMnemonicKey(OpenPath,"disk",&Controller)) {
        return(EBADF);
    }
    if ( Controller!=0 ) {
        return(EBADF);
    }

    if (!FwGetPathMnemonicKey(OpenPath,"cdrom",&Key)) {
        //
        // Now we have a CD-ROM disk number, so we open that for raw access.
        // Use a special bit to indicate CD-ROM, because otherwise
        // the BiosDiskOpen routine thinks a third or greater disk is
        // a CD-ROM.
        //
        return(BiosDiskOpen( Key | 0x80000000, 0, FileId ) );
    }

    if (FwGetPathMnemonicKey(OpenPath,"rdisk",&Key)) {
        return(EBADF);
    }

    //
    // Now we have a disk number, so we open that for raw access.
    // We need to add 0x80 to translate it to a BIOS number.
    //

    Status = BiosDiskOpen( Key,
                           0,
                           &DiskFileId );

    if (Status != ESUCCESS) {
        DBG_PRINT(STR_PREFIX"BiosDiskOpen Failed\r\n");

        return(Status);
    }

    //
    // Find the partition number to open
    //

    if (FwGetPathMnemonicKey(OpenPath,"partition",&Key)) {
        BiosPartitionClose(DiskFileId);
        return(EBADF);
    }

    //
    // If the partition number was 0, then we are opening the device
    // for raw access, so we are already done.
    //
    if (Key == 0) {
        *FileId = DiskFileId;
        return(ESUCCESS);
    }

    //
    // Before we open the partition, we need to find an available
    // file descriptor.
    //

    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable=&BiosPartitionEntryTable;


    //
    // Convert to zero-based partition number
    //
    PartitionNumber = (UCHAR)(Key - 1);

    DBG_PRINT(STR_PREFIX"Trying HardDiskPartitionOpen(...)\r\n");

    //
    // Try to open the MBR partition
    //
    Status = HardDiskPartitionOpen( *FileId,
                                   DiskFileId,
                                   PartitionNumber);


#ifdef EFI_PARTITION_SUPPORT

    if (Status != ESUCCESS) {
        //
        // Try to open the GPT partition
        //
        DBG_PRINT(STR_PREFIX"Trying BlOpenGPTDiskPartition(...)\r\n");

        Status = BlOpenGPTDiskPartition(*FileId,
                                    DiskFileId,
                                    PartitionNumber);
    }

#endif

    return Status;
}


ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count -  Returns actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;

    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                (ULONGLONG)SECTOR_SIZE * BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          Buffer,
                                                          Length,
                                                          Count );

    BlFileTable[FileId].Position.QuadPart += *Count;

    return(Status);
}



ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
            BlPrint(TEXT("SeekMode %lx not supported\r\n"),SeekMode);
            return(EACCES);

    }
    return(ESUCCESS);

}



ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count -  Returns actual bytes written.

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;

    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                   (ULONGLONG)SECTOR_SIZE * BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Write)(DiskId,
                                                           Buffer,
                                                           Length,
                                                           Count );

    if(Status == ESUCCESS) {
        BlFileTable[FileId].Position.QuadPart += *Count;
    }

    return(Status);
}



ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Attempts to open either the console input or output

Arguments:

    OpenPath - Supplies a pointer to the name of the device to open.  If
               this is either CONSOLE_INPUT_NAME or CONSOLE_OUTPUT_NAME,
               a file descriptor is allocated and filled in.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only (CONSOLE_INPUT_NAME)
                1 - Write Only (CONSOLE_OUTPUT_NAME)

    FileId - Returns the file descriptor for use with the Close, Read and
             Write routines

Return Value:

    ESUCCESS - Console successfully opened.

--*/

{
    if (_stricmp(OpenPath, CONSOLE_INPUT_NAME)==0) {

        //
        // Open the keyboard for input
        //

        if (OpenMode != ArcOpenReadOnly) {
            return(EACCES);
        }

        *FileId = ARC_CONSOLE_INPUT;

        return(ESUCCESS);
    }

    if (_stricmp(OpenPath, CONSOLE_OUTPUT_NAME)==0) {

        //
        // Open the display for output
        //

        if (OpenMode != ArcOpenWriteOnly) {
            return(EACCES);
        }
        *FileId = ARC_CONSOLE_OUTPUT;

        return(ESUCCESS);
    }

    return(ENOENT);

}

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine determines if there is a keypress pending

Arguments:

    FileId - Supplies the FileId to be read.  (should always be 0 for this
            function)

Return Value:

    ESUCCESS - There is a key pending

    EAGAIN - There is not a key pending

--*/

{
    ULONG Key;

    //
    // If we have buffered input...
    //
    if (KeyBufferEnd != KeyBufferStart) {
        return(ESUCCESS);
    }

    //
    // Check for a key
    //
    Key = GET_KEY();
    if (Key != 0) {
        //
        // We got a key, so we have to stick it back into our buffer
        // and return ESUCCESS.
        //
        BiosConsoleFillBuffer(Key);
        return(ESUCCESS);

    } else {
        //
        // no key pending
        //
        return(EAGAIN);
    }

}

ARC_STATUS
BiosConsoleRead(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Gets input from the keyboard.

Arguments:

    FileId - Supplies the FileId to be read (should always be 0 for this
             function)

    Buffer - Returns the keyboard input.

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes read

Return Value:

    ESUCCESS - Keyboard read completed succesfully.

--*/

{
    ULONG Key;

    *Count = 0;

    while (*Count < Length) {
        if (KeyBufferEnd == KeyBufferStart) { // then buffer is presently empty
            do {

                //
                // Poll the keyboard until input is available
                //
                Key = GET_KEY();
            } while ( Key==0 );

            BiosConsoleFillBuffer(Key);
        }

        Buffer[*Count] = KeyBuffer[KeyBufferStart];
        KeyBufferStart = (KeyBufferStart+1) % KEY_INPUT_BUFFER_SIZE;

        *Count = *Count + 1;
    }
    return(ESUCCESS);
}



VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    )

/*++

Routine Description:

    Places input from the keyboard into the keyboard buffer, expanding the
    special keys as appropriate.

    All keys translated here use the ARC translation table, as defined in the
    ARC specification, with one exception -- the BACKTAB_KEY, for which the
    ARC spec is lacking.  I have decided that BACKTAB_KEY is ESC+TAB.

Arguments:

    Key - Raw keypress value as returned by GET_KEY().

Return Value:

    none.

--*/

{
    switch(Key) {
        case UP_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DOWN_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case RIGHT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'C';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case LEFT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'D';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case INS_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = '@';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DEL_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F1_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F2_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'Q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F3_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'w';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F5_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 't';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F6_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'u';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F8_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'r';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F10_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'M';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case HOME_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'H';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case END_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'K';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case ESCAPE_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case BACKTAB_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = (UCHAR)(TAB_KEY & 0xFF);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        default:
            //
            // The ASCII code is the low byte of Key
            //
            KeyBuffer[KeyBufferEnd] = (UCHAR)(Key & 0xff);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
    }
}



ARC_STATUS
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PWCHAR String;
    ULONG Index;
    WCHAR a;
    PWCHAR p;
    ULONG y;

    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          String++,*Count = *Count+sizeof(WCHAR) ) {
        
        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= L'0') && (*String <= L'9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - L'0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case L';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case L'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        BlEfiClearToEndOfDisplay();
                        //TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        //TextClearDisplay();
                        BlEfiClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case L'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        //TextClearToEndOfLine();
                        BlEfiClearToEndOfDisplay();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        //TextClearFromStartOfLine();
                        BlEfiClearToEndOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        BlEfiGetCursorPosition( NULL, &y );
                        BlEfiPositionCursor( 0, y );
                        BlEfiClearToEndOfLine();
                        //TextClearFromStartOfLine();
                        //TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':                
                //TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                BlEfiPositionCursor( Parameter[1]-1, Parameter[0]-1 );                
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case L' ':
                FontSelection = TRUE;
                break;

            case L'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        // bugbug blink???
                        BlEfiSetAttribute( ATT_FG_WHITE );
                        //TextSetCurrentAttribute(7);
                        //
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        BlEfiSetAttribute( ATT_FG_INTENSE );
                        //TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        //bugbug no blink in EFI
                        //TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        BlEfiSetInverseMode( TRUE );
                        //TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    //bugbug EFI                    
#if 0
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;
#endif                    
                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:                        
                        TextCharOut(String);                        
                        break;
                }

            }
        }
    }
    return Status;
}


ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a BIOS-accessible disk for raw sector access.

Arguments:

    DriveId - Supplies the BIOS DriveId of the drive to open
              0 - Floppy 0
              1 - Floppy 1
              0x80 - Hard Drive 0
              0x81 - Hard Drive 1
              0x82 - Hard Drive 2
              etc

              High bit set and ID > 0x81 means the device is expected to be
              a CD-ROM drive.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    EFI_HANDLE DeviceHandle;
    PDRIVE_CONTEXT Context;
    BOOLEAN IsCd;

    DBGOUT((TEXT("BiosDiskOpen: enter, id = 0x%x\r\n"),DriveId));

    //
    // Check special drive number encoding for CD-ROM case
    //
    if(DriveId >= 0x80000000) {
        IsCd = TRUE;
        DriveId &= 0x7fffffff;
    } else {
        IsCd = FALSE;
    }

    if( OpenMode == FloppyOpenMode ) {

        //
        // Must be floppy.
        //
        DeviceHandle = GetFloppyDrive( DriveId );

        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            return EBADF;
        }

    } else {
    if( IsCd ) {

        //
        // For cd, we get the device we booted from.
        //
#ifndef FORCE_CD_BOOT
        DeviceHandle = GetCd();

        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            return EBADF;
        }

#else
        DeviceHandle = GetCdTest();

        if (DeviceHandle == (EFI_HANDLE)0)
          return EBADF;
#endif // for FORCE_CD_BOOT

    } else {

        //
        // For harddrive, we get the harddrive associated
        // with the passed-in rdisk (DriveId) value.
        //
        DeviceHandle = GetHardDrive( DriveId );
        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            DBGOUT((TEXT("GetHardDrive returns DEVICE_NOT_FOUND %x\r\n"),DriveId));
            return EBADF;
        }
    }
    }
    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGOUT((TEXT("BiosDiskOpen: no file table entry available\r\n")));
            DBGPAUSE
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;
    BlFileTable[*FileId].DeviceEntryTable = IsCd
                                          ? &BiosEDDSEntryTable
                                          : &BiosDiskEntryTable;


    Context = &(BlFileTable[*FileId].u.DriveContext);
    Context->DeviceHandle = (ULONGLONG) DeviceHandle;
    Context->xInt13 = TRUE;


    DBGOUT((TEXT("BiosDiskOpen: exit success\r\n")));

    return(ESUCCESS);
}

ARC_STATUS
BiospWritePartialSector(
    IN UCHAR Int13Unit,
    IN ULONGLONG Sector,
    IN PUCHAR Buffer,
    IN BOOLEAN IsHead,
    IN ULONG Bytes,
    IN UCHAR SectorsPerTrack,
    IN USHORT Heads,
    IN USHORT Cylinders,
    IN BOOLEAN AllowXInt13,
    IN ULONGLONG DeviceHandle
    )
{
    ARC_STATUS Status;

    //
    // Read sector into the write buffer
    //
    Status = ReadExtendedPhysicalSectors(
                DeviceHandle,
                Sector,
                1,
                LocalBuffer
                );

    if(Status != ESUCCESS) {
        return(Status);
    }

    //
    // Transfer the appropriate bytes from the user buffer to the write buffer
    //
    RtlMoveMemory(
        IsHead ? (LocalBuffer + Bytes) : LocalBuffer,
        Buffer,
        IsHead ? (SECTOR_SIZE - Bytes) : Bytes
        );

    //
    // Write the sector out
    //
    Status = WriteExtendedPhysicalSectors(
                DeviceHandle,
                Sector,
                1,
                LocalBuffer
                );
    return(Status);
}


ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open physical disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONGLONG DeviceHandle;
    UCHAR Int13Unit;
    ULONG HeadOffset,TailByteCount;
    UCHAR SectorsPerTrack;
    USHORT Heads,Cylinders;
    BOOLEAN AllowXInt13;
    ARC_STATUS Status;
    ULONG BytesLeftToTransfer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    PUCHAR UserBuffer;
    ULONG         PhysicalSectors;

    BytesLeftToTransfer = Length;
    PhysicalSectors = SECTOR_SIZE;

    if(!LocalBuffer) {
        LocalBuffer = BlAllocateHeap(SCRATCH_BUFFER_SIZE);
        if(!LocalBuffer) {
            Status = ENOMEM;
            goto BiosDiskWriteDone;
        }
    }

    HeadSector = BlFileTable[FileId].Position.QuadPart / PhysicalSectors;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % PhysicalSectors);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / PhysicalSectors;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % PhysicalSectors);

    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    DeviceHandle = BlFileTable[FileId].u.DriveContext.DeviceHandle;

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;

    UserBuffer = Buffer;

    //
    // Special case of transfer occuring entirely within one sector
    //
    CurrentSector = HeadSector;
    
    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {

        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        RtlMoveMemory(LocalBuffer+HeadOffset,Buffer,Length);

        Status = WriteExtendedPhysicalSectors(
                    DeviceHandle,
                    CurrentSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        BytesLeftToTransfer = 0;
        goto BiosDiskWriteDone;
    }

    if(HeadOffset) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    HeadSector,
                    Buffer,
                    TRUE,
                    HeadOffset,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13,
                    DeviceHandle
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= PhysicalSectors - HeadOffset;
        UserBuffer += PhysicalSectors - HeadOffset;
        CurrentSector += 1;
    }

    if(TailByteCount) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    TailSector,
                    (PUCHAR)Buffer + Length - TailByteCount,
                    FALSE,
                    TailByteCount,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13,
                    DeviceHandle
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG_PTR) UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now handle the middle part.  This is some number of whole sectors.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SECTOR_SIZE
        //
        // Because sectors per track is 1-63 we know this will fit in a UCHAR
        //
        if (AllowXInt13) {
            //
            // Ignore cylinders & heads & track information for XINT13 cases
            //
            SectorsToTransfer = (UCHAR)(BytesLeftToTransfer / PhysicalSectors);
        } else {
            SectorsToTransfer = (UCHAR)min(
                                        SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                        BytesLeftToTransfer / PhysicalSectors
                                        );
        }            
            
        //
        // Now we'll figure out where to transfer the data from.  If the
        // caller's buffer is under the 1 meg line, we can transfer the
        // data directly from the caller's buffer.  Otherwise we'll copy the
        // user's buffer to our local buffer and transfer from there.
        // In the latter case we can only transfer in chunks of
        // SCRATCH_BUFFER_SIZE because that's the size of the local buffer.
        //
        // Also make sure the transfer won't cross a 64k boundary.
        //
        if(Under1MegLine) {
            //
            // Check if the transfer would cross a 64k boundary.  If so,
            // use the local buffer.  Otherwise use the user's buffer.
            //
            if(((ULONG_PTR)UserBuffer & 0xffffffffffff0000) !=
              (((ULONG_PTR)UserBuffer + (SectorsToTransfer * PhysicalSectors) - 1) & 0xffffffffffff0000))
            {
                TransferBuffer = LocalBuffer;
                SectorsToTransfer = min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);

            } else {

                TransferBuffer = UserBuffer;
            }
        } else {
            TransferBuffer = LocalBuffer;
            SectorsToTransfer = min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);
        }

        if(TransferBuffer == LocalBuffer) {
            RtlMoveMemory(LocalBuffer,UserBuffer,SectorsToTransfer*PhysicalSectors);
        }

        Status = WriteExtendedPhysicalSectors(
                    DeviceHandle,
                    CurrentSector,
                    SectorsToTransfer,
                    TransferBuffer
                    );

        if(Status != ESUCCESS) {
            //
            // Tail part isn't contiguous with middle part
            //
            BytesLeftToTransfer += TailByteCount;
            return(Status);
        }

        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer * PhysicalSectors;
        UserBuffer += SectorsToTransfer * PhysicalSectors;
    }

    Status = ESUCCESS;

    BiosDiskWriteDone:

    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
pBiosDiskReadWorker(
    IN  ULONG   FileId,
    OUT PVOID   Buffer,
    IN  ULONG   Length,
    OUT PULONG  Count,
    IN  USHORT  SectorSize,
    IN  BOOLEAN xInt13
    )

/*++

Routine Description:

    Reads sectors directly from an open physical disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONG HeadOffset,TailByteCount;
    ULONG BytesLeftToTransfer;
    USHORT Heads,Cylinders;
    UCHAR SectorsPerTrack;
    UCHAR Int13Unit;
    ULONGLONG DeviceHandle;
    ARC_STATUS Status;
    PUCHAR UserBuffer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    BOOLEAN AllowXInt13;

    DBGOUT((TEXT("BiosDiskRead: enter; length=0x%lx, sector size=%u, xint13=%u\r\n"),Length,SectorSize,xInt13));

    BytesLeftToTransfer = Length;

    if(!LocalBuffer) {
        LocalBuffer = BlAllocateHeap(SCRATCH_BUFFER_SIZE);
        if(!LocalBuffer) {
            Status = ENOMEM;
            DBGOUT((TEXT("BiosDiskRead: out of memory\r\n")));
            goto BiosDiskReadDone;
        }
    }

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;
    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    DeviceHandle = BlFileTable[FileId].u.DriveContext.DeviceHandle;

    HeadSector = BlFileTable[FileId].Position.QuadPart / SectorSize;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % SectorSize);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / SectorSize;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % SectorSize);

    UserBuffer = Buffer;

    DBGOUT((
        TEXT("BiosDiskRead: unit 0x%x CHS=%lu %lu %lu\r\n"),
        Int13Unit,
        Cylinders,
        Heads,
        SectorsPerTrack
        ));

    DBGOUT((
        TEXT("BiosDiskRead: head=0x%lx%lx tail=0x%lx%lx\r\n"),
        (ULONG)(HeadSector >> 32),
        (ULONG)HeadSector,
        (ULONG)(TailSector >> 32),
        (ULONG)TailSector
        ));

    CurrentSector = HeadSector;
    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {
        //
        // Read contained entirely within one sector, and does not start or
        // end on the sector boundary.
        //
        DBGOUT((TEXT("BiosDiskRead: read entirely within one sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory(Buffer,LocalBuffer + HeadOffset,Length);
        BytesLeftToTransfer = 0;
        goto BiosDiskReadDone;
    }

    if(HeadOffset) {
        //
        // The leading part of the read is not aligned on a sector boundary.
        // Fetch the partial sector and transfer it into the caller's buffer.
        //
        DBGOUT((TEXT("BiosDiskRead: reading partial head sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory(Buffer,LocalBuffer + HeadOffset,SectorSize - HeadOffset);

        BytesLeftToTransfer -= SectorSize - HeadOffset;
        UserBuffer += SectorSize - HeadOffset;
        CurrentSector = HeadSector + 1;
    }

    if(TailByteCount) {
        //
        // The trailing part of the read is not a full sector.
        // Fetch the partial sector and transfer it into the caller's buffer.
        //
        DBGOUT((TEXT("BiosDiskRead: reading partial tail sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    TailSector,
                    1,
                    LocalBuffer,
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory( ((PUCHAR)Buffer+Length-TailByteCount), LocalBuffer, TailByteCount );
        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG_PTR) UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now BytesLeftToTransfer is an integral multiple of sector size.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SectorSize
        //
        //
        if(xInt13) {
            //
            // Arbitrary maximum sector count of 128. For a CD-ROM this is
            // 256K, which considering that the xfer buffer all has to be
            // under 1MB anyway, is pretty unlikely.
            //
            if((BytesLeftToTransfer / SectorSize) > 128) {
                SectorsToTransfer = 128;
            } else {
                SectorsToTransfer = (UCHAR)(BytesLeftToTransfer / SectorSize);
            }
        } else {
            //
            // Because sectors per track is 1-63 we know this will fit in a UCHAR.
            //
            SectorsToTransfer = (UCHAR)min(
                                        SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                        BytesLeftToTransfer / SectorSize
                                        );
        }

        if ((ULONG)(SectorSize * SectorsToTransfer) > Length) {
            TransferBuffer = LocalBuffer;
        } else {
            TransferBuffer = UserBuffer;
        }

        DBGOUT((
            TEXT("BiosDiskRead: reading 0x%x sectors @ 0x%lx%lx; buf=0x%lx\r\n"),
            SectorsToTransfer,
            (ULONG)(CurrentSector >> 32),
            (ULONG)CurrentSector,
            TransferBuffer
            ));

            Status = ReadExtendedPhysicalSectors(
                        DeviceHandle,
                        CurrentSector,
                        SectorsToTransfer,
                        TransferBuffer
                        );

        if(Status != ESUCCESS) {
            //
            // Trail part isn't contiguous
            //
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            BytesLeftToTransfer += TailByteCount;
            goto BiosDiskReadDone;
        }

        if(TransferBuffer == LocalBuffer) {
            RtlMoveMemory(UserBuffer,LocalBuffer,SectorsToTransfer * SectorSize);
        }
        UserBuffer += SectorsToTransfer * SectorSize;
        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer*SectorSize;
    }

    Status = ESUCCESS;
    DBGOUT((TEXT("BiosDiskRead: exit success\r\n")));

    BiosDiskReadDone:

    DBGPAUSE
    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
BiosDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    USHORT    PhysicalSectors;

    PhysicalSectors = SECTOR_SIZE;
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,PhysicalSectors,TRUE));
}


ARC_STATUS
BiosElToritoDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,2048,TRUE));
}


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
{
    //
    // THIS ROUTINE DOES NOT WORK FOR PARTITION 0.
    //

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;
    Finfo->StartingAddress.QuadPart = Finfo->StartingAddress.QuadPart << (CCHAR)Context->SectorShift;

    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;

    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    )
/*++

Routine Description:

    Gets the information about the disk.

Arguments:

    FileId - The file id to the disk for which information is needed

    FileInfo - Place holder for returning information about the disk

Return Value:

    ESUCCESS if successful, otherwise appropriate ARC error code.

--*/
{
    ARC_STATUS Status = EINVAL;

    if (FileInfo) {
        EFI_STATUS  EfiStatus;
        EFI_BLOCK_IO *EfiBlockIo = NULL;
        PDRIVE_CONTEXT  Context;
        
        Context = &BlFileTable[FileId].u.DriveContext;
        Status = EIO;

        FlipToPhysical();

        //
        // Get hold for the block IO protocol handle
        //
        EfiStatus = EfiBS->HandleProtocol((EFI_HANDLE)Context->DeviceHandle,
                            &EfiBlockIoProtocol,
                            &EfiBlockIo);

        FlipToVirtual();
        
        if (!EFI_ERROR(EfiStatus) && EfiBlockIo && EfiBlockIo->Media) {
            LONGLONG DiskSize = (EfiBlockIo->Media->BlockSize *
                                 EfiBlockIo->Media->LastBlock);

            if (DiskSize) {
                RtlZeroMemory(FileInfo, sizeof(FILE_INFORMATION));
                
                FileInfo->StartingAddress.QuadPart = 0;
                FileInfo->EndingAddress.QuadPart = DiskSize;
                FileInfo->CurrentPosition = BlFileTable[FileId].Position;
                
                //
                // NOTE : Anything less than 3MB is floppy drive
                //
                if ((DiskSize < 0x300000) && (EfiBlockIo->Media->RemovableMedia)) {
                    FileInfo->Type = FloppyDiskPeripheral;                            
                } else {
                    FileInfo->Type = DiskPeripheral;
                }

                Status = ESUCCESS;
            }
        }   
    }        

    return Status;
}


EFI_HANDLE
GetCd(
    )
{
    ULONG i;
    ULONGLONG DevicePathSize, SmallestPathSize;
    ULONG HandleCount;

    EFI_HANDLE *BlockIoHandles;

    EFI_HANDLE DeviceHandle = NULL;
    EFI_DEVICE_PATH *DevicePath, *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    EFI_STATUS Status;

    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        return(ReturnDeviceHandle);
    }

    FlipToPhysical();
    SmallestPathSize = 0;

    for (i = 0; i < HandleCount; i++) {
        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &DevicePath
                    );


        if (EFI_ERROR(Status)) {
            EfiST->ConOut->OutputString(EfiST->ConOut,
                                        L"GetCd: HandleProtocol failed\r\n");
            goto exit;
        }

        DevicePathSize = GetDevPathSize(DevicePath);

        EfiAlignDp(&TestPathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;


        //
        // In the cd case, just return the device we booted from.
        //
        while (TestPath->Type != END_DEVICE_PATH_TYPE) {
           if (TestPath->Type == MESSAGING_DEVICE_PATH) {
               if (TestPath->SubType == MSG_ATAPI_DP &&
                   BootContext.BusType == BootBusAtapi) {
                   //
                   // For ATAPI, match PrimarySecondary and SlaveMaster
                   // fields with the device we booted from.
                   //
                   AtapiDevicePath = (ATAPI_DEVICE_PATH *) TestPath;
                   BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContext.BootDevice);
                   if ( (AtapiDevicePath->PrimarySecondary == BootDeviceAtapi->PrimarySecondary) &&
                        (AtapiDevicePath->SlaveMaster == BootDeviceAtapi->SlaveMaster) &&
                        (AtapiDevicePath->Lun == BootDeviceAtapi->Lun) &&
                        ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               } else if (TestPath->SubType == MSG_SCSI_DP &&
                          BootContext.BusType == BootBusScsi) {
                   //
                   // For SCSI, match PUN and LUN fields with the
                   // device we booted from.
                   //
                   ScsiDevicePath = (SCSI_DEVICE_PATH *) TestPath;
                   BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContext.BootDevice);
                   if ((ScsiDevicePath->Pun == BootDeviceScsi->Pun) &&
                        (ScsiDevicePath->Lun == BootDeviceScsi->Lun) &&
                        ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               }
           } else if (TestPath->Type == HARDWARE_DEVICE_PATH) {
               if (TestPath->SubType == HW_VENDOR_DP &&
                   BootContext.BusType == BootBusVendor) {
                   UnknownDevicePath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath;
                   BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContext.BootDevice);

                   if ( (CompareGuid( &(UnknownDevicePath->DevicePath.Guid),
                                      &(BootDeviceUnknown->Guid)) == 0) &&
                        (UnknownDevicePath->LegacyDriveLetter ==
                         BootDeviceUnknown->LegacyDriveLetter) &&
                        ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               }
           }

           DevicePath = NextDevicePathNode(DevicePath);
           EfiAlignDp(&TestPathAligned,
                      DevicePath,
                      DevicePathNodeLength(DevicePath));

           TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#ifdef FORCE_CD_BOOT
    if (ReturnDeviceHandle == (EFI_HANDLE)DEVICE_NOT_FOUND) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"GetCD: LocateHandle failed\r\n");
        ReturnDeviceHandle = 0;
    }
#endif // for FORCE_CD_BOOT

    //
    // Change back to virtual mode.
    //
exit:
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    
    return ReturnDeviceHandle;
}

ULONG
BlGetDriveId(
    ULONG DriveType,
    PBOOT_DEVICE Device
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
	EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = DEVICE_NOT_FOUND;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    BOOLEAN DuplicateFound;
    ULONG DriveId;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for 
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONGLONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }
    
    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }


    // Save the number of cached Device Paths
    nCachedDevicePaths = i;
    ASSERT(nCachedDevicePaths = HandleCount);

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {



                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {
                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
					// removable media
                    //

						Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
						if(BlkIo->Media->RemovableMedia)
							nFoundDevice = DEVICE_NOT_FOUND;
						else
							nFoundDevice = 1;
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
					// Found a raw device
                     BlockIoHandlesBitmap[ i ] = i;

                     switch (DriveType) {
                         case BL_DISKTYPE_ATAPI:
                             if(  ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                                  ( TestPath->SubType == MSG_ATAPI_DP ) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary == 
                                      ((PBOOT_DEVICE_ATAPI)Device)->PrimarySecondary) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster ==
                                      ((PBOOT_DEVICE_ATAPI)Device)->SlaveMaster) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->Lun ==
                                      ((PBOOT_DEVICE_ATAPI)Device)->Lun) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }                                 
                             break;
                        case BL_DISKTYPE_SCSI:
                             if(  ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                                  ( TestPath->SubType == MSG_SCSI_DP ) &&
                                  ( ((SCSI_DEVICE_PATH *) TestPath)->Pun == 
                                      ((PBOOT_DEVICE_SCSI)Device)->Pun) &&
                                  ( ((SCSI_DEVICE_PATH *) TestPath)->Lun ==
                                      ((PBOOT_DEVICE_SCSI)Device)->Lun) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }
                             break;
                        case BL_DISKTYPE_UNKNOWN:
                             if(  ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                                  ( TestPath->SubType == HW_VENDOR_DP ) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }
                             break;
                         default:
                             break;
                     }

                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );
    
    return nDriveCount;
    //return nFoundDevice;           
    //return DriveId;
}


EFI_HANDLE
GetHardDrive(
    ULONG DriveId
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
	EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = DEVICE_NOT_FOUND;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    BOOLEAN DuplicateFound;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for 
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONGLONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {

                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {
                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
                    // removable media
                    //
                    Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(BlkIo->Media->RemovableMedia) { 
                        nFoundDevice = DEVICE_NOT_FOUND;
                    }
                    else {
                        nFoundDevice = 1;                            
                    }
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
					// Found a raw device
                    BlockIoHandlesBitmap[ i ] = i;
                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Count the bitmap and when we find
    // the DriveId, return the BlockIoHandle
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        if( BlockIoHandlesBitmap[i] != DEVICE_NOT_FOUND ) {
            if( nDriveCount++ == DriveId ) {
                ReturnDeviceHandle = BlockIoHandles[BlockIoHandlesBitmap[i]];
            }
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}

ULONG
FindAtapiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG PrimarySecondary,
     ULONG SlaveMaster,
    ULONG Lun
    )
{
    ULONG i = 0, nFoundDevice = 0;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    EFI_DEVICE_PATH *CurrentDevicePath;

    //
    // Find the Atapi raw device whose PrimarySecondary,
    // SlaveMaster and Lun are a match.
    //
    for( i=0; i<nDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) pDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( (TestPath->Type != END_DEVICE_PATH_TYPE) ) {

            if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                if( ( ((ATAPI_DEVICE_PATH *)TestPath)->PrimarySecondary == PrimarySecondary ) &&
                    ( ((ATAPI_DEVICE_PATH *)TestPath)->SlaveMaster == SlaveMaster ) &&
                    ( ((ATAPI_DEVICE_PATH *)TestPath)->Lun == Lun )) {

                    nFoundDevice = i;

                    return nFoundDevice;
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#if DBG    
    BlPrint( TEXT("FindAtapiDevice returning DEVICE_NOT_FOUND\r\n"));
    if (BdDebuggerEnabled == TRUE) {
        DbgBreakPoint();
    }    
#endif

    return DEVICE_NOT_FOUND;
}

ULONG
FindScsiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG Pun,
    ULONG Lun
    )
{
    ULONG i = 0, nFoundDevice = 0;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    EFI_DEVICE_PATH *CurrentDevicePath;

    //
    // Find the Atapi raw device whose PrimarySecondary,
    // SlaveMaster and Lun are a match.
    //
    for( i=0; i<nDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) pDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( (TestPath->Type != END_DEVICE_PATH_TYPE) ) {

            if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                ( TestPath->SubType == MSG_SCSI_DP ) ) {

                if( ( ((SCSI_DEVICE_PATH *)TestPath)->Pun == Pun ) &&
                    ( ((SCSI_DEVICE_PATH *)TestPath)->Lun == Lun )) {

                    nFoundDevice = i;

                    return nFoundDevice;
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#if DBG    
    BlPrint( TEXT("FindScsiDevice returning DEVICE_NOT_FOUND\r\n"));
    if (BdDebuggerEnabled == TRUE) {
        DbgBreakPoint();
    }    
#endif    

    return DEVICE_NOT_FOUND;
}

ULONG
GetDriveCount(
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
	EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = 0;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    BOOLEAN DuplicateFound;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for 
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONGLONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {

                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {
                    
                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol( 
                                            BlockIoHandles[i], 
                                            &EfiBlockIoProtocol, 
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
					if(!BlkIo->Media->RemovableMedia) {
                    
                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
					// removable media
                    //

						Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
						if(BlkIo->Media->RemovableMedia)
							;
						else
							nFoundDevice = 1;
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
					// Found a raw device
                     BlockIoHandlesBitmap[ i ] = nFoundDevice;
                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }	// while
    }	// for

    //
    // Count the bitmap and when we find
    // the DriveId, return the BlockIoHandle
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        if( BlockIoHandlesBitmap[i] != DEVICE_NOT_FOUND ) {

            nDriveCount++;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return nDriveCount;
}

BOOLEAN
IsVirtualFloppyDevice(
    EFI_HANDLE DeviceHandle
    )
/*++

Routine Description:

    Finds out if the given device is a virtual floppy (i.e. RAM Disk).

    NOTE : Currently we assume that if a device supports
    Block, Disk, File System & LoadedImage protocols then it should
    be virtual floppy. Also assumes that FlipToPhysical(...) has be 
    already been called.

Arguments:

    DeviceHandle - Handle to the device which needs to be tested.

Return Value:

    TRUE if the device is virtual floppy otherwise FALSE
    
--*/
{
    BOOLEAN Result = FALSE;

    if (DeviceHandle != (EFI_HANDLE)DEVICE_NOT_FOUND) {
        EFI_STATUS  EfiStatus;
        EFI_BLOCK_IO *EfiBlock = NULL;
        EFI_DISK_IO  *EfiDisk = NULL;
        EFI_LOADED_IMAGE *EfiImage = NULL;
        EFI_FILE_IO_INTERFACE *EfiFs = NULL;
       
        //
        // Get hold of the loaded image protocol handle
        //
        EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                &EfiLoadedImageProtocol,
                                &EfiImage);

        if (!EFI_ERROR(EfiStatus) && EfiImage) {
            //
            // Get hold of the FS protocol handle
            //
            EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                    &EfiFilesystemProtocol,
                                    &EfiFs);

            if (!EFI_ERROR(EfiStatus) && EfiFs) {
                // 
                // Get hold of the disk protocol
                //
                EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                        &EfiDiskIoProtocol,
                                        &EfiDisk);

                if (!EFI_ERROR(EfiStatus) && EfiDisk) {
                    // 
                    // Get hold of the block protocol
                    //
                    EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                            &EfiBlockIoProtocol,
                                            &EfiBlock);                    
                    
                    if (!EFI_ERROR(EfiStatus) && EfiBlock) {
                        Result = TRUE;
                    }
                }
            }                
        }        
    }

    return Result;
}
    

EFI_HANDLE
GetFloppyDrive(
    ULONG DriveId
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;

    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = 0;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    BOOLEAN DuplicateFound;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    
    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for 
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONGLONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)((HandleCount*sizeof(ULONG)) >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find the floppy.
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {
        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];

        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {
            if (!DriveId) {
                if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                               ( TestPath->SubType == HW_VENDOR_DP ) ) {                
                    //
                    // Find the Hardware Vendor raw device
                    //                    
                    if(!(((UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath)->LegacyDriveLetter & 0x80) &&
                        !(((UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath)->LegacyDriveLetter == 0xFF)
                        ) {
                        ReturnDeviceHandle = BlockIoHandles[i];

                        // Bail-out.
                        i = nCachedDevicePaths;
                        break;
                    }
                } else if (TestPath->Type == MESSAGING_DEVICE_PATH && 
                          TestPath->SubType == MSG_ATAPI_DP) {                   
                    //
                    // For ATAPI "floppy drive", we're really looking for a
                    // removable block IO device with a 512 byte block size, as
                    // this signature matches the ls120 style floppy drives and
                    // keeps us from accidentally finding cdrom drives.
                    //
                    // our search algorithm short-circuits when we find the
                    // first suitable device
                    //
                    EFI_DEVICE_PATH *TmpTestPath, *AtapiTestPath;
                    EFI_DEVICE_PATH_ALIGNED AtapiTestPathAligned;
                    EFI_BLOCK_IO * BlkIo;
                    BOOLEAN DefinitelyACDROM = FALSE;                    

                    Status = EfiBS->HandleProtocol(
                                         BlockIoHandles[i],
                                         &EfiBlockIoProtocol,
                                         &(( EFI_BLOCK_IO * ) BlkIo) );

#if 0
                    if (EFI_ERROR(Status)) {
                        DBGOUT((L"getting BlkIo interface failed, ec=%x\r\n",Status));
                    } else {
                        DBGOUT((L"Block size = %x, removable media = %s\r\n", 
                                BlkIo->Media->BlockSize,
                                BlkIo->Media->RemovableMedia ? L"TRUE" : L"FALSE" ));
                    }
#endif


                    TmpTestPath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];

                    EfiAlignDp(
                        &AtapiTestPathAligned,
                        TmpTestPath,
                        DevicePathNodeLength( TmpTestPath )
                        );

                    AtapiTestPath = (EFI_DEVICE_PATH *) &TestPathAligned;                    

                    //
                    // test the device 
                    // removable media?  512 byte block size?
                    //
                    if (!EFI_ERROR(Status) && (BlkIo->Media->RemovableMedia)
                        && BlkIo->Media->BlockSize == 512) {
                                        
                        //
                        // let's be doubly sure and make sure there
                        // isn't a cdrom device path attached to this
                        // device path
                        //
                        while (AtapiTestPath->Type != END_DEVICE_PATH_TYPE ) {
                            
                            if (AtapiTestPath->Type == MEDIA_DEVICE_PATH &&
                                AtapiTestPath->SubType == MEDIA_CDROM_DP) {
                                DefinitelyACDROM = TRUE;
                            }
                            //
                            // Get next device path node.
                            //
                            TmpTestPath = NextDevicePathNode( TmpTestPath );

                            EfiAlignDp(
                                &AtapiTestPathAligned,
                                TmpTestPath,
                                DevicePathNodeLength( TmpTestPath )
                                );

                            AtapiTestPath = (EFI_DEVICE_PATH *) &AtapiTestPathAligned;
    
                        }                        
    
                        if (DefinitelyACDROM == FALSE) {
                            //
                            // found the first floppy drive.
                            // Remember the BlockIo Handle
                            //  
                            ReturnDeviceHandle = BlockIoHandles[i];                      
                            break;
                        }
                    }
                }
            } else {
                //
                // Find the logical vendor device
                //
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                               ( TestPath->SubType == MSG_VENDOR_DP ) ) {

                    if (IsVirtualFloppyDevice(BlockIoHandles[i])) {
                        DriveId--;

                        //
                        // Is this the device we were looking for?
                        //
                        if (!DriveId) {
                            ReturnDeviceHandle = BlockIoHandles[i];
                            
                            i = nCachedDevicePaths; // for outer loop
                            break;      // found the virtual floppy device we were looking for
                        }                            
                    }
                }                
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}


#ifdef FORCE_CD_BOOT

EFI_DEVICE_PATH *
DevicePathFromHandle (
    IN EFI_HANDLE       Handle
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;
    EFI_GUID DevicePathProtocol;

    Status = EfiBS->HandleProtocol (Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    
    if (EFI_ERROR(Status)) {
        DevicePath = NULL;
    }

    return DevicePath;
}


ARC_STATUS
IsUDFSFileSystem(
	IN EFI_HANDLE Handle
	)
/*++

Routine Description:

  Mounts the UDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:

  Volume - UDF Volume pointer
  DeviceId - Device on which the Volume may be residing

Return Value:

  ESUCCESS if successful otherwise EBADF (if no UDF volume was found)

--*/
{
    ARC_STATUS  Status = EBADF;
    UCHAR           UBlock[UDF_BLOCK_SIZE+256] = {0};
    PUCHAR      Block = ALIGN_BUFFER(UBlock);
    ULONG       BlockIdx = 256;
    ULONG       LastBlock = 0;
    EFI_STATUS  EfiStatus;
    EFI_BLOCK_IO *BlkDev;

    EfiStatus = EfiBS->HandleProtocol(
                                     Handle,
                                     &EfiBlockIoProtocol,
                                     &BlkDev);

    if ((EfiStatus == EFI_SUCCESS) && (BlkDev) && (BlkDev->Media) &&
        (BlkDev->Media->RemovableMedia == TRUE)) {
        // get hold of Anchor Volume Descriptor
        EfiStatus = BlkDev->ReadBlocks(
                                      BlkDev,
                                      BlkDev->Media->MediaId,
                                      BlockIdx,
                                      UDF_BLOCK_SIZE,
                                      Block);

        if (EfiStatus == EFI_SUCCESS) {
            if (*(PUSHORT)Block == 0x2) {
                // get partition descriptor
                PNSR_PART Part;
                PWCHAR    TagID;
                ULONG     BlockIdx = *(PULONG)(Block + 20);

                do {
                    EfiStatus = BlkDev->ReadBlocks(
                                                  BlkDev,
                                                  BlkDev->Media->MediaId,
                                                  BlockIdx++,
                                                  UDF_BLOCK_SIZE,
                                                  Block);

                    TagID = (PWCHAR)Block;
                }
                while ((EfiStatus == ESUCCESS) && (*TagID) &&
                       (*TagID != 0x8) && (*TagID != 0x5));

                if ((EfiStatus == ESUCCESS) && (*TagID == 0x5)) {
                    Status = ESUCCESS;
                }
            }
        }
    }

	return Status;
}


ARC_STATUS
IsCDFSFileSystem(
	IN EFI_HANDLE Handle
	)
/*++

Routine Description:

  Mounts the CDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:


Return Value:

  ESUCCESS if successful otherwise EBADF (if no CDFS volume was found)

--*/
{
    EFI_DEVICE_PATH *Dp;
    ARC_STATUS Status = EBADF;


    Dp=DevicePathFromHandle(Handle);


    if (Dp) {
        while (!IsDevicePathEnd (Dp) && (Status == EBADF)) {
            if ((Dp->Type == MEDIA_DEVICE_PATH) &&
                (Dp->SubType == MEDIA_CDROM_DP) ) {
                Status = ESUCCESS;
            }
            Dp=NextDevicePathNode(Dp);
        }
    }

  	return Status;
}


EFI_HANDLE
GetCdTest(
    VOID
    )
{
    ULONG i;
    ULONGLONG DevicePathSize, SmallestPathSize;
    ULONG HandleCount;

    EFI_HANDLE *BlockIoHandles;

    EFI_HANDLE DeviceHandle = NULL;
    EFI_DEVICE_PATH *DevicePath, *TestPath,*Dp;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    EFI_STATUS Status;
    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
//    PBOOT_DEVICE_TCPIPv4 BootDeviceTcpipV4;
//    PBOOT_DEVICE_TCPIPv6 BootDeviceTcpipV6;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) 0;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"GetCdTest: BlGetEfiProtocolHandles failed\r\n");
        return(ReturnDeviceHandle);
    }
    
    //
    // change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();

    SmallestPathSize = 0;

    for (i = 0,; i < HandleCount; i++) {

      if (IsUDFSFileSystem(BlockIoHandles[i]) == ESUCCESS) {
        ReturnDeviceHandle = BlockIoHandles[i];
        break;
      }
    }

    if (ReturnDeviceHandle == (EFI_HANDLE) 0) {

        for (i = 0; i < HandleCount; i++) {
            if (IsCDFSFileSystem (BlockIoHandles[i]) == ESUCCESS) {
                ReturnDeviceHandle = BlockIoHandles[i];
                break;
            }

        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}

#endif // for FORCE_CD_BOOT


//
// Turn off the timer so we don't reboot waiting for the user to press a key
//
void
DisableEFIWatchDog (
    VOID
    )
{
    EfiBS->SetWatchdogTimer (0,0,0,NULL);
}

BOOLEAN
BlDiskGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.
    
    NOTE: This routine changes the seek position on disk, and you must seek
          back to your original seek position if you plan on reading from the
          disk after making this call.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)
    
    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;
    

    DiskId = *((PULONG)pContext);
    //
    // read from the appropriate LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;

    Status = BlSeek(DiskId,
                      &SeekPosition,
                      SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;
    
    Status = BlRead(
                DiskId,
                DataPointer,
                BytesToRead,
                &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }
    
    return(FALSE);

}



ARC_STATUS
BlGetGPTDiskPartitionEntry(
    IN ULONG DiskNumber,
    IN UCHAR PartitionNumber,
    OUT EFI_PARTITION_ENTRY UNALIGNED **PartitionEntry
    )
{
    ARC_STATUS Status;
    ULONG DiskId;
    LARGE_INTEGER SeekPosition;
    UCHAR DataBuffer[SECTOR_SIZE * 2];
    ULONG ReadCount;
    UCHAR NullGuid[16] = {0};
    UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;

    if (PartitionNumber >= 128) {
        return EINVAL;
    }

    //
    // Open the disk for raw access.
    //

    Status = BiosDiskOpen( DiskNumber,
                           0,
                           &DiskId );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BiosDiskOpen (%x) fails, %x\r\n"), DiskNumber, Status));
        return EINVAL;
    }


    BlFileTable[DiskId].Flags.Read = 1;

    //
    // Read the second LBA on the disk.
    //

    SeekPosition.QuadPart = 1 * SECTOR_SIZE;       

    Status = BlSeek( DiskId, &SeekPosition, SeekAbsolute );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlSeek fails, %x\r\n"), Status));
        goto done;
    }

    Status = BlRead( DiskId, DataBuffer, SECTOR_SIZE, &ReadCount );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlRead fails, %x\r\n"), Status));
        goto done;
    }

    if (ReadCount != SECTOR_SIZE) {
        Status = EIO;
        DBGOUT((TEXT("BlRead (wrong amt)\r\n")));
        goto done;
    }        

    EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataBuffer;
                                                          
    //
    // Verify EFI partition table.
    //
    if (!BlIsValidGUIDPartitionTable(
                            (UNALIGNED EFI_PARTITION_TABLE *)EfiHdr,
                            1,
                            &DiskId,
                            BlDiskGPTDiskReadCallback)) {
        DBGOUT((TEXT("BlIsValidGUIDPartitionTable fails, %x\r\n"), Status));
        Status = EBADF;
        goto done;
    }

    //
    // Locate and read the partition entry that was requested.
    //
    SeekPosition.QuadPart = EfiHdr->PartitionEntryLBA * SECTOR_SIZE;

    DBG_PRINT(STR_PREFIX"Seeking GPT Partition Entries\r\n");
        
    Status = BlSeek( DiskId, &SeekPosition, SeekAbsolute );

    if (Status != ESUCCESS) {
        goto done;
    }

    Status = BlRead( DiskId, EfiPartitionBuffer, sizeof(EfiPartitionBuffer), &ReadCount );
                                                          
    if (Status != ESUCCESS) {
        goto done;
    }

    if (ReadCount != sizeof(EfiPartitionBuffer)) {
        Status = EIO;
        goto done;
    }  

    PartEntry = BlLocateGPTPartition( PartitionNumber - 1, 128, NULL );

    if ( PartEntry != NULL ) {
    
        if ( (memcmp(PartEntry->Type, NullGuid, 16) != 0) &&
             (memcmp(PartEntry->Id, NullGuid, 16) != 0) &&
             (PartEntry->StartingLBA != 0) &&
             (PartEntry->EndingLBA != 0) ) {
            Status = ESUCCESS;
            goto done;
        }
    }

    Status = EBADF;

done:

    *PartitionEntry = PartEntry;

    BiosDiskClose(DiskId);

    if (Status != ESUCCESS) {
        Status = ENOENT;
    }

    return Status;
}

ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  ULONGLONG DeviceHandle,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
        PUCHAR    Buffer,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors via extended int13.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    etc.

    This routine does not check whether extended int13 is actually available
    for the drive.

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ARC_STATUS s;
    ULONG l,h;
    UCHAR Operation;

    if(!SectorCount) {
        return(ESUCCESS);
    }

    l = (ULONG)StartSector;
    h = (ULONG)(StartSector >> 32);

    Operation = (UCHAR)(Write ? 0x43 : 0x42);

    //
    // We don't reset since this routine is only used on hard drives and
    // CD-ROMs, and we don't totally understand the effect of a disk reset
    // on ElTorito.
    //
    s = GET_EDDS_SECTOR(DeviceHandle,l,h,SectorCount,Buffer,Operation);

    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow [TomP] Feb-13-1991
    Reworked substantially in Tokyo 7-July-95 (tedm)
    Port from ARC-BIOS to EFI 22-Nov-2000 (andrewr)

Abstract:

    This file contains an interface to the screen that is independent
    of the screen type actually being written to.  The module serves
    as a layer between OS loader applications and the EFI services
    that do the actual legwork of writing to the default console
    handlers.

--*/

#include "bldr.h"
#include "bootefi.h"


#include "efi.h"
#include "efip.h"
#include "flop.h"


//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern BOOLEAN GoneVirtual;

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + \
    (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Internal routines
//
VOID
puti(
    LONG
    );

VOID
putx(
    ULONG
    );

VOID
putu(
    ULONG
    );

VOID
putwS(
    PUNICODE_STRING String
    );

VOID
putS(
    PCWSTR String
    );

VOID
puts(
    PCSTR String
    );

VOID
BlPrint(
    PTCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex
     %C, %S  - ansi character, string
     %wS     - counted UNICODE_STRING

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.

Returns:

    Nothing

--*/

{
    ULONG l;
    ULONG Count;
    TCHAR ch;
    ULONG DeviceId;
    TCHAR b,c;
    PTSTR FormatString;
    va_list args;

    FormatString = cp;

    DeviceId = BlConsoleOutDeviceId;

    va_start(args, cp);

    //
    // Process the arguments using the descriptor string
    //
    while(*FormatString != TEXT('\0')) {
          
        b = *FormatString;
        FormatString += 1;

        if(b == TEXT('%')) {

            c = *FormatString;
            FormatString += 1;

            switch (c) {

            case TEXT('d'):
                
                puti((LONG)va_arg(args, LONG));
                
                break;

            case TEXT('s'):
                putS((PCWSTR)va_arg(args, PWSTR));
                
                break;

            case TEXT('S'):
                puts((PCSTR)va_arg(args, PSTR));
                
                break;

            case TEXT('c'):
                ch = (WCHAR)va_arg( args, WCHAR );
                ArcWrite(DeviceId, &ch, 1*sizeof(WCHAR), &Count);                
                break;
            
            case TEXT('C'):
                ch = (CHAR)va_arg( args, CHAR );
                ArcWrite(DeviceId, &ch, 1*sizeof(CHAR), &Count);
                
                break;

            case TEXT('x'):
                //note that this doesn't currently support zero padding.
                putx((ULONG)va_arg( args, ULONG));
                break;

            case TEXT('u'):
                putu( (ULONG)va_arg( args, ULONG ));
                break;

            case TEXT('w'):
                c = *FormatString;
                FormatString += 1;
                switch (c) {
                case TEXT('S'):
                case TEXT('Z'):
                    putwS((PUNICODE_STRING)va_arg( args, PUNICODE_STRING));
                    break;
                }
                break;

            case TEXT('l'):
                c = *FormatString;
                FormatString += 1;                    

                switch(c) {

                case TEXT('0'):
                    break;

                case TEXT('u'):
                    putu(va_arg( args, ULONG));                    
                    break;

                case TEXT('x'):
                    //note that this doesn't currently support zero padding
                    putx(va_arg( args, ULONG));                    
                    break;

                case TEXT('d'):
                    puti(va_arg( args, ULONG));                    
                    break;
                }
                break;

            default :
                ch = (TCHAR)b;
                ArcWrite(DeviceId, &ch, 1*sizeof(TCHAR), &Count);
                ch = (TCHAR)c;
                ArcWrite(DeviceId, &ch, 1*sizeof(TCHAR), &Count);
            }
        } else {
            ArcWrite(DeviceId, FormatString - 1, 1*sizeof(TCHAR), &Count);            
        }
    }

    va_end(args);    

#if 0

    //
    // This code pauses the system after each BlPrint.  You must enter 
    // a character to continue.  This is used for debugging
    //

    ArcRead(BlConsoleInDeviceId, &l, 1, &Count);

#endif
    
}


VOID
putwS(
    PUNICODE_STRING String
    )

/*++

Routine Description:

    Writes counted unicode string to the display at the current
    cursor position.

Arguments:

    String - pointer to unicode string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;    
    
    for(i=0; i < String->Length; i++) {        
        ArcWrite(BlConsoleOutDeviceId, &String->Buffer[i], 1*sizeof(WCHAR), &Count);
    }
}

VOID
puts(
    PCSTR AnsiString
    )

/*++

Routine Description:

    Writes an ANSI string to the display at the current cursor position.

Arguments:

    String - pointer to ANSI string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;
    WCHAR Char;
    PCSTR p;

    p = AnsiString;
    while (*p != '\0') {
        Char = (WCHAR)*p;
        ArcWrite(BlConsoleOutDeviceId, &Char, sizeof(WCHAR), &Count);
        p += 1;
    }
                          
}

VOID
putS(
    PCWSTR UnicodeString
    )

/*++

Routine Description:

    Writes an ANSI string to the display at the current cursor position.

Arguments:

    String - pointer to ANSI string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;
    WCHAR Char;
    PCWSTR p;

    p = UnicodeString;
    while (*p != L'\0') {
        Char = *p;
        ArcWrite(BlConsoleOutDeviceId, &Char, sizeof(WCHAR), &Count);
        p += 1;
    }
                          
}



VOID
putx(
    ULONG x
    )

/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x - ulong to write

Returns:

    Nothing

--*/

{
    ULONG j;
    ULONG Count;
    _TUCHAR ch;

    if(x/16) {
        putx(x/16);
    }

    if((j=x%16) > 9) {
        ch = (_TUCHAR)(j+TEXT('A')-10);
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    } else {
        ch = (_TUCHAR)(j+TEXT('0'));
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    }
}


VOID
puti(
    LONG i
    )

/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing

--*/

{
    ULONG Count;
    _TUCHAR ch;

    if(i<0) {
        i = -i;
        ch = TEXT('-');
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    }

    if(i/10) {
        puti(i/10);
    }

    ch = (_TUCHAR)((i%10)+TEXT('0'));
    ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
}


VOID
putu(
    ULONG u
    )

/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned

Returns:

    Nothing

--*/

{
    ULONG Count;
    _TUCHAR ch;

    if(u/10) {
        putu(u/10);
    }
    
    ch = (_TUCHAR)((u%10)+TEXT('0'));
    ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
}


#if 0
VOID
pTextCharOut(
    IN UCHAR c
    )
{
    if(DbcsLangId) {
        //
        // Single-byte only
        //
        TextGrCharOut(&c);
    } else {
        TextTmCharOut(&c);
    }
}

#endif

VOID
TextCharOut(
    IN PWCHAR pc
    )
{
    WCHAR  Text[2];
    Text[0] = *pc;
    Text[1] = L'\0';
    if (GoneVirtual) {
        FlipToPhysical();
    }
    EfiST->ConOut->OutputString(EfiST->ConOut,Text);
    if (GoneVirtual) {
        FlipToVirtual();
    }
#if 0
    if(DbcsLangId) {
        return(TextGrCharOut(pc));
    } else {
        return(TextTmCharOut(pc));
    }
#endif
}


VOID
TextStringOut(
    IN PWCHAR String
    )
{
    PWCHAR p = String;
    while (*p) {
        TextCharOut(p);
        p += 1;
    }

#if 0    
    if(DbcsLangId) {
        TextGrStringOut(String);
    } else {
        TextTmStringOut(String);
    }
#endif

}

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;
    
#ifdef EFI
    BlEfiSetAttribute( Attribute );
#else
    if(DbcsLangId) {
        TextGrSetCurrentAttribute(Attribute);
    } else {
        TextTmSetCurrentAttribute(Attribute);
    }
#endif
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
#ifdef EFI
    ULONG x,y, OrigX, OrigY;
    BOOLEAN FirstTime = TRUE;

    BlEfiGetCursorPosition( &OrigX, &OrigY );

    x = OrigX;
    y = OrigY;

    for (y = OrigY; y < BlEfiGetLinesPerRow() ; y++) {
        x = FirstTime
            ? OrigX
            : 0 ;

        FirstTime = FALSE;

        for (; x <= BlEfiGetColumnsPerLine(); x++) {
            BlEfiPositionCursor( y, x );
            BlEfiSetAttribute( Attribute );
        }
    }

    BlEfiPositionCursor( OrigY, OrigX );

#else
    if(DbcsLangId) {
        TextGrFillAttribute(Attribute,Length);
    } else {
        TextTmFillAttribute(Attribute,Length);
    }
#endif
}


_TUCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    )
{
#ifdef EFI
    return(BlEfiGetGraphicsChar( WhichOne ));
#else
    return((WhichOne < GraphicsCharMax)
           ? (DbcsLangId 
               ? TextGrGetGraphicsChar(WhichOne) 
               : TextTmGetGraphicsChar(WhichOne))
           : TEXT(' '));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\arcemul.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    arcemul.c

Abstract:

    This module provides the x86 emulation for the Arc routines which are
    built into the firmware on ARC machines.

    N. B.   This is where all the initialization of the SYSTEM_PARAMETER_BLOCK
            takes place.  If there is any non-standard hardware, some of the
            vectors may have to be changed.  This is where to do it.


Author:

    Allen Kay (akay) 26-Jan-1996

    Base on i386 version by John Vert (jvert) 13-Jun-1991

Environment:

    EFI

Revision History:

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "ntdddisk.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "scsi.h"
#include "scsiboot.h"

#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

extern PCHAR MnemonicTable[];

//
// Size definitions for HardDiskInitialize()
//

#define SUPPORTED_NUMBER_OF_DISKS 32
#define SIZE_FOR_SUPPORTED_DISK_STRUCTURE (SUPPORTED_NUMBER_OF_DISKS*sizeof(DRIVER_LOOKUP_ENTRY))


PDRIVER_UNLOAD AEDriverUnloadRoutine = NULL;


#define PORT_BUFFER_SIZE 10
UCHAR PortBuffer[PORT_BUFFER_SIZE];
ULONG PortBufferStart = 0;
ULONG PortBufferEnd = 0;

//
// Miniport DriverEntry typedef
//

typedef NTSTATUS
(*PDRIVER_ENTRY) (
    IN PVOID DriverObject,
    IN PVOID Parameter2
    );

//
// Private function prototypes
//

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

PCONFIGURATION_COMPONENT
AEComponentInfo(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    );

PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    );

PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    );

ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    );

PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    );

ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
AEClose(
    IN ULONG FileId
    );

ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEReadStatus (
    IN ULONG FileId
    );

VOID
AEReboot(
    VOID
    );

ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    );

PTIME_FIELDS
AEGetTime(
    VOID
    );

ULONG
AEGetRelativeTime(
    VOID
    );

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

VOID
HardDiskInitialize(
    IN OUT PVOID LookupTable,
    IN ULONG Entries,
    IN PVOID DeviceFoundCallback
    );

//
// This is the x86 version of the system parameter block on the ARC machines.
// It lives here, and any module that uses an ArcXXXX routine must declare
// it external.  Machines that have other than very plain-vanilla hardware
// may have to replace some of the hard-wired vectors with different
// procedures.
//

PVOID GlobalFirmwareVectors[MaximumRoutine];

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock =
    {
        0,                              // Signature??
        sizeof(SYSTEM_PARAMETER_BLOCK), // Length
        0,                              // Version
        0,                              // Revision
        NULL,                           // RestartBlock
        NULL,                           // DebugBlock
        NULL,                           // GenerateExceptionVector
        NULL,                           // TlbMissExceptionVector
        MaximumRoutine,                 // FirmwareVectorLength
        GlobalFirmwareVectors,          // Pointer to vector block
        0,                              // VendorVectorLength
        NULL                            // Pointer to vendor vector block
    };


extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// temptemp John Vert (jvert) 6-Sep-1991
//      Just do this until we can make our device driver interface look
//      like the ARC firmware one.
//

extern BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable;

ULONG FwStallCounter;


VOID
AEInitializeStall(
    VOID
    )
{
    FwStallCounter = GET_STALL_COUNT();
    return;
}

#if !defined(NO_LEGACY_DRIVERS)


ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    )

/*++

Routine Description:

    Initializes SCSI boot driver, if any.  Loads ntbootdd.sys from the
    boot partition, binds it to the osloader, and initializes it.

Arguments:

    DriveId - file id of the opened boot partition

Return Value:

    ESUCCESS - Drivers successfully initialized

--*/

{
    extern ULONG ScsiPortCount;
    extern ULONG MachineType;
    ARC_STATUS Status;
    PVOID Buffer;
    PVOID ImageBase;
    PLDR_DATA_TABLE_ENTRY DriverDataTableEntry;
    PDRIVER_ENTRY Entry;    
    ULONG i;
    ULONG ImageBasePage;

    ScsiPortCount = 0;

    FwStallCounter = GET_STALL_COUNT();
    Status = BlLoadImage(DriveId,
                         MemoryFirmwarePermanent,
                         "\\NTBOOTDD.SYS",
                         TARGET_IMAGE,
                         &ImageBase);
    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = BlAllocateDataTableEntry("NTBOOTDD.SYS",
                                      "\\NTBOOTDD.SYS",
                                      ImageBase,
                                      &DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }
    //
    // Scan the import table and bind to osloader
    //
    Status = BlScanOsloaderBoundImportTable(DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }

    Entry = (PDRIVER_ENTRY)DriverDataTableEntry->EntryPoint;

    Status = (*Entry)(NULL,NULL);
    if (Status == ESUCCESS) {
        //
        // Find the firmware's copy of the memory descriptor that
        // contains the driver and change it from MemoryFree to
        // MemoryFirmwareTemporary.
        //
        ImageBasePage = ((PtrToUlong(ImageBase) & 0x7fffffff) >> PAGE_SHIFT);
        i=0;
        while ((MDArray[i].BasePage >= ImageBasePage) ||
               (MDArray[i].BasePage + MDArray[i].PageCount < ImageBasePage)) {
            i++;
        }

        MDArray[i].MemoryType = MemoryFirmwareTemporary;

        Buffer = BlAllocateHeap(SIZE_FOR_SUPPORTED_DISK_STRUCTURE);

        if(Buffer == NULL) {
            return ENOMEM;
        }

        HardDiskInitialize(Buffer, SUPPORTED_NUMBER_OF_DISKS, NULL);
    }
    return(Status);
}

#endif // NO_LEGACY_DRIVERS


VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    This routine fills in all the fields in the Global System Parameter Block
    that it can.  This includes all the firmware vectors, the vendor-specific
    information, and anything else that may come up.

Arguments:

    None.


Return Value:

    None.

--*/

{
    int cnt;

    //
    // Fill in the pointers to the firmware functions which we emulate.
    // Those which we don't emulate are stubbed by BlArcNotYetImplemented,
    // which will print an error message if it is accidentally called.
    //

    for (cnt=0; cnt<MaximumRoutine; cnt++) {
        GlobalFirmwareVectors[cnt]=(PVOID)BlArcNotYetImplemented;
    }
    GlobalFirmwareVectors[CloseRoutine]  = (PVOID)AEClose;
    GlobalFirmwareVectors[OpenRoutine]  = (PVOID)AEOpen;
    GlobalFirmwareVectors[MemoryRoutine]= (PVOID)AEGetMemoryDescriptor;
    GlobalFirmwareVectors[SeekRoutine]  = (PVOID)AESeek;
    GlobalFirmwareVectors[ReadRoutine]  = (PVOID)AERead;
    GlobalFirmwareVectors[ReadStatusRoutine]  = (PVOID)AEReadStatus;
    GlobalFirmwareVectors[WriteRoutine] = (PVOID)AEWrite;
    GlobalFirmwareVectors[GetFileInformationRoutine] = (PVOID)AEGetFileInformation;
    GlobalFirmwareVectors[GetTimeRoutine] = (PVOID)AEGetTime;
    GlobalFirmwareVectors[GetRelativeTimeRoutine] = (PVOID)AEGetRelativeTime;
    GlobalFirmwareVectors[GetPeerRoutine] = (PVOID)FwGetPeer;
    GlobalFirmwareVectors[GetChildRoutine] = (PVOID)FwGetChild;
    GlobalFirmwareVectors[GetParentRoutine] = (PVOID)AEGetParent;
    GlobalFirmwareVectors[GetComponentRoutine] = (PVOID)FwGetComponent;
    GlobalFirmwareVectors[GetDataRoutine] = (PVOID)AEGetConfigurationData;
    GlobalFirmwareVectors[GetEnvironmentRoutine] = (PVOID)AEGetEnvironment;

    GlobalFirmwareVectors[RestartRoutine] = (PVOID)AEReboot;
    GlobalFirmwareVectors[RebootRoutine] = (PVOID)AEReboot;

}


PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    )

/*++

Routine Description:

    Emulates the Arc GetMemoryDescriptor call.  This must translate
    between the memory description passed to us by the SU module and
    the MEMORYDESCRIPTOR type defined by ARC.

Arguments:

    MemoryDescriptor - Supplies current memory descriptor.
        If MemoryDescriptor==NULL, return the first memory descriptor.
        If MemoryDescriptor!=NULL, return the next memory descriptor.

Return Value:

    Next memory descriptor in the list.
    NULL if MemoryDescriptor is the last descriptor in the list.

--*/

{
    extern ULONG NumberDescriptors;
    PMEMORY_DESCRIPTOR Return;
    if (MemoryDescriptor==NULL) {
        Return=MDArray;
    } else {
        if((ULONG)(MemoryDescriptor-MDArray) >= (NumberDescriptors-1)) {
            return NULL;
        } else {
            Return = ++MemoryDescriptor;
        }
    }
    return(Return);

}


ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    )

/*++

Routine Description:

    This is a stub routine used to fill in the firmware vectors which haven't
    been defined yet.  It uses BlPrint to print a message on the screen.

Arguments:

    None.

Return Value:

    EINVAL

--*/

{
#if DBG
    BlPrint(TEXT("ERROR - Unimplemented Firmware Vector called (FID %lx)\r\n"),
            FileId );
#endif
    return(EINVAL);
}


PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetChild.  Based on the current
    component, it returns the component's child component.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;

    //
    // if current component is NULL, return a pointer to first system
    // component; otherwise return current component's child component.
    //

    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Child) {
            return(&(CurrentEntry->Child->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        if (FwConfigurationTree) {
            return(&(FwConfigurationTree->ComponentEntry));
        } else {
            return(NULL);
        }
    }

}


PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetPeer.  Based on the current
    component, it returns the component's sibling.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Sibling) {
            return(&(CurrentEntry->Sibling->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Parent) {
            return(&(CurrentEntry->Parent->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    ESUCCESS - Data successfully returned.


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        RtlMoveMemory(ConfigurationData,
                      CurrentEntry->ConfigurationData,
                      Current->ConfigurationDataLength);
        return(ESUCCESS);
    } else {
        return(EINVAL);
    }

}


PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    )

/*++

Routine Description:

    This is the arc emulation routine for ArcGetEnvironment.  It returns
    the value of the specified NVRAM environment variable.

    NOTE John Vert (jvert) 23-Apr-1992
        This particular implementation uses the Daylight Savings Bit on
        the Real Time Clock to reflect the state of the LastKnownGood
        environment variable.  This is the only variable we support.

Arguments:

    Variable - Supplies the name of the environment variable to look up.

Return Value:

    A pointer to the specified environment variable's value, or
    NULL if the variable does not exist.

--*/

{
    UCHAR StatusByte;

#if 1

    //
    // Until firmware implements LastKnownGood variable,
    // return NULL for now.
    //

    return(NULL);

#else

    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return(NULL);
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);
    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        return("TRUE");
    } else {
        return(NULL);
    }

#endif
}


ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the file or device specified by OpenPath.

Arguments:

    OpenPath - Supplies a pointer to the fully-qualified path name.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    CHAR Buffer[128];

    Status = BiosConsoleOpen( OpenPath,
                              OpenMode,
                              FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    Status = BiosPartitionOpen( OpenPath,
                                OpenMode,
                                FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

#if !defined(NO_LEGACY_DRIVERS)

    //
    // It's not the console or a BIOS partition, so let's try the SCSI
    // driver.
    //

    //
    // Find a free FileId
    //

    *FileId = 2;
    while (BlFileTable[*FileId].Flags.Open == 1) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    strcpy(Buffer,OpenPath);

    Status = ScsiDiskOpen( Buffer,
                           OpenMode,
                           FileId );

    if (Status == ESUCCESS) {

        //
        // SCSI successfully opened it.  For now, we stick the appropriate
        // SCSI DeviceEntryTable into the BlFileTable.  This is temporary.
        //

        BlFileTable[*FileId].Flags.Open = 1;
        BlFileTable[*FileId].DeviceEntryTable = &ScsiDiskEntryTable;
        return(ESUCCESS);
    }

#endif // NO_LEGACY_DRIVERS

    return(Status);
}


ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    return(BlFileTable[FileId].DeviceEntryTable->Seek)( FileId,
                                                        Offset,
                                                        SeekMode );
}


ARC_STATUS
AEClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the file specified by FileId

Arguments:

    FileId - specifies the file to close

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{

    return(BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

}


ARC_STATUS
AEReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    Determines if data is available on the specified device

Arguments:

    FileId - Specifies the device to check for data.

Return Value:

    ESUCCESS - At least one byte is available.

    EAGAIN - No data is available

--*/

{
    //
    // Special case for console input
    //

    if (FileId == 0) {
#if 0
        //
        // Give priority to dumb terminal
        //
        if (BlIsTerminalConnected() && (PortBufferStart != PortBufferEnd)) {
            return(ESUCCESS);
        }

        if (BlIsTerminalConnected() && (BlPortPollOnly(BlTerminalDeviceId) == CP_GET_SUCCESS)) {
            return(ESUCCESS);
        }
#endif
        return(BiosConsoleReadStatus(FileId));
    } else {
        return(BlArcNotYetImplemented(FileId));
    }

}


ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file or device

Arguments:

    FileId - specifies the file to read from

    Buffer - Address of buffer to hold the data that is read

    Length - Maximum number of bytes to read

    Count -  Address of location in which to store the actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PCHAR TmpBuffer;
    ULONG StartTime;
    ULONG LastTime;
    UCHAR Ch;

    //
    // Special case for console input
    //

    if (FileId == 0) {

RetryRead:
#if 0
        if (BlIsTerminalConnected()) {

            *Count = 0;
            TmpBuffer = (PCHAR)Buffer;

            while (*Count < Length) {

                //
                // First return any buffered input
                //
                if (PortBufferStart != PortBufferEnd) {
                    TmpBuffer[*Count] = PortBuffer[PortBufferStart];
                    PortBufferStart++;
                    PortBufferStart = PortBufferStart % PORT_BUFFER_SIZE;
                    *Count = *Count + 1;
                    continue;
                }

                //
                // Now check for new input
                //
                if (BlPortPollByte(BlTerminalDeviceId, TmpBuffer + *Count) != CP_GET_SUCCESS) {
                    break;
                }

                //
                // Convert ESC key to the local equivalent
                //
                if (TmpBuffer[*Count] == 0x1b) {
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;

                    //
                    // Wait for the user to type a key.
                    //
                    StartTime = AEGetRelativeTime();

                    while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                        LastTime = AEGetRelativeTime();

                        //
                        // if the counter wraps back to zero, just restart the wait.
                        //
                        if (LastTime < StartTime) {
                            StartTime = LastTime;
                        }

                        //
                        // If one second has passed, the user must have just wanted a single
                        // escape key, so return with that.
                        //
                        if ((LastTime - StartTime) > 1) {
                            *Count = *Count + 1;
                            return (ESUCCESS);
                        }

                    }

                    //
                    // We have another key, get it and translate the escape sequence.
                    //
                    if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                        *Count = *Count + 1;
                        return (ESUCCESS);
                    }


                    switch (Ch) {
                    case '@': // F12 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'B';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '!': // F11 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'A';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '0': // F10 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'M';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '8': // F8 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'r';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '6': // F6 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'u';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '5': // F5 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 't';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '3': // F3 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'w';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '1': // F1 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '+': // Home key
                        PortBuffer[PortBufferEnd] = 'H';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '-': // End key
                        PortBuffer[PortBufferEnd] = 'K';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '[': // Cursor movement key

                        //
                        // The local computer can run a lot faster than the serial port can give bytes,
                        // so spin, polling, for a second.
                        //
                        StartTime = AEGetRelativeTime();
                        while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                            LastTime = AEGetRelativeTime();

                            //
                            // if the counter wraps back to zero, just restart the wait.
                            //
                            if (LastTime < StartTime) {
                                StartTime = LastTime;
                            }

                            //
                            // If one second has passed, we must be done.
                            //
                            if ((LastTime - StartTime) > 1) {
                                break;
                            }

                        }

                        if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;                            
                            break;
                        }

                        if ((Ch == 'A') || (Ch == 'B') || (Ch == 'C') || (Ch == 'D')) { // Arrow key.

                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;

                        } else { 

                            //
                            // Leave it as is
                            //
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        }
                        break;

                    default:
                        PortBuffer[PortBufferEnd] = Ch;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;
                    }

                } else if (TmpBuffer[*Count] == 0x7F) { // DEL key
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;
                    PortBuffer[PortBufferEnd] = 'P';
                    PortBufferEnd++;
                    PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                }

                *Count = *Count + 1;
            }

            if (*Count != 0) {
                return(ESUCCESS);
            }
            
        }
#endif

        if (BiosConsoleReadStatus(FileId) == ESUCCESS) {
            return(BiosConsoleRead(FileId,Buffer,Length,Count));
        }

        goto RetryRead;

    } else {

        *Count = 0;

        do {

            if ((PtrToUlong(Buffer) & 0xffff0000) !=
               ((PtrToUlong(Buffer) + Length) & 0xffff0000)) {

                Limit = 0x10000 - (PtrToUlong(Buffer) & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Read)( FileId,
                                                                Buffer,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            (PCHAR) Buffer += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint(TEXT("Disk I/O error: Status = %lx\r\n"),Status);
#endif                
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}


ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file or device

Arguments:

    FileId - Supplies the file or device to write to

    Buffer - Supplies address of the data to be written

    Length - Supplies number of bytes to write

    Count -  Address of location in which to store the actual bytes written.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PCHAR TmpBuffer;

    //
    // Special case for console output
    //

    if (FileId == 1) {

#if 0
        if (BlIsTerminalConnected()) {
            for (PartCount = 0, TmpBuffer = (PCHAR)Buffer; PartCount < Length; PartCount++) {
                BlPortPutByte(BlTerminalDeviceId, TmpBuffer[PartCount]);
            }
        }
#endif

        return(BiosConsoleWrite(FileId,(PWCHAR)Buffer,Length,Count));
    } else {
        *Count = 0;

        do {

            if ((PtrToUlong(Buffer) & 0xffff0000) !=
               ((PtrToUlong(Buffer) + Length) & 0xffff0000)) {

                Limit = 0x10000 - (PtrToUlong(Buffer) & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Write)( FileId,
                                                                Buffer,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            (PCHAR) Buffer += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint(TEXT("AERead: Status = %lx\r\n"),Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    )
{
    return(BlFileTable[FileId].DeviceEntryTable->GetFileInformation)( FileId,
                                                                      FileInformation);
}


TIME_FIELDS AETime;

PTIME_FIELDS
AEGetTime(
    VOID
    )
{
    ULONG Date,Time;

    GET_DATETIME(&Date,&Time);

    //
    // Date and time are filled as as follows:
    //
    // Date:
    //
    //    bits 0  - 4  : day
    //    bits 5  - 8  : month
    //    bits 9  - 31 : year
    //
    // Time:
    //
    //    bits 0  - 5  : second
    //    bits 6  - 11 : minute
    //    bits 12 - 16 : hour
    //

    AETime.Second = (CSHORT)((Time & 0x0000003f) >> 0);
    AETime.Minute = (CSHORT)((Time & 0x00000fc0) >> 6);
    AETime.Hour   = (CSHORT)((Time & 0x0001f000) >> 12);

    AETime.Day    = (CSHORT)((Date & 0x0000001f) >> 0);
    AETime.Month  = (CSHORT)((Date & 0x000001e0) >> 5);
    AETime.Year   = (CSHORT)((Date & 0xfffffe00) >> 9);

    AETime.Milliseconds = 0;        // info is not available
    AETime.Weekday = 7;             // info is not available - set out of range

    return(&AETime);
}


ULONG
AEGetRelativeTime(
    VOID
    )

/*++

Routine Description:

    Returns the time in seconds since some arbitrary starting point.

Arguments:

    None

Return Value:

    Time in seconds since some arbitrary starting point.

--*/

{
    ULONG TimerTicks;

    TimerTicks = GET_COUNTER();

    return((TimerTicks*10) / 182);
}


VOID
AEReboot(
    VOID
    )

/*++

Routine Description:

    Reboots the machine.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    REBOOT_PROCESSOR();
}



ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This routine opens the specified partition and sets the partition info
    in the FileTable at the specified index.  It does not fill in the
    Device Entry table.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DiskId - Supplies the file id for the physical device.

    PartitionNumber - Supplies the zero-based partition number

Return Value:

    If a valid partition is found on the hard disk, then ESUCCESS is
    returned. Otherwise, EIO is returned.

--*/

{

    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    ARC_STATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG Count;
    LARGE_INTEGER SeekPosition;

    BlFileTable[FileId].u.PartitionContext.DiskId=(UCHAR)DiskId;
    BlFileTable[FileId].Position.QuadPart=0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    //
    // Change to a 1-based partition number
    //
    PartitionNumber++;

    do {
        SeekPosition.QuadPart = (ULONGLONG)PartitionOffset * (ULONGLONG)SECTOR_SIZE;
        Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                              &SeekPosition,
                                                              SeekAbsolute );
        if (Status != ESUCCESS) {
            return(Status);
        }
        
        Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                              DataBuffer,
                                                              SECTOR_SIZE,
                                                              &Count );

        if (Status != ESUCCESS) {
            return Status;
        }            

        //
        // If sector zero is not a master boot record, then return failure
        // status. Otherwise return success.
        //

        if (DataBuffer[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
#if DBG
            BlPrint(TEXT("Boot record signature %x not found (%x found)\r\n"),
                    BOOT_RECORD_SIGNATURE,
                    DataBuffer[BOOT_SIGNATURE_OFFSET] );
#endif
            Status = EIO;
            break;
        }

        //
        // Read the partition information until the four entries are
        // checked or until we found the requested one.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];

        for (PartitionIndex=0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {

            //
            // Count first the partitions in the MBR. The units
            // inside the extended partition are counted later.
            //
            if ((Partition->PartitionType != PARTITION_ENTRY_UNUSED) &&
                (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY)                
            &&  !IsContainerPartition(Partition->PartitionType))
            {
                PartitionCount++;   // another partition found.
            }

            //
            // Check if the requested partition has already been found.
            // set the partition info in the file table and return.
            //
            if (PartitionCount == PartitionNumber) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                  (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                  (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                  (ULONG)(Partition->PartitionLengthMsb1 << 24);
                BlFileTable[FileId].u.PartitionContext.PartitionLength.QuadPart =
                        (PartitionLength << SECTOR_SHIFT);
                BlFileTable[FileId].u.PartitionContext.StartingSector=PartitionOffset + StartingSector;

                return ESUCCESS;
            }
        }

        //
        //  If requested partition was not yet found.
        //  Look for an extended partition.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        PartitionOffset = 0;

        for (PartitionIndex=0;
            PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
            PartitionIndex++,Partition++) {

            if (IsContainerPartition(Partition->PartitionType)) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionOffset = VolumeOffset+StartingSector;

                if (PrimaryPartitionTable) {
                    VolumeOffset = StartingSector;
                }

                break;      // only one partition can be extended.
            }
        }

        PrimaryPartitionTable = FALSE;
    } while (PartitionOffset != 0);
    
    return EBADF;
}

#if 0

VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This routine takes a DOS drive name ("A:" "B:" "C:" etc.) and translates
    it into an ARC name.  ("multi(0)disk(0)rdisk(0)partition(1)")

    N.B.    This will always return some sort of name suitable for passing
            to BiosPartitionOpen.  The name it constructs may not be an
            actual partition.  BiosPartitionOpen is responsible for
            determining whether the partition actually exists.

            Since no other driver should ever use ARC names beginning with
            "multi(0)disk(0)..." this will not be a problem.  (there is no
            way this routine will construct a name that BiosPartitionOpen
            will not open, but some other random driver will grab and
            successfully open)

Arguments:

    DosName - Supplies the DOS name of the drive.

    ArcName - Returns the ARC name of the drive.

Return Value:

--*/

{
    ARC_STATUS Status;
    ULONG DriveId;
    ULONG PartitionNumber;
    ULONG PartitionCount;
    ULONG Count;
    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionIndex;
    BOOLEAN HasPrimary;
    LARGE_INTEGER SeekPosition;

    //
    // Eliminate the easy ones first.
    //    A: is always "multi(0)disk(0)fdisk(0)partition(0)"
    //    B: is always "multi(0)disk(0)fdisk(1)partition(0)"
    //    C: is always "multi(0)disk(0)rdisk(0)partition(1)"
    //

    if (_stricmp(DosName,"A:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(0)partition(0)");
        return;
    }
    if (_stricmp(DosName,"B:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(1)partition(0)");
        return;
    }
    if (_stricmp(DosName,"C:")==0) {
        strcpy(ArcName,"multi(0)disk(0)rdisk(0)partition(1)");
        return;
    }

    //
    // Now things get more unpleasant.  If there are two drives, then
    // D: is the primary partition on the second drive.  Successive letters
    // are the secondary partitions on the first drive, then back to the
    // second drive when that runs out.
    //
    // The exception to this is when there is no primary partition on the
    // second drive.  Then, we letter the partitions on the first driver
    // consecutively, and when those partitions run out, we letter the
    // partitions on the second drive.
    //
    // I have no idea who came up with this wonderful scheme, but we have
    // to live with it.
    //

    //
    // Try to open the second drive.  If this doesn't work, we only have
    // one drive and life is easy.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId );

    if (Status != ESUCCESS) {

        //
        // We only have one drive, so whatever drive letter he's requesting
        // has got to be on it.
        //

        sprintf(ArcName,
                "multi(0)disk(0)rdisk(0)partition(%d)",
                toupper(DosName[0]) - 'C' + 1 );

        return;
    } else {

        //
        // Now we read the partition table off the second drive, so we can
        // tell if there is a primary partition or not.
        //
        SeekPosition.QuadPart = 0;

        Status = ArcSeek(DriveId,
                         &SeekPosition,
                         SeekAbsolute);
        if (Status != ESUCCESS) {
            ArcName[0]='\0';
            return;
        }

        Status = ArcRead(DriveId, DataBuffer, SECTOR_SIZE, &Count);
        ArcClose(DriveId);

        if (Status != ESUCCESS) {
            ArcName[0] = '\0';
            return;
        }

        HasPrimary = FALSE;

        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex = 0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {
            if (IsRecognizedPartition(Partition->PartitionType)) {
                HasPrimary = TRUE;
            }
        }

        //
        // Now we have to go through and count
        // the partitions on the first drive.  We do this by just constructing
        // ARC names for each successive partition until one BiosPartitionOpen
        // call fails.
        //

        PartitionCount = 0;
        do {
            ++PartitionCount;
            sprintf(ArcName,
                    "multi(0)disk(0)rdisk(0)partition(%d)",
                    PartitionCount+1);

            Status = BiosPartitionOpen( ArcName,
                                        ArcOpenReadOnly,
                                        &DriveId );

            if (Status==ESUCCESS) {
                BiosPartitionClose(DriveId);
            }
        } while ( Status == ESUCCESS );

        PartitionNumber = toupper(DosName[0])-'C' + 1;

        if (HasPrimary) {

            //
            // There is Windows NT primary partition on the second drive.
            //
            // If the DosName is "D:" then we know
            // this is the first partition on the second drive.
            //

            if (_stricmp(DosName,"D:")==0) {
                strcpy(ArcName,"multi(0)disk(0)rdisk(1)partition(1)");
                return;
            }

            if (PartitionNumber-1 > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber-1);
            }

        } else {

            //
            // There is no primary partition on the second drive, so we
            // consecutively letter the partitions on the first drive,
            // then the second drive.
            //

            if (PartitionNumber > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber);
            }

        }


        return;
    }
}
#endif


VOID
FwStallExecution(
    IN ULONG Microseconds
    )

/*++

Routine Description:

    Does a busy wait for a specified number of microseconds (very approximate!)

Arguments:

    Microseconds - Supplies the number of microseconds to busy wait.

Return Value:

    None.

--*/

{
    extern EFI_SYSTEM_TABLE *EfiST;
    EfiST->BootServices->Stall( Microseconds );
}


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{
    return(BlGetPathMnemonicKey(OpenPath,Mnemonic,Key));
}


PCONFIGURATION_COMPONENT
FwAddChild (
    IN PCONFIGURATION_COMPONENT Component,
    IN PCONFIGURATION_COMPONENT NewComponent,
    IN PVOID ConfigurationData OPTIONAL
    )
{
    ULONG Size;
    PCONFIGURATION_COMPONENT_DATA NewEntry;
    PCONFIGURATION_COMPONENT_DATA Parent;

    if (Component==NULL) {
        return(NULL);
    }

    Parent = CONTAINING_RECORD(Component,
                               CONFIGURATION_COMPONENT_DATA,
                               ComponentEntry);

    Size = sizeof(CONFIGURATION_COMPONENT_DATA) +
           NewComponent->IdentifierLength + 1;

    NewEntry = BlAllocateHeap(Size);
    if (NewEntry==NULL) {
        return(NULL);
    }

    RtlCopyMemory(&NewEntry->ComponentEntry,
                  NewComponent,
                  sizeof(CONFIGURATION_COMPONENT));
    NewEntry->ComponentEntry.Identifier = (PUCHAR)(NewEntry+1);
    NewEntry->ComponentEntry.ConfigurationDataLength = 0;
    strncpy(NewEntry->ComponentEntry.Identifier,
            NewComponent->Identifier,
            NewComponent->IdentifierLength);

    //
    // Add the new component as the first child of its parent.
    //
    NewEntry->Child = NULL;
    NewEntry->Sibling = Parent->Child;
    Parent->Child = NewEntry;

    return(&NewEntry->ComponentEntry);

}

PCONFIGURATION_COMPONENT
FwGetComponent(
    IN PCHAR Pathname
    )
{
    PCONFIGURATION_COMPONENT Component;
    PCONFIGURATION_COMPONENT MatchComponent;
    PCHAR PathString;
    PCHAR MatchString;
    PCHAR Token;
    ULONG Key;

    PathString = Pathname;

    //
    // Get the the root component.
    //

    MatchComponent = FwGetChild(NULL);

    //
    // Repeat search for each new match component.
    //

    do {

        //
        // Get the first child of the current match component.
        //

        Component = FwGetChild( MatchComponent );

        //
        // Search each child of the current match component for the next match.
        //

        while ( Component != NULL ) {

            //
            // Reset Token to be the current position on the pathname.
            //

            Token = PathString;

            MatchString = MnemonicTable[Component->Type];

            //
            // Compare strings.
            //

            while (*MatchString == tolower(*Token)) {
                MatchString++;
                Token++;
            }

            //
            // Strings compare if the first mismatch is the terminator for
            // each.
            //

            if ((*MatchString == 0) && (*Token == '(')) {

                //
                // Form key.
                //

                Key = 0;
                Token++;
                while ((*Token != ')') && (*Token != 0)) {
                    Key = (Key * 10) + *Token++ - '0';
                }

                //
                // If the key matches the component matches, so update
                // pointers and break.
                //

                if (Component->Key == Key) {
                    PathString = Token + 1;
                    MatchComponent = Component;
                    break;
                }
            }

            Component = FwGetPeer( Component );
        }

    } while ((Component != NULL) && (*PathString != 0));

    return MatchComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\biosdrv.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.h

Abstract:

    This module defines globally used procedure and data structures used be
    the ARC emulation BIOS drivers.

Author:

    John Vert (jvert) 8-Aug-1991

Revision History:

    Allen Kay (akay) 26-Jan-1996          Ported for IA64

--*/


//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_CSI 0x9B
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80

//
// Define special key input values
//
#define DOWN_ARROW 0x5000
#define UP_ARROW 0x4800
#define HOME_KEY 0x4700
#define END_KEY 0x4F00



//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );


ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );

ULONG
GetDriveCount(
    VOID
    );

EFI_HANDLE
GetCd(
    );

EFI_HANDLE
GetHardDrive(
    ULONG DriveId
    );

EFI_HANDLE
GetFloppyDrive(
    ULONG DriveId
    );


//
// constants for BlGetDriveId.DriveType
//
#define BL_DISKTYPE_ATAPI               0x00000001
#define BL_DISKTYPE_SCSI                0x00000002
#define BL_DISKTYPE_UNKNOWN             0x00000003


ULONG
BlGetDriveId(
    ULONG DriveType,
    PBOOT_DEVICE Device
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\entry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    EFI specific startup for os loaders

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#if defined(_IA64_)
#include "bootia64.h"
#endif

#include "biosdrv.h"

#include "efi.h"
#include "stdio.h"
#include "flop.h"

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif

extern VOID AEInitializeStall();

//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;

BOOLEAN GoneVirtual = FALSE;
//
// Prototypes for Internal Routines
//

VOID
DoGlobalInitialization(
    PBOOT_CONTEXT
    );

#if defined(ELTORITO)
BOOLEAN ElToritoCDBoot = FALSE;
#endif

extern CHAR NetBootPath[];

//
// Global context pointers. These are passed to us by the SU module or
// the bootstrap code.
//

PCONFIGURATION_COMPONENT_DATA FwConfigurationTree = NULL;
PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
UCHAR BootPartitionName[129];
ULONG FwHeapUsed = 0;
#if defined(NEC_98)
ULONG Key;
int ArrayDiskStartOrdinal = -1;
BOOLEAN BootedFromArrayDisk = FALSE;
BOOLEAN HyperScsiAvalable = FALSE;
#endif //NEC_98
ULONG MachineType = 0;
LONG_PTR OsLoaderBase;
LONG_PTR OsLoaderExports;
extern PUCHAR BlpResourceDirectory;
extern PUCHAR BlpResourceFileOffset;

#if DBG

extern EFI_SYSTEM_TABLE        *EfiST;
#define DBG_TRACE(_X) EfiST->ConOut->OutputString(EfiST->ConOut, (_X))

#else

#define DBG_TRACE(_X) 

#endif // for FORCE_CD_BOOT

VOID
NtProcessStartup(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    Main entry point for setup loader. Control is transferred here by the
    start-up (SU) module.

Arguments:

    BootContextRecord - Supplies the boot context, particularly the
        ExternalServicesTable.

Returns:

    Does not return. Control eventually passed to the kernel.


--*/
{
    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    ARC_STATUS Status;

    DBG_TRACE(L"NtProcessStart: Entry\r\n");
    
    //
    // Initialize the boot loader's video
    //

    DoGlobalInitialization(BootContextRecord);

    BlFillInSystemParameters(BootContextRecord);

    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //

    DBG_TRACE( L"NtProcessStartup:about to BlMemoryInitialize\r\n");

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        DBG_TRACE(TEXT("Couldn't initialize memory\r\n"));
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


#ifdef FORCE_CD_BOOT
    DBG_TRACE(L"Forcing BootMediaCdrom\r\n");    
    BootContextRecord->MediaType = BootMediaCdrom;
#endif // for FORCE_CD_BOOT    
    
    if (BootContextRecord->MediaType == BootMediaFloppyDisk) {

        //
        // Boot was from A:
        //

        BootDeviceFloppy = (PBOOT_DEVICE_FLOPPY) &(BootContextRecord->BootDevice);
        sprintf(BootPartitionName,
                "multi(0)disk(0)fdisk(%u)",
                BootDeviceFloppy->DriveNumber);

    } else if (BootContextRecord->MediaType == BootMediaTcpip) {

        //
        // Boot was from the net
        //
        strcpy(BootPartitionName,"net(0)");
        BlBootingFromNet = TRUE;

#if defined(ELTORITO)
    } else if (BootContextRecord->MediaType == BootMediaCdrom) {

#ifdef FORCE_CD_BOOT
        sprintf(BootPartitionName,
                "multi(0)disk(0)cdrom(%u)",
                0
                );
                
        ElToritoCDBoot = TRUE;
#else
        //
        // Boot was from El Torito CD
        //
        if( BootContextRecord->BusType == BootBusAtapi ) {
            BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    BootDeviceAtapi->Lun);
        } else if( BootContextRecord->BusType == BootBusScsi ) {
            BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    BootDeviceScsi->Lun);
        } else if( BootContextRecord->BusType == BootBusVendor ) {
            BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    0 
                    );
        }
        ElToritoCDBoot = TRUE;
#endif // for FORCE_CD_BOOT
#endif // for ELTORITO

    } else {
        //
        // Find the partition we have been booted from.  Note that this
        // is *NOT* necessarily the active partition.  If the system has
        // Boot Mangler installed, it will be the active partition, and
        // we have to go figure out what partition we are actually on.
        //
        if (BootContextRecord->BusType == BootBusAtapi) {
            BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_ATAPI, (PBOOT_DEVICE)BootDeviceAtapi), // BootDeviceAtapi->Lun,
                    BootContextRecord->PartitionNumber);
        } else if (BootContextRecord->BusType == BootBusScsi) {
            BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "scsi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_SCSI, (PBOOT_DEVICE)BootDeviceScsi), //BootDeviceScsi->Pun, 
                    BootContextRecord->PartitionNumber);
        } else if (BootContextRecord->BusType == BootBusVendor) {
            BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_UNKNOWN, (PBOOT_DEVICE)BootDeviceUnknown), //BootDeviceUnknown->LegacyDriveLetter & 0x7F, 
                    BootContextRecord->PartitionNumber);
        }
    }
    
    //
    // Initialize the OS loader I/O system.
    //

    AEInitializeStall();

    FlipToPhysical();
    DBG_TRACE( L"NtProcessStartup:about to Init I/O\r\n");
    FlipToVirtual();
    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
#if DBG
        BlPrint(TEXT("Couldn't initialize I/O\r\n"));
#endif
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
    
    //
    // Call off to regular startup code
    //
    FlipToPhysical();
    DBG_TRACE( L"NtProcessStartup:about to call BlStartup\r\n");
    FlipToVirtual();

    BlStartup(BootPartitionName);    

    //
    // we should never get here!
    //
    do {
        GET_KEY();
    } while ( 1 );

}


VOID
DoGlobalInitialization(
    IN PBOOT_CONTEXT BootContextRecord
    )

/*++

Routine Description

    This routine calls all of the subsytem initialization routines.


Arguments:

    None

Returns:

    Nothing

--*/

{
    ARC_STATUS Status;

    //
    // Set base address of OS Loader image for the debugger.
    //

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;

    //
    // Initialize memory.
    //

    Status = InitializeMemorySubsystem(BootContextRecord);
    if (Status != ESUCCESS) {
#if DBG
        BlPrint(TEXT("InitializeMemory failed %lx\r\n"),Status);
#endif
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
    ExternalServicesTable=BootContextRecord->ExternalServicesTable;
    MachineType = (ULONG) BootContextRecord->MachineType;

    //
    // Turn the cursor off
    //
    // bugbug EFI
    //HW_CURSOR(0,127);

    FlipToPhysical();
    DBG_TRACE( L"DoGlobalInitialization: cursor off\r\n");
    EfiST->ConOut->EnableCursor(EfiST->ConOut, FALSE);
    FlipToVirtual();

    BlpResourceDirectory = (PUCHAR)(BootContextRecord->ResourceDirectory);
    BlpResourceFileOffset = (PUCHAR)(BootContextRecord->ResourceOffset);

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\arctree.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    config.c

Abstract:

    Make a few ARC entries needed for NTLDR/ntoskrnl to boot.

Author:

    Allen Kay (akay) 26-Oct-98

Revision History:

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "string.h"
#include "pci.h"
#include "ntacpi.h"
#include "acpitabl.h"

#include "efi.h"
#include "biosdrv.h"

//
// External Data
//
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;
extern PVOID AcpiTable;

//
// Defines
//

#define LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define EDGE_TRIGGERED CM_RESOURCE_INTERRUPT_LATCHED
#define RESOURCE_PORT 1
#define RESOURCE_INTERRUPT 2
#define RESOURCE_MEMORY 3
#define RESOURCE_DMA 4
#define RESOURCE_DEVICE_DATA 5
#define ALL_PROCESSORS 0xffffffff

//
// Internal references and definitions.
//

typedef enum _RELATIONSHIP_FLAGS {
    Child,
    Sibling,
    Parent
} RELATIONSHIP_FLAGS;

//
// Hard Disk Drive
//
#define SIZE_OF_PARAMETER    12     // size of disk params
#define MAX_DRIVE_NUMBER     8      // max number of drives
#define RESOURCE_DEVICE_DATA 5
#define RESERVED_ROM_BLOCK_LIST_SIZE (((0xf0000 - 0xc0000)/512) * sizeof(CM_ROM_BLOCK))
#define DATA_HEADER_SIZE sizeof(CM_PARTIAL_RESOURCE_LIST)

typedef CM_PARTIAL_RESOURCE_DESCRIPTOR HWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR *PHWPARTIAL_RESOURCE_DESCRIPTOR;

typedef CM_PARTIAL_RESOURCE_LIST HWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST *PHWRESOURCE_DESCRIPTOR_LIST;

//
// Defines the structure to store controller information
// (used by ntdetect internally)
//

#define MAXIMUM_DESCRIPTORS 10

typedef struct _HWCONTROLLER_DATA {
    UCHAR NumberPortEntries;
    UCHAR NumberIrqEntries;
    UCHAR NumberMemoryEntries;
    UCHAR NumberDmaEntries;
    HWPARTIAL_RESOURCE_DESCRIPTOR DescriptorList[MAXIMUM_DESCRIPTORS];
} HWCONTROLLER_DATA, *PHWCONTROLLER_DATA;


//
// Hard Disk Defines
//
#pragma pack(1)
typedef struct _HARD_DISK_PARAMETERS {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} HARD_DISK_PARAMETERS, *PHARD_DISK_PARAMETERS;
#pragma pack()

PUCHAR PRomBlock = NULL;
USHORT RomBlockLength = 0;
USHORT NumberBiosDisks;

#if defined(_INCLUDE_LOADER_KBINFO_)
//
// Keyboard defines
//

//
// String table to map keyboard id to an ascii string.
//

#define UNKNOWN_KEYBOARD  0
#define OLI_83KEY         1
#define OLI_102KEY        2
#define OLI_86KEY         3
#define OLI_A101_102KEY   4
#define XT_83KEY          5
#define ATT_302           6
#define PCAT_ENHANCED     7
#define PCAT_86KEY        8
#define PCXT_84KEY        9

PUCHAR KeyboardIdentifier[] = {
    "UNKNOWN_KEYBOARD",
    "OLI_83KEY",
    "OLI_102KEY",
    "OLI_86KEY",
    "OLI_A101_102KEY",
    "XT_83KEY",
    "ATT_302",
    "PCAT_ENHANCED",
    "PCAT_86KEY",
    "PCXT_84KEY"
    };

UCHAR KeyboardType[] = {
    -1,
    1,
    2,
    3,
    4,
    1,
    1,
    4,
    3,
    1
    };

UCHAR KeyboardSubtype[] = {
    -1,
    0,
    1,
    10,
    4,
    42,
    4,
    0,
    0,
    0
    };
#endif  // _INCLUDE_LOADER_KBINFO_

#if defined(_INCLUDE_LOADER_MOUSEINFO_)
//
// Mouse Defines
//

typedef struct _MOUSE_INFORMATION {
        UCHAR MouseType;
        UCHAR MouseSubtype;
        USHORT MousePort;       // if serial mouse, 1 for com1, 2 for com2 ...
        USHORT MouseIrq;
        USHORT DeviceIdLength;
        UCHAR  DeviceId[10];
} MOUSE_INFORMATION, *PMOUSE_INFORMATION;

//
// Mouse Type definitions
//

#define UNKNOWN_MOUSE   0
#define NO_MOUSE        0x100             // YES! it is 0x100 *NOT* 0x10000

#define MS_MOUSE        0x200             // MS regular mouses
#define MS_BALLPOINT    0x300             // MS ballpoint mouse
#define LT_MOUSE        0x400             // Logitec Mouse

//
// note last 4 bits of the subtype are reserved subtype specific use
//

#define PS2_MOUSE       0x1
#define SERIAL_MOUSE    0x2
#define INPORT_MOUSE    0x3
#define BUS_MOUSE       0x4
#define PS_MOUSE_WITH_WHEEL     0x5
#define SERIAL_MOUSE_WITH_WHEEL 0x6

PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH"
    };

PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL"
    };

//
// The following table translates keyboard make code to
// ascii code.  Note, only 0-9 and A-Z are translated.
// Everything else is translated to '?'
//

UCHAR MakeToAsciiTable[] = {
    0x3f, 0x3f, 0x31, 0x32, 0x33,      // ?, ?, 1, 2, 3,
    0x34, 0x35, 0x36, 0x37, 0x38,      // 4, 5, 6, 7, 8,
    0x39, 0x30, 0x3f, 0x3f, 0x3f,      // 9, 0, ?, ?, ?,
    0x3f, 0x51, 0x57, 0x45, 0x52,      // ?, Q, W, E, R,
    0x54, 0x59, 0x55, 0x49, 0x4f,      // T, Y, U, I, O,
    0x50, 0x3f, 0x3f, 0x3f, 0x3f,      // P, ?, ?, ?, ?,
    0x41, 0x53, 0x44, 0x46, 0x47,      // A, S, D, F, G,
    0x48, 0x4a, 0x4b, 0x4c, 0x3f,      // H, J, K, L, ?,
    0x3f, 0x3f, 0x3f, 0x3f, 0x5a,      // ?, ?, ?, ?, Z,
    0x58, 0x43, 0x56, 0x42, 0x4e,      // X, C, V, B, N,
    0x4d};                             // W

#define MAX_MAKE_CODE_TRANSLATED 0x32
static ULONG MouseControllerKey = 0;

#endif  // _INCLUDE_LOADER_MOUSEINFO_

//
// ComPortAddress[] is a global array to remember which comports have
// been detected and their I/O port addresses.
//

#define MAX_COM_PORTS   4           // Max. number of comports detectable
#define MAX_LPT_PORTS   3           // Max. number of LPT ports detectable

#if 0 //unused
USHORT   ComPortAddress[MAX_COM_PORTS] = {0, 0, 0, 0};
#endif

//
// Global Definition
//

#if defined(_INCLUDE_LOADER_MOUSEINFO_) || defined(_INCLUDE_LOADER_KBINFO_)
USHORT HwBusType = 0;
#endif

PCONFIGURATION_COMPONENT_DATA AdapterEntry = NULL;

//
// Function Prototypes
//

#if defined(_INCLUDE_LOADER_KBINFO_)

PCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    IN USHORT KeyboardId
    );

#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)

PCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    );

#endif

PCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    );

PVOID
HwSetUpResourceDescriptor (
    PCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    );

VOID
HwSetUpFreeFormDataHeader (
    PHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    );




BuildArcTree(
     )
/*++

Routine Description:

    Main entrypoint of the HW recognizer test.  The routine builds
    a configuration tree and leaves it in the hardware heap.

Arguments:

    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
        receive the hardware configuration tree.

Returns:

    None.

--*/
{
    PCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    PCONFIGURATION_COMPONENT_DATA FirstCom = NULL, FirstLpt = NULL;
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    PCONFIGURATION_COMPONENT_DATA AcpiAdapterEntry = NULL;
    PCONFIGURATION_COMPONENT Component;
    RELATIONSHIP_FLAGS NextRelationship;
    CHAR Identifier[256];
    PUCHAR MachineId;
    USHORT KeyboardId = 0;
    USHORT Length, InitialLength, i, j, Count = 0;
    PCHAR IdentifierString;
    PHARD_DISK_PARAMETERS RomChain;
    PUCHAR PRomChain = NULL, ConfigurationData, EndConfigurationData;
    SHORT FreeSize;
    PHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    PCI_REGISTRY_INFO PciEntry;
    PACPI_BIOS_MULTI_NODE AcpiMultiNode;
    PUCHAR Current;
    PRSDP rsdp;

    //
    // Allocate heap space for System component and initialize it.
    // Also make the System component the root of configuration tree.
    //

    ConfigurationRoot = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                        sizeof(CONFIGURATION_COMPONENT_DATA));
    Component = &ConfigurationRoot->ComponentEntry;

    Component->Class = SystemClass;
    Component->Type = MaximumType;          // NOTE should be IsaCompatible
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0;
    Component->ConfigurationDataLength = 0;
    MachineId = "Intel Itanium processor family";
    if (MachineId) {
        Length = strlen(MachineId) + 1;
        IdentifierString = (PCHAR)BlAllocateHeap(Length);
        strcpy(IdentifierString, MachineId);
        Component->Identifier = IdentifierString;
        Component->IdentifierLength = Length;
    } else {
        Component->Identifier = 0;
        Component->IdentifierLength = 0;
    }
    NextRelationship = Child;
    PreviousEntry = ConfigurationRoot;


    //
    // ISA
    //
    AdapterEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &AdapterEntry->ComponentEntry;

    Component->Class = AdapterClass;

    Component->Type = MultiFunctionAdapter;
    strcpy(Identifier, "ISA");

    Length = strlen(Identifier) + 1;
    IdentifierString = (PCHAR)BlAllocateHeap(Length);
    strcpy(IdentifierString, Identifier);
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    //
    // Make Adapter component System's child
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

    //
    // Collect BIOS information for ConfigurationRoot component.
    // This step is done here because we need data collected in
    // adapter component.  The ConfigurationData is:
    //      HWRESOURCE_DESCRIPTOR_LIST header
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Parameter Table
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Rom Blocks.
    // (Note DATA_HEADER_SIZE contains the size of the first partial
    //  descriptor already.)
    //

#if DBG
    BlPrint(TEXT("Collecting Disk Geometry...\r\n"));
#endif

    RomChain = (PHARD_DISK_PARAMETERS)
               BlAllocateHeap(SIZE_OF_PARAMETER * MAX_DRIVE_NUMBER);

#if 0
    RomChain[0].DriveSelect = 0x80;
    RomChain[0].MaxCylinders = 0;
    RomChain[0].SectorsPerTrack = 0;
    RomChain[0].MaxHeads = 0;
    RomChain[0].NumberDrives = 1;               // Gambit only access 1 drive

    NumberBiosDisks = 1;                        // was defined in diska.asm
#endif

    InitialLength = (USHORT)(Length + RESERVED_ROM_BLOCK_LIST_SIZE + DATA_HEADER_SIZE +
                    sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    ConfigurationData = (PUCHAR)BlAllocateHeap(InitialLength);
    EndConfigurationData = ConfigurationData + DATA_HEADER_SIZE;
    if (Length != 0) {
        PRomChain = EndConfigurationData;
        RtlCopyMemory( PRomChain, (PVOID)RomChain, Length);
    }
    EndConfigurationData += (sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                             Length);
    HwSetUpFreeFormDataHeader((PHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              Length
                              );


    //
    // Scan ROM to collect all the ROM blocks, if possible.
    //

#if DBG
    BlPrint(TEXT("Constructing ROM Blocks...\r\n"));
#endif

    PRomBlock = EndConfigurationData;
    Length = 0;
    RomBlockLength = Length;
    if (Length != 0) {
        EndConfigurationData += Length;
    } else {
        PRomBlock = NULL;
    }

    //
    // We have both RomChain and RomBlock information/Headers.
    //

    DescriptorList = (PHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData;
    DescriptorList->Count = 2;
    Descriptor = (PHWPARTIAL_RESOURCE_DESCRIPTOR)(
                 EndConfigurationData - Length -
                 sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    Descriptor->Type = RESOURCE_DEVICE_DATA;
    Descriptor->ShareDisposition = 0;
    Descriptor->Flags = 0;
    Descriptor->u.DeviceSpecificData.DataSize = (ULONG)Length;
    Descriptor->u.DeviceSpecificData.Reserved1 = 0;
    Descriptor->u.DeviceSpecificData.Reserved2 = 0;

    Length = (USHORT)(EndConfigurationData - ConfigurationData);
    ConfigurationRoot->ComponentEntry.ConfigurationDataLength = Length;
    ConfigurationRoot->ConfigurationData = ConfigurationData;
    FreeSize = InitialLength - Length;

#if defined(_INCLUDE_LOADER_KBINFO_)

//#if defined(NO_ACPI)
    //
    // Set up device information structure for Keyboard.
    //

#if DBG
    BlPrint(TEXT("Constructing Keyboard Component ...\r\n"));
#endif

    KeyboardId = 7;           // PCAT_ENHANCED

    CurrentEntry = SetKeyboardConfigurationData(KeyboardId);

    //
    // Make display component the child of Adapter component.
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
#endif  // _INCLUDE_LOADER_MOUSEINFO_

    //
    // Set up device information for com port
    //

#if defined(_INCLUDE_COMPORT_INFO_)
    //
    // This code was taken out because the GetComportInformation() routine
    // was manufacturing data about the com port and writing the com port
    // address to 40:0.  This information should be determined by PnP
    //

#if DBG
    BlPrint(TEXT("Constructing ComPort Component ...\r\n"));
#endif

    if (CurrentEntry = GetComportInformation()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
        } else {
            PreviousEntry->Child = CurrentEntry;
        }
        while (CurrentEntry) {
            CurrentEntry->Parent = AdapterEntry;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }
#else
    
//    DbgPrint("Skipping ComPort Component ...\r\n");

    //
    // acpi node should be a sibling of adapter entry
    //
    // Note: this only works if !defined(_INCLUDE_LOADER_MOUSEINFO_)
    //
    NextRelationship = Sibling;
    PreviousEntry = AdapterEntry;
#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)
    //
    // Set up device information structure for Mouse.
    //

#if DBG
    BlPrint(TEXT("Constructing Mouse Component ...\r\n"));
#endif

    if (CurrentEntry = GetMouseInformation
        ()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }
//#endif    // NO_ACPI
#endif  // _INCLUDE_LOADER_MOUSEINFO_

    //DbgPrint("Constructing ACPI Bus Component ...\n");

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                          sizeof(CONFIGURATION_COMPONENT_DATA));

    Current = (PCHAR) BlAllocateHeap( DATA_HEADER_SIZE +
                                      sizeof(ACPI_BIOS_MULTI_NODE) );
    AcpiMultiNode = (PACPI_BIOS_MULTI_NODE) (Current + DATA_HEADER_SIZE);

    //DbgPrint("AcpiTable: %p\n", AcpiTable);

    if (AcpiTable) {

        rsdp = (PRSDP) AcpiTable;
        AcpiMultiNode->RsdtAddress.QuadPart = rsdp->XsdtAddress.QuadPart;

    }

    CurrentEntry->ConfigurationData = Current;

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = Length;

    Component->Class = AdapterClass;
    Component->Type = MultiFunctionAdapter;

    strcpy (Identifier, "ACPI BIOS");
    i = strlen(Identifier) + 1;
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    HwSetUpFreeFormDataHeader(
            (PHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
            0,
            0,
            0,
            Length - DATA_HEADER_SIZE
            );

    //
    // Add it to tree
    //

#if defined(_INCLUDE_COMPORT_INFO_)

    //
    // Note: this assumes the previousentry is a child of the AdapterEntry,
    //       typically, this would be the comport info node
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Parent->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent->Parent;
    }
    NextRelationship = Sibling;

#else

    //
    // ACPI BIOS node is a sibling of AdapterEntry
    //
    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    }
    
    //
    // ARC disk info node must be child of adapter entry
    //
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

#endif

#if 0
    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
#endif

    //
    // First entry created to make BlGetArcDiskInformation() happy
    //

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = ControllerClass;
    Component->Type = DiskController;

    strcpy (Identifier, "Controller Class Entry For Hard Disk");
    i = strlen(Identifier) + 1;
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = CurrentEntry;

    //
    // Looks for disks on system and add them.
    //
    for( j=0; j<GetDriveCount(); j++ ) {
        CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

        Component = &CurrentEntry->ComponentEntry;
        Component->ConfigurationDataLength = 0;

        Component->Class = PeripheralClass;
        Component->Type = DiskPeripheral;

        strcpy (Identifier, "Peripheral Class Entry For Hard Disk");
        i = strlen(Identifier) + 1;
        IdentifierString = (PCHAR)BlAllocateHeap(i);
        strcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = j;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        //
        // Add it to tree
        //
        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }

    //
    // add an entry for the floppy disk peripheral
    //
    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = PeripheralClass;
    Component->Type = FloppyDiskPeripheral;

    strcpy (Identifier, "Peripheral Class Entry For Floppy Disk");
    i = strlen(Identifier) + 1;
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
    
    //
    // add another entry for the floppy disk peripheral 
    // for virtual floppy support
    //
    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = PeripheralClass;
    Component->Type = FloppyDiskPeripheral;

    strcpy (Identifier, "Peripheral Class Entry For Floppy Disk");
    i = strlen(Identifier) + 1;
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 1;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    
    NextRelationship = Child;
    PreviousEntry = CurrentEntry;

    //
    // Done
    //
    FwConfigurationTree = (PCONFIGURATION_COMPONENT_DATA) ConfigurationRoot;
}

#if defined(_INCLUDE_LOADER_KBINFO_)

PCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    USHORT KeyboardId
    )

/*++

Routine Description:

    This routine maps Keyboard Id information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    KeyboardId - Supplies a USHORT which describes the keyboard id information.

    Buffer - Supplies a pointer to a buffer where to put the ascii.

Returns:

    None.

--*/
{
    PCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    PHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CM_KEYBOARD_DEVICE_DATA *KeyboardData;
    USHORT z, Length;

    //
    // Set up Keyboard COntroller component
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    Controller = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                 sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = KeyboardController;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 2;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x60;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x64;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    ControlData.DescriptorList[z].u.Interrupt.Level = 1;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 1;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {

        //
        // For EISA the LevelTriggered is temporarily set to FALSE.
        //

        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }

    Controller->ConfigurationData =
                        HwSetUpResourceDescriptor(Component,
                                                  NULL,
                                                  &ControlData,
                                                  0,
                                                  NULL
                                                  );

    //
    // Set up Keyboard peripheral component
    //

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = KeyboardPeripheral;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = (PVOID)NULL;
    Length = strlen(KeyboardIdentifier[KeyboardId]) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = BlAllocateHeap(Length);
    strcpy(Component->Identifier, KeyboardIdentifier[KeyboardId]);

    if (KeyboardId != UNKNOWN_KEYBOARD) {

        Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                 sizeof(CM_KEYBOARD_DEVICE_DATA);
        DescriptorList = (PHWRESOURCE_DESCRIPTOR_LIST)BlAllocateHeap(Length);
        CurrentEntry->ConfigurationData = DescriptorList;
        Component->ConfigurationDataLength = Length;
        DescriptorList->Count = 1;
        DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
        DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                    sizeof(CM_KEYBOARD_DEVICE_DATA);
        KeyboardData = (CM_KEYBOARD_DEVICE_DATA *)(DescriptorList + 1);
        KeyboardData->KeyboardFlags = 0;
        KeyboardData->Type = KeyboardType[KeyboardId];
        KeyboardData->Subtype = KeyboardSubtype[KeyboardId];
    }

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;
    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}

#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)

PCONFIGURATION_COMPONENT_DATA
SetMouseConfigurationData (
    PMOUSE_INFORMATION MouseInfo,
    PCONFIGURATION_COMPONENT_DATA MouseList
    )

/*++

Routine Description:

    This routine fills in mouse configuration data.

Arguments:

    MouseInfo - Supplies a pointer to the MOUSE_INFOR structure

    MouseList - Supplies a pointer to the existing mouse component list.

Returns:

    Returns a pointer to our mice controller list.

--*/
{
    UCHAR i = 0;
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, Controller, PeripheralEntry;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    USHORT z, Length;
    PUCHAR pString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // If it is not SERIAL_MOUSE, set up controller component
        //

        Controller = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                     sizeof(CONFIGURATION_COMPONENT_DATA));

        Component = &Controller->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = PointerController;
        Component->Flags.Input = 1;
        Component->Version = 0;
        Component->Key = MouseControllerKey;
        MouseControllerKey++;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;

        //
        // If we have mouse irq or port information, allocate configuration
        // data space for mouse controller component to store these information
        //

        if (MouseInfo->MouseIrq != 0xffff || MouseInfo->MousePort != 0xffff) {

            //
            // Set up port and Irq information
            //

            if (MouseInfo->MousePort != 0xffff) {
                ControlData.NumberPortEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareDeviceExclusive;
                ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                ControlData.DescriptorList[z].u.Port.Start.LowPart =
                                        (ULONG)MouseInfo->MousePort;
                ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                ControlData.DescriptorList[z].u.Port.Length = 4;
                z++;
            }
            if (MouseInfo->MouseIrq != 0xffff) {
                ControlData.NumberIrqEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareUndetermined;
                ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
                ControlData.DescriptorList[z].u.Interrupt.Level =
                                        (ULONG)MouseInfo->MouseIrq;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                        (ULONG)MouseInfo->MouseIrq;
                if (HwBusType == MACHINE_TYPE_MCA) {
                    ControlData.DescriptorList[z].Flags =
                                                        LEVEL_SENSITIVE;
                } else {

                    //
                    // For EISA the LevelTriggered is temporarily set to FALSE.
                    //

                    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                }
            }

            Controller->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          NULL,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

        } else {

            //
            // Otherwise, we don't have configuration data for the controller
            //

            Controller->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;
        }
    }

    //
    // Set up Mouse peripheral component
    //

    PeripheralEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &PeripheralEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = PointerPeripheral;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    PeripheralEntry->ConfigurationData = (PVOID)NULL;

    //
    // If Mouse PnP device id is found, translate it to ascii code.
    // (The mouse device id is presented to us by keyboard make code.)
    //

    Length = 0;
    if (MouseInfo->DeviceIdLength != 0) {
        USHORT i;

        if (MouseInfo->MouseSubtype == PS_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                if (MouseInfo->DeviceId[i] > MAX_MAKE_CODE_TRANSLATED) {
                    MouseInfo->DeviceId[i] = '?';
                } else {
                    MouseInfo->DeviceId[i] = MakeToAsciiTable[MouseInfo->DeviceId[i]];
                }
            }
        } else if (MouseInfo->MouseSubtype == SERIAL_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                MouseInfo->DeviceId[i] += 0x20;
            }
        }
        Length = MouseInfo->DeviceIdLength + 3;
    }
    Length += strlen(MouseIdentifier[MouseInfo->MouseType]) +
              strlen(MouseSubidentifier[MouseInfo->MouseSubtype]) + 1;
    pString = (PUCHAR)BlAllocateHeap(Length);
    if (MouseInfo->DeviceIdLength != 0) {
        strcpy(pString, MouseInfo->DeviceId);
        strcat(pString, " - ");
        strcat(pString, MouseIdentifier[MouseInfo->MouseType]);
    } else {
        strcpy(pString, MouseIdentifier[MouseInfo->MouseType]);
    }
    strcat(pString, MouseSubidentifier[MouseInfo->MouseSubtype]);
    Component->IdentifierLength = Length;
    Component->Identifier = pString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {
        Controller->Child = PeripheralEntry;
        PeripheralEntry->Parent = Controller;
        if (MouseList) {

            //
            // Put the current mouse component to the beginning of the list
            //

            Controller->Sibling = MouseList;
        }
        return(Controller);
    } else {
        CurrentEntry = AdapterEntry->Child; // AdapterEntry MUST have child
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Type == SerialController) {
                if (MouseInfo->MousePort == (USHORT)CurrentEntry->ComponentEntry.Key) {

                    //
                    // For serial mouse, the MousePort field contains
                    // COM port number.
                    //

                    PeripheralEntry->Parent = CurrentEntry;
                    CurrentEntry->Child = PeripheralEntry;
                    break;
                }
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
        return(NULL);
    }
}

PCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    )

/*++

Routine Description:

    This routine is the entry for mouse detection routine.  It will invoke
    lower level routines to detect ALL the mice in the system.

Arguments:

    None.

Returns:

    A pointer to a mouse component structure, if mouse/mice is detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PMOUSE_INFORMATION MouseInfo;
    PCONFIGURATION_COMPONENT_DATA MouseList = NULL;

    MouseInfo = (PMOUSE_INFORMATION)BlAllocateHeap (
                 sizeof(MOUSE_INFORMATION));
    MouseInfo->MouseType = 0x2;            // Microsoft mouse
    MouseInfo->MouseSubtype = PS2_MOUSE;   // PS2 mouse
    MouseInfo->MousePort = 0xffff;         // PS2 mouse port
    MouseInfo->MouseIrq = 0xc;             // Interrupt request vector was 3
    MouseInfo->DeviceIdLength = 0;
    MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    return(MouseList);
}

#endif // _INCLUDE_LOADER_MOUSEINFO_

#if defined(_INCLUDE_COMPORT_INFO_)
    
//
// This code was taken out because the GetComportInformation() routine
// was manufacturing data about the com port and writing the com port
// address to 40:0.  This information should be determined by PnP
//


PCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the comports information
    for the system.  The information includes port address, irq
    level.

    Note that this routine can only detect up to 4 comports and
    it assumes that if MCA, COM3 and COM4 use irq 4.  Otherwise,
    COM3 uses irq 4 and COM4 uses irq 3.  Also, the number of ports
    for COMPORT is set to 8 (for example, COM2 uses ports 2F8 - 2FF)

Arguments:

    None.

Return Value:

    A pointer to a stucture of type CONFIGURATION_COMPONENT_DATA
    which is the root of comport component list.
    If no comport exists, a value of NULL is returned.

--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    PCONFIGURATION_COMPONENT_DATA FirstComport = NULL;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR i, j, z;
    SHORT Port;
    UCHAR ComportName[] = "COM?";
    CM_SERIAL_DEVICE_DATA SerialData;
    ULONG BaudClock = 1843200;
    USHORT Vector;
    USHORT IoPorts[MAX_COM_PORTS] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};


    //
    // BIOS DATA area 40:0 is the port address of the first valid COM port
    //

    USHORT *pPortAddress = (USHORT *)0x00400000;

    //
    // Initialize serial device specific data
    //

    SerialData.Version = 0;
    SerialData.Revision = 0;
    SerialData.BaudClock = 1843200;

    //
    // Initialize Controller data
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    i = 0;

    Port = IoPorts[i];
    *(pPortAddress+i) = (USHORT)Port;


    //
    // Remember the port address in our global variable
    // such that other detection code (e.g. Serial Mouse) can
    // get the information.
    //

#if 0 // unused
    ComPortAddress[i] = Port;
#endif

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));
    if (!FirstComport) {
        FirstComport = CurrentEntry;
    }
    Component = &CurrentEntry->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = SerialController;
    Component->Flags.ConsoleOut = 1;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Output = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = i;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up type string.
    //

    ComportName[3] = i + (UCHAR)'1';

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)Port;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 8;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    //
    // For EISA the LevelTriggered is temporarily set to FALSE.
    // COM1 and COM3 use irq 4; COM2 and COM4 use irq3
    //

    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    if (Port == 0x3f8 || Port == 0x3e8) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 4;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
    } else if (Port == 0x2f8 || Port == 0x2e8) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 3;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
    } else if (i == 0 || i == 2) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 4;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
    } else {
        ControlData.DescriptorList[z].u.Interrupt.Level = 3;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
    }

    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;

    //
    // Try to determine the interrupt vector.  If we success, the
    // new vector will be used to replace the default value.
    //

    CurrentEntry->ConfigurationData =
                    HwSetUpResourceDescriptor(Component,
                                              ComportName,
                                              &ControlData,
                                              sizeof(SerialData),
                                              (PUCHAR)&SerialData
                                              );
    if (PreviousEntry) {
        PreviousEntry->Sibling = CurrentEntry;
    }
    PreviousEntry = CurrentEntry;

    return(FirstComport);
}
#endif


PVOID
HwSetUpResourceDescriptor (
    PCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    )

/*++

Routine Description:

    This routine allocates space from heap , puts the caller's controller
    information to the space and sets up CONFIGURATION_COMPONENT
    structure for the caller.

Arguments:

    Component - Supplies the address the component whose configuration data
                should be set up.

    Identifier - Suppies a pointer to the identifier to identify the controller

    ControlData - Supplies a point to a structure which describes
                controller information.

    SpecificDataLength - size of the device specific data.  Device specific
                data is the information not defined in the standard format.

    SpecificData - Supplies a pointer to the device specific data.


Return Value:

    Returns a pointer to the Configuration data.

--*/

{
    PCHAR pIdentifier;
    PHWRESOURCE_DESCRIPTOR_LIST pDescriptor = NULL;
    USHORT Length;
    SHORT Count, i;
    PUCHAR pSpecificData;

    //
    // Set up Identifier string for hardware component, if necessary.
    //

    if (Identifier) {
        Length = strlen(Identifier) + 1;
        Component->IdentifierLength = Length;
        pIdentifier = (PUCHAR)BlAllocateHeap(Length);
        Component->Identifier = pIdentifier;
        strcpy(pIdentifier, Identifier);
    } else {
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;
    }

    //
    // Set up configuration data for hardware component, if necessary
    //

    Count = ControlData->NumberPortEntries + ControlData->NumberIrqEntries +
            ControlData->NumberMemoryEntries + ControlData->NumberDmaEntries;

    if (SpecificDataLength) {

        //
        // if we have device specific data, we need to increment the count
        // by one.
        //

        Count++;
    }

    if (Count >0) {
        Length = (USHORT)(Count * sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                 FIELD_OFFSET(HWRESOURCE_DESCRIPTOR_LIST, PartialDescriptors) +
                 SpecificDataLength);
        pDescriptor = (PHWRESOURCE_DESCRIPTOR_LIST)BlAllocateHeap(Length);
        pDescriptor->Count = Count;

        //
        // Copy all the partial descriptors to the destination descriptors
        // except the last one. (The last partial descriptor may be a device
        // specific data.  It requires special handling.)
        //

        for (i = 0; i < (Count - 1); i++) {
            pDescriptor->PartialDescriptors[i] =
                                        ControlData->DescriptorList[i];
        }

        //
        // Set up the last partial descriptor.  If it is a port, memory, irq or
        // dma entry, we simply copy it.  If the last one is for device specific
        // data, we set up the length and copy the device spcific data to the end
        // of the decriptor.
        //

        if (SpecificData) {
            pDescriptor->PartialDescriptors[Count - 1].Type =
                            RESOURCE_DEVICE_DATA;
            pDescriptor->PartialDescriptors[Count - 1].Flags = 0;
            pDescriptor->PartialDescriptors[Count - 1].u.DeviceSpecificData.DataSize =
                            SpecificDataLength;
            pSpecificData = (PUCHAR)&(pDescriptor->PartialDescriptors[Count]);
            RtlCopyMemory( pSpecificData, SpecificData, SpecificDataLength);
        } else {
            pDescriptor->PartialDescriptors[Count - 1] =
                            ControlData->DescriptorList[Count - 1];
        }
        Component->ConfigurationDataLength = Length;
    }
    return(pDescriptor);
}

VOID
HwSetUpFreeFormDataHeader (
    PHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    )

/*++

Routine Description:

    This routine initialize free formed data header.  Note this routine
    sets the the Header and initialize the FIRST PartialDescriptor only.
    If the header contains more than one descriptor, the caller must handle
    it itself.

Arguments:

    Header - Supplies a pointer to the header to be initialized.

    Version - Version number for the header.

    Revision - Revision number for the header.

    Flags - Free formed data flags.  (Currently, it is undefined and
                should be zero.)

    DataSize - Size of the free formed data.


Return Value:

    None.

--*/

{

    Header->Version = Version;
    Header->Revision = Revision;
    Header->Count = 1;
    Header->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    Header->PartialDescriptors[0].ShareDisposition = 0;
    Header->PartialDescriptors[0].Flags = Flags;
    Header->PartialDescriptors[0].u.DeviceSpecificData.DataSize = DataSize;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\efidisp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    efidisp.c

Author:

    Create It. 21-Nov-2000 (andrewr)

Abstract:

    This file contains utility routines for manipulating the EFI 
    SIMPLE_CONSOLE_OUTPUT interface

--*/

#include "bldr.h"
#include "bootefi.h"


#include "efi.h"
#include "efip.h"
#include "flop.h"

//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;

extern BOOLEAN GoneVirtual;

BOOLEAN gInverse = FALSE;


ULONG
BlEfiGetLinesPerRow(
    VOID
    )
/*++

Routine Description:

    Gets the number of lines per EFI console row.

Arguments:

    None.
    
Return Value:

    ULONG - number of lines.

--*/
{
    //
    // TODO: read the modes to determine lines/row.
    //
    // for now we just support 80x25
    //
    
    return 25;
}

ULONG
BlEfiGetColumnsPerLine(
    VOID
    )
/*++

Routine Description:

    Gets the number of columns per EFI console line.

Arguments:

    None.
    
Return Value:

    ULONG - number of columns.

--*/
{
    //
    // TODO: read the modes to determine columns/line.
    //
    // for now we just support 80x25
    //
    return 80;
}


BOOLEAN
BlEfiClearDisplay(
    VOID
    )
/*++

Routine Description:

    Clears the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();
    Status = EfiST->ConOut->ClearScreen(EfiST->ConOut);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiClearToEndOfDisplay(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i,j, LinesPerRow,ColumnsPerLine;
    BOOLEAN FirstTime = TRUE;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();

    LinesPerRow = BlEfiGetLinesPerRow();
    ColumnsPerLine = BlEfiGetColumnsPerLine();


    for (i = EfiST->ConOut->Mode->CursorRow; i<= LinesPerRow; i++) {

        j = FirstTime 
             ? EfiST->ConOut->Mode->CursorColumn
             : 0 ;

        FirstTime = FALSE;
        
        for (; j <= ColumnsPerLine; j++) {

            EfiST->ConOut->SetCursorPosition(
                                EfiST->ConOut,
                                i,
                                j);
    
            //
            // outputting a space should clear the current character
            //
            
            EfiST->ConOut->OutputString( EfiST->ConOut,
                                         L" " );
        }

    }

    //
    // flip back into virtual mode and return
    //
    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiClearToEndOfLine(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the line.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i, ColumnsPerLine;
    ULONG x, y;

    ColumnsPerLine = BlEfiGetColumnsPerLine();

    //
    // save current cursor position
    //
    BlEfiGetCursorPosition( &x, &y );
    
    FlipToPhysical();
    for (i = EfiST->ConOut->Mode->CursorColumn; i <= ColumnsPerLine; i++) {
        
        EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            i,
                            EfiST->ConOut->Mode->CursorRow);
        
        //
        // outputting a space should clear the current character
        //
        EfiST->ConOut->OutputString( EfiST->ConOut,
                                     L" " );
    }

    //
    // restore the current cursor position
    //
    EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            x,
                            y );

    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiGetCursorPosition(
    OUT PULONG x, OPTIONAL
    OUT PULONG y OPTIONAL
    )
/*++

Routine Description:

    retrieves the current cursor position

Arguments:

    x - if specified, receives the current cursor column.
    y - if specified, receives the current cursor row.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    FlipToPhysical();

    if (x) {
        *x = EfiST->ConOut->Mode->CursorColumn;
    }

    if (y) {
        *y = EfiST->ConOut->Mode->CursorRow;
    }
        
    FlipToVirtual();

    return(TRUE);

}


BOOLEAN
BlEfiPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )
/*++

Routine Description:

    Sets the current cursor position.

Arguments:

    Column - column to set (x coordinate)
    Row - row to set (y coordinate)
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->SetCursorPosition(EfiST->ConOut,Column,Row);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiEnableCursor(
    BOOLEAN bVisible
    )
/*++

Routine Description:

    Turns on or off the input cursor.

Arguments:

    bVisible - TRUE indicates that the cursor should be made visible.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->EnableCursor( EfiST->ConOut, bVisible );
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiSetAttribute(
    ULONG Attribute
    )
/*++

Routine Description:

    Sets the current attribute for the console.
    
    This routines switches between the ATT_* constants into the EFI_* display
    constants.  Not all of the ATT_ flags can be supported under EFI, so we 
    make a best guess.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN foreground,background;
    UINTN EfiAttribute;

    switch (Attribute & 0xf) {
        case ATT_FG_BLACK:
            foreground = EFI_BLACK;
            break;
        case ATT_FG_RED:
            foreground = EFI_RED;
            break;
        case ATT_FG_GREEN:
            foreground = EFI_GREEN;
            break;
        case ATT_FG_YELLOW:
            foreground = EFI_YELLOW;
            break;
        case ATT_FG_BLUE:
            foreground = EFI_BLUE;
            break;
        case ATT_FG_MAGENTA:
            foreground = EFI_MAGENTA;
            break;
        case ATT_FG_CYAN:
            foreground = EFI_CYAN;
            break;
        case ATT_FG_WHITE:
            foreground = EFI_LIGHTGRAY; // this is a best guess
            break;
        case ATT_FG_INTENSE:
            foreground = EFI_WHITE; // this is a best guess
            break;
        default:
            // you may fall into this for blinking attribute, etc.
            foreground = EFI_WHITE;  
    }

    switch ( Attribute & ( 0xf << 4)) {
        case ATT_BG_BLACK:
            background = EFI_BACKGROUND_BLACK;
            break;
        case ATT_BG_RED:
            background = EFI_BACKGROUND_RED;
            break;
        case ATT_BG_GREEN:
            background = EFI_BACKGROUND_GREEN;
            break;
        case ATT_BG_YELLOW:
            // there is no yellow background in EFI
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_BLUE:
            background = EFI_BACKGROUND_BLUE;
            break;
        case ATT_BG_MAGENTA:
            background = EFI_BACKGROUND_MAGENTA;
            break;
        case ATT_BG_CYAN:
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_WHITE:
            // there is no white background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        case ATT_BG_INTENSE:
            // there is no intense (or white) background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        default:
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
    }
        
    EfiAttribute = foreground | background ;
    

    FlipToPhysical();
    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}


BOOLEAN
BlEfiSetInverseMode(
    BOOLEAN fInverseOn
    )
/*++

Routine Description:

    Sets the console text to an inverse attribute.
    
    Since EFI doesn't support the concept of inverse, we have
    to make a best guess at this.  Note that if you clear the
    display, etc., then the entire display will be set to this
    attribute.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN EfiAttribute,foreground,background;

    //
    // if it's already on, then just return.
    //
    if (fInverseOn && gInverse) {
        return(TRUE);
    }

    //
    // if it's already off, then just return.
    //
    if (!fInverseOn && !gInverse) {
        return(TRUE);
    }


    FlipToPhysical();

    //
    // get the current attribute and switch it.
    //
    EfiAttribute = EfiST->ConOut->Mode->Attribute;
    foreground = EfiAttribute & 0xf;
    background = (EfiAttribute & 0xf0) >> 4 ;

    EfiAttribute =  background | foreground;

    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    gInverse = !gInverse;

    return (Status == EFI_SUCCESS);
}




//
// Array of EFI drawing characters.
//
// This array MUST MATCH the GraphicsChar enumerated type in bldr.h.
//
USHORT EfiDrawingArray[GraphicsCharMax] = { 
    BOXDRAW_DOUBLE_DOWN_RIGHT,
    BOXDRAW_DOUBLE_DOWN_LEFT,
    BOXDRAW_DOUBLE_UP_RIGHT,
    BOXDRAW_DOUBLE_UP_LEFT,
    BOXDRAW_DOUBLE_VERTICAL,
    BOXDRAW_DOUBLE_HORIZONTAL,
    BLOCKELEMENT_FULL_BLOCK,
    BLOCKELEMENT_LIGHT_SHADE    
};



USHORT
BlEfiGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
/*++

Routine Description:

    Gets the appropriate mapping character.
    
    
    
Arguments:

    GraphicsChar - enumerated type indicating character to be retrieved.
    
Return Value:

    USHORT - EFI drawing character.

--*/
{
    //
    // just return a space if the input it out of range
    //
    if (WhichOne >= GraphicsCharMax) {
        return(L' ');
    }
    
    return(EfiDrawingArray[WhichOne]);
}


#if DBG

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    EFI_EVENT EventArray[2];
    EFI_INPUT_KEY Key;
    UINTN num;

    if (GoneVirtual) {
        FlipToPhysical();
    }
    EventArray[0] = EfiST->ConIn->WaitForKey;
    EventArray[1] = NULL;
    EfiBS->WaitForEvent(1,EventArray,&num);
    //
    // reset the event
    //
    EfiST->ConIn->ReadKeyStroke( EfiST->ConIn, &Key );
    if (GoneVirtual) {
        FlipToVirtual();
    }
    
}

#else

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\efiutil.c ===
#include "bldr.h"
#include "bootefi.h"
#include "efi.h"
#include "smbios.h"
#include "stdlib.h"

extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;


INTN
RUNTIMEFUNCTION
CompareGuid(
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    )
/*++

Routine Description:

    Compares two GUIDs

Arguments:

    Guid1       - guid to compare
    Guid2       - guid to compare

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    INT32       *g1, *g2, r;

    //
    // Compare 32 bits at a time
    //

    g1 = (INT32 *) Guid1;
    g2 = (INT32 *) Guid2;

    r  = g1[0] - g2[0];
    r |= g1[1] - g2[1];
    r |= g1[2] - g2[2];
    r |= g1[3] - g2[3];

    return r;
}


EFI_STATUS
GetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    )

{
    UINTN Index;

    //
    // ST is system table
    //
    for(Index=0;Index<EfiST->NumberOfTableEntries;Index++) {
        if (CompareGuid(TableGuid,&(EfiST->ConfigurationTable[Index].VendorGuid))==0) {
            *Table = EfiST->ConfigurationTable[Index].VendorTable;
            return EFI_SUCCESS;
        }
    }
    return EFI_NOT_FOUND;
}


ARC_STATUS
BlGetEfiProtocolHandles(
    IN EFI_GUID *ProtocolType,
    OUT EFI_HANDLE **pHandleArray,
    OUT ULONG *NumberOfDevices
    )
/*++

Routine Description:

    Finds all of the handles that support a given protocol type.
    
    This routine requires that BlInitializeMemory() has already been
    called.

Arguments:

    ProtocolType - GUID that describes handle type to search for.
    pHandleArray - receives an array of handles that support the specified
                   protocol.
                   The page that these handles reside in can be freed via 
                   BlFreeDescriptor.
    NumberOfDevices - receives the number of device handles that support the
                   given protocol

Returns:
    ARC_STATUS indicating outcome.

--*/
{
    EFI_HANDLE *HandleArray = NULL;
    ULONGLONG HandleArraySize = 0;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;
    EFI_STATUS EfiStatus;
    
    *pHandleArray = NULL;
    *NumberOfDevices = 0;

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();

//    EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlGetEfiProtocolHandles\r\n");

    //
    // Try to find out how much space we need.
    //
    EfiStatus = EfiBS->LocateHandle (
                ByProtocol,
                ProtocolType,
                0,
                (UINTN *) &HandleArraySize,
                HandleArray
                );

    FlipToVirtual();

    if (EfiStatus != EFI_BUFFER_TOO_SMALL) {
        //
        // yikes.  something is really messed up.  return failure.
        //        
//        EfiST->ConOut->OutputString(EfiST->ConOut, L"LocateHandle returned failure\r\n");
        return(EINVAL);
    }
    
//    EfiST->ConOut->OutputString(EfiST->ConOut, L"About to BlAllocateAlignedDescriptor\r\n");
    //
    // allocate space for the handles.
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG)(HandleArraySize >> PAGE_SIZE),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
//        EfiST->ConOut->OutputString(EfiST->ConOut, L"BlAllocateAlignedDescriptor failed\r\n");
        return(ArcStatus);
    }

    

    HandleArray = (EFI_HANDLE *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);
    
    FlipToPhysical();
    RtlZeroMemory(HandleArray, HandleArraySize);

//    EfiST->ConOut->OutputString(EfiST->ConOut, L"calling LocateHandle again\r\n");

    //
    // now get the handles now that we have enough space.
    //
    EfiStatus = EfiBS->LocateHandle (
                ByProtocol,
                ProtocolType,
                0,
                (UINTN *) &HandleArraySize,
                (EFI_HANDLE *)HandleArray
                );

//    EfiST->ConOut->OutputString(EfiST->ConOut, L"back from LocateHandle\r\n");
    FlipToVirtual();

    if (EFI_ERROR(EfiStatus)) {
        //
        // cleanup and return
        //        
//        EfiST->ConOut->OutputString(EfiST->ConOut, L"LocateHandle failed\r\n");
        BlFreeDescriptor( MemoryPage );
        return(EINVAL);
    }

//    EfiST->ConOut->OutputString(EfiST->ConOut, L"LocateHandle succeeded, return success\r\n");
    *NumberOfDevices = (ULONG)(HandleArraySize / sizeof (EFI_HANDLE));
    *pHandleArray = HandleArray;

//    BlPrint(TEXT("BlGetEfiProtocolHandles: found %x devices\r\n"), *NumberOfDevices );

    return(ESUCCESS);

}




CHAR16 *sprintf_buf;
UINT16 count;


VOID
__cdecl
putbuf(CHAR16 c)
{
    *sprintf_buf++ = c;
    count++;
}
VOID
bzero(CHAR16 *cp, int len)
{
    while (len--) {
        *(cp + len) = 0;
    }
}

VOID
__cdecl
doprnt(VOID (*func)(CHAR16 c), const CHAR16 *fmt, va_list args);


//
// BUGBUG this is a semi-sprintf hacked together just to get it to work
//
UINT16
__cdecl
wsprintf(CHAR16 *buf, const CHAR16 *fmt, ...)
{

    va_list args;

    sprintf_buf = buf;
    va_start(args, fmt);
    doprnt(putbuf, fmt, args);
    va_end(args);
    putbuf('\0');
    return count--;
}

void
__cdecl
printbase(VOID (*func)(CHAR16), ULONG x, int base, int width)
{
    static CHAR16 itoa[] = L"0123456789abcdef";
    ULONG j;
    LONG k;
    CHAR16 buf[32], *s = buf;

    bzero(buf, 16);
    if (x == 0 ) {
        *s++ = itoa[0];
    }
    while (x) {
        j = x % base;
        *s++ = itoa[j];
        x -= j;
        x /= base;
    }

    if( s-buf < width ) {
        for( k = 0; k < width - (s-buf); k++ ) {
            func('0');
        }
    }
    for (--s; s >= buf; --s) {
        func(*s);
    }
}

void
__cdecl
printguid(
    VOID (*func)( CHAR16), 
    GUID *pGuid
    )
{
    ULONG u;
    
    func(L'{');
    printbase(func, pGuid->Data1, 16, 8);
    func(L'-');
    printbase(func, pGuid->Data2, 16, 4);
    func(L'-');
    printbase(func, pGuid->Data3, 16, 4);
    func(L'-');
    printbase(func, pGuid->Data4[0], 16, 2);
    printbase(func, pGuid->Data4[1], 16, 2);
    func(L'-');
    printbase(func, pGuid->Data4[2], 16, 2);
    printbase(func, pGuid->Data4[3], 16, 2);
    printbase(func, pGuid->Data4[4], 16, 2);
    printbase(func, pGuid->Data4[5], 16, 2);
    printbase(func, pGuid->Data4[6], 16, 2);
    printbase(func, pGuid->Data4[7], 16, 2);
    func(L'}');    
}


void
__cdecl
doprnt(VOID (*func)( CHAR16 c), const CHAR16 *fmt, va_list args)
{
    ULONG x;
    LONG l;
    LONG width;
    CHAR16 c, *s;
    GUID * g;

    count = 0;

    while (c = *fmt++) {
        if (c != '%') {
            func(c);
            continue;
        }

        width=0;
        c=*fmt++;

        if(c == '0') {
            while( c = *fmt++) {

                if (!isdigit(c)) {
                    break;
                }

                width = width*10;
                width = width+(c-48);

            }
        }
        fmt--; // back it up one char

        switch (c = *fmt++) {
        case 'x':
            x = va_arg(args, ULONG);
            printbase(func, x, 16, width);
            break;
        case 'o':
            x = va_arg(args, ULONG);
            printbase(func, x, 8, width);
            break;
        case 'd':
            l = va_arg(args, LONG);
            if (l < 0) {
                func('-');
                l = -l;
            }
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'u':
            l = va_arg(args, ULONG);
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'g':
            g = va_arg(args, GUID *);
            printguid(func, g);
            break;
        case 'c':
            c = va_arg(args, CHAR16);
            func(c);
            break;
        case 's':
            s = va_arg(args, CHAR16 *);
            while (*s) {
                func(*s++);
            }
            break;
        default:
            func(c);
            break;
        }
    }
}

VOID
CatPrint(
    IN UNICODE_STRING *String,
    IN CHAR16* Format,
    ...
    )
{
    CHAR16* pString = String->Buffer;
    va_list args;

    if (*pString != '\0') {
        pString = String->Buffer + wcslen(String->Buffer);
    }

    sprintf_buf = pString;

    va_start(args, Format);
    doprnt(putbuf, Format, args);
    va_end(args);
    putbuf('\0');

}

VOID
_DevPathPci (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    PCI_DEVICE_PATH UNALIGNED         *Pci;

    Pci = DevPath;
    CatPrint(Str, L"Pci(%x|%x)", Pci->Device, Pci->Function);
}

VOID
_DevPathPccard (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    PCCARD_DEVICE_PATH UNALIGNED      *Pccard;

    Pccard = DevPath;   
    CatPrint(Str, L"Pccard(Socket%x)", Pccard->SocketNumber);
}

VOID
_DevPathMemMap (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MEMMAP_DEVICE_PATH UNALIGNED      *MemMap;

    MemMap = DevPath;   
    CatPrint(Str, L"MemMap(%d:%x-%x)",
        MemMap->MemoryType,
        MemMap->StartingAddress,
        MemMap->EndingAddress
        );
}

VOID
_DevPathController (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CONTROLLER_DEVICE_PATH UNALIGNED  *Controller;

    Controller = DevPath;
    CatPrint(Str, L"Ctrl(%d)",
        Controller->Controller
        );
}

VOID
_DevPathVendor (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    VENDOR_DEVICE_PATH UNALIGNED        *Vendor;
    CHAR16                              *Type;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH UNALIGNED   *UnknownDevPath;
    EFI_GUID UnknownDevice      = UNKNOWN_DEVICE_GUID;
    EFI_GUID VendorGuid;
    

    Vendor = DevPath;
    switch (DevicePathType(&Vendor->Header)) {
    case HARDWARE_DEVICE_PATH:  Type = L"Hw";        break;
    case MESSAGING_DEVICE_PATH: Type = L"Msg";       break;
    case MEDIA_DEVICE_PATH:     Type = L"Media";     break;
    default:                    Type = L"?";         break;
    }                            

    RtlCopyMemory( &VendorGuid, &Vendor->Guid, sizeof(EFI_GUID));

    CatPrint(Str, L"Ven%s(%g", Type, &VendorGuid);
    if (CompareGuid (&VendorGuid, &UnknownDevice) == 0) {
        /* 
         *  GUID used by EFI to enumerate an EDD 1.1 device
         */
        UnknownDevPath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH UNALIGNED *)Vendor;
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    } else {
        CatPrint(Str, L")");
    }
}


VOID
_DevPathAcpi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    ACPI_HID_DEVICE_PATH UNALIGNED        *Acpi;

    Acpi = DevPath;
    if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
        CatPrint(Str, L"Acpi(PNP%04x,%x)", EISA_ID_TO_NUM (Acpi->HID), Acpi->UID);
    } else {
        CatPrint(Str, L"Acpi(%08x,%x)", Acpi->HID, Acpi->UID);
    }
}


VOID
_DevPathAtapi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    ATAPI_DEVICE_PATH UNALIGNED       *Atapi;

    Atapi = DevPath;
    CatPrint(Str, L"Ata(%s,%s)", 
        Atapi->PrimarySecondary ? L"Secondary" : L"Primary",
        Atapi->SlaveMaster ? L"Slave" : L"Master"
        );
}

VOID
_DevPathScsi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    SCSI_DEVICE_PATH UNALIGNED        *Scsi;

    Scsi = DevPath;
    CatPrint(Str, L"Scsi(Pun%x,Lun%x)", Scsi->Pun, Scsi->Lun);
}


VOID
_DevPathFibre (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
  