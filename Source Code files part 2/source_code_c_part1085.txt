wnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))            /* ;Internal */
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))                        /* ;Internal */

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))
#define ListBox_AddFile(hwndCtl, lpszFilename)      ((int)(DWORD)SendMessage((hwndCtl), LB_ADDFILE, 0, (LPARAM)(LPCSTR)(lpszFilename)))    /* ;Internal */

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#pragma warning(4:4020)
#pragma warning(disable:4001)
#pragma warning(disable:4103)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#define NOCOMM                      /* ;Internal */
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID                void

#define FAR                 _far
#define NEAR                _near
#define PASCAL              _pascal
#define CDECL               _cdecl
#define CONST               const                   /* ;Internal */

#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI              _loadds _far _pascal    /* ;Internal */
#define CALLBACK            _loadds _far _pascal    /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API                 WINAPI                  /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int                 BOOL;
#define FALSE               0
#define TRUE                1

typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int        UINT;

#ifdef STRICT
typedef signed long         LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL                0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;

#define SZ char                         /* ;Internal */

typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*          PBYTE;
typedef BYTE FAR*           LPBYTE;

typedef int NEAR*           PINT;
typedef int FAR*            LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*          PLONG;
typedef long FAR*           LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*             PHANDLE;
typedef HANDLE NEAR*        SPHANDLE;
typedef HANDLE FAR*         LPHANDLE;

typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;

typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_CPUEM        0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_WINNT        0x4000
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING             0x8000
#define ERR_PARAM               0x4000

/* Internal error value masks */            /* ;Internal */
#define ERR_TYPE_MASK           0x0fff      /* ;Internal */
#define ERR_FLAGS_MASK          0xc000      /* ;Internal */
                                            /* ;Internal */
#define ERR_SIZE_MASK           0x3000
#define ERR_SIZE_SHIFT          12          /* ;Internal */
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000
                                            /* ;Internal */
/* Error option flags (set by [kernel] ErrorOptions win.ini variable) *//* ;Internal */
                                            /* ;Internal */
#define ERO_PARAM_ERROR_BREAK   0x0001      /* ;Internal */
#define ERO_BUFFER_FILL         0x0002      /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE          0x7004
#define ERR_BAD_DFLAGS          0x7005
#define ERR_BAD_DINDEX          0x7006
#define ERR_BAD_PTR             0x7007
#define ERR_BAD_FUNC_PTR        0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR      0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43
#define EW_EXITANDEXECAPP 0x44   /* ;Internal */

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);                 /* ;Internal */

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0

/****** Task Management *****************************************************/

#endif  /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);                /* ;Internal */
                                                        /* ;Internal */
/* GetAppCompatFlags flag values */                     /* ;Internal */
#define GACF_IGNORENODISCARD    0x0001                  /* ;Internal */
#define GACF_FORCETEXTBAND      0x0002                  /* ;Internal */
#define GACF_ONELANDGRXBAND     0x0004                  /* ;Internal */
#define GACF_IGNORETOPMOST      0x0008                  /* ;Internal */
#define GACF_CALLTTDEVICE       0x0010                  /* ;Internal */
#define GACF_MULTIPLEBANDS      0x0020                  /* ;Internal */
#define GACF_ALWAYSSENDNCPAINT  0x0040                  /* ;Internal */
#define GACF_EDITSETTEXTMUNGE   0x0080                  /* ;Internal */
#define GACF_MOREEXTRAWNDWORDS  0x0100                  /* ;Internal */
#define GACF_TTIGNORERASTERDUPE 0x0200                  /* ;Internal */
#define GACF_HACKWINFLAGS       0x0400                  /* ;Internal */
#define GACF_DELAYHWHNDSHAKECHK 0x0800                  /* ;Internal */
#define GACF_ENUMHELVNTMSRMN    0x1000                  /* ;Internal */
#define GACF_ENUMTTNOTDEVICE    0x2000                  /* ;Internal */
#define GACF_SUBTRACTCLIPSIBS   0x4000                  /* ;Internal */
#define GACF_FORCETTGRAPHICS    0x8000                  /* ;Internal */
#define GACF_NOHRGN1            0x00010000              /* ;Internal */
#define GACF_NCCALCSIZEONMOVE   0x00020000              /* ;Internal */
#define GACF_SENDMENUDBLCLK     0x00040000              /* ;Internal */
#define GACF_30AVGWIDTH         0x00080000              /* ;Internal */

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                    /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)      /* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)      /* ;Internal */

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

/* LocalNotify callback */                                          /* ;Internal */
#ifdef STRICT                                                       /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*);   /* ;Internal */
#else                                                               /* ;Internal */
typedef FARPROC LNOTIFYPROC;                                        /* ;Internal */
#endif                                                              /* ;Internal */
                                                                    /* ;Internal */
#define LNOTIFY_OUTOFMEM    0                                       /* ;Internal */
#define LNOTIFY_MOVE        1                                       /* ;Internal */
#define LNOTIFY_DISCARD     2                                       /* ;Internal */
                                                                    /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                        /* ;Internal */
                                                                    /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400      /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ        0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long    WINAPI _hread(HFILE, void _huge*, long);
long    WINAPI _hwrite(HFILE, const void _huge*, long);
#endif  /* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);   /* ;Internal */

#endif  /* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection errors */
#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)       GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)

/* If any new types are added above this point, */  /* ;Internal */
/* DIFFERENCE must be changed.  The GROUP_*     */  /* ;Internal */
/* values minus the non-GROUP values must be    */  /* ;Internal */
/* equal to DIFFERENCE                          */  /* ;Internal */
#define DIFFERENCE          11                      /* ;Internal */
#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON       MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE     0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */    /* ;Internal */
#define ORD_LANGDRIVER    1                  /* ;Internal */

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif  /* WINVER >= 0x030a */
#endif  /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
UINT    WINAPI GetSystemDefaultLangID(void);
#endif  /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif  /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)        (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR   0x8000                          /* ;Internal */
                                                        /* ;Internal */
/* Internal SelectBitmap stuff */                       /* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/     /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR            0
#define COLOR_BACKGROUND           1
#define COLOR_ACTIVECAPTION        2
#define COLOR_INACTIVECAPTION      3
#define COLOR_MENU                 4
#define COLOR_WINDOW               5
#define COLOR_WINDOWFRAME          6
#define COLOR_MENUTEXT             7
#define COLOR_WINDOWTEXT           8
#define COLOR_CAPTIONTEXT          9
#define COLOR_ACTIVEBORDER        10
#define COLOR_INACTIVEBORDER      11
#define COLOR_APPWORKSPACE        12
#define COLOR_HIGHLIGHT           13
#define COLOR_HIGHLIGHTTEXT       14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT             18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#define COLOR_MAX                 20            /* ;Internal */
#else  /* WINVER >= 0x030a */                   /* ;Internal */
#define COLOR_MAX                 18            /* ;Internal */
#endif  /* WINVER >= 0x030a */
#define COLOR_ENDCOLORS           COLOR_MAX     /* ;Internal */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL             5
#define PS_INSIDEFRAME      6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311
#define WM_PALETTEGONNACHANGE   WM_PALETTEISCHANGING    /* ;Internal */
#define WM_CHANGEPALETTE        WM_PALETTECHANGED       /* ;Internal */

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);

#if (WINVER >= 0x030a)                                  /* ;Internal */
/* DC hook callback function */                         /* ;Internal */
                                                        /* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
                                                        /* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);   /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);          /* ;Internal */
                                                        /* ;Internal */
/* Callback reason code values */                       /* ;Internal */
                                                        /* ;Internal */
#define DCHC_INVALIDVISRGN 0x0001                       /* ;Internal */
#define DCHC_DELETEDC      0x0002                       /* ;Internal */
                                                        /* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);          /* ;Internal */
                                                        /* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001                    /* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002                    /* ;Internal */
#endif  /* WINVER >= 0x030a */                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);

BOOL    WINAPI FastWindowFrame(HDC, const RECT FAR*, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_VALID            0x1fff  /* ;Internal: Union of all those above */

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP                0x0000
#define TA_UPDATECP                  0x0001
#define TA_LEFT                      0x0000
#define TA_RIGHT                     0x0002
#define TA_CENTER                    0x0006
#define TA_TOP                       0x0000
#define TA_BOTTOM                    0x0008
#define TA_BASELINE                  0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE         32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define GB2312_CHARSET      134
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING             0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE       0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif  /* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);   /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL    WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD          bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE        bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */                             /* ;Internal */
typedef struct tagPELARRAY                  /* ;Internal */
{                                           /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;                         /* ;Internal */
} PELARRAY;                                 /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif  /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE    1
#define WHITEONBLACK    2
#define COLORONCOLOR    3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif  /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_EXTFLOODFILL            0x0548

#define META_RESETDC                 0x014C
#define META_STARTDOC                0x014D
#define META_STARTPAGE               0x004F
#define META_ENDPAGE                 0x0050
#define META_ABORTDOC                0x0052
#define META_ENDDOC                  0x005E

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS            0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                       /* ;Internal */
typedef struct tagWND NEAR* HWND;   /* ;Internal */
#else                               /* ;Internal */
DECLARE_HANDLE(HWND);
#endif                              /* ;Internal */

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN          0
#define SM_CYSCREEN          1
#define SM_CXVSCROLL         2
#define SM_CYHSCROLL         3
#define SM_CYCAPTION         4
#define SM_CXBORDER          5
#define SM_CYBORDER          6
#define SM_CXDLGFRAME        7
#define SM_CYDLGFRAME        8
#define SM_CYVTHUMB          9
#define SM_CXHTHUMB          10
#define SM_CXICON            11
#define SM_CYICON            12
#define SM_CXCURSOR          13
#define SM_CYCURSOR          14
#define SM_CYMENU            15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL         20
#define SM_CXHSCROLL         21
#define SM_DEBUG             22
#define SM_SWAPBUTTON        23
#define SM_RESERVED1         24
#define SM_RESERVED2         25
#define SM_RESERVED3         26
#define SM_RESERVED4         27
#define SM_CXMIN             28
#define SM_CYMIN             29
#define SM_CXSIZE            30
#define SM_CYSIZE            31
#define SM_CXFRAME           32
#define SM_CYFRAME           33
#define SM_CXMINTRACK        34
#define SM_CYMINTRACK        35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_MAX               42         /* ;Internal */
#define SM_CMETRICS          43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE       0x001E
#define WM_FILESYSCHANGE    0x0034              /* ;Internal */

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_TIMEOUTS                7   /* ;Internal */
#define SPI_KANJIMENU               8   /* ;Internal */
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_MAX                     36   /* ;Internal */

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDWININICHANGE       0x0002
#define SPIF_VALID                  0x0003  /* ;Internal */

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL             0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER             0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002
#define PM_VALID        0x0003       /* ;Internal */

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040

#define QS_ALLINPUT     0x007f
#define QS_VALID        0x007f      /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST  ((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE       3

#define WH_CALLWNDPROC      4

#define WH_MSGFILTER        (-1)
#define WH_SYSMSGFILTER     6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX           0
#define MSGF_MESSAGEBOX          1          /* ;Internal */
#define MSGF_MENU                2
#define MSGF_MOVE                3
#define MSGF_SIZE                4
#define MSGF_SCROLLBAR           5
#define MSGF_NEXTWINDOW          6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7          /* ;Internal */
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST      0x0380
#define WM_PENWINLAST       0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F

/* Reserved message ranges */                   /* ;Internal */
#define WM_KANJIFIRST       0x0280  /* JAPAN */ /* ;Internal */
#define WM_KANJILAST        0x029F  /* JAPAN */ /* ;Internal */
#define WM_HANGEULFIRST     0x0280  /* KOREA */ /* ;Internal */
#define WM_HANGEULLAST      0x029F  /* KOREA */ /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for multi-media                       */     /* ;Internal */
#define WM_MM_RESERVED_FIRST 0x03A0             /* ;Internal */
#define WM_MM_RESERVED_LAST  0x03DF             /* ;Internal */
#define WM_INTERNAL_COALESCE_LAST  0x03b0       /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_DDE_FIRST 0x03E0            /* ;Internal */
#define WM_INTERNAL_DDE_LAST  0x03EF            /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for CBT                               */     /* ;Internal */
#define WM_CBT_RESERVED_FIRST 0x03F0            /* ;Internal */
#define WM_CBT_RESERVED_LAST  0x03FF            /* ;Internal */

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER            0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION       0x0016

#define WM_QUIT             0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR      0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_SAVEBITS         0x0800

#define CS_DBLCLKS          0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE          0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT         0x0100

#define CS_GLOBALCLASS      0x4000
#define CS_VALID            0x7fef  /* ;Internal */
#endif  /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L

/* Main window states */
#define WS_MINIMIZE         0x20000000L
#define WS_MAXIMIZE         0x01000000L

/* Main window styles */
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

/* Control window styles */
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_DRAGOBJECT     0x00000002L                /* ;Internal */
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST        0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#define WS_EX_VALID          0x0000003fL    /* ;Internal */
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

#define WS_VALID            0xffff0000L     /* ;Internal */

#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE           0x0001
#define WM_NCCREATE         0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY          0x0002
#define WM_NCDESTROY        0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#define WM_SETVISIBLE       0x0009              /* ;Internal */

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_MAX              9   /* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW       0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif  /* NOSHOWWINDOW */

#define WM_SETREDRAW        0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE           0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT       ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */  /* ;Internal */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */  /* ;Internal */
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_DEFERDRAWING    SWP_DEFERERASE /* Don't do any drawing or erasing */ /* ;Internal */
                                                                      /* ;Internal */
#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_FRAMECHANGED |                        /* ;Internal */ \
                            SWP_SHOWWINDOW | SWP_HIDEWINDOW |         /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
                                                                      /* ;Internal */
#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
#define SWP_VALID           0x27ff  /* ;Internal */

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST        /* ;Internal */

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE             0x0003
#define WM_SIZEWAIT         0x0004      /* ;Internal */
#define WM_SIZE             0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN        0x0013
#define WM_CLOSE            0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024

#define WM_ENTERSIZEMOVE    0x0231              /* ;Internal */
#define WM_EXITSIZEMOVE     0x0232              /* ;Internal */
#define WM_ISACTIVEICON     0x0035              /* ;Internal */
#define WM_UNUSED0036       0x0036              /* ;Internal */
#define WM_TESTING          0x0040              /* ;Internal */

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST    0
#define GW_HWNDLAST     1
#define GW_HWNDNEXT     2
#define GW_HWNDPREV     3
#define GW_OWNER        4
#define GW_CHILD        5
#define GW_MAX          5       /* ;Internal */

HWND    WINAPI GetNextQueueWindow(HWND, int); /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_NORESETATTRS    0x00000004L /* ;Internal */
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L

#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L

#define DCX_EXCLUDEUPDATE   0x00000100L /* ;Internal */
#define DCX_INTERSECTUPDATE 0x00000200L /* ;Internal */

#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_INVALID         0x00000800L /* ;Internal */
#define DCX_INUSE           0x00001000L /* ;Internal */
#define DCX_SAVEDRGNINVALID 0x00002000L /* ;Internal */

#define DCX_USESTYLE        0x00010000L
#define DCX_NEEDFONT        0x00020000L /* ;Internal */
#define DCX_NODELETERGN     0x00040000L /* ;Internal */
#define DCX_NOCLIPCHILDREN  0x00080000L /* ;Internal */
#define DCX_NORECOMPUTE     0x00100000L /* ;Internal */
#define DCX_VALIDATE        0x00200000L /* ;Internal */

#define DCX_MATCHMASK           (DCX_WINDOW | DCX_CACHE |                 /* ;Internal */ \
                                 DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS |    /* ;Internal */ \
                                 DCX_LOCKWINDOWUPDATE                     /* ;Internal */ \
                                )                                         /* ;Internal */
#define DCX_VALID           0x000104fbL /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT            0x000F
#define WM_ERASEBKGND       0x0014
#define WM_PAINTICON        0x0026              /* ;Internal */
#define WM_ICONERASEBKGND   0x0027
#define WM_SYNCPAINT        0x0088              /* ;Internal */
#define WM_SYNCTASK         0x0089              /* ;Internal */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800
                                                                        /* ;Internal */
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/ /* ;Internal */
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */ /* ;Internal */
                                                                        /* ;Internal */
#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */ /* ;Internal */
#define RDW_VALID               0x0fff                                  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004

#define SW_SCROLLWINDOW     0x8000  /* ;Internal */
#define SW_VALID            0x8007  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT          0x0085

#define WM_NCCALCSIZE       0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

#define WVR_MINVALID        WVR_ALIGNTOP        /* ;Internal */
#define WVR_MAXVALID        WVR_VALIDRECTS      /* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT           rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST        0x0084

/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT              /* ;Internal */
#define HTSIZELAST          HTBOTTOMRIGHT       /* ;Internal */

/****** Drag-and-drop support ***********************************************/

#define WM_DROPOBJECT       0x022A              /* ;Internal */
#define WM_QUERYDROPOBJECT  0x022B              /* ;Internal */
#define WM_BEGINDRAG        0x022C              /* ;Internal */
#define WM_DRAGLOOP         0x022D              /* ;Internal */
#define WM_DRAGSELECT       0x022E              /* ;Internal */
#define WM_DRAGMOVE         0x022F              /* ;Internal */
#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES        0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

#define WM_ACTIVATE         0x0006
#define WM_ACTIVATEAPP      0x001C
#define WM_NCACTIVATE       0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008

#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101

#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103

#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105

#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107

#define WM_YOMICHAR         0x0108  /* JAPAN */ /* ;Internal */
#define WM_CONVERTREQUEST   0x010A  /* JAPAN */ /* ;Internal */
#define WM_CONVERTRESULT    0x010B  /* JAPAN */ /* ;Internal */
#define WM_INTERIM          0x010C  /* KOREA */ /* ;Internal */

/* Keyboard message range */
#define WM_KEYFIRST         0x0100
#define WM_KEYLAST          0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED         0x0100
#define KF_DLGMODE          0x0800
#define KF_MENUMODE         0x1000
#define KF_ALTDOWN          0x2000
#define KF_REPEAT           0x4000
#define KF_UP               0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_KANA             0x15    /* JAPAN */ /* ;Internal */
#define VK_KANJI            0x19    /* JAPAN */ /* ;Internal */
#define VK_HANGEUL          0x15    /* KOREA */ /* ;Internal */
#define VK_JUNJA            0x17    /* KOREA */ /* ;Internal */
#define VK_HANJA            0x19    /* KOREA */ /* ;Internal */
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F
#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F
#define VK_F17              0x80
#define VK_F18              0x81
#define VK_F19              0x82
#define VK_F20              0x83
#define VK_F21              0x84
#define VK_F22              0x85
#define VK_F23              0x86
#define VK_F24              0x87
#define VK_NUMLOCK          0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */

BOOL WINAPI IsTwoByteCharPrefix(char);      /* ;Internal */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD         2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST       0x0200
#define WM_MOUSELAST        0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif  /* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE       0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER            0x0113
#define WM_SYSTIMER         0x0118              /* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT           0x0000
#define MF_CHANGE           0x0080
#define MF_APPEND           0x0100
#define MF_DELETE           0x0200
#define MF_REMOVE           0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND        0x0000
#define MF_BYPOSITION       0x0400

#define MF_SEPARATOR        0x0800

#define MF_ENABLED          0x0000
#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_UNCHECKED        0x0000
#define MF_CHECKED          0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING           0x0000
#define MF_BITMAP           0x0004
#define MF_OWNERDRAW        0x0100

#define MF_POPUP            0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK        0x0040

#define MF_UNHILITE         0x0000
#define MF_HILITE           0x0080

#define MF_SYSMENU          0x2000
#define MF_HELP             0x4000
#define MF_MOUSESELECT      0x8000

#define MF_VALID            0x4fff  /* ;Internal */
#define MF_CHANGE_VALID     0x5fff  /* ;Internal */

#define MF_END              0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#define TPM_VALID       0x000f  /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120
#define WM_ENTERMENULOOP    0x0211              /* ;Internal */
#define WM_EXITMENULOOP     0x0212              /* ;Internal */
#define WM_NEXTMENU         0x0213              /* ;Internal */

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND          0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
#define SB_MSGCMD_MAX       8       /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
#define SB_MAX              3       /* ;Internal */

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#define ESB_MAX             0x0003              /* ;Internal */
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH    /* ;Internal */
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT              1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

#define WM_SETCURSOR        0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK         0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F      /* ;Internal */
#define MB_ICONMASK         0x00F0      /* ;Internal */
#define MB_DEFMASK          0x0F00      /* ;Internal */
#define MB_MODEMASK         0x3000      /* ;Internal */
#define MB_MISCMASK         0xC000      /* ;Internal */
#define MB_VALID            0xb377      /* ;Internal */


#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND   0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

/* SC_HOTKEY support messages */ /* ;Internal */
#define WM_SETHOTKEY    0x0032   /* ;Internal */
#define WM_GETHOTKEY    0x0033   /* ;Internal */

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30

/* Dialog styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG       0x0110
#define WM_NEXTDLGCTL       0x0028
#define WM_ALTTABACTIVE     0x0029              /* ;Internal */

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE        0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE       0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR         0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT       1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN        3
#define CTLCOLOR_DLG        4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6
#define CTLCOLOR_MAX        8       /* ;Internal */

#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM      0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL    /* ;Internal */
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#define STM_MSGMAX          (WM_USER+2)    /* ;Internal */
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL  /* ;Internal */
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT             0x00000000L
#define ES_CENTER           0x00000001L
#define ES_RIGHT            0x00000002L
#define ES_MULTILINE        0x00000004L
#define ES_UPPERCASE        0x00000008L
#define ES_LOWERCASE        0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL      0x00000040L
#define ES_AUTOHSCROLL      0x00000080L
#define ES_NOHIDESEL        0x00000100L
#define ES_OEMCONVERT       0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY         0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_SCROLL               (WM_USER+5)     /* ;Internal */
#define EM_LINESCROLL           (WM_USER+6)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_GETTHUMB             (WM_USER+14)    /* ;Internal */
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_LIMITTEXT            (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_MSGMAX               (WM_USER+35)    /* ;Internal */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_ADDFILE             (WM_USER+23)     /* ;Internal */
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETANCHORINDEX      (WM_USER+29)     /* ;Internal */
#define LB_GETANCHORINDEX      (WM_USER+30)     /* ;Internal */
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */
#define LBCB_CARETON           (WM_USER+36)     /* ;Internal */
#define LBCB_CARETOFF          (WM_USER+37)     /* ;Internal */
#define LB_MSGMAX              (WM_USER+38)     /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_LBTRACKPOINT     0x0131              /* ;Internal */

/* Listbox message return values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

#define LB_CTLCODE          0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

#define LBD_UPPERCASE   0x8001     /* ;Internal */
#define LBD_SIZE        0x8002     /* ;Internal */
#define LBD_DATE        0x8004     /* ;Internal */
#define LBD_TIME        0x8008     /* ;Internal */
#define LBD_ATTRIBUTE   0x8010     /* ;Internal */
#define LBD_FULLDETAILS 0x801E     /* ;Internal */
#define LBD_SENDDETAILS 0x8020     /* ;Internal */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000
#define DDL_VALID           0xe03f      /* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX                (WM_USER+25)       /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)

#endif  /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

#define WH_MIN              (-1)                            /* ;Internal */
#define WH_MAX              10                              /* ;Internal */
#define WH_MINHOOK          WH_MIN                          /* ;Internal */
#define WH_MAXHOOK          WH_MAX                          /* ;Internal */
#define WH_CHOOKS           (WH_MAXHOOK - WH_MINHOOK + 1)   /* ;Internal */

/* Standard hook code */
#define HC_ACTION           0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN        (-3)
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)

#endif  /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif  /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG            9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE           EV_RingTe
#define EV_VALID            0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110      0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY           0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int     FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER               0x000F

#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002
#define GND_VALID               0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef NOWINDOWSX          /* ;Internal */
#ifndef RC_INVOKED          /* ;Internal */
#include "windowsx.h"       /* ;Internal */
#ifndef STRICT              /* ;Internal */
#undef  SelectFont          /* ;Internal */
#endif  /* STRICT */        /* ;Internal */
#endif  /* RC_INVOKED */    /* ;Internal */
#endif  /* NOWINDOWSX */    /* ;Internal */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifndef NODBCS
#ifdef DBCS
#if defined (JAPAN)
#define    NATIVE_CHARSET       SHIFTJIS_CHARSET
#elif defined (KOREA)
#define    NATIVE_CHARSET       HANGEUL_CHARSET
#elif defined (TAIWAN)
#define    NATIVE_CHARSET       CHINESEBIG5_CHARSET
#elif defined (PRC)
#define    NATIVE_CHARSET       GB2312_CHARSET
#else
#define    NATIVE_CHARSET       ANSI_CHARSET
#endif
#endif
#endif


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_WINDOWS */


// WOW Section //

int  FAR PASCAL WowGetNextVdmCommand(LPVOID);
int  FAR PASCAL WOWRegisterShellWindowHandle(HWND,LPVOID, HWND);
int  FAR PASCAL WowFailedExec(void);
void FAR PASCAL ExitKernelThunk(WORD wExitCode);
WORD FAR PASCAL WowSetExitOnLastApp(WORD fExitOnLastApp);

// Pickup WOW Generic Thunk Interfaces from wownt16,h //

#include "wownt16.h"

// this is a prototype.  CallProc32W is a messed up vararg function
// however rasapi16.c uses it.

#ifndef NO_CALLPROC32_DECL
DWORD FAR PASCAL CallProc32W(LPVOID, DWORD, DWORD);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\wmsyserr.h ===
/****************************************************************************/
/*									    */
/*  WMSYSERR.H -							    */
/*									    */
/*	Message Box String Defines					    */
/*									    */
/****************************************************************************/

/* SysErrorBox() stuff */

#define MAX_SEB_STYLES  7  /* number of SEB_* values */

#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

#define  SEB_BTN1       1  /* Button 1 was selected */
#define  SEB_BTN2       2  /* Button 1 was selected */
#define  SEB_BTN3       3  /* Button 1 was selected */

/* SysErrorBox() button structure definition */

typedef struct tagSEBBTN
  {
    unsigned int style;
    BOOL         finvert;
    RECT         rcbtn;
    POINT        pttext;
    LPSTR        psztext;
    BYTE         chaccel;
  } SEBBTN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\winnls.h ===
/***********************************************************************\
*									*
* WINNLS.H - East Asia input method editor (DBCS_IME) definitions	*
*									*
* History:								*
* 21-Oct-1991	bent							*
*		initial merge of East Asia 3.0 versions			*
*		Should be updated to resolve local inconsistencies.	*
*									*
* Copyright (c) 1990  Microsoft Corporation				*
*									*
\***********************************************************************/

typedef struct _tagDATETIME {
    WORD	year;
    WORD	month;
    WORD	day;
    WORD	hour;
    WORD	min;
    WORD	sec;
} DATETIME;

typedef struct _tagIMEPRO {
    HWND	hWnd;
    DATETIME	InstDate;
    WORD	wVersion;
    BYTE	szDescription[50];
    BYTE	szName[80];
    BYTE	szOptions[30];
#ifdef TAIWAN
    BYTE	szUsrFontName[80];
    BOOL	fEnable;
#endif
} IMEPRO;
typedef IMEPRO      *PIMEPRO;
typedef IMEPRO near *NPIMEPRO;
typedef IMEPRO far  *LPIMEPRO;

void FAR PASCAL InquireWINNLS( void );			/* ;Internal */
BOOL FAR PASCAL IMPGetIME( HWND, LPIMEPRO );
BOOL FAR PASCAL IMPQueryIME( LPIMEPRO );
BOOL FAR PASCAL IMPDeleteIME( LPIMEPRO );
BOOL FAR PASCAL IMPAddIME( LPIMEPRO );
BOOL FAR PASCAL IMPSetIME( HWND, LPIMEPRO );
BOOL FAR PASCAL IMEModifyIME( LPSTR, LPIMEPRO );	/* ;Internal */
WORD FAR PASCAL IMPGetDefaultIME( LPIMEPRO );		/* ;Internal */
WORD FAR PASCAL IMPSetDefaultIME( LPIMEPRO );		/* ;Internal */
BOOL FAR PASCAL WINNLSSetIMEHandle( LPSTR, HWND );	/* ;Internal */
BOOL FAR PASCAL WINNLSSetIMEStatus( HWND, BOOL );	/* ;Internal */

BOOL FAR PASCAL WINNLSEnableIME( HWND, BOOL );
WORD FAR PASCAL WINNLSGetKeyState( void );		/* ;Internal */
VOID FAR PASCAL WINNLSSetKeyState( WORD );		/* ;Internal */
BOOL FAR PASCAL WINNLSGetEnableStatus( HWND );
BOOL FAR PASCAL WINNLSSetKeyboardHook (BOOL);		/* ;Internal */

#ifdef KOREA
BOOL FAR PASCAL WINNLSSetIMEHotkey( HWND, WORD, WORD );
LONG FAR PASCAL WINNLSGetIMEHotkey( HWND );
#else
BOOL FAR PASCAL WINNLSSetIMEHotkey( HWND, WORD );	/* ;Internal */
WORD FAR PASCAL WINNLSGetIMEHotkey( HWND );
#endif //KOREA

#ifdef TAIWAN
typedef HANDLE HIME;

/* Extended IME information*/
typedef struct _tagIMEInfo {
    BYTE	szIMEName[7];
    BYTE	szPrompMessage[32];
    WORD	nMaxKeyLen;
} IMEINFO;
typedef IMEINFO far *LPIMEINFO;

HWND FAR PASCAL WINNLSGetSysIME(void);
void FAR PASCAL WINNLSSetSysIME(HWND);
BOOL FAR PASCAL SwitchIM( WORD , WORD );
BOOL ToNextIM(void);
void SetFullAbcState(BOOL);
BOOL EngChiSwitch(BOOL);
void FAR PASCAL TimerProc(HWND,int,WORD,LONG);
HWND FAR PASCAL IMPGetFullShapeHWnd(void);
void FAR PASCAL IMPSetFullShapeHWnd(HWND);
BOOL FAR PASCAL IMPSetFirstIME(HWND,LPIMEPRO);
BOOL FAR PASCAL IMPGetFirstIME(HWND,LPIMEPRO);
BOOL FAR PASCAL IMPDialogIME(LPIMEPRO,HWND);
BOOL FAR PASCAL IMPEnableIME(HWND,LPIMEPRO,BOOL);
BOOL FAR PASCAL IMPSetUsrFont(HWND,LPIMEPRO);
BOOL FAR PASCAL WINNLSQueryIMEInfo(HWND,HWND,LPIMEINFO);
#endif //TAIWAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2galloc.asm ===
PAGE    ,132
        TITLE   GALLOC - Global memory allocator

.sall
.xlist
include kernel.inc
include protect.inc
.list

.286p

DataBegin

externB  Kernel_flags
externB  fCheckFree
externW  pGlobalHeap
externW  WinFlags

gsearch_state_machine   dw      0
GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = NOT GA_ALIGN_BYTES


ifdef WOW
externB  fInAlloc
externW  SelectorFreeBlock
endif

public DpmiMemory, DpmiBlockCount
DpmiMemory DpmiBlock    NUM_DPMI_BLOCKS dup (<>)

DpmiBlockCount dw 0

DataEnd

sBegin  CODE
assumes CS,CODE

externNP gcompact
externNP gmovebusy
externNP gmoveable
externNP gslidecommon
externNP galign

externNP get_physical_address
externNP set_physical_address
externNP alloc_data_sel
externNP set_sel_limit
externNP free_sel
externNP get_blotto
externNP cmp_sel_address
externNP alloc_data_sel_above
externNP PreallocSel
externNP DPMIProc
ifdef WOW
externNP alloc_special_sel
endif

;-----------------------------------------------------------------------;
; gsearch                                                               ;
;                                                                       ;
; Searches from start to finish for a free global object to allocate    ;
; space from.  For a fixed request it tries to get the space as low as  ;
; possible, moving movable out of the way if neccessary.  For movable   ;
; requests it also starts at the bottom.  For discardable code it       ;
; starts from the top, only using the first free block it finds.        ;
;  If at first blush it can't find a block it compacts memory and tries ;
; again.                                                                ;
;  When it finally finds a block it gsplices it in, makes sure the      ;
; arena headers are fine, and returns the allocated block.              ;
;  Called from within the global memory manager's critical section.     ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocations flags                                          ;
;       BX = #paras                                                     ;
;       CX = owner field value                                          ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       AX = data address of block allocated or NULL                    ;
;       BX = ga_prev or ga_next                                         ;
;       DX = allocation flags                                           ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1                                                          ;
;       AX = 0                                                          ;
;       BX = ga_prev or ga_next                                         ;
;       DX = size of largest free block                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,DS                                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX,SI,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       galign                                                          ;
;       gfindfree                                                       ;
;       fmovebusy                                                       ;
;       gcheckfree                                                      ;
;       gcompact                                                        ;
;       gsplice                                                         ;
;       gzero                                                           ;
;       gmarkfree                                                       ;
;       use_EMS_land                                                    ;
;       use_lower_land                                                  ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Jul 22, 1987 11:15:19p  -by-  David N. Weise  [davidw]           ;
; Fixed BOGUS BLOCK freeing yet again.                                  ;
;                                                                       ;
;  Sun May 10, 1987 11:29:38p  -by-  David N. Weise  [davidw]           ;
; Added the state machine to handle the case of wanting to search       ;
; both global arenas.                                                   ;
;                                                                       ;
;  Sat Feb 28, 1987 06:31:11p  -by-  David N. Weise   [davidw]          ;
; Putting in support for allocating discardable code from EEMS land.    ;
;                                                                       ;
;  Tue Dec 30, 1986 01:54:50p  -by-  David N. Weise   [davidw]          ;
; Made sure it freed any bogus blocks created.                          ;
;                                                                       ;
;  Thu Nov 20, 1986 04:00:06p  -by-  David N. Weise   [davidw]          ;
; Rewrote it use the global free list.  Also made it put fixed requests ;
; as low as possible and to search again after a compact.               ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Tue Sep 23, 1986 04:35:39p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   gsearch,<PUBLIC,NEAR>
cBegin nogen

        SetKernelDS
        mov     gsearch_state_machine,codeOFFSET grow_heap

        mov     ds,pGlobalHeap
        UnSetKernelDS

look_again:
        push    bx                      ; Save requested size
        push    cx                      ; Save owner
        push    ax                      ; Save flags
        add     bx,1                    ; Room for header (set flags for galign)
        call    galign                  ; Get requested size in DX
        push    dx                      ; Save adjusted requested size

        inc     dx                      ; Fail quickly if asking for
        jnz     @f                      ;   too much memory
        jmp     gsearch_fail
@@:
        dec     dx

; see if there is any one free space large enough for the request first

        mov     si,dx
        dec     si                      ; Room for header
        mov     cx,[di].gi_free_count
        jcxz    were_hosed_from_start
        mov     es,[di].hi_first
is_there_one:
        mov     es,es:[di].ga_freenext
        cmp     si,es:[di].ga_size
        jbe     short got_one
        loop    is_there_one
were_hosed_from_start:
        jmp     space_not_found

got_one:
        mov     bx,ga_prev              ; search backwards
        test    al,GA_ALLOCHIGH
        jz      short alloc_low

;------ allocate disc code -------

        public  alloc_high
alloc_high:

        mov     cx,[di].gi_free_count
        mov     es,[di].hi_last         ; Start with last entry.
alloc_high_loop:
        mov     es,es:[di].ga_freeprev
        cmp     si,es:[di].ga_size
        ja      short loop_it
        jmp     afound                  ; Yes, exit search loop
loop_it:
        loop    alloc_high_loop
were_hosed:
        jmps    space_not_found

;------ allocate moveable ---------

        public  alloc_low
alloc_low:
        mov     bl,ga_next              ; Search forwards.
        test    al,GA_MOVEABLE
        jz      short alloc_fixed
        call    gcheckfree              ; Room for requested size?
        jb      short were_hosed
        jmp     afound

;------ allocate fixed ------------

        public  alloc_fixed
alloc_fixed:
        mov     es,[di].hi_first        ; Start with first entry.
        mov     cx,[di].hi_count
        mov     es,es:[bx]              ; Skip first sentinel
alloc_fixed_loop:
        push    cx
        push    es
        call    is_there_theoretically_enough_space
        cmp     ax,dx
        jb      short nope
        pop     es
        pop     cx
        call    can_we_clear_this_space
        jz      short anext1
        call    gcheckfree              ; Yes, room for requested size?
        jb      short anext1
                                        ; Now we have enough free space,
                                        ; slide it back as far as possible.
        push    ax                      ; This is to prevent us blocking
        push    dx                      ; the growth of moveable blocks.

keep_sliding:
        push    es
        mov     es,es:[di].ga_prev
        mov     ax,es
        mov     dx,es:[di].ga_size
        call    gmoveable               ; Is previous block moveable?
        pop     es
        jz      short no_slide

        call    PreallocSel
        jz      no_slide
        push    bx
        mov     bx, ga_prev             ; Sliding backwards
        push    es                      ; gslide will invalidate this block
        call    gslidecommon            ; C - calling convention
        call    free_sel                ; free the pushed selector
        pop     bx
        jmps    keep_sliding

no_slide:
        pop     dx                      ; requested size
        pop     ax                      ; block size
        pop     si                      ; adjusted requested size
        pop     cx                      ; flags

        push    cx                      ; these two expected on stack later
        push    si

        test    ch,GA_ALLOC_DOS             ;If this is a DOS land alloc
        jz      okey_dokey                  ;  make sure that the block
        push    ax                          ;  we found is below the 1 meg
        push    dx                          ;  boundry, or fail the request
        cCall   get_physical_address,<es>
        cmp     dx,0010h                    ;  (0010:0000 = 1024k = 1 meg)
        pop     dx
        pop     ax
        jae     space_not_found

okey_dokey:
        jmp     afound

nope:   or      ax,ax
        jz      short hosed_again
anext:  pop     si                      ; get rid of CX, ES on the stack
        pop     si
anext1: mov     es,es:[bx]
        loop    alloc_fixed_loop
        jmps    and_again

hosed_again:
        pop     es
        pop     cx
and_again:

; no one space big enough, try compacting

        public  space_not_found
space_not_found:
        pop     dx                      ; get size
        pop     ax                      ; get flags
        push    ax
        push    dx

        test    al,GA_ALLOCHIGH
        jnz     short ask_for_what_we_need
        add     dx,0400h                ; ask for 16k more
        jnc     short ask_for_what_we_need      ; no overflow
        mov     dx,-1

ask_for_what_we_need:
        SetKernelDS
        push    gsearch_state_machine
        mov     ds,pGlobalHeap
        UnSetKernelDS
        retn

;------------------------------

public  do_compact                      ; for debugging

do_compact:
        call    gcompact
        SetKernelDS
        mov     gsearch_state_machine,codeOFFSET gsearch_fail
        mov     ds,pGlobalHeap
        UnSetKernelDS

over_compact:        
        pop     dx
        pop     ax
        pop     cx
        pop     bx
        jmp     look_again

;------------------------------

public	grow_heap			; for debugging

grow_heap:
        SetKernelDS
	mov	gsearch_state_machine,codeOFFSET do_compact
        mov     ds,pGlobalHeap
        UnSetKernelDS
        call    GrowHeap
        jmp     over_compact
 
;------------------------------

public  gsearch_fail                    ; for debugging

gsearch_fail:                           ; get size of largest free block
        xor     dx,dx
        mov     cx,[di].gi_free_count
        jcxz    gs_failure
        mov     es,[di].hi_first
largest_loop:
        mov     es,es:[di].ga_freenext
        mov     ax,es:[di].ga_size
        cmp     dx,ax
        jae     short new_smaller
        mov     dx,ax
new_smaller:
        loop    largest_loop
gs_failure:
        pop     ax                      ; adjusted requested size
        pop     ax                      ; AX = flags

        pop     cx                      ; CX = owner field
        pop     ax                      ; waste requested size
        xor     ax,ax                   ; Return zero, with ZF = 1
        ret

; Here when we have a block big enough.
;   ES:DI = address of block
;   AX = size of block, including header
;   DX = requested size, including header
;   BX = ga_prev if backwards search and ga_next if forwards search

afound:

ifdef WOW      ; Optimized path for WOW

        push    ds
        SetkernelDS
        cmp     fInAlloc, 1
        UnSetKernelDS
        pop     ds

        jne     nothing_special

aallocsels:
        pop     cx                      ; adjusted requested size
        pop     ax                      ; get the flags

        push    ax                      ; restore the stack
        push    cx

        push    ax                      ; allocation flags
        push    es                      ; Selector FreeBlock
        mov     ax, es:[di].ga_size
        push    ax                      ; actual size of freeblock
        inc     ax
        mov     cx, ax                  ; save in cx too
        sub     cx, dx
        push    cx                      ; size new freeblock
        push    dx                      ; adjusted size
        push    bx                      ; bl = ga_prev pr ga_next
        call    alloc_special_sel
        jz      gs_failure              ;  no selector
        jmps    no_sel_wanted

nothing_special:

endif       ; End Optimized path for WOW

        mov     ax,es:[di].ga_size      ; Use actual size of free block
        inc     ax
        mov     cx,ax                   ; See how much extra space there is
        sub     cx,dx                   ; (found size - requested size)
        jcxz    no_sel_wanted
        call    PreallocSel             ; Make sure we can splice
        jz      gs_failure              ;  no selector
no_sel_wanted:
        mov     ax,es:[di].ga_freeprev
        xor     si,si                   ; Assume nothing extra to free
        call    gdel_free               ; remove the alloc block from freelist
if KDEBUG
        push    ds
        SetKernelDS
        cmp     fCheckFree,0
        pop     ds
        UnSetKernelDS
        jnz     short not_during_boot
        call    check_this_space
not_during_boot:
endif
        jcxz    aexit                   ; No, continue
        cmp     bl,ga_prev              ; Yes, scanning forwards or backwards?
        je      short abackward         ; Backwards.
;        mov     si,es                   ; Forwards.   Put extra space at end of
        mov     si,dx                   ; free block
        call    gsplice                 ; ES:DI = block we are allocating
        jmps    aexit                   ; SI = block to mark as free
abackward:
        mov     si,es:[di].ga_size      ; Scanning backwards.  Put extra space
        sub     si,dx                   ; at beginning of free block.
        inc     si
        call    gsplice
        mov     es,si                   ; ES:DI = block we are allocating
        mov     si,es:[di].ga_prev      ; SI = block to mark as free

; Here with allocated block
;   AX = data address or zero if nothing allocated
;   ES:DI = address of block to mark as busy and zero init if requested
;   SI = address of block to mark as free

aexit:
        pop     dx                      ; waste adjusted requested size
        pop     dx                      ; Restore flags
        pop     es:[di].ga_owner        ; Mark block as busy with owner field value
        pop     cx                      ; waste requested size
        mov     es:[di].ga_lruprev,di
        mov     es:[di].ga_lrunext,di
        push    ax                      ; previous free block
        mov     al,GA_SEGTYPE
        and     al,dl
        test    dh,GAH_NOTIFY
        jz      short no_notify
        or      al,GAH_NOTIFY
no_notify:
        mov     es:[di].ga_flags,al     ; Store segment type bits

        mov     ax,es                   ; AX = address of client data

        test    dl,GA_ZEROINIT          ; Want it zeroed?
        jz      short aexit1            ; No, all done

        push    ax
        cCall   get_blotto
        mov     cx,es:[di].ga_size      ; Yes, zero paragraphs
;       dec     cx                      ; to end of this block
        push    bx
        mov     bx,ax                   ; from beginning of client data
        call    gzero                   ; zero them
        pop     bx
        pop     ax
aexit1:
        mov     es,si                   ; Free any extra space
        pop     si                      ; previous free block
        dec     si                      ; make it RING 0 for gmarkfree
        call    gmarkfree

        or      ax,ax
        ret                             ; Return AX points to client portion
                                        ; of block allocated.
cEnd nogen

;-----------------------------------------------------------------------;
; is_there_theoretically_enough_space
;
; Starting at the given arena checks to see if there are enough
;  continuous free and unlocked moveable blocks.
;
; Entry:
;       CX = arenas to search
;       DX = size requested
;       DS = BurgerMaster
;       ES:DI = arena to start from
;
; Returns:
;       AX = 0 =>  not enough space and no more memory left to search
;       AX = 1 =>  not enough space in this block, but maybe....
;        otherwise
;       AX = size of block
;
; Registers Destroyed:
;       CX,SI
;
; Registers Preserved:
;       BX,DX,DI,ES
;
; History:
;  Mon 05-Sep-1988 15:21:14  -by-  David N. Weise  [davidw]
; Moved it here from gsearch so that grealloc could use it as well.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   is_there_theoretically_enough_space,<PUBLIC,NEAR>
cBegin nogen

        xor     ax,ax
ittes:
        cmp     es:[di].ga_owner,di
        jne     short is_it_moveable
        add     ax,es:[di].ga_size
        push    bx
        push    cx
        push    ax
        push    dx
        mov     cx,word ptr [di].gi_disfence_hi ; See if begin of reserve area
        mov     bx,word ptr [di].gi_disfence_lo ;  is above end of free block
        cCall   get_physical_address,<es:[di].ga_next>
        sub     bx,ax
        sbb     cx,dx                   ; used as cmp ONLY CARRY is VALID
        pop     dx
        pop     ax
        jb      short ittes_above_fence ; All below fence?
        pop     cx
        pop     bx
        jmps    this_ones_free
ittes_above_fence:
        REPT    4
        shr     cx,1
        rcr     bx,1
        ENDM
        add     ax,bx                   ; No, Reduce apparent size of free block
        pop     cx
        pop     bx
        inc     ax
        cmp     ax,dx
        jae     short theoretically_enough
        jmps    absolutely_not
is_it_moveable:
        test    es:[di].ga_flags,GA_DISCCODE
        jnz     short absolutely_not
        test    es:[di].ga_handle,GA_FIXED      ; See if movable.
        jnz     short theoretically_not
        cmp     es:[di].ga_count,0
        jne     short theoretically_not         ; See if locked.
        add     ax,es:[di].ga_size
this_ones_free:
        inc     ax
        cmp     ax,dx
        jae     short theoretically_enough
        mov     es,es:[ga_next]
        loop    ittes

; For the case of gsearch we should never get here for two reasons.
;  1) It should be impossible to have no discardable code loaded, in
;  this case we would have failed in the above loop.  2) We checked
;  at the very start for a free block somewhere that could have
;  satisfied the request.  In our mucking around to load as low as
;  possible we destroyed this free block and we did not produce a free
;  block we could use.  However we know from debugging code in 2.03
;  that this happens extremely rarely.  Because of the rareness of
;  this event we will not try to recover, instead we simply fail the call.

absolutely_not:
        mov     ax,-1                   ; return AX = 0
theoretically_not:
        inc     ax                      ; DX is even, => cmp the same.
theoretically_enough:
        ret
cEnd nogen



;-----------------------------------------------------------------------;
; can_we_clear_this_space
;
; Attempts to make a free space starting at the address moved in.
; To do this it moves moveable out of the area.  The only subtlety
; involves a free block that stradles the end of wanted area.  This
; may get broken into two pieces, the lower piece gets temporary marked
; as allocated and BOGUS, the upper piece will remain free.
;
; Entry:
;       CX = max number of blocks to look at
;       DX = size wanted in paragraphs
;       DS = BurgerMaster
;       ES:DI = beginning arena
;
; Returns:
;       ZF = 0
;        ES:DI points to free space
;       ZF = 1
;        couldn't free the space up
;
; Registers Destroyed:
;       AX,SI
;
; History:
;  Mon 05-Sep-1988 16:48:31  -by-  David N. Weise  [davidw]
; Moved it out of gsearch so that grealloc could use it.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   can_we_clear_this_space,<PUBLIC,NEAR>
cBegin nogen

        push    cx
        push    es
        mov     ax, es                  ; Beginning of space we want.
        cmp     di,es:[di].ga_owner     ; Is it free?
        jnz     short can_we_move_it
        mov     cx,dx
        dec     cx
        cmp     cx,es:[di].ga_size
        ja      short asdf
        or      ax,ax                   ; return ZF = 0
        pop     es
        pop     cx
        ret

asdf:   mov     es,es:[di].ga_next

        public can_we_move_it
can_we_move_it:
        push    bx
        push    cx
        push    dx
        push    es
        cmp     es:[di].ga_owner,GA_BOGUS_BLOCK
        jnz     short not_bogus
        xor     si,si
        call    gmarkfree
        jmp     restart
not_bogus:
        push    ax
        cCall   alloc_data_sel_above,<ax,dx>
        mov     si, ax                  ; End of space we want.
        pop     ax
        or      si, si
        jnz     got_marker_sel
        pop     cx                      ; Trash es saved on stack
        jmp     no_clear
got_marker_sel:
        mov     cx,[di].gi_free_count
        jcxz    forget_it               ; Nothing is free, so don't bother
        mov     dx,es:[di].ga_size      ; Yes, try to find a place for the
        mov     es,[di].hi_first        ;  moveable block
look_loop:
        mov     es,es:[di].ga_freenext
        mov     bx,es
        cCall   cmp_sel_address,<bx,ax> ; It defeats our purpose to move the
        jb      short check_this_out    ;  block to a free space we want.
        cCall   cmp_sel_address,<bx,si>
        jb      short is_there_hope
check_this_out:
        push    ax
        call    gcheckfree
        push    cx
        jb      short inopportune_free_space
        cCall   free_sel,<si>
        pop     cx
        pop     ax

        pop     si                      ; SI = moveable block for gmovebusy
        mov     bx,ga_next
        call    gmovebusy               ; Move moveable block out of the way
        pop     dx
        pop     cx
        pop     bx
        pop     cx                      ; WAS pop es but es destroyed below
        pop     cx
        mov     es,si                   ; Replace the ES on the stack,
                                        ;  the free block may have grown
                                        ;  downward with the gmovebusy.
        jmp     can_we_clear_this_space

inopportune_free_space:
        pop     cx
        pop     ax
        loop    look_loop
forget_it:
        jmp     couldnt_clear_it

        public is_there_hope
is_there_hope:
        push    ax
        push    cx
        push    dx
        cCall   get_physical_address,<es:[di].ga_next>
        mov     cx, dx
        mov     bx, ax
        cmp     cx, [di].gi_disfence_hi
        jb      below_reserved
        ja      above_reserved
        cmp     bx, [di].gi_disfence_lo
        jbe     short below_reserved
above_reserved:
        mov     cx, [di].gi_disfence_hi
        mov     bx, [di].gi_disfence_lo
        
below_reserved:
        cCall   get_physical_address,<si>
        sub     bx, ax
        sbb     cx, dx                  ; Check the overlap.
        
        jae     short overlap
        pop     dx
        jmps inopportune_free_space
overlap:
REPT 4
        shr     cx, 1
        rcr     bx, 1
ENDM
        mov     cx, dx
        pop     dx
        cmp     bx,dx
        jbe     short inopportune_free_space

        mov     bx, ax
        cCall   get_physical_address,<es>
        sub     bx, ax
        sbb     cx, dx
REPT 4
        shr     cx, 1
        rcr     bx, 1
ENDM
        cCall   free_sel,<si>
        mov     si, bx
        pop     cx
        pop     ax

; cut off the first piece for the original alloc

        push    es:[di].ga_freeprev
        call    gdel_free
if KDEBUG
        push    ds
        SetKernelDS
        cmp     fCheckFree,0
        pop     ds
        UnSetKernelDS
        jnz     short not_during_boot_1
        call    check_this_space
not_during_boot_1:
endif
        call    gsplice

; ES:DI = addr of block to mark as busy, SI = addr of block to mark as free

        mov     es:[di].ga_owner,GA_BOGUS_BLOCK
        mov     es:[di].ga_lruprev,di
        mov     es:[di].ga_lrunext,di
        mov     es,si                   ; Free any extra space
        pop     si                      ; previous free block
        dec     si                      ; make it RING 0 for gmarkfree
        call    gmarkfree
restart:
        pop     dx                      ; WAS pop es
        pop     dx
        pop     cx
        pop     bx
        pop     es
        pop     cx
        jmp     can_we_clear_this_space

; If here then failure! see if we made a bogus block!

couldnt_clear_it:
        pop     es                      ; recover block we wanted moved
check_again:
        mov     dx,es:[di].ga_next
        cCall   cmp_sel_address,<dx,si> ; SI points to where bogus block
        ja      short no_bogus_block    ;   would be.
        je      short is_it_bogus
        mov     es,dx
        cmp     dx, es:[di].ga_next
        je      short no_bogus_block
        jmp     check_again
is_it_bogus:
        cmp     es:[di].ga_owner,GA_BOGUS_BLOCK
        jnz     short no_bogus_block
        push    si
        xor     si,si
        call    gmarkfree
        pop     si
no_bogus_block:

if KDEBUG
        mov     cx,[di].hi_count
        mov     es,[di].hi_first
bogus_all:
        cmp     es:[di].ga_owner,GA_BOGUS_BLOCK
        jnz     short not_me
        INT3_ANCIENT
not_me: mov     es,es:[di].ga_next
        loop    bogus_all
endif
        cCall   free_sel,<si>

no_clear:
        pop     dx
        pop     cx
        pop     bx
        pop     es
        pop     cx
        xor     ax,ax                   ; return ZF = 1
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gfindfree                                                             ;
;                                                                       ;
; Searches for a free block that is big enough but does not encroach    ;
; on the area reserved for code swapping.                               ;
;                                                                       ;
; Arguments:                                                            ;
;       ES:DI = address of existing block to start looking at           ;
;       CX = #arena entries left to look at                             ;
;       BX = direction of search, ga_next or ga_prev                    ;
;       DX = #paragraphs needed                                         ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       AX = address of free block that is big enough                   ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,CX,DX,DI,SI,DS,ES                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       gcheckfree                                                      ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Sep 24, 1986 10:16:38p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gfindfree,<PUBLIC,NEAR>
cBegin nogen
        push    cx
        push    es
gffloop:
        cmp     es:[di].ga_owner,di     ; Free block?
        jne     short gffnext           ; No, continue
        call    gcheckfree              ; Yes, is it big enough?
        mov     ax,es
        jae     short gffexit           ; Yes, return
gffnext:
        mov     es,es:[bx]              ; next or previous block
        loop    gffloop
gfffail:
        xor     ax,ax                   ; No, return zero in AX
gffexit:
        pop     es
        pop     cx
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gcheckfree                                                            ;
;                                                                       ;
; Checks the size of the passed free block against the passed desired   ;
; size, making sure that the limitations of the code reserve area are   ;
; not violated for objects other than discardable code. It also checks  ;
; for Phantoms.                                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       ES:DI = address of free block                                   ;
;       DX = #paragraphs needed                                         ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       CF = 0 block big enough                                         ;
;       AX = apparent size of free block                                ;
;                                                                       ;
; Error Returns:                                                        ;
;       none                                                            ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu 27-Apr-1989  10:38:05   -by-  David N. Weise   [davidw]          ;
; Fixed this to work in pmode.                                          ;
;                                                                       ;
;  Thu Apr 02, 1987 10:45:22p  -by-  David N. Weise   [davidw]          ;
; Added Phantom support.                                                ;
;                                                                       ;
;  Tue Sep 23, 1986 05:54:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gcheckfree,<PUBLIC,NEAR>
cBegin nogen
        push    si
        mov     ax,es:[di].ga_size      ; Compute size of free block
        inc     ax
        test    byte ptr [di].gi_cmpflags,GA_DISCCODE
        jnz     short gcftest           ; Discardable code not restricted

; Due to recent changes in the way disccode is allocated, we must make
;  sure that non-disccode in never allocated above a disccode block.

        push    es
might_be_code_below:
        mov     es,es:[di].ga_prev
        cmp     es:[di].ga_owner,GA_NOT_THERE
        jz      short might_be_code_below
        cmp     es:[di].ga_owner,di     ; Free block?
        jz      short might_be_code_below
        test    es:[di].ga_flags,GA_DISCCODE
        pop     es
        jnz     short gcfrsrv1

        push    bx
        push    cx
        push    ax
        push    dx
        mov     cx,word ptr [di].gi_disfence_hi ; See if begin of reserve area
        mov     bx,word ptr [di].gi_disfence_lo ;  is above end of free block
        cCall   get_physical_address,<es:[di].ga_next>
        sub     bx,ax
        sbb     cx,dx                   ; used as cmp ONLY CARRYY is VALID
        pop     dx
        pop     ax
        jae     short gcftest1          ; Yes, return actual size of free block
        REPT    4
        shr     cx,1
        rcr     bx,1
        ENDM
        neg     bx
        sub     ax,bx                   ; No, Reduce apparent size of free block
        ja      short gcftest1          ; Is it more than what is free?

        xor     ax,ax                   ; Yes, then apparent size is zero
                                        ; Nothing left, set apparent size to 0
gcftest1:
        pop     cx
        pop     bx
        jmps    gcftest
gcfrsrv1:                               ; Yes, then apparent size is zero
        xor     ax,ax                   ; Nothing left, set apparent size to 0
gcftest:
        cmp     ax,dx                   ; Return results of the comparison
        pop     si
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gsplice                                                               ;
;                                                                       ;
; Splits one block into two.                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       SI = size in paragraphs of new block to make                    ;
;       ES:DI = address of existing block                               ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       SI = address of new block                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       nothing                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,DX,DI,DS,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 23, 1986 03:50:30p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gsplice,<PUBLIC,NEAR>
cBegin nogen

        push    bx
        push    dx
        mov     dx,si                   ; save size
        mov     bx,es:[di].ga_size
        sub     bx,dx                   ; get size of 2nd new block made

        push    ax
        push    bx
        push    dx

ifdef WOW      ; Optimized path for WOW

        push    ds
        SetkernelDS
        mov     ax, SelectorFreeBlock  ; same as fInAlloc == 1
        or      ax, ax
        UnSetKernelDS
        pop     ds
        jnz     gsplice_oldpath2

gsplice_oldpath:
endif         ; end optimized path for WOW

        mov     bx,si
        xor     cx,cx
        REPT    4
        shl     bx,1
        rcl     cx,1
        ENDM
        cCall   get_physical_address,<es>
        add     ax,bx
        adc     dx,cx
        cCall   alloc_data_sel,<dx,ax,1>

ifdef WOW
gsplice_oldpath2:
endif
        mov     si,ax
        pop     dx
        pop     bx
        pop     ax
        inc     [di].hi_count           ; Adding new arena entry
        push    si                      ; save new
        push    es                      ; save old
        mov     cx,si                   ; save old.next
        xchg    es:[di].ga_next,cx      ; and old.next = new
        mov     es,cx
        mov     es:[di].ga_prev,si      ; [old old.next].prev = new
        mov     es,si
        mov     es:[di].ga_next,cx      ; new.next = old old.next
        mov     es:[di].ga_size,bx
        pop     cx                      ; new.prev = old
        mov     es:[di].ga_sig,GA_SIGNATURE
        mov     es:[di].ga_owner,di     ; Zero owner & handle fields
        mov     es:[di].ga_flags,0      ; For good measure.
        mov     es:[di].ga_prev,cx
        mov     es:[di].ga_handle,di
        mov     es,cx                   ; ES = old
        dec     dx                      ; get size of 1st block made
        mov     es:[di].ga_size,dx
        pop     si                      ; restore new
        pop     dx
        pop     bx
        ret
cEnd nogen

;-----------------------------------------------------------------------;
; gjoin                                                                 ;
;                                                                       ;
; Merges a block into his previous neighbor.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       ES:DI = address of block to remove                              ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       nothing                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       nothing                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       gdel_free                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Tue Sep 23, 1986 03:58:00p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gjoin,<PUBLIC,NEAR>
cBegin nogen
        push    ax
        push    bx
        dec     [di].hi_count
        call    gdel_free
        mov     ax,es:[di].ga_size
        mov     si,es:[di].ga_prev      ; who points to this block
        mov     es,es:[di].ga_next      ; Get address of block after
if KDEBUG
        mov     bx, es
        cmp     bx, es:[di].ga_prev
        jne     short ok
        INT3_FATAL
ok:
endif
        cCall   free_sel,<es:[di].ga_prev>      ; Free selector being removed
        mov     es:[di].ga_prev,si      ; one we are removing.
        push    es                      ; Change it's back link
        mov     es,si
        pop     es:[di].ga_next         ; and change the forward link
        inc     ax                      ; Recompute size of block
        add     es:[di].ga_size,ax
        pop     bx
        pop     ax
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gzero                                                                 ;
;                                                                       ;
; Fills the given area with zeros.                                      ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = address of first paragraph                                 ;
;       CX = address of last paragraph                                  ;
;                                                                       ;
; Returns:                                                              ;
;       BX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,DX,DI,SI,DS,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX                                                              ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 23, 1986 04:08:55p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gzero,<PUBLIC,NEAR>
cBegin nogen

; Assumptions: on entry, BX contains selector to start of block, and is
; for a scratch descriptor that can be modified.  CX contains the # of
; paragraphs to be zeroed.

        push    es                      ; Determine if we're running on an
        SetKernelDS es                  ;   80286.  If so, we gotta worry
        test    es:WinFlags,WF_CPU286   ;   about 64k segments.
        jz      its_a_386

        UnSetKernelDS es                ; removes addressibility from es

        push    ax
        push    bx
        push    cx
        push    dx
        push    di

        cld
        mov     es,bx                   ; address block with es
        mov     bx,cx                   ; bx = total # paras to zero
        jcxz    gzexit                  ; just in case...

        push    bx                      ; Say it ain't so, Joe...
        xor     cx,cx                   ; force the incoming sel/descriptor to
        mov     bx,cx                   ;  a limit of 64k - it might be higher
        inc     cx                      ;  which would cause set_physical_adr
        cCall   set_sel_limit,<es>      ;  to destroy following descriptors.
        pop     bx

        jmp     short gz_doit

next_64k:
        push    es
        cCall   get_physical_address,<es>       ;update selector to next
        inc     dl                              ;  64k block
        cCall   set_physical_address,<es>
        pop     es                              ;reload it with new base

gz_doit:
        mov     cx,1000h                ; 1000h paras = 64k bytes
        cmp     bx,cx
        jae     @f
        mov     cx,bx                   ; less than 64k left
@@:
        sub     bx,cx                   ; bx = # paras left to do
        shl     cx,3                    ; cx = # words to zero this time
        xor     ax,ax
        mov     di,ax
        rep stosw

        or      bx,bx                   ; more to do?
        jnz     short next_64k          ; go do the next block

gzexit:
        pop     di
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     es
        ret

; The CPU is an 80386 or better, zero the memory a faster way...

its_a_386:

        .386

        push    eax
        push    edi
        push    ecx

        movzx   ecx, cx
        shl     ecx, 2                  ; # dwords to clear
        mov     es, bx
        xor     eax, eax
        xor     edi, edi

        cld
        rep     stos    dword ptr es:[edi]

        pop     ecx
        pop     edi
        pop     eax
        pop     es
        ret

        .286p

cEnd nogen


;-----------------------------------------------------------------------;
; gmarkfree                                                             ;
;                                                                       ;
; Marks a block as free, coalesceing it with any free blocks before     ;
; or after it.  This does not free any handles.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       SI    = the first free object before this one                   ;
;               0 if unknown                                            ;
;               Ring 1 if no free list update wanted                    ;
;               Ring 0 if free list update required                     ;
;       ES:DI = block to mark as free.                                  ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 1 if freed a fixed block                                   ;
;        SI = 0                                                         ;
;       ZF = 0 if freed a moveable block                                ;
;        SI = handle table entry                                        ;
;       ES:DI = block freed (may have been coalesced)                   ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DS                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       none                                                            ;
;                                                                       ;
; Calls:                                                                ;
;       gjoin                                                           ;
;       gadd_free                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Sun Nov 09, 1986 01:35:08p  -by-  David N. Weise   [davidw]          ;
; Made the debugging version fill all free space with CCCC.             ;
;                                                                       ;
;  Wed Sep 24, 1986 10:27:06p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gmarkfree,<PUBLIC,NEAR>
cBegin nogen

        call    gadd_free
        mov     si,es
        or      si,si
        jz      short gmf_exit

; Mark this block as free by clearing the owner field.

        mov     es:[di].ga_sig,GA_SIGNATURE
        mov     es:[di].ga_owner,di     ; Mark as free
        mov     es:[di].ga_flags,0      ; For good measure.

; Remember the handle value in DX, before setting to zero.

        push    dx
        xor     dx,dx
        xchg    es:[di].ga_handle,dx

; Try to coalesce with next block, if it is free

        push    es:[di].ga_prev         ; save previous block
        mov     es,es:[di].ga_next      ; ES = next block
        cmp     es:[di].ga_owner,di     ; Is it free?
        jne     short free2             ; No, continue
        call    gjoin                   ; Yes, coalesce with block we are freeing
free2:
        pop     es                      ; ES = previous block
        cmp     es:[di].ga_owner,di     ; Is it free?
        jne     short free3             ; No, continue
        mov     es,es:[di].ga_next      ; Yes, coalesce with block we are freeing;
        call    gjoin
free3:
        mov     si,dx                   ; Return 0 or handle in SI
        pop     dx                      ; restore handle
        cmp     es:[di].ga_owner,di     ; Point to free block?
        je      short free4             ; Yes, done
        mov     es,es:[di].ga_next      ; No, leave ES pointing at free block
free4:
if KDEBUG
        call    CCCC
endif   
gmf_exit:
        or      si,si
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gadd_free                                                             ;
;                                                                       ;
; Links in the given partition into the global free list.               ;
;                                                                       ;
; Arguments:                                                            ;
;       SI    = the first free object before this one                   ;
;               0 if unknown                                            ;
;               odd if no free list update wanted                       ;
;       DS:DI = BurgerMaster                                            ;
;       ES:DI = free global object to add                               ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun Nov 09, 1986 02:42:53p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   gadd_free,<PUBLIC,NEAR>
cBegin nogen
        test    si,1
        jnz     no_update_wanted

        push    ax
        push    si
        push    ds
        mov     ax,es
        or      ax,ax                   ; this happens with gmovebusy
        jz      gaf_exit

        inc     [di].gi_free_count

        ;
        ; For DPMI compliance, we cannot look at addresses of
        ; selectors in the LDT and DPMI calls would be too slow,
        ; so we scan forward from the block we are freeing,
        ; looking for a free block or the sentinal and insert
        ; the new block before it.
        ;
        smov    ds, es
need_a_home_loop:
        mov     ds, ds:[di].ga_next
        cmp     ds:[di].ga_owner, di    ; Free?
        je      found_a_home
        cmp     ds:[di].ga_sig, GA_ENDSIG       ; Sentinal
        jne     need_a_home_loop

found_a_home:
        mov     si, ds:[di].ga_freeprev ; Fix up block after free block
        mov     ds:[di].ga_freeprev, es

        mov     es:[di].ga_freeprev,si  ; Fix up free block
        mov     es:[di].ga_freenext,ds

        mov     ds,si                   ; Fix up block before free block
        mov     ds:[di].ga_freenext,es

if KDEBUG
        call    check_free_list
endif

gaf_exit:
        pop     ds
        pop     si
        pop     ax

no_update_wanted:
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gdel_free                                                             ;
;                                                                       ;
; Removes a partition from the global free list.                        ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:DI = BurgerMaster                                            ;
;       ES:DI = arena header of partition                               ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun Nov 09, 1986 02:43:26p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   gdel_free,<PUBLIC,NEAR>
cBegin nogen
        push    ax
        push    ds
        push    es
        mov     ds,es:[di].ga_freeprev
        mov     es,es:[di].ga_freenext
        mov     ds:[di].ga_freenext,es
        mov     es:[di].ga_freeprev,ds
        pop     es
        pop     ds

        dec     [di].gi_free_count
gfx:
        pop     ax

if KDEBUG
        call    check_free_list
endif
        ret
cEnd nogen

;-----------------------------------------------------------------------
;  GrowHeap -- this procedure grows the global heap
;
;  Input:
;       None
;
;  Output:
;       carry clear for success
;
        public GrowHeap
GrowHeap proc near
        
        push    si
        push    di
        push    bx
        push    es
        
        xor     si,si
        
        ;
        ; Request 1 MB
        ;
        xor     ax,ax
        call    AllocDpmiBlock
        
        or      ax,ax
        jz      gh30
        
        ;
        ; Format the block
        ;
        or      bx,bx
        jnz     gh10
        
        mov     si,1
gh10:   mov     dx,ax
        call    FormatHeapBlock
        

        ;
        ; Add the block to the heap
        ;
        call    AddBlockToHeap
        
        clc
gh20:   pop     es
        pop     bx
        pop     di
        pop     si
        ret
        
gh30:   stc
        jmp     gh20
        
GrowHeap endp
;-----------------------------------------------------------------------
;  FormatHeapBlock -- this procedure initializes three arenas in a
;	global heap block.  The first arena is marked as the heap
;	initial sentinel, the second arena is the heap free block, and
;	the third arena at the very end of the block is marked as
;	'not there'.
;
;  In:	SI:BX - size of block in paragraphs
;	DX - selector pointing to start of block (descriptor is modified!)
;
;  Out: AX - selector to ending 'not there' block
;	BX - zero
;	SI - selector to initial sentinel
;	DI - selector to free block arena
;	ES:BX -> initial sentinel arena
;
;  Uses: CX, DX
        public FormatHeapBlock
FormatHeapBlock proc	near

; Setup selector to first arena (the new initial sentinel)

	push	bx				;save # paragraphs
	push	si

	mov	bx,dx				;get physical address of start
	cCall	get_physical_address,<bx>

	push	ax				;save unaligned start address
	push	dx

	add	ax,GA_ALIGN_BYTES
	adc	dx,0
	and	ax,GA_MASK_BYTES

	cCall	set_physical_address,<bx>
	mov	si,bx				;si -> initial sentinel

	mov	bx,10h				;set initial selector to
	xor	cx,cx				;  be just 1 arena long
	cCall	set_sel_limit,<si>

; Setup selector to second arena (the free block)

	add	ax,10h+GA_ALIGN_BYTES
	adc	dx,0
	and	ax,GA_MASK_BYTES
	cCall	alloc_data_sel,<dx,ax,1>
	mov	di,ax				;di -> free block arena

; Setup selector to the third arena ('NOT THERE' at end of heap block)

	pop	dx				;recover unaligned start addr
	pop	ax

	pop	cx				;recover len in paragraphs
	pop	bx
		  
	sub	bx,1
	sbb	cx, 0
rept 4	  	     
	shl	bx,1
	rcl	cx,1				;cx:bx = len in bytes
endm
	add	ax,bx
	adc	dx,cx
	and	ax,GA_MASK_BYTES		;dx:ax -> not there arena addr

	push	ax				;save not there arena address
	push	dx

	cCall	alloc_data_sel,<dx,ax,1>

; Now fill in the arenas

	mov	es,ax
	assumes es,nothing

	xor	bx,bx				;es:bx -> not there arena

	mov	es:[bx].ga_sig,GA_SIGNATURE
	mov	es:[bx].ga_owner,GA_NOT_THERE
	mov	es:[bx].ga_flags,bl
	mov	es:[bx].ga_size,bx
	mov	es:[bx].ga_prev,di
	mov	es:[bx].ga_handle,bx
	mov	es:[bx].ga_lrunext,bx
	mov	es:[bx].ga_lruprev,bx

	mov	es,di				;es:bx -> free block

	mov	es:[bx].ga_sig,GA_SIGNATURE
	mov	es:[bx].ga_owner,bx
	mov	es:[bx].ga_flags,bl
	mov	es:[bx].ga_prev,si
	mov	es:[bx].ga_next,ax
	mov	es:[bx].ga_handle,bx
	mov	es:[bx].ga_lrunext,bx
	mov	es:[bx].ga_lruprev,bx

	pop	cx				;cx:bx = address of end arena
	pop	bx
	push	ax				;save not there selector

	cCall	get_physical_address,<di>	;dx:ax = address of free arena
	sub	bx,ax
	sbb	cx,dx				;cx:bx = length in bytes
rept	4
	shr	cx,1
	rcr	bx,1
endm
	sub	bx,1
	sbb	cx,0				;cx:bx = length in paragraphs

	or	cx, cx				; Less than 1024k?
	jz	@F				;   yes, set correct size
	xor	bx, bx				;   no, set bogus size
@@:		    
	mov	cx,bx
	xor	bx,bx
	mov	es:[bx].ga_size,cx		;save free block size (<1024k)

	pop	ax				;recover end arena selector

	mov	es,si				;es:bx -> initial sentinel

	mov	es:[bx].ga_sig,GA_SIGNATURE
	mov	es:[bx].ga_size,bx
	mov	es:[bx].ga_owner,GA_NOT_THERE
	mov	es:[bx].ga_flags,bl
	mov	es:[bx].ga_prev,si		;first.prev = self
	mov	es:[bx].ga_next,di
	mov	es:[bx].ga_handle,bx
	mov	es:[bx].ga_lrunext,bx
	mov	es:[bx].ga_lruprev,bx

	ret

FormatHeapBlock endp

;-----------------------------------------------------------------------
;
;  In:  AX - selector to ending 'not there' block
;	BX - zero
;	SI - selector to initial sentinel
;	DI - selector to free block arena
;	ES:BX -> initial sentinel arena
        public AddBlockToHeap
AddBlockToHeap proc near

        pusha
        push    bp
        mov     bp,sp       
        sub     sp,8
SelFirstBlock equ word ptr [bp - 2]
SelLastBlock equ word ptr [bp - 4]
SelFreeBlock equ word ptr [bp - 6]
SelInsertBlock equ word ptr [bp - 8]

        mov     SelFirstBlock,si
        mov     SelLastBlock,ax
        mov     SelFreeBlock,di
        
        ;
        ; Get the physical address of this block
        ;
        cCall   get_physical_address, <si>
        mov     bx,ax
        mov     cx,dx
        
        xor     di,di
        ;
        ; search for the correct place to insert it.
        ;
        mov     si,[di].hi_first
        
abh20:  cCall   get_physical_address, <si>
        cmp     dx,cx
        jb      abh40
        ja      abh60
        
        cmp     ax,bx
        jb      abh40
        
        ;
        ; Found our spot
        ;
        jmp     abh60
        
        ;
        ; Check the next block
        ;
abh40:  mov     es,si
        ;
        ; Have we reached the end of the list?
        ;
        cmp     si,es:[di].ga_next
        mov     si,es:[di].ga_next
        jne     abh20
                
        ;
        ; es contains the selector of the block to insert this
        ; heap partition after
        ;
abh60:
	add	[di].hi_count,3 	;three more arenas
        mov     ax,GA_SIGNATURE
        cmp     es:[di].ga_sig,GA_ENDSIG
        jne     abh70
        
        ;
        ; New block will be at the end of the heap
        ;
        mov     es:[di].ga_sig,GA_SIGNATURE
        mov     ax,GA_ENDSIG
    
        ;
        ; make this the next block in the heap
        ;
abh70:  mov     dx,SelFirstBlock
        mov     bx,es:[di].ga_next
        mov     es:[di].ga_next,dx
        mov     cx,es
        mov     SelInsertBlock,cx
        mov     es,dx
        mov     es:[di].ga_prev,cx
        
        ;
        ; Put the last block last
        ;
        mov     dx,SelLastBlock
        mov     es,dx
        mov     es:[di].ga_next,bx
        
        ;
        ; If this block was last, don't update next.prev 
        ;
        cmp     ax,GA_ENDSIG
        je      abh75
        
        mov     es,bx
        mov     es:[di].ga_prev,dx
        jmp     abh80
        
        ;
        ; Fix the old heap end block
        ;
abh75:  mov     es,[di].hi_last
        mov     es:[di].ga_owner,GA_NOT_THERE
        mov     es:[di].ga_sig,GA_SIGNATURE
        mov     es:[di].ga_size,di
        mov     cx,es:[di].ga_freeprev
        mov     es:[di].ga_freeprev,di
        mov     es:[di].ga_freenext,di
        
        ;
        ; Turn the new end block into a proper end block
        ;
        mov     es,SelLastBlock
        mov     es:[di].ga_sig,GA_ENDSIG
        mov     es:[di].ga_owner,-1
        mov     bx,SelFreeBlock
        mov     es:[di].ga_freeprev,bx
        mov     es:[di].ga_freenext,-1
        mov     es:[di].ga_size,GA_ALIGN
        mov     ax,SelLastBlock
        mov     es:[di].ga_next,ax
        
        ; 
        ; Fix the free list
        ;
        mov     es,cx
        mov     es:[di].ga_freenext,bx
        mov     es,bx
        mov     es:[di].ga_freeprev,cx
        mov     ax,SelLastBlock
        mov     es:[di].ga_freenext,ax
        
        ;
        ; Fix the discardable code fence
        ;
        cCall   get_physical_address, <[di].hi_last>
        sub     ax,[di].gi_disfence
        sbb     dx,[di].gi_disfence_hi
        
        mov     bx,ax
        mov     cx,dx
        cCall   get_physical_address, <SelLastBlock>
        
        sub     ax,bx
        sbb     dx,cx
        
        mov     [di].gi_disfence,ax
        mov     [di].gi_disfence_hi,dx
        
        ;
        ; Increment the free block count
        ;
        inc     [di].gi_free_count
        
        ;
        ; Make this block the last block in the heap
        ;
        mov     ax,SelLastBlock
        mov     [di].hi_last,ax
        jmp     abh90
        
        ;
        ; Add the free block to the free list
        ;
abh80:  mov     es,SelFreeBlock
        mov     si,0
        cCall   gadd_free
        
abh90:  mov     sp,bp
        pop     bp
        popa
        ret

AddBlockToHeap endp

;-----------------------------------------------------------------------;
; AllocDpmiBlock                                                        ;
;                                                                       ;
;       Allocates a block from DPMI and stores the information in       ;
;       DpmiMemory.  It also allocates a selector for the beginning of  ;
;       the block.                                                      ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
;       AX = size of block to allocate in paragraphs                    ;
;                                                                       ;
; Returns:                                                              ;
;       AX = selector to block if allocated		                ;
;	BX = size of block in paragraphs 	                        ;
;	BX = zero if block is 1 megabyte in size.	                ;
;                                                                       ;
; Error Returns:                                                        ;
;	AX = zero if error				                ;
;                                                                       ;
;-----------------------------------------------------------------------;
        public AllocDpmiBlock
AllocDpmiBlock proc near
        push    es
        push    ds
        push    si
        push    di
        push    cx
        push    bp
        mov     bp,sp
        sub     sp,30h  ; space for meminfo structure
MemInfo equ     [bp - 30h]        
        SetKernelDS
        ;
        ; Find an unused Dpmi Block
        ;
        mov     si,0
        mov     cx,NUM_DPMI_BLOCKS - 1
adb3:   cmp     DpmiMemory[si].DBSel,0
        je      adb5
        
        add     si,size DpmiBlock
        loop    adb3
        
        ;
        ; Did We find one?
        ;
        cmp     DpmiMemory[si].DBSel,0
        jne     adb140
        
        ;
        ; Store expected size
        ;
adb5:   mov     DpmiMemory[si].DBSize, ax
        
        ;
        ; Convert paragraphs to bytes (if paragraphs = 0, then alloc a 
        ; megabyte)
        ;
        mov     cx,ax
        mov     bx,10h
        or      cx,cx
        jz      adb10
        
        mov     bx,ax
        shr     bx,0ch
        shl     cx,04h
        
        ;
        ; Attempt to allocate the block
        ;
adb10:  push    si
        DPMICALL 501h
        mov     dx,si
        pop     si
        jc      adb100
        
        ;
        ; put information into dpmi memory list
        ;
adb20:  mov     DpmiMemory[si].DBHandleLow,di
        mov     DpmiMemory[si].DBHandleHigh,dx
        
        ;
        ; Allocate a selector for the beginning of the block
        ;
	cCall	alloc_data_sel,<bx,cx,1>
        
        ;
        ; Remember the selector
        ;
        mov     DpmiMemory[si].DBSel,ax
        
        ;
        ; Update the number of dpmi blocks
        ;
        inc     DpmiBlockCount
 
        ;
        ; Return the information
        ;
        mov     bx,DpmiMemory[si].DBSize
 adb40: mov     sp,bp
        pop     bp
        pop     cx
        pop     di
        pop     si
        pop     ds
        pop     es
        ret
        
        ;
        ; Couldn't allocate a block the size we wanted.  Find the largest
        ; block we can allocate
        ;
adb100: mov     ax,ss
        mov     es,ax
        lea     di,MemInfo
        DPMICALL 500h
        jc      adb140
        
        ;
        ; Convert block size to paragraphs
        ;
        mov     ax,es:[di]
        mov     dx,es:[di + 2]
        mov     bx,dx
        mov     cx,ax
        shl     dx,0ch
        shr     ax,4
        or      ax,dx
        
        ;
        ; Store expected size 
        ; N.B. We don't jump back into the above code, because this
        ;      could result in an infinite loop if something is seriously
        ;      wrong with DPMI.
        ;
        mov     DpmiMemory[si].DBSize, ax
        
        ;
        ; Attempt to allocate the block
        ;
        push    si
        DPMICALL 501h
        mov     dx,si
        pop     si
        jnc     adb20
        
        ;
        ; We have failed to allocate the memory
        ;
adb140: xor     ax,ax
        jmp     adb40
        
        UnsetKernelDS
AllocDpmiBlock endp
if KDEBUG

;-----------------------------------------------------------------------;
; CCCC                                                                  ;
;                                                                       ;
; Fills the given area with DBGFILL_FREE                                ;
;                                                                       ;
; Arguments:                                                            ;
;       ES:DI = arena header of free area.                              ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All.                                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun Nov 09, 1986 01:39:52p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   CCCC,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        SetKernelDS
        cmp     fCheckFree,0
        jnz     short dont_CCCC         ; not while booting
        test    Kernel_flags,kf_check_free
        jz      short dont_CCCC
        push    ax
        push    bx
        push    cx
        push    dx
        push    di
        push    es
        mov     bx,es:[di].ga_size
        mov     ax,es
        call    get_blotto
        mov     es,ax

;;;     mov     cx,ss                   ; make sure we're not wiping
;;;     cmp     cx,ax                   ;  out the stack
;;;     jb      short by_64Kb_loop
;;;     add     ax,bx
;;;     cmp     cx,ax
;;;     ja      short by_64Kb_loop      ; yes it wastes debugging bytes
;;;     jmps    no_not_the_stack        ;  but it's readable

        push    bx                      ; Say it ain't so, Joe...
        xor     cx,cx                   ; force the incoming sel/descriptor to
        mov     bx,cx                   ;  a limit of 64k - it might be higher
        inc     cx                      ;  which would cause set_physical_adr
        cCall   set_sel_limit,<es>      ;  to destroy following descriptors.
        pop     bx

        jmp     short CC_doit

CC_next_64k:
        push    es
        cCall   get_physical_address,<es>       ;update selector to next
        inc     dl                              ;  64k block
        cCall   set_physical_address,<es>
        pop     es                              ;reload it with new base

CC_doit:
        mov     cx,1000h                ; 1000h paras = 64k bytes
        cmp     bx,cx
        jae     @f
        mov     cx,bx                   ; less than 64k left
@@:
        sub     bx,cx                   ; bx = # paras left to do
        shl     cx,3                    ; cx = # words to CC this time
        mov     ax,(DBGFILL_FREE or (DBGFILL_FREE SHL 8))
        xor     di, di
        rep stosw

        or      bx,bx                   ; more to do?
        jnz     short CC_next_64k       ; go do the next block
no_not_the_stack:
        pop     es
        pop     di
        pop     dx
        pop     cx
        pop     bx
        pop     ax
dont_CCCC:
        pop     ds
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; init_free_to_CCCC                                                     ;
;                                                                       ;
; Initializes all of the free space to zero.  It speeds booting if      ;
; CCCCing is not done during boot time.                                 ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       CCCC                                                            ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Nov 19, 1986 09:41:58a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   init_free_to_CCCC,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        SetKernelDS
        test    Kernel_flags,kf_check_free
        jz      short dont_init
        push    cx
        push    di
        push    es
        xor     di,di
        mov     ds,pGlobalHeap
        UnSetKernelDS
        mov     cx,[di].gi_free_count
        mov     es,[di].hi_first
        mov     es,es:[di].ga_freenext
CCCC_all_loop:
        call    CCCC
        mov     es,es:[di].ga_freenext
        loop    CCCC_all_loop

; get EMS land if there

        mov     cx,[di].gi_alt_free_count
        jcxz    no_alts
        mov     es,[di].gi_alt_first
        mov     es,es:[di].ga_freenext
CCCC_alt_loop:
        call    CCCC
        mov     es,es:[di].ga_freenext
        loop    CCCC_alt_loop
no_alts:
        pop     es
        pop     di
        pop     cx
dont_init:
        pop     ds
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; check_this_space                                                      ;
;                                                                       ;
; Makes sure the given free space is still filled with DBGFILL_FREE     ;
;                                                                       ;
; Arguments:                                                            ;
;       ES:DI = arena header of space to check                          ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Nov 18, 1986 08:26:52p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   check_this_space,<PUBLIC,NEAR>,<ax,bx,cx,dx,di,ds,es>
cBegin
        SetKernelDS
        cmp     fCheckFree,0
        jnz     short not_while_boot
        test    Kernel_flags,kf_check_free
        jnz     short cts_check_it_out
not_while_boot:
        jmps    cts_ret
cts_check_it_out:
        mov     bx,es:[di].ga_size
        mov     ax,es
        call    get_blotto
        mov     es,ax

        push    bx                      ; Say it ain't so, Joe...
        xor     cx,cx                   ; force the incoming sel/descriptor to
        mov     bx,cx                   ;  a limit of 64k - it might be higher
        inc     cx                      ;  which would cause set_physical_adr
        cCall   set_sel_limit,<es>      ;  to destroy following descriptors.
        pop     bx

        jmp     short cts_doit

cts_next_64k:
        push    es
        cCall   get_physical_address,<es>       ;update selector to next
        inc     dl                              ;  64k block
        cCall   set_physical_address,<es>
        pop     es                              ;reload it with new base

cts_doit:
        mov     cx,1000h                ; 1000h paras = 64k bytes
        cmp     bx,cx
        jae     @f
        mov     cx,bx                   ; less than 64k left
@@:
        sub     bx,cx                   ; bx = # paras left to do
        shl     cx,3                    ; cx = # words to zero this time
        mov     ax,(DBGFILL_FREE or (DBGFILL_FREE shl 8))
        xor     di, di
        repz    scasw           ; check it out
        jz      short so_far_so_good
        kerror  0FFh,<FREE MEMORY OVERWRITE AT >,es,di
        jmps    cts_ret
so_far_so_good:
        or      bx,bx                   ; more to do?
        jnz     short cts_next_64k      ; go do the next block

cts_ret:
cEnd


;-----------------------------------------------------------------------;
; check_free_list                                                       ;
;                                                                       ;
; Checks the global free list for consistency.                          ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Oct 29, 1986 10:13:42a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   check_free_list,<PUBLIC,NEAR>
cBegin nogen
        push    ax
        push    bx
        push    cx
        push    ds
        push    es
        SetKernelDS
        cmp     fCheckFree,0
        jnz     short cfl_outta_here
        test    Kernel_flags,kf_check_free
        jnz     short cfl_check_it_out
cfl_outta_here:
        jmp     all_done
cfl_check_it_out:
        mov     ds,pGlobalHeap
        UnSetKernelDS
        mov     es,[di].hi_first
        mov     cx,[di].gi_free_count
        or      cx,cx
        jnz     short short_relative_jumps
        jmp     all_done
short_relative_jumps:
        mov     ax,es:[di].ga_freenext
        mov     es,ax
check_chain_loop:
        mov     ds,es:[di].ga_freeprev
        mov     es,es:[di].ga_freenext
        cmp     ds:[di].ga_freenext,ax
        jnz     short prev_bad
        mov     bx,ds
        cmp     ax,bx
        jmps    prev_okay
prev_bad:
        mov     bx, ax
        kerror  0FFh,<free_list: prev bad>,ds,bx
        mov     ax, bx
prev_okay:
        cmp     es:[di].ga_freeprev,ax
        jnz     short next_bad
        mov     bx,es
        cmp     ax,bx
        jmps    next_okay

next_bad:
        mov     bx, ax
        kerror  0FFh,<free_list: next bad>,bx,es
next_okay:
        mov     ax,es
        loop    check_chain_loop
        SetKernelDS
        mov     ds,pGlobalHeap
        UnSetKernelDS
        cmp     [di].hi_last,ax
        jz      short all_done
        mov     bx, ax
        kerror  0FFh,<free_list: count bad>,[di].hi_last,bx
all_done:
        pop     es
        pop     ds
        pop     cx
        pop     bx
        pop     ax
        ret
cEnd nogen

;-----------------------------------------------------------------------;
; ValidateFreeSpaces                                                    ;
;                                                                       ;
; The global free list is gone through to make sure that all free       ;
; partitions are filled with DBGFILL_FREE                               ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Nov 18, 1986 09:46:55a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   ValidateFreeSpaces,<PUBLIC,FAR>
cBegin nogen
        push    ds
        SetKernelDS
        test    Kernel_flags,kf_check_free
        jz      short dont_validate
        push    cx
        push    di
        push    es
        xor     di,di
        mov     ds,pGlobalHeap
        UnSetKernelDS
        mov     cx,[di].gi_free_count
        mov     es,[di].hi_first
        mov     es,es:[di].ga_freenext
        jcxz    empty_list
check_all_loop:
        call    check_this_space
        mov     es,es:[di].ga_freenext
        loop    check_all_loop
empty_list:
        pop     es
        pop     di
        pop     cx
dont_validate:
        pop     ds
        ret
cEnd nogen

else

cProc   ValidateFreeSpaces,<PUBLIC,FAR>
cBegin nogen
        ret
cEnd nogen

endif

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2gcompac.asm ===
TITLE	GCOMPACT - Global memory compactor

.sall
.xlist
include kernel.inc
include protect.inc
.list

WM_COMPACTING	= 041h

.286p

DataBegin

externA  __AHINCR
externB  Kernel_Flags
externW  kr2dsc
;externW  WinFlags
externD  gcompact_start
externD  gcompact_timer
externD  pPostMessage

externB  DpmiMemory
externW  DpmiBlockCount
fSwitchStacks	DB  0
fUpDown		DB  0

DataEnd

sBegin	CODE
assumes CS,CODE

;externW  gdtdsc

externNP glrudel
externNP gmarkfree
externNP gcheckfree
externNP gdel_free
externNP gnotify
externNP Enter_gmove_stack
externNP Leave_gmove_stack

if KDEBUG
externFP ValidateFreeSpaces
endif
externFP SetSelectorBase

externNP get_arena_pointer
externNP get_physical_address
externNP set_physical_address
externNP set_sel_limit
externNP get_rover_2
externNP cmp_sel_address
externNP get_temp_sel
externNP alloc_data_sel_above
externNP alloc_data_sel_below
externNP free_sel
externNP PreallocSel
externNP AssociateSelector
externNP mark_sel_NP
if ALIASES
externNP check_for_alias
endif
externNP DPMIProc


;-----------------------------------------------------------------------;
; gcompact								;
; 									;
; Compacts the global heap.						;
;									;
; Arguments:								;
;	DX = minimum #contiguous bytes needed				;
;	DS:DI = address of global heap information			;
; 									;
; Returns:								;
;	AX = size of largest contiguous free block			;
;	ES:DI = arena header of largest contiguous free block		;
;	DX = minimum #contiguous bytes needed				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	SI								;
; 									;
; Registers Destroyed:							;
;	CX								;
; 									;
; Calls:								;
;	gcmpheap							;
;	gcheckfree							;
;	gdiscard							; 									;
; History:								;
; 									;
;  Thu Sep 25, 1986 05:34:32p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	gcompact,<PUBLIC,NEAR>
cBegin nogen

	push	si
	mov	ax,40h
	mov	es,ax
	mov	ax,es:[6Ch]		; get the BIOS ticker count
	SetKernelDS	es
	sub	gcompact_timer.lo,ax
gcompactl:
if KDEBUG
	call	ValidateFreeSpaces
endif
	push	dx			; Save requested size
	cmp	[di].gi_reserve,di	; Is there a reserve swap area?
	je	gcompact1		; No, then dont compact lower heap
	mov	es,[di].hi_first	; Yes, compact lower heap
	mov	bx,ga_next
	call	gcmpheap
gcompact1:
	test	[di].gi_cmpflags,BOOT_COMPACT
	jz	gcompact1a
	pop	dx
	jmps	gcompactx
gcompact1a:
	mov	es,[di].hi_last 	; Compact upper heap
	mov	bx,ga_prev
	call	gcmpheap
	pop	dx			; Get requested size
	mov	es,ax			; ES points to largest free block
	or	ax,ax			; Did we find a free block?
	jz	gcompact2		; No, try discarding
	call	gcheckfree		; Yes, see if block big enough
	jae	gcompactx		; Yes, all done
gcompact2:				; Discarding allowed?
	test	[di].gi_cmpflags,GA_NODISCARD+GA_NOCOMPACT
	jnz	gcompactx		; No, return
	cmp	[di].hi_freeze,di	; Heap frozen?
	jne	gcompactx		; Yes, return

	push	es
	call	gdiscard		; No, try discarding
	pop	cx			; Saved ES may be bogus if gdiscard
					; discarded anything...
	jnz	gcompactl		; Compact again if anything discarded
	mov	es, cx			; Nothing discarded so ES OK.
gcompactx:
	push	ax
	push	dx
	push	es
	mov	ax,40h
	mov	es,ax
	mov	ax,es:[6Ch]
	mov	si,ax
	SetKernelDS	es
	cmp	pPostMessage.sel,0	; is there a USER around yet?
	jz	tock
	add	gcompact_timer.lo,ax
	sub	ax,gcompact_start.lo
	cmp	ax,546			; 30 secs X 18.2 tics/second
	jb	tock
	cmp	ax,1092 		; 60 secs
	ja	tick
	mov	cx,gcompact_timer.lo	; poor resolution of timer!
	jcxz	tick
	xchg	ax,cx
	xor	dx,dx
	xchg	ah,al			; shl 8 DX:AX
	xchg	dl,al
	div	cx
	cmp	ax,32			; < 12.5% ?
	jb	tick
	mov	ah,al
	mov	bx,-1			; broadcast
	mov	cx,WM_COMPACTING
	xor	dx,dx
	push	es
	cCall	pPostMessage,<bx, cx, ax, dx, dx>
	pop	es
tick:	mov	gcompact_start.lo,si
	mov	gcompact_timer.lo,0
tock:	pop	es
	pop	dx
	pop	ax
	pop	si			; Restore SI
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gcmpheap								;
; 									;
; 									;
; Arguments:								;
;	BX = ga_prev or ga_next						;
;	DX = minimum #contiguous bytes needed				;
;	DS:DI = address of global heap information			;
;	ES:DI = first arena to start with				;
; 									;
; Returns:								;
;	AX = largest free block						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	AX,CX								;
; 									;
; Calls:								;
;	gslide								;
;	gbestfit							;
; 									;
; History:								;
; 									;
;  Thu Sep 25, 1986 05:38:16p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	gcmpheap,<PUBLIC,NEAR>
cBegin nogen
	mov	cx,[di].hi_count
	xor	ax,ax			; Nothing found yet
	push	ax			; Save largest free block so far
gchloop:
	cmp	es:[di].ga_owner,di
	je	gchfreefnd
gchnext:
	mov	es,es:[bx]
	loop	gchloop
	pop	ax			; Return largest free block in AX
	ret

gchfreefnd:
	test	[di].gi_cmpflags,GA_NOCOMPACT
	jnz	gchmaxfree		; No, just compute max free.
	cmp	[di].hi_freeze,di	; Heap frozen?
	jne	gchmaxfree		; Yes, just compute max free.
	push	es
	cmp	bl,ga_prev		; Compacting upper heap?
	jnz	no_hack
	test	[di].gi_cmpflags,GA_DISCCODE
	jz	no_hack
	cmp	dx,es:[ga_size]
	ja	no_hack
	mov	es,es:[di].ga_next
	test	es:[di].ga_flags,GA_DISCCODE
	jnz	hack
	cmp	es:[di].ga_owner,GA_SENTINAL
	jz	hack
	cmp	es:[di].ga_owner,GA_NOT_THERE
	jnz	no_hack

; Check to see if anything is locked above us!

gch_hack_check:
	test	es:[di].ga_flags,GA_DISCCODE
	jnz	hat_check
	mov	ax,es:[di].ga_owner
	or	ax,ax
	jz	hat_check
	cmp	ax,GA_NOT_THERE
	jz	hat_check
	cmp	ax,GA_SENTINAL
	jz	hack
	jmp	short no_hack
hat_check:
	mov	es,es:[di].ga_next
	jmp	gch_hack_check

hack:	pop	es
	pop	ax
	mov	ax,es
	ret

no_hack:
	pop	es
	call	PreallocSel
	jz	gchmaxfree
	push	dx
	call	gslide
	pop	dx
	jnz	gchfreefnd
best_it:
	push	dx
	call	gbestfit
	pop	dx
	jnz	best_it			; Useless to gslide anymore.
gchmaxfree:
	cmp	bl,ga_prev		; Compacting upper heap?
	jne	gchnext			; No, dont compute largest free block
	pop	si			; Recover largest free block so far
	mov	ax,es			; AX = current free block
	cmp	si,ax			; Same as current?
	je	gchmf2			; Yes, no change then
	cmp	es:[di].ga_owner,di	; No, is current free?
	jne	gchmf2			; No, ignore it then
	push	es
	cmp	ds:[di].gi_reserve,di	; Is there a code reserve area?
	je	gchmf0			; No, continue
	test	ds:[di].gi_cmpflags,GA_DISCCODE ; If allocating disc
	jz	gchmf0			;  code then only use free block if
	mov	es,es:[di].ga_next
	test	es:[di].ga_flags,GA_DISCCODE
	jnz	gchmf0				; butted up against disc code
	cmp	es:[di].ga_owner,GA_SENTINAL	; or sentinal.
	pop	es
	jnz	gchmf2
	push	es
gchmf0:
	pop	es
	or	si,si			; First time?
	jz	gchmf1			; Yes, special case
	push	es
	mov	es,si
	mov	ax,es:[di].ga_size	; No, get size of largest free block
	pop	es			; Compare with size of this free block
	cmp	es:[di].ga_size,ax	; Is it bigger?
	jb	gchmf2			; No, do nothing
gchmf1: mov	si,es			; Yes, remember biggest free block
gchmf2: push	si			; Save largest free block so far
	jmp	gchnext			; Go process next block
cEnd nogen


;-----------------------------------------------------------------------;
; gslide								;
; 									;
; Sees if next/previous block can slide into the passed free block.	;
; 									;
; Arguments:								;
;	ES:DI = free block						;
;	DS:DI = address of global heap information			;
;	CX = #arena entries left to examine				;
;	BX = ga_next or ga_prev						;
; 									;
; Returns:								;
;	ZF = 0 if block found and moved into passed free block		;
;		ES:DI points to new free block				;
;		SI:DI points to new free block				;
;									;
;	ZF = 1 if no block found					;
;		ES:DI points to original free block			;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	AX,DX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Sep 25, 1986 05:58:25p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gslide,<PUBLIC,NEAR>
cBegin nogen
	push	es
	mov	es,es:[bx]
	mov	ax,es
	mov	dx,es:[di].ga_size
	call	gmoveable
	pop	es
	jz	gslide_no_move
	cmp	bx,ga_next
	jnz	sliding_up
	push	es:[bx]			; gslide will invalidate this block
	jmps	slide
sliding_up:
	push	es			; gslide will invalidate this block
slide:	call	gslidecommon		; C - calling convention
	call	free_sel		; free the pushed selector
gslide_no_move:
	ret
cEnd nogen

					; Enter here from gbestfit
cProc	gslidecommon,<PUBLIC,NEAR>
cBegin nogen
					; moving non-contiguous blocks
	push	es:[di].ga_freeprev
	push	es:[di].ga_freenext

	mov	si,ax			; Source is busy block
	inc	dx			; DX = busy.ga_size + 1
	cmp	bl,ga_next
	je	gslidedown

; Here to slide moveable block up to high end of free block.
;
; Free and busy block adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   busy    |		    |	free  ? |
;		|-----------|		    |		|
;		|   free    |	     b ->   |-----------|
;		|	    |		    | ? busy  ? |
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ?		|
;
;
;	a = busy
;	b = free.ga_next - busy.ga_size - 1
;	c = free.ga_next
;	destination = b
;
; Free and busy block NOT adjacent
;     0000:0	|	    |		    |		|
;		|-----------|		    |-----------|
;		|   busy    |		    |	free	|
;		|-----------|		    |-----------|
;		|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    |	free  ? |
;		|	    |	     b ->   |-----------|
;		|	    |		    | ? busy  ? |
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ?		|
;
;
;	a = free
;	b = free.ga_next - busy.ga_size - 1
;	c = free.ga_next
;	destination = b
;
gslideup:
	mov	ax,es:[di].ga_next
	push	ax			; Save c
	cCall	alloc_data_sel_below, <ax, dx>	; Bogus arena header
	push	ax			; Save b
	cmp	es:[bx],si		; Are blocks adjacent?
	je	gslideup1
	push	es			; No, a = free
	jmps	gslideup2
gslideup1:
	push	si			; Yes, a = busy
gslideup2:

	mov	es,ax			; Destination is b
	xor	ax,ax			; a.ga_prev will remain valid
	jmps	gslidemove

; Here to slide moveable block down to low end of free block.
;
; Free and busy block adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    | ? busy  ? |
;		|	    |	     b ->   |-----------|
;		|-----------|		    | ? free  ? |
;		|   busy    |		    |		|
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ?		|
;
;	a = free
;	b = free + busy.ga_size + 1
;	c = busy.ga_next
;	destination = free
;
; Free and busy block NOT adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    | ? busy  ? |
;		|	    |	     b ->   |-----------|
;		|	    |		    | ? free  ? |
;		|-----------|	     c ->   |-----------|
;		|	    |		    | ?		|
;		|-----------|		    |-----------|
;		|   busy    |		    |	free	|
;		|-----------|		    |-----------|
;     FFFF:0	|	    |		    |		|
;
;
;	a = free
;	b = free + busy.ga_size + 1
;	c = free.ga_next
;	destination = free
;

gslidedown:
	cmp	es:[bx],si		; Are blocks adjacent?
	je	gslidedn1
	push	es:[di].ga_next		; No, c = free.ga_next
	jmps	gslidedn2
gslidedn1:

	push	es
	mov	es,si
	mov	ax,es:[di].ga_next
	pop	es
	push	ax
gslidedn2:
	cCall	alloc_data_sel_above, <es, dx>
	push	ax			; Save b
	push	es			; Save a
	mov	ax,es:[di].ga_prev	; a.ga_prev must be restored after move
gslidemove:

	push	ax
	push	si			; Source arena

	mov	ax, es
	mov	es, si			; Save source arena contents

	push	word ptr es:[di]
	push	word ptr es:[di+2]
	push	word ptr es:[di+4]
	push	word ptr es:[di+6]
	push	word ptr es:[di+8]
	push	word ptr es:[di+10]
	push	word ptr es:[di+12]
	push	word ptr es:[di+14]
	mov	es, ax

	call	gmove

	pop	word ptr es:[di+14]	; "Copy" source arena to destination
	pop	word ptr es:[di+12]
	pop	word ptr es:[di+10]
	pop	word ptr es:[di+8]
	pop	word ptr es:[di+6]
	pop	word ptr es:[di+4]
	pop	word ptr es:[di+2]
	pop	word ptr es:[di]

	pop	si
	pop	ax

; update lruentries

	mov	dx,es:[di].ga_lruprev
	or	dx,dx
	jz	no_links
	cmp	[di].gi_lruchain,si
	jnz	didnt_slide_head
	mov	[di].gi_lruchain,es
didnt_slide_head:
	cmp	dx,si			; Did we move the only entry?
	jnz	many_entries
	mov	es:[di].ga_lrunext,es
	mov	es:[di].ga_lruprev,es
	jmps	no_links
many_entries:
	push	ds
	mov	ds,dx
	mov	ds:[di].ga_lrunext,es
	mov	ds,es:[di].ga_lrunext
	mov	ds:[di].ga_lruprev,es
	pop	ds
no_links:

	mov	si,es			; Save new busy block location
	pop	es			; ES = a
	or	ax,ax			; Does a.prev need to be restored?
	jz	gslide1			; No, continue
	mov	es:[di].ga_prev,ax	; Yes, do it
gslide1:

; update arena prev and next pointers

	pop	ax
	mov	es:[di].ga_next,ax	; a.ga_next = b
	mov	dx,es
	mov	es,ax
	mov	es:[di].ga_prev,dx	; b.ga_prev = a
	pop	ax
	mov	es:[di].ga_next,ax	; b.ga_next = c
	mov	dx,es
	mov	es,ax
	mov	es:[di].ga_prev,dx	; c.ga_prev = b
	mov	es,si			; ES = new busy block
	mov	si,es:[di].ga_handle	; SI = handle
	or	si,si
	jz	gslide2
	cCall	AssociateSelector,<si,es>
gslide2:
	mov	es,es:[bx]		; Move to new free block
	push	bx
	push	cx
	cCall	get_physical_address,<es:[di].ga_next>
	mov	bx,ax
	mov	cx,dx
	cCall	get_physical_address,<es>
	sub	bx,ax
	sbb	cx,dx
	REPT	4
	shr	cx,1
	rcr	bx,1
	ENDM
	mov	ax,bx
	pop	cx
	pop	bx
	mov	si,es
	dec	ax
	mov	es:[di].ga_size,ax
	mov	es:[di].ga_flags,0

; update the global free list

	pop	ax			; ga_freenext
	pop	dx			; ga_freeprev
	mov	es:[di].ga_freeprev,dx
	mov	es:[di].ga_freenext,ax
	mov	es,dx
	mov	es:[di].ga_freenext,si
	mov	es,ax
	mov	es:[di].ga_freeprev,si
	mov	es,si
if KDEBUG
	test	si, 1			; make SI odd for gmarkfree
	jnz	ok
	INT3_WARN
ok:
endif
	call	gmarkfree		; Coalesce new free block
	mov	si,es
	or	ax,ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gmove									;
;									;
; Moves a moveable block into the top part of a free block.  		;
;									;
; Arguments:								;
;	DS:DI = master object						;
;	ES:0  = arena of destination block				;
;	SI:0  = arena of source block					;
;									;
; Returns:								;
;	DS:DI = master object	(it may have moved)			;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	AX,BX,CX,DX,DI,SI,ES						;
;									;
; Registers Destroyed:							;
;	none								;
;									;
; Calls:								;
;	gnotify								;
;									;
; History:								;
;									;
;  Thu Sep 25, 1986 03:31:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	gmove,<PUBLIC,NEAR>
cBegin nogen

	push	es
	pusha

	cCall	get_physical_address,<es>	; Destination arena address
	add	ax, 10h				; Destination is one paragraph
	adc	dx, 0				; past the arena header

	push	ax				; Save to update source
	push	dx				; selectors after the move

	push	ax				; Scribbled by SetSelectorBase
	push	dx
	SetKernelDS es
	cCall	SetSelectorBase,<kr2dsc,dx,ax>	; NOTE kr2dsc has SEG_RING set

				; While we have destination
				; address, see if move will
				; be up or down
	pop	cx
	pop	bx				; CX:BX has address of dest
	cCall	get_physical_address,<si>	; Source address
	cmp	dx, cx				; cmp src, dest
	jne	@F
	cmp	ax, bx
@@:
	mov	cx, 0			; move to preserve CARRY
	adc	ch, 0
	push	cx			; Save fUpDown, CL = 0

	mov	es, si			; ES:DI = arena header of source
	UnSetKernelDS es
	push	es:[di].ga_size		; Save #paragraphs
	mov	bx, es:[di].ga_handle	; BX = handle of source
	Handle_To_Sel	bl

if KDEBUG
	cCall	get_arena_pointer,<bx>
	cmp	ax, si
	je	@F
	INT3_ANCIENT
@@:
endif

	mov	si, bx			; SI = client data selector of source
	mov	cx, bx			; CX = client data selector of dest

	mov	ax, GN_MOVE
	call	gnotify			; Call global notify procedure
	pop	dx			; DX = #paragraphs to move
	pop	cx			; CH has fUpDown, CL = 0

	pop	bx			; Destination address in registers
	pop	di			; in case we switch stacks

	SetKernelDS es
	mov	fUpDown, ch
	mov	ax,ss			; Are we about to move the stack?
	cmp	ax,si
	jne	stack_no_move
	mov	cx, ax			; Selector does not change!
	call	Enter_gmove_stack	; switch to temporary stack
stack_no_move:
	mov	[fSwitchStacks],cl	; Remember if we switched

; Save DS value AFTER call to gnotify, as the master object might be the
; block we are moving and thus changed by the global heap notify proc.
; IRRELEVANT SINCE IT IS A SELECTOR!!!

	push	ds
	push	di			; Re-save destination address -
	push	bx			; we may be on different stack
	push	si			; Save source selector
	mov	di, kr2dsc		; DI = Destination selector array

	mov	bx, dx			; # paragraphs to copy
	xor	cx, cx
					; Calculate length
rept 4
	shl	bx, 1
	rcl	cx, 1
endm

	push	cx
	cCall	set_sel_limit,<di>	; Set destination selector array
	pop	cx

	sub	bx, 1			; Now turn into limit
	sbb	cl, 0			; CX has number of selectors - 1

;
; At this point, DX = # paragraphs to be moved, SI = source selector,
; DI = dest selector
;
	or	dx,dx			; just in case...
	jnz	@f
	jmps	all_moved
@@:
	mov	bx,dx			; bx = total # paras to move

	cld				; assume moving down
	mov	dx,__AHINCR		; dx = selector increment

	cmp	fUpDown,0		; Moving up or down?  Need to
	jz	start_move		;   adjust start descriptors if up

	assumes	es, nothing

	std

	; Moving data up.  Fudge the address so we copy
	; from the end of each segment.

	push	dx
	mov	ax, dx			; Selector increment
	mul	cx			; * (number of sels - 1)
	add	si, ax			; Get source and destination selecotors
	add	di, ax			; for last piece of copy
	pop	dx
	neg	dx			; Going backwards through the array

	mov	ds, si			; Set source and destination segments
	mov	es, di

	mov	cx, bx			; See if partial copy first
	and	cx, 0FFFh		; 64k-1 paragraphs
	jz	move_blk		; exact multiple, go for it
					; Not exact, set up first copy by hand
	sub	bx, cx			; This many paragraphs less
	shl	cx, 4			; byte count
	mov	si, cx
	shr	cx, 1			; word count
	jmps	move_up

start_move:
	mov	ds,si
	mov	es,di

move_blk:
	mov	cx,1000h		; 1000h paras = 64k bytes
	cmp	bx,cx
	jae	@f
	mov	cx,bx			; less than 64k left
@@:
	sub	bx,cx			; bx = # paras left to do
	shl	cx,3			; cx = # words to move this time

	xor	si,si			; assume going down
	cmp	dl,0			; really moving down?
	jg	@F			; yes, jmp, (yes, SIGNED!)
move_up:
	dec	si			; up: point to last word in segment
	dec	si
@@:
	mov	di,si
	rep movsw

	or	bx,bx			; more to do?
	jz	all_moved

		; Adjust source/dest selectors up/down by 64k

	mov	si,ds
	add	si,dx

	mov	di,es
	add	di,dx

	jmps	start_move		; go do the next block

all_moved:
	pop	si			; Source selector array

	pop	dx			; New address for source selectors
	pop	ax
if ALIASES
	cCall	check_for_alias,<si,dx,ax>
endif
	cCall	set_physical_address,<si>	; Update source selector array

	pop	ds			; Restore DS (it might be different)

	SetKernelDS es
	cmp	[fSwitchStacks], 0	; Switch to new stack if any
	je	move_exit
	call	Leave_gmove_stack
move_exit:

	popa
	pop	es
	UnSetKernelDS es

	cld			; Protect people like MarkCl from themselves
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gbestfit								;
; 									;
; Searches for the largest moveable block that will fit in the passed	;
; free block.								;
;									;
; Arguments:								;
;	ES:DI = free block						;
;	DS:DI = address of global heap information			;
;	CX = #arena entries left to examine				;
;	BX = ga_next or ga_prev						;
; 									;
; Returns:								;
;	ZF = 1 if block found & moved into free block w/ no extra room.	;
;		ES:DI = busy block before/after new busy block.		;
;									;
;	ZF = 0 if ES:DI points to a free block, either the		;
;		original one or what is left over after moving a block	;
;		into it.						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	DX,SI								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Sep 25, 1986 05:52:12p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gbestfit,<PUBLIC,NEAR>
cBegin nogen
	push	es
	push	cx
	xor	si,si			; Have not found anything yet
	xor	ax, ax			; largest block so far
	mov	dx,es:[di].ga_size	; Compute max size to look for
gbfloop:
	cmp	es:[di].ga_owner,di	; Is this block busy?
	je	gbfnext			; No, continue
	cmp	es:[di].ga_size,dx	; Yes, is block bigger than max size?
	ja	gbfnext			; Yes, continue
	call	gmoveable		; Yes, is it moveable
	jz	gbfnext			; No, continue
	cmp	es:[di].ga_size,ax	; Is it bigger than the largest so far?
	jbe	gbfnext			; No, continue
gbf1st:
	mov	si,es			; Yes, remember biggest block
	mov	ax,es:[di].ga_size	; ...and size
gbfnext:
	mov	es,es:[bx]		; Skip past this block
	loop	gbfloop
	pop	cx			; All done looking
	pop	es
	or	si,si			; Did we find a block?
	jz	gbestfit1		; No, return with Z flag
	call	gmovebusy		; Yes, move it into free block
gbestfit1:
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gmovebusy								;
; 									;
; Subroutine to move a busy block to a free block of the same size,	;
; preserving the appropriate arena header fields, freeing the old	;
; busy block and updating the handle table entry to point to the	;
; new location of the block.						;
; 									;
; Arguments:								;
;	BX = ga_prev or ga_next						;
;	SI = old busy block location					;
;	ES:DI = new busy block location					;
;	DS:DI = address of global heap information			;
; 									;
; Returns:								;
;	ES:DI = points to new busy block arena header			;
; 	SI:DI = points to free block where block used to be		;
;		(may be coalesced)					;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	BX,CX,DX							;
; 									;
; Registers Destroyed:							;
;	AX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Jun 22, 1987 11:39:56p  -by-  David N. Weise   [davidw]		;
; Made it jump off to gslidecommon when appropriate.			;
; 									;
;  Mon Oct 27, 1986 10:17:16p  -by-  David N. Weise   [davidw]		;
; Made the lru list be linked arenas, so we must keep the list correct	;
; here.									;
; 									;
;  Thu Sep 25, 1986 05:49:25p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gmovebusy,<PUBLIC,NEAR>
cBegin nogen
	push	cx
	push	dx
	mov	ax,es
	mov	cx,es:[di].ga_size	; CX = size of destination
	cmp	es:[di].ga_owner,di	; Is destination busy?
	mov	es,si
	mov	dx,es:[di].ga_size	; DX = size of source
	jne	gmbexactfit		; Yes, then dont create extra block
	cmp	cx,dx			; No, are source and destination same size?
	je	gmbexactfit		; Yes, then dont create extra block

	mov	es,ax			; ES = destination
	cmp	es:[di].ga_next,si	; Are the two blocks adjacent?
					;  If so we want to do a gslide.
	mov	ax,si			; AX = source
	jnz	not_adjacent
	cmp	bx,ga_next
	jnz	gmb_sliding_up
	push	es:[bx]			; gslide will invalidate this block
	jmps	gmb_slide
gmb_sliding_up:
	push	es			; gslide will invalidate this block
gmb_slide:
	call	gslidecommon		; C - calling convention
	call	free_sel		; free the pushed selector
	jmp	gmbexit
not_adjacent:
	push	si			; Save busy block address
	call	gslidecommon		; Call common code to do the move
	inc	[di].hi_count		; Just created a new arena entry
	mov	ax,es			; Save new free block address
	pop	es			; Get old busy block address
	xor	si,si
	call	gmarkfree		; Mark as free and coalesce
	mov	si,es
	mov	es,ax			; Restore new free block address
	or	ax,ax			; Return with Z flag clear.
	jmps	gmbexit

gmbexactfit:
	mov	ch,es:[di].ga_count
	mov	cl,es:[di].ga_flags
	push	es:[di].ga_owner
	push	es:[di].ga_lruprev
	push	es:[di].ga_lrunext
	mov	es,ax
	jne	it_wasnt_free
	call	gdel_free
it_wasnt_free:
	pop	es:[di].ga_lrunext	; Copy client words to new header
	pop	es:[di].ga_lruprev
	pop	es:[di].ga_owner
	mov	es:[di].ga_flags,cl
	mov	es:[di].ga_count,ch
	cmp	es:[di].ga_lruprev,di
	jz	no_link
	cmp	[di].gi_lruchain,si
	jnz	didnt_move_head
	mov	[di].gi_lruchain,es
didnt_move_head:
	push	ds
	mov	ds,es:[di].ga_lruprev
	mov	[di].ga_lrunext,ax	; Update the lru list
	mov	ds,es:[di].ga_lrunext
	mov	[di].ga_lruprev,ax	; Update the lru list
	pop	ds
no_link:
	mov	es, ax				; ES is destination of copy

	call	gmove			; Move the client data
	mov	es, si
	xor	si,si
	call	gmarkfree		; Free old block
	mov	cx,es
	mov	es,ax
	or	si,si
	jz	gmb1
	mov	es:[di].ga_handle,si	; Set back link to handle in new block
	cCall	AssociateSelector,<si,es> ; and associate with new arena
	xor	dx,dx			; Set Z flag
gmb1:
	mov	si,cx
gmbexit:
	pop	dx
	pop	cx
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gmoveable								;
; 									;
; Tests if an ojbect is moveable.  Non moveable blocks are:		;
; Fixed blocks, moveable blocks that are locked, moveable blocks	;
; going up, discardable code going down.				;
; 									;
; Arguments:								;
;	ES:DI = arena header of object					;
;	DS:DI = address of global heap information			;
;	BX = ga_next or ga_prev						;
; 									;
; Returns:								;
;	ZF = 0 if object moveable					;
;	ZF = 1 if object not moveable					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Wed Oct 15, 1986 05:04:39p  -by-  David N. Weise   [davidw]		;
; Moved he_count to ga_count.						;
; 									;
;  Thu Sep 25, 1986 05:42:17p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gmoveable,<PUBLIC,NEAR>
cBegin nogen
	test	es:[di].ga_handle,GA_FIXED	; If no handle then fixed
	jnz	gmfixed

	cmp	 es:[di].ga_count,bh		 ; If locked then fixed
	jne	 gmfixed

	test	[di].gi_cmpflags,BOOT_COMPACT	; If fb_init_EMS then all down
	jnz	gmokay
	test	es:[di].ga_flags,GA_DISCCODE	; If discardable code
	jz	gmnotcode
	cmp	bl,ga_next			; Discardable code can only
	ret					; move up in memory
gmnotcode:
	cmp	[di].gi_reserve,di		; If no reserved code area?
	je	gmokay				; Then anything can move up
	cmp	bl,ga_prev			; Otherwise can only move down
	ret					; in memory
gmfixed:
	or	bh,bh				; Return with ZF = 1 if
	ret					; not moveable
gmokay:
	or	bl,bl
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gdiscard								;
; 									;
; Subroutine to walk LRU chain, discarding objects until the #paras	;
; discarded, plus the biggest free block is greater than the #paras	;
; we are looking for.							;
; 									;
; Arguments:								;
;	AX = size of largest free block	so far				;
;	DX = minimum #paras needed					;
;	DS:DI = address of global heap information			;
; 									;
; Returns:								;
;	ZF = 0 if one or more objects discarded.			;
;	ZF = 1 if no objects discarded.					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	AX,DX,DI							;
; 									;
; Registers Destroyed:							;
;	BX,CX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
;  Mon Oct 27, 1986 09:34:45p  -by-  David N. Weise   [davidw]		;
; The glru list was reworked to link the arenas, not using the handle	;
; table as a middle man.  Because of this change glruprev was moved	;
; inline and the code shortened up again.				;
; 									;
;  Wed Oct 15, 1986 05:04:39p  -by-  David N. Weise   [davidw]		;
; Moved he_count to ga_count.						;
; 									;
;  Thu Sep 25, 1986 05:45:31p  -by-  David N. Weise   [davidw]		;
; Shortened it up a bit and added this nifty comment block.		;
;-----------------------------------------------------------------------;

cProc	gdiscard,<PUBLIC,NEAR>
cBegin nogen
	push	ax
	push	dx

	mov	[di].hi_ncompact,0	; Clear compaction flag
	sub	dx,ax			; How much to discard before
	mov	[di].hi_distotal,dx	; compacting again.

	xor	bx,bx			; BX = amount of DISCCODE below fence
	test	[di].gi_cmpflags,GA_DISCCODE
	jnz	fence_not_in_effect0

	mov	cx,[di].gi_lrucount
	jcxz	fence_not_in_effect0	; All done if LRU chain empty
	mov	es,[di].gi_lruchain	; ES -> most recently used (ga_lruprev
	push	dx
gdloop0:				; is the least recently used)
	mov	es,es:[di].ga_lruprev	; Move to next block in LRU chain
	test	es:[di].ga_flags,GA_DISCCODE	; Discardable code?
	jz	gdloop0a		; No, ignore
	mov	ax,es
	cCall	get_physical_address,<ax>
	cmp	word ptr [di].gi_disfence_hi,dx ; Yes, is this code fenced off?
	ja	gdloop0b
	jb	gdloop0a		; No, ignore
	cmp	word ptr [di].gi_disfence_lo,ax ; Yes, is this code fenced off?
	jbe	gdloop0a		; No, ignore
gdloop0b:
	add	bx,es:[di].ga_size	; Yes, accumulate size of discardable
gdloop0a:				; code below the fence
	loop	gdloop0
	pop	dx

fence_not_in_effect0:
	mov	es,[di].gi_lruchain
	cmp	[di].gi_lrucount, 0
	je	gdexit
	push	es:[di].ga_lruprev
	push	[di].gi_lrucount
gdloop:
	pop	cx
	pop	ax
	jcxz	gdexit			; No more see if we discarded anything
	mov	es, ax			; ES on stack may be invalid if count 0
	dec	cx
	push	es:[di].ga_lruprev	; Save next handle from LRU chain
	push	cx
	cmp	es:[di].ga_count,0	; Is this handle locked?
	jne	gdloop			; Yes, ignore it then
	test	[di].gi_cmpflags,GA_DISCCODE
	jnz	fence_not_in_effect
	test	es:[di].ga_flags,GA_DISCCODE
	jz	fence_not_in_effect
	or	bx,bx			; Discardable code below fence?
	jz	gdloop			; No, cant discard then
	cmp	bx,es:[di].ga_size	; Yes, more than size of this block?
	jb	gdloop			; No, cant discard then
	sub	bx,es:[di].ga_size	; Yes, reduce size of code below fence
fence_not_in_effect:
	push	bx
	call	DiscardCodeSegment
	pop	bx
	jnz	discarded_something
	test	[di].hi_ncompact,10h	; did a GlobalNotify proc free enough?
	jz	gdloop
	jmps	enough_discarded
discarded_something:
	test	[di].hi_ncompact,10h	; did a GlobalNotify proc free enough?
	jnz	enough_discarded
	or	[di].hi_ncompact,1	; Remember we discarded something
	sub	[di].hi_distotal,ax	; Have we discarded enough yet?
	ja	gdloop			; No, look at next handle
enough_discarded:
	pop	cx			; Flush enumeration counter
	pop	cx			; and saved ES
gdexit:
	cmp	[di].hi_ncompact,0	; Return with Z flag set or clear
	pop	dx
	pop	ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; DiscardCodeSegment							;
; 									;
; Discards the given segment.  Calls gnotify to fix stacks, entry	;
; points, thunks, and prologs.  Then glrudel removes it from the lru	;
; list and gmarkfree finally gets rid of it.				;
;									;
; Arguments:								;
;	DS:DI => BurgerMaster						;
;	ES    =  Address of segment to discard				;
; 									;
; Returns:								;
;	AX = size discarded						;
;	ZF = 0 ok							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
; 	BX,CX,DX							;
;									;
; Calls:								;
;	gnotify								;
;	glrudel								;
;	gmarkfree							;
;									;
; History:								;
; 									;
;  Fri Jun 12, 1987            -by-  Bob Matthews     [bobm]		;
; Made FAR.								;
;									;
;  Sun Apr 19, 1987 12:05:40p  -by-  David N. Weise   [davidw]          ;
; Moved it here from InitTask, so that FirstTime could use it.		;
;-----------------------------------------------------------------------;

cProc	DiscardCodeSegment,<PUBLIC,NEAR>
cBegin nogen
	push	si
	mov	bx,es:[di].ga_handle	; BX = handle
	mov	al,GN_DISCARD		; AX = GN_DISCARD
	push	es
	call	gnotify
	pop	es
	jz	cant_discard		; Skip this handle if not discardable
	call	glrudel			; Delete handle from LRU chain
	push	es:[di].ga_owner	; Save owner field
	mov	ax,es:[di].ga_size	; Save size
	xor	si,si
	call	gmarkfree		; Free the block associated with this handle
	mov	bx,si
	pop	cx			; Owner
	cCall	mark_sel_NP,<bx,cx>
cant_discard:
	pop	si
	ret
cEnd nogen


;-----------------------------------------------------------------------
; ShrinkHeap
;
;   This routine finds free partitions and returns them to DPMI
;
; Input:
;       ds:di=>BurgerMaster
;
; Output:
;       none
;

        public ShrinkHeap
ShrinkHeap proc near
        
        push    si
        push    cx
        push    bx
        push    ax
        push    ds
        push    es
        push    bp
        mov     bp,sp
        sub     sp,8
SelFirst equ word ptr [bp - 2]
SelLast equ word ptr [bp - 4]
SelFree equ word ptr [bp - 6]
SelBurgerMaster equ word ptr [bp - 8]
        mov     SelBurgerMaster,ds
        
        SetKernelDS
        ;
        ; Iterate over each of the DPMI blocks
        ;  there should be fewer dpmi blocks than blocks on the free list
        ;
        mov     cx,DpmiBlockCount
        mov     si,offset DpmiMemory
    
        ;
        ; If this block doesn't exist, go on to the next one
        ;
sh30:   mov     ax,[si].DBSel
        cmp     ax,di
        je      sh60
        
        ;
        ; Found an in use dpmi block
        ;
        dec     cx
        
        ;
        ; Check to see if the next block is free
        ;
        mov     SelFirst,ax
        mov     es,ax
        mov     bx,es:[di].ga_next
        mov     es,bx
        mov     SelFree,bx
        cmp     es:[di].ga_owner,di
        jne     sh60
    
        ;
        ; Check to see if it is followed by a not there block
        ; (Note:  we should check for -1 in the future so we can
        ;  free the last block as well)
        ;
        mov     bx,es:[di].ga_next
        mov     SelLast,bx
        mov     es,bx
        cmp     es:[di].ga_owner,GA_NOT_THERE
        jne     sh60

        ;
        ; Found one, so remove the free block
        ;
        mov     es,SelFree
        mov     ds,SelBurgerMaster
        UnsetKernelDS
        call    gdel_free
    
        ;
        ; Fix up the global information
        ;
        sub     [di].hi_count,3

        ;
        ; Unlink from the heap
        ;
        mov     es,SelFirst
        mov     es,es:[di].ga_prev
        mov     ds,SelLast
        mov     ds,ds:[di].ga_next
        mov     ds:[di].ga_prev,es
        mov     es:[di].ga_next,ds
    
        ;
        ; Free all of the selectors
        ;
        cCall   free_sel,<SelFirst>
        cCall   free_sel,<SelLast>
        cCall   free_sel,<SelFree>
    
        ;
        ; Give the block back to Dpmi
        ;
        push    si
        push    di
        SetKernelDS
        mov     di,[si].DBHandleLow
        mov     si,[si].DBHandleHigh
        DPMICALL 502h
        pop     di
        pop     si
    
        ;
        ; Decrease the number of dpmi blocks
        ;
        dec     DpmiBlockCount
        
        ;
        ; Forget the block
        ;
        mov     [si].DBSel,di
                
        ;
        ; move on to the next iteration
        ;
sh60:   add     si,size DpmiBlock
        or      cx,cx
        jz      sh70
        
        jmp     sh30
        
sh70:   mov     sp,bp
        pop     bp
        pop     es
        pop     ds
        pop     ax
        pop     bx
        pop     cx
        pop     si
        ret
ShrinkHeap endp
sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2ginterf.asm ===
page    ,132
    TITLE   GINTERF - Global Memory Manager interface procedures

.sall
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
include protect.inc
ifdef WOW
include wowkrn.inc
include vint.inc
endif
.list

CheckHeap MACRO name
local   a
if KDEBUG
    extrn   CheckGlobalHeap     :near
    call    CheckGlobalHeap
    jnc a
    or  ax,ERR_GMEM
    xor bx,bx
    kerror  <>,<&name: Invalid global heap>,dx,bx
a:
endif
    endm

PROFILE MACRO   function
    pushf
    add word ptr ds:[di.gi_stats][c&function], 1
    adc word ptr ds:[di.gi_stats][c&function][2], 0
    popf
    ENDM

ifdef WOW
externFP WowCursorIconOp
externFP WowDdeFreeHandle
endif

externW pStackTop
externW pStackMin
externW pStackBot

DataBegin

externB Kernel_Flags
externB fBooting
externW hGlobalHeap
externW pGlobalHeap
externW curTDB
externW loadTDB
externW hExeHead

GSS_SI  dw  0
GSS_DS  dw  0
GSS_RET dd  0

DataEnd

sBegin  CODE
assumes CS,CODE

if SDEBUG
externNP DebugFreeSegment
endif

externNP galloc
externNP grealloc
externNP gfree
externNP glock
externNP gunlock
externNP gfreeall
externNP galign
externNP gcompact
externNP gmovebusy
externNP gsearch
externNP genter
externNP gleave
externNP gavail
externNP glrutop
externNP glrubot
externNP glrudel
externNP glruadd
externNP gmarkfree
;externNP gdiscard

externNP get_arena_pointer
externNP pdref
externNP cmp_sel_address
externNP get_physical_address
externNP set_physical_address
externNP set_sel_limit
externNP alloc_data_sel
externFP FreeSelector
externNP GetAccessWord
externNP MyGetAppCompatFlags
if ALIASES
externNP add_alias
externNP delete_alias
externNP get_alias_from_original
externNP get_original_from_alias
externNP wipe_out_alias
endif
externNP ShrinkHeap
externNP DpmiProc
externNP HackCheck

if KDEBUG
externFP OutputDebugString

ThisIsForTurboPascal:
    db "A program has attempted an invalid selector-to-handle conversion.",13,10,"Attempting to correct this error.",13,10,0
endif

if ROM
externNP GetOwner
endif

if  KDEBUG
externNP xhandle_norip
endif

;-----------------------------------------------------------------------;
; gbtop                                                                 ;
;                                   ;
; Converts a 32-bit byte count to a 16-bit paragraph count.     ;
;                                   ;
; Arguments:                                ;
;   AX = allocation flags or -1 if called from GlobalCompact    ;
;   BX = stack address of 32-bit unsigned integer           ;
;   DX = handle being reallocated or zero               ;
;   DS:DI = address of GlobalInfo for global heap           ;
;                                   ;
; Returns:                              ;
;   AX = updated allocation flags                   ;
;   BX = #paragraphs needed to contain that many bytes      ;
;   CX = owner value to use                     ;
;   DX = handle being reallocated or zero               ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed Dec 03, 1986 10:20:01p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

cProc   gbtop,<PUBLIC,NEAR>
cBegin nogen
    push    dx
    mov dx,ss:[bx][2]
    mov bx,ss:[bx]
    mov cx,4
    add bx,15
    adc dx,0
    jnc gbtop1
    dec dx
    dec bx
gbtop1:
    shr dx,1
    rcr bx,1
    loop    gbtop1
    or  dx,dx       ; Requesting more than 1 meg?
    jz  gbtop2
    mov bx,0FFFFh   ; Yes, set to bogus value - this can NEVER succeed
gbtop2:
    pop dx
    inc ax
    jnz gbtop2a
    ret         ; All done if called from GlobalCompact
gbtop2a:
    dec ax

    push    ax
if ROM
    cCall   GetOwner,<[bp].savedCS>
    mov es,ax           ; ES has owner exe hdr selector
else
    cCall   get_arena_pointer,<[bp].savedCS>
    mov es,ax           ; ES has arena of calling CS (if known)
endif
    pop ax

    push    ds
    SetKernelDS

    cmp fBooting,0      ; Done booting?
    jne gbtop3          ; No, must be KERNEL allocating then
if ROM
    mov cx,es
    cmp cx,hExeHead     ; Is the KERNEL calling us?
else
    mov cx,hExeHead     ; CX = KERNEL exe header
    cmp cx,es:[di].ga_owner ; Is the KERNEL calling us?
endif
        je      gbtop3                  ; Yes, let him party

    and ax,not GA_INTFLAGS  ; No, then cant use these flags
gbtop3:
    pop ds
    UnSetKernelDS

    test    ah,GA_ALLOC_DOS     ; Dos land allocations can never ever
    jz  gbtop3b         ;   be moved once allocated--make sure
    and al,not GA_MOVEABLE  ;   caller isn't confused about this
gbtop3b:

    mov cl,GA_SEGTYPE       ; Isolate segment type bits in CL
    and cl,al
    mov [di].gi_cmpflags,al ; Save flags for gcompact
    and [di].gi_cmpflags,CMP_FLAGS

    push    ds
    SetKernelDS

    test    al, GA_MOVEABLE     ; Is this fixed?
    jz  gbtop4          ;   yes, must go low
ife ROM
    cmp fBooting, 1     ; Booting?
    je  @F          ;   yes, allocate high
endif
    test    cl, GA_DISCCODE     ;   no, only discardable code goes high
    jz  gbtop4
@@:
    or  al, GA_ALLOCHIGH
gbtop4:
    pop ds
    UnSetKernelDS

    push    ax          ; Under Win1.0x ANY bit in 0Fh meant
    mov al,HE_DISCARDABLE   ;  make discardable.
    and ah,al           ; Under Win2.0x ONLY 01h or 0Fh means
    cmp ah,al           ;  discardable.
    pop ax
    jnz gbtop4a
    and ah,not HE_DISCARDABLE   ; Yes, convert to boolean value
    or  ah,GA_DISCARDABLE
gbtop4a:

    and ah,NOT GA_SEGTYPE   ; Clear any bogus flags
    or  ah,cl           ; Copy segment type bits
    test    ah,GA_SHAREABLE     ; Shared memory request?
    jz  GetDefOwner     ; No, default action

    mov cx, es          ; Arena of calling CS
    jcxz    no_owner_yet

ife ROM
    mov cx,es:[di].ga_owner ; owner of calling code segment
endif
no_owner_yet:
    ret
cEnd nogen


cProc   GetDefOwner,<PUBLIC,NEAR>
cBegin  nogen
    push    ds
    SetKernelDS
    mov cx,curTDB
    jcxz    xxxx
    mov es,cx
    mov cx,loadTDB
    jcxz    xxx
    mov es,cx
xxx:    mov cx,es:[TDB_PDB]
    inc cx
xxxx:   dec cx
    pop ds
    UnSetKernelDS
    ret
cEnd    nogen


; The remainder of this file implements the exported interface to the
;  global memory manager.  A summary follows:

;   HANDLE  far PASCAL GlobalAlloc( WORD, DWORD );
;   HANDLE  far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
;   HANDLE  far PASCAL GlobalFree( HANDLE );
;   HANDLE  far PASCAL GlobalFreeAll( WORD );
;   char far *  far PASCAL GlobalLock( HANDLE );
;   BOOL    far PASCAL GlobalUnlock( HANDLE );
;   DWORD   far PASCAL GlobalSize( HANDLE );
;   DWORD   far PASCAL GlobalCompact( DWORD );
;   #define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )
;   HANDLE  far PASCAL GlobalHandle( WORD );
;   HANDLE  far PASCAL LockSegment( WORD );
;   HANDLE  far PASCAL UnlockSegment( WORD );


cProc   IGlobalAlloc,<PUBLIC,FAR>,<si,di>
    parmW   flags
    parmD   nbytes
cBegin
    call    genter          ; About to modify memory arena
    PROFILE GLOBALALLOC

    cCall   MyGetAppCompatFlags     ; Ignore the NODISCARD flag
    test    al, GACF_IGNORENODISCARD    ;   for selected modules
    mov ax, flags
    jz  @f
    call    IsKernelCalling         ; needs caller's CS @ [bp+4]
    jz  @f              ; skip hack if kernel calling us
    and al, NOT GA_NODISCARD
@@:

ifdef WOW
    ; compatibility: amipro calls globalallocs some memory for storing one
    ; of its ini files and accesses the lpstring[byte after the null char].
    ; This happens to be harmless on most occasions because we roundoff the
    ; allocation to next 16byte boundary. However if the allocation request
    ; is for exactly 0x10 bytes we allocate a selector of exactly 0x10 bytes
    ; and thus amipro GPs when it access the byte seg:0x10 
    ;
    ; So here is a cheap fix. 
    ;                                                          - nanduri

    cmp word ptr nbytes+2, 0
    jnz @F
    cmp word ptr nbytes, 010h
    jne @F
    inc word ptr nbytes
@@:
endif

    xor dx,dx           ; No handle
    lea bx,nbytes       ; Convert requested bytes to paragraphs
    call    gbtop           ; ... into BX
    call    galloc
    CheckHeap   GlobalAlloc
    call    gleave
    mov es,di
cEnd

cProc   IGlobalReAlloc,<PUBLIC,FAR>,<si,di>
    parmW   handle
    parmD   nbytes
    parmW   rflags
cBegin
;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
    test    byte ptr handle,7
    jnz @F
if KDEBUG
    Trace_Out "GlobalReAlloc:"
    push    seg ThisIsForTurboPascal
    push    offset ThisIsForTurboPascal
    cCall   OutputDebugString
    INT3_WARN
endif
    dec handle
@@:

    call    genter      ; About to modify memory arena
    PROFILE GLOBALREALLOC

    cCall   MyGetAppCompatFlags     ; Ignore the NODISCARD flag
    test    al, GACF_IGNORENODISCARD    ;   for selected modules
    mov ax, rflags
    jz  @f
    call    IsKernelCalling         ; needs caller's CS @ [bp+4]
    jz  @f              ; skip hack if kernel calling us
    and al, NOT GA_NODISCARD
@@:
    mov dx,handle
    ;mov    ax,rflags
    lea bx,nbytes   ; Convert requested bytes to paragraphs
    call    gbtop       ; ... into BX
    call    grealloc
gr_done:
    CheckHeap   GlobalReAlloc
    call    gleave
    mov es,di
cEnd

cProc   DiscardTheWorld,<PUBLIC,NEAR>
cBegin
    call    genter
    mov [di].gi_cmpflags, GA_DISCCODE
    mov dx, -1
    Trace_Out "Discarding the World."
    call    gcompact
    call    gleave
cEnd


;  Returns with Z flag set if ss:[bp+4] is a kernel code segment selector.
;  Uses:   DX, flags.

cProc   IsKernelCalling,<PUBLIC,NEAR>
cBegin  nogen
    mov dx, [bp+4]          ; CS of GlobalAlloc caller
    cmp dx, IGROUP
    jz  @f
    cmp dx, _NRESTEXT
    jz  @f
    cmp dx, _MISCTEXT
@@:
    ret
cEnd    nogen

;-----------------------------------------------------------------------;
; GlobalFree                                ;
;                                   ;
; Frees the given object.  If the object lives in someone elses banks   ;
; then the argument MUST be a handle entry.             ;
;                                   ;
; Arguments:                                ;
;   parmW   handle                          ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]     ;
; Added the zero'ing of ES on exit.                                     ;
;                                   ;
;  Sat Apr 25, 1987 10:23:13p  -by-  David N. Weise   [davidw]      ;
; Added support for EMS and added this nifty comment block.     ;
;-----------------------------------------------------------------------;

cProc   IGlobalFree,<PUBLIC,FAR>,<si,di>
    parmW   handle
ifdef WOW
DsOnStack equ [bp][-2]
endif

; if you add any local params or make this nogen or something similar,
; the references to [bp][-2] to access DS on stack will need to change!

cBegin
    call    genter          ; About to modify memory arena
    PROFILE GLOBALFREE
    xor ax,ax           ; In case handle = 0.
    mov dx,handle
    or  dx,dx
    jnz @F
    jmp nothing_to_free
@@:
;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
    test    dl,7
    jnz @F
if KDEBUG
    Trace_Out "GlobalFree:"
    push    seg ThisIsForTurboPascal
    push    offset ThisIsForTurboPascal
    cCall   OutputDebugString
    INT3_WARN
endif
    dec dx
    mov handle,dx
@@:

if ALIASES
    call    wipe_out_alias
endif
    push    dx
    call    pdref           ; returns dx=handle, ax=selector
    pushf               ; save pdref Z flag return

ifdef WOW
;
;   [bp][-2] has been changed to DsOnStack
;
endif

    cmp ax,DsOnStack     ; Are we about to free the DS on
    jz  short yup       ;  the stack and GP?
    cmp dx,DsOnStack
    jnz short nope
yup:    xor dx,dx           ; Yup, zero DS image on stack...
    mov DsOnStack,dx
nope:
    popf                ; flags from pdref, Z set if discarded
    pop dx

    jz  @f          ; discarded can be freed, but has
                    ;   no arena pointer
    mov     bx, es          ; Invalid handle if arena ptr = 0
    or  bx, bx
    jz  nothing_to_free
@@:

if KDEBUG
    or  si,si
    jz  freeo
    or  ch,ch           ; Debugging check for count underflow
    jz  freeo
    pusha
    xor bx,bx
    kerror  ERR_GMEMUNLOCK,<GlobalFree: freeing locked object>,bx,handle
    popa
freeo:
endif

ifdef WOW
    test cl, GAH_CURSORICON ; call to pdref above sets cl
    jz   gf_wowdde
    push ax                 ; save
    push bx
    push dx
    push es

    push handle
    push FUN_GLOBALFREE
    call WowCursorIconOp
    or   ax, ax             ; if TRUE 'free' else 'dont free, fake success'

    pop  es
    pop  dx
    pop  bx
    pop  ax                 ; restore

    jnz  gf_notglobalicon

    xor  ax, ax             ; fake success
    xor  cx, cx
    jmps nothing_to_free

gf_wowdde:
    test cl, GAH_WOWDDEFREEHANDLE ; call to pdref above sets cl
    jz   gf_noticon

    push ax                 ; save
    push bx
    push dx
    push es

    push handle
    call WowDdeFreeHandle
    or   ax, ax             ; if TRUE 'free' else 'dont free, fake success'

    pop  es
    pop  dx
    pop  bx
    pop  ax                 ; restore

    jnz  gf_notglobalicon

    xor  ax, ax             ; fake success
    xor  cx, cx
    jmps nothing_to_free

gf_notglobalicon:
gf_noticon:
endif

    xor cx,cx           ; Dont check owner field
    call    gfree


nothing_to_free:
    CheckHeap   GlobalFree
    call    gleave
    mov es,di

cEnd


;-----------------------------------------------------------------------;
; GlobalFreeAll                             ;
;                                   ;
; Frees all of the global objects belonging to the given owner.     ;
;                                   ;
; Arguments:                                ;
;   parmW   id                          ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]     ;
; Added the zero'ing of ES on exit.                                     ;
;                                   ;
;  Sat Apr 25, 1987 10:23:13p  -by-  David N. Weise   [davidw]          ;
; Added support for EMS and added this nifty comment block.     ;
;-----------------------------------------------------------------------;

cProc   GlobalFreeAll,<PUBLIC,FAR>,<si,di>
    parmW   id
cBegin
    call    genter          ; About to modify memory arena
    PROFILE GLOBALFREEALL
    mov cx,1
    push    cx
    mov dx,id           ; Get id to match with
    or  dx,dx           ; Is it zero?
    jnz all1            ; No, continue
    call    GetDefOwner     ; Yes, CX = default task owner to free
    mov dx,cx
all1:
if SDEBUG
    mov es,[di].hi_first    ; ES:DI points to first arena entry
    mov cx,[di].hi_count    ; CX = #entries in the arena
all2:
    cmp es:[di].ga_owner,dx
    jne all3
    mov ax, es:[di].ga_handle
    Handle_To_Sel al
    push    cx
    push    dx
    cCall   DebugFreeSegment,<ax,0>
    pop dx
    pop cx
all3:
    mov es,es:[di].ga_next  ; Move to next block
    loop    all2        ; Back for more if there (may go extra times
                ; because of coalescing, but no great whoop)
endif
    call    gfreeall
    pop cx
    CheckHeap   GlobalFreeAll
    call    gleave
    mov es,di
cEnd


;-----------------------------------------------------------------------;
; xhandle                                                               ;
;                                   ;
; Returns the handle for a global segment.              ;
;                                   ;
; Arguments:                                ;
;   Stack = sp   -> near return return address          ;
;       sp+2 -> far return return address of caller     ;
;       sp+6 -> segment address parameter           ;
;                                   ;
; Returns:                              ;
;   Old DS,DI have been pushed on the stack             ;
;                                   ;
;   ZF= 1 if fixed segment.                     ;
;    AX = handle                            ;
;                                   ;
;   ZF = 0                              ;
;    AX = handle                            ;
;    BX = pointer to handle table entry             ;
;    CX = flags and count word from handle table            ;
;    DX = segment address                       ;
;    ES:DI = arena header of object                 ;
;    DS:DI = master object segment address              ;
;                                   ;
; Error Returns:                            ;
;   AX = 0 if invalid segment address               ;
;   ZF = 1                              ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Thu Oct 16, 1986 02:40:08p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

cProc   xhandle,<PUBLIC,NEAR>
cBegin nogen
    pop dx          ; Get near return address
    mov bx,sp           ; Get seg parameter from stack
    mov ax,ss:[bx+4]
    cmp ax,-1           ; Is it -1?
    jnz xh1
    mov ax,ds           ; Yes, use callers DS
xh1:    inc bp
    push    bp
    mov bp,sp
    push    ds          ; Save DS:DI
    push    di
    call    genter
    push    dx
    mov dx,ax
    push    si

    call    pdref

    mov dx,ax           ; get seg address in DX
    jz  xhandle_ret     ; invalid or discarded handle
    mov bx,si
    or  si,si
    jz  xhandle_ret
    mov ax,si

xhandle_ret:
    pop si
    ret
cEnd nogen


cProc   GlobalHandleNorip,<PUBLIC,FAR>
;   parmW   seg
cBegin  nogen
if  KDEBUG
    call    xhandle_norip
    jmp xhandlex
endif
cEnd    nogen


cProc   IGlobalHandle,<PUBLIC,FAR>
    parmW   selector
cBegin
    cCall   MyLock,<selector>
    xchg    ax, dx
cEnd


cProc   MyLock,<PUBLIC,NEAR>
;   parmW   selector
cBegin nogen
    mov bx, sp
    xor ax, ax          ; In case LAR fails
    xor dx, dx
    lar ax, ss:[bx+2]
        jnz     ML_End                  ; LAR failed, get out
    test    ah, DSC_PRESENT
    jz  @F

    push    ds          ; Do quick conversion for present
    SetKernelDS         ; selector
    mov ds, pGlobalHeap
    UnSetKernelDS
    cCall   get_arena_pointer,<ss:[bx+2]>

        ;** Fix for bugs #9106 and (I think) #9102
        or      ax,ax                   ;Did get_arena_pointer fail?
        jnz     ml_got_arena            ;No, skip this
ife ROM
        ;** If we get here, it's only because get_arena_pointer failed.
        ;**     This happens with any non-heap selector.
        pop     ds
    jmps    ML_End          ;Return NULL instead of GP faulting
else
        ;** get_arena_pointer fails when called with a ROM segment selector
        ;**     so just assume that's what happened and return the selector
    mov ax,ss:[bx+2]        ;   Assume that's what happened and
    jmps    ml_ret          ;   just return the selector
endif
ml_got_arena:
    mov ds, ax
    mov ax, ds:[ga_handle]
ml_ret:
    pop ds
    mov dx, ax
    Handle_To_Sel   al
ML_End:
    ret 2

@@:
    pop ax          ; Convert to far call for xhandle
    push    cs
    push    ax
    call    xhandle         ; Go around the houses
    PROFILE GlobalHandle
    xchg    ax, dx
    jmp xhandlex
cEnd nogen


cProc   ILockSegment,<PUBLIC,FAR>
;   parmW   seg
cBegin  nogen
    call    xhandle         ; Get handle
    PROFILE LOCKSEGMENT
    jz  @F          ; Ignore invalid or discarded objects
    test    cl,GA_DISCARDABLE
    jz  @F
    call    glock
@@:
    jmp xhandlex
cEnd    nogen


cProc   IGlobalFix,<PUBLIC,FAR>
;   parmW   seg
cBegin  nogen
    call    xhandle         ; Get handle
    PROFILE GLOBALFIX
    jnz igf5
    jmp xhandlex        ; Ignore invalid or discarded objects
igf5:
    call    glock
    jmp    xhandlex
cEnd    nogen


cProc   IUnlockSegment,<PUBLIC,FAR>
;   parmW   seg
cBegin  nogen
    call    xhandle         ; Get handle
    PROFILE UNLOCKSEGMENT
    jz  xhandlex        ; Ignore invalid or discarded objects
    test    cl,GA_DISCARDABLE
    jz  xhandlex
    call    gunlock
    jmps    xhandlex
cEnd    nogen


cProc   IGlobalUnfix,<PUBLIC,FAR>
;   parmW   seg
cBegin  nogen
    call    xhandle         ; Get handle
    PROFILE GLOBALUNFIX
    jz  xhandlex        ; Ignore invalid or discarded objects
    call    gunlock
    jmps    xhandlex
cEnd    nogen


cProc   IGlobalSize,<PUBLIC,FAR>
;   parmW   handle
cBegin  nogen
    call    xhandle         ; Call ghandle with handle in DX
    PROFILE GLOBALSIZE
    jnz gs1         ; Continue if valid handle
    or  dx,dx
    jnz gs1
    xor ax,ax           ; Return zero if invalid handle
    jmps    xhandlex
gs1:    mov ax, es          ; Invalid handle if arena ptr = 0
    or  ax, ax
    jz  gs4
gs2:    mov ax,es:[di].ga_size  ; Get size in paragraphs
gs2a:   push    ax
    xor dx,dx           ; Returning a long result
    mov cx,4
gs3:    shl ax,1
    rcl dx,1
    loop    gs3
if 0
    ; This hack should be enabled for Simcity when its other problems
    ; are fixed on RISC (aka with krnl286).
    push    ds
    push    dx
    push    ax
    cCall   hackcheck,<handle>
    or      ax,ax
    jz      gsN
    pop     ax
    pop     dx
    mov     ax,02000h
    xor     dx,dx
    push    dx
    push    ax
gsN:
    pop     ax
    pop     dx
    pop     ds
endif
    pop cx          ; Return number paragraphs in CX
    jmps    xhandlex
gs4:    xor dx, dx
    jmps    xhandlex
cEnd    nogen

cProc   IGlobalFlags,<PUBLIC,FAR>
;   parmW   handle
cBegin  nogen
    call    xhandle         ; Call ghandle with handle in DX
    PROFILE GLOBALFLAGS
    xchg    cl,ch           ; Return lock count in low half
    mov ax,cx           ; Let caller do jcxz to test failure
xhandlex:
    call    gleave
    mov es,di           ; don't return arbitrary selector
    pop di
    pop ds
    pop bp
    dec bp
    ret 2
cEnd    nogen

cProc   IGlobalLock,<PUBLIC,FAR>
    parmW   handle
ifdef WOW
    localW  gflags
    localW  accword
endif

cBegin
ifdef WOW
    mov gflags,0
endif
    xor dx, dx          ; Assume failure
    cmp handle, -1
    jne @F
    mov handle, ds
@@:
    cCall   GetAccessWord,<handle>
ifdef WOW
    mov     accword, ax
endif
    test    al, DSC_PRESENT     ; Is it present?
    jz  GL_exit
    mov dx, handle      ; OK, will return something
    Handle_To_Sel   dl      ; Turn parameter into a selector
ifndef WOW
    test    ah, DSC_DISCARDABLE ; Is it discardable
    jz  GL_exit         ;   no, Lock is a nop
endif

    cCall   get_arena_pointer,<dx>  ; Discardable, get its arena
    or  ax, ax
    jz  GL_exit         ; No arena, assume an alias

    mov es, ax
ifdef WOW
    mov al, es:[ga_flags]
    mov byte ptr gflags, al
    test    accword, DSC_DISCARDABLE SHL 8
    jz      GL_exit
endif
    inc es:[ga_count]       ; Finally, do the lock
;;; jz  GL_rip          ; Rip if we overflow

GL_exit:
ifdef WOW
    test    gflags, GAH_CURSORICON
    jz      GL_NotIcon
    push    dx            ; save
    push    handle        ; arg for CursorIconLockOp
    push    FUN_GLOBALLOCK ; func id
    call    WowCursorIconOp
    pop     dx            ; restore

GL_NotIcon:
endif
    xor ax, ax
    mov es, ax          ; Clean out ES
    mov cx, dx          ; HISTORY - someone probably does a jcxz
cEnd

cProc   IGlobalUnlock,<PUBLIC,FAR>
    parmW   handle
ifdef WOW
    localW  gflags
    localW  accword
endif

cBegin
    mov gflags,0
    cmp handle, -1
    jne @F
    mov handle, ds
@@:
;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
    test    byte ptr handle,7
    jnz @F
if KDEBUG
    Trace_Out "GlobalUnlock:"
    push    seg ThisIsForTurboPascal
    push    offset ThisIsForTurboPascal
    cCall   OutputDebugString
    INT3_WARN
endif
    dec handle
@@:
    xor cx, cx          ; Assume zero lock count
    cCall   GetAccessWord,<handle>
ifdef WOW
    mov     accword, ax
endif
    test    al, DSC_PRESENT     ; Is it present?
    jz  GU_exit         ;   no, must be discarded, return 0:0
ifndef WOW
    test    ah, DSC_DISCARDABLE ; Is it discardable
    jz  GU_exit         ;   no, Lock is a nop
endif

    cCall   get_arena_pointer,<handle>  ; Discardable, get its arena
    or  ax, ax
    jz  GU_exit         ; No arena, assume an alias

    mov es, ax
ifdef WOW
    mov al, es:[ga_flags]
    mov byte ptr gflags, al
    test    accword, DSC_DISCARDABLE SHL 8
    jz      GU_exit
endif
    mov cl, es:[ga_count]   ; Get current count
    dec cl
    cmp cl, 0FEh
    jae @F
    dec es:[ga_count]       ; Finally, do the unlock
    jmps    GU_Exit
@@:
;;; ; Rip if we underflow
    xor cx, cx          ; Return zero on underflow

GU_exit:
ifdef WOW
    test    gflags, GAH_CURSORICON
    jz      GUL_NotIcon
    push    cx            ; save
    push    handle        ; arg for CursorIconLockOp
    push    FUN_GLOBALUNLOCK  ;  UnLocking
    call    WowCursorIconOp
    pop     cx            ; restore

GUL_NotIcon:
endif
    xor ax, ax
    mov es, ax          ; Clean out ES
    mov ax, cx
cEnd

;-----------------------------------------------------------------------;
; GlobalWire                                ;
;                                   ;
; Locks a moveable segment and moves it down as low as possible.    ;
; This is meant for people who are going to be locking an object    ;
; for a while and wish to be polite.  It cannot work as a general   ;
; panacea, judgement is still called for in its use!            ;
;                                   ;
; Arguments:                                ;
;   WORD    object handle                       ;
;                                   ;
; Returns:                              ;
;   DWORD   object address                      ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;   xhandle                             ;
;   gmovebusy                           ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed Dec 03, 1986 01:07:13p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalWire,<PUBLIC,FAR>
;   parmW   handle
cBegin nogen
    SetKernelDS es
    or  Kernel_Flags[1],kf1_MEMORYMOVED
    UnSetKernelDS   es
if KDEBUG
    push    ds
    SetKernelDS
    cmp [fBooting], 0
    jnz shutup
    push    bx
    mov bx, sp
    mov bx, ss:[bx+8]
    krDebugOut <DEB_WARN OR DEB_KrMemMan>, "GlobalWire(#BX of %BX2) (try GlobalLock)"
    pop bx
shutup:
    pop ds
    UnSetKernelDS
endif
    call    xhandle
    push    si
    jz  gw_done         ; Ignore invalid or discarded objects
    push    bx          ; Save handle
    push    cx
    test    cl,GA_DISCARDABLE
    jz  @F
    inc es:[di].ga_count    ; don't want to discard if discardable
@@: xor ax,ax           ; Try to get a fixed segment.
    mov bx,es:[di].ga_size
    mov cx,es:[di].ga_owner
    call    gsearch         ; AX = segment
    pop cx
    pop bx          ; Object handle.
    push    ax          ; Return from gsearch
    cCall   get_arena_pointer,<bx>  ; Get arena header, gsearch may
    mov es,ax           ; have moved the global object!
    test    cl,GA_DISCARDABLE
    jz  @F
    dec es:[di].ga_count    ; undo lock
@@:
;;; mov es, es:[di].ga_next
;;; mov ax, es:[di].ga_prev ; REAL arena header
    mov si,ax
;;; mov es,ax
    pop ax
    or  ax,ax
    push    bx          ; Handle
    jz  lock_in_place       ; Couldn't get memory.
    push    ax          ; New Block
    mov bx,ax
    cCall   cmp_sel_address,<bx,si> ; Flags set as if cmp bx,si
    ja  oh_no_mr_bill       ; Let's not move it up in memory!!
    pop es
;   mov bx,ga_next      ; This is always an exact fit.
    call    gmovebusy       ; Wire it on down.
lock_in_place:
    pop bx          ; Handle
    inc es:[di].ga_count    ; Lock it down.
    test    es:[di].ga_flags,GA_DISCCODE
    jz  not_disccode
    call    glrudel
    and es:[di].ga_flags,NOT GA_DISCCODE
not_disccode:
    mov ax,es
    mov ax, es:[di].ga_handle
    Handle_To_Sel   al
gw_done:
    mov dx,ax
    xor ax,ax           ; Make address SEG:OFF.
    pop si
gw_ret: jmp xhandlex

oh_no_mr_bill:
    pop bx          ; kill what's on stack
    push    es
    mov es, ax
    xor si, si
    call    gmarkfree
    pop es
    jmp lock_in_place
cEnd nogen

;-----------------------------------------------------------------------;
; GlobalUnWire                              ;
;                                   ;
;                                   ;
; Arguments:                                ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed Sep 16, 1987 04:28:49p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalUnWire,<PUBLIC,FAR>
;   parmW   handle
cBegin  nogen
    call    xhandle
    jnz guw_go
    jmp xhandlex
guw_go:

    cCall   GetAccessWord,<bx>
    test    ah, DSC_DISCARDABLE
    jz  guw_not_disccode
    test    al, DSC_CODE_BIT
    jz  guw_not_disccode
    or  es:[di].ga_flags,GA_DISCCODE
    call    glruadd
guw_not_disccode:

if KDEBUG
    cmp ch,00h          ; Debugging check for count underflow
    jne unlock1
    push    bx          ;  then the count is wrong.
    push    cx
    push    dx
    xor cx,cx
    kerror  ERR_GMEMUNLOCK,<GlobalUnWire: Object usage count underflow>,cx,bx
    pop dx
    pop cx
    pop bx
unlock1:
endif
    call    gunlock
    mov ax, 0FFFFh  ; TRUE
    jcxz    guw_done
    inc ax      ; FALSE
guw_done:
    jmp xhandlex
cEnd nogen


;-----------------------------------------------------------------------;
; GlobalCompact                             ;
;                                   ;
; Compacts the global arena until a free block of the requested size    ;
; appears.  Contrary to the toolkit it ALWAYS compacts!         ;
;                                   ;
; Arguments:                                ;
;   DWORD   minimum bytes wanted                    ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]     ;
; Added the zero'ing of ES on exit.                                     ;
;                                   ;
;  Wed Dec 03, 1986 01:09:02p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing
    
cProc   GlobalCompact,<PUBLIC,FAR>,<bx,si,di>
    parmD   minBytes
cBegin
    call    genter          ; About to modify memory arena
    PROFILE GLOBALCOMPACT
    CheckHeap   GlobalCompact

    cCall   DpmiFreeSpace
    cmp     dx,seg_minBytes
    jb      GCReallyCompact
    ja      GCWorked
    
    cmp     ax,off_minBytes
    jnb     GCWorked
    
GCReallyCompact:
if KDEBUG
    push    ax
    push    bx
    mov ax, seg_minBytes
    mov bx, off_minBytes
    krDebugOut  DEB_TRACE, "%SS2 GlobalCompact(#ax#BX), discarding segments"
    pop bx
    pop ax
endif
    mov ax,-1
    lea bx,minBytes
    call    gbtop
    assumes es, nothing
    clc             ; galign should be called with CF = 0
    call    galign
    call    gavail          ; Returns paragraphs in DX:AX
    mov cx,4            ; Convert paragraphs to bytes
    push    ax
gcsize1:
    shl ax,1
    rcl dx,1
    loop    gcsize1
    pop cx          ; Let caller do jcxz to test failure.
    jmp     GCDone

GCWorked:
    cmp     dx,0fh          ; make sure return value not too large
    jb      GCAlmostDone
    ja      GCAD1
    
    cmp     ax,0ffb0h
    jb      GCAlmostDone
    
GCAD1:
    mov     dx,0fh
    mov     ax,0ffb0h

GCAlmostDone:
    mov     cx,dx
    mov     bx,ax
    shr     bx,4
    shl     cx,12
    or      cx,bx

GCDone:
    call    ShrinkHeap
    call    gleave
    mov es,di
cEnd

;-----------------------------------------------------------------------;
; GlobalNotify                              ;
;                                   ;
; This sets a procedure to call when a discardable segment belonging    ;
; to this task gets discarded.  The discardable object must have been   ;
; allocated with the GMEM_DISCARDABLE bit set.              ;
;                                   ;
; Arguments:                                ;
;   parmD   NotifyProc                      ;
;                                   ;
; Returns:                              ;
;   nothing                             ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;   AX,CX,DX,DI,SI,DS                       ;
;                                   ;
; Registers Destroyed:                          ;
;   BX,ES                               ;
;                                   ;
; Calls:                                ;
;   nothing                             ;
;                                   ;
; History:                              ;
;                                   ;
;  Tue Jun 23, 1987 10:16:32p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalNotify,<PUBLIC,FAR>

    parmD   NotifyProc
cBegin
    push    ds
    les bx,NotifyProc       ; verify pointer
    SetKernelDS
    mov ds,curTDB
    UnsetKernelDS
    mov word ptr ds:[TDB_GNotifyProc][2],es
    mov word ptr ds:[TDB_GNotifyProc][0],bx
    pop ds
cEnd


cProc   GlobalMasterHandle,<PUBLIC,FAR>
cBegin  nogen
    push    ds
    SetKernelDS
    mov ax,hGlobalHeap
    mov dx,pGlobalHeap
    UnSetKernelDS
    pop ds
    ret
cEnd    nogen


;-----------------------------------------------------------------------;
; GetTaskDS                             ;
;                                   ;
; Gets the segment of the current task's DS.                ;
;                                   ;
; Arguments:                                ;
;   none                                ;
;                                   ;
; Returns:                              ;
;   AX = selector.                          ;
;   DX = selector.                          ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;   nothing                             ;
;                                   ;
; History:                              ;
;                                   ;
;  Thu Jun 25, 1987 10:52:10p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

cProc   GetTaskDS,<PUBLIC,FAR>
cBegin nogen
    push    ds
    SetKernelDS
    mov ds,curTDB
    UnsetKernelDS
    mov ax,ds:[TDB_Module]
    mov dx,ax
    pop ds
    ret
cEnd nogen

    assumes ds, nothing
    assumes es, nothing

cProc   IGlobalLRUOldest,<PUBLIC,FAR>
;   parmW   handle
cBegin  nogen
    call    xhandle         ; Call ghandle with handle in DX
    jz  xhandlex2
    call    glrubot
xhandlex2:
    jmp xhandlex
cEnd    nogen


cProc   IGlobalLRUNewest,<PUBLIC,FAR>
;   parmW   handle
cBegin  nogen
    call    xhandle         ; Call ghandle with handle in DX
    jz  xhandlex2
    call    glrutop
    jmp xhandlex
cEnd    nogen


;-----------------------------------------------------------------------;
; SwitchStackTo                             ;
;                                   ;
; Switched to the given stack, and establishes the BP chain.  It also   ;
; copies the last stack arguments from the old stack to the new stack.  ;
;                                   ;
; Arguments:                                ;
;   parmW   new_ss                          ;
;   parmW   new_sp                          ;
;   parmW   stack_top                       ;
;                                   ;
; Returns:                              ;
;   A new stack!                            ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;   DI,SI,DS                            ;
;                                   ;
; Registers Destroyed:                          ;
;   AX,BX,CX,DX,ES                          ;
;                                   ;
; Calls:                                ;
;   nothing                             ;
;                                   ;
; History:                              ;
;                                   ;
;  Tue Sep 22, 1987 08:42:05p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProcVDO SwitchStackTo,<PUBLIC,FAR>
;   parmW   new_ss
;   parmW   new_sp
;   parmW   stack_top
cBegin  nogen

    SetKernelDS es
    FCLI
    mov GSS_SI,si
    mov GSS_DS,ds
    pop word ptr GSS_RET[0] ; get the return address
    pop word ptr GSS_RET[2]
    assumes es, nothing
    pop ax          ; stack_top
    pop bx          ; new_sp
    pop dx          ; new_ss
    mov si,bp           ; Calculate # of parameters on stack.
    dec si          ; remove DS
    dec si
    mov cx,si
    sub cx,sp
    shr cx,1
    push    bp          ; save BP
    smov    es,ss
    mov ds,dx           ; new_ss
    mov ds:[2],sp
    mov ds:[4],ss
    mov ds:[pStackTop],ax
    mov ds:[pStackMin],bx
    mov ds:[pStackBot],bx

; switch stacks

    mov ss,dx
    mov sp,bx
    mov bp,bx
    xor ax,ax
    push    ax          ; null terminate bp chain
    jcxz    no_args
copy_args:
    dec si
    dec si
    push    es:[si]
    loop    copy_args
no_args:
    SetKernelDS
    mov es,curTDB
    mov es:[TDB_taskSS],ss
    mov es:[TDB_taskSP],sp
    push    GSS_RET.sel
    push    GSS_RET.off     ; get the return address
    mov si,GSS_SI
    mov ds,GSS_DS
    FSTI
    ret

cEnd nogen

;-----------------------------------------------------------------------;
; SwitchStackBack                           ;
;                                   ;
; Switches to the stack stored at SS:[2], and restores BP.  Preserves   ;
; AX and DX so that results can be passed back from the last call.  ;
;                                   ;
; Arguments:                                ;
;   none                                ;
;                                   ;
; Returns:                              ;
;   The old stack!                          ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;   AX,DX,DI,SI,DS                          ;
;                                   ;
; Registers Destroyed:                          ;
;   BX,CX,ES                            ;
;                                   ;
; Calls:                                ;
;   nothing                             ;
;                                   ;
; History:                              ;
;                                   ;
;  Tue Sep 22, 1987 09:56:32p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                             ;
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc SwitchStackBack,<PUBLIC,FAR>
cBegin nogen

    push    ds
    SetKernelDS
    FCLI
    pop GSS_DS
    pop GSS_RET.off     ; get the return address
    pop GSS_RET.sel
    xor bx,bx
    xor cx,cx
    xchg    bx,ss:[4]
    xchg    cx,ss:[2]
    mov ss,bx
    mov sp,cx
    mov es,curTDB
    mov es:[TDB_taskSS],ss
    mov es:[TDB_taskSP],sp
    pop bp
    push    GSS_RET.sel
    push    GSS_RET.off     ; get the return address
    mov ds,GSS_DS
    UnSetKernelDS
    FSTI
    ret

cEnd nogen

;
; GetFreeMemInfo - reports Free and Unlocked pages
;          in paging systems.  -1 for non paging system.
;
cProc   GetFreeMemInfo,<PUBLIC,FAR>
cBegin nogen
    mov ax, -1
    mov dx, ax
    ret
cEnd nogen


;-----------------------------------------------------------------------;
; GetFreeSpace                              ;
;                                   ;
; Calculates the current amount of free space               ;
;                                   ;
; Arguments:                                ;
;   flags - ignored for non-EMS system              ;
;                                   ;
; Returns:                              ;
;   DX:AX   Free space in bytes                 ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;   DI,SI,DS                            ;
;                                   ;
; Registers Destroyed:                          ;
;   BX,CX,ES                            ;
;                                   ;
; Calls:                                ;
;   nothing                             ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]     ;
; Added the zero'ing of ES on exit.                                     ;
;                                   ;
;-----------------------------------------------------------------------;

    assumes ds, nothing
    assumes es, nothing

cProc   IGetFreeSpace,<PUBLIC,FAR>,<si,di>
    parmW   flags
    localV  MemInfo,30h
cBegin
    call    genter
    xor si, si
    xor dx, dx

    mov es, [di].hi_first
gfs_loop:
    mov es, es:[di].ga_next
    cmp es:[di].ga_sig, GA_ENDSIG
    je  gfs_last            ; End of heap
    mov ax, es:[di].ga_owner
    cmp ax, GA_NOT_THERE
    je  gfs_loop            ; Nothing there
    or  ax, ax              ; Free?
    jz  gfs_freeblock
    test    flags, 2            ; Ignore discardable?
    jnz gfs_loop
    mov bx, es:[di].ga_handle
    test    bl, GA_FIXED
    jnz gfs_loop            ; Fixed block if odd
    cmp es:[di].ga_sig, 0
    jne gfs_loop            ; skip if locked
    cCall   GetAccessWord,<bx>
    test    ah, DSC_DISCARDABLE
    jz  gfs_loop
gfs_freeblock:
    mov ax, es:[di].ga_size
    inc ax
    add si, ax
    adc dx, 0               ; Keep 32 bit total
    jmps    gfs_loop

gfs_last:
    test    flags, 2            ; No fence stuff if ignoring discardable
    jnz @F
    sub si, [di].gi_reserve     ; Subtract out that above fence
    sbb dx, 0
@@:
    mov ax, si              ; Return in DX:AX
                        ; Convert to bytes
REPT 4
    shl ax, 1
    rcl dx, 1
ENDM

    ;
    ; Get the ammount of free memory
    ;
    push    bx
    push    cx
    push    ax
    push    dx
    call    DpmiFreeSpace
    pop     dx
    pop     ax
    add     ax,bx
    adc     dx,cx
    pop     cx
    pop     bx
@@: call    gleave
    mov es,di
cEnd

;-----------------------------------------------------------------------;
; GlobalDOSAlloc
;
; Allocates memory that is accessible by DOS.
;
; Entry:
;   parmD   nbytes      number of bytes to alloc
;
; Returns:
;   AX = memory handle
;   DX = DOS segment paragraph address
;
; History:
;  Tue 23-May-1989 11:30:57  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalDOSAlloc,<PUBLIC,FAR>,<di,si>
    parmD   nbytes
cBegin
    mov ax,GA_ALLOC_DOS shl 8
    cCall   IGlobalAlloc,<ax,nbytes>
    xor dx,dx            ; In case of error return
    or  ax,ax
    jz  short gda_exit
    push    ax
    cCall   get_physical_address,<ax>
REPT 4
    shr dx,1
    rcr ax,1
ENDM
    xchg    dx,ax
    pop ax
gda_exit:
cEnd

;-----------------------------------------------------------------------;
; GlobalDOSFree
;
; Frees memory allocated by GlobalDOSAlloc.
;
; Entry:
;   parmW   handle
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 17:48:03  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalDOSFree,<PUBLIC,FAR>
    parmW   handle
cBegin  nogen
    jmp IGlobalFree
cEnd    nogen

if ALIASES

;-----------------------------------------------------------------------;
; GlobalAllocHuge
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 21-Jan-1990 16:35:10  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalAllocHuge,<PUBLIC,FAR>,<di,si>

    parmW   flags
    parmD   nbytes
    parmW   maxsegs         ; !!! check for maxsegs = 0

    localW  hMem
    localW  hAlias
cBegin
    cCall   GlobalAlloc,<0,nbytes>
    or  ax,ax
    jz  gah_exit
    mov hMem,ax
    cCall   get_physical_address,<ax>
    mov cx,maxsegs
    cmp cx,0Fh
    jb  @F
    mov cx,0Fh
@@: shl cx,12
    or  cx,0FFFh
    cCall   alloc_data_sel,<dx,ax,cx>
    or  ax,ax
    jz  gah_error_return
    mov hAlias,ax
    mov bx,hMem
    call    add_alias       ; the key point!
    mov bx,ax
    mov ax,maxsegs      ; the only way to remember
    call    add_alias       ;  the number of selectors
    mov cx,nbytes.hi
    mov bx,nbytes.lo
    cCall   set_sel_limit,<hAlias>
    mov ax,hAlias
    jmps    gah_exit

gah_error_return:
    cCall   GlobalFree,<hMem>
    xor ax,ax

gah_exit:

cEnd


;-----------------------------------------------------------------------;
; GlobalReAllocHuge
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 21-Jan-1990 16:35:10  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalReAllocHuge,<PUBLIC,FAR>,<si,di>

    parmW   handle
    parmD   nbytes
cBegin
    mov ax,handle
    call    get_alias_from_original
    cmp bx,nbytes.hi
    jb  grh_error_exit
    call    get_original_from_alias
    push    es
    or  bx,SEG_RING
    cCall   GlobalRealloc,<bx,nbytes,0>
    pop es
    or  ax,ax           ; did we get the memory?
    jz  grh_exit
    cmp ax,es:[di].sae_sel  ; did the selector change?
    jz  grh_exit
    mov es:[di].sae_sel,ax
    cCall   get_physical_address,<ax>
    cCall   set_physical_address,<handle>
    mov ax,handle
    jmps    grh_exit

grh_error_exit:
    xor ax,ax

grh_exit:

cEnd


;-----------------------------------------------------------------------;
; GlobalFreeHuge
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 22-Jan-1990 21:24:02  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalFreeHuge,<PUBLIC,FAR>,<di,si>

    parmW   handle
cBegin
    mov ax,handle
    call    get_alias_from_original
    mov es:[di].sae_sel,0
    mov es:[di].sae_alias,0
    mov cx,bx
    mov bx,0FFFFh
    cCall   set_sel_limit,<ax>
    mov dx,ax
    mov ax,handle
    call    get_original_from_alias
    push    bx
    push    ax
    call    delete_alias
    pop ax          ; wastes a couple of bytes
    cCall   FreeSelector,<ax>
    pop ax
    cCall   GlobalFree,<ax>
cEnd

endif ; ALIASES

;-----------------------------------------------------------------------;
; GlobalHuge
;
; Random place holder of an entry point.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 23-Jan-1990 00:53:59  -by-  David N. Weise  [davidw]
; Stubbed it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   GlobalHuge,<PUBLIC,FAR>

cBegin nogen
    ret 10
cEnd nogen

cProc DpmiFreeSpace,<PUBLIC,NEAR>,<di,si,es>
        localV MemInfo,30h
cBegin
        ;
        ; Get Memory Info
        ;
        mov     ax,ss  
        mov     es,ax
        lea     di,MemInfo
        DPMICALL 500h
        jc      dfs30
        
        ;
        ; Convert pages to bytes
        ;
        mov     bx,MemInfo[14h]
        mov     cx,MemInfo[16h]
REPT 12    
        shl     bx,1
        rcl     cx,1
ENDM
        ;
        ; Get the rest of the info
        ;
        mov     ax,MemInfo[0]
        mov     dx,MemInfo[2]
        jmp     dfs40
        
dfs30:  xor     ax,ax
        mov     bx,ax
        mov     cx,ax
        mov     dx,ax
        
dfs40:
cEnd

ifdef WOW
;--------------------------------------------------------------------------;
;
; Similar to GlobalFlags
;
;--------------------------------------------------------------------------;

cProc   SetCursorIconFlag,<PUBLIC,FAR>
   parmW   handle
   parmW   fSet
cBegin
    cCall   get_arena_pointer,<handle>      ; get the owner
    mov es,ax
    or  ax,ax
    jz  sf_error
    mov ax,fSet
    or  ax,ax
    jz  sf_unset
    or  es:[ga_flags], GAH_CURSORICON
    jmps sf_error
sf_unset:
    and es:[ga_flags], NOT GAH_CURSORICON
sf_error:
    xor ax,ax
    mov es,ax
cEnd

;--------------------------------------------------------------------------;
;
; Stamp the 01h in globalarena for DDE handles. This is GAH_PHANTOM flag
; which is not used any longer.
;
;--------------------------------------------------------------------------;

cProc SetDdeHandleFlag,<PUBLIC,FAR>
    parmW   handle
    parmW   fSet
cBegin
    cCall   get_arena_pointer,<handle>      ; get the owner
    mov es,ax
    or  ax,ax
    jz  sd_error

    mov ax,fSet
    or  ax,ax
    jz  sd_unset
    or  es:[ga_flags], GAH_WOWDDEFREEHANDLE
    jmps sd_error

sd_unset:
    and es:[ga_flags], NOT GAH_WOWDDEFREEHANDLE

sd_error:
    xor ax,ax
    mov es,ax
cEnd
endif

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3gacheck.asm ===
.xlist
include kernel.inc
include	protect.inc
.list

	.386p

DataBegin

externB  fBooting
externW	 pGlobalHeap

DataEnd


sBegin	CODE
assumes	CS,CODE

if KDEBUG

externNP check_lru_list
externNP check_free_list

externFP ValidateFreeSpaces


;-----------------------------------------------------------------------;
; CheckGlobalHeap                                                       ;
; 									;
; The Global Heap is checked for consistency.  First the forward links	;
; are examined to make sure they lead from the hi_first to the hi_last.	;
; Then the backward links are checked to make sure they lead from the	;
; hi_last to the hi_first.  Then the arenas are sequentially checked	;
; to see that the moveable entries point to allocated handles and that	;
; said handles point back.  The handle table is then checked to see	;
; that the number of used handles match the number of referenced	;
; handles, and that the number of total handles matches the sum of the	;
; free, discarded, and used handles.  Finally the free list of handles	;
; is checked.								;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	CF = 0 everything is just fine					;
;	all registers preserved						;
; 									;
; Error Returns:							;
;	CF = 1								;
;	DX = offending arena header					;
;	AX = 01h Forward links invalid					;
;	     02h Backward links invalid					;
;	     04h ga_handle points to free handle			;
;	     08h arena points to handle but not vice versa		;
;	     80h ga_sig is bad						;
;	DX = 0								;
;	AX = 10h allocated handles don't match used handles		;
;	     20h total number of handles don't match up			;
;	     40h total number of free handles don't match up		;
;									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Nov 01, 1986 02:16:46p  -by-  David N. Weise   [davidw]          ;
; Rewrote it from C into assembly.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CheckGlobalHeap,<PUBLIC,NEAR>
cBegin nogen
	push	eax
	push	edx
	push	ebx
	push	ecx
	push	edi
	push	esi
	push	ds
	push	es
	push	fs
	push	gs

	xor	eax,eax
	xor	edx,edx
	xor	edi,edi
	SetKernelDS es
	cmp	pGlobalHeap,di
	jnz	short there_is_a_GlobalHeap
	jmp	all_done
there_is_a_GlobalHeap:
;;;     test    fBooting, 1
;;;     jnz     no_check
	mov	ds,pGlobalHeap
;;;	UnSetKernelDS
	cmp	[di].hi_check,di
	jnz	short checking_enabled
no_check:
;;;	jmp	all_done
checking_enabled:
	mov	cx,[di].hi_count
	mov	esi,[di].phi_first
;;;	mov	es, dx
forward_ho:

	push	cx
	mov	eax, ds:[esi].pga_address
	mov	ecx, ds:[esi].pga_size
	cmp	ds:[esi].pga_owner, GA_NOT_THERE
	je	short no_limit_check
	cmp	ds:[esi].pga_owner, GA_BURGERMASTER
	je	short no_limit_check
	cmp	ds:[esi].pga_owner, di
	je	short no_limit_check
	cmp	ds:[esi].pga_handle, di
	je	short no_limit_check
        test    fBooting, 1
        jnz     short no_limit_check
	mov	bx, ds:[esi].pga_handle
	dec	ecx
	Handle_To_Sel	bl
	lsl	ebx, ebx
	jnz	short bad_limit
	cmp	ecx, ebx
	je	short ok_limit
bad_limit:
int 3
ok_limit:
no_limit_check:
	add	eax, ds:[esi].pga_size
	mov	ebx, ds:[esi].pga_next
	mov	edx, ds:[ebx].pga_address
	cmp	eax, edx
	pop	cx
	xchg	esi, ebx
	jne	short forward_size_mismatch
	cmp	ebx, ds:[esi].pga_prev
	jz	short size_and_next_match
forward_size_mismatch:
	cmp	ds:[esi].pga_owner, GA_NOT_THERE
	je	short size_and_next_match
	cmp	cx,1
	jnz	short forward_links_invalid
size_and_next_match:
	loop	xxxx
	cmp	ebx,[di].phi_last
	jz	short forward_links_okay
forward_links_invalid:
int 3
	mov	edx,ebx
	mov	ax,1
	jmps	all_done
xxxx:
	jmp	forward_ho

	UnSetKernelDS es

forward_links_okay:

	xor	ax, ax
	call	check_lru_list
	call	check_free_list
;	push	cs
;	call	near ptr ValidateFreeSpaces
clear_dx_all_done:
	xor	dx,dx
all_done:
	pop	gs
	pop	fs
	pop	es
	pop	ds
	pop	esi
	pop	edi
	pop	ecx
	pop	ebx
	or	ax,ax
	jnz	short cgh_error
	pop	edx
	pop	eax
	ret
cgh_error:
	int	3
	add	sp,8
	stc
	ret
cEnd nogen

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2gmem.asm ===
TITLE   GMEM - Register interface to global memory allocator

.xlist
include kernel.inc
include tdb.inc
include protect.inc
.list

externFP SetSelectorLimit

DataBegin

externB  fBooting
;externW  curTDB
;externW  pGlobalHeap
externW  SelTableStart
externW  SelTableLen

ifdef WOW
globalB  fInAlloc, 0
globalW  UserSelArray, 0
globalW  SelectorFreeBlock, 0
endif

DataEnd

sBegin  CODE
assumes CS,CODE

externNP DPMIProc
DPMICALL MACRO  callno
        mov     ax, callno
        call    DPMIProc
        ENDM

;externW  gdtdsc


externNP gsplice
externNP gjoin
externNP gzero
externNP gsearch
externNP gmarkfree
;externNP gcheckfree
externNP gmovebusy
externNP gcompact
externNP glruadd
externNP glrudel
externNP glrutop
externNP gnotify
externNP henum
externNP is_there_theoretically_enough_space
externNP can_we_clear_this_space

externNP get_physical_address
externNP set_physical_address
externNP alloc_sel
externNP alloc_data_sel_above
externNP pdref
externNP set_sel_limit
externNP mark_sel_PRESENT
externNP mark_sel_NP
externNP free_sel
externNP FreeSelArray
externNP GrowSelArray
externNP get_arena_pointer
externNP get_temp_sel
externNP get_blotto
;externNP get_sel
externNP PreallocSel
externNP AssociateSelector
externNP GetAccessWord
externNP SetAccessWord
externFP set_discarded_sel_owner

if ROM
externNP IsROMObject
endif

if KDEBUG
externNP CheckGAllocBreak
endif

;-----------------------------------------------------------------------;
; galign                                                                ;
;                                                                       ;
; Aligns the size request for a global item to a valid para boundary.   ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = #paras                                                     ;
;       CF = 1 if #paras overflowed.                                    ;
;                                                                       ;
; Returns:                                                              ;
;       DX = #paras aligned,  to next higher multiple of 2              ;
;                                                                       ;
; Error Returns:                                                        ;
;       DX = FFFFh                                                      ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
; Registers Destroyed:                                                  ;
;       none                                                            ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Mon Sep 22, 1986 03:14:56p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   galign,<PUBLIC,NEAR>
cBegin  nogen

        jc      align_error             ; Overflow occur?
        lea     dx,[bx+GA_ALIGN]        ; No, add alignment amount
        and     dl,GA_MASK              ; ...modulo alignment boundary
        cmp     dx,bx                   ; Test for overflow
        jnb     align_exit              ; Yes, continue
align_error:
        mov     dx,0FFFFh               ; Return impossible size
align_exit:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; galloc                                                                ;
;                                                                       ;
; Allocates global memory.                                              ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocation flags                                           ;
;       BX = #paragraphs                                                ;
;       CX = owner field                                                ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle to object or zero                                   ;
;       BX = size of largest free block if AX = 0                       ;
;       CX = AX                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       DX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       gsearch                                                         ;
;       ghalloc                                                         ;
;       glruadd                                                         ;
;       gmarkfree                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Jun 24, 1987 03:04:32a  -by-  David N. Weise     [davidw]        ;
; Added support for Global Notify.                                      ;
;                                                                       ;
;  Mon Sep 22, 1986 02:38:19p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

AccessWord      dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_CODE+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_CODE+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT

cProc   galloc,<PUBLIC,NEAR>
cBegin  nogen

if ROM and KDEBUG
        if 1
        %out    Remove me someday
        endif
        or      cx,cx                   ; had trouble with owner == 0
        jnz     @f                      ;   too many times!
        Debug_Out "ROMKRNL: galloc with owner = 0!"
@@:
endif

if KDEBUG
        test    al,GA_DISCCODE          ; If discardable code, allow alloc
        jnz     @F
        call    CheckGAllocBreak
        jnc     @F
        jmp     gaerr
@@:
endif

        or      bx,bx                   ; Allocating zero size?
        jnz     @F
        jmp     allocate_zero_size
@@:

ifdef WOW
        push    ds
        SetKernelDS
        mov     fInAlloc, 1
        mov     SelectorFreeBlock, 0
        mov     UserSelArray, 0
        UnSetKernelDS
        pop     ds
endif
        call    gsearch                 ; Search for block big enough
        jnz     bleech
        mov     cx, ax

ifdef WOW
        push    ds
        SetKernelDS
        mov     fInAlloc, 0
        mov     SelectorFreeBlock, 0
        mov     UserSelArray, 0
        UnSetKernelDS
        pop     ds
endif

        ret                             ; Done, if couldn't get enough
bleech:
        mov     es,ax
        push    dx

ifdef WOW

        push    ds
        SetKernelDS
        mov     fInAlloc, 0
        mov     SelectorFreeBlock, 0
        mov     ax, UserSelArray
        UnSetKernelDS
        pop     ds
        or      ax, ax
        jnz     got_Sel
        mov     ax, es

old_path:

endif
        mov     bx,dx
        cCall   get_physical_address,<ax>
        add     ax,10h                  ; Calculate address of object
        adc     dx,0
        mov     cx, ax                  ; in DX:CX

        and     bx, ((GA_CODE_DATA+GA_DISCARDABLE) shl 8) + GA_DGROUP
        or      bl, bh
        xor     bh, bh
        shl     bx, 1
        mov     ax, cs:AccessWord[bx]   ; Pick up access rights for selector
        cCall   alloc_sel,<dx,cx,es:[di].ga_size>

got_sel:
        pop     dx
        or      ax, ax
        jz      short gaerr1
        cCall   AssociateSelector,<ax,es>
        test    dl,GA_MOVEABLE          ; Is this a moveable object?
        jnz     moveable
        test    dh, GA_DISCARDABLE      ; We have a fixed block
        jnz     not_moveable            ; Not interested in discardable blocks
        mov     bx, ax
%out THIS IS WRONG!!!
ifdef WOW
        ; the following dpmicall is basically a NOP. so just
        ; avoid the call altogether.
        ;                                    - Nanduri Ramakrishna
else
        mov     ax, 4                   ; Lock the WIN386 pages
        ;bugbugbugbug
        DPMICALL ax                     ; int     31h
        mov     ax, bx
endif
        jmps    not_moveable
moveable:
        mov     es:[di].ga_count,0      ; Initialize lock count to 0
        StoH    al                      ; Mark as moveable block
not_moveable:
        mov     es:[di].ga_handle,ax    ; Set handle in arena
        mov     bx, ax                  ; AX and BX handle

        call    glruadd                 ; Yes, Add to LRU chain
        mov     cx, ax
        ret

allocate_zero_size:
        test    al,GA_MOVEABLE          ; Yes, moveable?
        jz      gaerr                   ; No, return error (AX = 0)

        mov     bx, ax
        and     bx, ((GA_CODE_DATA+GA_DISCARDABLE) shl 8) + GA_DGROUP
        or      bl, bh                  ; Above bits are exclusive
        xor     bh, bh
        shl     bx, 1
        mov     ax, cs:AccessWord[bx]   ; Pick up access rights for selector
        and     al, NOT DSC_PRESENT     ; These are NOT present
        xor     dx, dx                  ; Base of zero for now
        cCall   alloc_sel,<dx,dx,cx>
        or      ax, ax
        jz      gaerr

        cCall   AssociateSelector,<ax,cx>
        StoH    al                      ; Handles are RING 2
        mov     bx,ax
ga_exit:
        mov     cx, ax
        ret

gaerr1:
        xor     si,si
        call    gmarkfree
gaerr:
        KernelLogError  DBF_WARNING,ERR_GALLOC,"GlobalAlloc failed"
        xor     dx,dx                   ; DX = 0 means NOT out of memory
        xor     ax,ax                   ; Return AX = 0 to indicate error
        jmps    ga_exit
cEnd    nogen


;-----------------------------------------------------------------------;
; grealloc                                                              ;
;                                                                       ;
; Reallocates the given global memory object.                           ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocation flags                                           ;
;       BX = #paragraphs for new size                                   ;
;       CX = new owner field value                                      ;
;       DX = existing handle                                            ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle to object or zero                                   ;
;       DX = size of largest free block if AX = 0                       ;
;       CX = AX                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 05-Feb-1990 21:07:33  -by-  David N. Weise  [davidw]             ;
; Got rid of the spagetti code.                                         ;
;                                                                       ;
;  Mon Sep 22, 1986 10:11:48a  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   grealloc,<PUBLIC,NEAR>,<si>

        localW  rflags
        localW  hMem
        localW  oldhMem
        localW  owner
        localW  rsize
        localW  canmove
        localB  locked
        localB  mflags
        localW  numsels
cBegin
        mov     rflags,ax
        mov     hMem,dx
        mov     oldhMem,dx
        mov     owner,cx
        mov     rsize,bx
        call    pdref
        mov     dx,bx                   ; save owner if discarded
        mov     word ptr mflags,cx
        mov     bx,rsize
        jnz     handle_ok
        jmp     racreate                ; Do nothing with 0, free or discarded  handles
handle_ok:
        test    byte ptr rflags,GA_MODIFY  ; Want to modify table flags?
        jnz     ramodify                ; Yes go do it
        or      bx,bx                   ; Are we reallocing to zero length?
        jz      radiscard
        jmp     ra_shrink_grow          ; No, continue

;-----------------------------------------------------------------------;
; Here to discard object, when reallocating to zero size.  This         ;
; feature is only enabled if the caller passes the moveable flag        ;
;-----------------------------------------------------------------------;

radiscard:
        or      ch,ch                   ; Is handle locked?
        jnz     radiscard_fail
        test    byte ptr rflags,GA_MOVEABLE ; Did they want to discard?
        jz      radiscard_fail          ; No, then return failure.
        mov     al,GN_DISCARD           ; AL = discard message code
        xor     cx,cx                   ; CX = means realloc
        mov     bx,hMem                 ; BX = handle
        push    es
        call    gnotify                 ; See if okay to discard
        pop     es
        jz      radiscard_fail          ; No, do nothing
        call    glrudel                 ; Yes, Delete handle from LRU chain

        cCall   mark_sel_NP,<si,es:[di].ga_owner>

        xor     si,si
        call    gmarkfree               ; Free client data
        mov     ax,0                    ; don't change flags
        jz      @F                      ; Return NULL if freed a fixed block
        mov     bx, si
        mov     ax,hMem                 ; Return original handle, except
@@:     jmp     raexit                  ; GlobalLock will now return null.

radiscard_fail:
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        xor     dx,dx
        xor     ax,ax
        jmp     raexit

;-----------------------------------------------------------------------;
; There are 2 attributes that can change:                               ;
;  1) Fixed -> moveable - added in 2.x, probably not used by many       ;
;  2) nondiscardable <-> discardable                                    ;
;  3) non-shared -> shared, i.e., the owner changes                     ;
;-----------------------------------------------------------------------;

ramodify:
if ROM
        cCall   IsROMObject,<hMem>      ; If someone is trying to modify a
        jc      ramod_done              ;   ROM object, just pretend it worked
endif
        mov     ax,rflags               ; Get new flags
        mov     dx,owner                ; Get new owner field value
        or      si,si                   ; Moveable object?
        jnz     is_moveable             ;  yes, change discardability/owner
        test    al,GA_MOVEABLE          ; Make fixed into moveable?
        jz      ra_mod_owner            ; Fixed, can ONLY change owner

        push    ax
        push    cx
        mov     ax, es:[di].ga_handle   ; Turn selector into handle
        StoH    al
        mov     bx, ax
        mov     es:[di].ga_handle, ax
        mov     es:[di].ga_count, 0     ; 0 lock count for new movable obj
        pop     cx
        pop     ax
        mov     si,bx

; fall through to code that makes [non]discardable and may change owner

is_moveable:
        call    glrudel                 ; Remove from lru chain, even though
        push    bx
        mov     bx, ax
        cCall   GetAccessWord,<si>
        and     ah, not DSC_DISCARDABLE ; Clear discard bit
        test    bh, GA_DISCARDABLE
        jz      ra_notdiscardable
        or      ah, DSC_DISCARDABLE
ra_notdiscardable:
        cCall   SetAccessWord,<si,ax>
        mov     ax, bx
        pop     bx
        test    cl,HE_DISCARDED         ; Is this a discarded handle?
        jz      ramod1                  ; No, continue
        test    ah,GA_SHAREABLE         ; Only change owner if making shared
        jz      ramod_done

        push    bx
        push    es
        mov     bx, si
        mov     es, dx
        call    set_discarded_sel_owner
        pop     es
        pop     bx
        jmps    ramod_done

ramod1: call    glruadd                 ; only adds to list IF object is disc

ra_mod_owner:
        test    ah,GA_SHAREABLE         ; Only change owner if making shared
        jz      ramod_done
        mov     es:[di].ga_owner,dx     ; Set new owner value
ramod_done:
        mov     ax,hMem                 ; Return the same handle
        jmp     raexit                  ; All done

;-----------------------------------------------------------------------;
; We are here to grow a 0 sized object up big.                          ;
;-----------------------------------------------------------------------;

racreate:
        test    cl,HE_DISCARDED         ; Is this a discarded handle?
        jz      racre_fail              ; No, return error
        or      bx,bx                   ; Are we reallocing to zero length?
        mov     ax,hMem
        jz      racre_done              ; Yes, return handle as is.
if KDEBUG
        test    cl,GA_DISCCODE          ; if discardable code, allow realloc
        jnz     @F
        call    CheckGAllocBreak
        jc      racre_fail
@@:
endif
        mov     ax,GA_MOVEABLE          ; Reallocating a moveable object
        or      ax,rflags               ; ...plus any flags from the caller

        and     cl,GA_SEGTYPE
        or      al,cl
        mov     cx,dx                   ; get owner
        push    ds
        SetKernelDS
ife ROM
        cmp     fBooting, 1             ; Allocate high while booting
        je      @F
endif
        test    al,GA_DISCCODE          ; Discardable code segment?
        jz      ranotcode
@@:
        or      al,GA_ALLOCHIGH         ; Yes, allocate high
ranotcode:
        pop     ds
        UnSetKernelDS
        mov     [di].gi_cmpflags,al     ; Save flags for gcompact
        and     [di].gi_cmpflags,CMP_FLAGS
        push    si                      ; save handle
        call    gsearch                 ; Find block big enough
        pop     si                      ; restore existing handle
        jz      racre_fail1

        mov     bx,ax                   ; save new block
        cCall   mark_sel_PRESENT,<ax,si> ; sets a new set of sels if necessary
        or      si,si
        jz      racre_worst_case
        xchg    ax,si                   ; Return original/new handle
                                        ; Set back link to handle in new block
        cCall   AssociateSelector,<ax,si>
        mov     es,si
        mov     es:[di].ga_handle,ax
        mov     es:[di].ga_count,0
        call    glruadd                 ; Add to LRU chain
        jmps    racre_done

racre_worst_case:
        mov     es,bx                   ; Free block if no handles available.
        xor     si,si
        call    gmarkfree

racre_fail:
        xor     dx,dx
racre_fail1:
        push    dx
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        pop     dx
        xor     ax,ax                   ; Yes, return failure
racre_done:
        jmp     raexit


;-----------------------------------------------------------------------;
; This is what most would have thought is the guts of GlobalRealloc.    ;
;-----------------------------------------------------------------------;

ra_shrink_grow:

if KDEBUG
        test    es:[di].ga_flags,GA_DISCCODE
        jz      ok
        INT3_WARN                       ; GlobalRealloc of discardable code!
ok:
endif
        cmp     bx,es:[di].ga_size
        jz      rasame

        add     bx,1                    ; add room for header, set carry bit
        jc      ra_s_g_fail
        call    galign                  ; assuming there is room.
        dec     dx                      ; Exclude header again
        mov     si,dx

; Here if not trying to realloc this block to zero
; ES:0 = arena header of current block
; AX:0 = client address of current block
; CH = lock count of current block
; DX = new requested size of block
; SI = new requested size of block

        mov     bx,es:[di].ga_next      ; Get address of current next header
        cmp     si,es:[di].ga_size      ; Are we growing or shrinking?
        ja      raextend                ; We are growing

        call    rashrink
rasame: mov     ax,hMem                 ; Return the same handle
        jmp     raexit                  ; All done

raextend:
        test    rflags,GA_DISCCODE      ; Not allowed to grow a disccode seg
        jnz     ra_s_g_fail
if KDEBUG
        call    CheckGAllocBreak
        jc      ra_s_g_fail
endif
        push    ax
        call    GrowSelArray
        mov     numsels, cx             ; Save how many to free just in case
        mov     cx, ax
        pop     ax
        jcxz    ra_s_g_fail             ; Didn't get selectors
        mov     hMem, cx                ; We have a new handle
        call    ragrow
        jnc     rasame
        test    mflags,GA_DISCARDABLE   ; if discardable, just stop now
        jz      ramove                  ;  since it might get discarded!
ra_s_g_fail:
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        xor     ax,ax                   ; Yes, return failure
        xor     dx,dx
        jmp     raexit


; Here to try to move the current block
; AX = client address of current block
; ES:0 = arena header of current block
; CH = lock count of current block
; SI = new requested size of block

ramove: mov     canmove, 1
        mov     dx,rflags               ; get the passed in flags
        test    dx,GA_MOVEABLE          ; Did they say OK to move
        jnz     ramove1                 ; Yes, try to move even iflocked or fixed
        cmp     locked, 0               ; Locked?
        jnz     racompact               ; Continue if this handle not locked
                                        ; yes, try to find space to grow in place
        or      dx,GA_MOVEABLE          ; If moveable, make sure bit set.
        test    hMem,GA_FIXED           ; Is this a moveable handle?
        jz      ramove2                 ; Yes, okay to move
racompact:
        xor     dx,dx                   ; No, get size of largest free block
        call    gcompact
        jmps    racantmove

ramove1:
        test    hMem, GA_FIXED
        jz      ramove2
        and     dx, NOT GA_MOVEABLE
ramove2:
        mov     ax,dx                   ; AX = allocation flags
        mov     bx,si                   ; BX = size of new block
        call    PreAllocSel             ; for gmovebusy later
        jz      racantmove
        mov     cx,bx                   ; CX = owner (use size for now)
        call    gsearch                 ; Find block big enough
        jz      racantmove              ; Cant find one, grow in place now?
        mov     cx,hMem

        push    ax
        cCall   get_arena_pointer,<cx>
;;;     mov     es,ax
;;;     mov     es,es:[di].ga_next      ; get real arena header
;;;     mov     si,es:[di].ga_prev
        mov     si, ax                  ; SI = source arena
        pop     es                      ; ES = destination arena

        call    gmovebusy               ; Call common code to move busy block
                                        ; (AX destroyed)
        push    bx
        push    cx
        mov     bx, es:[di].ga_size
        xor     cx,cx
REPT    4
        shl     bx,1
        rcl     cx,1
ENDM
        cCall   set_sel_limit, <es:[di].ga_handle>

        pop     cx
        pop     bx
        mov     ax,cx                   ; Return new handle
raexit:
        mov     cx,ax
        jcxz    ra_done
        test    hMem,GA_FIXED           ; Is this a moveable object?
        jz      ra_done                 ;  no, don't lock
        mov     bx, ax
ifdef WOW
        ; the following dpmicall is basically a NOP. so just
        ; avoid the call altogether.
        ;                                    - Nanduri Ramakrishna
else
        mov     ax, 4                   ; Lock the WIN386 pages
        ; bugbugbugbug
        DPMICALL ax                     ; int     31h
        mov     ax, bx
endif
        jmps    ra_done

racantmove:
        mov     dx, hMem
        call    pdref

        mov     bx,rsize
        add     bx,1                    ; add room for header, set carry bit
        call    galign                  ; assuming there is room.
        dec     dx                      ; Exclude header again
        mov     si,dx

        mov     bx,es:[di].ga_next      ; Get address of current next header
        call    ragrow
        jc      racmove3
        jmp     rasame

racmove3:
        xor     dx,dx                   ; No, get size of largest free block
        call    gcompact
        mov     dx,ax                   ; DX = size of largest free block

rafailmem:
        cCall   get_arena_pointer,<hMem>
        mov     es,ax
        mov     ax,es:[di].ga_size      ; AX = size of current block
        mov     es,es:[di].ga_next      ; Check following block
        cmp     es:[di].ga_owner,di     ; Is it free?
        jne     rafailmem0              ; No, continue
        add     ax,es:[di].ga_size      ; Yes, then include it as well
        inc     ax
rafailmem0:
        cmp     ax,dx                   ; Choose the larger of the two
        jbe     rafailmem1
        mov     dx,ax
rafailmem1:
        push    dx                      ; Save DX
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        pop     dx                      ; RestoreDX
        xor     ax,ax
        jmps    raexit

ra_done:                                ; 3 feb 1990, this
        push    ax                      ;  is a last minute hack
        push    bx
        push    cx
        push    dx
        mov     bx,hMem
        mov     cx,oldhMem
ife RING-1
        inc     bx
        and     bl,NOT 1
        inc     cx
        and     cl,NOT 1
else
        or      bl, 1
        or      cl, 1
endif
        cmp     bx,cx                   ; was a new selector allocated?
        jz      ra_really_done          ;
        or      ax,ax                   ; figure out if we suceeded
        jz      ra_ra
        cCall   FreeSelArray,<cx>       ; free the original selector
        jmps    ra_really_done

ra_ra:  cCall   get_physical_address,<bx>
        cCall   set_physical_address,<oldhMem>
        cCall   get_arena_pointer,<hMem>
        INT3_ANCIENT
        cCall   AssociateSelector,<cx,es>
        push    ax

        mov     cx, numsels
        mov     ax, hMem
fsloop:
        cCall   free_sel,<ax>
        add     ax, 8
        loop    fsloop

        pop     es
        mov     ax,oldhMem
        mov     es:[ga_handle],ax
        cCall   AssociateSelector,<ax,es>

ra_really_done:
        pop     dx
        pop     cx
        pop     bx
        pop     ax

cEnd

;-----------------------------------------------------------------------;
; rashrink                                                              ;
;                                                                       ;
; Shrinks the given block                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       Here to shrink a block                                          ;
;       ES:0 = arena header of current block                            ;
;       DX   = new requested size of block                              ;
;       SI   = new requested size of block                              ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ALL but DS, DI                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       gsplice                                                         ;
;       gmarkfree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue 06-Feb-1990 01:03:54  -by-  David N. Weise  [davidw]             ;
; I got no clue what the history of this thing is, all I know is        ;
; that I got to fix it fast to prevent selector leak.                   ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   rashrink,<PUBLIC,NEAR>
cBegin nogen

        mov     bx,si
        xor     cx,cx
        REPT    4
        shl     bx,1
        rcl     cx,1
        ENDM
        mov     ax,es:[di].ga_handle
        or      ax,ax
        jz      ra_free

; !! the following was added Tue 06-Feb-1990 01:47:12
;  it doesn't belong here really but it is the only way to
;  prevent selector leak.

        push    bx
        push    cx
        push    si

        mov     si,ax
        cCall   GetAccessWord,<si>
        mov     bl, ah
        mov     ax, si
        and     bl, 0Fh                 ; Current hlimit
        inc     bl                      ; number of selectors there now
        mov     cx,dx

        add     cx, 0FFFh
        rcr     cx, 1                   ; 17 bitdom
        shr     cx, 11
        sub     bl, cl
        jbe     ignore_this_shi

        xor     bh,bh                   ; BX = number of selectors to free
        shl     cx,3
        .errnz  SIZE DscPtr - 8
        add     cx,si                   ; CX = selector to start to free
        xchg    bx,cx
@@:     cCall   free_sel,<bx>
        add     bx,SIZE DscPtr
        loop    @B

ignore_this_shi:
        pop     si
        pop     cx
        pop     bx

; end of shi

        Handle_To_Sel   al
        cCall   set_sel_limit,<ax>
ra_free:
        inc     dx                      ; Test for small shrinkage
        inc     dx
        .errnz  GA_ALIGN - 1

        cmp     dx,es:[di].ga_size      ; Enough room from for free block?
        ja      rashrunk                ; No, then no change to make

; !! why isn't the PreAllocSel done before the set_sel_limit?
; Because it belongs with the 'gsplice'.

        call    PreallocSel             ; Must be able to get selector
        jz      rashrunk
                                        ; Yes, ES:DI = cur block, SI=new block
        inc     si                      ; Include header in size of block
        call    gsplice                 ; splice new block into the arena
        mov     es,si                   ; ES:DI = new free block
        xor     si,si
        call    gmarkfree               ; Mark it as free
rashrunk:
        ret
cEnd nogen

;-----------------------------------------------------------------------;
; ragrow                                                                ;
;                                                                       ;
; Tries to grow the given global memory object in place                 ;
;                                                                       ;
; Arguments:                                                            ;
;       AX:0 = client address of current block                          ;
;       ES:0 = arena header of current block                            ;
;       BX:0 = arena header of next block                               ;
;       DX = SI = new requested size of block                           ;
;                                                                       ;
; Returns:                                                              ;
;       CY = 0          Success                                         ;
;                                                                       ;
;       CY = 1          Failed                                          ;
;               ES preserved                                            ;
;               DX contains free memory required                        ;
;                                                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ALL but DS, DI                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       is_there_theoretically_enough_space                             ;
;       can_we_clear_this_space                                         ;
;       gjoin                                                           ;
;       gzero                                                           ;
;       rashrink                                                        ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 05-Sep-1988 20:10:15  -by-  David N. Weise  [davidw]             ;
; Made ragrow be more intelligent by trying to extend into moveable     ;
; blocks.                                                               ;
;-----------------------------------------------------------------------;
cProc   ragrow,<PUBLIC,NEAR>
cBegin nogen

        push    si
        push    es                      ; Save current block address
        sub     dx, es:[di].ga_size     ; compute amount of free space wanted
        mov     es,bx                   ; ES = next block address
        mov     cx,[di].hi_count
        push    cx
        push    es
        call    is_there_theoretically_enough_space
        pop     es
        pop     cx
        cmp     ax,dx
        jb      ragx
        call    can_we_clear_this_space
        jz      ragx
        pop     cx                      ; clear the stack
        pop     si
        push    si
        call    gjoin                   ; and attach to end of current block
        pop     si                      ; (will free a selector)
        test    byte ptr rflags,GA_ZEROINIT ; Zero fill extension?
        jz      ranz                    ; No, continue

        mov     bx, dx                  ; number of paragraphs to fill
        mov     dx, si                  ; New size of block
        sub     dx, bx                  ; Old size of block
        inc     dx                      ; Paragraph offset of where to zero
        cCall   alloc_data_sel_above,<es,dx>
        push    bx
        push    ax                      ; set the limit really big
        push    es
        cCall   SetSelectorLimit,<ax,0Fh,0FFFFh>
        pop     es
        pop     ax
        pop     cx                      ; Number of paragraphs to zero
        mov     bx, ax                  ; Selector to fill
        call    gzero                   ; zero fill extension
        cCall   free_sel,<bx>
ranz:
        mov     dx, si
        mov     bx,es:[di].ga_next      ; Pick up new next block address
        call    rashrink                ; Now shrink block to correct size
        clc
        ret
ragx:
        pop     es                      ; Recover current block address
        pop     si
        stc
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gfree                                                                 ;
;                                                                       ;
; Frees a global object.                                                ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = global memory object handle                                ;
;       CX = owner field value to match or zero if dont care            ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;       CX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;       CX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ?                                                               ;
; Calls:                                                                ;
;       gdref                                                           ;
;       free_object                                                     ;
;       hfree                                                           ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 11:48:38a  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block and restructured.                      ;
;-----------------------------------------------------------------------;

cProc   gfree,<PUBLIC,NEAR>
cBegin  nogen

        push    cx
        call    pdref

        pop     dx
        jz      object_discarded
        call    free_object
        jmps    gfree_exit
object_discarded:

        cCall   AssociateSelector,<si,di>
        cCall   FreeSelArray,<si>
        xor     ax,ax                   ;!!! just for now force success

gfree_exit:
        mov     cx,ax
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; free_object                                                           ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = owner field value to match or zero if dont care            ;
;       DS:DI = address of global heap info                             ;
;       ES:DI = address of arena header                                 ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       glrudel                                                         ;
;       gmarkfree                                                       ;
;       hfree                                                           ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 02:59:06p  -by-  David N. Weise     [davidw]        ;
; Moved it from gfree.                                                  ;
;-----------------------------------------------------------------------;

cProc   free_object,<PUBLIC,NEAR>
cBegin  nogen
        or      dx,dx
        jz      free_it
        cmp     es:[di].ga_owner,dx
        je      free_it
        mov     ax,-1
        jmps    free_object_exit
free_it:
        call    glrudel         ; delete object from LRU chain
        xor     si,si
        call    gmarkfree       ; free the object
        cCall   AssociateSelector,<si,di>
        cCall   FreeSelArray,<si>
        xor     ax,ax                   ;!!! just for now force success
free_object_exit:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; free_handle                                                           ;
;                                                                       ;
; Frees the given handle.                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:SI = handle table entry address                              ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;       CX = AX                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ?                                                               ;
; Calls:                                                                ;
;       hfree                                                           ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 02:30:32p  -by-  David N. Weise     [davidw]        ;
; Moved it from gfree.                                                  ;
;-----------------------------------------------------------------------;

;cProc  free_handle,<PUBLIC,NEAR>
;cBegin nogen
;       xor     ax,ax
;       or      si,si
;       jz      free_handle_exit
;       push    bx
;       mov     bx,si
;       call    hfree
;       pop     bx
;free_handle_exit:
;       ret
;cEnd   nogen


;-----------------------------------------------------------------------;
; gfreeall                                                              ;
;                                                                       ;
; Frees all global objects that belong to the given owner.  It first    ;
; loops through the global heap freeing objects and then loops through  ;
; the handle table freeing handles of discarded objects.                ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = owner field value to match                                 ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX,ES,SI                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       free_object                                                     ;
;       henum                                                           ;
;       hfree                                                           ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 05:46:52p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gfreeall,<PUBLIC,NEAR>
cBegin  nogen

        mov     es,[di].hi_first        ; ES:DI points to first arena entry
        mov     cx,[di].hi_count        ; CX = #entries in the arena
free_all_objects:
        push    cx
        call    free_object             ; Free object if matches owner
        pop     cx
        mov     es,es:[di].ga_next      ; Move to next block
        loop    free_all_objects

; may go extra times, as CX does not track coalescing done by gfree,
;  but no big whoop


        push    ax
        push    bx
        push    di
        SetKernelDS es
        mov     si, SelTableStart
        mov     cx, SelTableLen
        shr     cx, 1
        mov     di, si
        smov    es, ds
        UnSetKernelDS es

free_all_handles_loop:
        mov     ax, dx
        repne scas      word ptr es:[di]        ; Isn't this easy?
        jne     short we_be_done
        lea     bx, [di-2]
        sub     bx, si
        shl     bx, 2
        or      bl, SEG_RING

if KDEBUG
        lsl     ax, bx
        cmp     ax, dx
        je      @F
        INT3_ANCIENT
@@:
endif

        cCall   GetAccessWord,<bx>
        test    al,DSC_PRESENT                  ; segment present?
        jnz     short free_all_handles_loop     ; yes, not a handle
        test    ah,DSC_DISCARDABLE              ; discardable?
        jz      short free_all_handles_loop     ; no, nothing to free
        cCall   free_sel,<bx>
        mov     word ptr [di-2], 0              ; Remove owner from table
        jcxz    we_be_done
        jmps    free_all_handles_loop
we_be_done:
        pop     di
        pop     bx
        pop     ax


gfreeall_done:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; glock                                                                 ;
;                                                                       ;
; Increment the lock count of an object in handle table entry           ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = handle to global object                                    ;
;       CH = handle table flags                                         ;
;       CL = lock count for moveable objects                            ;
;       DX = segment address of object                                  ;
;       DS:DI = address of master object                                ;
;       ES:DI = arena header                                            ;
;                                                                       ;
; Returns:                                                              ;
;       CX = updated lock count                                         ;
;       DX = pointer to client area                                     ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1 if count overflowed.                                     ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 05:38:57p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   glock,<PUBLIC,NEAR>
cBegin  nogen
        push    ax
        inc     ch                      ; Increment lock count
        jz      overflow                ; All done if overflow
        mov     es:[di].ga_count,ch     ; Update lock count
glockerror:
overflow:
        pop     ax
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; gunlock                                                               ;
;                                                                       ;
; Decrement the lock count of an object.                                ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = handle to global object                                    ;
;       CH = handle table flags                                         ;
;       CL = lock count for moveable objects                            ;
;       CX = handle table flags and lock count for moveable objects     ;
;       DS:DI = address of master object                                ;
;       ES:DI = arena header                                            ;
;                                                                       ;
; Returns:                                                              ;
;       CX = updated lock count, no underflow                           ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       glrutop                                                         ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 04:39:01p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gunlock,<PUBLIC,NEAR>
cBegin  nogen
        push    ax
        mov     ax,bx
        dec     ch                      ; Decrement usage count
        cmp     ch,0FFh-1               ; ff -> fe, 0 -> ff
        jae     count_zero              ; Return if pinned, or was already 0
        dec     es:[di].ga_count        ; Non-zero update lock count
        jnz     count_positive          ; All done if still non-zero
        test    cl,GA_DISCARDABLE       ; Is this a discardable handle?
        jz      count_zero              ; No, all done
        call    glrutop                 ; Yes, bring to top of LRU chain
count_zero:
        xor     cx,cx
count_positive:
        pop     ax
        ret
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2protect.asm ===
PAGE    ,132
        TITLE   Windows Protect Mode Routines

.list
include kernel.inc
include protect.inc
include pdb.inc
include newexe.inc
.list

        .286p

ifdef WOW

;
; the dpmi func  04f1h is idential to function 00h, except that
; the descriptor base and limit are not initialized to zero.
;

;
; the dpmi func 04f2h  is identical to 0ch except that it
; sets 'count' (in cx) LDTs at one time. The first selector is in
; register bx. The descriptor data is in gdtdsc[bx], gdtdsc[bx+8]
; etc. This data is shared between dpmi (dosx.exe) and us and thus
; need not be passed in es:di

WOW_DPMIFUNC_00 equ 04f1h
WOW_DPMIFUNC_0C equ 04f2h
endif

MovsDsc Macro           ;Move (copy) a descriptor (4 words)
        cld
        rept    4
        movsw
        endm
        endm

CheckDS Macro
        local   okDS
        push    ax
        mov     ax, ds
        cmp     ax, pGlobalHeap
        je      okDS
        int 3
okDS:
        pop     ax
        endm

CheckLDT Macro selector
if KDEBUG
        test    selector,SEL_LDT
        jnz     @F
        int 3
@@:
endif
        Endm

DPMICALL MACRO  callno
        mov     ax, callno
        call    DPMIProc
        ENDM

CHECKSEL MACRO  selector
        ENDM

extrn GlobalHandle:FAR
extrn GlobalRealloc:FAR
extrn GlobalFix:FAR
extrn GlobalUnFix:FAR
extrn IGlobalFix:FAR                    ;Far calls in this segment
extrn IGlobalFlags:FAR
IF KDEBUG
extrn GlobalHandleNorip:FAR
ELSE
extrn IGlobalHandle:FAR
ENDIF

DataBegin

ifdef WOW
externW SelectorFreeBlock
externW UserSelArray
endif

externW WinFlags

extrn   kr1dsc:WORD
extrn   kr2dsc:WORD
extrn   blotdsc:WORD
extrn   DemandLoadSel:WORD
extrn   temp_sel:WORD

externW MyCSSeg
externW selWoaPdb
externW cpLowHeap
externW selLowHeap
externW pGlobalHeap
externW SelTableLen

externW MyCSAlias

extrn   SelTableStart:DWORD
extrn   sel_alias_array:WORD

if ROM
externW selROMTOC
externW selROMLDT
externW sel1stAvail
endif

if ROM
externD lmaHiROM
externD cbHiROM
endif

globalD lpProc,0

DataEnd


DataBegin INIT

RModeCallStructure      STRUC
RMCS_DI                 dw      0
                        dw      0
RMCS_ESI                dd      0
RMCS_EBP                dd      0
RMCS_Res                dd      0
RMCS_EBX                dd      0
RMCS_EDX                dd      0
RMCS_ECX                dd      0
RMCS_EAX                dd      0
RMCS_Flags              dw      0
RMCS_ES                 dw      0
RMCS_DS                 dw      0
RMCS_FS                 dw      0
RMCS_GS                 dw      0
RMCS_IP                 dw      0
RMCS_CS                 dw      0
RMCS_SP                 dw      0
RMCS_SS                 dw      0
RModeCallStructure      ENDS

MyCallStruc     RModeCallStructure <>

public  MS_DOS_Name_String
MS_DOS_Name_String      db      "MS-DOS", 0

DataEnd INIT

sBegin  CODE

externW MyCSDS
externW gdtdsc
ifdef WOW
externD prevInt31proc
endif

sEnd    CODE

sBegin  INITCODE
assumes cs,CODE

;-----------------------------------------------------------------------;
; SwitchToPMODE                                                         ;
;                                                                       ;
; Entry:                                                                ;
;       In Real or Virtual Mode                                         ;
;       DS -> Data Segment                                              ;
;       ES -> PSP                                                       ;
;                                                                       ;
; Returns:                                                              ;
;       In Protect Mode                                                 ;
;       BX -> LDT selector                                              ;
;       SI -> Segment of start of available memory                      ;
;       ES -> PSP                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       Exits via DOS call 4Ch                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,DATA
        assumes es,nothing

ife ROM

cProc   SwitchToPMODE,<PUBLIC,NEAR>
cBegin nogen

        push    cx
        push    es                      ; Current PSP

        mov     ax, 1687h
        int     2Fh                     ; Get PMODE switch entry
        or      ax, ax                  ; Can we do it?
        jz      @F
NoPMODEj:
        jmp     NoPMODE
@@:
        xor     bh, bh                  ; Set CPU type now
        mov     bl,WF_CPU286
        cmp     cl, 2                   ; At least a 286?
        jb      NoPMODEj                ; No, Fail
        je      @F                      ; It is a 286?
        mov     bl,WF_CPU386
        cmp     cl,3                    ; No, 386?
        je      @F
        mov     bl,WF_CPU486            ; No, assume 486 for now
@@:
        mov     WinFlags, bx            ; Save away CPU type
        mov     word ptr [lpProc][0], di
        mov     word ptr [lpProc][2], es
        pop     ax                      ; PSP
        add     ax, 10h                 ; Skip the PSP
        mov     es, ax                  ; Give this to the DOS extender
        add     si, ax                  ; Start of memory available to us
        mov     selWoaPdb, si           ; PDB for WOA
        add     si, 10h                 ; Move start on another 256 bytes

        xor     ax, ax                  ; 16-bit app
        call    [lpProc]                ; Switch to PROTECTED mode
        jc      short NoPMODEj          ; No, still Real/Virtual mode

        mov     ax, cs
        and     al, 7                   ; LDT, Ring 3
        cmp     al, 7
        je      @F
        jmp     BadDPMI                 ; Insist on Ring 3!
@@:

        mov     bx, cs                  ; Allocate CS Alias
        DPMICALL 000Ah

        mov     MyCSAlias, ax           ; Save CS Alias in DS

        mov     bx, ds                  ; Use alias to update code seg var
        mov     ds, ax
        assumes ds, CODE

        mov     MyCSDS, bx              ; The DS selector

        mov     ds, bx
        ReSetKernelDS

        push    si                      ; Unlock all of our memory
        mov     bx, si                  ; Segment address of start of our memory
        mov     di, es:[PDB_block_len]  ; End of our memory
        sub     di, bx                  ; Size of our block in paragraphs
        mov     cpLowHeap, di           ; (MAY NEED INCREMENTING!!!)
        xor     si, si                  ; Calculate # bytes in SI:DI
        REPT 4
        shl     di, 1
        rcl     si, 1
        ENDM
        mov     cx, bx                  ; Convert start of block to linear
        xor     bx, bx                  ; address
        REPT 4
        shl     cx, 1
        rcl     bx, 1
        ENDM
        mov     ax, 0602h
        ;BUGBUGBUGBUG
        int     31h                     ; Mark region as pageable.

        pop     bx
        DPMICALL 0002h                  ; Convert start of memory to selector
        mov     si, ax
        mov     selLowHeap, ax          ; Save for WOA (MAY NEED PARA LESS!!!)

        mov     bx, selWoaPdb           ; Convert WOA PDB segment to selector
        DPMICALL 0002h
        mov     selWoaPdb, ax

        push    si
        push    es
        mov     ax, 168Ah               ; See if we have MS-DOS extensions
        mov     si, dataOffset MS_DOS_Name_String
        int     2Fh
        cmp     al, 8Ah
        je      short BadDPMI           ; No extensions, screwed

        mov     word ptr [lpProc][0], di  ; Save CallBack address
        mov     word ptr [lpProc][2], es

        mov     ax, 0100h               ; Get base of LDT
        call    [lpProc]
        jc      short NoLDTParty
ifndef WOW
        verw    ax                      ; Writeable?
else
        verr    ax                      ; for WOW we can use read access
endif
        jnz     short NoLDTParty        ;  nope, don't bother with it

        mov     es, MyCSAlias
        assumes es,CODE
        mov     gdtdsc, ax
        assumes es,nothing

NoLDTParty:                             ; Well, we'll just have to use DPMI!
        pop     es
        pop     si
        xor     bx, bx
        pop     cx
        ret

BadDPMI:
                ;
                ; Call real/virtual mode to whine
                ;
        xor     cx, cx                          ; Nothing on stack to copy
        xor     bh, bh                          ; Flags to DPMI
        mov     ax, MyCSSeg
        mov     MyCallStruc.RMCS_DS, ax         ; Real mode DS will be parent PDB
        mov     MyCallStruc.RMCS_ES, cx         ; Real mode ES will be 0
        mov     MyCallStruc.RMCS_CS, ax         ; Real mode CS
        mov     MyCallStruc.RMCS_IP, codeoffset RModeCode       ; Real mode IP

        smov    es, ds
        mov     di, dataoffset MyCallStruc      ; ES:DI points to call structure
        mov     ax, 0301h                       ; Call Real Mode Procedure
        int     31h
        jmps    GoodBye

RModeCode:
        mov     dx, codeoffset szInadequate
        mov     ah, 9
        int     21h
        retf

;szInadequate:
;       DB      'KRNL286: Inadequate DPMI Server',13,10,'$'
externB <szNoPMode, szInadequate>

NoPMODE:                                ; NOTE: stack trashed...
ifdef WOW
        ;** Put Up a Dialog Box If we fail to Enter Protect Mode
        ;** Prepare the dialog box
        push    cs                      ;In our DS
        push    codeOFFSET szNoPMode    ; -> unable to enter Prot Mode

        push    ds
externB <syserr>
        push    dataOffset syserr       ;Caption

        push    0                       ;No left button

        push    SEB_CLOSE + SEB_DEFBUTTON ;Button 1 style

        push    0                       ;No right button
externFP kSYSERRORBOX
	call	kSYSERRORBOX		 ;Put up the system error message
externNP ExitKernel
        jmp     ExitKernel

else    ; Not WOW

        mov     dx, codeoffset szNoPMode
;       call    complain
;       DB      'KRNL286: Unable to enter Protected Mode',7,7,7,13,10,'$'
;complain:
;       pop     dx
        push    cs
        pop     ds                      ; DS:DX -> error message
        mov     ah,9                    ; Print error message
        int     21h

endif ; WOW


GoodBye:
        mov     ax, 4CFFh
        int     21h
cEnd nogen

endif ;ROM

;-----------------------------------------------------------------------;
; LDT_Init                                                              ;
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   LDT_Init,<PUBLIC,NEAR>,<ax,bx,cx,di,es>
cBegin

        ReSetKernelDS
        mov     es, bx                  ; Selector for LDT if any

        push    es                      ; Get random selectors
        smov    es, ds
        ReSetKernelDS es
        assumes ds,nothing
        mov     cx, 1                   ; Argument to get_sel
        call    get_sel
        mov     kr1dsc, si
        call    get_sel
        mov     blotdsc, si
        call    get_sel
        or      si, SEG_RING
        mov     DemandLoadSel, si

        mov     ax, DSC_DATA+DSC_PRESENT; Get an array of 16 selectors
        cCall   alloc_sel,<0000h,0BADh,0FFFFh>  ; This covers 1Mb.
        mov     kr2dsc, ax
        smov    ds, es
        pop     es
        assumes es,nothing
cEnd

sEnd INITCODE

sBegin  CODE
assumes cs,CODE

;-----------------------------------------------------------------------;
; AllocSelector
;
;
; Entry:
;
; Returns:
;       AX = New selector
;          = 0  if out of selectors
;
; Registers Destroyed:
;
; History:
;  Thu 08-Dec-1988 14:17:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   AllocSelectorWOW,<PUBLIC,FAR>
        parmW   selector
cBegin
        ; same as allocselector but doesn't set the descriptor
        cCall   inner_alloc_selector,<selector,0ffffh>
cEnd

cProc   AllocSelector,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall   inner_alloc_selector,<selector,0>
cEnd


labelFP <PUBLIC, IAllocCStoDSAlias>

;-----------------------------------------------------------------------;
; AllocAlias
;
; This allocates a data alias for the passed in selector, which
; can be either code or data.  The alias will track segment
; motion.
;
; Entry:
;       parmW   selector        selector to get an alias for
;
; Returns:
;       AX = selector
;          = 0 failure
;
; Registers Destroyed:
;
; History:
;  Sat 20-Jan-1990 23:40:32  -by-  David N. Weise  [davidw]
; Cleaning up.
;
;  Fri 02-Dec-1988 11:04:58  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   AllocAlias,<FAR,PUBLIC>

        parmW   selector
cBegin
ifdef WOW
        push    bx      ; Whitewater tool ObjDraw needs this too
endif
        cCall   inner_alloc_selector,<selector,1>
        ; WhiteWater Resource Toolkit (shipped with Borland's Turbo
        ; Pascal) depends on dx being the data selector which was true
        ; in 3.0 but in 3.1 validation layer destroys it.
        mov     dx,selector
ifdef WOW
        pop     bx
endif
cEnd

;-----------------------------------------------------------------------;
; AllocDStoCSAlias
;
; This allocates a code alias for the passed in selector, which
; should be data.  The alias will track segment motion.  The
; passed in selector must be less than 64K.
;
; Entry:
;       parmW   selector        selector to get an alias for
;
; Returns:
;       AX = selector
;          = 0 failure
;
; Registers Destroyed:
;
; History:
;  Sat 20-Jan-1990 23:40:32  -by-  David N. Weise  [davidw]
; Cleaning up.
;
;  Fri 02-Dec-1988 11:04:58  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IAllocDStoCSAlias,<FAR,PUBLIC>, <cx,si,di>
        parmW   data_selector
cBegin
        ;** AllocDStoCSAlias has an interesting hack.  A fix was made to
        ;** not allow apps to GlobalAlloc fixed memory.  This was done
        ;** for performance reasons.  The only reason we can ascertain
        ;** for an app needing fixed GlobalAlloc'ed memory is in the case
        ;** of alias selectors.  We assume that all apps needing alias
        ;** selectors will use this function to make the alias.  So, if
        ;** we see a DStoCS alias being made, we make sure the DS is fixed.
        mov     ax, data_selector ;Get handle
        push    ax
IF KDEBUG
        call    GlobalHandleNorip       ;Make sure it's really a handle
ELSE
        call    IGlobalHandle           ;Make sure it's really a handle
ENDIF
        test    ax, 1                   ;Fixed blocks have low bit set
        jnz     ADCA_Already_Fixed      ;It's already a fixed block!

        ;** If the block is not fixed, it may be locked so we must check this.
        push    ax                      ;Save returned selector
        push    ax                      ;Use as parameter
        call    IGlobalFlags            ;Returns lock count if any
        or      al, al                  ;Non-zero lock count?
        pop     ax                      ;Get selector back
        jnz     ADCA_Already_Fixed      ;Yes, don't mess with it

        ;** Fix the memory.  Note that we're only doing this for 
        ;**     apps that are calling this on non-fixed or -locked memory.
        ;**     This will cause them to rip on the GlobalFree call to this
        ;**     memory, but at least it won't move on them!
        push    ax                      ;Fix it
        call    IGlobalFix
ADCA_Already_Fixed:

        cCall   inner_alloc_selector,<data_selector,2>
if ALIASES
        or      ax,ax
        jz      ada_nope
        mov     bx,data_selector
        call    add_alias
ada_nope:
endif
        smov    es,0

        ; WhiteWater Resource Toolkit (shipped with Borland's Turbo
        ; Pascal) depends on dx being the data selector which was
        ; true in 3.0 but in 3.1 validation layer destroys it.
        mov     dx,data_selector
cEnd

;-----------------------------------------------------------------------;
; inner_alloc_selector
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 20-Jan-1990 23:40:32  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   inner_alloc_selector,<PUBLIC,NEAR>,<di,si>

        parmW   selector
        parmW   sel_type
        localV  DscBuf,DSC_LEN
cBegin
        mov     cx, 1
        mov     di, selector
        and     di, not SEG_RING_MASK
        jnz     as1

        call    get_sel
        jnz     short as_exit           ; We got it
        jmps    as_exit1

as1:
        mov     bx, selector
        lea     di, DscBuf
        smov    es, ss

ifdef WOW
        DPMICALL 000Bh                  ; Get existing descriptor
else
        push    ds
        mov     ds, gdtdsc
        push    si                      ; Get Descriptor
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif
        mov     cl, DscBuf.dsc_hlimit
        and     cl, 0Fh
        inc     cl                      ; # selectors

        call    get_sel
        jz      short as_exit1
ifdef WOW
        cmp     sel_type, 0ffffh        ; called from AllocSelectorWOW ?
        jz      as_exit                 ; yes . dont set descriptor
endif
        cmp     sel_type,0              ; called from AllocSelector?
        jz      as_fill                 ;  done if so
        mov     al,DSC_PRESENT+DSC_DATA
        cmp     sel_type,1              ; called from AllocAlias?
        jz      @F
        or      al,DSC_CODE_BIT         ; called from AllocDStoCSAlias
@@:
        mov     DscBuf.dsc_access,al
as_fill:
        mov     bx, si
        or      bl, SEG_RING

        call    fill_in_selector_array

as_exit:
        or      si, SEG_RING
as_exit1:
        mov     ax,si
        smov    es, 0
cEnd


;-----------------------------------------------------------------------;
; get_sel                                                               ;
;                                                                       ;
; Entry:                                                                ;
;       CX = # of selectors required                                    ;
;                                                                       ;
; Returns:                                                              ;
;       SI = First Selector                                             ;
;       DS = LDT                                                        ;
;       ZF = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       SI = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   AllocSelectorArray,<PUBLIC,FAR>,<si>
        parmW   nSels
cBegin
        mov     cx, nSels
        call    get_sel
        mov     ax, si
        jz      asa_fail

        or      si, SEG_RING
        mov     bx, si
        mov     dx, cx
        mov     cx, DSC_DATA+DSC_PRESENT        ; Mark all as Data and Present
ifdef WOW
fill_in_access:
        DPMICALL 0009h
        lea     bx, [bx+DSC_LEN]
        dec     dx
        jnz     fill_in_access
else
        push    ds
        mov     ds, gdtdsc
        push    bx
        and     bl, not 7
fill_in_access:
        mov     word ptr ds:[bx].dsc_access, cx
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        lea     bx, [bx+DSC_LEN]
        dec     dx
        jnz     fill_in_access
        pop     bx
        pop     ds
endif; WOW
        mov     ax, si

asa_fail:
cEnd


cProc   get_sel,<PUBLIC,NEAR>
cBegin nogen
        call    SetKernelDSProc                 ; Must call procedure here
        ReSetKernelDS
        push    ax
        push    cx
        xor     ax, ax
        cmp     cx, 1                           ; One selector only?
        jne     gs_int31
        cmp     temp_sel, ax                    ; Have one waiting?
        je      gs_int31                        ;  no, get one
        xchg    temp_sel, ax                    ; Use the waiting selector
        jmps    gs_got_sel
gs_int31:
	DPMICALL 0000h
        CHECKSEL ax

gs_got_sel:
        mov     si, ax
        and     si, not SEG_RING_MASK

if KDEBUG
        jnz     got_sel
        push    es
        pusha
        kerror  0,<Out of selectors>
        popa
        pop     es
        jmps    gs_exit
got_sel:
endif

        mov     ax, si
        shr     ax, 2
        cmp     ax, SelTableLen         ; Make sure we can associate it
        jae     gs_free_sels

gs_exit:
        mov     ds, gdtdsc                      ; SIDE EFFECT...
        UnSetKernelDS
gs_exit_2:
        pop     cx
        pop     ax
        or      si, si
        ret

gs_free_sels:
        ReSetKernelDS
        cmp     SelTableLen, 0
        je      gs_exit                 ; Not set yet, so we are ok

        mov     ds, gdtdsc
        UnSetKernelDS
        push    bx
        mov     bx, si                  ; Could not associate, so free them
        xor     si, si
        or      bl, SEG_RING
as_free:
        DPMICALL 0001h
        lea     bx, [bx+DSC_LEN]
        loop    as_free
        pop     bx
        jmps    gs_exit_2

cEnd nogen


;-----------------------------------------------------------------------;
; FreeSelector                                                          ;
; free_sel                                                              ;
; FreeSelArray
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,CX,DX,DI,SI,DS,ES                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IFreeSelector,<FAR,PUBLIC>,<di,si>
        parmW   selector
cBegin
        CheckLDT selector
if ALIASES
        mov     ax,selector
        call    delete_alias
endif
        xor     ax, ax
        mov     es, ax                  ; GRRRRRRRR!
        cCall   FreeSelArray,<selector>
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   free_sel,<PUBLIC,NEAR>,<ax,bx>
        parmW   selector
cBegin
        pushf                           ; !! for the nonce
        mov     bx,selector             ;  must be careful in gcompact
                                        ;  to ignore error return
if KDEBUG
        or      bx, SEG_RING            ; Ensure Table bit correct
endif

        DPMICALL 0001h
        popf
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   FreeSelArray,<PUBLIC,NEAR>,<ax,bx,cx>
        parmW   selector
cBegin
        mov     bx,selector             ;  to ignore error return

        cCall   GetSelectorCount
        mov     cx, ax

fsa_loop:
        DPMICALL 0001h
        lea     bx, [bx+DSC_LEN]
        loop    fsa_loop                ; Any left to free
cEnd


;-----------------------------------------------------------------------;
; GrowSelArray                                                          ;
;                                                                       ;
; This is called from within grealloc.  The point is to grow the        ;
; number of contiguous selectors to tile the memory object.             ;
; If we can't get a contiguous set then we attempt to find a set        ;
; anywhere.                                                             ;
;                                                                       ;
; Entry:                                                                ;
;       ES => arena header                                              ;
;                                                                       ;
; Returns:                                                              ;
;       AX => new selector array                                        ;
;       CX => new number of selectors                                   ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,DX,DI,SI,DS,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GrowSelArray,<PUBLIC,NEAR>,<bx,si,di,ds>
        localV  DscBuf,DSC_LEN
        localW  oldCount
cBegin
        mov     bx, es:[ga_handle]
        mov     di, bx

        cCall   GetSelectorCount
        mov     word ptr oldCount, ax

        mov     cx, si                  ; New size
        dec     cx                      ; Paragraph limit
        shr     cx, 12
        inc     cx                      ; new # selectors
        cmp     al, cl                  ; Same # of selectors required?
        je      gsa_done                ;  yes, just return!

        call    get_sel                 ; get a new selector array
        jz      short gsa_nosels
        xchg    si, di                  ; DI now new array, SI old array

        push    es
        push    cx
        and     bx, SEG_RING_MASK       ; Ring bits
        or      bx, di                  ; New handle
        mov     cx, word ptr oldCount
        push    ds                      ; Copy Descriptor(s)
        push    si
        mov     es, gdtdsc
        mov     ds, gdtdsc
        and     si, not 7

        shl     cx, 2                   ; CX = 4 * Descriptors = words to copy
        rep     movsw

        pop     si
        pop     ds
ifdef WOW
        ; set the descriptors
        push    bx
        mov     cx, word ptr oldCount
        or      bx, SEG_RING_MASK       ; start selector
        DPMICALL WOW_DPMIFUNC_0C
        pop     bx
endif; WOW
        pop     cx
        pop     es

        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<si,0>
        mov     es:[ga_handle], bx
        cCall   AssociateSelector,<bx,es>
        jmps    gsa_done

gsa_nosels:
        xor     bx, bx                  ; Indicate failure
gsa_done:
        mov     ax, bx
        or      ax, ax                  ; Indicate success
gsa_ret:
cEnd


        assumes ds, nothing
        assumes es, nothing

cProc   PreallocSel,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        push    cx
        push    si
        mov     cx, 1
        call    get_sel
        call    SetKernelDSProc
        ReSetKernelDS
        mov     temp_sel, si
        or      si, si                  ; Set flags for caller
        pop     si
        pop     cx
        pop     ds
        UnSetKernelDS
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; alloc_sel                                                             ;
; alloc_data_sel
;                                                                       ;
; Entry:                                                                ;
;       parmD   Address         32 bit address                          ;
;       parmW   Limit           limit in paragraphs (limit of 1 meg)    ;
;       AX = flags              alloc_sel only                          ;
;                                                                       ;
; Returns:                                                              ;
;       AX = new selector                                               ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu 07-Apr-1988 21:33:27    -by-  David N. Weise   [davidw]          ;
; Added the GlobalNotify check.                                         ;
;                                                                       ;
;  Sun Feb 01, 1987 07:48:39p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;
        assumes ds, nothing
        assumes es, nothing

if ROM
public far_alloc_data_sel16
far_alloc_data_sel16 equ this far
endif

cProc   far_alloc_data_sel,<PUBLIC,FAR>
        parmD   Address
        parmW   Limit
cBegin
        cCall   alloc_data_sel,<Address,Limit>
cEnd

if ROM
public alloc_data_sel16
alloc_data_sel16 equ this near
endif

cProc   alloc_data_sel,<PUBLIC,NEAR>
;       parmD   Address
;       parmW   Limit
cBegin nogen
        mov     ax, DSC_DATA+DSC_PRESENT
        errn$   alloc_sel
cEnd nogen


cProc   alloc_sel,<PUBLIC,NEAR>,<bx,cx,dx,si,di,ds,es>
        parmD   Address
        parmW   Limit
        localV  DscBuf,DSC_LEN
cBegin
        mov     cx, 1
        test    al, DSC_PRESENT
        jz      as_oneonly

        mov     cx, Limit               ; Calculate how many selectors required
        add     cx, 0FFFh
        rcr     cx, 1                   ; 17 bitdom
        shr     cx, 11

as_oneonly:
        call    get_sel
        jz      short a_s_exit

        mov     bx, si                  ; Selector in bx for DPMI
        or      bl, SEL_LDT
        lea     di, DscBuf
        smov    es, ss                  ; es:di points to descriptor buffer
        push    ax                      ; Save access word

        mov     ax, Address.lo          ; Set descriptor base
        mov     DscBuf.dsc_lbase, ax
        mov     ax, Address.hi
        mov     DscBuf.dsc_mbase, al
        mov     DscBuf.dsc_hbase, ah

        pop     ax                      ; Access word
        test    al, DSC_PRESENT         ; If selector not present, limit is
        jnz     short set_everything    ; as passed, not a paragraph count

        mov     word ptr DscBuf.dsc_access, ax
        mov     ax, word ptr Limit
        mov     DscBuf.dsc_limit, ax
ifdef WOW
        DPMICALL 000Ch                  ; Fill in our stuff in the descriptor
else
        push    ds
        push    bx                      ; Set Descriptor
        mov     ds, gdtdsc
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif; WOW
        jmps    as_done

set_everything:
        dec     cl
        and     ah, not 0Fh             ; Zero limit 19:16
        or      ah, cl                  ; Fill in limit 19:16
        inc     cl
        mov     word ptr DscBuf.dsc_access, ax
        mov     ax, Limit
        shl     ax, 4                   ; Convert paragraphs to byte limit
        dec     ax
        mov     DscBuf.dsc_limit, ax

        call    fill_in_selector_array

as_done:
        or      si, SEG_RING
a_s_exit:
        mov     ax, si
cEnd


;-----------------------------------------------------------------------;
; fill_in_selector_array                                                ;
;                                                                       ;
; Entry:                                                                ;
;       AX      = size of object in paragraphs                          ;
;       DH      = Discard bit for descriptors                           ;
;       DL      = Access bits                                           ;
;       CX:BX   = 32 bit base address of object                         ;
;       SI      = index into LDT                                        ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       SI, DI, DS, ES                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,BX,CX,DX                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   fill_in_selector_array,<PUBLIC,NEAR>
cBegin  nogen
        CheckLDT bl

        push    ds
        push    es:[di].dsc_limit               ; Save limit for last selector
        SetKernelDS
        test    WinFlags, WF_CPU286             ; protect mode on a 286?
        jz      next_sel
        mov     es:[di].dsc_limit, 0FFFFh       ; Others get 64k limit on 286

next_sel:
        cmp     cx, 1                           ; Last selector?
        jne     fsa_not_last
        pop     es:[di].dsc_limit               ;  yes, get its limit
fsa_not_last:
        DPMICALL 000Ch                          ; Set this descriptor
        lea     bx, [bx+DSC_LEN]                ; On to next selector
        add     es:[di].dsc_mbase, 1            ; Add 64kb to address
        adc     es:[di].dsc_hbase, 0
        dec     es:[di].dsc_hlimit              ; subtract 64kb from limit
        loop    next_sel

        pop     ds
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; GetSelectorBase
; get_physical_address
;
;
; Entry:
;
; Returns:
;       DX:AX   32 bit physical address
; Registers Destroyed:
;       none
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetSelectorBase,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall   get_physical_address,<selector>
cEnd

cProc   get_physical_address,<PUBLIC,NEAR>
        parmW   selector
cBegin
        push    bx
        push    cx
        mov     bx, selector
        CheckLDT bl
ifdef WOWJUNK
        DPMICALL 0006h
        mov     ax, dx
        mov     dx, cx
else
	push	ds			; Get Segment Base Address
        mov     ds, gdtdsc
        and     bl, not 7
        mov     ax, ds:[bx].dsc_lbase
        mov     dl, ds:[bx].dsc_mbase
        mov     dh, ds:[bx].dsc_hbase
        pop     ds
endif; WOW
        pop     cx
        pop     bx
cEnd

;-----------------------------------------------------------------------;
; set_physical_address
;
;
; Entry:
;       DX:AX  32 bit physical address
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_physical_address,<PUBLIC,NEAR>,<ax,bx,cx,dx>
        parmW   selector
cBegin
        CheckLDT selector

        push    di

        push    ax                      ; save low bits of address
        mov     bx, selector
        call    GetSelectorCount
        mov     di, ax
        mov     cx, dx                  ; CX:DX has new address
        pop     dx

set_bases:
        DPMICALL 0007h                  ; Set selector base
        lea     bx, [bx+DSC_LEN]        ; On to next selector
        inc     cx                      ; Add 64k to base
        dec     di
        jnz     set_bases

        pop     di

cEnd


;-----------------------------------------------------------------------;
; get_selector_length16
;
;
; Entry:
;
; Returns:
;       AX      16 bit segment length
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_selector_length16,<PUBLIC,NEAR>
        parmW   selector
cBegin
        mov     ax, -1
        lsl     ax, selector
        inc     ax                      ; length is one bigger!
cEnd


;-----------------------------------------------------------------------;
; set_sel_limit
;       SIDE EFFECT: descriptor bases and access are set based
;                    on the first in the array
;
; Entry:
;       CX:BX = length of segment
; Returns:
;
; Registers Destroyed:
;       CX
;
; History:
;  Fri 15-Jul-1988 19:41:44  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_sel_limit,<PUBLIC,NEAR>,<ax,bx,dx>
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin

        push    es
        push    di

        push    bx                      ; Get existing descriptor
        smov    es, ss
        lea     di, DscBuf
        mov     bx, selector
        CheckLDT bl
ifdef WOW
        DPMICALL 000Bh
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif; WOW
        pop     bx

        mov     dx, word ptr [DscBuf.dsc_access]
        and     dh, 0F0h                ; Zap old hlimit bits

        sub     bx, 1                   ; Turn length into linit
        sbb     cx, 0
        and     cx, 0Fh                 ; Get bits 19:16 of new limit
        or      dh, cl                  ; Set new hlimit bits

        mov     word ptr DscBuf.dsc_access, dx
        mov     DscBuf.dsc_limit, bx
        mov     bx, Selector

        jcxz    ssl_set_limit1          ; Only one, fast out

        inc     cx                      ; Turn CX into selector count
        call    fill_in_selector_array
        jmps    ssl_done

ssl_set_limit1:                                 ; Fast out for one only
ifdef WOW
        DPMICALL 000Ch
else
        push    ds
        push    bx                      ; Set Descriptor
        mov     ds, gdtdsc
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif; WOW
ssl_done:
        pop     di
        pop     es

        smov    ss,ss                           ; It might be SS we're changing
cEnd


;-----------------------------------------------------------------------;
; mark_sel_NP
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Fri 15-Jul-1988 21:37:22  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   mark_sel_NP,<PUBLIC,NEAR>
        parmW   selector
        parmW   owner
        localV  DscBuf,DSC_LEN
cBegin
        push    es
        push    ax
        push    bx
        push    di
ifdef WOW
        lea     di, DscBuf
        smov    es, ss
        mov     bx, selector
        DPMICALL 000Bh
        and     DscBuf.dsc_access, not DSC_PRESENT
        or      DscBuf.dsc_hlimit, DSC_DISCARDABLE
        mov     ax, owner
        mov     DscBuf.dsc_owner, ax
        DPMICALL 000Ch
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        mov     bx, selector
        and     bl, not 7
        and     [bx].dsc_access, not DSC_PRESENT
        or      [bx].dsc_hlimit, DSC_DISCARDABLE
        mov     ax, owner
        mov     [bx].dsc_owner, ax
        pop     ds
endif; WOW
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<bx,owner>
        pop     di
        pop     bx
        pop     ax
        pop     es
cEnd


;-----------------------------------------------------------------------;
; mark_sel_PRESENT
;
; This little routine is called from grealloc, specifically
; racreate.
;
; Entry:
;       parmW   arena_sel
;       parmW   selector
;
; Returns:
;       SI = selector to client area (may have changed)
;
; Registers Destroyed:
;
; History:
;  Tue 06-Feb-1990 00:29:56  -by-  David N. Weise  [davidw]
; Cleaning up tony's int 1's way too late.
;
;  Fri 15-Jul-1988 21:37:22  -by-  David N. Weise  [davidw]
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   mark_sel_PRESENT,<PUBLIC,NEAR>,<ax,bx,cx,dx,di,ds>
        parmW   arena_sel
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin
        push    es
        smov    es, ss
        lea     di, DscBuf              ; ES:DI -> descriptor buffer
        mov     bx, selector
ifdef WOW
        DPMICALL 000Bh                  ; Get old descriptor
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif; WOW
        or      DscBuf.dsc_access, DSC_PRESENT

        mov     ds, arena_sel
        mov     bl, DscBuf.dsc_hlimit
        and     bl, 0Fh                 ; Current number of selectors - 1
        inc     bl
        mov     ax, ds:[ga_size]
        mov     cx, ax
        dec     cx
        shr     cx, 12                  ; New number of selectors - 1
        inc     cl
        sub     bl, cl
        jz      go_ahead                ; Same number, just fill in array
        jb      get_big                 ; More, must get more

; here to get small

        and     DscBuf.dsc_hlimit, NOT 0Fh
        dec     cl
        or      DscBuf.dsc_hlimit, cl   ; Put new number of selectors in limit
        inc     cl
        push    cx
        xor     bh,bh                   ; BX = number of selectors to free
        shl     cx,3
        .errnz  DSC_LEN - 8
        add     cx,selector             ; CX = selector to start to free
        xchg    bx,cx
@@:     cCall   free_sel,<bx>
        lea     bx, [bx+DSC_LEN]
        loop    @B
        pop     cx
        jmps    go_ahead                ; And fill in remaining selectors

get_big:
        push    ax                      ; # paragraphs
        mov     bx, ds
        DPMICALL 0006h                  ; Get base address of arena
        add     dx, 10h                 ; Move on to block
        adc     cx, 0
        pop     bx                      ; # paragraphs
        mov     ax, word ptr DscBuf.dsc_access  ; Access bits in ax
        cCall   alloc_sel,<cx,dx,bx>
        mov     si, ax
        or      ax,ax                   ; did we get a set?
        jz      return_new_handle
        or      si, SEG_RING
        test    selector, IS_SELECTOR
        jnz     @F
        StoH    si
        HtoS    selector
@@:
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<selector,0>
        cCall   FreeSelArray,<selector> ; Zap old handle
        jmps    return_new_handle

go_ahead:
        shl     ax, 4                   ; AX had length in paras
        dec     ax                      ; now limit in bytes
        mov     DscBuf.dsc_limit, ax    ; Put in descriptor
        push    cx
        mov     bx, ds
        DPMICALL 0006h                  ; Get base address of arena
        add     dx, 10h                 ; Move on to block
        adc     cx, 0
        mov     DscBuf.dsc_lbase, dx
        mov     DscBuf.dsc_mbase, cl
        mov     DscBuf.dsc_hbase, ch
        pop     cx                      ; # selectors
        mov     bx, selector

        call    fill_in_selector_array
        mov     si, selector            ; return old selector in SI
return_new_handle:
        pop     es
cEnd

;-----------------------------------------------------------------------;
; alloc_data_sel_below
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 19:10:14  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   alloc_data_sel_below,<PUBLIC,NEAR>,<bx,cx,dx>
        parmW   selector
        parmW   paras
cBegin
        mov     bx, paras
        xor     cx, cx
rept 4
        shl     bx, 1
        rcl     cx, 1
endm
        cCall   get_physical_address,<selector>
        sub     ax, bx
        sbb     dx, cx
        cCall   alloc_data_sel,<dx, ax, 1>
cEnd

;-----------------------------------------------------------------------;
; alloc_data_sel_above
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 19:10:14  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   alloc_data_sel_above,<PUBLIC,NEAR>,<bx,cx,dx>
        parmW   selector
        parmW   paras
cBegin
        mov     bx, paras
        xor     cx, cx
rept 4
        shl     bx, 1
        rcl     cx, 1
endm
        cCall   get_physical_address,<selector>
        add     ax, bx
        adc     dx, cx
        cCall   alloc_data_sel,<dx, ax, 1>
cEnd


;-----------------------------------------------------------------------;
; cmp_sel_address
;
;       Compares the physical addresses corresponding to two selectors
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 19:10:14  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   cmp_sel_address,<PUBLIC,NEAR>,<ax,bx,cx,dx>
        parmW   sel1
        parmW   sel2
cBegin
        cCall   get_physical_address,<sel1>
        mov     cx, dx
        mov     bx, ax
        cCall   get_physical_address,<sel2>
        cmp     cx, dx
        jne     csa_done
        cmp     bx, ax
csa_done:
cEnd


;-----------------------------------------------------------------------;
; get_arena_pointer
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 20:11:27  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   far_get_arena_pointer,<FAR,PUBLIC>
        parmW   selector
cBegin
        cCall   get_arena_pointer,<selector>
cEnd

cProc   get_arena_pointer,<PUBLIC,NEAR>
        parmW   selector
cBegin
        push    bx
        push    ds
        push    es

        mov     bx, selector
        cCall   get_selector_association
        ReSetKernelDS es

if ROM
        test    al,1                    ; If the low bit isn't set
        jnz     @f                      ;   then it's either 0 or the
        xor     ax,ax                   ;   special ROM owner selector
        jmps    gap_exit                ;   (see Get/SetROMOwner)
@@:
endif

if KDEBUG
        or      ax, ax
        jz      gap_exit
        mov     ds, ax                  ; Sanity checks:

        cmp     ds:[ne_magic], NEMAGIC
        je      gap_exit
        cmp     ds:[0], 020CDh          ; PSP - not a very good check,
        je      gap_exit                ;       but OK for DEBUG
        push    si
        mov     si, ds:[ga_handle]      ; Make sure handle matches
        sel_check si
        or      si, si
        jz      short gap_match         ; Boot time...
        sub     bx, word ptr SelTableStart
        shl     bx, 2
        cmp     bx, si
        je      short gap_match
        xor     ax, ax                  ; put back in 5 feb 90, alias avoided
;;;     xor     ax, ax                  ; Removed - may be an alias!
gap_match:
        pop     si
endif ; KDEBUG
gap_exit:
        pop     es
        pop     ds
        pop     bx
cEnd


;-----------------------------------------------------------------------;
; AssociateSelector
;
;  Put the arena pointer or owner in the selector table slot
; corresponding to the given selector.
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;       flags
;
; History:
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FarAssociateSelector,<PUBLIC,FAR>
        parmW   Selector
        parmW   ArenaSel
cBegin
        cCall   AssociateSelector,<Selector,ArenaSel>
cEnd

cProc   AssociateSelector,<PUBLIC,NEAR>,<ax,bx,es>
        parmW   selector
        parmW   ArenaSel
cBegin
        SetKernelDS es

        CheckDS                         ; DS must bp pGlobalHeap
        mov     bx, selector
        and     bl, NOT SEG_RING_MASK
        shr     bx, 2                   ; 2 bytes per selector: divide by 4
if KDEBUG
        cmp     bx, SelTableLen         ; More sanity
        jb      @F
        INT3_WARN
        jmps    bad
@@:
endif

        add     bx, word ptr SelTableStart
        mov     ax, ArenaSel

if KDEBUG
        or      ax, ax                  ; Zero means deleting entry
        jz      okay
        CheckLDT al                     ; Ensure we won't GP fault later
okay:
endif

        mov     ds:[bx], ax             ; Finally fill in table entry
bad:
cEnd


;-----------------------------------------------------------------------;
; get_selector_association
;
; Returns the arena pointer or owner field from the selector table that
; was set by AssociateSelector.
;
;
; Entry:
;       BX = selector to get associated arena pointer/owner
;
; Returns:
;       AX = arena pointer/owner or 0
;       DS = pGlobalHeap
;       ES = Kernel DS
;
; Registers Destroyed:
;       BX, flags
;
; History:
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_selector_association,<PUBLIC,NEAR>
cBegin  nogen

        SetKernelDS es
        mov     ds, pGlobalHeap

        and     bl, NOT SEG_RING_MASK
        shr     bx, 2                   ; 2 bytes per selector: divide by 4

if ROM  ;-------------------------------

        cmp     bx, SelTableLen         ; Selector in range?  Make this check
        jb      gsa_in_range            ;   even if not debug kernel.
        xor     ax,ax                   ; No, just fail
        jmps    gsa_exit
gsa_in_range:

else ;ROM       ------------------------

if KDEBUG
        cmp     bx, SelTableLen         ; Selector in range?
        jb      @F
        INT3_WARN
        xor     ax, ax                  ; No, just fail
        jmps    gsa_exit
@@:
endif
endif ;ROM      ------------------------

        add     bx, word ptr SelTableStart
        mov     ax, ds:[bx]             ; Get associated value

gsa_exit:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; pdref                                                                 ;
;                                                                       ;
; Dereferences the given global handle, i.e. gives back abs. address.   ;
;                                                                       ;
; Arguments:                                                            ;
;       DX    = selector                                                ;
;       DS:DI = BURGERMASTER                                            ;
;                                                                       ;
; Returns:                                                              ;
;       ES:DI = address of arena header                                 ;
;       AX = address of client data                                     ;
;       CH = lock count or 0 for fixed objects                          ;
;       CL = flags                                                      ;
;       SI = handle, 0 for fixed objects                                ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1 if invalid or discarded                                  ;
;       AX = 0                                                          ;
;       BX = owner of discarded object                                  ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       ghdref                                                          ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   pdref,<PUBLIC,NEAR>

cBegin nogen
        mov     si, dx
        sel_check si

        or      si, si                  ; Null handle?
        mov     ax, si
        jz      pd_exit                 ; yes, return 0

        cCall   GetAccessWord,<dx>      ; Get the access bits
        or      ax, ax
        jz      pd_totally_bogus

; We should beef up the check for a valid discarded sel.

        xor     cx,cx
        test    ah, DSC_DISCARDABLE
        jz      pd_not_discardable
        or      cl,GA_DISCARDABLE
                                                ; Discardable, is it code?
        test    al,DSC_CODE_BIT
        jz      pd_not_code
        or      cl,GA_DISCCODE
pd_not_code:

pd_not_discardable:
        test    al,DSC_PRESENT
        jnz     pd_not_discarded

; object discarded

        or      cl,HE_DISCARDED
ife RING-1
        or      si, SEG_RING+1                  ; Handles are RING 2
else
        or      si, SEG_RING-1                  ; Handles are RING 2
endif
        cCall   get_arena_pointer,<si>          ; get the owner
        mov     bx, ax
        xor     ax,ax
        jmps    pd_exit

pd_not_discarded:
if KDEBUG
        or      si, SEG_RING                    ; For the sel_check later
endif
        cCall   get_arena_pointer,<si>
        or      ax, ax
        jz      pd_nomatch
        mov     es, ax
        mov     ax, es:[ga_handle]              ; The real thing
        mov     si, ax
        cmp     ax, dx                          ; Quick check - handle in header
        je      pd_match                        ; matches what we were given?

        test    dl, IS_SELECTOR                 ; NOW, we MUST have been given
        jz      pd_totally_bogus                ; a selector!!
        test    al, GA_FIXED                    ; Fixed segment?
        jnz     pd_nomatch                      ; Doesn't match arena header...
        push    ax
        HtoS    al
        cmp     ax, dx                          ; Selector must match
        pop     ax
        jne     pd_nomatch
pd_match:
        or      cl, es:[ga_flags]
        and     cl, NOT HE_DISCARDED            ; same as GA_NOTIFY!!
        test    al, GA_FIXED
        jnz     pd_fixed
        mov     ch, es:[ga_count]
        HtoS    al                              ; Back to ring 1

pd_exit:
        or      ax,ax
        ret

pd_totally_bogus:
if KDEBUG
        or      dx,dx
        jnz     dref_invalid
pd_null_passed:
endif
        xor     dx,dx

pd_nomatch:                                     ; Handle did not match...
        mov     ax, dx                          ; Must be an alias...
pd_fixed:
        xor     si, si
        xor     dx, dx
        jmps    pd_exit

if KDEBUG
dref_invalid:
        push    ax
        kerror  ERR_GMEMHANDLE,<gdref: invalid handle>,0,dx
        pop     ax
        jmps    pd_null_passed
endif
cEnd nogen


;-----------------------------------------------------------------------;
; get_rover_2                                                           ;
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_rover_2,<PUBLIC,NEAR>,<ax,bx,di>
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, es
        lea     di, DscBuf
        smov    es, ss
ifdef WOW
        DPMICALL 000Bh                  ; Get source descriptor
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif; WOW
        SetKernelDS es
        mov     bx, kr2dsc              ; Will set kr2 to point there
        or      bl, SEG_RING
        mov     word ptr DscBuf.dsc_access, DSC_PRESENT+DSC_DATA
        mov     DscBuf.dsc_limit, 0FFFFh
        smov    es, ss
        UnSetKernelDS es
ifdef WOW
        DPMICALL 000Ch
else
        push    ds
        mov     ds, gdtdsc
        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif; WOW
        mov     es, bx
cEnd


;-----------------------------------------------------------------------;
; get_blotto
;
;
; Entry:
;       AX = arena header
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 31-Jul-1988 16:20:53  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_blotto,<PUBLIC,NEAR>,<bx,di,es>
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, ax
        lea     di, DscBuf
        smov    es, ss
ifdef WOW
        DPMICALL 000Bh                  ; Get source descriptor
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif
        SetKernelDS es
        mov     bx, blotdsc             ; Will set kr2 to point there
        or      bl, SEG_RING
        mov     word ptr DscBuf.dsc_access, DSC_PRESENT+DSC_DATA
        mov     DscBuf.dsc_limit, 0FFFFh
        mov     DscBuf.dsc_hlimit, 0Fh
        add     DscBuf.dsc_lbase, 10h   ; Move on to object from arena
        adc     DscBuf.dsc_mbase, 0
        adc     DscBuf.dsc_hbase, 0
        smov    es, ss
        UnSetKernelDS es
ifdef WOW
        DPMICALL 000Ch                  ; Set new descriptor
else
        push    ds
        mov     ds, gdtdsc
        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif ;WOW
        mov     ax, bx                  ; Return new selector
cEnd


;-----------------------------------------------------------------------;
; get_temp_sel
; far_get_temp_sel
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 08-Aug-1988 19:14:45  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   far_get_temp_sel,<FAR,PUBLIC>
cBegin nogen
        cCall   get_temp_sel
        ret
cEnd nogen

cProc   get_temp_sel,<PUBLIC,NEAR>,<ax,bx,cx,di,si,ds>
        localV  DscBuf,DSC_LEN
cBegin
        mov     cx, 1
	call	get_sel
        mov     ax, si
        jz      gts_exit

        mov     bx, es
        smov    es, ss
        lea     di, DscBuf
ifdef WOW
        DPMICALL 000Bh                  ; Get existing descriptor
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif ; WOW

        mov     DscBuf.dsc_access,DSC_PRESENT+DSC_DATA
        mov     DscBuf.dsc_limit,0ffffh
IFNDEF WOW
        or      DscBuf.dsc_hlimit, 0Fh  ; Max length ; bugbug daveh
ENDIF
        mov     bx, si
        or      bl, SEG_RING
ifdef WOW
        DPMICALL 000Ch                  ; Set new descriptor
else
        push    ds
        mov     ds, gdtdsc
        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif ; WOW
        mov     es, bx                  ; and return selector in ES
gts_exit:
cEnd

cProc   far_free_temp_sel,<FAR,PUBLIC>
        parmW   selector
cBegin
        cCall   free_sel,<selector>
cEnd

;-----------------------------------------------------------------------;
; PrestoChangoSel
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 08-Dec-1988 14:17:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IPrestoChangoSelector,<PUBLIC,FAR>,<di,si>
        parmW   sourcesel
        parmW   destsel
        localV  DscBuf,DSC_LEN
cBegin
        smov    es, ss
        lea     di, DscBuf
        mov     bx, sourcesel
ifdef WOW
        DPMICALL 000Bh
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif ; WOW
        xor     DscBuf.dsc_access, DSC_CODE_BIT
        mov     bx, destsel
ifdef WOW
        DPMICALL 000Ch
else
        push    ds
        mov     ds, gdtdsc
        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
endif; WOW
        mov     ax, bx
        smov    es, 0
cEnd


if 0
;-----------------------------------------------------------------------;
; pmnum                                                                 ;
;                                                                       ;
; Enumerates the allocated selectors in the GDT with the                ;
; specified discard level.                                              ;
;                                                                       ;
; Arguments:                                                            ;
;       SI = zero first time called.  Otherwise contains a pointer      ;
;            to the last handle returned.                               ;
;       CX = #handles remaining.  Zero first time called.               ;
;       DI = address of local arena information structure.              ;
;                                                                       ;
; Returns:                                                              ;
;       SI = address of handle table entry                              ;
;       CX = #handles remaining, including the one returned.            ;
;       ZF = 1 if SI = 0 and no more handle table entries.              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Oct 14, 1986 04:19:15p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   pmnum,<PUBLIC,NEAR>
cBegin nogen
        or      si,si               ; Beginning of enumeration?
        jnz     lcdhenext           ; No, return next handle
        mov     ax,[di].hi_htable   ; Yes, start with last handle table block

lcdhtloop:
        mov     si,ax               ; SI = address of handle table block
        or      si,si               ; Any more handle table blocks?
        jz      lcdheall            ; No, return zero
        lodsw                       ; Get # handles in this block
        errnz   ht_count
        mov     cx,ax               ; into CX
lcdheloop:                          ; Loop to process each handle table entry
        mov     ax,word ptr [si].lhe_flags
        errnz   <lhe_flags - he_flags>
        errnz   <2-lhe_flags>
        errnz   <3-lhe_count>

        inc     ax                  ; Free handle?
        jz      lcdhenext           ; Yes, skip this handle
        errnz   <LHE_FREEHANDLE - 0FFFFh>
        errnz   <LHE_FREEHANDLE - HE_FREEHANDLE >
        dec     ax

        cmp     [di].hi_dislevel,0  ; Enumerating all allocated handles?
        je      lcdheall            ; Yes, return this handle

        test    al,LHE_DISCARDED    ; No, handle already discarded?
        jnz     lcdhenext           ; Yes, skip this handle

        and     al,LHE_DISCARDABLE  ; Test if DISCARDABLE
        cmp     [di].hi_dislevel,al ; at the current discard level
        jne     lcdhenext           ; No, skip this handle

        or      ah,ah               ; Is handle locked?
        jnz     lcdhenext           ; Yes, skip this handle

lcdheall:
        or      si,si               ; No, then return handle to caller
        ret                         ; with Z flag clear

lcdhenext:
        lea     si,[si].SIZE LocalHandleEntry    ; Point to next handle table entry
        errnz   <LocalHandleEntry - HandleEntry>
        loop    lcdheloop           ; Process next handle table entry
        lodsw                       ; end of this block, go to next
        jmp     lcdhtloop
cEnd nogen
endif


;-----------------------------------------------------------------------;
; LongPtrAdd
;
; Performs segment arithmetic on a long pointer and a DWORD offset
; The resulting pointer is normalized to a paragraph boundary.
; The offset cannot be greater than a megabyte.
;
; Entry:
;
; Returns:
;       DX:AX new segment:offset
;
; Error returns:
;       DX:AX = 0
;
; Registers Destroyed:
;       BX,CX
;
; History:
;  Mon 19-Dec-1988 18:37:23  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifdef WOW

LPTRADDWOW_SETBASE equ 01h

;cProc	LongPtrAddWOW,<PUBLIC,FAR>,<si,di>
;	parmD	long_ptr
;	parmD	delta
;       parmW   RefSelector
;       parmW   flBaseSetting
;
;  effectively pops RefSelector and flBaseSetting  into dx and ax.
;  and jumps to longptrAddWorker.
;
;  RefSelector is used only if the descriptor needs to be set.
;

labelFP <PUBLIC,LongPtrAddWOW>
       pop ax
       pop dx           ; far return address
       mov bx,sp
       xchg ax, ss:[bx]    ; replace the 'dword' with the return address
       xchg dx, ss:[bx+2]
       jmps LongPtrAddWorker ; ax = flags; dx = reference selector

labelFP <PUBLIC,LongPtrAdd>
     mov ax, LPTRADDWOW_SETBASE
     xor dx, dx
     ; fall through

cProc	LongPtrAddWorker,<PUBLIC,FAR>,<si,di>
	parmD	long_ptr
	parmD	delta
	localV	DscBuf,DSC_LEN
        localW  flBaseSetting
        localW  RefSelector
cBegin
        mov     flBaseSetting, ax         ; save in localvariables
        mov     RefSelector, dx
        or      dx, dx                    ; if RefSelector is nonzero
        jz      @F                        ; use it for querying descriptor info.
        xchg    dx, word ptr long_ptr[2]  ; and store the selector to be set in
        mov     RefSelector, dx           ; the localvariable
@@:
else

cProc	LongPtrAdd,<PUBLIC,FAR>,<si,di>
	parmD	long_ptr
	parmD	delta
	localV	DscBuf,DSC_LEN
cBegin

endif
        mov     bx,word ptr long_ptr[2]
        lea     di, DscBuf
        smov    es, ss
ifdef WOW
        DPMICALL 000Bh                  ; Pick up old descriptor
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
endif ; WOW
        mov     ax,word ptr long_ptr[0] ; get the pointer into SI:AX
        and     ax,0FFF0h

        mov     si, DscBuf.dsc_lbase    ; DX:SI gets old base
        mov     dl, DscBuf.dsc_mbase
        mov     dh, DscBuf.dsc_hbase

        add     si, ax                  ; Add in old pointer offset
        adc     dx, 0

        mov     cx, word ptr delta[2]   ; add the segment and MSW
        test    cx, 0FFF0h
ifdef WOW
        jz      @F
        test    flBaseSetting, LPTRADDWOW_SETBASE
        jnz     lptr_mustset
        jmp     short lpa_too_big
@@:
else
	jnz	short lpa_too_big
endif

        add     si, word ptr delta[0]
        adc     dx, cx

ifdef WOW
lptr_mustset:
endif

        mov     cl, DscBuf.dsc_hlimit   ; Calculate # selectors now in array
        and     cl, 0Fh
        xor     ch, ch
        inc     cx

ifdef WOW
        test    flBaseSetting, LPTRADDWOW_SETBASE
        jz      lptr_dontset
        cmp     RefSelector, 0
        jz      @F
        mov     bx, RefSelector
        mov     word ptr long_ptr[2], bx
@@:
endif
        mov     DscBuf.dsc_lbase, si    ; Put new base back in descriptor
        mov     DscBuf.dsc_mbase, dl
        mov     DscBuf.dsc_hbase, dh

        call    fill_in_selector_array

ifdef WOW
lptr_dontset:
	test	word ptr delta[2], 0fff0h
        jz      @F
        mov     cx, word ptr delta[2]
        jmps    lpa_too_big
@@:
endif
        mov     dx,word ptr long_ptr[2]
        mov     ax,word ptr long_ptr[0]
        and     ax, 0Fh
        jmps    lpa_exit

lpa_too_big:
        xor     ax,ax
        xor     dx,dx
lpa_exit:
        smov    es,0
cEnd


;-----------------------------------------------------------------------;
; SetSelectorBase
;
; Sets the base and limit of the given selector.
;
; Entry:
;       parmW   selector
;       parmD   selbase
;
; Returns:
;       AX = selector
;
; Error Returns:
;       AX = 0
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetSelectorBase,<PUBLIC,FAR>
        parmW   selector
        parmD   selbase
cBegin
        mov     bx, selector
        mov     dx, selbase.lo
        mov     cx, selbase.hi
ifdef WOW
        DPMICALL 0007h
else
        push    ds
        mov     ds, gdtdsc
        push    bx
        and     bl, not 7
        mov     ds:[bx].dsc_lbase, dx
        mov     ds:[bx].dsc_mbase, cl
        mov     ds:[bx].dsc_hbase, ch
        pop     bx
        pop     ds
endif ; WOW
        mov     ax, 0
        jc      ssb_exit
        mov     ax, selector                    ; Return selector
ssb_exit:
cEnd

;-----------------------------------------------------------------------;
; GetSelectorLimit
;
; Gets the limit of the given selector.
;
; Entry:
;       parmW   selector
;
; Returns:
;       DX:AX = limit of selector
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetSelectorLimit,<PUBLIC,FAR>
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, selector
ifdef WOW
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh
        xor     dx, dx
        mov     ax, DscBuf.dsc_limit
        mov     dl, DscBuf.dsc_hlimit
        and     dx, 0Fh                 ; AND out flags
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        and     bl, not 7
        mov     ax, [bx].dsc_limit
        mov     dl, [bx].dsc_hlimit
        and     dx, 0Fh                 ; AND out flags
        pop     ds
endif ; WOW
cEnd


;-----------------------------------------------------------------------;
; SetSelectorLimit
;
; Sets the limit of the given selector.
;
; Entry:
;       parmW   selector
;       parmD   sellimit
;
; Returns:
;       AX = 0 success
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetSelectorLimit,<PUBLIC,FAR>
        parmW   selector
        parmD   sellimit
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, selector
ifdef WOW
        push    di
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh
        mov     ax, word ptr sellimit[0]
        mov     DscBuf.dsc_limit, ax
        mov     al, byte ptr sellimit[2]
        and     al, 0Fh
        and     DscBuf.dsc_hlimit, 0F0h
        or      DscBuf.dsc_hlimit, al
        DPMICALL 000Ch
        pop     di
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    si
        mov     si, bx
        and     si, not 7
        mov     ax, sellimit.lo
        mov     [si].dsc_limit, ax
        mov     ax, sellimit.hi
        and     al, 0Fh
        and     [si].dsc_hlimit, 0F0h
        or      [si].dsc_hlimit, al
        pop     si
        pop     ds
endif ;WOW
        xor     ax,ax                   ; for now always return success
cEnd

;-----------------------------------------------------------------------;
; SelectorAccessRights
;
; Sets the access and other bytes of the given selector.
;
; Entry:
;       parmW   selector
;       parmW   getsetflag
;       parmD   selrights
;
; Returns:
;       AX = 0 success
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SelectorAccessRights,<PUBLIC,FAR>

        parmW   selector
        parmW   getsetflag
        parmW   selrights
        localV  DscBuf,DSC_LEN
cBegin

        cCall   GetAccessWord,<selector>
        cmp     getsetflag,0
        jnz     short sar_set

        and     ax, 0D01Eh              ; Hide bits they can't play with
        jmps    sar_exit

sar_set:
        mov     cx, selrights
        and     cx, 0D01Eh              ; Zap bits they can't set and
        and     ax, NOT 0D01Eh          ; get them from existing access rights
        or      cx, ax
        mov     bx, selector
ifdef WOW
        push    di
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh                  ; Set new access rights
        mov     word ptr DscBuf.dsc_access, cx
        DPMICALL 000Ch
        pop     di
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        and     bx, not 7
        mov     word ptr [bx].dsc_access, cx
        pop     ds
endif ;WOW
        xor     ax,ax                   ; for now always return success

sar_exit:

cEnd

;
; Direct GDT access is really helpful here - you are supposed
; to use LAR to get the high access bits, but this
; cannot be done on a 286 where we are STILL using
; these bits in a 386 compatible manner
;

cProc   GetAccessWord,<PUBLIC,NEAR>
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin
        push    bx
        push    es
        cmp     gdtdsc, 0                       ; Do we have LDT access?
        je      do_it_the_really_slow_way       ;  no, must make DPMI call

        mov     es, gdtdsc                      ; Go grab it out of the LDT
        mov     bx, selector
        sel_check bl
        mov     ax, word ptr es:[bx].dsc_access
        jmps    gaw_exit

do_it_the_really_slow_way:
        push    di
        lea     di, DscBuf
        smov    es, ss
        mov     bx, selector
        DPMICALL 000Bh
        mov     ax, word ptr DscBuf.dsc_access
        pop     di
gaw_exit:
        pop     es
        pop     bx
gaw_exit1:
cEnd

;
; Setting it is WORSE....
;
cProc   SetAccessWord,<PUBLIC,NEAR>,<ax,bx,es>
        parmW   selector
        parmW   access
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, selector
ifndef WOW                                      ; For WOW we have to call DMPI, LATER for mips this should party directly
        cmp     gdtdsc, 0
        je      slow_again

        mov     es, gdtdsc                      ; Go stuff it in the LDT
        sel_check bl
        mov     ax, access
        mov     word ptr es:[bx].dsc_access, ax
        jmps    saw_exit

endif ; WOW
slow_again:
;
; The DPMI guys changed their mind, NOW call 9h
; WILL set the AVL bit in the descriptor on
; all implementations.
;
        sel_check bl
        push    cx
        mov     cx, access
        DPMICALL 0009h
        pop     cx
saw_exit:
cEnd

;
; Selector in BX
;
cProc   GetSelectorCount,<PUBLIC,NEAR>
cBegin nogen
        cmp     gdtdsc, 0
        je      @F
        push    ds
        push    bx
        mov     ds, gdtdsc
        sel_check       bl
        mov     al, ds:[bx].dsc_hlimit
        pop     bx
        pop     ds
        and     ax, 0Fh
        inc     al
        ret
@@:
        push    es
        push    di
        sub     sp, DSC_LEN
        mov     di, sp
        smov    es, ss
        DPMICALL 000Bh
        mov     al, es:[di].dsc_hlimit
        add     sp, DSC_LEN
        pop     di
        pop     es
        and     ax, 0Fh
        inc     al
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; GlobalPageLock
;
; Page locks the memory associated with the Handle.
;
; Entry:
;     parmW   handle
;
; Returns:
;     AX = new lock count
;
; History:
;  Fri 16-Feb-1990 02:13:09  -by-  David N. Weise  [davidw]
; Should it or shouldn't it?  At the very least it must lock
; the object to be consitent with 386pmode.
;
;  Wed 31-May-1989 22:14:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

      assumes ds,nothing
      assumes es,nothing

cProc   IGlobalPageLock,<PUBLIC,FAR>,<si,di>

        parmW   handle
cBegin
        cCall   GlobalFix,<handle>
        cCall   GetSelectorLimit,<handle>
        mov     si, dx
        mov     di, ax
        cCall   get_physical_address,<handle>
        mov     bx, dx
        mov     cx, ax
        DPMICALL 0600h
        mov     ax, 1
cEnd


;-----------------------------------------------------------------------;
; GlobalPageUnlock
;
; Page unlocks the memory associated with the Handle.
;
; Entry:
;     parmW   handle
;
; Returns:
;     AX = new lock count
;
; History:
;  Fri 16-Feb-1990 02:13:09  -by-  David N. Weise  [davidw]
; Should it or shouldn't it?  At the very least it must unlock
; the object to be consitent with 386pmode.
;
;  Wed 31-May-1989 22:14:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

      assumes ds,nothing
      assumes es,nothing

cProc   IGlobalPageUnlock,<PUBLIC,FAR>,<si,di>

        parmW   handle
cBegin
        cCall   GlobalUnFix,<handle>
        cCall   GetSelectorLimit,<handle>
        mov     si, dx
        mov     di, ax
        cCall   get_physical_address,<handle>
        mov     bx, dx
        mov     cx, ax
        DPMICALL 0601h
        xor     ax,ax                   ; page lock count is zero
cEnd


if ROM  ;----------------------------------------------------------------

;-----------------------------------------------------------------------
; ChangeROMHandle
;
; Changes the handle of an allocated memory block.  Used when loading
; segments from ROM to RAM so RAM copy can use the handle expected by
; other ROM code.
;
; Entry:
;     parmW   hOld
;     parmW   hNew
;
; Returns:
;     AX = hNew if successful, 0 if not
;
; History:
;
;-----------------------------------------------------------------------

      assumes ds,nothing
      assumes es,nothing


cProc ChangeROMHandle,<PUBLIC,FAR>,<bx,si,di,ds,es>
        parmW   hOld
        parmW   hNew
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx,hOld                 ; Get arena pointer for old handle
        cCall   get_arena_pointer,<bx>
        or      ax,ax
if KDEBUG
        jnz     @f
        INT3_WARN
        jmps    ch_ret
@@:
else
        jz      ch_ret
endif
        push    ax
        mov     si, bx
        and     bx, SEG_RING_MASK       ; Ring bits
        or      bx, hNew                ; New handle
        smov    es, ss
        lea     di, DscBuf
        xchg    bx ,si
        DPMICALL 000Bh                  ; Get old descriptor
        xchg    bx, si
        DPMICALL 000Ch                  ; Set new descriptor
        pop     es                      ; es -> arena (or owner)

        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<si,0>        ; Old sel has not association

        test    DscBuf.dsc_access,DSC_PRESENT   ; Change handle in arena
        jz      crh_np                          ;   if selector is present
        mov     es:[ga_handle], bx
crh_np:
        cCall   AssociateSelector,<bx,es>       ; New sel associated with this
                                                ;   arena or owner
        cCall   FreeSelArray,<hOld>             ; Free old selector

        mov     ax,bx
ch_ret:
cEnd

;-----------------------------------------------------------------------
; CloneROMSelector
;
; Changes the base and limit of the clone selector to point to the
; ROM selector's original ROM segment.  ROM segment selectors may be
; changed when loading a ROM segment to RAM.
;
; Entry:
;     parmW   selROM
;     parmW   selClone
;
; Returns:
;
; History:
;
;-----------------------------------------------------------------------

      assumes ds,nothing
      assumes es,nothing

cProc CloneROMSelector,<PUBLIC,NEAR>,<bx, si, di, ds, es>
        parmW   selROM
        parmW   selClone
        localV  DscBuf,DSC_LEN
cBegin
        SetKernelDS es
        mov     ax,selROMLDT
        mov     es,selROMToc
        assumes es,nothing

        mov     bx,selROM

if KDEBUG
        cmp     bx,es:[FirstROMsel]     ; sanity checks to make sure
        jae     @f                      ;   selector is within ROM range
        INT3_WARN
@@:
        push    bx
        and     bl,not SEG_RING_MASK
        sub     bx,es:[FirstROMsel]
        shr     bx,3
        cmp     bx,es:[cROMsels]
        jbe     @f
        INT3_WARN
@@:
        pop     bx
endif
        mov     si, bx
        and     si, NOT SEG_RING_MASK
        sub     si, es:[FirstROMsel]    ; si = offset in ROM LDT of descriptor

        mov     ds, ax                  ; copy ROM desciptor to stack buffer
        smov    es, ss
        lea     di, DscBuf

        errnz   <8 - DSC_LEN>
        movsw
        movsw
        movsw
        movsw

        mov     bx, selClone            ; clone descriptor to orig ROM contents
        lea     di, DscBuf
        DPMICALL 000Ch

        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<bx,0>        ; no arena/owner currently

        mov     ax,bx                   ; return with selClone in AX
cEnd

endif ;ROM      ---------------------------------------------------------


cProc   SetKernelCSDwordProc,<PUBLIC,NEAR>,<ax,bx,ds>
        parmw   addr
        parmw   hiword
        parmw   loword
cBegin
        SetKernelDS
        mov     ds, MyCSAlias
        UnSetKernelDS
        mov     bx, addr
        mov     ax, loword
        mov     [bx], ax
        mov     ax, hiword
        mov     [bx+2], ax
cEnd

cProc   GetKernelDataSeg,<PUBLIC,NEAR>
cBegin nogen
        mov     ax, cs:MyCSDS
        ret
cEnd nogen

cProc   SetKernelDSProc,<PUBLIC,NEAR>
cBegin nogen
        mov     ds, cs:MyCSDS
        ret
cEnd nogen

cProc   SetKernelESProc,<PUBLIC,NEAR>
cBegin nogen
        mov     es, cs:MyCSDS
        ret
cEnd nogen

cProc   CheckKernelDSProc,<PUBLIC,NEAR>
cBegin nogen
if KDEBUG
        cmp     ax, cs:MyCSDS
        je      dsok
        INT3_WARN
dsok:
endif
        ret
cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   FarGetOwner,<PUBLIC,FAR>,<bx>
        parmW   Selector
cBegin
        cCall   GetOwner,<Selector>
cEnd

cProc   GetOwner,<PUBLIC,NEAR>,<es>
        parmW   Selector
cBegin
        cCall   get_arena_pointer,<Selector>
if ROM
        or      ax,ax                           ; get_arena_pointer fails on
        jnz     go_got_it                       ;   ROM segments so give it
        cCall   GetROMOwner,<Selector>          ;   another try
        jmps    go_end
go_got_it:
else
        or      ax, ax
        jz      go_end
endif
        mov     es, ax
        mov     ax, es:[ga_owner]
go_end:
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   FarSetOwner,<PUBLIC,FAR>
        parmW   Selector
        parmW   owner
cBegin
        cCall   SetOwner,<Selector,owner>
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   SetOwner,<PUBLIC,NEAR>,<ax,es>
        parmW   Selector
        parmW   owner
cBegin
        cCall   get_arena_pointer,<Selector>
        mov     es, ax
        push    owner
        pop     es:[ga_owner]
cEnd


if ROM  ;----------------------------------------------------------------

;-----------------------------------------------------------------------
; Set/GetROMOwner
;
; The Get/SetROMOwner routines use AssociateSelector and the inverse
; get_selector_association routines to track the owner of an object
; in ROM.  ROM objects (like code segments and resources) don't have
; a global heap arena to store the owner's ID in.
;
; NOTE: THIS CODE DEPENDS ON WINDOWS RUNNING IN RING 1 OR 3!!  The low
; bit of the associated value is set to zero to indicate the object is
; in ROM.  SetROMOwner expects the owner selector to have the low bit
; set, and GetROMOwner returns the owner field with the low bit set.
;
;-----------------------------------------------------------------------
        assumes ds, nothing
        assumes es, nothing

cProc   FarSetROMOwner,<PUBLIC,FAR>
        parmW   Selector
        parmW   Owner
cBegin
        cCall   SetROMOwner,<Selector,Owner>
cEnd

cProc   SetROMOwner,<PUBLIC,NEAR>,<ds>
        parmW   Selector
        parmW   Owner
cBegin
        mov     ax,Owner
        and     al,NOT 1                        ; mark this as a ROM selector
        SetKernelDS
        mov     ds,pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<Selector,ax>
cEnd


cProc   GetROMOwner,<PUBLIC,NEAR>,<bx,es,ds>
        parmW   Selector
cBegin
        mov     bx,Selector
        cCall   get_selector_association
        or      ax,ax
        jz      gro_exit

        test    al,1                    ; low bit off if ROM owner
        jnz     gro_not_rom_owner

        or      al,1                    ; restore bit cleared by SetROMOwner
        jmps    gro_exit

gro_not_rom_owner:
        xor     ax,ax

gro_exit:
cEnd

;-----------------------------------------------------------------------;
; IsROMObject
;
; Determines if a given selector points into the ROM area.
;
; Entry:
;       selector        selector to check
;
; Returns:
;       AX != 0 & CY set if selector points to ROM
;       AX =  0 & CY clr if selector does not point to ROM
;
; Registers Destroyed:
;       none
;
; History:
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FarIsROMObject, <PUBLIC, FAR>
    parmW selector
cBegin
    cCall   IsROMObject, <selector>
cEnd

cProc   IsROMObject,<PUBLIC,NEAR>,<bx,di,es>
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin

        push    ds
        SetKernelDS

if KDEBUG
        mov     ax,selector
        sel_check ax
endif
        mov     bx,selector
        smov    es,ss
        lea     di,DscBuf
        DPMICALL 000Bh                  ; Get current descriptor

        mov     bh,DscBuf.dsc_hbase     ; is descriptor base at or
        mov     bl,DscBuf.dsc_mbase     ;   above start of ROM?
        mov     ax,DscBuf.dsc_lbase
        sub     ax,lmaHiROM.off
        sbb     bx,lmaHiROM.sel
        jc      iro_not_rom

        sub     ax,cbHiROM.off          ; make sure it's not above
        sbb     bx,cbHiROM.sel          ;   the end of the ROM
        jnc     iro_not_rom

        mov     al,1                    ; in ROM range, ret AX != 0 & CY set
        jmps    iro_exit

iro_not_rom:
        xor     ax,ax                   ; not in ROM, AX = 0 & CY clear

iro_exit:
        pop     ds
        assumes ds,nothing
cEnd


endif ;ROM      ---------------------------------------------------------


        assumes ds, nothing
        assumes es, nothing

cProc   FarValidatePointer,<PUBLIC,FAR>
        parmD   p
cBegin
        cCall   ValidatePointer,<p>
cEnd

cProc   ValidatePointer,<PUBLIC,NEAR>
        parmD   p
cBegin
        lsl     ax, seg_p
        jnz     short bad_p             ; can we access this selector?
        cmp     ax, off_p               ;  yes, is the offset valid?
        jae     short good_p
bad_p:
        xor     ax, ax
        jmps    vp_done
good_p:
        mov     ax, 1
vp_done:
cEnd

        assumes ds, nothing
        assumes es, nothing

OneParaBytes    dw      10h

cProc   SelToSeg,<PUBLIC,NEAR>,<dx>
        parmW   selector
cBegin
        cCall   get_physical_address,<selector>
        div     OneParaBytes                    ; Smaller than rotates
cEnd



cProc   SegToSelector,<PUBLIC,NEAR>,<bx>
        parmW   smegma
cBegin
        mov     bx, smegma
        DPMICALL 0002h
cEnd


;-----------------------------------------------------------------------;
; set_discarded_sel_owner
;
; Sets the owner of a selector that points to a discarded object,
; which lives in the limit field.
;
; Entry:
;       BX = selector to mark
;       ES = owner
;
; Returns:
;       nothing
;
; Registers Destroyed:
;       BX
;
; History:
;  Sun 03-Dec-1989 21:02:24  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_discarded_sel_owner,<PUBLIC,FAR>,<ds,di>
        localV  DscBuf,DSC_LEN
cBegin
        mov     cx, es
ifdef WOW
        push    ax
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh
        mov     DscBuf.dsc_owner, cx
        DPMICALL 000Ch
        pop     ax
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    di
        mov     di, bx
        and     di, not 7
        mov     [di].dsc_owner, cx
        pop     di
        pop     ds
endif ; WOW
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<bx,cx>
        mov     es, cx                  ; Restore ES
cEnd


;-----------------------------------------------------------------------;
; SetResourceOwner
;
; Sets the owner of a selector that points to a not present resource
;
; Entry:
;
; Returns:
;       nothing
;
; Registers Destroyed:
;
; History:
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetResourceOwner,<PUBLIC,NEAR>,<ax,bx,cx,di,ds,es>
        parmW   selector
        parmW   owner
        parmW   selCount
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, selector
        mov     cx, owner
ifdef WOW

        smov    es, ss
        lea     di, DscBuf
        DPMICALL 000Bh                  ; Get current descriptor
        mov     DscBuf.dsc_owner, cx
        mov     DscBuf.dsc_access, DSC_DATA
        mov     cx,selCount
        dec     cl
        and     cl,00001111b
        or      cl,DSC_DISCARDABLE
        mov     DscBuf.dsc_hlimit, cl   ; Save number of selectors here
        DPMICALL 000Ch                  ; Set it with new owner
else
        push    ds                      ; Get Descriptor
        mov     ds, gdtdsc
        push    bx
        and     bx, not 7
        mov     [bx].dsc_owner, cx
        mov     [bx].dsc_access, DSC_DATA
        mov     cx,selCount
        dec     cl
        and     cl,00001111b
        or      cl,DSC_DISCARDABLE
        mov     [bx].dsc_hlimit, cl   ; Save number of selectors here
        pop     bx
        pop     ds
endif ; WOW
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector,<bx,owner>    ; And save in selector table
cEnd


;-----------------------------------------------------------------------;
;
; Alias stuff moved out due to gross bloating of this file
;
;-----------------------------------------------------------------------;
if ALIASES
include aliases.asm
endif


;-----------------------------------------------------------------------;
; DPMIProc
;
; Called NEAR by the DPMICALL macro -
; this is better than intercepting int 31h
;
; By sheer fluke, all intercepts return with
; Carry clear ie no error.
;
;-----------------------------------------------------------------------;
cProc   DPMIProc,<PUBLIC,NEAR>
cBegin nogen
        or      ah, ah
        jz      @F
CallServer:
ifndef WOW
        int     31h                     ; Nope, call DPMI server
        ret
else
        test    word ptr [prevInt31Proc + 2],0FFFFh
        jz      dp30
dp20:   pushf
        call    [prevInt31Proc]
        ret
endif
@@:
if ROM
        cmp     al, 01h                 ; Free selector?
        jne     @f
        push    ds
        SetKernelDS
        cmp     bx,sel1stAvail          ; Yes, don't free selectors in
        pop     ds                      ;   the preallocated ROM range
        UnSetKernelDS
        jae     CallServer
        ret
@@:
endif ;ROM
ifdef WOW
        cmp     gdtdsc, 0               ; Can we party?
        jz      CallServer              ; Nope
endif
        push    ds
        mov     ds, gdtdsc
ifdef WOW

        or      al, al
        jnz     @F
        mov     ax, WOW_DPMIFUNC_00
        pop     ds
        jmps    CallServer
@@:
endif
        cmp     al, 0Bh
        jne     @F

        test    bx,4
        jnz     xx1

        ; On MIPS if Win87EM is processing an NPX exception the selector
        ; to Dosx's stack is being looked up here.  Since it is a global
        ; selector the normal lookup will not find it and Win87EM will
        ; fault.  This is solved by calling Dosx since it knows about the
        ; global selectors that we don't. - MarkRi [6/93]
        ;
        pop     ds
        jmps    CallServer

xx1:    push    si                      ; Get Descriptor - used very often!
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
        ret

ifndef WOW
@@:
        cmp     al, 0Ch
        jne     @F

        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
        ret

@@:
        cmp     al, 07h         ; Set Segment Base Address
        jne     @F
        push    bx
        and     bl, not 7
        mov     ds:[bx].dsc_lbase, dx
        mov     ds:[bx].dsc_mbase, cl
        mov     ds:[bx].dsc_hbase, ch
        pop     bx
        pop     ds
        ret
endif
@@:
        cmp     al, 06h                 ; Get Segment Base Address
        jne     @F
        push    bx
        and     bl, not 7
        mov     dx, ds:[bx].dsc_lbase
        mov     cl, ds:[bx].dsc_mbase
        mov     ch, ds:[bx].dsc_hbase
        pop     bx
        pop     ds
        ret
ifndef WOW
@@:
        cmp     al, 09h                 ; Set Descriptor Access Rights
        jne     @F
        push    bx
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
        ret
endif
@@:
        pop     ds
        jmp     CallServer

ifdef WOW
dp30:   int     31h
        ret
endif
cEnd nogen


if ROM
if1
%out CheckROMSelector -- fix me!!  (what exactly is wrong?)
endif
endif

if 0 ;;ROM and KDEBUG

;------------------------------------------------------------------------
; CheckROMSelector
;
; ROM Windows debug hack to ensure that Windows code doesn't try writing
; to the ROM image.  It does this by making any data selector to the
; ROM read only.
;
; Entry:
;       DS:BX -> descriptor to check
;
; Returns:
;       nothing
;
; Registers Destroyed:
;       none
;
;------------------------------------------------------------------------

        assumes ds,nothing
        assumes es,nothing

cProc   CheckROMSelector,<PUBLIC,NEAR>
cBegin  nogen

        test    ds:[bx].dsc_access,DSC_CODEDATA         ; code or data dsc?
        jz      crs_exit                                ;   no, skip it

        test    ds:[bx].dsc_access,DSC_CODE_BIT         ; code?
        jnz     crs_exit                                ;   yes, skip it

        push    ax
        push    dx
        mov     dh,ds:[bx].dsc_hbase            ; is descriptor base at or
        mov     dl,ds:[bx].dsc_mbase            ;   above start of ROM?
        mov     ax,ds:[bx].dsc_lbase
        sub     ax,lmaHiROM.off
        sbb     dx,lmaHiROM.sel
        jc      crs_exit1

        sub     ax,cbHiROM.off                  ; make sure it's not above
        sbb     dx,cbHiROM.sel                  ;   the end of the ROM
        jnc     crs_exit1

        and     ds:[bx].dsc_access,NOT DSC_RW_BIT       ; make it read only

crs_exit1:
        pop     dx
        pop     ax

crs_exit:
        ret

cEnd    nogen

endif ;ROM and KDEBUG

ifdef WOW


cProc   alloc_special_sel,<PUBLIC,NEAR>,<bx,cx,dx,si,di,ds>
        parmW   AllocFlags
        parmW   SelFreeBlock
        parmW   SizeFreeBlock
        parmW   SizeNewFreeBlock
        parmW   AdjustedSize
        parmB   fBaseAddressToUse

        localD  AddressNewFreeBlock
        localD  Address
        localW  Limit
        localW  cFreeBlock
        localW  cTotalSelectors
        localW  EachSelectorLimit
cBegin

        ;
        ; this will be our ds
        ;

        mov     ds, gdtdsc

        ;
        ; replace allocflags with accessword
        ;

        mov     bx, AllocFlags
        and     bx, ((GA_CODE_DATA+GA_DISCARDABLE) shl 8) + GA_DGROUP
        or      bl, bh
        xor     bh, bh
        shl     bx, 1
        mov     ax, cs:SelAccessWord[bx]  ; Pick up access rights for selector
        mov     AllocFlags, ax            ; allocflags = access rights

        ;
        ; Limit for data selectors
        ;

        mov     ax, AdjustedSize
        dec     ax
        mov     Limit, ax

        ;
        ; compute  base address for new freeblock and the first selector
        ; the base address is dependent on fBaseAddressToUse flag
        ;

        cCall   get_physical_address,<SelFreeBlock>

        cmp     fBaseAddressToUse, ga_prev
        jne     @F

        mov     bx, SizeNewFreeBlock
        xor     cx,cx
        REPT    4
        shl     bx,1
        rcl     cx,1
        ENDM

        add     ax, bx
        adc     dx, cx

        mov     AddressNewFreeBlock.lo, ax
        mov     AddressNewFreeBlock.hi, dx

        ;
        ; compute  base address for first selector
        ;

        add ax, 10h
        adc dx, 00h

        mov     Address.lo, ax
        mov     Address.hi, dx

        jmps    alloc_checkforfreeblock
@@:

        push    ax      ; save base address of freeblock
        push    dx

        add     ax, 10h
        adc     dx, 00h

        mov     Address.lo, ax     ; address of first selector
        mov     Address.hi, dx

        pop     dx
        pop     ax

        mov     bx, AdjustedSize
        xor     cx,cx
        REPT    4
        shl     bx,1
        rcl     cx,1
        ENDM

        add     ax, bx
        adc     dx, cx

        mov     AddressNewFreeBlock.lo, ax
        mov     AddressNewFreeBlock.hi, dx

alloc_checkforfreeblock:

        ;
        ; check if a 'new' free block needs to be created.
        ; cFreeBlock = (SizeNewFreeBlock) ? 1 : 0;
        ;

        mov     cFreeBlock, 0
        mov     cx, SizeNewFreeBlock
        jcxz    alloc_nofreeblock
        mov     cFreeBlock, 1

alloc_nofreeblock:


        ;
        ; start of processing
        ;

        mov     cx, 1
        mov     ax, AllocFlags
        test    al, DSC_PRESENT
        jz      allocspecial_oneonly
                                        ; limit in paras
        mov     cx, Limit               ; Calculate how many selectors required
        add     cx, 0FFFh
        rcr     cx, 1                   ; 17 bitdom
        shr     cx, 11

allocspecial_oneonly:
        push    cx
        add     cx, cFreeBlock          ; cFreeBlock is zero or one
        mov     cTotalSelectors, cx

        ;
        ; the dpmi func is 04f1h. This is idential to function 00h, except that
        ; the descriptor base and limit are not initialized to zero.
        ;

        DPMICALL WOW_DPMIFUNC_00
        pop     cx
        jnz     allocspecial_continue
        jmp     allocspecial_exit

allocspecial_continue:

        push    ax                      ; save the first selector
        and     ax, not SEG_RING

        mov     bx, ax                  ; Selector in bx for DPMI

        mov     ax, Address.lo          ; Set descriptor base
        mov     [bx].dsc_lbase, ax
        mov     di, ax                  ; used later
        mov     ax, Address.hi
        mov     [bx].dsc_mbase, al
        mov     [bx].dsc_hbase, ah

        mov     ax, AllocFlags
        test    al, DSC_PRESENT              ; If selector not present, limit is
        jnz     short allocspecial_present   ; as passed, not a paragraph count

allocspecial_not_present:

        mov     word ptr [bx].dsc_access, ax
        mov     ax, word ptr Limit
        mov     [bx].dsc_limit, ax

        jmps    allocspecial_done

allocspecial_present:

        dec     cl
        and     ah, not 0Fh             ; Zero limit 19:16
        or      ah, cl                  ; Fill in limit 19:16
        inc     cl
        mov     word ptr [bx].dsc_access, ax
        mov     si, ax                  ; save for later use
        mov     ax, Limit
        shl     ax, 4                   ; Convert paragraphs to byte limit
        dec     ax
        mov     [bx].dsc_limit, ax

        dec     cx
        jcxz    allocspecial_done       ; if sel=1 done.

        mov     EachSelectorLimit, ax   ; ax the limit from above
        mov     al, [bx].dsc_mbase           ;
        mov     ah, [bx].dsc_hbase
        mov     dl, [bx].dsc_hlimit

        push    ds
        SetKernelDS
        test    WinFlags, WF_CPU286             ; protect mode on a 286?
        pop     ds


        push    [bx].dsc_limit               ; Save limit for last selector
        jz      allocspecial_next_sel        ; the result of the test above
        mov     EachSelectorLimit, 0FFFFh    ; Others get 64k limit on 286

allocspecial_next_sel:
        push    ax
        mov     ax, EachSelectorLimit
        mov     [bx].dsc_limit, ax           ; limit for current selector
        pop     ax

        lea     bx, [bx+DSC_LEN]               ; On to next selector
        cmp     cx, 1                          ; Last selector?
        jne     allocspecial_fsa_not_last
        pop     [bx].dsc_limit               ;  yes, get its limit

allocspecial_fsa_not_last:
        mov     [bx].dsc_lbase, di
        mov     word ptr [bx].dsc_access, si
        inc     ax
        mov     [bx].dsc_mbase, al            ; Add 64kb to address
        mov     [bx].dsc_hbase, ah
        dec     dl
        mov     [bx].dsc_hlimit, dl           ; subtract 64kb from limit
        loop    allocspecial_next_sel

allocspecial_done:
        cmp     cFreeBlock, 1
        jne     allocspecial_nofreeblock

allocspecial_freeblock:

        mov     ax, AddressNewFreeBlock.lo      ; the base for freeblock
        mov     dx, AddressNewFreeBlock.hi


        lea     bx, [bx+DSC_LEN]                ; On to next selector
        mov     [bx].dsc_limit, 0fh          ; = 1 para
        mov     [bx].dsc_lbase, ax
        mov     [bx].dsc_mbase, dl
        mov     [bx].dsc_hbase, dh

        mov     ax, DSC_DATA+DSC_PRESENT
        and     ah, not 0Fh                     ; Zero limit 19:16
        mov     word ptr [bx].dsc_access, ax

allocspecial_nofreeblock:

        pop     si                ; restore the first selector

        push    bx
        mov     cx, cTotalSelectors
        mov     bx, si

        ;
        ; the dpmi func is 04f2h. This is identical to 0ch except that it
        ; sets 'count' (in cx) LDTs at one time. The first selector is in
        ; register bx. The descriptor data is in gdtdsc[bx], gdtdsc[bx+8]
        ; etc. This data is shared between dpmi (dosx.exe) and us and thus
        ; need not be passed in es:di

        DPMICALL WOW_DPMIFUNC_0C
        pop     bx

        SetKernelDS

        ;
        ; sanity check. done so late because if this  check was done
        ; somewhere eariler, we would have had to Save and Restor DS. Since
        ; this check would be successful most of the time, it is quite Ok
        ; to do it now and we would avoid unneccessary loading of DS.

        mov     ax, bx
        shr     ax, 2
        cmp     ax, SelTableLen         ; Make sure we can associate it
        jb      @F
        xor     ax, ax                  ; set zero flag
        jmps    allocspecial_exit

@@:
        mov     UserSelArray, si  ; the selector for user data
        mov     ax, bx
        or      ax, SEG_RING      ; selector of new freeblock, if one is
                                  ; created. sets nz flag.
        mov     SelectorFreeBlock, ax ;
allocspecial_exit:
cEnd


;----------------------------------------------------------------------------
; grabbed from 2gmem.asm
;
;----------------------------------------------------------------------------

SelAccessWord   dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_CODE+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_CODE+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT



;-----------------------------------------------------------------------------
; Grab the selector 0x47 so that we dont need to special case the biosdata
; selector (0x40) while converting seg:off address to flat 32bit address
;
; This, however should not be part of Krnl286 heap.
;
;                                                    - Nanduri Ramakrishna
;-----------------------------------------------------------------------------
cProc   AllocSelector_0x47,<PUBLIC,FAR>, <ax, bx, cx, ds>
cBegin

     ; alloc the specific selector

     mov bx, 047h
     DPMICALL 0dh
     jc  as47_exit

     ; initialize the LDT

     and     bx, not SEG_RING
     mov     ds, gdtdsc
     mov     [bx].dsc_limit, 00h          ; = 1 byte
     mov     [bx].dsc_lbase, 0400h
     mov     [bx].dsc_mbase, 00h
     mov     [bx].dsc_hbase, 00h

     mov     ax, DSC_DATA+DSC_PRESENT
     and     ah, not 0Fh                     ; Zero limit 19:16
     mov     word ptr [bx].dsc_access, ax

     ; set the LDT

     mov     cx,1
     mov     bx, 047h
     DPMICALL WOW_DPMIFUNC_0C

as47_exit:
cEnd
sEnd    CODE

sBegin  NRESCODE

assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING


cProc   get_sel_flags,<PUBLIC,NEAR>
	parmW	selector
cBegin
    ; Not used in krnl286
        xor     ax,ax
        xor     dx,dx
cEnd

cProc   set_sel_for_dib,<PUBLIC,NEAR>
        parmW   selector
        parmW   flags
        parmD   address
        parmW   csel
cBegin
    ; Not used in krnl286
        xor     ax,ax
        xor     dx,dx
cEnd

cProc   RestoreDib,<PUBLIC,NEAR>
        parmW   selector
        parmW   flags
        parmD   address
cBegin
    ; Not used in krnl286
        xor     ax,ax
        xor     dx,dx
cEnd

cProc   DibRealloc,<PUBLIC,FAR>
        parmW   Selector
        parmW   NewSize
cBegin
cEnd

endif

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2gmemini.asm ===
page	,132

; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.

.sall
.xlist
include kernel.inc
include protect.inc
.list

DataBegin

externB Kernel_Flags
externW hGlobalHeap
externW pGlobalHeap
externW sel_alias_array
externW WinFlags
externW SelTableLen
externD SelTableStart

DataEnd

DataBegin	INIT

        INITIAL_BLOCK_SIZE equ 0       ; one meg
	NUM_DPMI_BLOCKS equ	20     ; Impossibly huge number

DPMI_block	STRUC
	blksize	dw	0
	addr_lo	dw	0
	addr_hi	dw	0
DPMI_block	ENDS

DPMI_memory	DPMI_block	NUM_DPMI_BLOCKS	DUP	(<>)

top_block	dw	?

DataEnd	INIT

sBegin	INITCODE
assumes CS,CODE

externW gdtdsc

externNP get_physical_address
externNP set_physical_address
externNP set_sel_limit
externNP alloc_data_sel
externNP get_arena_pointer
externNP get_rover_2
externNP AssociateSelector
externNP AllocDpmiBlock
externNP FormatHeapBlock
externNP AddBlockToHeap

externFP GlobalAlloc
externNP DPMIProc

GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = NOT GA_ALIGN_BYTES


;-----------------------------------------------------------------------;
; GlobalPigAll								;
;									;
;	Allocates all the DPMI memory in the system as blocks of 1 Meg. ;
; or smaller.  Stores the addresses and sizes in the DPMI_memory array. ;
;									;
;-----------------------------------------------------------------------;
cProc	GlobalPigAll,<NEAR,PUBLIC>,<ds,es,di,si,ax,bx,cx,dx>
	localV	MemInfo,30h
	localW	saveCX
cBegin
	smov	es, ss
	SetKernelDS
ifdef WOW
; DOSX is not efficient about the way it manages its heap.   If we alloc
; the largest block an then free it - it will do better management
; when we alloc 1Mbyte chunks.	 Otherwise it will alloc 3 selectors
; and 1k of unused memory per megabyte
	lea	di, MemInfo
	DPMICALL 0500h			; Get Free Memory Info
	mov	cx, es:[di]		; BX:CX gets largest free block
	mov	bx, es:[di+2]
	or	ax,bx
	jz	idb_gotblocks		; None to be had!

	DPMICALL 0501h			; allocate is all
	DPMICALL 0502h			; Free it all
endif; WOW
	mov	si,dataOffset DPMI_memory	; DS:SI -> first DPMI_block
	mov	cx,NUM_DPMI_BLOCKS
idb_getblock:
	mov	word ptr saveCX,cx
	lea	di, MemInfo
	DPMICALL 0500h			; Get Free Memory Info
	mov	cx, es:[di]		; BX:CX gets largest free block
	mov	bx, es:[di+2]
	mov	ax,cx
	or	ax,bx
	jz	idb_gotblocks		; None to be had!

	cmp	bx,0010h		; 1 Meg. or more available?
	jb	@F			; No, use what is available
	mov	bx,0010h
	xor	cx,cx
@@:					; BX:CX is bytes to allocate
	mov	dx,bx			; copy to DX:AX
	mov	ax,cx
rept 4
	shr	dx,1
	rcr	ax,1
endm
	mov	[si].blksize,ax		; Size is #paragraphs we hope to get

;
; This call returns an address in BX:CX, and a handle in SI:DI.  We don't
; use the handle for anything, but we do use SI here.
;
	push	si
	DPMICALL 0501h			; allocate the block
	pop	si

	jc	idb_gotblocks
	mov	[si].addr_lo,cx
	mov	[si].addr_hi,bx
	add	si,SIZE DPMI_block

	mov	cx,word ptr saveCX
	loop	idb_getblock

idb_gotblocks:
	mov	[top_block],si

	UnsetKernelDS
cEnd

									;
;-----------------------------------------------------------------------;
; Find_DPMI_block							;
;									;
; Allocate a block of memory from DPMI that is 1 megabyte in size,	;
; or the largest available block if smaller.				;
;									;
;	RETURNS:	AX = selector to block if allocated		;
;			AX = zero if error				;
;			CX = size of block in paragraphs (yech!)	;
;			CX = zero if block is 1 megabyte in size.	;
;-----------------------------------------------------------------------;
	
cProc	Find_DPMI_block,<PUBLIC,NEAR>,<ds,si,es,di,bx,dx>
	localV	MemInfo,30h
	localW	SizeOfBlock
cBegin
	SetKernelDS
	smov	es, ds
	xor	ax,ax				; AX = 0
	mov	si,dataOffset DPMI_memory	; DS:SI -> first DPMI_block

adb_findfirstblock:
	cmp	si,[top_block]
	jnb	adb_ret
	mov	cx,[si].addr_lo
	mov	bx,[si].addr_hi
	or	bx,cx
	jnz	adb_foundfirstblock
	add	si,SIZE DPMI_block		; SI -> next block
	jmp	adb_findfirstblock

adb_foundfirstblock:
	mov	di,si				; SI -> first block

adb_nextblock:
	add	di,SIZE DPMI_block		; DI -> next block
	cmp	di,[top_block]
	jnb	adb_foundblock

	mov	dx,[si].addr_lo			; which block is lower?
	cmp	dx,[di].addr_lo
	mov	dx,[si].addr_hi
	sbb	dx,[di].addr_hi

	jb	adb_nextblock	; block at si is lower than block at di

	mov	dx,[si].addr_lo
	xchg	dx,[di].addr_lo
	xchg	dx,[si].addr_lo

	mov	dx,[si].addr_hi
	xchg	dx,[di].addr_hi
	xchg	dx,[si].addr_hi

	mov	dx,[si].blksize
	xchg	dx,[di].blksize
	xchg	dx,[si].blksize

	jmp	adb_nextblock

adb_foundblock:					; DS:SI -> block to use
	mov	bx,ax
	mov	cx,ax
	xchg	bx,[si].addr_hi
	xchg	cx,[si].addr_lo
	cCall	alloc_data_sel,<bx,cx,1>; Get selector for start of block
						; (return result)
	mov	cx,[si].blksize
adb_ret:
	UnsetKernelDS
cEnd

;-----------------------------------------------------------------------;
; GlobalInit								;
;									;
; Procedure to initialize the global heap.				;
;									;
; Arguments:								;
;	parmW	hdelta	= size (.25k) of master object			;
;	parmW	palloc	= selector of block to mark allocated		;
;	parmW	pstart	= selector pointing to first available address	;
;	parmW	pend	= selector pointing to last available address	;
;									;
;	Note: for the ROM kernel, palloc is actually the size in bytes	;
;	      of the allocated block, not a pointer!			;
;									;
; Returns:								;
;	AX = handle for allocated block					;
;									;
; Error Returns:							;
;									;
; Alters:								;
;	ES								;
; Calls:								;
;	ginit								;
;									;
; History:								;
;									;
;  Fri May 05, 1989 09:40:00a  -by-  Jim Mathews	[jimmat]	;
; Dear diary, many things have happened since the last comment entry... ;
; Added code to allocate a block of conventional memory and link it	;
; into the Windows global heap when running under the 286 DOS extender. ;
;									;
;  Sat Jun 20, 1987 05:55:35p  -by-  David N. Weise     [davidw]	;
; Making real EMS work with the fast boot version.			;
; 									;
;  Sun Mar 15, 1987 06:38:04p  -by-  David N. Weise	[davidw]	;
; Added support for the linked free list long ago.			;
; 									;
;  Wed Feb 18, 1987 08:09:18p  -by-  David N. Weise	[davidw]	;
; Added the initialization of the gi_alt entries.			;
; 									;
;  Mon Sep 08, 1986 07:53:41p  -by-  David N. Weise	[davidw		;
; Changed the return values so that this can be called from other than	;
; initialization code.							;
;-----------------------------------------------------------------------;

cProc	GlobalInit,<PUBLIC,NEAR>,<ds,si,di>
	parmW   hdelta
	parmW   palloc
	parmW   pstart
	parmW	pend
	localW	hInitMem
	localW	allocated_sel
	localW	next_block
	localW	free_hi
	localW	free_lo
	localV	MemInfo,30h

cBegin

	mov	ax,palloc		; AX = block to mark allocated
	mov	bx,pstart		; BX = first available address
	mov	cx,hdelta		; CX = size (.25k) of master object
	mov	dx,pend 		; DX = last available address
	call	ginit

	mov	allocated_sel,ax

	xor	di,di			; Initialize master object
	mov	[di].hi_first,bx	; Fill in pointers to first and
	mov	[di].hi_last,dx 	; last blocks
	mov	[di].hi_count,5 	; 5 arena entries
	or	ax,ax
	jnz	allocated_block
	mov	[di].hi_count,4 	; 4 arena entries
allocated_block:
	mov	[di].gi_lruchain,di	; Nothing in LRU list so far
	mov	[di].gi_lrucount,di
	mov	[di].gi_lrulock,di	; ...and not locked
	mov	[di].gi_reserve,di	; No discardable code reserve area yet

	cCall	get_physical_address, <dx>
	mov	word ptr [di].gi_disfence,ax		; gi_disfence = hi_last
	mov	word ptr [di].gi_disfence_hi,dx

	mov	[di].hi_hdelta,32

	mov	[di].gi_alt_first,-1	; Fill in pointers to first and
	mov	[di].gi_alt_last,-1	;  last blocks, the -1 is necessary!!
	mov	[di].gi_alt_count,di	; # of arena entries
	mov	[di].gi_alt_lruchain,di
	mov	[di].gi_alt_lrucount,di	; MUST be 0!
	mov	[di].gi_alt_free_count,di
	mov	[di].gi_alt_reserve,di
	mov	[di].gi_alt_disfence,di
	mov	[di].gi_alt_pPhantom,-1	; MUST be -1!

	mov	bx,ds
	SetKernelDS es
	mov	hGlobalHeap,bx
	cCall	get_arena_pointer,<ds>

	mov	es,ax
	assumes es,nothing
	mov	es:[di].ga_handle,bx	; Point master object to handle
	mov	es:[di].ga_count,0
	push	es:[di].ga_next		; Push free block arena

ife ROM
	mov	es, [di].hi_last
endif
	mov	es,es:[di].ga_prev	; Point to allocated object before
	mov	bx,allocated_sel
	StoH	bl			; It is moveable

	mov	es:[di].ga_handle,bx
	mov	hInitMem,bx
if ROM					; For ROM Windows, the alloc block is
	mov	es:[di].ga_count,1	;   krnl DS which needs to be locked!
else
	mov	es:[di].ga_count,0
endif
no_allocated_object:

; initialize free list

	mov	[di].gi_free_count,1
	mov	ax,[di].hi_first
	mov	cx,[di].hi_last
	mov	es,ax
	pop	bx				; Free block arena
	mov	es:[di].ga_freeprev,-1		; Fill in first sentinal
	mov	es:[di].ga_freenext,bx
	mov	es,cx
	mov	es:[di].ga_freeprev,bx		; Fill in last sentinal
	mov	es:[di].ga_freenext,-1
	mov	es,bx
	mov	es:[di].ga_freeprev,ax		; Link in free block
	mov	es:[di].ga_freenext,cx

GI_done:

;
; Allocate a block for the heap
;
        mov     ax,INITIAL_BLOCK_SIZE
        xor     si,si
        call    AllocDpmiBlock
        or      bx,bx
        jnz     ginom
        mov     si,1
ginom:  mov     dx,ax      
        call	FormatHeapBlock 	;build the arenas in the XMS block
	assume	es:NOTHING
        call    AddBlockToHeap

if ALIASES
	call	init_alias_list
endif

	mov	ax,hInitMem
	clc
	jmps	@f

GI_fail:
	xor	ax,ax
	stc
@@:

cEnd


gi_set_size	proc	near

	cCall	get_physical_address, <es:[di].ga_next>
	mov	bx, ax
	mov	cx, dx
	cCall	get_physical_address, <es>
	sub	bx, ax
	sbb	cx, dx
rept 4
	shr	cx, 1
	rcr	bx, 1
endm
	dec	bx
	mov	es:[di].ga_size, bx
	ret

gi_set_size	endp


;-----------------------------------------------------------------------;
; ginit									;
;									;
; Procedure to initialize the global heap.				;
;									;
;   The global heap looks as follows after this procedure returns:	;
;									;
;	BX - first object in arena, alway busy, zero length.		;
;	   - free object						;
;	AX - allocated object						;
;	DS - master object						;
;	DX - last object in arena, alway busy, zero length.		;
;									;
;									;
; Arguments:								;
;	AX = address of block to mark allocated.  May be zero.		;
;	BX = address of first paragraph in arena			;
;	DX = address of last  paragraph in arena			;
;	CX = initial size of master object, in bytes			;
;									;
;	Note: for the ROM kernel, AX is actually the size in bytes of	;
;	      the allocated block, not it's address.                    ;
;									;
; Returns:								;
;	AX = aligned address of block marked allocated.			;
;	BX = aligned address of first object in arena			;
;	CX = size of master object, in bytes				;
;	DX = aligned address of last object in arena			;
;	DS = aligned address of master object				;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;	DI,SI,ES							;
; Calls:								;
;	nothing								;
; History:								;
;									;
;  Thu Sep 11, 1986 04:22:02p  -by-  David N. Weise	[davidw]	;
; Commented it, made it handle the case of no allocated block correctly.;
;-----------------------------------------------------------------------;

cProc	ginit,<PUBLIC,NEAR>

	localW	size_free
	localW	size_allocated
	localW	size_master
	localW	allocated_arena
	localW	allocated_sel
	localW	BurgerMaster_arena
	localW	BurgerMaster_sel
	localW	new_last_sel
	localW	size_free_hi
	localW	marker_arena

cBegin

; SI = the first block address (sentinel, always busy)

	CheckKernelDS
	ReSetKernelDS
if ROM
	xchg	ax,dx				; want diff stack order if ROM
	mov	allocated_sel, ds		; something of a hack that this
						;   code 'knows' DS is the alloc
						;   block
endif
	push	ax
	push	dx

	cCall	get_physical_address,<bx>	; Start of our memory

%OUT Is alignment necessary???

	add	ax, GA_ALIGN_BYTES		; Align our start
	adc	dx, 0
	and	ax, GA_MASK_BYTES

	cCall	set_physical_address, <bx>
	mov	si, bx				; first sentinal
	mov	bx, 10h				; just an arena
	xor	cx, cx
	cCall	set_sel_limit, <si>

if ROM	;----------------------------------------------------------------

; The allocated block (kernel's data segment) is next, and already in place

	add	ax, 10h+GA_ALIGN_BYTES
	adc	dx, 0
	and	al, GA_MASK_BYTES
	push	ax
	cCall	alloc_data_sel,<dx,ax,1>	; Get arena for data seg
	mov	allocated_arena, ax
	pop	ax

if KDEBUG
	push	dx
	push	ax
	mov	cx,ax
	mov	bx,dx
	add	cx,10h
	adc	bx,0				; BX:CX better -> DS
	cCall	get_physical_address,<ds>
	cmp	ax,cx
	jne	rom_oh_no
	cmp	dx,bx
	jz	@f
rom_oh_no:
	Debug_Out "ginit: DS arena in wrong spot!"
@@:
	pop	ax
	pop	dx
endif
	pop	bx				; size of alloc block
	add	ax,bx
	adc	dx,0

	add	bx,15				; save size of alloc
	and	bl,NOT 15			;   block in paragraphs
	shr	bx,4
	mov	size_allocated,bx

endif ;ROM	---------------------------------------------------------


; CX = where the master object goes (second block)

	add	ax, 10h+GA_ALIGN_BYTES		; Skip past sentinal
	adc	dx, 0
	and	al, GA_MASK_BYTES
	push	ax
	cCall	alloc_data_sel,<dx, ax, 1>	; Get arena for BurgerMaster
	mov	BurgerMaster_arena, ax

	mov	cx, size GlobalInfo+1
	and	cl, NOT 1			; Word align selector table -
	mov	word ptr SelTableStart, cx	; it starts after GlobalInfo
     ;;;mov	ax, 8*1024			; Selector table length
	mov	ax, 8*1024*2			; Assume 8k sels * 2 bytes each
	test	[WinFlags], WF_ENHANCED 	; Slime to allow 286 krnl under
	jnz	@f				;   386enh mode where LDT grows
	mov	bx, gdtdsc
	or	bx, bx
	jz	@f				; If we party on the LDT,
	lsl	ax, bx				;   use the LDT limit to size
	add	ax, 1				;   the table
	rcr	ax, 1
	shr	ax, 1				; ASSUMES LDT DOES NOT GROW!!!
@@:
	mov	SelTableLen, ax
	add	cx, ax
	add	cx, GA_ALIGN_BYTES+10h		; Include arena header
	and	cl, GA_MASK_BYTES

	pop	ax				; DX:AX is address of arena
	mov	bx, cx
	shr	bx, 4				; length in paras
	dec	bx				; excluding arena header
	mov	size_master, bx
	push	ax				; Save start of master object arena
	push	dx
	add	ax, 10h
	adc	dx, 0
	cCall	alloc_data_sel, <dx, ax, bx>
	mov	BurgerMaster_sel, ax
	pop	dx
	pop	ax
	add	ax, cx			; Move past master object
	adc	dx, 0

; DI = the third block address (initial free block)

	cCall	alloc_data_sel,<dx, ax, 1>
	mov	di, ax				; First free block

; DX = the last block address (sentinel, always busy)

if ROM
	pop	dx
	cCall	get_physical_address,<dx>	; End of our world
else
	pop	ax
	xor	dx, dx
	REPT 4
	shl	ax, 1
	rcl	dx, 1
	ENDM
endif
	sub	ax, 10h
	sbb	dx, 0
	and	ax, GA_MASK_BYTES
	mov	bx, ax			; Save end of allocated block
	mov	cx, dx
	cCall	alloc_data_sel, <dx, ax, 1>
	mov	new_last_sel, ax	; Save it away

ife ROM ;----------------------------------------------------------------

	pop	ax			; Allocated Block
	cCall	get_physical_address, <ax>
	sub	ax, 10h			; Make room for arena
	sbb	dx, 0
	and	al, GA_MASK_BYTES	; "Align" it

	sub	bx, ax
	sbb	cx, dx			; Length in bytes
rept	4
	shr	cx, 1
	rcr	bx, 1
endm
	dec	bx			; Length in paras
	mov	size_allocated, bx

	push	ax
	cCall	alloc_data_sel, <dx, ax, 1>
	mov	allocated_arena, ax
	pop	ax
	add	ax, 10h
	adc	dx, 0
	push	ax
	cCall	alloc_data_sel, <dx, ax, 1000h>
	mov	allocated_sel, ax
	pop	ax

	sub	ax, 10h
	sbb	dx, 0				; Back to arena
	mov	bx, ax
	mov	cx, dx				; cx:bx = addr allocated arena

endif ;ROM	---------------------------------------------------------

	cCall	get_physical_address, <di>
	sub	bx, ax
	sbb	cx, dx			; Length in bytes of free block
rept	4
	shr	cx, 1
	rcr	bx, 1
endm
	sub	bx, 1			; Length in paras
	sbb	cx, 0
	mov	size_free, bx
	mov	size_free_hi, cx

	mov	ax, allocated_arena
	mov	cx, BurgerMaster_arena
	mov	dx, new_last_sel

; Fill in first block

	mov	ds,si
assumes ds, nothing
	xor	bx,bx
	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_size,GA_ALIGN
	mov	ds:[bx].ga_owner,-1
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_prev,ds	; first.prev = self
if ROM
	mov	ds:[bx].ga_next,ax	; Next is the allocated block
else
	mov	ds:[bx].ga_next,cx	; Next is master object
endif
	mov	ds:[bx].ga_handle,bx
	mov	ds:[bx].ga_lrunext,bx
	mov	ds:[bx].ga_lruprev,bx
	push	ds			; Save pointer to first block

; Fill in the last block (sentinel block)

	mov	ds,dx
	mov	ds:[bx].ga_sig,GA_ENDSIG
	mov	ds:[bx].ga_size,GA_ALIGN
	mov	ds:[bx].ga_owner,-1	; Always allocated
	mov	ds:[bx].ga_next,ds	; last.next = self
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_handle,bx
	mov	ds:[bx].ga_lrunext,bx
	mov	ds:[bx].ga_lruprev,bx
	push	ds			; Save pointer to last block
if ROM
	mov	ds:[bx].ga_prev,di	; Previous is free block
else
	mov	ds:[bx].ga_prev,ax	; Previous is allocated block
endif

; Fill in the allocated block

	mov	ds,ax
if ROM
	mov	ds:[bx].ga_next, cx	; next object is burger master
else
	mov	ds:[bx].ga_next, dx	; next object is sentinel
endif
	mov	dx,size_allocated
	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_size,dx
	mov	ds:[bx].ga_owner,-1
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_handle,bx
	mov	ds:[bx].ga_lruprev,bx
	mov	ds:[bx].ga_lrunext,bx
if ROM
	mov	ds:[bx].ga_prev, si	; Previous object is sentinal
else
	mov	ds:[bx].ga_prev, di	; Previous object is free block
endif

; Fill in free block

	mov	ds,di
if ROM
	mov	dx,new_last_sel
	mov	ds:[bx].ga_next, dx	; Next ojb is last block
else
	mov	ds:[bx].ga_next, ax	; Next obj allocated block
endif
	mov	dx,size_free

	cmp	size_free_hi, 0
	je	gi_small
	xor	dx, dx			; BOGUS VALUE!!
gi_small:

	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_owner,bx	; This is a free block
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_size,dx
	mov	ds:[bx].ga_prev,cx
	mov	ds:[bx].ga_handle,bx
	mov	ds:[bx].ga_lruprev,bx
	mov	ds:[bx].ga_lrunext,bx

; Fill in the master object

	mov	ds,cx
	mov	ds:[bx].ga_next,di
if ROM
	mov	ds:[bx].ga_prev,ax	; prev obj is allocated block
else
	mov	ds:[bx].ga_prev,si
endif
	mov	cx,size_master
	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_size,cx
	mov	ds:[bx].ga_owner,-3
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_handle,bx	; No handle table entry for this
					; moveable object yet.
	mov	ds:[bx].ga_lruprev,bx
	mov	ds:[bx].ga_lrunext,bx

; Initialize master object

					; CX = size of master object in paras
;;;	mov	dx, ds			; DX = address of master object

	mov	dx,BurgerMaster_sel

	shl	cx,1			; Get size of master object in words
	shl	cx,1
	shl	cx,1

	push	cx			; save size in words

	SetKernelDS
	mov	pGlobalHeap,dx
	mov	es,dx
	assumes es,nothing
	xor	ax,ax
	xor	di,di			; Init master object to zero
	rep	stosw

	mov	ds,dx			; Switch to master object as our DS
	UnSetKernelDS

	cCall	AssociateSelector,<ds,BurgerMaster_arena>

	pop	cx
	shl	cx,1			; CX = size of master object in bytes

	mov	ax, allocated_sel	; AX = address of allocated block
	cCall	AssociateSelector,<ax,allocated_arena>
	pop	dx			; DX = address of last block
	pop	bx			; BX = address of first block

cEnd

;-----------------------------------------------------------------------;
; init_alias_list
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 15-Jan-1990 23:59:36  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	init_alias_list,<PUBLIC,NEAR>

cBegin nogen
	push	ds
	SetKernelDS
	cCall	GlobalAlloc,<GA_ZEROINIT,0,256>
	or	ax,ax
	jz	ial_exit
	mov	sel_alias_array,ax
	mov	es,ax
	xor	di,di
	mov	es:[di].sa_size,256 - SIZE SASTRUC
	mov	es:[di].sa_allocated,(256 - (SIZE SASTRUC)) / (SIZE SAENTRY)
	mov	ax,1			; signify success
ial_exit:
	pop	ds
	ret
cEnd nogen



sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2glru.asm ===
TITLE	GLRU - Primitives for LRU management

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

DataBegin

;externB  EMSSwapDepth
externB  Kernel_InDOS
externB  Kernel_flags
;externW  curTDB
externW  loadTDB
externW  pGlobalHeap
;externW  hExeSweep


DataEnd

sBegin	CODE
assumes CS,CODE

externW  gdtdsc
externNP GetAccessWord
externNP  DPMIProc


;-----------------------------------------------------------------------;
; lrusweep								;
; 									;
; Searches all of the exe headers in the system for segments that have	;
; been accessed since the last time through.  For each segment found	;
; its referenced byte is reset and that segment is moved to the top	;
; of the lru chain.  This routine is called (default) every 4 timer	;
; ticks from the int 8 handler.						;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	nothing								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DX,DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,ES							;
;									;
; Calls:								;
;	glrutop								;
; 									;
; History:								;
; 									;
;  Tue Apr 21, 1987 06:22:41p  -by-  David N. Weise   [davidw]		;
; Added the check for discarded segments.				;
; 									;
;  Wed Apr 08, 1987 11:00:59a  -by-  David N. Weise   [davidw]		;
; Made it clear only the curTask's private handle table.		;
; 									;
;  Wed Feb 18, 1987 08:13:35p  -by-  David N. Weise   [davidw]		;
; Added the sweeping of the private handle tables.			;
; 									;
;  Tue Feb 10, 1987 02:11:40a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lrusweep,<PUBLIC,FAR>
cBegin nogen

	push	dx
	push	di
	push	si
	push	ds
	xor	di,di
	SetKernelDS
	cmp	kernel_InDOS,0		; SMARTDrive and EMS may be present
	jnz	dont_do_it		;  => disk buffers over the code segs 
	cmp	di,loadTDB		; Ignore interrupt if loading task
	jnz	dont_do_it
	mov	ds,pGlobalHeap
	UnSetKernelDS
	cmp	di,ds:[di].gi_lrulock	; Ignore interrupt if inside memory
	jz	do_it			;  manager
dont_do_it:
	jmps	sweepdone
do_it:

	mov	cx, ds:[di].gi_lrucount
	jcxz	stuff_it
	mov	si, ds:[di].gi_lruchain

	push	bx
	push	ds

;; For WOW dpmi will update the ACCESSED bits from the real LDT in NT on timer ticks
;; So it will not be totally accurate but will be accurate enough.  mattfe apr16 92

	mov	ds, gdtdsc			; Go grab it out of the LDT
sweep_loop:
	mov	es, si
	mov	si, es:[di].ga_lrunext
	mov	bx, es:[di].ga_handle

	sel_check bl

if KDEBUG
	test	ds:[bx].dsc_hlimit, DSC_DISCARDABLE
	jnz	sweep_ok
	INT3_WARN
sweep_ok:
endif
	test	ds:[bx].dsc_access, DSC_ACCESSED ; Segment accessed?
	jz	sweep_next
ifdef WOW
	push	cx
	xor	cx,cx
	mov	cl, ds:[bx].dsc_access
	and	cx, not DSC_ACCESSED
	DPMICALL 0009h
	pop	cx
	jnc	@f
	INT3_WARN
@@:
else
	and	ds:[bx].dsc_access, not DSC_ACCESSED
endif ; WOW

	pop	ds
	call	glrutop
	push	ds
	mov	ds, gdtdsc
sweep_next:
	loop	sweep_loop
	pop	ds
	pop	bx

stuff_it:



sweepdone:
	pop	ds
	pop	si
	pop	di
	pop	dx
	ret
cEnd nogen




;
; Entry:
;   DI == 0
;   DS:SI.gi_lruchain -> head of list
;   ES:0  -> arena header of object to insert
;   DX = 0 => insert at head of list
;      !=0 => insert at tail of list
;
; Exit:
;   BX,DX destroyed
;
cProc	LRUInsert,<PUBLIC,NEAR>
cBegin	nogen
	inc	ds:[si].gi_lrucount	; Increment count of LRU entries
	mov	bx,ds:[si].gi_lruchain	; BX = head of list
	or	dx,dx			; Inserting at head of chain?
	jnz	lruins0 		; No, tail so dont update head
	mov	ds:[si].gi_lruchain,es	; Yes, make new one the new head
lruins0:
	or	bx,bx			; List empty?
	jnz	lruins1
	mov	es:[di].ga_lruprev,es	; Yes, make circular
	mov	es:[di].ga_lrunext,es
	mov	ds:[si].gi_lruchain,es
	ret
lruins1:
	push	es			; Save ES
	push	bx			; ES = insertion point
	mov	bx,es			; BX = new
	mov	dx,es			; DX = new
	pop	es
	xchg	es:[di].ga_lruprev,bx
	mov	es,bx
	xchg	es:[di].ga_lrunext,dx
	pop	es
	mov	es:[di].ga_lruprev,bx
	mov	es:[di].ga_lrunext,dx
	ret
cEnd	nogen




;
; Entry:
;   DI == 0
;   DS:SI.gi_lruchain -> head of list
;   ES:0  -> arena header of object to insert
;
; Exit:
;   BX,DX destroyed
;
;
cProc	LRUDelete,<PUBLIC,NEAR>
cBegin	nogen

;
; This is basically a consistency check, in case we don't fix
; GlobalRealloc() for 3.1.
;
	push	ax
	mov	ax,es:[di].ga_lrunext
	or	ax,es:[di].ga_lruprev
	pop	ax

	jz	lrudel_ret

	dec	ds:[si].gi_lrucount	; Decrement count of LRU entries
	jnz	lrudel0
	mov	ds:[si].gi_lruchain,di	; List empty, zero LRU chain.
	mov	es:[di].ga_lruprev,di	; Zero pointers in deleted object
	mov	es:[di].ga_lrunext,di
	ret
lrudel0:
	mov	dx,es
	cmp	ds:[si].gi_lruchain,dx	; Are we deleting the head?
	jne	lrudel1
	mov	dx,es:[di].ga_lrunext
	mov	ds:[si].gi_lruchain,dx	; Yes, make it point to the next one
lrudel1:
	xor	bx,bx			; Zero pointers in deleted object
	xchg	es:[di].ga_lrunext,bx

	xor	dx,dx
	xchg	es:[di].ga_lruprev,dx
	push	es
	mov	es,dx
	mov	es:[di].ga_lrunext,bx
	mov	es,bx
	mov	es:[di].ga_lruprev,dx
	pop	es
lrudel_ret:
	ret
cEnd	nogen

;
; glruSetup
;
; INPUT: ES -> arena header
;	 DI = 0
;
; OUTPUT: ZF set: block is not on LRU list
;	  ZF clear:
;		SI = 0
;		
;
cProc	glruSetup,<PUBLIC,NEAR>
cBegin	nogen
	mov	bx,es:[di].ga_handle
	or	bx,bx
	jz	gsdone
	push	ax
	cCall	GetAccessWord,<bx>
	test	ah, DSC_DISCARDABLE
	pop	ax
	jz	gsdone			; not a discardable object
	xor	si,si
	or	sp,sp
gsdone:
	ret
cEnd	nogen




;-----------------------------------------------------------------------;
; glrutop								;
; 									;
; Moves a discardable object to the head of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = global arena of moveable object				;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:20:10p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrutop,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si
	call	glruSetup
	jz	glrutop1

	call	LRUDelete
	xor	dx,dx		    ; DX == 0 means insert at head
	call	LRUInsert
glrutop1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; glrubot								;
; 									;
; Moves a discardable object to the tail of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = global arena of moveable object				;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:20:10p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrubot,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si
	call	glruSetup
	jz	glrubot1

	call	LRUDelete
	mov	dx,sp		    ; DX != 0 means insert at tail
	call	LRUInsert
glrubot1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen




;-----------------------------------------------------------------------;
; glruadd								;
; 									;
; Adds a discardable object to the head of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = arena header of object					;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	AX,BX,CX,DX,DI,SI,DS						;
; 									;
; Registers Destroyed:							;
;	none								;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:23:35p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glruadd,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si

	call	glruSetup
	jz	glruadd1

	xor	dx,dx		    ; DX == 0 means insert at head
	call	LRUInsert
glruadd1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; glrudel								;
; 									;
; Removes a discardable object from the LRU chain.			;
; 									;
; Arguments:								;
;	ES:DI = arena header of object					;
;	DS:DI = address of global heap info				;
; 									;
; Returns:								;
;	Nothing.							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:36:49p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrudel,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si

	call	glruSetup
	jz	glrudel1

	call	LRUDelete
glrudel1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


if KDEBUG

;-----------------------------------------------------------------------;
; check_lru_list							;
; 									;
; Checks the glru list for consistency.					;
; 									;
; Arguments:								;
;	nothing								;
;									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
;									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Wed Oct 29, 1986 10:13:42a  -by-  David N. Weise   [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	check_lru_list,<PUBLIC,NEAR>

cBegin nogen

	push	ds
	SetKernelDS
	test	Kernel_flags,kf_check_free
	jnz	check_lru_too
	jmps	cll_ret
check_lru_too:
	push	ax
	push	bx
	push	cx
	push	dx
	push	es
	mov	ds,pGlobalHeap
	UnSetKernelDS
	xor	bx,bx
do_it_again:
	mov	ax,[bx].gi_lruchain
	mov	cx,[bx].gi_lrucount	; without ems gi_alt_count is 0
	or	cx,cx
        jnz     short_relative_jumps
	jmps	all_done
short_relative_jumps:
	push	ds
	push	bx
	mov	es,ax
check_chain_loop:
	mov	ds,es:[di].ga_lruprev
	mov	es,es:[di].ga_lrunext
	cmp	ds:[di].ga_lrunext,ax
	jz	prev_okay
	mov	bx, ax
	kerror	0FFh,<lru: prev bad>,ds,bx
	mov	ax, bx
prev_okay:
	cmp	es:[di].ga_lruprev,ax
	jz	next_okay
	mov	bx, ax
	kerror	0FFh,<lru: next bad>,bx,es
next_okay:
	mov	ax,es
	loop	check_chain_loop
	pop	bx
	pop	ds
	cmp	[bx].gi_lruchain,ax
	jz	all_done
	mov	cx, ax
	kerror	0FFh,<lru: count bad>,cx,[bx].gi_lrucount
all_done:
	or	bx,bx
	jnz	really_done
	mov	bx,gi_alt_lruchain - gi_lruchain
	jmp	do_it_again
really_done:
	pop	es
	pop	dx
	pop	cx
	pop	bx
	pop	ax
cll_ret:
	pop	ds
	ret

cEnd nogen

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\2gmoreme.asm ===
TITLE	GMOREMEM - More Global Memory Manager procedures

.xlist
include kernel.inc
include tdb.inc
include newexe.inc
include protect.inc
.list

	.286

DataBegin

externB Kernel_Flags
;externW hGlobalHeap
externW pGlobalHeap
externW curTDB
externW headTDB
externW cur_dos_PDB
externW Win_PDB
externW MaxCodeSwapArea

DataEnd

externFP CalcMaxNRSeg

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;externW MyCSDS

if SDEBUG
externNP DebugMovedSegment
endif

;if SWAPPRO
;externNP WriteDiscardRecord
;endif

externNP real_dos
externNP gcompact
externNP get_physical_address
externNP get_arena_pointer
externNP GetAccessWord
externFP CVWBreak
externNP GrowHeap

if LDCHKSUM
externNP ZeroSegmentChksum
endif


;-----------------------------------------------------------------------;
; genter                                                                ;
; 									;
; Enters a critical region for the global heap.				;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	DS:DI = address of GlobalInfo for global heap			;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Sep 29, 1986 03:05:33p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	genter,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	mov	ds,pGlobalHeap
	UnSetKernelDS
	xor	di,di
	inc	[di].gi_lrulock
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; gleave                                                                ;
; 									;
; Leaves a critical region for the global heap.				;
; 									;
; Arguments:								;
;	DS:DI = address of GlobalInfo for global heap			;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Sep 29, 1986 03:07:53p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gleave,<PUBLIC,NEAR>

cBegin nogen
	dec	ds:[gi_lrulock]
	jnz	gl_ret
	test	ds:[gi_flags],GIF_INT2
	jz	gl_ret
	and	ds:[gi_flags],NOT GIF_INT2
	pushf
	call	CVWBreak
gl_ret: ret

cEnd nogen


;-----------------------------------------------------------------------;
; gavail                                                                ;
; 									;
; Gets the available memory.						;
; 									;
; Arguments:								;
;	DX    = number of paragraphs wanted				;
;	DS:DI = master object						;
; Returns:								;
;	AX = #paragraphs available for the biggest block		;
;	DX = 0 								;
;									;
; Error Returns:							;
;	none								;
; 									;
; Registers Preserved:							;
;	DI,DS 								;
; Registers Destroyed:							;
;	BX,CX,SI,ES							;
; Calls:								;
;	gcompact							;
; 									;
; History:								;
;  Thu Apr 06, 1988 08:00:00a  -by-  Tim Halvorsen    [iris]		;
; Fix bug in computation of space available when GA_NOT_THERE object	;
; resides above discard fence.						;
;									;
;  Wed Oct 15, 1986 05:09:27p  -by-  David N. Weise   [davidw]          ;
; Moved he_count to ga_count.						;
; 									;
;  Sat Sep 27, 1986 09:37:27a  -by-  David N. Weise   [davidw]          ;
; Reworked it.								;
;-----------------------------------------------------------------------;

cProc	gavail,<PUBLIC,NEAR>
cBegin nogen
	mov	byte ptr [di].gi_cmpflags,0
	call	gcompact
	mov	es,[di].hi_first
	xor	dx,dx
loop_for_beginning:
	xor	ax,ax
	mov	es,es:[di].ga_next		; Next block
	cmp	es:[di].ga_sig,GA_ENDSIG	; End of arena?
	jnz	blecher
	jmp	all_done
blecher:
	cmp	es:[di].ga_owner,di		; Free?
	jz	how_big_is_it			; Yes
	mov	si,es:[di].ga_handle
	or	si,si				; Fixed?
	jz	loop_for_beginning		; Yes, next block
	cmp	es:[di].ga_count,0		; Locked?
	jne	loop_for_beginning		; Yes, next block
	push	ax
	cCall	GetAccessWord,<si>
	test	ah, DSC_DISCARDABLE
	pop	ax
	jz	loop_for_beginning		; No, next block

how_big_is_it:
	mov	ax,es:[di].ga_size		; Use this size
loop_for_bigness:
	mov	es,es:[di].ga_next		; Next block
	cmp	es:[di].ga_owner,di		; Free?
	jz	include_his_size		; Yes, include size

	cmp	es:[di].ga_sig,GA_ENDSIG	; End of arena?
	jz	all_done
	mov	si,es:[di].ga_handle
	or	si,si				; Fixed?
	jz	end_of_bigness			; Yes, stop looking
	cmp	es:[di].ga_count,0		; Locked?
	jne	end_of_bigness			; Yes, stop looking
	push	ax
	cCall	GetAccessWord,<si>
	test	ah, DSC_DISCARDABLE
	pop	ax
	jz	dont_include_him	; No, dont include in count then
include_his_size:			; Free or Discardable
	add	ax,es:[di].ga_size	; Increase availabe space
	inc	ax			; by size of this block
dont_include_him:			; Moveable
	jmp	loop_for_bigness

end_of_bigness:
	mov	si,es
	cmp	es:[di].ga_owner,GA_NOT_THERE
	jnz	nothing_not_there
	push	ax
	push	dx
	cCall	get_physical_address,<si>
	sub	ax,word ptr [di].gi_disfence_lo
	sbb	dx,word ptr [di].gi_disfence_hi
	jae	fence_lower
	pop	dx
	pop	ax
	jmps	nothing_not_there

fence_lower:
	REPT	4
	shr	dx,1
	rcr	ax,1
	ENDM
	mov	si,ax
	pop	dx
	pop	ax
	sub	ax,si
	jmps	all_done_1

nothing_not_there:
	cmp	ax,dx			; Did we find a bigger block?
	jbe	blech_o_rama		; No, then look again
	mov	dx,ax			; Yes, remember size
blech_o_rama:
	jmp	loop_for_beginning

all_done:
	sub	ax,[di].gi_reserve	; In case lower_land has little free.
	jb	all_done_2
all_done_1:
	cmp	ax,dx			; Did we find a bigger block?
	ja	gcsize
all_done_2:
	mov	ax,dx
gcsize:
	inc	ax			; Cheap bug fix
	or	ax,ax			; zero mem available?
	jz	gcfinal			; yes, return 0
	dec	ax			; Dont be too exact
	jz	gcfinal
	dec	ax
	jz	gcfinal
	dec	ax
gcfinal:
	and	al,GA_MASK		; round down to nearest alignment
	xor	dx,dx
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; greserve                                                              ;
; 									;
; Sets the size of the discardable code reserve area.			;
; If the new size is larger than the old size, it checks to see		;
; if there is enough room to support the new size.			;
; 									;
; Arguments:								;
;	AX = new greserve size						;
; 									;
; Returns:								;
;	CX = the largest greserve we can get				;
;	AX != 0  success						;
;	AX  = 0  failure						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	BX,DX,ES							;
; 									;
; Calls:								;
;	genter								;
;	gcompact							;
;	will_gi_reserve_fit						;
;	gleave								;
; 									;
; History:								;
; 									;
;  Sun 14-Jan-1990 13:42:59  -by-  David N. Weise  [davidw]		;
; The greserve must be twice as big as the largest non-resident 	;
; segment, because restarting a NP fault requires both caller and	;
; callee to be in memory.						;
;									;
;  Tue May 19, 1987 00:03:08p  -by-  David N. Weise   [davidw]		;
; Made it far.								;
;									;
;  Sat Sep 27, 1986 01:03:08p  -by-  David N. Weise   [davidw]          ;
; Made it perform according to spec and added this nifty comment block.	;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	greserve,<PUBLIC,FAR>,<si,di>	; FAR because of the gcompact below
	localW	new_size
cBegin
	call	genter
	add	ax, ax			; Double required so caller & callee
	add	ax,GA_ALIGN		;   both fit in memory
	and	al,GA_MASK
	mov	new_size,ax
	mov	si, ax

	mov	cx,[di].gi_reserve	; Get old size.
	jcxz	first_time		; Old size equal to zero?
	call	will_gi_reserve_fit
	jnc	new_okay
 
        call    GrowHeap
        call    will_gi_reserve_fit
        jnc     new_okay
        
try_compacting:
	mov	dx,new_size
	call	gcompact		; Try compacting to get new reserve
	call	will_gi_reserve_fit
	jnc	new_okay
	
will_not_fit:
	xor	ax,ax
	jmps	gr_exit

first_time:				; Things are strange at first
	mov	bx, ax
	xor	cx, cx
REPT 4
	shl	bx, 1
	rcl	cx, 1
ENDM
	cCall	get_physical_address,<[di].hi_last>
	sub	ax, bx
	sbb	dx, cx			; Address of gi_reserve

new_okay:
	mov	word ptr [di].gi_disfence_lo,ax
	mov	word ptr [di].gi_disfence_hi,dx
	mov	dx,new_size
	mov	[di].gi_reserve,dx
gr_exit:
	call	gleave
cEnd


;-----------------------------------------------------------------------;
; will_gi_reserve_fit                                                   ;
; 									;
; See if new size okay by scanning arena backwards.			;
; 									;
; Arguments:								;
;	SI = new greserve size						;
;	DS:DI = master object						;
;									;
; Returns:								;
;	DX:AX = gi_disfence						;
;	BX = amount of NOT THERE memory, such as EGA			;
;	CX = the largest greserve we can get				;
;	CF = 0  new size ok						;
;	CF = 1  new size NOT ok						;
;	ES:DI => arena below CODE segments				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	SI,DI,DS							;
; 									;
; Registers Destroyed:							;
;									;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Jul 12, 1987 08:13:23p  -by-  David N. Weise      [davidw]	;
; Added EMS support.							;
; 									;
;  Sat Sep 27, 1986 01:03:57p  -by-  David N. Weise   [davidw]          ;
; Rewrote it.								;
;-----------------------------------------------------------------------;

cProc	will_gi_reserve_fit,<PUBLIC,NEAR>
	localB	got_half
	localW	second_block
	localW	largest_block
	localW	fence_block
	localW	fence_offset
cBegin

	xor	ax,ax
	xor	bx,bx
	mov	got_half, al
	mov	fence_block, ax
	mov	largest_block, ax
	mov	second_block, ax

	mov	es,[di].hi_last
	mov	cx,[di].hi_count

how_much_space_loop:
	mov	es,es:[di].ga_prev
how_much_space_loop1:
	cmp	di,es:[di].ga_owner		; If free then include.
	jz	include_this_one
	test	es:[di].ga_flags,GA_DISCCODE	; If disccode then include.
	jz	end_block
include_this_one:
	add	ax, es:[di].ga_size	; Total the size of this block
	inc	ax			; include arena header
	loop	how_much_space_loop

end_block:
	cmp	ax, largest_block	; Track two largest blocks
	jbe	not_largest
	push	largest_block
	mov	largest_block, ax
	pop	second_block
	jmps	not_second
not_largest:
	cmp	ax, second_block
	jbe	not_second
	mov	second_block, ax
not_second:
	cmp	fence_block, di
	jne	skip_not_there
	cmp	si, ax			; This block big enough?
	jbe	set_fence
	cmp	got_half, 0
	jne	skip_not_there		; Already split requirement
	shr	si, 1
	cmp	si, ax			; Half fits?
	ja	no_good
	mov	got_half, 1		;  yes, will use this block
	jmps	skip_not_there
set_fence:
	sub	ax, si
	mov	fence_offset, ax	; Offset from next arena
	mov	ax, es:[di].ga_next
	mov	fence_block, ax
	jmps	skip_not_there
no_good:
	shl	si, 1			;  no, keep trying for full amount
skip_not_there:
	xor	ax, ax				; zero count
	cmp	es:[di].ga_owner,GA_NOT_THERE
	jne	thats_all_folks
skip_not_there_loop:
	add	bx,es:[di].ga_size
	dec	cx
	mov	es, es:[di].ga_prev
	cmp	es:[di].ga_owner, GA_NOT_THERE	; skip all not there blocks
	je	skip_not_there_loop
	jmps	how_much_space_loop1

thats_all_folks:
	mov	cx, second_block		; Return max of twice second
	shl	cx, 1				; largest block and the largest
	jnc	not_monstrously_huge		; block
	mov	cx, 0FFFDh
	jmps	time_to_go
not_monstrously_huge:
	cmp	cx, largest_block
	jae	time_to_go
	mov	cx, largest_block
time_to_go:
	cmp	got_half, 1
	jne	si_ok
	shl	si, 1
si_ok:
	cmp	cx, si				; Set CARRY for failure
	jc	failed
	push	bx
	push	cx
	cCall	get_physical_address,<fence_block>
	mov	bx, fence_offset
	xor	cx, cx
REPT 4
	shl	bx, 1
	rcl	cx, 1
ENDM
	add	ax, bx
	adc	dx, cx				; DX:AX is new fence
	pop	cx
	pop	bx
	clc					; Success
failed:
cEnd


;-----------------------------------------------------------------------;
; gnotify                                                               ;
; 									;
; This is where the hard job of updating the stacks and thunks happens.	;
; We only walk stacks and thunks for code and data (defined by being	;
; LocalInit'ed), not for resources or task allocated segments.		;
; 									;
; Arguments:								;
;	AL = message code						;
;	BX = handle							;
;	CX = optional argument						;
;	ES = address of arena header					;
; 									;
; Returns:								;
;	AX = return value from notify proc or AL			;
;	DS = current DS (i.e. if DATA SEG was moved then DS is updated.	;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI								;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jun 24, 1987 03:08:39a  -by-  David N. Weise   [davidw]		;
; Adding support for Global Notify.					;
; 									;
;  Wed Dec 03, 1986 01:59:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gnotify,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	di
	xor	ah,ah
	mov	di,cx
	mov	cx,ax
	mov	si,bx
	loop	notify_discard
	errnz	<GN_MOVE - 1>

;-----------------------------------------------------------------------;
;  Here for a segment that moved.					;
;-----------------------------------------------------------------------;

why_bother:

	mov	cx,ds
	cmp	cx,si			; Did we move DS?
	jne	notify_exit_0		; No, continue
notify_exit_0:
	jmp	notify_exit

notify_discard:
;;;;;;	loop	notify_exit
	loop	notify_exit_0
	errnz	<GN_DISCARD - 2>

;-----------------------------------------------------------------------;
;  Here for a segment discarded.					;
;-----------------------------------------------------------------------;

	xor	ax,ax
	test	bl,1
	jnz	notify_exit_0		; SDK is wrong, can't free fixed.
	push	ax
	cCall	GetAccessWord,<bx>
	test	ah, DSC_DISCARDABLE
	pop	ax
	jz	notify_exit_0

	test	es:[ga_flags],GAH_NOTIFY
	jnz	@F
	jmp	dont_bother_asking
@@:

	push	bx
	push	cx
	push	dx
	mov	ax,1
	mov	es,es:[ga_owner]
	cmp	es:[ne_magic],NEMAGIC
	jz	dont_ask		; doesn't belong to a particular task
	mov	ax,es
	SetKernelDS es
	push	HeadTDB 		; Look for TDB that owns this block.
find_TDB:
	pop	cx
	jcxz	dont_ask
	mov	es,cx
	UnSetKernelDS es
	push	es:[TDB_next]
	cmp	ax,es:[TDB_PDB]
	jnz	find_TDB
	pop	cx			; clear stack in 1 byte
	mov	cx,word ptr es:[TDB_GNotifyProc][0]	; paranoia
	cmp	cx,word ptr es:[TDB_GNotifyProc][2]
	jz	dont_ask
	push	ds
	SetKernelDS

;;;	xor	cx, cx			; bad Hack for Legend
;;;	cmp	ax, cur_dos_PDB		; Are we on task's PDB
;;;	je	nothing_to_hack		;   Yes, fine
;;;	mov	cx, cur_dos_PDB		; No, save the PDB to restore
;;;	push	ax
;;;	push	bx
;;;	mov	bx, ax
;;;	mov	cur_dos_PDB, bx		; And point us to the task's
;;;	mov	Win_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_dos
;;;	pop	bx
;;;	pop	ax
;;;nothing_to_hack:
;;;	push	cx			; Save old PDB (if any)

	push	Win_PDB			; Save current PDB
	mov	Win_PDB, ax		; Ensure it is the task's

	or	Kernel_Flags[1],kf1_GLOBALNOTIFY

	push	es:[TDB_GNotifyProc]+2	; push addr of func to call onto stack
	push	es:[TDB_GNotifyProc]

	push	bx			; push arg for notify proc

	mov	ax,ss			; Zap segment regs so DS
	mov	ds,ax			; doesn't get diddled by callee
	mov	es,ax

	mov	bx,sp
	call	dword ptr ss:[bx]+2
	add	sp,4			; clean up stack.

	SetKernelDS
	and	Kernel_Flags[1],not kf1_GLOBALNOTIFY

	pop	Win_PDB			; Restore PDB

;;;	pop	bx			; Saved PDB
;;;	or	bx, bx			; Was there one?
;;;	jz	@F			;   Nope.
;;;	push	ax
;;;	mov	ah, 50h			; Set it back...
;;;	mov	cur_dos_PDB, bx
;;;	mov	Win_PDB, bx
;;;	call	real_dos
;;;	pop	ax
;;;@@:
	
	pop	ds
	UnSetKernelDS

dont_ask:
	pop	dx
	pop	cx
	pop	bx
	or	ax,ax			; Well, can we?
	jz	notify_exit
dont_bother_asking:

	cCall	get_arena_pointer,<si>
	mov	es,ax
	mov	es,es:[ga_owner]
	cmp	es:[ne_magic],NEMAGIC
	jnz	not_in_exe
	mov	di,es:[ne_segtab]
	mov	cx,es:[ne_cseg]
	jcxz	not_in_exe
;	 test	 es:[ne_flags],NENOTP
;	 jnz	 pt0a
;	 inc	 bx
pt0a:
	cmp	bx,es:[di].ns_handle
	jz	pt0b
	add	di,SIZE NEW_SEG1
	loop	pt0a
	jmps	not_in_exe
pt0b:
	and	byte ptr es:[di].ns_flags,not NSLOADED	 ; Mark as not loaded.
not_in_exe:

why_bother_again:
	xor	di,di
if SDEBUG
	cCall	DebugMovedSegment,<si,di>
endif
if LDCHKSUM
	call	ZeroSegmentChksum	; SI points to segment
endif
	mov	ax,1
notify_exit:
	or	ax,ax
	pop	di
	pop	si
	ret

gn_error:
	kerror	0FFh,<gnotify - cant discard segment>,si,si
	xor	ax,ax
	jmp	notify_exit

cEnd nogen

;-----------------------------------------------------------------------;
; MemoryFreed								;
;									;
; This call is apps that have a GlobalNotify procedure.  Some apps	;
; may shrink the segment instead of allowing it to be discarded, or	;
; they may free other blocks.  This call tells the memory manager	;
; that some memory was freed somewhere. 				;
;									;
; Arguments:								;
;	WORD = # paragraphs freed					;
;									;
; Returns:								;
;	DX:AX = amount of memory that still needs freeing		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
;									;
;  Fri 08-Apr-1988 10:25:55  -by-  David N. Weise  [davidw]		;
; Wrote it!								;
;-----------------------------------------------------------------------;

cProc	MemoryFreed,<PUBLIC,FAR>

	parmW	memory_freed
cBegin
	xor	ax,ax
	SetKernelDS
	test	Kernel_Flags[1],kf1_GLOBALNOTIFY
	jz	mf_done
	mov	ds,pGlobalHeap
	UnSetKernelDS
	mov	ax,memory_freed
	or	ax,ax
	jz	mf_inquire
	or	ds:[hi_ncompact],1	; Remember we discarded something
	sub	ds:[hi_distotal],ax	; Have we discarded enough yet?
	ja	mf_inquire
	or	ds:[hi_ncompact],10h	; To tell gdiscard that we're done.
mf_inquire:
	mov	ax,ds:[hi_distotal]	; Have we discarded enough yet?
mf_done:
	xor	dx,dx

cEnd


;-----------------------------------------------------------------------;
; SetSwapAreaSize							;
; 									;
; Sets the current task's code swap area size.				;
; 									;
; Arguments:								;
;	WORD	== 0 then current size is just returned			;
; 		!= 0 number paragraphs wanted for swap area		;
; Returns:								;
;	AX = Size actually set						;
;	DX = Max size you can get					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Apr 18, 1988 08:00:00a  -by-  T.H. SpeedWagon  [-????-]		;
; Move routine into CODE segment, so applications can query the		;
; code working set value without paging in the NRESCODE segment.	;
; 									;
;  Thu Apr 23, 1987 09:36:00p  -by-  R.E.O. SpeedWagon [-???-]		;
; Added ability to get size without setting it.				;
; 									;
;  Wed Dec 03, 1986 10:52:16p  -by-  David N. Weise   [davidw]          ;
; Rewrote it.								;
;-----------------------------------------------------------------------;


cProc   SetSwapAreaSize,<PUBLIC,FAR>
	parmW	nParas
	localW	MxCodeSwapArea
cBegin
	SetKernelDS
	mov	ax,nParas
	xor	bx,bx
	mov	cx,MaxCodeSwapArea
	mov	MxCodeSwapArea,cx	; avoid a segment load later
	cmp	ax,cx
	jbe	requested_size_OK
	mov	ax,cx
requested_size_OK:
	mov	ds,CurTDB
	UnSetKernelDS
	mov	ds,ds:[bx].TDB_pModule	; Get exe header address
	or	ax,ax			; just a query request?
	jz	got_it			; yes
	cmp	ax,ds:[bx].ne_swaparea
	jz	got_it			; just want what we have?
	ja	calc_it

; To restart a NP fault both caller and callee must be in memory.
;  So we cheat here, and set the minimum to be twice the rmode number.
; We have to prevent the app from setting the swap area too
;  small.  So we recalculate the minimum needed.  We should
;  do this is rmode as well, but the chance of messing up is
;  much larger in pmode, where new app writers are apt to
;  be very cavalier with lots of memory.
; We should keep another NE variable instead of always
;  recalculating the largest ne_seg BUT at this late
;  date this is simpler!

	push	ax
	xor	ax,ax				; No max yet.
	mov	cx,ds:[bx].ne_cseg
	mov	bx,ds:[bx].ne_segtab
	jcxz	no_NR_segments
get_largest_loop:
	test	ds:[bx].ns_flags,NSDATA 	; Code segment?
	jnz	not_disc_code
	.errnz	NSCODE
	test	ds:[bx].ns_flags,NSDISCARD	; Discardable?
	jz	not_disc_code			; No, ignore.
	mov	dx,ds:[bx].ns_minalloc		; Yes, get size
	add	dx,0Fh				; in paragraphs
	shr	dx,4
	cmp	ax,dx			; Biggest NR Seg?
	jae	not_disc_code
	mov	ax,dx
not_disc_code:
	add	bx,SIZE NEW_SEG1
	loop	get_largest_loop
no_NR_segments:
	shl	ax,1
	mov	cx,ax
	pop	ax
	cmp	ax,cx
	ja	calc_it
	mov	ax,cx

calc_it:
	xchg	ds:[ne_swaparea],ax
	push	ax
	call	CalcMaxNRSeg
	pop	dx
	or	ax,ax
	jnz	got_it
	mov	ds:[ne_swaparea],dx
got_it:
	mov	ax,ds:[ne_swaparea]
	mov	dx,MxCodeSwapArea
	cmp	cx,dx
	ja	cant_get_that_much
	mov	dx,cx
cant_get_that_much:
cEnd

;
; SetReserve	- Sets gi_reserve to the given number of paragraphs
;
; Registers Destroyed:
;	AX, BX, DX
;

cProc	SetReserve,<PUBLIC,FAR>,<di>
	parmW	paras
cBegin
	SetKernelDS
	mov	ds, pGlobalHeap
	UnSetKernelDS
	xor	di,di
	mov	bx, paras
	mov	ds:[di].gi_reserve, bx
	shl	bx, 4
	cCall	get_physical_address,<ds:[di].hi_last>
	sub	ax, bx
	sbb	dx, di
	mov	ds:[di].gi_disfence_lo, ax
	mov	ds:[di].gi_disfence_hi, dx
cEnd


sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3galloc.asm ===
PAGE    ,132
        TITLE   GALLOC - Global memory allocator

.sall
.xlist
include kernel.inc
include protect.inc
include wowcmpat.inc
.list

.386

DataBegin

externB  Kernel_flags
externB  fBooting
externB  fCheckFree
externW  pGlobalHeap
externW  Win386_Blocks
externW  FreeArenaCount
         
gsearch_state_machine   dw      0
gsearch_compact_first   dw      0

        public ffixedlow
ffixedlow               db      0

DataEnd

sBegin  CODE
assumes CS,CODE

externNP gcompact
externNP gmovebusy
externNP gslide
externNP galign
externNP genter
externNP gleave
ifdef WOW
externFP MyGetAppWOWCompatFlagsEx
endif
externNP gwin386discard
externNP GetDPMIFreeSpace
externNP InnerShrinkHeap
          
externNP get_physical_address
externNP set_physical_address
externNP alloc_arena_header
externNP free_arena_header
ifndef WOW_x86
externNP get_blotto
endif
externNP PreallocArena
externNP DPMIProc

;-----------------------------------------------------------------------;
; gsearch                                                               ;
;                                                                       ;
; Searches from start to finish for a free global object to allocate    ;
; space from.  For a fixed request it tries to get the space as low as  ;
; possible, moving movable out of the way if neccessary.  For movable   ;
; requests it also starts at the bottom.  For discardable code it       ;
; starts from the top, only using the first free block it finds.        ;
;  If at first blush it can't find a block it compacts memory and tries ;
; again.                                                                ;
;  When it finally finds a block it gsplices it in, makes sure the      ;
; arena headers are fine, and returns the allocated block.              ;
;  Called from within the global memory manager's critical section.     ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocations flags                                          ;
;       EBX = #bytes                                                    ;
;       CX = owner field value                                          ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       AX = data address of block allocated or NULL                    ;
;       BX = ga_prev or ga_next                                         ;
;       DX = allocation flags                                           ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1                                                          ;
;       AX = 0                                                          ;
;       BX = ga_prev or ga_next                                         ;
;       DX = size of largest free block                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,DS                                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX,SI,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       galign                                                          ;
;       gfindfree                                                       ;
;       fmovebusy                                                       ;
;       gcheckfree                                                      ;
;       gcompact                                                        ;
;       gsplice                                                         ;
;       gzero                                                           ;
;       gmarkfree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;                                                                       ;
;  19-Aug-95 davehart:  Win 3.1 tries to grow the heap before           ;
;  compacting it, for WOW we want to compact first to be a good         ;
;  multitasking neighbor.                                               ;
;                                                                       ;
;  Wed Jul 22, 1987 11:15:19p  -by-  David N. Weise  [davidw]           ;
; Fixed BOGUS BLOCK freeing yet again.                                  ;
;                                                                       ;
;  Sun May 10, 1987 11:29:38p  -by-  David N. Weise  [davidw]           ;
; Added the state machine to handle the case of wanting to search       ;
; both global arenas.                                                   ;
;                                                                       ;
;  Sat Feb 28, 1987 06:31:11p  -by-  David N. Weise   [davidw]          ;
; Putting in support for allocating discardable code from EEMS land.    ;
;                                                                       ;
;  Tue Dec 30, 1986 01:54:50p  -by-  David N. Weise   [davidw]          ;
; Made sure it freed any bogus blocks created.                          ;
;                                                                       ;
;  Thu Nov 20, 1986 04:00:06p  -by-  David N. Weise   [davidw]          ;
; Rewrote it use the global free list.  Also made it put fixed requests ;
; as low as possible and to search again after a compact.               ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Tue Sep 23, 1986 04:35:39p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   gsearch,<PUBLIC,NEAR>
cBegin nogen

        CheckKernelDS   fs
        ReSetKernelDS   fs

        cmp     word ptr [di].gi_free_count, 96
        jae     short compact_first
        mov     gsearch_compact_first, 0
        mov     gsearch_state_machine,codeOFFSET grow_heap
        jmp     short look_again

compact_first:
        mov     gsearch_compact_first, 1
        mov     gsearch_state_machine,codeOFFSET do_compact_nodiscard

look_again:
        push    ebx                     ; Save requested size
        push    cx                      ; Save owner
        push    ax                      ; Save flags
        clc                             ; Instead of add
        call    galign                  ; Get requested size in EDX
        push    edx                     ; Save adjusted requested size

; see if there is any one free space large enough for the request first

        mov     cx,[di].gi_free_count
        jcxz    were_hosed_from_start
        mov     esi,[di].phi_first
is_there_one:
        mov     esi,ds:[esi].pga_freenext
        cmp     edx,ds:[esi].pga_size
        jbe     short got_one
        loop    is_there_one
were_hosed_from_start:
        jmp     space_not_found

got_one:
        mov     ebx,pga_prev            ; search backwards
        test    al,GA_ALLOCHIGH
        jz      short alloc_low

;------ allocate disc code -------

        public  alloc_high
alloc_high:
        mov     cx,[di].gi_free_count
        mov     esi,[di].phi_last               ; Start with last entry.
alloc_high_loop:
        mov     esi,ds:[esi].pga_freeprev
        cmp     edx,ds:[esi].pga_size
        jbe     afound                  ; Yes, exit search loop
        loop    alloc_high_loop
        jmp     space_not_found
           

;------ allocate moveable ---------

        public  alloc_low
alloc_low:
        mov     ebx,pga_next            ; Search forwards.
        test    al,GA_MOVEABLE
        jz      short alloc_fixed
        call    gcheckfree              ; Room for requested size?
        jb      space_not_found
        jmp     afound

;------ allocate fixed ------------

        public  alloc_fixed
alloc_fixed:
        mov     esi,[di].phi_first      ; Start with first entry.
        mov     cx,[di].hi_count
        mov     esi,ds:[esi+ebx]        ; Skip first sentinel

        ; maybe ALLOC_DOS or regular fixed.
        test    ah, GA_ALLOC_DOS
        jnz     alloc_fixed_loop
        test    fBooting, 2             ; are we past KERNEL loading
        jnz     alloc_fixed_loop        ; N: give him under 1MB line
        ; check to see if we want old behaviour
        ; this is to fix some mm drivers that mmsystem.dll will load
        test    ffixedlow, 1            ; want FIXED under 1MB?
        jnz     alloc_fixed_loop        ; Y: give him under 1MB line
        ; start fixed blocks > 1MB. This will leave room for GlobalDOSAllocs
        ; Memory < 1MB will also get used for moveable blocks as we start
        ; from phi_first for these. These can be moved out of the way when
        ; we need to alloc GA_DOS_ALLOC requests.

fast_forward_to_1MB_line:                       ; need to store this ptr
                                                ; for speed?
        cmp     ds:[esi].pga_address, 100000h   ; > 1Mb?
        jae     skip_not_there                  ; OK for fixed allocs now
        mov     esi,ds:[esi+ebx]
        loop    fast_forward_to_1MB_Line

        ; when here it means we have no free blocks > 1MB!!!
        ; but have a block < 1MB. space_not_found will discard
        ; enough to move blocks up to generate room for this fixed blk.
        jmp     space_not_found

skip_not_there:
if KDEBUG
        cmp     [esi].pga_owner, GA_NOT_THERE
        je      @f
        krDebugOut <DEB_ERROR OR DEB_KrMemMan>, "NOT_THERE block not there!"
@@:
endif
        mov     esi,ds:[esi+ebx]

alloc_fixed_loop:
        push    cx
        push    esi
        call    is_there_theoretically_enough_space
        cmp     eax,edx
        jb      short nope
        pop     esi
        pop     cx
        call    can_we_clear_this_space
        jz      short anext1
        call    gcheckfree              ; Yes, room for requested size?
        jb      short anext1
                                        ; Now we have enough free space,
                                        ; slide it back as far as possible.
        push    eax                     ; This is to prevent us blocking
        push    edx                     ; the growth of moveable blocks.
        push    ebx                     ; AND to keep pagelocked code together
        call    PreallocArena
        jz      short no_sliding

        mov     ebx, pga_prev           ; Sliding backwards
keep_sliding:
        call    gslide
        jnz     keep_sliding

no_sliding:
        pop     ebx
        pop     edx
        pop     eax

        pop     edx
        pop     cx
        test    ch, GA_ALLOC_DOS
        push    cx
        push    edx
        jz      afound
        cmp     ds:[esi].pga_address, 100000h   ; > 1Mb?
        jb      afound
        jmp     gsearch_fail

nope:
        or      eax,eax
        jz      short hosed_again
anext:
        add     sp, 6                   ; get rid of CX, ESI on the stack
anext1:
        mov     esi,ds:[esi+ebx]
        loop    alloc_fixed_loop
        jmps    and_again

hosed_again:
        pop     esi
        pop     cx
and_again:

; no one space big enough, try compacting

        public  space_not_found
space_not_found:
        pop     edx                     ; get adjusted size
        pop     ax                      ; get flags
        push    ax
        push    edx
;       test    al,GA_ALLOCHIGH
;       jnz     short ask_for_what_we_need
;       add     edx,0400h               ; ask for 1k more
;       jnc     short ask_for_what_we_need      ; no overflow
;       mov     edx,-1
ask_for_what_we_need:

        jmp     gsearch_state_machine
                
;------------------------------

public  do_compact_nodiscard            ; for debugging

do_compact_nodiscard:
        mov     gsearch_state_machine,codeOFFSET grow_heap

        ;
        ; Before growing the heap try compacting without
        ; discarding.  This step isn't executed unless there
        ; were 96 or more free blocks at entry to gsearch.
        ;

        test    ds:[di].gi_cmpflags, GA_NODISCARD
        jnz     short dcn_nodiscard

        or      ds:[di].gi_cmpflags, GA_NODISCARD
        call    gcompact
        and     ds:[di].gi_cmpflags, NOT GA_NODISCARD
        jmp     short over_compact

dcn_nodiscard:
        call    gcompact
        jmp     short over_compact


public  do_compact                      ; for debugging

do_compact:
        mov     gsearch_state_machine,codeOFFSET gsearch_fail

        ;
        ; If we tried compacting before and GA_NODISCARD was set,
        ; there is no need to compact again, since we already
        ; compacted with GA_NODISCARD before attempting to
        ; grow the heap.  If GA_NODISCARD was not set, our earlier
        ; compact forced it on, so it's worth trying again since
        ; we may be able to discard enough to satisfy the request.
        ;

        cmp     gsearch_compact_first, 0
        je      short @f
        test    ds:[di].gi_cmpflags, GA_NODISCARD
        jnz     short gsearch_fail

@@:
        call    gcompact

over_compact:
        pop     edx
        pop     ax
        pop     cx
        pop     ebx
        jmp     look_again

public  grow_heap                       ; for debugging

grow_heap:
        mov     gsearch_state_machine,codeOFFSET do_compact

        push    edx                     ; can we get the space from DPMI?
        call    GrowHeap
        pop     edx
        jnc     short over_compact      ; heap grew, go look again

        call    InnerShrinkHeap         ; try to give back DPMI blocks so DPMI
                                        ;   mmgr can defragment its memory
        jz      short do_compact        ; heap did not shrink

        push    edx                     ; gave some back, try to get it again
        call    GrowHeap
        pop     edx
        jnc     short over_compact      ; heap grew, go look again
doomed:

;------------------------------

public  gsearch_fail                    ; for debugging

gsearch_fail:                           ; get size of largest free block
        .errnz  doomed-gsearch_fail
        xor     edx,edx
        mov     cx,[di].gi_free_count
        jcxz    gs_failure
        mov     esi,[di].phi_first
largest_loop:
        mov     esi,ds:[esi].pga_freenext
        mov     eax,ds:[esi].pga_size
        cmp     edx,eax
        jae     short new_smaller
        mov     edx,eax
new_smaller:
        loop    largest_loop
gs_failure:
        pop     eax                     ; adjusted requested size
        pop     ax                      ; AX = flags

        pop     cx                      ; CX = owner field
        pop     eax                     ; waste requested size
        xor     eax,eax                 ; Return zero, with ZF = 1
        ret

; Here when we have a block big enough.
;   ES:DI = address of block
;   AX = size of block, including header
;   DX = requested size, including header
;   BX = ga_prev if backwards search and ga_next if forwards search

afound:
        mov     ecx,ds:[esi].pga_size   ; Use actual size of free block
        sub     ecx,edx                 ; (found size - requested size)
        jecxz   no_arena_needed
        call    PreallocArena
        jnz     short no_arena_needed

;
; Detect infinite loop here.  If we are out of arenas, and
; the compact failed once, then another one isn't going to do much
; good.
;
        cmp     gsearch_state_machine,codeOFFSET gsearch_fail
        je      gsearch_fail

        pop     edx                     ; get adjusted size
        pop     ax                      ; get flags
        push    ax
        push    edx
        and     ds:[di].gi_cmpflags, NOT (GA_NODISCARD+GA_NOCOMPACT)
        or      ds:[di].gi_cmpflags, COMPACT_ALLOC
        mov     edx, -1                 ; Discard the world!
        jmp     do_compact

no_arena_needed:
        mov     eax,ds:[esi].pga_freeprev
        call    gdel_free               ; remove the alloc block from freelist
        jecxz   aexitx
        cmp     bl,pga_prev             ; Yes, scanning forwards or backwards?
        je      short abackward         ; Backwards.
        call    gsplice                 ; FS:ESI = block we are allocating
        jmps    aexit                   ; EDX = block to mark as free
abackward:
        neg     edx
        add     edx,ds:[esi].pga_size   ; Scanning backwards.  Put extra space
        call    gsplice
        xchg    edx, esi
        jmps    aexit

; Here with allocated block
;   AX = data address or zero if nothing allocated
;   ES:DI = address of block to mark as busy and zero init if requested
;   EDX = address of block to mark as free

aexitx:
        xor     edx,edx                 ; Assume nothing extra to free
aexit:
        pop     ecx                     ; waste adjusted requested size
        pop     cx                      ; Restore flags
        pop     ds:[esi].pga_owner      ; Mark block as busy with owner field value
        add     sp, 4                   ; waste requested size
        mov     ds:[esi].pga_lruprev,edi
        mov     ds:[esi].pga_lrunext,edi

        push    esi
        mov     esi, edx                ; Free any extra space
        mov     edx, eax                ; Previous free block
        call    gmarkfree
        pop     esi

        mov     dx, cx
        mov     al,GA_SEGTYPE
        and     al,dl
        test    dh,GAH_NOTIFY
        jz      short no_notify
        or      al,GAH_NOTIFY
no_notify:
        mov     ds:[esi].pga_flags,al   ; Store segment type bits
        mov     eax,esi                 ; AX = address of client data

        test    cl,GA_ZEROINIT          ; Want it zeroed?
        jz      short aexit1            ; No, all done

        push    eax
ifdef WOW_x86
;; On NT we try never to set selectors when we don't need to since it is a
;; slow operation - a system call.  In this case we can use selector 23h
;; which points to all flat vdm memory as data
        push    es
        push    bx
        push    edi

        mov     bx,FLAT_SEL
        mov     es,bx

        mov     ecx,ds:[esi].pga_size   ; Yes, zero paragraphs
        push    ecx

        shr     ecx, 2                  ; # dwords to clear
        mov     edi, ds:[esi].pga_address
        xor     eax, eax

        cld
        rep     stos    dword ptr es:[edi]

        pop     ecx
        pop     edi
        pop     bx
        pop     es
else
        cCall   get_blotto
        mov     ecx,ds:[esi].pga_size   ; Yes, zero paragraphs
        push    bx
        mov     bx,ax                   ; from beginning of client data
        call    gzero                   ; zero them
        pop     bx
endif; WOW_x86
        pop     eax
aexit1:

        or      eax,eax
        ret                             ; Return AX points to client portion
        UnSetKernelDS   FS              ; of block allocated.
cEnd nogen                

;------------------------------------------------------------------
;
; ChangeAllocFixedBehaviour
; GlobalAlloc(FIXED) used to return address < 1MB if possible in 3.1
; It doesn't anymore in Chicago. You need to call this API if you
; want the old behaviour. Bad things will happen if you switch to old
; behaviour and forget to switch it back.
; MMSYSTEM.DLL loads some drivers that may expect this behaviour and
; they are the only callers of this fun. at the time of its writing.
; ENTRY = flags
;               0 = chicago behaviour
;               1 = win31 behaviour
; EXIT
;       old bahaviour before this change (can be used to restore)
;
;------------------------------------------------------------------

cProc   ChangeAllocFixedBehaviour,<PUBLIC,FAR>
        parmW   flags
cBegin
        GENTER32
        CheckKernelDS   FS
        ReSetKernelDS   fs

        mov     ax, flags
        xchg    al, ffixedlow

        GLEAVE32
cEnd

cProc   GrowHeap,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   FS
        ReSetKernelDS   fs
        cmp     FreeArenaCount, 4       ; 3 for below, 1 for a gsplice later
        jb      short gh_fail

        pushad        
        push    edx                     ; Save requested size
                                        ; If they want more than 64k, assume they
                                        ; want a big block and just allocate that amount.
        cmp     edx, 64*1024            ; Want more than 64k?
        jae     short ask_for_it        ;   yes, just round up
        mov     edx, 128*1024           ;   no, try for 128k
ask_for_it:                                                
        mov     ebx, edx
        add     ebx, 4096-1             ; Round up to 4k multiple
        and     bx, NOT (4096-1)

        cCall   MyGetAppWOWCompatFlagsEx ; check if we need to pad it
        test    ax, WOWCFEX_BROKENFLATPOINTER
        jz      short @f
        add     ebx, 4096*4             ; make it a bit bigger
@@:

        push    ebx                     ; Length we will ask for
        mov     cx, bx
        shr     ebx, 16
        DPMICALL 0501h                  ; Allocate Memory Block
                                        ; Get our memory
        jnc     short got_more_memory
        pop     ebx                     ; Toss length we asked for

                                        ; Couldn't get our 1st choice, how
        call    GetDPMIFreeSpace        ;   much is available
        mov     ebx, eax                ;   ebx = largest available

        pop     edx                     ; Requested size
        cmp     ebx, edx                ; Enough for request?
        jbe     SHORT gh_fail_pop

        push    edx                     ; Expected on stack below
        push    ebx                     ; Length we will ask for
        mov     cx, bx
        shr     ebx, 16
        DPMICALL 0501h                  ; Allocate Memory Block
                                        ; Get our memory
        jnc     short got_more_memory
        add     sp, 8                   ; Toss requested size & len asked for

gh_fail_pop:
        popad
gh_fail:
        stc                             ; No chance mate!
        ret
                                        ; Now we have a new block
                                        ; Sort it in to the heap
                                        ; Create NOT THERE blocks to
got_more_memory:                        ; bracket the new block
        inc     Win386_Blocks
        pop     edx                     ; Length of block allocated
if KDEBUG
        mov     eax, edx
        shr     eax, 16
        krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "GrowHeap: #ax#DX allocated"
endif
        shl     ebx, 16
        mov     bx, cx                  ; EBX has linear address
        pop     ecx                     ; Toss original length
        shl     esi, 16
        mov     si, di                  ; ESI has WIN386 handle
        xor     edi, edi
        cCall   alloc_arena_header,<ebx>
        mov     ecx, eax                ; First not there arena
        mov     [ecx].pga_size, edi
        mov     [ecx].pga_sig, GA_SIGNATURE
        mov     [ecx].pga_owner, GA_NOT_THERE
        mov     [ecx].pga_handle, di
        mov     [ecx].pga_flags, di
        mov     [ecx].pga_lrunext, esi  ; Save WIN386 handle here
        mov     [ecx].pga_lruprev, edi
        cCall   alloc_arena_header,<ebx>
        mov     [eax].pga_size, edx     ; Free block
        push    ebx                     ; Save address
        add     edx, ebx                ; Address of end of block
        mov     ebx, eax
        mov     [ecx].pga_next, ebx
        mov     [ebx].pga_prev, ecx
        mov     [ebx].pga_owner, di
        cCall   alloc_arena_header,<edx>
        mov     edx, eax
        mov     [ebx].pga_next, edx
        mov     [edx].pga_prev, ebx
        mov     [edx].pga_size, edi
        mov     [edx].pga_owner, GA_NOT_THERE
        mov     [edx].pga_handle, di
        mov     [edx].pga_flags, di
        mov     [edx].pga_sig, GA_SIGNATURE
        mov     [edx].pga_lrunext, edi
        mov     [edx].pga_lruprev, edi

        pop     eax                     ; Address of block
sort_it:
        mov     esi, [edi].phi_first
        cmp     eax, [esi].pga_address  ; Below start of heap?
        ja      short sort_loop         ;   no, sort it in
;       int     3                       ; [this code never reached]
        mov     [esi].pga_address, eax  ;   yes, adjust sentinel
        jmps    link_it_in              ; Sentinel now points to new block

sort_loop:
        mov     esi, [esi].pga_next
        cmp     [esi].pga_next, esi     ; At end?
        je      short sort_found        ;   yes, put here
        cmp     [esi].pga_owner, GA_NOT_THERE
        jne     short sort_loop
        mov     esi, [esi].pga_prev     ; Will go after previous block.

sort_found:                             ; Block will go after ESI
        cmp     [esi].pga_next, esi     ; This the sentinel?
        jne     short link_it_in        ;   no, link it in
        mov     eax, [edx].pga_address  ;   yes, adjust sentinel
        mov     [esi].pga_address, eax
        sub     eax, [di].gi_reserve    ; Adjust fence
        mov     [di].gi_disfence_lo, ax
        shr     eax, 16
        mov     [di].gi_disfence_hi, ax
        mov     esi, [esi].pga_prev     ; New block goes before sentinel

link_it_in:                             ; Link it in after ESI
        mov     [ecx].pga_prev, esi
        xchg    [esi].pga_next, ecx
        mov     [edx].pga_next, ecx
        mov     [ecx].pga_prev, edx

        add     [di].hi_count, 3        ; Three more entries in heap
        mov     esi, ebx
        xor     edx, edx
        call    gmarkfree               ; To be picked up next time around
        popad
        clc
        ret
        UnSetKernelDS   FS
cEnd nogen

; Input - DWORD - Old Arena offset from burgermaster
;
; Output - None

cProc   FreeHeapDib,<PUBLIC,FAR>
        parmD   OldArena
cBegin
	CheckKernelDS	FS
        ReSetKernelDS   fs

        ; Make sure arena before and after are GA_NOT_THERE
        mov     ebx,OldArena
        mov     edx,ds:[ebx].pga_prev
        cmp     ds:[edx].pga_owner,GA_NOT_THERE
        jne     short fhd5
        mov     ecx,ds:[ebx].pga_next
        cmp     ds:[ecx].pga_owner,GA_NOT_THERE
        je      short fhd7
fhd5:
if KDEBUG
        krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "FreeHeapDIB: Corrupt DIB Block"
endif
fhd7:
        ;Free all the three arenas. First fixup the arena list.
        ; edx - First GA_NOT_THERE arena
        ; ebx - Actual DIB arean
        ; ecx - Last GA_NOT_THERE arena

        mov eax,ds:[edx].pga_prev
        mov ebx,ds:[ecx].pga_next
        mov ds:[eax].pga_next,ebx
        mov ds:[ebx].pga_prev,eax


        mov ds:[edx].pga_handle,0
        cCall   free_arena_header,<edx>

        mov ds:[ecx].pga_handle,0
        cCall   free_arena_header,<ecx>

        mov edx,OldArena
        mov ds:[edx].pga_handle,0
        cCall   free_arena_header,<edx>

        xor     di,di
        sub     [di].hi_count, 3        ; Three less entries in heap
        dec     Win386_Blocks
	UnSetKernelDS	FS
cEnd

; Input - DWORD - Dib Address
;         DWORD - Old Arena offset from burgermaster
;
; Output - eax = new arena if operation successful
;          eax = NULL if operation failed

cProc   GrowHeapDib,<PUBLIC,FAR>
        parmD   OldArena
        parmD   NewAddress
cBegin
	CheckKernelDS	FS
	ReSetKernelDS	fs
	cmp	FreeArenaCount, 4	; 3 for below, 1 for a gsplice later
        jae     short ghd_start
        xor     eax,eax
	ret

        ; Now we have a new block. Sort it in to the heap. Create
        ; NOT THERE blocks as well.

ghd_start:
        inc     Win386_Blocks
        mov     ebx,OldArena
        mov     edx,ds:[ebx].pga_size   ; Length of block
if KDEBUG
	mov	eax, edx
	shr	eax, 16
        krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "GrowHeapDIB: #ax#DX allocated"
endif
        mov     ebx,NewAddress          ; Ebx is the address of new block
        mov     esi, ebx                ; ESI has WIN386 handle
	xor	edi, edi
	cCall	alloc_arena_header,<ebx>
	mov	ecx, eax		; First not there arena
	mov	[ecx].pga_size, edi
	mov	[ecx].pga_sig, GA_SIGNATURE
	mov	[ecx].pga_owner, GA_NOT_THERE
	mov	[ecx].pga_handle, di
	mov	[ecx].pga_flags, di
	mov	[ecx].pga_lrunext, esi	; Save WIN386 handle here
	mov	[ecx].pga_lruprev, edi
	cCall	alloc_arena_header,<ebx>
        mov     [eax].pga_size, edx     ; DIB block
	push	ebx			; Save address
	add	edx, ebx		; Address of end of block
	mov	ebx, eax
	mov	[ecx].pga_next, ebx
        mov     [ebx].pga_prev, ecx
        push    ecx
        mov     ecx,OldArena
        mov     ax, [ecx].pga_handle
        mov     [ebx].pga_handle,ax
        mov     ax, [ecx].pga_owner
        mov     [ebx].pga_owner,ax
        mov     al, [ecx].pga_count
        mov     [ebx].pga_count,al
        inc     [ebx].pga_count         ; make sure it doesn't move
        mov     al, [ecx].pga_pglock
        mov     [ebx].pga_pglock,al
        mov     al, [ecx].pga_flags
        mov     [ebx].pga_flags,al
        mov     al, [ecx].pga_selcount
        mov     [ebx].pga_selcount,al
        mov     [ebx].pga_lrunext, edi
        mov     [ebx].pga_lruprev, edi
        pop     ecx
	cCall	alloc_arena_header,<edx>
	mov	edx, eax
	mov	[ebx].pga_next, edx
	mov	[edx].pga_prev, ebx
	mov	[edx].pga_size, edi
	mov	[edx].pga_owner, GA_NOT_THERE
	mov	[edx].pga_handle, di
	mov	[edx].pga_flags, di
	mov	[edx].pga_sig, GA_SIGNATURE
	mov	[edx].pga_lrunext, edi
	mov	[edx].pga_lruprev, edi

	pop	eax			; Address of block
	mov	esi, [edi].phi_first
	cmp	eax, [esi].pga_address	; Below start of heap?
        ja      short ghd_sort_loop         ;   no, sort it in
;	int	3			; [this code never reached]
	mov	[esi].pga_address, eax	;   yes, adjust sentinel
        jmps    ghd_link_it_in              ; Sentinel now points to new block

ghd_sort_loop:
	mov	esi, [esi].pga_next
	cmp	[esi].pga_next, esi	; At end?
        je      short ghd_sort_found    ;   yes, put here
	cmp	[esi].pga_owner, GA_NOT_THERE
        jne     short ghd_sort_loop
	mov	esi, [esi].pga_prev	; Will go after previous block.

ghd_sort_found:                         ; Block will go after ESI
	cmp	[esi].pga_next, esi	; This the sentinel?
        jne     short ghd_link_it_in    ;   no, link it in
	mov	eax, [edx].pga_address	;   yes, adjust sentinel
	mov	[esi].pga_address, eax
	sub	eax, [di].gi_reserve	; Adjust fence
	mov	[di].gi_disfence_lo, ax
	shr	eax, 16
	mov	[di].gi_disfence_hi, ax
	mov	esi, [esi].pga_prev	; New block goes before sentinel

ghd_link_it_in:                         ; Link it in after ESI
	mov	[ecx].pga_prev, esi
	xchg	[esi].pga_next, ecx
	mov	[edx].pga_next, ecx
	mov	[ecx].pga_prev, edx

        add     [di].hi_count, 3        ; Three more entries in heap
        mov     eax,ebx
	UnSetKernelDS	FS
cEnd

;-----------------------------------------------------------------------;
; is_there_theoretically_enough_space
;
; Starting at the given arena checks to see if there are enough
;  continuous free and unlocked moveable blocks.
;
; Entry:
;       CX = arenas to search
;       EDX = size requested
;       DS = BurgerMaster
;       FS:ESI = arena to start from
;
; Returns:
;       EAX = 0 =>  not enough space and no more memory left to search
;       EAX = 1 =>  not enough space in this block, but maybe....
;        otherwise
;       EAX = size of block
;
; Registers Destroyed:
;       CX,ESI
;
; Registers Preserved:
;       BX,DX,DI,ES
;
; History:
;  Mon 05-Sep-1988 15:21:14  -by-  David N. Weise  [davidw]
; Moved it here from gsearch so that grealloc could use it as well.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   is_there_theoretically_enough_space,<PUBLIC,NEAR>
cBegin nogen

        xor     eax,eax
ittes:
        cmp     ds:[esi].pga_owner,di
        jne     short is_it_moveable
        add     eax,ds:[esi].pga_size
        push    ebx
        push    eax
        mov     bx,word ptr [di].gi_disfence_hi ; See if begin of reserve area
        shl     ebx, 16
        mov     bx,word ptr [di].gi_disfence_lo ;  is above end of free block
        mov     eax, ds:[esi].pga_address
        add     eax, ds:[esi].pga_size          ; Address of end of free block
        sub     eax,ebx           
        ja      short ittes_above_fence ; All below fence?
ittes_below_fence:
        pop     eax                     ;  yes, we can use it
        pop     ebx
        jmps    this_ones_free

ittes_above_fence:
        cmp     eax, ds:[di].gi_reserve
        jae     ittes_below_fence
        mov     ebx, eax                ; portion above the fence
        pop     eax                     ; Total size so far
        sub     eax,ebx                 ; No, Reduce apparent size of free block
        pop     ebx
        cmp     eax,edx
        jae     short theoretically_enough
        jmps    absolutely_not

is_it_moveable:
        cmp     ds:[esi].pga_owner,GA_NOT_THERE ; Against end of heap partition?
        je      short theoretically_not         ;   no room here.
        test    ds:[esi].pga_handle,GA_FIXED    ; See if movable.
        jnz     short theoretically_not
        cmp     ds:[esi].pga_count,0
        jne     short theoretically_not         ; See if locked.
        add     eax,ds:[esi].pga_size
this_ones_free:
        cmp     eax,edx
        jae     short theoretically_enough
        mov     esi,ds:[esi].pga_next
        loop    ittes

; For the case of gsearch we should never get here for two reasons.
;  1) It should be impossible to have no discardable code loaded, in
;  this case we would have failed in the above loop.  2) We checked
;  at the very start for a free block somewhere that could have
;  satisfied the request.  In our mucking around to load as low as
;  possible we destroyed this free block and we did not produce a free
;  block we could use.  However we know from debugging code in 2.03
;  that this happens extremely rarely.  Because of the rareness of
;  this event we will not try to recover, instead we simply fail the call.

absolutely_not:
        mov     eax,-1                  ; return EAX = 0
theoretically_not:
        inc     eax                     ; DX is even, => cmp the same.
theoretically_enough:
        ret
cEnd nogen



;-----------------------------------------------------------------------;
; can_we_clear_this_space
;
; Attempts to make a free space starting at the address moved in.
; To do this it moves moveable out of the area.  The only subtlety
; involves a free block that stradles the end of wanted area.  This
; may get broken into two pieces, the lower piece gets temporary marked
; as allocated and BOGUS, the upper piece will remain free.
;
; Entry:
;       CX = max number of blocks to look at
;       EDX = size wanted in bytes
;       DS = BurgerMaster
;       FS:ESI = beginning arena
;
; Returns:
;       ZF = 0
;        FS:ESI points to free space
;       ZF = 1
;        couldn't free the space up
;
; Registers Destroyed:
;       AX,SI
;
; History:
;  Mon 05-Sep-1988 16:48:31  -by-  David N. Weise  [davidw]
; Moved it out of gsearch so that grealloc could use it.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   can_we_clear_this_space,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   FS
        ReSetKernelDS   FS
        
        push    ecx
        push    esi
        cmp     di,[di].gi_free_count   ; any free blocks?
        jz      short cwcts_fail
        mov     eax, esi                ; Beginning of space we want.
        cmp     di,ds:[esi].pga_owner   ; Is it free?
        jnz     short can_we_move_it
        mov     ecx,edx
        cmp     ecx,ds:[esi].pga_size
        ja      short asdf
        or      eax,eax                 ; return ZF = 0
cwcts_fail:
        pop     esi
        pop     ecx
        ret

asdf:   mov     esi,ds:[esi].pga_next

        public can_we_move_it
can_we_move_it:
        push    ebx
        push    ecx
        push    edx
        push    esi
        cmp     ds:[esi].pga_owner,GA_BOGUS_BLOCK
        jnz     short not_bogus
        xor     edx,edx
        call    gmarkfree
        jmp     restart
not_bogus:
        mov     ebx, ds:[eax].pga_address
        add     ebx, edx                ; EBX is the end of the space we want
        mov     cx,[di].gi_free_count
        mov     edx,ds:[esi].pga_size   ; Yes, try to find a place for the
        mov     esi,[di].phi_first      ;  moveable block
look_loop:
        call    PreAllocArena           ; Needed for gmovebusy or gsplice
        jz      couldnt_clear_it
        mov     esi,ds:[esi].pga_freenext
        push    esi
        mov     esi, ds:[esi].pga_address
        cmp     esi, ds:[eax].pga_address ; It defeats our purpose to move the
        jb      short check_this_out      ;  block to a free space we want.
        cmp     esi, ebx
        jb      short is_there_hope
check_this_out:
        pop     esi
        push    eax
        call    gcheckfree
        push    ecx
        jb      short inopportune_free_space
        pop     ecx
        pop     eax

        pop     edx                     ; EDX = moveable block for gmovebusy
        mov     ebx,pga_next
        call    gmovebusy               ; Move moveable block out of the way
        mov     esi,edx                 ; Replace the ESI on the stack,
                                        ;  the free block may have grown
                                        ;  downward with the gmovebusy.
        pop     edx
        pop     ecx
        pop     ebx
        pop     ecx                     ; WAS pop esi but esi set above now
        pop     ecx
        jmp     can_we_clear_this_space

inopportune_free_space:
        pop     ecx
        pop     eax
        loop    look_loop
        jmps    couldnt_clear_it

        public is_there_hope
is_there_hope:
        pop     esi
        push    eax
        push    ecx

        mov     ecx, ds:[esi].pga_address
        add     ecx, ds:[esi].pga_size          ; ECX end of block
                                  
        mov     ax, [di].gi_disfence_hi
        shl     eax, 16
        mov     ax, [di].gi_disfence_lo         ; EAX == fence

        sub     eax, ecx                        ; Fence - End
        jae     short below_reserved            ; Block is below fence
        neg     eax                             ; End - Fence
        cmp     eax, ds:[di].gi_reserve
        jae     short below_reserved            ; Block is above reserved
        sub     ecx, eax                        ; End - (End - Fence)
                                                ; Gives Fence in ECX
below_reserved:
        sub     ecx, ebx                        ; Adjust size of free block
        jbe     inopportune_free_space          ; No room here

overlap:
        cmp     ecx,edx                         ; Is it big enough?
        jbe     short inopportune_free_space

        mov     edx, ebx
        sub     edx, ds:[esi].pga_address       ; Calculate overlap

        pop     ecx
        pop     eax

; cut off the first piece for the original alloc

        push    ds:[esi].pga_freeprev
        call    gdel_free
        call    gsplice

; DS:ESI = addr of block to mark as busy, FS:EDX = addr of block to mark as free

        mov     ds:[esi].pga_owner,GA_BOGUS_BLOCK
        mov     ds:[esi].pga_lruprev,edi
        mov     ds:[esi].pga_lrunext,edi
        mov     esi, edx
        pop     edx                     ; previous free block
        call    gmarkfree               ; Free any extra space
restart:
        pop     edx                     ; WAS pop es
        pop     edx
        pop     ecx
        pop     ebx
        pop     esi
        pop     ecx
        jmp     can_we_clear_this_space

; If here then failure! see if we made a bogus block!

couldnt_clear_it:
        pop     esi                     ; recover block we wanted moved
check_again:
        mov     edx,ds:[esi].pga_next
        cmp     edx, ds:[edx].pga_next    ; At end of arenas?
        je      short no_bogus_block      ;   Yes, let's go
        cmp     ds:[edx].pga_address, ebx ; EBX points to where bogus block
        ja      short no_bogus_block      ;   would be.
        je      short is_it_bogus
        mov     esi,edx
        jmps    check_again
is_it_bogus:
        cmp     ds:[esi].pga_owner,GA_BOGUS_BLOCK
        jnz     short no_bogus_block
        xor     edx,edx
        call    gmarkfree
no_bogus_block:

if KDEBUG
        mov     cx,[di].hi_count
        mov     esi,[di].phi_first
bogus_all:
        cmp     ds:[esi].pga_owner,GA_BOGUS_BLOCK
        jnz     short not_me
        int     3
not_me: mov     esi,ds:[esi].pga_next
        loop    bogus_all
endif
        pop     edx
        pop     ecx
        pop     ebx
        pop     esi
        pop     ecx
        xor     eax,eax                 ; return ZF = 1
        ret
        UnSetKernelDS   FS
cEnd nogen

;-----------------------------------------------------------------------;
; gcheckfree                                                            ;
;                                                                       ;
; Checks the size of the passed free block against the passed desired   ;
; size, making sure that the limitations of the code reserve area are   ;
; not violated for objects other than discardable code. It also checks  ;
; for Phantoms.                                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       FS:ESI = address of free block                                  ;
;       DX = #bytes needed                                              ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       CF = 0 block big enough                                         ;
;       EAX = apparent size of free block                               ;
;                                                                       ;
; Error Returns:                                                        ;
;       none                                                            ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu 27-Apr-1989  10:38:05   -by-  David N. Weise   [davidw]          ;
; Fixed this to work in pmode.                                          ;
;                                                                       ;
;  Thu Apr 02, 1987 10:45:22p  -by-  David N. Weise   [davidw]          ;
; Added Phantom support.                                                ;
;                                                                       ;
;  Tue Sep 23, 1986 05:54:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gcheckfree,<PUBLIC,NEAR>
cBegin nogen
        mov     eax,ds:[esi].pga_size   ; Compute size of free block
        test    byte ptr [di].gi_cmpflags,GA_DISCCODE
        jnz     short gcftest           ; Discardable code not restricted

        push    ebx
        mov     ebx, [di].phi_last              ; Last sentinel
        mov     ebx, ds:[ebx].pga_address
        cmp     ebx, ds:[esi].pga_address       ; Above sentinel?
        jbe     short gcftest1                  ;  yes, not in reserved area!
         
        push    eax  
        mov     bx,word ptr [di].gi_disfence_hi ; See if begin of reserve area
        shl     ebx, 16
        mov     bx,word ptr [di].gi_disfence_lo ;  is above end of free block
        add     eax, ds:[esi].pga_address       ; EAX address of end of block
        sub     ebx, eax
        pop     eax  
        jae     short gcftest1          ; Yes, return actual size of free block
        neg     ebx
        sub     eax,ebx                 ; No, Reduce apparent size of free block
        ja      short gcftest1          ; Is it more than what is free?

        xor     eax,eax                 ; Yes, then apparent size is zero
                                        ; Nothing left, set apparent size to 0
gcftest1:
        pop     ebx
        jmps    gcftest
gcfrsrv1:                               ; Yes, then apparent size is zero
        xor     eax,eax                 ; Nothing left, set apparent size to 0
gcftest:
        cmp     eax,edx                 ; Return results of the comparison
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gsplice [should be named gslice,                                      ;
;          since splice means combine two into one - donc]              ;
;                                                                       ;
; Splits one block into two.                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       EDX = size in bytes of new block to make                        ;
;       DS:ESI = address of existing block                              ;
;       DS:DI = address of global arena information structure           ;
;                                                                       ;
; Returns:                                                              ;
;       EDX = address of new block
;                                                                       ;
; Error Returns:                                                        ;
;       nothing                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,DX,DI,DS,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 23, 1986 03:50:30p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gsplice,<PUBLIC,NEAR>,<EAX,EBX>
cBegin

        mov     ebx,ds:[esi].pga_size
        sub     ebx,edx                 ; get size of 2nd new block made
        mov     eax, ds:[esi].pga_address
        add     eax, edx
        cCall   alloc_arena_header,<eax>

        inc     [di].hi_count           ; Adding new arena entry
        mov     ecx, eax
        xchg    ds:[esi].pga_next,ecx   ; and old.next = new
        mov     ds:[ecx].pga_prev,eax   ; [old old.next].prev = new

        mov     ds:[eax].pga_next,ecx   ; new.next = old old.next
        mov     ds:[eax].pga_prev,esi

        mov     ds:[eax].pga_size,ebx
        mov     ds:[eax].pga_sig,GA_SIGNATURE
        mov     ds:[eax].pga_owner,di   ; Zero owner & handle fields
        mov     ds:[eax].pga_flags,0    ; For good measure.
        mov     ds:[eax].pga_handle,di

        mov     ds:[esi].pga_size,edx

        mov     edx, eax
gsplice_ret:
cEnd

;-----------------------------------------------------------------------;
; gjoin                                                                 ;
;                                                                       ;
; Merges a block into his previous neighbor.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       FS:ESI = address of block to remove                             ;
;       DS:DI  = address of global arena information structure          ;
;                                                                       ;
; Returns:                                                              ;
;       nothing                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       nothing                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       gdel_free                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Tue Sep 23, 1986 03:58:00p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gjoin,<PUBLIC,NEAR>
cBegin nogen
if KDEBUG
        cmp     esi, ds:[esi].pga_prev
        jne     short ok
int 3
int 3
ok:
endif
        push    eax                     ; assumes one is on freelist
        push    edx
        dec     [di].hi_count
        call    gdel_free
        mov     eax,ds:[esi].pga_size
        mov     edx,ds:[esi].pga_next   ; Get address of block after
        mov     esi,ds:[esi].pga_prev   ; Get address of block before
        cCall   free_arena_header,<ds:[edx].pga_prev>   ; Free arena being removed
        mov     ds:[edx].pga_prev,esi   ; Fix up block after
        mov     ds:[esi].pga_next, edx  ; and the one before
        add     ds:[esi].pga_size,eax   ; Recompute size of block
        pop     edx
        pop     eax
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gzero                                                                 ;
;                                                                       ;
; Fills the given area with zeros.                                      ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = address of first paragraph                                 ;
;       ECX = Bytes to clear                                            ;
;                                                                       ;
; Returns:                                                              ;
;       BX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,DX,DI,SI,DS,ES                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX                                                              ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 23, 1986 04:08:55p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gzero,<PUBLIC,NEAR>
cBegin nogen

; Assumptions: on entry, BX contains selector to start of block, and is
; for a scratch descriptor that can be modified.  ECX contains the # of
; bytes to be zeroed.
  

        push    es
        push    eax
        push    edi
        push    ecx

        shr     ecx, 2                  ; # dwords to clear
        mov     es, bx
        xor     eax, eax
        xor     edi, edi

        cld
        rep     stos    dword ptr es:[edi]

        pop     ecx
        pop     edi
        pop     eax
        pop     es
        ret

cEnd nogen


;-----------------------------------------------------------------------;
; gmarkfree                                                             ;
;                                                                       ;
; Marks a block as free, coalesceing it with any free blocks before     ;
; or after it.  This does not free any handles.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       EDX     = the first free object before this one                 ;
;               0 if unknown                                            ;
;               Ring 1 if no free list update wanted                    ;
;               Ring 0 if free list update required                     ;
;       FS:ESI = block to mark as free.                                 ;
;       DS:DI  = address of global arena information structure          ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 1 if freed a fixed block                                   ;
;        DX = 0                                                         ;
;       ZF = 0 if freed a moveable block                                ;
;        DX = handle table entry                                        ;
;       FS:ESI = block freed (may have been coalesced)                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DS                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       none                                                            ;
;                                                                       ;
; Calls:                                                                ;
;       gjoin                                                           ;
;       gadd_free                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Nov 17, 1986 11:41:49a  -by-  David N. Weise   [davidw]          ;
; Added support for the free list of global partitions.                 ;
;                                                                       ;
;  Sun Nov 09, 1986 01:35:08p  -by-  David N. Weise   [davidw]          ;
; Made the debugging version fill all free space with CCCC.             ;
;                                                                       ;
;  Wed Sep 24, 1986 10:27:06p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gmarkfree,<PUBLIC,NEAR>
cBegin nogen

        call    gadd_free
        or      esi,esi
        jz      short gmf_exit

; Mark this block as free by clearing the owner field.

        mov     ds:[esi].pga_sig,GA_SIGNATURE
        mov     ds:[esi].pga_owner,di   ; Mark as free
        mov     ds:[esi].pga_flags,0    ; For good measure.

; Remember the handle value in DX, before setting to zero.

        xor     dx,dx
        xchg    ds:[esi].pga_handle,dx

; Try to coalesce with next block, if it is free

        push    ds:[esi].pga_prev       ; save previous block
        mov     esi,ds:[esi].pga_next   ; ESI = next block
        cmp     ds:[esi].pga_owner,di   ; Is it free?
        jne     short free2             ; No, continue
        call    gjoin                   ; Yes, coalesce with block we are freeing
free2:
        pop     esi                     ; ESI = previous block
        cmp     ds:[esi].pga_owner,di   ; Is it free?
        jne     short free3             ; No, continue
        mov     esi,ds:[esi].pga_next   ; Yes, coalesce with block we are freeing;
        call    gjoin
free3:
        cmp     ds:[esi].pga_owner,di   ; Point to free block?
        je      short free4             ; Yes, done
        mov     esi,ds:[esi].pga_next   ; No, leave ES pointing at free block
free4:
        call    gwin386discard
gmf_exit:
        or      dx,dx
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gadd_free                                                             ;
;                                                                       ;
; Links in the given partition into the global free list.               ;
;                                                                       ;
; Arguments:                                                            ;
;       EDX    = the first free object before this one                  ;
;               0 if unknown                                            ;
;               odd if no free list update wanted                       ;
;       DS:DI  = BurgerMaster                                           ;
;       FS:ESI = free global object to add                              ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun Nov 09, 1986 02:42:53p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   gadd_free,<PUBLIC,NEAR>
cBegin nogen
        push    eax
        push    edx

        test    dl,1
        jnz     short no_update_wanted

        or      esi,esi                 ; this happens with gmovebusy
        jz      short no_update_wanted
                      
        inc     [di].gi_free_count
        mov     edx, esi
        
need_a_home_loop:
        mov     edx, ds:[edx].pga_prev
        cmp     ds:[edx].pga_owner, di          ; Found a free block?
        je      short found_a_home
        cmp     ds:[edx].pga_prev, edx          ; Sentinel?
        jne     short need_a_home_loop
        
found_a_home:
        mov     eax, ds:[edx].pga_freenext
        mov     ds:[esi].pga_freenext, eax
        mov     ds:[esi].pga_freeprev, edx
        mov     ds:[edx].pga_freenext, esi
        mov     ds:[eax].pga_freeprev, esi

if KDEBUG
        call    check_free_list
endif
gaf_exit:
no_update_wanted:
        pop     edx
        pop     eax
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gdel_free                                                             ;
;                                                                       ;
; Removes a partition from the global free list.                        ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:DI = BurgerMaster                                            ;
;       FS:ESI = arena header of partition                              ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun Nov 09, 1986 02:43:26p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   gdel_free,<PUBLIC,NEAR>
cBegin nogen

        push    edi
        push    esi
        mov     edi,ds:[esi].pga_freeprev
        mov     esi,ds:[esi].pga_freenext
        mov     ds:[edi].pga_freenext,esi
        mov     ds:[esi].pga_freeprev,edi
        pop     esi
        pop     edi

        dec     [di].gi_free_count
if KDEBUG
        call    check_free_list
endif
        ret
cEnd nogen


if KDEBUG
;-----------------------------------------------------------------------;
; check_free_list                                                       ;
;                                                                       ;
; Checks the global free list for consistency.                          ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Oct 29, 1986 10:13:42a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   check_free_list,<PUBLIC,NEAR>
cBegin nogen
        push    eax
        push    ebx
        push    cx
        push    esi
        push    ds
        SetKernelDS
        cmp     fCheckFree,0
        jnz     short cfl_outta_here
        test    Kernel_flags,kf_check_free
        jnz     short cfl_check_it_out
cfl_outta_here:
        jmp     all_done
cfl_check_it_out:
        mov     ds,pGlobalHeap
        UnSetKernelDS
        mov     esi,[di].phi_first
        mov     cx,[di].gi_free_count
        or      cx,cx
        jz      all_done
        mov     eax, ds:[esi].pga_freenext
        mov     esi, eax
check_chain_loop:
        mov     ebx,ds:[esi].pga_freeprev
        mov     esi,ds:[esi].pga_freenext
        cmp     ds:[ebx].pga_freenext,eax
        jz      short prev_okay
prev_bad:
        push    esi
        mov     esi, eax
        kerror  0FFh,<free_list: prev bad>,bx,si
        mov     eax, esi
        pop     esi
prev_okay:
        cmp     ds:[esi].pga_freeprev,eax
        jnz     short next_bad
        mov     ebx,esi
        jmps    next_okay
next_bad:
        mov     bx, ax
        kerror  0FFh,<free_list: next bad>,bx,es
next_okay:
        mov     eax,esi
        loop    check_chain_loop
        SetKernelDS
        mov     ds,pGlobalHeap
        UnSetKernelDS
        cmp     [di].phi_last,eax
        jz      short all_done
        mov     bx, ax
        kerror  0FFh,<free_list: count bad>,[di].phi_last,bx
all_done:
        pop     ds
        pop     esi
        pop     cx
        pop     ebx
        pop     eax
        ret
cEnd nogen

endif

cProc   ValidateFreeSpaces,<PUBLIC,FAR>
cBegin nogen
        ret
cEnd nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3gcompac.asm ===
TITLE   GCOMPACT - Global memory compactor

.sall
.xlist
include kernel.inc
.list

WM_COMPACTING   = 041h

.386p

include protect.inc

DataBegin

externB  Kernel_Flags
externW  WinFlags
externW  Win386_Blocks
externW  PagingFlags
externD  gcompact_start
externD  gcompact_timer
externD  pPostMessage
externD  NextCandidate

fSwitchStacks   DB  0
fUpDown         DB  0

DataEnd

externFP GlobalCompact
ifdef WOW
externFP VirtualFree
endif

sBegin  CODE
assumes CS,CODE
assumes fs, nothing

externNP glrudel
externNP gmarkfree
externNP gcheckfree
externNP gdel_free
externNP gsplice
externNP gnotify
externNP genter
externNP gleave
externNP Enter_gmove_stack
externNP Leave_gmove_stack

if KDEBUG
externFP ValidateFreeSpaces
endif

externNP set_selector_address32
ifndef WOW_x86
externNP get_rover_232
endif
externNP AssociateSelector32
externNP alloc_arena_header
externNP free_arena_header
externNP mark_sel_NP
externNP PreAllocArena
externNP DPMIProc
externNP get_physical_address

if KDEBUG
externNP CheckGlobalHeap
endif

;-----------------------------------------------------------------------;
; gcompact                                                              ;
;                                                                       ;
; Compacts the global heap.                                             ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = minimum #contiguous bytes needed                           ;
;       DS:DI = address of global heap information                      ;
;                                                                       ;
; Returns:                                                              ;
;       AX = size of largest contiguous free block                      ;
;       ES:DI = arena header of largest contiguous free block           ;
;       DX = minimum #contiguous bytes needed                           ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       gcmpheap                                                        ;
;       gcheckfree                                                      ;
;       gdiscard                                                        ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Sep 25, 1986 05:34:32p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gcompact,<PUBLIC,NEAR>
cBegin nogen

        CheckKernelDS   fs
        ReSetKernelDS   fs
        push    esi
        smov    es,40h
        mov     ax,es:[6Ch]             ; get the BIOS ticker count
        sub     gcompact_timer.lo,ax
        or      Kernel_Flags[1],kf1_MEMORYMOVED

        mov     si, [di].gi_cmpflags
        push    si
        push    si
        test    WinFlags[1], WF1_PAGING
        jz      short @F
                                                ; First time:
        or      [di].gi_cmpflags, GA_NOCOMPACT  ;  No movement
@@:
gcompactl:                   
if KDEBUG
        call    ValidateFreeSpaces
endif
        push    edx                     ; Save requested size
ife ROM
        cmp     [di].gi_reserve,edi     ; Is there a reserve swap area?
        je      short gcompact1         ; No, then dont compact lower heap
endif
        mov     esi,[di].phi_first      ; Yes, compact lower heap
        mov     ebx,pga_next
        call    gcmpheap
gcompact1:
        mov     esi,[di].phi_last       ; Compact upper heap
        mov     ebx,pga_prev
        call    gcmpheap
        pop     edx                     ; Get requested size
        mov     esi,eax                 ; ES points to largest free block
        or      eax,eax                 ; Did we find a free block?
        jz      short gcompact2         ; No, try discarding
        call    gcheckfree              ; Yes, see if block big enough
        jae     short gcompactxx        ; Yes, all done
gcompact2:                              ; Discarding allowed?
        cmp     [di].hi_freeze,di       ; Heap frozen?
        jne     short gcompactxx        ; Yes, return
        test    [di].gi_cmpflags,GA_NODISCARD
        jnz     short gcompactx         ; No, return
        test    WinFlags[1], WF1_PAGING
        jnz     short @F
        test    [di].gi_cmpflags, GA_NOCOMPACT  ; Ignore flag if paging
        jnz     short gcompactx                               
@@:
        push    esi
        call    gdiscard                ; No, try discarding
        pop     ecx                     ; Saved ESI may be bogus if gdiscard
                                        ; discarded anything...
        jnz     short gcompactl         ; Compact again if anything discarded
        mov     esi, ecx                ; Nothing discarded so ES OK.

gcompactx:
        test    WinFlags[1], WF1_PAGING
        jz      short gcompactxx
        pop     si                      ; Original flags
        mov     [di].gi_cmpflags, si
        or      si, GA_NOCOMPACT+GA_NODISCARD   
        push    si                      ; Abort next time
        test    [di].gi_cmpflags, GA_NOCOMPACT
        jz      short gcompactl               

gcompactxx:
        add     sp,2                    ; Toss working flags
        push    ax
        push    dx
        push    es
        mov     ax,40h
        mov     es,ax
        mov     ax,es:[6Ch]
        mov     si,ax
        cmp     pPostMessage.sel,0      ; is there a USER around yet?
        jz      short tock
        add     gcompact_timer.lo,ax
        sub     ax,gcompact_start.lo
        cmp     ax,546                  ; 30 secs X 18.2 tics/second
        jb      short tock
        cmp     ax,1092                 ; 60 secs
        ja      short tick
        mov     cx,gcompact_timer.lo    ; poor resolution of timer!
        jcxz    short tick
        xchg    ax,cx
        xor     dx,dx
        xchg    ah,al                   ; shl 8 DX:AX
        xchg    dl,al
        div     cx
        cmp     ax,32                   ; < 12.5% ?
        jb      short tick
        mov     ah,al
        mov     bx,-1                   ; broadcast
        mov     cx,WM_COMPACTING
        xor     dx,dx
        cCall   pPostMessage,<bx, cx, ax, dx, dx>
tick:   mov     gcompact_start.lo,si
        mov     gcompact_timer.lo,0
tock:   pop     es
        pop     dx
        pop     ax
        pop     [di].gi_cmpflags
        pop     esi                     ; Restore SI
        ret
        UnSetKernelDS   fs
cEnd nogen


;-----------------------------------------------------------------------;
; gcmpheap                                                              ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       EBX = pga_prev or pga_next                                      ;
;       EDX = minimum #contiguous bytes needed                          ;
;       DS:DI = address of global heap information                      ;
;       FS = Kernel DATA                                                ;
;                                                                       ;
; Returns:                                                              ;
;       EAX = largest free block                                        ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,CX                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       gslide                                                          ;
;       gbestfit                                                        ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Sep 25, 1986 05:38:16p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   gcmpheap,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   fs
        ReSetKernelDS   fs
        mov     NextCandidate, -1
        xor     eax,eax                 ; Nothing found yet
        push    eax                     ; Save largest free block so far
gchloop:
        cmp     ds:[esi].pga_owner,di
        je      short gchfreefnd
        cmp     ds:[esi].pga_owner, GA_NOT_THERE
        jne     short gchnext
        mov     NextCandidate, -1
gchnext:
        mov     esi, ds:[esi+ebx]
        cmp     esi, ds:[esi+ebx]       ; Sentinel?
        jne     short gchloop           ;   no, continue

gchexit:
        pop     eax                     ; Return largest free block in AX
        ret

gchfreefnd:
        test    [di].gi_cmpflags,GA_NOCOMPACT
        jnz     short gchmaxfree        ; No, just compute max free.
        cmp     [di].hi_freeze,di       ; Heap frozen?
        jne     short gchmaxfree        ; Yes, just compute max free.
        push    esi
        test    [di].gi_cmpflags,COMPACT_ALLOC
        jz      short no_hack
        call    gcheckfree              ; Allocating, this big enough?
        jb      short no_hack           ; yes, STOP NOW!
        cmp     bl,pga_prev             ; Compacting upper heap?
        jnz     short no_hack
        test    [di].gi_cmpflags,GA_DISCCODE
        jz      short no_hack
        cmp     edx,ds:[esi].pga_size
        ja      short no_hack
        mov     esi,ds:[esi].pga_next
        test    ds:[esi].pga_flags,GA_DISCCODE
        jnz     short hack
        cmp     ds:[esi].pga_owner,GA_SENTINAL
        jz      short hack
        cmp     ds:[esi].pga_owner,GA_NOT_THERE
        jnz     short no_hack
hack:
        pop     esi
        pop     eax
        mov     eax,esi
        ret

no_hack:
        pop     esi
        test    byte ptr WinFlags[1], WF1_PAGING        ; Paging?
        jnz     short best_it                           ;  yes, don't slide                     
        call    PreAllocArena
        jz      short gchmaxfree
        push    edx
        call    gslide
        pop     edx
        jnz     short gchfreefnd
best_it:
        push    edx
        call    gfirstfit
        pop     edx
gchmaxfree:
        cmp     bl,pga_prev             ; Compacting upper heap?
        jne     short gchnext           ; No, dont compute largest free block
        cmp     ds:[esi].pga_owner,di   ; Is current free?
        jne     gchnext                 ; No, ignore it then
        pop     eax                     ; Recover largest free block so far
        push    edx
        cmp     esi,eax                 ; Same as current?
        je      short gchmf2            ; Yes, no change then
        push    eax
        cmp     ds:[di].gi_reserve,edi  ; Is there a code reserve area?
        je      short gchmf0                    ; No, continue
        test    ds:[di].gi_cmpflags,GA_DISCCODE ; If allocating disc
        jnz     short gchmf0                    ;  code ignore the fence
        mov     ax, [di].gi_disfence_hi
        shl     eax, 16
        mov     ax, [di].gi_disfence_lo
        mov     edx, ds:[esi].pga_size          ; Size of this block
        add     edx, ds:[esi].pga_address       ; End of this block
        sub     eax, edx                        ; Fence above it?
        jae     short gchmf0                    ;   yes, use the whole block
        neg     eax                             ; Amount above the fence
        cmp     eax, ds:[di].gi_reserve         ; Above reserve?
        jae     short gchmf0                    ;   yes, use all of it
        sub     edx, eax                        ; Subtract off that above fence
        ja      short gchmf00                   ; Use as size of block
        pop     eax
        jmps    gchmf2
        
gchmf0:
        mov     edx, ds:[esi].pga_size  ; Size of this block
gchmf00:
        pop     eax
        or      eax,eax                 ; First time?
        jz      short gchmf1            ; Yes, special case
        cmp     edx, ds:[eax].pga_size  ; Is it bigger?
        jb      short gchmf2            ; No, do nothing
gchmf1:
        mov     eax,esi                 ; Yes, remember biggest free block
gchmf2:
        pop     edx
        push    eax                     ; Save largest free block so far
        test    PagingFlags, 2          ; Idle time compaction!
        jnz     gchexit
        jmp     gchnext                 ; Go process next block
        UnSetKernelDS   fs
cEnd nogen


;-----------------------------------------------------------------------;
; gslide                                                                ;
;                                                                       ;
; Sees if next/previous block can slide into the passed free block.     ;
;                                                                       ;
; Arguments:                                                            ;
;       FS:ESI = free block                                             ;
;       DS:DI = address of global heap information                      ;
;       CX = #arena entries left to examine                             ;
;       EBX = pga_next or pga_prev                                      ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 0 if block found and moved into passed free block          ;
;               FS:ESI points to new free block                         ;
;               FS:EDX points to new free block                         ;
;                                                                       ;
;       ZF = 1 if no block found                                        ;
;               FS:ESI points to original free block                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       EAX,EDX                                                         ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Sep 25, 1986 05:58:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gslide,<PUBLIC,NEAR>
cBegin nogen
        push    esi
        mov     esi,ds:[ebx+esi]
        mov     edx,esi                 ; Source of move in EDX
        call    gmoveable
        pop     esi
        jz      short gslide_no_move
        call    gmovebusy               ; Handle exact fits etc!!
        call    gpagingcandidate
if KDEBUG
        cmp     edx, ds:[esi+ebx]       ; Are we adjacent?
        je      short gslide_adjacent   
        int 3
        int 3
gslide_adjacent:
endif
        mov     esi, edx
        or      esi, esi                ; ZF = 0
gslide_no_move:
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gmove                                                                 ;
;                                                                       ;
; Moves a moveable block into the top part of a free block.  The low    ;
; order bit of the source and destination may be either set or reset.   ;
; If set, then this routine does NOT move the arena header paragraph.   ;
; If the bit is reset, then the arena header is moved.  Only the low    ;
; order bit of EDX is examined, and the low order bit of ESI is assumed ;
; to the same.                                                          ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:DI = master object                                           ;
;       ES:0    = address of destination block                          ;
;       FS:ESI  = arena of destination block                            ;
;       FS:EDX  = arena of source block                                 ;
;       ECX     = # bytes to move                                       ;
;                                                                       ;
; Returns:                                                              ;
;       DS:DI = master object   (it may have moved)                     ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,ES                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       none                                                            ;
;                                                                       ;
; Calls:                                                                ;
;       gnotify                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Sep 25, 1986 03:31:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gmove,<PUBLIC,NEAR>
cBegin nogen

        CheckKernelDS   fs
        ReSetKernelDS   fs

        push    es
        pushad

        mov     eax, edx
        push    esi                     ; Save destination
        mov     edx, ecx                ; # bytes passed in in ECX
        mov     bx, ds:[eax].pga_handle ; BX = handle of source
        Handle_To_Sel   bl
        mov     cx, bx                  ; CX = client data address of dest.

        push    eax
        push    edx                     ; Save #paragraphs

        mov     ax, GN_MOVE
        push    cx                      ; Save client data address
        call    gnotify                 ; Call global notify procedure
        pop     cx

        pop     edx                     ; EDX = #paragraphs to move
        pop     esi                     ; ESI = source arena
        pop     edi                     ; EDI = destination arena

; Save DS value AFTER call to gnotify, as the master object might be the
; block we are moving and thus changed by the global heap notify proc.

        push    gs
        smov    gs, ds
        mov     ax,ss                   ; Are we about to move the stack?
        cmp     ax,cx
        mov     cx,0                    ; ...assume no
        jne     short stack_no_move
        mov     cx, ax                  ; Selector does not change!
        call    Enter_gmove_stack       ; switch to temporary stack
stack_no_move:
        mov     fSwitchStacks,cl        ; Remember if we switched

        xor     cx, cx                  ; Ready for result of compare
        mov     eax, gs:[edi].pga_address
        cmp     gs:[esi].pga_address, eax
        adc     ch, 0
        mov     fUpDown,ch

        mov     ecx, edx                ; # bytes to move
        shr     ecx, 2                  ; # dwords to move
        jecxz   all_done
        cmp     fUpDown, 0
        jnz     short move_it_up

; MOVE IT DOWN

        cld
        xor     esi, esi
        jmps    move_it

move_it_up:
        std
        mov     esi, ecx
        dec     esi
        shl     esi,2

move_it:
        mov     ds, bx                  ; DS:SI = first word in source block
        mov     edi, esi
ifdef WOW_x86
        smov    es,FLAT_SEL                     ; 23:EAX => pga_address or taget
        add     edi,eax
endif; WOW_x86
        rep     movs    dword ptr [edi], dword ptr [esi]
                                        ; 386 BUG, ECX, ESI, EDI ARE NOW TRASHED

all_done:
        smov    ds, gs  
        cCall   set_selector_address32,<bx,eax> ; Update source selector

        cmp     fSwitchStacks,cl        ; Switch to new stack if any
        je      short move_exit
        call    Leave_gmove_stack
move_exit:
        pop     gs
                
        popad
        pop     es
        cld                     ; Protect people like MarkCl from themselves
        ret
        UnSetKernelDS   fs
cEnd nogen


;-----------------------------------------------------------------------;
; gbestfit                                                              ;
;                                                                       ;
; Searches for the largest moveable block that will fit in the passed   ;
; free block.                                                           ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:ESI = free block                                             ;
;       DS:DI = address of global heap information                      ;
;       CX = #arena entries left to examine                             ;
;       EBX = pga_next or pga_prev                                      ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 1 if block found & moved into free block w/ no extra room. ;
;               DS:ESI = busy block before/after new busy block.        ;
;                                                                       ;
;       ZF = 0 if DS:ESI points to a free block, either the             ;
;               original one or what is left over after moving a block  ;
;               into it.                                                ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       DX,SI                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       gmoveable                                                       ;
;       gmovebusy                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Sep 25, 1986 05:52:12p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   gfirstfit,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   fs
        ReSetKernelDS   fs
        push    ecx
        mov     edx, esi                ; Save free block
        
gbfrestart:
        call    PreAllocArena           ; Abort if no free arenas
        jz      short gbfabort
        mov     eax,ds:[edx].pga_size   ; Compute max size to look for
        jmps    gbfnext
        
gbfloop:
        cmp     ds:[esi].pga_owner,di   ; Is this block busy?
        je      short gbfnext           ; No, continue
        cmp     ds:[esi].pga_size,eax   ; Yes, is block bigger than max size?
        ja      short gbfnext           ; Yes, continue
        cmp     ds:[esi].pga_owner,GA_NOT_THERE ; Is this even here?
        je      short gbfnext           ; No, continue
        call    gmoveable               ; Yes, is it moveable
        jnz     short gbffound
gbfnext:                                ; No, continue
        mov     esi, ds:[esi+ebx]       ; Skip past this block
        cmp     esi, ds:[esi+ebx]       ; Sentinel?
        jne     gbfloop

gbfabort:
        mov     esi, edx                ; Return original free block in ESI
        jmps    gfirstfit1              ; Nothing found!

gbffound:
        xchg    edx, esi                ; Source of move
        call    gmovebusy               ; Yes, move it into free block
        mov     NextCandidate, -1
        call    gpagingcandidate
        mov     NextCandidate, -1
        xchg    esi, edx                ; Put free block in esi
        call    gwin386discard
        xchg    esi, edx

        cmp     edx, ds:[esi+ebx]       ; Blocks adjacent?
        je      short gfirstfit1        ; Yes, may have coalesced.
                                        ; Return busy block in ESI

        mov     esi, ds:[esi+ebx]       ; Get block after busy block
        cmp     ds:[esi].pga_owner,di   ; Is this block busy?
        jne     short gfirstfit1        ;   Yes, fit was exact
        xchg    edx, esi                ; EDX is new free block
        jmps    gbfrestart              ; Start search from old busy block
        
gfirstfit1:
        pop     ecx
        ret
        UnSetKernelDS   fs
cEnd nogen


;-----------------------------------------------------------------------;
; gmovebusy                                                             ;
;                                                                       ;
; Subroutine to move a busy block to a free block of the same size,     ;
; preserving the appropriate arena header fields, freeing the old       ;
; busy block and updating the handle table entry to point to the        ;
; new location of the block.                                            ;
;                                                                       ;
; [tonyg]                                                               ;
; The above has been inaccurate for a while - the destination is NOT    ;
; necessarily free, NOR is it always the same size!                     ;
;                                                                       ;
; It will now handle everything gslidecommon used to do!                ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = ga_prev or ga_next                                         ;
;       DS:EDX = old busy block location                                ;
;       DS:ESI = new busy block location                                ;
;       DS:DI = address of global heap information                      ;
;                                                                       ;
; Returns:                                                              ;
;       DS:ESI = points to new busy block arena header                  ;
;       DS:EDX = points to free block where block used to be            ;
;               (may be coalesced)                                      ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       EBX,ECX                                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       EAX                                                             ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Jun 22, 1987 11:39:56p  -by-  David N. Weise   [davidw]          ;
; Made it jump off to gslidecommon when appropriate.                    ;
;                                                                       ;
;  Mon Oct 27, 1986 10:17:16p  -by-  David N. Weise   [davidw]          ;
; Made the lru list be linked arenas, so we must keep the list correct  ;
; here.                                                                 ;
;                                                                       ;
;  Thu Sep 25, 1986 05:49:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gmovebusy,<PUBLIC,NEAR>
cBegin nogen
if KDEBUG
        cmp     ds:[esi].pga_owner, GA_NOT_THERE
        jne     short @F
AAARRRGGGHHH:
        int 3
        int 3
@@:
        cmp     ds:[edx].pga_owner, GA_NOT_THERE
        je      AAARRRGGGHHH
endif

        push    ecx
        mov     ecx,ds:[edx].pga_size   ; ECX = size of source
        cmp     ds:[esi].pga_owner,di   ; Is destination busy?
        jne     gmbexactfit             ; Yes, then don't create extra block
        mov     eax, ds:[esi].pga_freeprev
        call    gdel_free               ; Take off free list now!
        cmp     ecx,ds:[esi].pga_size   ; No, source and destination same size?
        je      short gmbexactfit       ; Yes, then don't create extra block
        jb      short gmbsplice         ; Destination is larger, split it

if KDEBUG
                                        ; MUST BE ADJACENT IF DESTINATION
        cmp     ds:[esi+ebx], edx       ; SMALLER THAN SOURCE!!!
        je      short gmb_adjust
        int 3
        int 3
gmb_adjust:
endif
        push    ecx                     ; source length
        push    ds:[esi].pga_size       ; destination length
        cmp     bl, pga_next
        je      short gmb_down
                                        ; Moving busy block up
        mov     eax, ds:[edx].pga_address       ; Correct destination address
        add     eax, ds:[esi].pga_size
        mov     ds:[esi].pga_address, eax
        call    gmb_gmove
        jmps    gmb_adjusted

gmb_down:                               ; Moving busy block down
        call    gmb_gmove
        mov     ecx, ds:[esi].pga_address       ; Correct new free block address
        add     ecx, ds:[edx].pga_size
        mov     ds:[edx].pga_address, ecx

gmb_adjusted:
        pop     ds:[edx].pga_size       ; Swap sizes
        pop     ds:[esi].pga_size       
        jmps    gmb_moved
        
gmbsplice:
        push    ecx
        push    edx
        mov     edx, ecx                ; # bytes in block to make
        cmp     bl, pga_prev
        je      short gmb_backward
        call    gsplice                 ; Split the block
        jmps    gmb_spliced

gmb_backward:
        neg     edx
        add     edx, ds:[esi].pga_size  ; Second block will be used
        call    gsplice
        xchg    esi, edx

gmb_spliced:
        mov     ds:[esi].pga_owner,1    ; Mark new block busy
        push    esi                     ; New free block
        mov     esi, edx                ; Block to free
        mov     edx, eax
        call    gmarkfree
        pop     esi                     ; New free block
        pop     edx                     ; Source for copy
        pop     ecx

gmbexactfit:
        call    gmb_gmove

gmb_moved:
        mov     eax, esi
        mov     esi, edx
        xor     edx, edx
        call    gmarkfree               ; Free old block
        mov     ecx,esi                 ; New free block
        mov     esi,eax                 ; New block
        or      dx,dx
        jz      short gmb1
        mov     ds:[esi].pga_handle,dx  ; Set back link to handle in new block
        cCall   AssociateSelector32,<dx,esi>    ; Associate with new arena
        xor     dx,dx                   ; Set Z flag
gmb1:
        mov     edx,ecx
gmbexit:
        pop     ecx
        ret
cEnd nogen

;
; Common code for gmovebusy
;
cProc   gmb_gmove,<PUBLIC,NEAR>

cBegin nogen
        push    ecx                     ; # bytes to move
        push    dword ptr ds:[edx].pga_count
        push    ds:[edx].pga_owner
        push    ds:[edx].pga_lruprev
        push    ds:[edx].pga_lrunext

        pop     ds:[esi].pga_lrunext    ; Copy client words to new header
        pop     ds:[esi].pga_lruprev
        pop     ds:[esi].pga_owner
        pop     dword ptr ds:[esi].pga_count
        cmp     ds:[esi].pga_lruprev,edi
        jz      short no_link
        cmp     [di].gi_lruchain,edx
        jnz     short didnt_move_head
        mov     [di].gi_lruchain,esi
didnt_move_head:
        mov     ecx,ds:[edx].pga_lruprev
        mov     ds:[ecx].pga_lrunext,esi        ; Update the lru list
        mov     ecx,ds:[edx].pga_lrunext
        mov     ds:[ecx].pga_lruprev,esi        ; Update the lru list
no_link:
        pop     ecx
ifndef WOW_x86
        call    get_rover_232
endif
        jmp     gmove                           ; Move the client data

cEnd    nogen

;-----------------------------------------------------------------------;
; gmoveable                                                             ;
;                                                                       ;
; Tests if an ojbect is moveable.  Non moveable blocks are:             ;
; Fixed blocks, moveable blocks that are locked, moveable blocks        ;
; going up, discardable code going down.                                ;
;                                                                       ;
; Arguments:                                                            ;
;       FS:ESI = arena header of object                                 ;
;       DS:DI = address of global heap information                      ;
;       BX = ga_next or ga_prev                                         ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 0 if object moveable                                       ;
;       ZF = 1 if object not moveable                                   ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Oct 15, 1986 05:04:39p  -by-  David N. Weise   [davidw]          ;
; Moved he_count to ga_count.                                           ;
;                                                                       ;
;  Thu Sep 25, 1986 05:42:17p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gmoveable,<PUBLIC,NEAR>
cBegin nogen
        test    ds:[esi].pga_handle,GA_FIXED    ; If no handle then fixed
        jnz     short gmfixed

        cmp     ds:[esi].pga_count,bh            ; If locked then fixed
        jne     short  gmfixed

        test    ds:[esi].pga_flags,GA_DISCCODE  ; If discardable code
        jz      short gmnotcode
        cmp     bl,pga_next                     ; Discardable code can only
        ret                                     ; move up in memory
gmnotcode:
        cmp     [di].gi_reserve,edi             ; If no reserved code area?
        je      short gmokay                    ; Then anything can move up
        cmp     bl,pga_prev                     ; Otherwise can only move down
        ret                                     ; in memory
gmfixed:
        or      bh,bh                           ; Return with ZF = 1 if
        ret                                     ; not moveable
gmokay:
        or      esi,esi
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; gdiscard                                                              ;
;                                                                       ;
; Subroutine to walk LRU chain, discarding objects until the #paras     ;
; discarded, plus the biggest free block is greater than the #paras     ;
; we are looking for.                                                   ;
;                                                                       ;
; Arguments:                                                            ;
;       EAX = size of largest free block so far                         ;
;       EDX = minimum #bytes needed                                     ;
;       DS:DI = address of global heap information                      ;
;                                                                       ;
; Returns:                                                              ;
;       ZF = 0 if one or more objects discarded.                        ;
;       ZF = 1 if no objects discarded.                                 ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,DX,DI                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;  Mon Oct 27, 1986 09:34:45p  -by-  David N. Weise   [davidw]          ;
; The glru list was reworked to link the arenas, not using the handle   ;
; table as a middle man.  Because of this change glruprev was moved     ;
; inline and the code shortened up again.                               ;
;                                                                       ;
;  Wed Oct 15, 1986 05:04:39p  -by-  David N. Weise   [davidw]          ;
; Moved he_count to ga_count.                                           ;
;                                                                       ;
;  Thu Sep 25, 1986 05:45:31p  -by-  David N. Weise   [davidw]          ;
; Shortened it up a bit and added this nifty comment block.             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   gdiscard,<PUBLIC,NEAR>
cBegin nogen
        push    eax
        push    edx

        mov     [di].hi_ncompact,0      ; Clear compaction flag
        sub     edx,eax                 ; How much to discard before
        mov     [di].hi_distotal,edx    ; compacting again.

        xor     ebx,ebx                 ; EBX = amount of DISCCODE below fence
        test    [di].gi_cmpflags,GA_DISCCODE
        jnz     short fence_not_in_effect0

        mov     cx,[di].gi_lrucount
        jcxz    fence_not_in_effect0    ; All done if LRU chain empty

        mov     ax, [di].gi_disfence_hi
        shl     eax, 16
        mov     ax, [di].gi_disfence_lo
        push    edx
        mov     edx, eax
        add     edx, ds:[edi].gi_reserve
        mov     esi,[di].gi_lruchain    ; ESI -> most recently used (ga_lruprev
gdloop0:                                ; is the least recently used)
        mov     esi,ds:[esi].pga_lruprev ; Move to next block in LRU chain
        test    ds:[esi].pga_flags,GA_DISCCODE  ; Discardable code?
        jz      short gdloop0a          ; No, ignore
        cmp     edx, ds:[esi].pga_address
        jbe     short gdinclude
        cmp     eax, ds:[esi].pga_address ; Yes, is this code fenced off?
        jbe     short gdloop0a          ; No, ignore
gdinclude:
        add     ebx,ds:[esi].pga_size   ; Yes, accumulate size of discardable
gdloop0a:                               ; code below the fence
        loop    gdloop0
        pop     edx

fence_not_in_effect0:
        mov     esi,[di].gi_lruchain
        cmp     [di].gi_lrucount, 0
        je      short gdexit
        push    ds:[esi].pga_lruprev
        push    [di].gi_lrucount
gdloop:
        pop     cx
        pop     eax
        jcxz    gdexit                  ; No more see if we discarded anything
        mov     esi, eax                ; ES on stack may be invalid if count 0
        dec     cx
        push    ds:[esi].pga_lruprev    ; Save next handle from LRU chain
        push    cx
        cmp     ds:[esi].pga_count,0    ; Is this handle locked?
        jne     short gdloop                    ; Yes, ignore it then
        test    [di].gi_cmpflags,GA_DISCCODE
        jnz     short fence_not_in_effect
        test    ds:[esi].pga_flags,GA_DISCCODE
        jz      short fence_not_in_effect
        or      ebx,ebx                 ; Discardable code below fence?
        jz      short gdloop                    ; No, cant discard then
        cmp     ebx,ds:[esi].pga_size   ; Yes, more than size of this block?
        jb      short gdloop                    ; No, cant discard then
        sub     ebx,ds:[esi].pga_size   ; Yes, reduce size of code below fence
fence_not_in_effect:
        push    ebx
        call    DiscardCodeSegment
        pop     ebx
        jnz     short discarded_something
        test    [di].hi_ncompact,10h    ; did a GlobalNotify proc free enough?
        jz      short gdloop
        jmps    enough_discarded
discarded_something:
        test    [di].hi_ncompact,10h    ; did a GlobalNotify proc free enough?
        jnz     short enough_discarded
        or      [di].hi_ncompact,1      ; Remember we discarded something
        sub     [di].hi_distotal,eax    ; Have we discarded enough yet?
        ja      short gdloop            ; No, look at next handle
enough_discarded:                     
        pop     cx                      ; Flush enumeration counter
        pop     ecx                     ; and saved ESI
gdexit:
        cmp     [di].hi_ncompact,0      ; Return with Z flag set or clear
        pop     edx
        pop     eax
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; DiscardCodeSegment                                                    ;
;                                                                       ;
; Discards the given segment.  Calls gnotify to fix stacks, entry       ;
; points, thunks, and prologs.  Then glrudel removes it from the lru    ;
; list and gmarkfree finally gets rid of it.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:DI => BurgerMaster                                           ;
;       ES    =  Address of segment to discard                          ;
;                                                                       ;
; Returns:                                                              ;
;       AX = size discarded                                             ;
;       ZF = 0 ok                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS,ES                                                     ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       gnotify                                                         ;
;       glrudel                                                         ;
;       gmarkfree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Jun 12, 1987            -by-  Bob Matthews     [bobm]            ;
; Made FAR.                                                             ;
;                                                                       ;
;  Sun Apr 19, 1987 12:05:40p  -by-  David N. Weise   [davidw]          ;
; Moved it here from InitTask, so that FirstTime could use it.          ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   DiscardCodeSegment,<PUBLIC,NEAR>
cBegin nogen
        push    esi
        mov     bx,ds:[esi].pga_handle  ; BX = handle
        mov     al,GN_DISCARD           ; AX = GN_DISCARD
        call    gnotify
        jz      short cant_discard              ; Skip this handle if not discardable
        call    glrudel                 ; Delete handle from LRU chain
        push    ds:[esi].pga_owner      ; Save owner field
        mov     eax,ds:[esi].pga_size   ; Save size
        xor     edx,edx
        call    gmarkfree               ; Free the block associated with this handle
        mov     bx,dx
        pop     cx                      ; Owner
        cCall   mark_sel_NP,<bx,cx>
cant_discard:
        pop     esi
        ret
cEnd nogen

;-----------------------------------------------------------------------;
; ShrinkHeap                                                            ;
;                                                                       ;
; Tries to return DPMI memory blocks to DPMI memory manager.            ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       InnerShrinkHeap                                                 ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   ShrinkHeap,<PUBLIC,NEAR>
cBegin nogen

        push    ds

        GENTER32
        ReSetKernelDS   FS

        cCall   InnerShrinkHeap
        jnz     short sh_maybe_more

        and     PagingFlags, NOT 8              ; Don't call back if # win386
                                                ;   didn't change
sh_maybe_more:

        GLEAVE32
        UnSetKernelDS   FS
        pop     ds
        ret
                         
cEnd nogen

;-----------------------------------------------------------------------;
; InnerShrinkHeap                                                       ;
;                                                                       ;
; Checks heap to see if there are any blocks to return to Win386        ;
; Compacts if there are Win386 blocks around AND there is more          ;
; than 512k free.                                                       ;
; Returns any completely free Win386 block to Win386.                   ;
;                                                                       ;
; Arguments:                                                            ;
;       FS = Kernel's DS                                                ;
;       EDI = 0                                                         ;
;                                                                       ;
; Returns:                                                              ;
;       Z flag set if no blocks returned, Z clear if 1 or more returned.;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       UnlinkWin386Block                                               ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   InnerShrinkHeap,<PUBLIC,NEAR>
cBegin  nogen

        CheckKernelDS   FS
        ReSetKernelDS   FS
        pushad

        push    Win386_Blocks

        cmp     Win386_Blocks, 0
        je      short sh_done
                                                ; First count up free blocks
        mov     esi, [edi].phi_first
scan_loop:
        mov     esi, [esi].pga_freenext
scan_next:
        cmp     esi, [esi].pga_next             ; Sentinel?
        je      short sh_done                   ;   yes, all done

        mov     ebx, [esi].pga_prev
        cmp     [ebx].pga_owner, GA_NOT_THERE
        jne     short scan_loop
        mov     ecx, [esi].pga_next
        cmp     [ecx].pga_owner, GA_NOT_THERE
        jne     short scan_loop
        mov     eax, [ecx].pga_next             ; Block after NOT_THERE block
        cmp     eax, [eax].pga_next             ; Sentinel?
        je      short sh_done                   ;  yes, don't try to unlink
                                                ; Have block to return
        push    [esi].pga_freeprev              ; Current block will be freed

        cCall   UnlinkWin386Block

        pop     esi                             ; Continue before block freed
        jmps    scan_loop
        
sh_done:
        pop     ax                      ; Starting value of Win386_Blocks
        cmp     ax, Win386_Blocks       ; Set Z flag if heap didn't shrink

        popad
        UnSetKernelDS   FS
        ret
cEnd

;-----------------------------------------------------------------------;
; UnlinkWin386Block                                                     ;
;                                                                       ;
; Returns a block to Win386 and unlinks it from the heap.               ;
;                                                                       ;
; Arguments:                                                            ;
;       EBX     Block previous to block to be unlinked                  ;
;       ESI     Block to be unlinked                                    ;
;       ECX     Block after to block to be unlinked                     ;
;                                                                       ;
; Returns:                                                              ;
;       ESI     Block previous to EBX                                   ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;        ECX, DX, EDI, DS, ES                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       EAX, EBX, EDX                                                   ;
;                                                                       ;
; Calls:                                                                ;
;       GlobalCompact                                                   ;
;       UnlinkWin386Block                                               ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   UnlinkWin386Block,<PUBLIC,NEAR>
cBegin nogen

        CheckKernelDS   FS
        ReSetKernelDS   FS
        push    dx

        mov     edx, [ecx].pga_next             ; Block after all this
        cmp     edx, [edx].pga_next             ; Last sentinel?
        je      RSHORT dont_do_it               ;   Never free last block
                                 
if KDEBUG        
        push    edx
        mov     eax, [esi].pga_size
        mov     edx, eax
        shr     edx, 16
        krDebugOut <DEB_TRACE OR DEB_krMemMan>, "UnlinkWin386Block: releasing #dx#AX bytes"
        pop     edx
endif
        push    esi
        call    gdel_free                       ; Remove from free list
ifdef WOW
        push    edx
        push    ebx
        push    ecx
        mov     eax,MEM_RELEASE
        mov     edi,[esi].pga_size
        cCall   VirtualFree,<[ebx].pga_lrunext,edi,eax>
        pop     ecx
        pop     ebx
        pop     edx
else
        mov     esi, [ebx].pga_lrunext          ; Saved WIN386 handle
        mov     di, si
        shr     esi, 16                         ; Put in SI:DI
        DPMICALL 0502h                          ; Free Memory Block
endif; WOW
        xor     edi, edi
        pop     esi

        dec     Win386_Blocks

        mov     eax, [ebx].pga_prev             ; Block before all this
        mov     [eax].pga_next, edx             ; Unlink them.
        mov     [edx].pga_prev, eax

        cCall   free_arena_header,<ebx>         ; Free the arena headers
        cCall   free_arena_header,<esi>
        cCall   free_arena_header,<ecx>

        mov     esi, eax                        ; For gfreeall

        sub     [edi].hi_count, 3

if KDEBUG
        call    CheckGlobalHeap
endif

dont_do_it:
        pop     dx
        ret
        UnSetKernelDS   FS

cEnd nogen

cProc   gpagingcandidate,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   FS
        ReSetKernelDS   FS
        test    byte ptr WinFlags[1], WF1_PAGING        ; Paging?
        jz      short gpc_not_paging                    
        pushad
        mov     ebx, ds:[esi].pga_address
        mov     esi, ds:[esi].pga_size
        add     esi, ebx                        ; End of region
        shr     ebx, 12
        shr     esi, 12
        cmp     ebx, NextCandidate
        jb      short gpc_use_this_page
        mov     ebx, NextCandidate              ; Start the region here
gpc_use_this_page:
        cmp     esi, ebx
        jne     short call_win386
        mov     NextCandidate, ebx
        jmps    gpc_done
call_win386:
        mov     NextCandidate, -1
        sub     esi, ebx                        ; number of pages
        mov     di, si
        shr     esi, 16
        mov     cx, bx
        shr     ebx, 16
        DPMICALL 0700h                          ; Page Candidate
gpc_done:
        popad
gpc_not_paging:
        ret
        UnSetKernelDS   FS
cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   gwin386discard,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   FS
        ReSetKernelDS   FS
        cmp     ds:[esi].pga_size, 4096
        jb      short not_a_chance      ; Quick exit
        cmp     ds:[esi].pga_size, 16*1024
        jb      short inform_later

        pushad
        mov     ebx, ds:[esi].pga_address
        mov     esi, ds:[esi].pga_size

        mov     di, si  
        shr     esi, 16                 ; SI:DI is # bytes to discard
        mov     cx, bx                               
        shr     ebx, 16                 ; BX:CX is first bytes to discard
        DPMICALL 0703h
        popad    
        jmps    not_a_chance

inform_later:
        or      PagingFlags, 1
not_a_chance:
        ret
        UnSetKernelDS   FS
cEnd nogen


cProc DiscardFreeBlocks,<PUBLIC,NEAR>
cBegin nogen
        push    es
        push    ds
        GENTER32
        ReSetKernelDS   FS
        and     PagingFlags, NOT 1

        mov     esi, ds:[di].phi_first
        mov     esi, ds:[esi].pga_freenext
dfb_next:
        cmp     esi, ds:[esi].pga_next          ; Sentinel?
        je      short dfb_done                  ;   yes, all done

        push    esi
        push    edi
        cmp     ds:[esi].pga_size, 4096
        jb      short no_win386discard  ; Quick exit

        mov     ebx, ds:[esi].pga_address
        mov     esi, ds:[esi].pga_size
        add     esi, ebx                ; First byte past block
        shr     esi, 12                 ; Page of this byte
        add     ebx, 0fffh
        shr     ebx, 12                 ; First page we can discard
        sub     esi, ebx                ; # pages we can discard
        jbe     short no_win386discard  ;   none to discard

        mov     di, si  
        shr     esi, 16                 ; SI:DI is # pages to discard
        mov     cx, bx
        shr     ebx, 16                 ; BX:CX is first page to discard
        DPMICALL 0701h                  ; Say goodbye, pages

no_win386discard:
        pop     edi
        pop     esi

        mov     esi, ds:[esi].pga_freenext
        jmps    dfb_next

dfb_done:
        GLEAVE32
        UnSetKernelDS   FS
        pop     ds      
        pop     es
        ret
cEnd nogen

;---------------------------------------------------------------------------
;
;   guc_findfree
;
;   helper function for guncompact
;
;   finds the next free block below the address
;   in ECX into which the block pointed to by ESI will fit.
;
;   Entry:
;       ECX = maximum address (desired swap area)
;       DS:DI = global heap info
;       ESI = arena of block to move
;
;   Exit:
;       Carry clear if block found, set if not
;       EDX = free block arena
;
;   Uses:
;       EAX, EDX
;
;   Preserves:
;       EBX, ECX, ESI, EDI
;
;   History:
;       Fri Jun 7, 1991 9:38  -by-  Craig Critchley          [craigc]
;         Wrote it...
;
;--------------------------------------------------------------------------

cProc   guc_findfree, <NEAR, PUBLIC>
cBegin nogen

    mov     edx, ds:[di].phi_last
    mov     edx, ds:[edx].pga_freeprev

gucff_check:
    cmp     edx, ds:[edx].pga_prev              ; if at start, not found
    jz      short gucff_notfound

    mov     eax, ds:[edx].pga_address           ; is it out of swap area
    add     eax, ds:[edx].pga_size
    cmp     eax, ecx
    jae     short gucff_nextblock

    mov     eax, ds:[esi].pga_size              ; does it fit
    cmp     ds:[edx].pga_size, eax
    jb      short gucff_nextblock

    clc                                         ; return it in EDX
    ret

gucff_nextblock:
    mov     edx, ds:[edx].pga_freeprev          ; previous free block
    jmp     short gucff_check

gucff_notfound:
    stc                                         ; return error
    ret

cEnd nogen

;-----------------------------------------------------------------------------
;
;   guncompact -
;
;   this function moves segments that are not free or discardable code
;   out of the intended swap area.  don't take the name too seriously.
;
;   Entry:
;       ECX = size of intended swap area
;       DS:DI = global heap info
;       FS = global heap
;
;   Exit:
;       Carry clear if space could be cleared, set if not
;
;   Registers used:
;       EAX, EBX, ECX, EDX, ESI
;
;   Called by:
;       greserve
;
;   Calls:
;       gmoveable
;       gmovebusy
;
;   History:
;       Fri Jun 7, 1991 9:38  -by-  Craig Critchley          [craigc]
;         Wrote it...
;
;-----------------------------------------------------------------------------

cProc   guncompact, <NEAR, PUBLIC>

cBegin <nogen>

    mov     edx, [di].phi_last                  ; point to last block
    mov     ebx, pga_prev

    sub     ecx, ds:[edx].pga_address           ; find desired code fence
    neg     ecx

guc_trymovingblock:
    mov     esi, ds:[edx+ebx]                   ; block under current one...
    cmp     ds:[esi].pga_owner, 0               ; don't move free blocks
    jz      short guc_skipblock
    test    ds:[esi].pga_flags, GA_DISCCODE     ; don't move discardable code
    jnz     short guc_skipblock
    cmp     ds:[esi].pga_owner, GA_NOT_THERE    ; ignore not-there's
    jz      short guc_skipblock

    call    gmoveable                           ; can this block be moved?
    jz      short guc_error                     ; if not, swap area toast
    push    edx
    call    guc_findfree                        ; find a block to move it into
    pop     eax
    jc      short guc_error                     ; error if didn't find one
    push    eax
    xchg    edx, esi
    call    gmovebusy                           ; move it
    xchg    edx, esi
    pop     edx

    ;;; can we just fall thru the block ought to be free now...
    jmp     short guc_trymovingblock            ; move what's there now

guc_skipblock:
    mov     edx, esi                            ; this block now first cleared
    cmp     ds:[edx].pga_address, ecx           ; big enough?
    ja      short guc_trymovingblock

guc_done:
    clc                                         ; success-o-mundo!!
    ret

guc_error:
    stc                                         ; if not, we could not
    ret                                         ; clear swap area

cEnd   <nogen>

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3gmem.asm ===
TITLE   GMEM - Register interface to global memory allocator

.xlist
include kernel.inc
include tdb.inc
.list

.386p
include protect.inc

DataBegin

;externW  curTDB
;externW  pGlobalHeap
externW  Win386_Blocks
externW  SelTableLen
externD  SelTableStart

ifdef WOW
globalB  fInAlloc, 0
globalW  UserSelArray, 0
globalW  SelectorFreeBlock, 0
endif

if ROM
externW gdtdsc
endif

DataEnd


sBegin  CODE
assumes CS,CODE
externNP DPMIProc
ife ROM
externW  gdtdsc
endif

externNP gsplice
externNP gjoin
externNP gzero
externNP gsearch
externNP gmarkfree
;externNP gdel_free
;externNP gcheckfree
externNP gmovebusy
externNP gcompact
externNP glruadd
externNP glrudel
externNP glrutop
externNP gnotify
externNP is_there_theoretically_enough_space
externNP can_we_clear_this_space

if ROM
externNP IsROMObject
endif

externNP get_physical_address
externNP alloc_sel
externNP alloc_data_sel
externFP IAllocCStoDSAlias
externNP pdref
externNP set_sel_limit
externNP set_selector_limit32
externNP set_selector_address32
externNP mark_sel_PRESENT
externNP mark_sel_NP
externNP free_sel
externNP FreeSelArray
externNP GrowSelArray
externNP get_arena_pointer32
externNP get_temp_sel
externNP AssociateSelector32
externNP free_arena_header
externNP PageLockLinear
externNP UnlinkWin386Block
externNP gwin386discard
externNP PreAllocArena

if KDEBUG
externNP CheckGAllocBreak   ; LINTERF.ASM
endif

;-----------------------------------------------------------------------;
; galign                                                                ;
;                                                                       ;
; Aligns the size request for a global item to a valid para boundary.   ;
;                                                                       ;
; Arguments:                                                            ;
;       EBX = #bytes                                                    ;
;       CF = 1 if #paras overflowed.                                    ;
;                                                                       ;
; Returns:                                                              ;
;       EDX = #bytes aligned,  to next higher multiple of 32            ;
;                                                                       ;
; Error Returns:                                                        ;
;       EDX = 0100000h                                                  ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       all                                                             ;
; Registers Destroyed:                                                  ;
;       none                                                            ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Mon Sep 22, 1986 03:14:56p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   galign,<PUBLIC,NEAR>
cBegin  nogen

        jc      short align_error       ; Overflow occur?
        lea     edx,[ebx+GA_ALIGN_BYTES]; No, add alignment amount
        and     dl,GA_MASK_BYTES        ; ...modulo alignment boundary
        cmp     edx,ebx                 ; Test for overflow
        jnb     short align_exit        ; OK, continue
align_error:
        mov     edx,0FF0000h            ; Return largest possible size
        jmps    align_exit1             ; 255*64k since max # selectors is 255
align_exit:
        cmp     edx, 100000h            ; Greater than 1Mb?
        jbe     short align_exit1       ;  no, done
        add     edx, 0FFFh              ;  yes, page align
        jc      align_error
        and     dx, not 0FFFh
        cmp     edx, 0FF0000h           ; Too big?
        ja      short align_error       ;   yep, hard luck
align_exit1:
        ret
cEnd    nogen

;-----------------------------------------------------------------------;
; galloc                                                                ;
;                                                                       ;
; Allocates global memory.                                              ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocation flags                                           ;
;       BX = #paragraphs                                                ;
;       CX = owner field                                                ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle to object or zero                                   ;
;       BX = size of largest free block if AX = 0                       ;
;       CX = AX                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       DX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       gsearch                                                         ;
;       ghalloc                                                         ;
;       glruadd                                                         ;
;       gmarkfree                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Jun 24, 1987 03:04:32a  -by-  David N. Weise     [davidw]        ;
; Added support for Global Notify.                                      ;
;                                                                       ;
;  Mon Sep 22, 1986 02:38:19p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

AccessWord      dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_CODE+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_CODE+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT
                dw      DSC_DATA+DSC_PRESENT
                dw      (DSC_DISCARDABLE SHL 8) + DSC_DATA+DSC_PRESENT

cProc   galloc,<PUBLIC,NEAR>
cBegin  nogen

if KDEBUG
        test    al,GA_DISCCODE          ; if discardable code, allow alloc
        jnz     @F
        call    CheckGAllocBreak
        jc      gaerr                   ; time to fail...
@@:
endif
        cmp     ebx, (16*1024*1020)     ; Too big?
        ja      gaerr                   ;  yes.

        or      ebx,ebx                 ; Allocating zero size?
        jz      allocate_zero_size

        call    gsearch                 ; Search for block big enough
        jz      ga_exit                 ; Done, if couldn't get enough

        mov     esi,eax
        push    dx
        mov     bx,dx
        mov     edx, ds:[esi].pga_address
        mov     ecx, ds:[esi].pga_size

        and     bx, ((GA_CODE_DATA+GA_DISCARDABLE) shl 8) + GA_DGROUP
        or      bl, bh
        xor     bh, bh
        shl     bx, 1
        mov     ax, cs:AccessWord[bx]   ; Pick up access rights for selector
        cCall   alloc_sel,<edx,ecx>
        pop     dx
        or      ax, ax                  ; Did we get the selectors?
        jz      short gaerr2            ;   no, free block and return
                                
        add     ecx, 0FFFFh             ; Calculate # selectors we got
        shr     ecx, 16
        mov     ds:[esi].pga_selcount, cl
        cCall   AssociateSelector32,<ax,esi>
        test    dl,GA_MOVEABLE          ; Is this a moveable object?
        jnz     short moveable
        test    dh, GA_DISCARDABLE      ; We have a fixed block
        jnz     short not_moveable      ; Not interested in discardable blocks
        mov     bx, ax
ifdef WOW
        ; the following dpmicall is basically a NOP. so just
        ; avoid the call altogether.
        ;                                    - Nanduri Ramakrishna
else
        DPMICALL 0004H
        jc      short gaerr1
endif
        inc     [esi].pga_pglock        ; Mark it locked
        mov     ax, bx
        jmps    not_moveable

moveable:
        mov     ds:[esi].pga_count,0    ; Initialize lock count to 0
        StoH    ax                      ; Mark as moveable block
not_moveable:
        mov     ds:[esi].pga_handle,ax  ; Set handle in arena
        mov     bx, ax                  ; AX and BX handle

        call    glruadd                 ; Yes, Add to LRU chain
        mov     cx,ax
        ret

allocate_zero_size:
        test    al,GA_MOVEABLE          ; Yes, moveable?
        jz      short gaerr             ; No, return error (AX = 0)

        mov     bx, ax
        and     bx, ((GA_CODE_DATA+GA_DISCARDABLE) shl 8) + GA_DGROUP
        or      bl, bh                  ; Above bits are exclusive
        xor     bh, bh
        shl     bx, 1
        mov     ax, cs:AccessWord[bx]   ; Pick up access rights for selector
        and     al, NOT DSC_PRESENT     ; These are NOT present
        xor     edx, edx                ; Base of zero for now
        cCall   alloc_sel,<edx,dx,cx>
        or      ax, ax
        jz      short gaerr

        cCall   AssociateSelector32,<ax,0,cx>   ; Save owner in selector table
        
        StoH    al                      ; Handles are RING 2
        mov     bx,ax
ga_exit:
        mov     cx,ax
        ret

gaerr1:                                 ; Failed to page lock, free up everthing
        cCall   FreeSelArray,<bx>
gaerr2:                                 ; Failed to get selectors
        xor     edx,edx
        call    gmarkfree
gaerr:
        KernelLogError  DBF_WARNING,ERR_GALLOC,"GlobalAlloc failed"
        xor     dx,dx                   ; DX = 0 means NOT out of memory
        xor     ax,ax                   ; Return AX = 0 to indicate error
        jmps    ga_exit
cEnd    nogen


;-----------------------------------------------------------------------;
; grealloc                                                              ;
;                                                                       ;
; Reallocates the given global memory object.                           ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocation flags                                           ;
;       EBX = #bytes for new size                                       ;
;       CX = new owner field value                                      ;
;       DX = existing handle                                            ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle to object or zero                                   ;
;       DX = size of largest free block if AX = 0                       ;
;       CX = AX                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       SI                                                              ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Sep 22, 1986 10:11:48a  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   grealloc,<PUBLIC,NEAR>
cBegin  nogen

        push    bp
        mov     bp,sp
        push    ax
rflags  EQU     word ptr [bp-2]
        push    dx
h       EQU     word ptr [bp-4]
        push    cx
owner   EQU     word ptr [bp-6]
        push    ebx
rsize   EQU     dword ptr [bp-10]
        sub     sp, 6
canmove EQU     byte ptr [bp-12]
locked  EQU     byte ptr [bp-13]
mflags  EQU     byte ptr [bp-14]
pgLockSel EQU   word ptr [bp-16]
        push    dx
oldh    EQU     word ptr [bp-18]

        mov     pgLockSel, 0            ; No selector to free yet

        call    pdref
        mov     dx, bx                  ; save owner if discarded
        mov     word ptr (mflags), cx
        mov     ebx,rsize
        jz      racreate                ; Do nothing with 0, free or discarded  handles
handle_ok:
        test    byte ptr rflags,GA_MODIFY  ; Want to modify table flags?
        jnz     short ramodify          ; Yes go do it
        or      ebx,ebx                 ; Are we reallocing to zero length?
        jz      short to_0
        jmp     raokay                  ; No, continue
to_0:   or      ch,ch                   ; Is handle locked?
        jz      short radiscard
rafail: 
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        xor     ax,ax                   ; Yes, return failure
        xor     dx,dx
        jmp     raexit

radiscard:                              ; No, then try to discard the object

; Here to discard object, when reallocating to zero size.  This
; feature is only enabled if the caller passes the moveable flag

        test    byte ptr rflags,GA_MOVEABLE ; Did they want to discard?
        jz      short rafail                    ; No, then return failure.

        mov     al,GN_DISCARD           ; AL = discard message code
        xor     cx,cx                   ; CX = means realloc
        mov     bx, ds:[esi].pga_handle ; BX = handle
        push    es
        call    gnotify                 ; See if okay to discard
        pop     es
        jz      short rafail            ; No, do nothing
        call    glrudel                 ; Yes, Delete handle from LRU chain

        cCall   mark_sel_NP,<ds:[esi].pga_handle,ds:[esi].pga_owner>
        xor     edx,edx
        call    gmarkfree               ; Free client data
        jz      short rafixed           ; Return NULL if freed a fixed block
        jmp     rasame                  ; Return original handle, except
                                        ; GlobalLock will now return null.
rafixed:
        xor     ax,ax
        jmp     raexit

ramodify:
if ROM
        cCall   IsROMObject, <h>
        or      ax, ax
        jnz     rasame1
endif
        mov     ax,rflags               ; Get new flags
        mov     dx,owner                ; Get new owner field value
        mov     bx, ds:[esi].pga_handle
        test    bl, GA_FIXED            ; Moveable object?
        jz      short is_moveable
        test    al,GA_MOVEABLE          ; Make fixed into moveable?
        jz      short ramod2            ; No, change owner only

        StoH    bx                      ; Turn selector into handle
        mov     ds:[esi].pga_handle, bx
        mov     ds:[esi].pga_count, 0   ; 0 lock count for new movable obj

is_moveable:
        call    glrudel                 ; Yes, remove from lru chain
        push    ax
        push    ecx
        lar     ecx, ebx                ; Get existing access rights
        shr     ecx, 8
        test    ah, GA_DISCARDABLE      ; Do we want it to be discardable?
        jnz     short ra_want_discardable
.errnz DSC_DISCARDABLE-10h
        btr     cx, 12                  ; Ensure DSC_DISCARDABLE is off
        jnc     short ra_ok_disc_bit    ;  it was
        jmps    ra_set_access           ;  nope, must reset it
ra_want_discardable:
        bts     cx, 12                  ; Ensure DSC_DISCARDABLE is on
        jc      short ra_ok_disc_bit
ra_set_access:
        DPMICALL 0009h
ra_ok_disc_bit:
        pop     ecx
        pop     ax
ra_notdiscardable:
        test    cl,HE_DISCARDED         ; Is this a discarded handle?
        jz      short ramod1            ; No, continue
        test    ah,GA_SHAREABLE         ; Only change owner if making shared
        jz      short rasame1
int 3
        push    ax
        push    ecx
        lsl     ecx, ebx                ; Use existing high limit bits
        shr     ecx, 16
        DPMICALL 0008h                  ; Set segment limit (to CX:DX)
        pop     ecx
        pop     ax
        jmps    rasame1
ramod1:
        call    glruadd                 ; Add to lru chain if now discardable
ramod2:
        test    ah,GA_SHAREABLE         ; Only change owner if making shared
        jz      short rasame1
        mov     ds:[esi].pga_owner,dx   ; Set new owner value
rasame1:
        jmp     rasame

rafail0:
        jmp     rafail
racreate:
        test    cl,HE_DISCARDED         ; Is this a discarded handle?
        jz      short rafail0           ; No, return error
        or      ebx,ebx                 ; Are we reallocing to zero length?
        jz      short rasame1           ; Yes, return handle as is.

if KDEBUG
        test    cl,GA_DISCCODE          ; if discardable code, allow realloc
        jnz     @F
        call    CheckGAllocBreak
        jc      rafail0
@@:
endif
        mov     ax,GA_MOVEABLE          ; Reallocating a moveable object
        or      ax,rflags               ; ...plus any flags from the caller
                                        ; DO NOT CHANGE: flag conflict 
                                        ; GA_DISCARDABLE == GA_ALLOCHIGH.             
        and     cl,not (HE_DISCARDED + GA_ALLOCHIGH)           
        or      al,cl                     
        mov     cx,dx                   ; get owner

        test    al,GA_DISCCODE          ; Discardable code segment?
        jz      short ranotcode
        or      al,GA_ALLOCHIGH         ; Yes, allocate high
ranotcode:
        or      al, COMPACT_ALLOC       ; Allow discarding
        mov     [di].gi_cmpflags,al     ; Save flags for gcompact
        and     [di].gi_cmpflags,CMP_FLAGS or GA_ALLOCHIGH
        push    si                      ; save handle
        call    gsearch                 ; Find block big enough
        pop     si                      ; restore existing handle
        jz      rafailmem1
                        
        cCall   mark_sel_PRESENT,<eax,si>       
        or      si,si                   ; Might have failed to grow selector array
        jz      short racre_worst_case

        xchg    eax,esi                 ; Return original handle
                                        ; Set back link to handle in new block
        cCall   AssociateSelector32,<ax,esi>
        mov     ds:[esi].pga_handle,ax
        mov     ds:[esi].pga_count,0
;       and     ch,GA_SEGTYPE           ; OPTIMIZE superfluous??
;       and     es:[di].ga_flags,GAH_NOTIFY
;       or      es:[di].ga_flags,ch     ; Copy segment type flags to ga_flags
        call    glruadd                 ; Add to LRU chain
        jmp     raexit
                
racre_worst_case:
        mov     esi, eax                ; Free block if selectors not available
        xor     edx, edx
        call    gmarkfree

        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"

        xor     dx, dx
        xor     ax, ax
        jmp     raexit

raokay:

if KDEBUG
        test    ds:[esi].pga_flags,GA_DISCCODE
        jz      short ok
        Debug_Out "GlobalReAlloc of Discardable Code"
ok:
endif
        cmp     ebx,ds:[esi].pga_size
        jz      short rasame

        clc
        call    galign                  ; assuming there is room.

; Here if not trying to realloc this block to zero
; FS:ESI = arena header of current block
; AX:0 = client address of current block
; CH = lock count of current block
; EDX = new requested size

        cmp     ds:[esi].pga_pglock, 0  ; Are we page locked?
        je      short ranolock
        push    ax
        push    dx
        push    es
        cCall   IAllocCStoDSAlias,<h>   ; Get an alias selector (type doesn't
        pop     es
        pop     dx
        mov     pgLockSel, ax           ; matter)
        or      ax, ax                  ; Got selector?
        pop     ax
        jz      rafail                  ;   no, goodbye
ranolock:
        mov     ebx,ds:[esi].pga_next   ; Get address of current next header
        cmp     edx,ds:[esi].pga_size   ; Are we growing or shrinking?
        ja      short raextend          ; We are growing

        call    rashrink

ifdef WOW
        ; the following dpmicall is basically a NOP. so just
        ; avoid the call altogether.
        ;                                    - Nanduri Ramakrishna
else
        mov     bx, h
        mov     ax, pgLockSel           ; Were we page locked?
        or      ax, ax
        jz      short rasame            ;  no, nothing to do
        Handle_To_Sel   bl
        DPMICALL 0004h
endif

rasame_pglock:
ifdef WOW
        ; avoid the call altogether.
else
        mov     bx, pgLockSel           ; Were we page locked?
        or      bx, bx
        jz      short rasame
        DPMICALL 0005h
endif

rasame:
        mov     ax,h                    ; Return the same handle
        jmp     raexit                  ; All done

raextend:
        test    rflags,GA_DISCCODE      ; Not allowed to grow a disccode seg
        jnz     short rafail1
if KDEBUG
        call    CheckGAllocBreak
        jc      rafail1
endif
        push    ax
        call    GrowSelArray
        mov     cx, ax
        pop     ax                      ; Did we get the selectors?
        jcxz    rafail1                 ;  no, fail
        mov     h, cx                   ; Update handle
        call    ragrow
        jnc     short rasame_pglock     ; Success
        test    mflags,GA_DISCARDABLE   ; if discardable, just stop now
        jz      short ramove            ;  since it might get discarded!
rafail1:                    
        jmp     rafail

; Here to try to move the current block
; AX = client address of current block
; ES:0 = arena header of current block
; CH = lock count of current block
; EDX = new requested size of block

ramove:
        mov     ebx, edx                ; Size now in EBX
        mov     canmove, 1
        mov     dx,rflags               ; get the passed in flags
        test    dx,GA_MOVEABLE          ; Did they say OK to move
        jnz     short ramove1           ; Yes, try to move even iflocked or fixed
        cmp     locked, 0               ; Locked?
                                        ; Continue if this handle not locked
        jnz     short racompact         ; yes, try to find space to grow in place
        or      dx,GA_MOVEABLE          ; If moveable, make sure bit set.
        test    h,GA_FIXED              ; Is this a moveable handle?
        jz      short ramove2           ; Yes, okay to move

racompact:
        xor     dx,dx                   ; No, get size of largest free block
        call    gcompact
        jmp     racantmove

ramove1:
        test    h, GA_FIXED
        jz      short ramove2
        and     dx, NOT GA_MOVEABLE
ramove2:
        mov     ax,dx                   ; AX = allocation flags
;;;     mov     bx,si                   ; EBX = size of new block
        mov     cx,1                    ; CX = owner (use size for now)
        call    gsearch                 ; Find block big enough
        jz      short racantmove        ; Cant find one, grow in place now?
        mov     esi, eax                ; ESI = destination arena
        call    PreAllocArena           ; Required for gmovebusy
        jz      short ramove2a
        mov     cx, pgLockSel           ; Do we have to page lock it?
        jcxz    ramove3
        cCall   PageLockLinear,<ds:[esi].pga_address,ds:[esi].pga_size>
        jnc     short ramove3                   ; Locked it?
ramove2a:
        xor     edx, edx                ;  no, free memory block
        call    gmarkfree
        jmps    racantmove
ramove3:
        mov     cx,h

        cCall   get_arena_pointer32,<cx>
        mov     edx,eax

        call    gmovebusy               ; Call common code to move busy block
                                        ; (AX destroyed)

        push    ebx
        push    esi
        mov     esi, edx                        ; free block just emptied
        mov     ebx, ds:[esi].pga_prev          ; See if block can be
        cmp     ds:[ebx].pga_owner, GA_NOT_THERE; returned to win386
        jne     short ra_no_unlink
        push    ecx
        mov     ecx, ds:[esi].pga_next
        cmp     ds:[ecx].pga_owner, GA_NOT_THERE
        jne     short ra_no_unlink_ecx
        mov     eax, ds:[ecx].pga_next
        cmp     eax, ds:[eax].pga_next          ; Sentinel?
        je      short ra_no_unlink_ecx          ;  yes, keep this block

        push    edx
        push    edi
        cCall   UnlinkWin386Block
        pop     edi
        pop     edx

ra_no_unlink_ecx:
        pop     ecx
ra_no_unlink:
        pop     esi
        pop     ebx

        cCall   set_selector_limit32,<ds:[esi].pga_handle,ds:[esi].pga_size>
        jmp     rasame_pglock

racantmove:
        mov     dx, h
        call    pdref

        mov     ebx,rsize
        clc
        call    galign                  ; assuming there is room.

        mov     ebx,ds:[esi].pga_next   ; Get address of current next header
        call    ragrow
        jc      short racmove3
        jmp     rasame_pglock

racmove3:
        xor     dx,dx                   ; No, get size of largest free block
        call    gcompact
        mov     dx,ax                   ; DX = size of largest free block

rafailmem:

        mov     eax,ds:[esi].pga_size   ; AX = size of current block
        mov     esi,ds:[esi].pga_next   ; Check following block
        cmp     ds:[esi].pga_owner,di   ; Is it free?
        jne     short rafailmem0        ; No, continue
        add     eax,ds:[esi].pga_size   ; Yes, then include it as well
;;;     inc     ax
rafailmem0:
        cmp     ax,dx                   ; Choose the larger of the two
        jbe     short rafailmem1
        mov     dx,ax
rafailmem1:
        push    dx                      ; Save DX
        KernelLogError  DBF_WARNING,ERR_GREALLOC,"GlobalReAlloc failed"
        pop     dx                      ; Restore DX

        xor     ax,ax

raexit:
        push    ax
        push    bx
        push    dx

        mov     bx, pgLockSel
        or      bx, bx                  ; Have alias selector?
        jz      short noSel             ;  nope, all ok
        cCall   free_sel,<bx>
noSel:
        mov     bx, h
;;;     inc     bl
        and     bl, NOT 1
        mov     cx, oldh
;;;     inc     cl
        and     cl, NOT 1
        cmp     bx, cx                  ; Did we get new selector array?
        je      short no_new_handle     ;  nope.
        or      ax, ax                  ; Did we succeed?
        jz      short free_new
        HtoS    cl
        cCall   FreeSelArray,<cx>       ; Free old selector array
        jmps    no_new_handle
                                        ; Update old selector array
free_new:
        HtoS    bl
        cCall   get_arena_pointer32,<bx>        ; Get new arena (may have moved)
        mov     esi,eax
        HtoS    cl
        cCall   AssociateSelector32,<cx,esi>    ; Set up old sel array
        cCall   set_selector_address32,<cx,ds:[esi].pga_address>
        lsl     ecx, ecx                        ; Get old length
if KDEBUG
        jz      short @F
        int 3
@@:
endif
        add     ecx, 10000h
        shr     ecx, 16                         ; CL has old # selectors
        xchg    ds:[esi].pga_selcount, cl
        mov     ax, oldh
        xchg    ds:[esi].pga_handle, ax ; Reset handle
        cCall   AssociateSelector32,<ax,0,0>    ; Disassociate new array
fsloop:
        cCall   free_sel,<ax>                   ; Free new selector array
        add     ax, 8
        loop    fsloop

no_new_handle:
        pop     dx
        pop     bx
        pop     ax
        mov     cx, ax

        mov     sp,bp
        pop     bp
        ret

cEnd    nogen

;-----------------------------------------------------------------------;
; rashrink                                                              ;
;                                                                       ;
; Shrinks the given block                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       Here to shrink a block                                          ;
;       DS:ESI = arena header of current block                          ;
;       DS:EBX = arena header of next block                             ;
;       EDX = new requested size                                        ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ALL but DS, DI                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       gsplice                                                         ;
;       gmarkfree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;
cProc   rashrink,<PUBLIC,NEAR>
cBegin nogen

        call    PreAllocArena           ; Make sure we can do it
        jz      short rashrunk
         
        mov     ax,ds:[esi].pga_handle
        or      ax,ax
        jz      short ra_free
        Handle_To_Sel   al
        push    ecx
        push    edx
        lsl     ecx, eax
        Limit_To_Selectors      ecx     ; Old # selectors
        dec     edx
        Limit_To_Selectors      edx     ; New # selectors
        sub     cx, dx             
        jbe     short none_to_free

        mov     ds:[esi].pga_selcount, dl
        push    ax
        .errnz  SIZE DscPtr-8
        shl     dx, 3
        add     ax, dx                  ; First selector to free
ras_loop:
        cCall   free_sel,<ax>
        add     ax, SIZE DscPtr
        loop    ras_loop
        pop     ax

none_to_free:
        pop     edx
        pop     ecx
        
        cCall   set_selector_limit32,<ax,edx>
ra_free:
        cmp     edx,ds:[esi].pga_size   ; Enough room from for free block?
        jae     short rashrunk          ; No, then no change to make

        call    gsplice                 ; splice new block into the arena
        mov     esi, edx
        xor     edx, edx
        call    gmarkfree               ; Mark it as free
rashrunk:
        ret
cEnd nogen

;-----------------------------------------------------------------------;
; ragrow                                                                ;
;                                                                       ;
; Tries to grow the given global memory object in place                 ;
;                                                                       ;
; Arguments:                                                            ;
;       AX:0 = client address of current block                          ;
;       FS:ESI = arena header of current block                          ;
;       FS:EBX = arena header of next block                             ;
;       EDX = new requested size of block                               ;
;                                                                       ;
; Returns:                                                              ;
;       CY = 0          Success                                         ;
;                                                                       ;
;       CY = 1          Failed                                          ;
;               ESI preserved                                           ;
;               EDX contains free memory required                       ;
;                                                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ALL but DS, DI                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       is_there_theoretically_enough_space                             ;
;       can_we_clear_this_space                                         ;
;       gjoin                                                           ;
;       gzero                                                           ;
;       rashrink                                                        ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 05-Sep-1988 20:10:15  -by-  David N. Weise  [davidw]             ;
; Made ragrow be more intelligent by trying to extend into moveable     ;
; blocks.                                                               ;
;-----------------------------------------------------------------------;
cProc   ragrow,<PUBLIC,NEAR>
cBegin nogen

        push    ds:[esi].pga_size       ; Save in case we have to back out
        push    edx
        push    esi                     ; Save current block address
        sub     edx, ds:[esi].pga_size  ; compute amount of free space wanted
        xchg    esi,ebx                 ; ESI = next block address
        mov     cx,[di].hi_count
        push    ax
        push    cx
        push    esi
        call    is_there_theoretically_enough_space
        pop     esi
        pop     cx
        cmp     eax,edx
        jb      short ragx
        call    can_we_clear_this_space
        jz      short ragx
        cCall   alloc_data_sel,<ds:[esi].pga_address, edx>

        or      ax, ax                  ; Did we get a selector?
        jnz     short okk               ;  yes, continue
        jmps    ragx            
okk:
        mov     cx, ax
        pop     ax
        push    cx                      ; Parameter to free_sel (below)
        push    edx
        call    gjoin                   ; and attach to end of current block
        pop     edx
        test    byte ptr rflags,GA_ZEROINIT ; Zero fill extension?
        jz      short ranz                      ; No, continue
        mov     bx,cx                   ; Yes, BX = first paragraph to fill
        mov     ecx,edx                 ; compute last paragraph to fill
        call    gzero                   ; zero fill extension
ranz:
        call    FreeSelArray
        pop     edx                     ; clear the stack
        pop     edx                     ; New length of block
        mov     bx, ds:[esi].pga_handle
        Handle_To_Sel   bl
        cCall   set_selector_limit32,<bx,edx>

ifndef WOW  ; WOW doesn't lock pages
        cmp     ds:[esi].pga_pglock, 0
        je      short rag1

        mov     ax, 4                   ; Page lock the whole thing
        int     31h
        mov     ax, bx
        jc      short rag2
endif; WOW

rag1:
        mov     ebx,ds:[esi].pga_next   ; Pick up new next block address
        call    rashrink                ; Now shrink block to correct size
        add     sp, 4
        clc
        ret
ragx:
        pop     ax
        pop     esi                     ; Recover current block address
        pop     edx
        add     sp, 4                   ; toss original size
        stc
        ret
rag2:
if KDEBUG
int 3
endif
        pop     edx                     ; Shrink back to orignal size
        mov     ebx, ds:[esi].pga_next
        call    rashrink
        stc                             ; and fail
        ret
        
cEnd nogen


;-----------------------------------------------------------------------;
; gfree                                                                 ;
;                                                                       ;
; Frees a global object.                                                ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = global memory object handle                                ;
;       CX = owner field value to match or zero if dont care            ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;       CX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;       CX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ?                                                               ;
; Calls:                                                                ;
;       gdref                                                           ;
;       free_object                                                     ;
;       hfree                                                           ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 11:48:38a  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block and restructured.                      ;
;-----------------------------------------------------------------------;

cProc   gfree,<PUBLIC,NEAR>
cBegin  nogen

        push    cx
        call    pdref
        pop     dx
        jz      short object_discarded
        call    free_object
        jmps    gfree_exit

        ;** When the object is discarded, we have to remove the sel table
        ;*      pointer to the object (this points to the >owner< of the
        ;**     block for discardable objects)
object_discarded:
        PUBLIC object_discarded
        xor     eax,eax
        cCall   AssociateSelector32, <si,eax> ;Remove in the sel table
        cCall   FreeSelArray,<si>
        xor     ax,ax                   ;Force success

gfree_exit:
        mov     cx,ax
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; free_object                                                           ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = owner field value to match or zero if dont care            ;
;       DS:DI = address of global heap info                             ;
;       ES:ESI = address of arena header                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       glrudel                                                         ;
;       gmarkfree                                                       ;
;       hfree                                                           ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 02:59:06p  -by-  David N. Weise     [davidw]        ;
; Moved it from gfree.                                                  ;
;-----------------------------------------------------------------------;

cProc   free_object,<PUBLIC,NEAR>
cBegin  nogen
        or      dx,dx
        jz      short free_it
        cmp     ds:[esi].pga_owner,dx
        je      short free_it
        mov     ax,-1
        jmps    free_object_exit
free_it:
        call    glrudel                         ; delete object from LRU chain
ifdef WOW
        ; No need to call DPMI to unpagelock
else
        movzx   cx, ds:[esi].pga_pglock
        jcxz    fo_notpglocked
        mov     bx, ds:[esi].pga_handle
unpagelock:
        DPMICALL 0005h
        loop    unpagelock
endif
        mov     ds:[esi].pga_pglock, 0
fo_notpglocked:
        push    dx
        xor     edx,edx
        call    gmarkfree                       ; free the object

        mov     ebx, ds:[esi].pga_prev          ; See if block can be
        cmp     ds:[ebx].pga_owner, GA_NOT_THERE; returned to win386
        jne     short fo_no_return
        mov     ecx, ds:[esi].pga_next
        cmp     ds:[ecx].pga_owner, GA_NOT_THERE
        jne     short fo_no_return
        push    ecx
        mov     ecx, ds:[ecx].pga_next
        cmp     ecx, ds:[ecx].pga_next          ; Sentinel?
        pop     ecx
        je      short fo_no_return              ;  yes, keep this block

        cCall   UnlinkWin386Block
        jmps    fo_no_discard

fo_no_return:
        call    gwin386discard
fo_no_discard:
        Handle_To_Sel   dl
        cCall   AssociateSelector32,<dx,edi>    ; Trash sel table entry
        cCall   FreeSelArray,<dx>
        pop     dx
        xor     ax,ax                   ;!!! just for now force success
free_object_exit:
        ret
cEnd    nogen


cProc   free_object2,<PUBLIC,FAR>
cBegin  nogen
        call    glrudel                         ; delete object from LRU chain
ifdef WOW
        ; No need to call DPMI to unpagelock
else
        movzx   cx, ds:[esi].pga_pglock
        jcxz    fo2_notpglocked
        mov     bx, ds:[esi].pga_handle
unpagelock2:
        DPMICALL 0005h
        loop    unpagelock2
endif
        mov     ds:[esi].pga_pglock, 0
fo2_notpglocked:
        xor     edx,edx
        call    gmarkfree                       ; free the object

        mov     ebx, ds:[esi].pga_prev          ; See if block can be
        cmp     ds:[ebx].pga_owner, GA_NOT_THERE; returned to win386
        jne     short fo2_no_return
        mov     ecx, ds:[esi].pga_next
        cmp     ds:[ecx].pga_owner, GA_NOT_THERE
        jne     short fo2_no_return
        push    ecx
        mov     ecx, ds:[ecx].pga_next
        cmp     ecx, ds:[ecx].pga_next          ; Sentinel?
        pop     ecx
        je      short fo2_no_return              ;  yes, keep this block

        cCall   UnlinkWin386Block
        jmps    fo2_no_discard

fo2_no_return:
        call    gwin386discard
fo2_no_discard:
        xor     ax,ax                   ;!!! just for now force success
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; free_handle                                                           ;
;                                                                       ;
; Frees the given handle.                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:SI = handle table entry address                              ;
;                                                                       ;
; Returns:                                                              ;
;       AX = 0                                                          ;
;       CX = AX                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1                                                         ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ?                                                               ;
; Calls:                                                                ;
;       hfree                                                           ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 20, 1986 02:30:32p  -by-  David N. Weise     [davidw]        ;
; Moved it from gfree.                                                  ;
;-----------------------------------------------------------------------;

;cProc  free_handle,<PUBLIC,NEAR>
;cBegin nogen
;       xor     ax,ax
;       or      si,si
;       jz      short free_handle_exit
;       push    bx
;       mov     bx,si
;       call    hfree
;       pop     bx
;free_handle_exit:
;       ret
;cEnd   nogen


;-----------------------------------------------------------------------;
; gfreeall                                                              ;
;                                                                       ;
; Frees all global objects that belong to the given owner.  It first    ;
; loops through the global heap freeing objects and then loops through  ;
; the handle table freeing handles of discarded objects.                ;
;                                                                       ;
; Arguments:                                                            ;
;       DX = owner field value to match                                 ;
;       DS:DI = address of global heap info                             ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       CX,ES,SI                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       free_object                                                     ;
;       henum                                                           ;
;       hfree                                                           ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 05:46:52p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gfreeall,<PUBLIC,NEAR>
cBegin  nogen

        mov     esi,[di].phi_first      ; ES:DI points to first arena entry
        mov     cx,[di].hi_count        ; CX = #entries in the arena
free_all_objects:
        push    cx
        call    free_object             ; Free object if matches owner
        pop     cx
        mov     esi,ds:[esi].pga_next   ; Move to next block
        loop    free_all_objects

; may go extra times, as CX does not track coalescing done by gfree,
;  but no big whoop


        push    ax
        push    ebx
        push    edi
        CheckKernelDS   FS
        ReSetKernelDS   FS
        movzx   ecx, SelTableLen
        shr     ecx, 2
        mov     edi, SelTableStart
        mov     esi, edi
        smov    es, ds
        UnSetKernelDS   FS
free_all_handles_loop:
        movzx   eax, dx
        repne scas      dword ptr es:[edi]      ; Isn't this easy?
        jne     short we_be_done
        lea     eax, [edi-4]
        sub     eax, esi
        shl     ax, 1
        or      al, SEG_RING

        lar     ebx, eax
        test    bh,DSC_PRESENT                  ; segment present?
        jnz     short free_all_handles_loop     ; yes, not a handle
        test    ebx,DSC_DISCARDABLE SHL 16      ; discardable?
        jz      short free_all_handles_loop     ; no, nothing to free
        cCall   FreeSelArray,<ax>
        mov     dword ptr [edi-4], 0            ; Remove owner from table
        jmps    free_all_handles_loop
we_be_done:
        pop     edi
        pop     ebx
        pop     ax
        
gfreeall_done:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; glock                                                                 ;
;                                                                       ;
; Increment the lock count of an object in handle table entry           ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = handle to global object                                    ;
;       CH = handle table flags                                         ;
;       CL = lock count for moveable objects                            ;
;       DX = segment address of object                                  ;
;       DS:DI = address of master object                                ;
;       ES:DI = arena header                                            ;
;                                                                       ;
; Returns:                                                              ;
;       CX = updated lock count                                         ;
;       DX = pointer to client area                                     ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1 if count overflowed.                                     ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 05:38:57p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   glock,<PUBLIC,NEAR>
cBegin  nogen
        push    ax
        inc     ch                      ; Increment lock count
        jz      short overflow          ; All done if overflow
        mov     ds:[esi].pga_count,ch   ; Update lock count
glockerror:
overflow:
        pop     ax
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; gunlock                                                               ;
;                                                                       ;
; Decrement the lock count of an object.                                ;
;                                                                       ;
; Arguments:                                                            ;
;       BX = handle to global object                                    ;
;       CH = handle table flags                                         ;
;       CL = lock count for moveable objects                            ;
;       CX = handle table flags and lock count for moveable objects     ;
;       DS:DI = address of master object                                ;
;       ES:DI = arena header                                            ;
;                                                                       ;
; Returns:                                                              ;
;       CX = updated lock count, no underflow                           ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       glrutop                                                         ;
; History:                                                              ;
;                                                                       ;
;  Fri Sep 19, 1986 04:39:01p  -by-  David N. Weise     [davidw]        ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   gunlock,<PUBLIC,NEAR>
cBegin  nogen
        push    ax
        mov     ax,bx
        dec     ch                      ; Decrement usage count
        cmp     ch,0FFh-1               ; ff -> fe, 0 -> ff
        jae     short count_zero                ; Return if pinned, or was already 0
        dec     ds:[esi].pga_count      ; Non-zero update lock count
        jnz     short count_positive            ; All done if still non-zero
        test    cl,GA_DISCARDABLE       ; Is this a discardable handle?
        jz      short count_zero                ; No, all done
        call    glrutop                 ; Yes, bring to top of LRU chain
count_zero:
        xor     cx,cx
count_positive:
        pop     ax
        ret
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3gmoreme.asm ===
TITLE	GMOREMEM - More Global Memory Manager procedures

.xlist
include kernel.inc
include tdb.inc
include newexe.inc
.list

include protect.inc

.386p

DataBegin

externB Kernel_Flags
externW pGlobalHeap
externW curTDB
externW headTDB
externW Win_PDB
externW MaxCodeSwapArea

DataEnd


sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

if SDEBUG
externNP DebugMovedSegment
endif


externNP gcompact


externNP get_physical_address
externNP GrowHeap

externNP guncompact

;-----------------------------------------------------------------------;
; genter                                                                ;
; 									;
; Enters a critical region for the global heap.				;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	DS:DI = address of GlobalInfo for global heap			;
;	FS    = Kernel Data segment					;
; 	    								;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Sep 29, 1986 03:05:33p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	genter,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS	FS
	mov	ds,pGlobalHeap
	xor	edi,edi
	inc	[di].gi_lrulock
	ret
	UnSetKernelDS	FS
cEnd nogen


;-----------------------------------------------------------------------;
; gleave                                                                ;
; 									;
; Leaves a critical region for the global heap.				;
; 									;
; Arguments:								;
;	DS:DI = address of GlobalInfo for global heap			;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Sep 29, 1986 03:07:53p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gleave,<PUBLIC,NEAR>
cBegin nogen
	dec	ds:[gi_lrulock]
	jnz	short gl_ret
	test	ds:[gi_flags],GIF_INT2
	jz	short gl_ret
	and	ds:[gi_flags],NOT GIF_INT2
	int	02h
gl_ret: ret
cEnd nogen


;-----------------------------------------------------------------------;
; gavail                                                                ;
; 									;
; Gets the available memory.						;
; 									;
; Arguments:								;
;	DX    = number of paragraphs wanted				;
;	DS:DI = master object						;
; Returns:								;
;	AX = #paragraphs available for the biggest block		;
;	DX = 0 								;
;									;
; Error Returns:							;
;	none								;
; 									;
; Registers Preserved:							;
;	DI,DS 								;
; Registers Destroyed:							;
;	BX,CX,SI,ES							;
; Calls:								;
;	gcompact							;
; 									;
; History:								;
;  Thu Apr 06, 1988 08:00:00a  -by-  Tim Halvorsen    [iris]		;
; Fix bug in computation of space available when GA_NOT_THERE object	;
; resides above discard fence.						;
;									;
;  Wed Oct 15, 1986 05:09:27p  -by-  David N. Weise   [davidw]          ;
; Moved he_count to ga_count.						;
; 									;
;  Sat Sep 27, 1986 09:37:27a  -by-  David N. Weise   [davidw]          ;
; Reworked it.								;
;-----------------------------------------------------------------------;

cProc	gavail,<PUBLIC,NEAR>
cBegin nogen
	push	esi
	push	ecx
	mov	byte ptr [di].gi_cmpflags,0
	call	gcompact

	mov	cx,word ptr [di].gi_disfence_hi	; ECX has address of fence
	shl	ecx, 16
	mov	cx,word ptr [di].gi_disfence_lo
	mov	esi,[di].phi_first
	xor	edx,edx
loop_for_beginning:
	xor	eax,eax
	mov	esi,ds:[esi].pga_next		; Next block
	cmp	ds:[esi].pga_sig,GA_ENDSIG	; End of arena?
	je	all_done
	mov	ebx, ds:[esi].pga_address
	add	ebx, ds:[esi].pga_size		; End of block
	sub	ebx, ecx			; Below fence?
	jbe	short include_it		;  yes, use it
	cmp	ebx, ds:[di].gi_reserve		; Difference > reserve?
	jb	all_done			;  no, can't use it
include_it:	
	cmp	ds:[esi].pga_owner,di		; Free?
	jz	short how_big_is_it		;  Yes calculate length
	cmp	ds:[esi].pga_owner,GA_NOT_THERE	; Marker arena?
	jz	short loop_for_beginning       	;  Yes, next block
	mov	bx,ds:[esi].pga_handle	
	test	bl, GA_FIXED			; Fixed?
	jnz	short loop_for_beginning	; Yes, next block
	cmp	ds:[esi].pga_count,0		; Locked?
	jne	short loop_for_beginning	; Yes, next block
	lar	ebx, ebx			; See lar docs and protect.inc
	test	ebx, DSC_DISCARDABLE SHL 16	; bit is in third byte of EBX
	jz	short loop_for_beginning	;  Not discardable, next block
						
how_big_is_it:
	mov	eax,ds:[esi].pga_size		; Use this size
loop_for_bigness:
	mov	esi,ds:[esi].pga_next		; Next block
	cmp	ds:[esi].pga_owner,di		; Free?
	jz	short include_his_size		;  Yes, include size
	cmp	ds:[esi].pga_owner,GA_NOT_THERE	; Marker arena?
	jz	short end_of_bigness       	;  Yes
		      
	cmp	ds:[esi].pga_sig,GA_ENDSIG	; End of arena?
	jz	short end_of_bigness
	mov	bx,ds:[esi].pga_handle
	test	bx,GA_FIXED			; Fixed?
	jnz	short end_of_bigness		; Yes, stop looking
	cmp	ds:[esi].pga_count,0		; Locked?
	jne	short end_of_bigness		; Yes, stop looking
	lar	ebx, ebx			; See lar docs and protect.inc
	test	ebx, DSC_DISCARDABLE SHL 16	; bit is in third byte of EBX
	jz	short loop_for_bigness		; No, dont include in count then
include_his_size:     				; Free or Discardable
	add	eax,ds:[esi].pga_size		; Increase available space
	jmp	loop_for_bigness

end_of_bigness:
	mov	esi, ds:[esi].pga_prev		; Get end of useable block
	mov	ebx, ds:[esi].pga_address
	add	ebx, ds:[esi].pga_size
	mov	esi, ds:[esi].pga_next
	sub	ebx, ecx			; Subtract fence
	jbe	short all_below_fence
	cmp	ebx, ds:[di].gi_reserve
	jae	short all_below_fence

	sub	eax,ebx			; We are above the fence, subtract
					; that above the fence and say goodbye
all_below_fence:
	cmp	eax,edx			; Did we find a bigger block?
	jbe	short blech_o_rama	; No, then look again
	mov	edx,eax			; Yes, remember size
blech_o_rama:
	jmp	loop_for_beginning

all_done:
	mov	eax,edx
	sub	eax, 20h		; Dont be too exact
	or	eax,eax			; See if negative
	jns	short gcfinal			  
	xor	eax, eax		; Disallow negative returns
gcfinal:
	and	al,NOT 1Fh		; round down to nearest alignment
	xor	dx,dx  
	pop	ecx
	pop	esi
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; greserve                                                              ;
; 									;
; Sets the size of the discardable code reserve area.			;
; If the new size is larger than the old size, it checks to see		;
; if there is enough room to support the new size.			;
; 									;
; Arguments:								;
;	AX = new greserve size						;
; 									;
; Returns:								;
;	CX = the largest greserve we can get				;
;	AX != 0  success						;
;	AX  = 0  failure						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	BX,DX,ES							;
; 									;
; Calls:								;
;	genter								;
;	gcompact							;
;	will_gi_reserve_fit						;
;	gleave								;
; 									;
; History:								;
;  Fri Jun 14, 1991	       -by-  Craig A. Critchley [craigc]	;
; Lots has happened since 1987 - undo change to get 128K always in	;
; enhanced mode, added call to guncompact for ROM			;
; 									;
;  Tue May 19, 1987 00:03:08p  -by-  David N. Weise   [davidw]          ;
; Made it far.								;
;									;
;  Sat Sep 27, 1986 01:03:08p  -by-  David N. Weise   [davidw]          ;
; Made it perform according to spec and added this nifty comment block.	;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	greserve,<PUBLIC,FAR>		; FAR because of the gcompact below
	localD	new_size
cBegin
	GENTER32
	ReSetKernelDS	FS

        movzx   eax, ax
	shl	eax, 4			; convert to bytes
	mov	ebx, eax
	shl	eax, 1			; double it
	add	eax, ebx		; triple it!
					; hold 3 64k segs for rep move case
	cmp	eax, 030000h		; if >= 192K, THAT'S ENOUGH!
	jb	short no_extra		;   So there, Mr EXCEL!
	krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "greserve: Who wants > 192K?"
	mov	eax, 030000h

no_extra:
	add	eax,GA_ALIGN_BYTES
        and     al,byte ptr GA_MASK_BYTES

	mov	new_size,eax
	mov	ebx,eax
	mov	eax, ds:[di].phi_last
	mov	eax, ds:[eax].pga_address
	sub	eax,ebx			; Address of new gi_reserve
	cmp	ebx, [di].gi_reserve	; New value <= old?
	ja	short @F
        ;jmp    new_okay
	; never reduce the reserve to less than 192K!!!
	cmp	ebx, 30000h
	jae	new_okay
	;krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "greserve: Ignoring reduction of reserve area."
	or	ax, 1			; success code
	jmp	gr_exit
@@:
if KDEBUG
	mov	ecx, ebx
	shr	ecx, 16
        krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "greserve: #cx#BX bytes"
endif
			
	call	will_gi_reserve_fit
	jnc	short new_okay

	push   	eax			; Must be junk in the way!
	push	edx
	; removed a compact here 
	mov	ecx, new_size
	call	guncompact		; slide stuff down 
	pop	edx
	pop	eax
	call	will_gi_reserve_fit
	jnc	short new_okay
	
	mov	edx, new_size
;win95 has;        or      byte ptr fs:[Heap_Insert_Position], 1   ; insert at end
        call    GrowHeap                ; Assume this will insert new blk at end
	jc	short will_not_fit
	mov	eax, ds:[di].phi_last
	mov	eax, ds:[eax].pga_address
	sub	eax, new_size
	call	will_gi_reserve_fit
	jnc	short new_okay
will_not_fit:
if KDEBUG
	krDebugOut DEB_ERROR, "greserve doesn't fit"
        INT3_NEVER         ; fixed at 192k, see ldboot.asm
endif
	xor	ax,ax
	jmps	gr_exit

new_okay:
	mov	word ptr [di].gi_disfence_lo,ax
	shr	eax, 16
	mov	word ptr [di].gi_disfence_hi,ax
	mov	edx,new_size
	mov	[di].gi_reserve,edx
	or	ax, 1			; success code
gr_exit:
	GLEAVE32
	UnSetKernelDS	FS
cEnd			


;-----------------------------------------------------------------------;
; will_gi_reserve_fit                                                   ;
; 									;
; See if new size okay by scanning arena backwards.  If not under EMS	;
; this is trivial.  With EMS we take into consideration the disjoint	;
; areas and the WRAITHS.						;
; 									;
; Arguments:								;
;	EAX = gi_disfence						;
;	DS:DI = master object						;
;									;
; Returns:								;
;	CF = 0  new size ok						;
;	CF = 1  new size NOT ok						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	AX,DX,DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	none								;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Jul 12, 1987 08:13:23p  -by-  David N. Weise      [davidw]	;
; Added EMS support.							;
; 									;
;  Sat Sep 27, 1986 01:03:57p  -by-  David N. Weise   [davidw]          ;
; Rewrote it.								;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	will_gi_reserve_fit,<PUBLIC,NEAR>
cBegin nogen

	push	esi

	mov	esi, [di].phi_last
	mov	esi, [esi].pga_prev		     ; skip sentinal

does_it_fit:
	mov	esi, [esi].pga_prev		    ; do first to skip nothere
	cmp	[esi].pga_owner, di		    ; is it free?
	je	short ok_thisll_fit
	test	[esi].pga_flags, GA_DISCCODE	    ; is it code?
	jz	short nope_wont_fit
ok_thisll_fit:
	cmp	eax, [esi].pga_address		    ; do we have enough
	jb	short does_it_fit

it_all_fits:
	clc					    ; return excellent!
	pop	esi
	ret

nope_wont_fit:
	stc					    ; return heinous!
	pop	esi
	ret

cEnd nogen


;-----------------------------------------------------------------------;
; gnotify                                                               ;
; 									;
; This is where the hard job of updating the stacks and thunks happens.	;
; We only walk stacks and thunks for code and data (defined by being	;
; LocalInit'ed), not for resources or task allocated segments.		;
; 									;
; Arguments:								;
;	AL = message code						;
;	BX = handle							;
;	CX = optional argument						;
;	ESI = address of arena header					;
; 									;
; Returns:								;
;	AX = return value from notify proc or AL			;
;	DS = current DS (i.e. if DATA SEG was moved then DS is updated.	;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI								;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jun 24, 1987 03:08:39a  -by-  David N. Weise   [davidw]		;
; Adding support for Global Notify.					;
; 									;
;  Wed Dec 03, 1986 01:59:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	gnotify,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	di
	xor	ah,ah
	mov	di,cx
	mov	cx,ax
	loop	notify_discard
	errnz	<GN_MOVE - 1>

	mov	cx,ds
	cmp	cx,bx			; Did we move DS?
	jne	short notify_exit_0		; No, continue
notify_exit_0:
	jmp	notify_exit

notify_discard:
	loop	notify_exit_0
	errnz	<GN_DISCARD - 2>

;-----------------------------------------------------------------------;
;  Here for a segment discarded.					;
;-----------------------------------------------------------------------;

	xor	ax,ax
	test	bl,1
	jnz	short notify_exit_0		; SDK is wrong, can't free fixed.
	push	ebx
	lar	ebx, ebx			; See lar docs and protect.inc
	test	ebx, DSC_DISCARDABLE SHL 16	; bit is in third byte of EBX
	pop	ebx
	jz	short notify_exit_0

	test	ds:[esi].pga_flags,GAH_NOTIFY
	jnz	@F
	jmp	dont_bother_asking
@@:
	push	bx
	push	cx
	push	dx
	mov	ax,1
	mov	es,ds:[esi].pga_owner
	cmp	es:[ne_magic],NEMAGIC
	jz	short dont_ask		; doesn't belong to a particular task
	mov	ax,es
	SetKernelDS es
	push	HeadTDB 		; Look for TDB that owns this block.
	UnSetKernelDS es
find_TDB:
	pop	cx
	jcxz	dont_ask
	mov	es,cx
	push	es:[TDB_next]
	cmp	ax,es:[TDB_PDB]
	jnz	short find_TDB
	pop	cx			; clear stack in 1 byte
	mov	cx,word ptr es:[TDB_GNotifyProc][0]	; paranoia
	or	cx,word ptr es:[TDB_GNotifyProc][2]
	jz	short dont_ask
	push	ds
	SetKernelDS
	or	Kernel_Flags[1],kf1_GLOBALNOTIFY

	push	Win_PDB			; Save current PDB
	mov	Win_PDB, ax		; Ensure it is the task's
	push	fs

	push	dword ptr es:[TDB_GNotifyProc]

	push	bx			; push arg for notify proc

	mov	ax,ss			; Zap segment regs so DS
	mov	ds,ax			; doesn't get diddled by callee
	mov	es,ax

	mov	bx,sp
	call	dword ptr ss:[bx]+2
	add	sp,4			; clean up stack.

	SetKernelDS
	and	Kernel_Flags[1],not kf1_GLOBALNOTIFY

	pop	fs
	pop	Win_PDB			; Restore PDB

	pop	ds
	UnSetKernelDS
dont_ask:
	pop	dx
	pop	cx
	pop	bx
	or	ax,ax			; Well, can we?
	jz	short notify_exit
dont_bother_asking:

	mov	es,ds:[esi].pga_owner
	cmp	es:[ne_magic],NEMAGIC
	jnz	short not_in_exe
	mov	di,es:[ne_segtab]
	mov	cx,es:[ne_cseg]
	jcxz	not_in_exe
pt0a:
	cmp	bx,es:[di].ns_handle
	jz	short pt0b
	add	di,SIZE NEW_SEG1
	loop	pt0a
	jmps	not_in_exe
pt0b:
	and	byte ptr es:[di].ns_flags,not NSLOADED	 ; Mark as not loaded.
not_in_exe:

why_bother_again:
	xor	di,di
if SDEBUG
	cCall	DebugMovedSegment,<si,di>
endif
	mov	ax,1
notify_exit:
	or	ax,ax
	pop	di
	pop	si
	ret

gn_error:
	kerror	0FFh,<gnotify - cant discard segment>,si,si
	xor	ax,ax
	jmp	notify_exit

cEnd nogen

;-----------------------------------------------------------------------;
; MemoryFreed								;
;									;
; This call is apps that have a GlobalNotify procedure.  Some apps	;
; may shrink the segment instead of allowing it to be discarded, or	;
; they may free other blocks.  This call tells the memory manager	;
; that some memory was freed somewhere. 				;
;									;
; Arguments:								;
;	WORD = # paragraphs freed					;
;									;
; Returns:								;
;	DX:AX = amount of memory that still needs freeing		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
;									;
;  Fri 08-Apr-1988 10:25:55  -by-  David N. Weise  [davidw]		;
; Wrote it!								;
;-----------------------------------------------------------------------;

cProc	MemoryFreed,<PUBLIC,FAR>

	parmW	memory_freed
cBegin
	xor	ax,ax
	SetKernelDS
	test	Kernel_Flags[1],kf1_GLOBALNOTIFY
	jz	short mf_done
	mov	ds,pGlobalHeap
	UnSetKernelDS
	mov	ax,memory_freed
	or	ax,ax
	jz	short mf_inquire
	or	ds:[hi_ncompact],1	; Remember we discarded something
	sub	ds:[hi_distotal],ax	; Have we discarded enough yet?
	ja	short mf_inquire
	or	ds:[hi_ncompact],10h	; To tell gdiscard that we're done.
mf_inquire:
	mov	ax,ds:[hi_distotal]	; Have we discarded enough yet?
mf_done:
	xor	dx,dx

cEnd


;-----------------------------------------------------------------------;
; SetSwapAreaSize							;
; 									;
; Sets the current task's code swap area size.				;
; 									;
; Arguments:								;
;	WORD	== 0 then current size is just returned			;
; 		!= 0 number paragraphs wanted for swap area		;
; Returns:								;
;	AX = Size actually set						;
;	DX = Max size you can get					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
;	This API is history!!!!						;
; swap area is now fixed at 192k we don't grow or shrink it		;
; 									;
;-----------------------------------------------------------------------;


cProc   SetSwapAreaSize,<PUBLIC,FAR>
	parmW   nParas
cBegin
	SetKernelDS
	mov	dx,MaxCodeSwapArea
	mov	ax,dx
cEnd

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3glru.asm ===
TITLE	GLRU - Primitives for LRU management

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

.386p

DataBegin

externB  Kernel_InDOS
externB  Kernel_flags
;externW  curTDB
externW  loadTDB
externW  pGlobalHeap
;externW  hExeSweep
;externW  WinFlags

if ROM
externW  gdtdsc
endif
	 
DataEnd


sBegin	CODE
assumes CS,CODE

externNP  DPMIProc

ife ROM
externW  gdtdsc
endif

;-----------------------------------------------------------------------;
; lrusweep								;
; 									;
; Searches all of the exe headers in the system for segments that have	;
; been accessed since the last time through.  For each segment found	;
; its referenced byte is reset and that segment is moved to the top	;
; of the lru chain.  This routine is called (default) every 4 timer	;
; ticks from the int 8 handler.						;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	nothing								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DX,DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,ES							;
;									;
; Calls:								;
;	glrutop								;
; 									;
; History:								;
; 									;
;  Tue Apr 21, 1987 06:22:41p  -by-  David N. Weise   [davidw]		;
; Added the check for discarded segments.				;
; 									;
;  Wed Apr 08, 1987 11:00:59a  -by-  David N. Weise   [davidw]		;
; Made it clear only the curTask's private handle table.		;
; 									;
;  Wed Feb 18, 1987 08:13:35p  -by-  David N. Weise   [davidw]		;
; Added the sweeping of the private handle tables.			;
; 									;
;  Tue Feb 10, 1987 02:11:40a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lrusweep,<PUBLIC,FAR>
cBegin nogen

	push	edx
	push	edi
	push	esi
	push	ds
	push	es
	push	fs
	xor	edx,edx
	xor	edi,edi
	SetKernelDS	fs

; [notes from code review 4/91, added by donc 4/16/91
;   1) should check WinFlags1 for WF_PAGING,
;   2) insist on direct LDT access
;   3) try assembling without DPMI
;   4) have LRUSweepFreq= setting in .ini file to control update rate
; ]
					;  Excuses not to do the sweep:
	cmp	kernel_InDOS,0		; SMARTDrive and EMS may be present
	jnz	short dont_do_it	;  => disk buffers over the code segs
	cmp	di,loadTDB		; Ignore interrupt if loading task
	jnz	short dont_do_it
	mov	ds,pGlobalHeap
	cmp	di,ds:[di].gi_lrulock	; Ignore interrupt if inside memory
	jz	short do_it		;  manager

dont_do_it:
	jmp	sweepdone

do_it:
	mov	cx, ds:[di].gi_lrucount
	jcxz	dont_do_it
	mov	esi, ds:[di].gi_lruchain

	mov	bx, gdtdsc
	or	bx, bx	  		; See if we can poke at the LDT
	jz	short sweep_loop_dpmi	;  no, must use DPMI calls
	mov	es, bx		     	;  yes, ES points to the LDT

		      
					; Direct LDT access loop
sweep_loop:
	mov	esi, [esi].pga_lrunext
	mov	bx, [esi].pga_handle

	sel_check bx

if KDEBUG
	test	es:[bx].dsc_hlimit, DSC_DISCARDABLE ; Ensure it really is discardable
	jnz	short sweep_ok		 	   
	Debug_Out "lrusweep: Bad lru entry"
sweep_ok:
endif

	btr	word ptr es:[bx].dsc_access, 0	; Test and reset accessed bit
.errnz DSC_ACCESSED-1		     
	jnc	short sweep_next
				    
	call	glrutop		; Accessed objects are most recently used

sweep_next:
	loop	sweep_loop
	jmps	sweepdone
		     

					; DPMI loop
sweep_loop_dpmi:
	mov	esi, [esi].pga_lrunext
	mov	bx, [esi].pga_handle
	lar	edx, ebx
	shr	edx, 8			; Access bits in DX			   
			
if KDEBUG
	test	dh, DSC_DISCARDABLE	; Ensure it really is discardable
	jnz	short sweep_ok_dpmi		 
	Debug_Out "lrusweep: Bad lru entry"
sweep_ok_dpmi:
endif

	btr	dx, 0		; Segment accessed?
.errnz DSC_ACCESSED-1
	jnc	short sweep_next_dpmi ;  no, leave it where it is on LRU list
				       
	push	cx
	mov	cx, dx
	DPMICALL 0009h		; Set access word
	pop	cx

	call	glrutop		; Accessed objects are most recently used

sweep_next_dpmi:
	loop	sweep_loop_dpmi

sweepdone:
	pop	fs
	pop	es
	pop	ds
	pop	esi
	pop	edi
	pop	edx
	ret
	UnSetKernelDS	fs
cEnd nogen




;
; Entry:
;   DI == 0
;   DS:SI.gi_lruchain -> head of list
;   ES:0  -> arena header of object to insert
;   DX = 0 => insert at head of list
;      !=0 => insert at tail of list
;
; Exit:
;   BX,DX destroyed
;
cProc	LRUInsert,<PUBLIC,NEAR>
cBegin	nogen
	inc	ds:[di].gi_lrucount	; Increment count of LRU entries
	mov	ebx,ds:[di].gi_lruchain	; BX = head of list
	or	dx,dx			; Inserting at head of chain?
	jnz	short lruins0 		; No, tail so dont update head
	mov	ds:[di].gi_lruchain,esi	; Yes, make new one the new head
lruins0:
	or	ebx,ebx			; List empty?
	jnz	short lruins1
	mov	ds:[esi].pga_lruprev,esi; Yes, make circular
	mov	ds:[esi].pga_lrunext,esi
	mov	ds:[di].gi_lruchain,esi
	ret
lruins1:
	mov	edx,esi			; DX = new
	xchg	ds:[ebx].pga_lruprev,edx
	mov	ds:[edx].pga_lrunext,esi

	mov	ds:[esi].pga_lruprev,edx
	mov	ds:[esi].pga_lrunext,ebx

	ret
cEnd	nogen




;
; Entry:
;   DI == 0
;   DS:DI.gi_lruchain -> head of list
;   DS_ESI  -> arena header of object to delete
;
; Exit:
;   EBX,EDX destroyed
;
;
cProc	LRUDelete,<PUBLIC,NEAR>
cBegin	nogen

;
; This is basically a consistency check, in case we don't fix
; GlobalRealloc() for 3.1.
;
	push	eax
	mov	eax,ds:[esi].pga_lrunext
	or	eax,ds:[esi].pga_lruprev
	pop	eax
	jz	lrudel_ret

	dec	ds:[di].gi_lrucount	; Decrement count of LRU entries
	jnz	short lrudel0
	mov	ds:[di].gi_lruchain,edi	; List empty, zero LRU chain.
	mov	ds:[esi].pga_lruprev,edi; Zero pointers in deleted object
	mov	ds:[esi].pga_lrunext,edi
	ret
lrudel0:
	mov	edx,esi
	cmp	ds:[di].gi_lruchain,edx	; Are we deleting the head?
	jne	short lrudel1
	mov	edx,ds:[esi].pga_lrunext
	mov	ds:[di].gi_lruchain,edx	; Yes, make it point to the next one
lrudel1:
	xor	ebx,ebx			; Zero pointers in deleted object
	xchg	ds:[esi].pga_lrunext,ebx

	xor	edx,edx
	xchg	ds:[esi].pga_lruprev,edx
	mov	ds:[edx].pga_lrunext,ebx
	mov	ds:[ebx].pga_lruprev,edx
lrudel_ret:
	ret
cEnd	nogen





cProc	glruSetup,<PUBLIC,NEAR>
cBegin	nogen
	mov	bx,ds:[esi].pga_handle
	test	bl, GA_FIXED
	jz	short gsmoveable
	xor	bx, bx			; Set ZF
	jmps	gsdone
gsmoveable:
	push	ebx
	lar	ebx, ebx
	test	ebx, DSC_DISCARDABLE SHL 16
	pop	ebx
	jz	short gsdone
	or	sp,sp
gsdone:
	ret
cEnd	nogen




;-----------------------------------------------------------------------;
; glrutop								;
; 									;
; Moves a discardable object to the head of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = global arena of moveable object				;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:20:10p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrutop,<PUBLIC,NEAR>
cBegin nogen
	push	ebx
	push	edx
	push	esi
	call	glruSetup
	jz	short glrutop1

	call	LRUDelete
	xor	dx,dx		    ; DX == 0 means insert at head
	call	LRUInsert
glrutop1:
	pop	esi
	pop	edx
	pop	ebx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; glrubot								;
; 									;
; Moves a discardable object to the tail of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = global arena of moveable object				;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:20:10p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrubot,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si
	call	glruSetup
	jz	short glrubot1

	call	LRUDelete
	mov	dx,sp		    ; DX != 0 means insert at tail
	call	LRUInsert
glrubot1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen




;-----------------------------------------------------------------------;
; glruadd								;
; 									;
; Adds a discardable object to the head of the LRU chain.		;
; 									;
; Arguments:								;
;	DS:DI = address of global heap info				;
;	ES:DI = arena header of object					;
; 									;
; Returns:								;
;	Updated LRU chain						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	AX,BX,CX,DX,DI,SI,DS						;
; 									;
; Registers Destroyed:							;
;	none								;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:23:35p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glruadd,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si

	call	glruSetup
	jz	short glruadd1

	xor	dx,dx		    ; DX == 0 means insert at head
	call	LRUInsert
glruadd1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; glrudel								;
; 									;
; Removes a discardable object from the LRU chain.			;
; 									;
; Arguments:								;
;	ES:DI = arena header of object					;
;	DS:DI = address of global heap info				;
; 									;
; Returns:								;
;	Nothing.							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Mon Oct 27, 1986 04:36:49p  -by-  David N. Weise   [davidw]		;
; Rewrote it to eliminate the handle table as intermediary.		;
;-----------------------------------------------------------------------;

cProc	glrudel,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	dx
	push	si

	call	glruSetup
	jz	short glrudel1

	call	LRUDelete
glrudel1:
	pop	si
	pop	dx
	pop	bx
if KDEBUG
	call	check_lru_list
endif
	ret
cEnd nogen


if KDEBUG

;-----------------------------------------------------------------------;
; check_lru_list							;
; 									;
; Checks the glru list for consistency.					;
; 									;
; Arguments:								;
;	EDI	0							;
;									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
;									;
; History:								;
; 									;
;  Wed Feb 18, 1987 08:30:45p  -by-  David N. Weise   [davidw]		;
; Added support for EMS.						;
; 									;
;  Wed Oct 29, 1986 10:13:42a  -by-  David N. Weise   [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	check_lru_list,<PUBLIC,NEAR>
cBegin nogen
	push	ds
	SetKernelDS
	test	Kernel_flags,kf_check_free
	jz	cll_ret

	push	ax
	push	ebx
	push	cx
	push	edx
	push	esi
	mov	ds,pGlobalHeap
	UnSetKernelDS
do_it_again:
	mov	ebx,[di].gi_lruchain
	mov	cx,[di].gi_lrucount	; without ems gi_alt_count is 0
	or	cx,cx
	jz	all_done

	mov	esi,ebx
check_chain_loop:
	mov	edx,ds:[esi].pga_lruprev
	mov	esi,ds:[esi].pga_lrunext
	cmp	ds:[edx].pga_lrunext,ebx
	jz	short prev_okay
	kerror	0FFh,<lru: prev bad>,dx,bx
prev_okay:
	cmp	ds:[esi].pga_lruprev,ebx
	jz	short next_okay
	kerror	0FFh,<lru: next bad>,bx,si
next_okay:
	mov	ebx,esi
	loop	check_chain_loop
	cmp	[di].gi_lruchain,ebx
	jz	short all_done
	kerror	0FFh,<lru: count bad>,bx,[di].gi_lrucount
all_done:
	pop	esi
	pop	edx
	pop	cx
	pop	ebx
	pop	ax
cll_ret:
	pop	ds
	ret
cEnd nogen

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3protect.asm ===
PAGE    ,132
        TITLE   Windows Protect Mode Routines

.xlist
include kernel.inc

        .386p

include protect.inc
include pdb.inc
.list

ifdef WOW

;
; the dpmi func  04f1h is idential to function 00h, except that
; the descriptor base and limit are not initialized to zero.
;

;
; the dpmi func 04f2h  is identical to 0ch except that it
; sets 'count' (in cx) LDTs at one time. The first selector is in
; register bx. The descriptor data is in gdtdsc[bx], gdtdsc[bx+8]
; etc. This data is shared between dpmi (dosx.exe) and us and thus
; need not be passed in es:di

WOW_DPMIFUNC_00 equ 04f1h
WOW_DPMIFUNC_0C equ 04f2h


endif


MovsDsc Macro           ;Move (copy) a descriptor (4 words)
        cld
        movsd
        movsd
        endm

CheckDS Macro
        local   okds
if KDEBUG
        push    ax
        mov     ax, ds
        SetKernelDS
        cmp     ax, ArenaSel
        mov     ds, ax
        UnSetKernelDS
        je      short okds
        int 3
        int 3
okds:
        pop     ax
endif
        endm

CheckLDT Macro selector
if KDEBUG
        test    selector,SEL_LDT
        jnz     short @F
        int 3
@@:
endif
        Endm

DPMICALL        MACRO   callno
        mov     ax, callno
        call    DPMIProc
        ENDM


MY_SEL  equ 0F00h       ; Access word to indicate selector owned by kernel

externW pLocalHeap

DataBegin

ifdef WOW
externW SelectorFreeBlock
externW UserSelArray
externB fBooting
globalW high0c,0
globalD FlatAddressArray,0
endif


externW MyCSSeg
externW WinFlags
externW ArenaSel
externW pGlobalHeap

externW MyCSAlias

extrn   kr1dsc:WORD
extrn   kr2dsc:WORD
extrn   blotdsc:WORD
extrn   DemandLoadSel:WORD
extrn   FreeArenaList:DWORD
extrn   FreeArenaCount:DWORD
extrn   HighestArena:DWORD
extrn   temp_arena:DWORD
extrn   SelTableLen:word
extrn   SelTableStart:DWORD
extrn   temp_sel:WORD
extrn   FirstFreeSel:WORD
extrn   CountFreeSel:WORD

if ROM
externW selROMTOC
externW selROMLDT
externW sel1stAvail
endif

if ROM
externD lmaHiROM
externD cbHiROM
externD linHiROM
endif

DataEnd

DataBegin INIT

RModeCallStructure      STRUC
RMCS_EDI                dd      0
RMCS_ESI                dd      0
RMCS_EBP                dd      0
RMCS_Res                dd      0
RMCS_EBX                dd      0
RMCS_EDX                dd      0
RMCS_ECX                dd      0
RMCS_EAX                dd      0
RMCS_Flags              dw      0
RMCS_ES                 dw      0
RMCS_DS                 dw      0
RMCS_FS                 dw      0
RMCS_GS                 dw      0
RMCS_IP                 dw      0
RMCS_CS                 dw      0
RMCS_SP                 dw      0
RMCS_SS                 dw      0
RModeCallStructure      ENDS

MyCallStruc     RModeCallStructure <>

globalD lpProc,0

if ROM
externW gdtdsc
endif

public MS_DOS_Name_String
MS_DOS_Name_String      db      "MS-DOS", 0

DataEnd INIT

externFP IGlobalFree
externFP IGlobalAlloc
ifdef WOW
externFP kSYSERRORBOX
externFP VirtualAlloc
endif

sBegin  CODE
assumes cs,CODE
assumes ds,nothing


externNP genter
extrn GrowHeapDib: FAR
extrn LocalNotifyDib: FAR
extrn LocalNotifyDefault: FAR
extrn FreeHeapDib: FAR
externNP gleave
extrn IGlobalFix:FAR                    ;Far calls in this segment
extrn GlobalHandleNorip:FAR
extrn IGlobalFlags:FAR
extrn IGlobalHandle: FAR
extrn Free_Object2: FAR

extrn   mycsds:WORD

ife ROM
extrn   gdtdsc:WORD
endif

ifdef WOW
externD prevInt31proc
endif


sEnd    CODE

sBegin  INITCODE
assumes cs,CODE
assumes ds,nothing

;=======================================================================;
;                                                                       ;
; 386 PROTECTED MODE INITIALISATION ROUTINES                            ;
;                                                                       ;
;=======================================================================;

ife ROM

;   this function is not used in ROM since DOSX switches to Pmode before
;   jumping to kernel.  this means the enhanced mode loader will have
;   to do something similar...

;-----------------------------------------------------------------------;
; SwitchToPMODE                                                         ;
;                                                                       ;
; Entry:                                                                ;
;       In Real or Virtual Mode                                         ;
;       ES -> PSP                                                       ;
;                                                                       ;
; Returns:                                                              ;
;       In Protect Mode                                                 ;
;       BX -> LDT selector                                              ;
;       SI -> Segment of start of available memory                      ;
;       ES -> PSP                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       Exits via DOS call 4Ch                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,DATA
        assumes es,nothing


cProc   SwitchToPMODE,<PUBLIC,NEAR>
cBegin nogen

        push    cx
        push    es                      ; Current PSP

        mov     ax, 1687h
        int     2Fh                     ; Get PMODE switch entry
        or      ax, ax                  ; Can we do it?
        jnz     NoPMODE

        xor     bh, bh                  ; Set CPU type now
        cmp     cl, 3                   ; At least a 386?
        jb      NoPMODE

        mov     bl,WF_CPU386
        je      short @F                ; If 386
        mov     bl,WF_CPU486            ; No, assume 486 for now
@@:
        mov     WinFlags, bx            ; Save away CPU type
        mov     word ptr [lpProc][0], di
        mov     word ptr [lpProc][2], es
        pop     ax                      ; PSP
        add     ax, 10h                 ; Skip the PSP
        mov     es, ax                  ; Give this to the DOS extender
        add     si, ax                  ; Start of memory available to us

                                        ; THIS IS IT FOLKS!
        xor     ax, ax                  ; 16-bit app
        call    [lpProc]                ; Switch to PROTECTED mode
        jc      NoPMODE                 ; No, still Real/Virtual mode
        
        mov     ax, cs
        and     al, 7                   ; LDT, Ring 3
        cmp     al, 7
        jne     short BadDPMI           ; Insist on Ring 3!
                
        mov     bx, cs                  ; Allocate CS Alias
        DPMICALL 000Ah

        mov     MyCSAlias, ax           ; Save CS Alias in DS

        mov     bx, ds                  ; Use alias to update code seg var
        mov     ds, ax
        assumes ds, CODE

        mov     MyCSDS, bx              ; The DS selector

        mov     ds, bx
        ReSetKernelDS

        push    es
        push    si
        mov     ax, 168Ah               ; See if we have MS-DOS extensions
        mov     si, dataoffset MS_DOS_Name_String
        int     2Fh                     ; DS:SI -> MS-DOS string
        cmp     al, 8Ah                 ; Have extensions?
        je      short BadDPMI           ;  no extensions, screwed
                        
        mov     [lpProc][0], di         ; Save CallBack address
        mov     [lpProc][2], es
        
        mov     ax, 0100h               ; Get base of LDT
        call    [lpProc]
        jc      short NoLDTParty
        verw    ax                      ; Writeable?
        jnz     short NoLDTParty        ;  nope, don't bother with it yet

        mov     es, MyCSAlias
        assumes es,CODE
        mov     gdtdsc, ax
        assumes es,nothing

NoLDTParty:             
        pop     si
        pop     es
        
        push    si                      ; Unlock all of our memory
ifndef WOW  ; For WOW its all pageable
        movzx   ebx, si
        shl     ebx, 4                  ; Linear address of start of our memory
        movzx   esi, es:[PDB_block_len] ; End of our memory
        shl     esi, 4
        sub     esi, ebx                ; Size of our block
        mov     di, si
        shr     esi, 10h
        mov     cx, bx
        shr     ebx, 10h
        mov     ax, 0602h
        int     31h                     ; Mark region as pageable.
endif
        pop     bx
        mov     ax, 2                   ; Convert start of memory to selector
        int     31h
        mov     si, ax

        xor     bx, bx
        pop     cx
        ret

BadDPMI:
                ;
                ; Call real/virtual mode to whine
                ;
        xor     cx, cx                          ; Nothing on stack to copy
        xor     bh, bh                          ; Flags to DPMI
        mov     ax, MyCSSeg
        mov     MyCallStruc.RMCS_DS, ax         ; Real mode DS will be parent PDB
        mov     MyCallStruc.RMCS_ES, cx         ; Real mode ES will be 0
        mov     MyCallStruc.RMCS_CS, ax         ; Real mode CS
        mov     MyCallStruc.RMCS_IP, codeoffset RModeCode       ; Real mode IP

        smov    es, ds
        mov     di, dataOffset MyCallStruc      ; ES:DI points to call structure
        mov     ax, 0301h                       ; Call Real Mode Procedure
        int     31h
        jmps    GoodBye

RModeCode:
        mov     dx, codeoffset szInadequate
        mov     ah, 9
        int     21h
        retf

;Inadequate:
;       DB      'KRNL386: Inadequate DPMI Server',13,10,'$'
externB <szNoPMode, szInadequate>

NoPMODE:                                ; NOTE: stack trashed...
ifdef WOW
        ;** Put Up a Dialog Box If we fail to Enter Protect Mode
        ;** Prepare the dialog box
        push    cs                      ;In our DS
        push    codeOFFSET szNoPMode    ; -> unable to enter Prot Mode

        push    ds
externB <syserr>
        push    dataOffset syserr       ;Caption

        push    0                       ;No left button

        push    SEB_CLOSE + SEB_DEFBUTTON ;Button 1 style

        push    0                       ;No right button

        call    kSYSERRORBOX             ;Put up the system error message
externNP ExitKernel
        jmp     ExitKernel

else    ; Not WOW

        mov     dx, codeoffset szNoPMode
;       call    complain
;        DB      'KRNL386: Unable to enter Protected Mode',13,10,'$'
;complain:
;       pop     dx
        push    cs
        pop     ds                      ; DS:DX -> error message
        mov     ah,9                    ; Print error message
        int     21h

endif; WOW

GoodBye:
        mov     ax, 4CFFh
        int     21h
cEnd nogen

endif

;-----------------------------------------------------------------------;
; LDT_Init                                                              ;
;                                                                       ;
; Entry:                                                                ;
;       DS -> CS                                                        ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;


cProc   LDT_Init,<PUBLIC,NEAR>,<ax,bx,cx,di,es>
cBegin  
        ReSetKernelDS

        cmp     gdtdsc, 0
        jz      short SlowAllocation
;
; Scan LDT for free selectors and
; put on a linked list
;
        mov     es, gdtdsc
        mov     cx, 1
        DPMICALL 0000h                          ; Get selector from win386
        and     al, NOT SEG_RING_MASK
        mov     FirstFreeSel, ax                ; Set up header
        mov     si, ax
        mov     word ptr es:[si], -1
        mov     word ptr es:[si].dsc_access, MY_SEL     ; MINE!
        
        mov     cx, es
        lsl     ecx, ecx                        ; limit of LDT
        xor     eax, eax

steal_sels:
        mov     di, si                          ; prev selector in list
not_this_one:
        add     si, DSC_LEN                     ; use add for flags
        jz      short end_ldt
        cmp     si, cx
        ja      short end_ldt

        cmp     dword ptr es:[si], eax
        jne     not_this_one
        cmp     dword ptr es:[si][4], eax
        jne     not_this_one

        mov     word ptr es:[di], si    ; Link into list
        mov     word ptr es:[si].dsc_access, MY_SEL     ; MINE!
        inc     CountFreeSel
        jmps    steal_sels

end_ldt:
        mov     word ptr es:[di], -1
SlowAllocation:

        push    es                      ; Get random selectors
        smov    es, ds
        ReSetKernelDS es
        UnSetKernelDS
                                ; Could get 3 selectors at once here,
                                ; but get_sel is more efficient for just 1
        mov     cx, 1           ; Argument to get_sel
        call    get_sel
        or      si, SEG_RING
        mov     kr1dsc, si
        call    get_sel
        mov     kr2dsc, si
        call    get_sel
        mov     blotdsc, si
        call    get_sel
        or      si, SEG_RING
        mov     DemandLoadSel, si       ; for demand loading segments
    smov    ds, es
        pop     es
        UnSetKernelDS es
cEnd

sEnd    INITCODE

sBegin  CODE
assumes cs,CODE
assumes ds,nothing


;=======================================================================;
;                                                                       ;
; SELECTOR ALLOCATION/DEALLOCATION ROUTINES                             ;
;                                                                       ;
;=======================================================================;


;-----------------------------------------------------------------------;
; AllocSelector
;
;
; Entry:
;
; Returns:
;       AX = 0 if out of selectors
;
; Registers Destroyed:
;
; History:
;  Thu 08-Dec-1988 14:17:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifdef WOW
labelFP <PUBLIC,AllocSelectorWOW>
       mov ax, 1
       jmps AllocSelectorWorker

labelFP <PUBLIC,AllocSelector>
       xor ax, ax
       ; fall through

cProc   AllocSelectorWorker,<PUBLIC,FAR>,<di,si,es>
        parmW   selector
        localV  OldDsc,DSC_LEN
        localW  fDontSetDescriptor
cBegin
        mov     fDontSetDescriptor, ax
else
cProc   AllocSelector,<PUBLIC,FAR>,<di,si,es>
        parmW   selector
        localV  OldDsc,DSC_LEN
cBegin

endif

        mov     cx, 1
        lsl     ecx, dword ptr selector
        jz      short as_present

        call    get_sel                 ; He passed in some junk, give him
ifdef WOW                   ; just one selector...
    ; If we have a good selector, use DPMI to write it through to the
    ; system LDT before giving it to an application to use.
    jz   short as_exit1
    mov  ax, [bp+4]         ; Get caller CS.
    cmp  ax, IGROUP         ; Don't write thru if it's KRNL386 calling.
    je   short as_exit
    cmp  ax, _NRESTEXT
    je   short as_exit
    cmp  ax, _MISCTEXT
    je   short as_exit

    ;Set shadow LDT entry to known state.
    push bx
    push ds
    mov  ds, gdtdsc          ; Get shadow LDT in DS
    UnSetKernelDS
    mov  bx, si

    mov  [bx].dsc_limit, 00h   ; Set entry to: BASE = 0, LIMIT = 0, BYTES,
    mov  [bx].dsc_lbase, 00h   ;  DPL = 3, PRESENT, DATA
    mov  [bx].dsc_mbase, 00h
    mov  [bx].dsc_hbase, 00h
    mov  ax, DSC_DATA+DSC_PRESENT
    mov  word ptr [bx].dsc_access, ax
    pop  ds

    DPMICALL  WOW_DPMIFUNC_0C ; Write shadow LDT entry thru to system LDT.
    pop  bx
    jmps as_exit
else
    jnz short as_exit       ; just one selector...
        jmps    as_exit1
endif

as_present:
        Limit_To_Selectors      ecx

        call    get_sel
        jz      short as_exit1
ifdef WOW
        test     fDontSetDescriptor, 1
        jnz      as_exit
endif
        smov    es, ss
        lea     di, OldDsc              ; ES:DI points to descriptor
        mov     bx, selector            ; BX gets old selector

        push    ds
if ROM
        SetKernelDS
endif
        mov     ds, gdtdsc
if ROM
        assumes ds,nothing
endif
        push    si                      ; Get Descriptor
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
        mov     bx, si                  ; BX gets new selector
        or      bl, SEG_RING

        call    fill_in_selector_array  ; and set new array to match

as_exit:
        or      si, SEG_RING
as_exit1:
        mov     ax,si
cEnd

;-----------------------------------------------------------------------;
; AllocResSelArray - Allocate a resource Selector array (see resaux)    ;
;                   Combination of AllocSelectorArray + SetResourceOwner;
; Entry:                                                                ;
;       nSels = # selectors required                                    ;
;       parmW   owner                                                   ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
; get_sel - get an array of selectors                                   ;
;                                                                       ;
; Entry:                                                                ;
;       CX = # selectors required                                       ;
;                                                                       ;
; Returns:                                                              ;
;       SI = First Selector                                             ;
;       DS = LDT                                                        ;
;       ZF = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       SI = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,ES                                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;   mattfe March 30th 1993 - WOW Specific Routine, by combining the two ;
;   routines I can reduce the number of DPMI calls by 40/1 for loading  ;
;   a typical app.                                                      ;
;-----------------------------------------------------------------------;
ifdef WOW

        assumes ds, nothing
        assumes es, nothing

cProc   AllocResSelArray,<PUBLIC,NEAR>,<cx,si,di,es,ds>
        parmW   nSels
        parmW   owner
cBegin
        mov     cx, nSels
        call    get_sel
        mov     ax, si
        jz      short ARSA_fail

        or      si, SEG_RING
        mov     bx, si

        mov     dx, cx

        push    ds
        mov     ds, gdtdsc
        push    bx
        and     bl, not 7

;; For the first selector mark it with the resource owner

        mov     cx, owner
        mov     ds:[bx].dsc_owner, cx
        mov     word ptr ds:[bx].dsc_access, (DSC_DISCARDABLE SHL 8) + DSC_DATA
        mov     cx,nSels
        mov     ds:[bx].dsc_hbase, cl      ; Save number of selectors here

        mov     cx, DSC_DATA+DSC_PRESENT

        lea     bx, [bx+DSC_LEN]
        dec     dx
        jz      ASRA_CallNT

ARSA_fill_in_access:
        mov     word ptr ds:[bx].dsc_access, cx
        lea     bx, [bx+DSC_LEN]
        dec     dx
        jnz     ARSA_fill_in_access

ASRA_CallNT:
        mov     bx,si                       ; First Selector
        mov     cx,nSels                    ; Count
        DPMICALL  WOW_DPMIFUNC_0C

        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector32,<si,0,owner> ; And save in selector table
        pop     ax                          ; Return first sel
        pop     ds

ARSA_fail:
cEnd
endif ; WOW


;-----------------------------------------------------------------------;
; AllocSelectorArray - external entry for get_sel                       ;
; Entry:                                                                ;
;       nSels = # selectors required                                    ;
;                                                                       ;
; get_sel - get an array of selectors                                   ;
;                                                                       ;
; Entry:                                                                ;
;       CX = # selectors required                                       ;
;                                                                       ;
; Returns:                                                              ;
;       SI = First Selector                                             ;
;       DS = LDT                                                        ;
;       ZF = 0                                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       SI = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,ES                                                   ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   AllocSelectorArray,<PUBLIC,FAR>,<si>
        parmW   nSels
cBegin
        mov     cx, nSels
        call    get_sel
        mov     ax, si
        jz      short asa_fail

        or      si, SEG_RING
        mov     bx, si
        mov     dx, cx
        mov     cx, DSC_DATA+DSC_PRESENT
ifdef WOW                               ; LATER should use single op to update
fill_in_access:                         ; complete LDT with one call.
        DPMICALL 0009h
        lea     bx, [bx+DSC_LEN]
        dec     dx
        jnz     fill_in_access
else
        push    ds
        mov     ds, gdtdsc
        push    bx
        and     bl, not 7
fill_in_access:
        mov     word ptr ds:[bx].dsc_access, cx
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        lea     bx, [bx+DSC_LEN]
        dec     dx
        jnz     fill_in_access
        pop     bx
        pop     ds
endif; WOW
        mov     ax, si


asa_fail:
cEnd

if KDEBUG
cProc   check_free_sel_list,<PUBLIC,NEAR>
cBegin
    pushf
    pusha
    push  ds

    call SetKernelDSProc     ; Must call direct in this file
    ReSetKernelDS

    mov  cx, CountFreeSel
    cmp  cx, 2               ; Only check list with more than 1 entry.
    jb   cfl_ok
    inc  cx                  ; Count dummy entry.
    mov  si, FirstFreeSel    ; Pointer to head of list
    mov  ds, gdtdsc          ; Get shadow LDT in DS
    UnSetKernelDS

cfl_loop:
    mov  ax, word ptr [si]   ; Get next.
    cmp  ax, 0FFFFH          ; -1 is sentinal
    je   short cfl_trashed
    mov  di, si              ; Save prev. for debugging.
    mov  si, ax
    loop cfl_loop
    mov  ax, word ptr [si]   ; Get sentinal.

cfl_done:
    cmp  ax, 0FFFFH          ; -1 is sentinal
    je   short cfl_ok        ; Must have sentinal and
cfl_trashed:
    kerror  0, <Free sel list is trashed>

cfl_ok:
    pop  ds
    popa
    popf
cEnd
endif

cProc   get_sel,<PUBLIC,NEAR>
        localW  MySel
cBegin
        pusha
gs_retry_get_sel:
        call    SetKernelDSProc         ; Must call direct in this file
        ReSetKernelDS

        mov     si, FirstFreeSel        ; Pointer to head of list
        mov     ds, gdtdsc
        UnSetKernelDS
        mov     dx, cx                  ; Sels wanted

        mov     ax, word ptr [si]
        inc     ax                      ; -1 teminated
        jz      short gs_searchfailed

if KDEBUG
    call check_free_sel_list
endif

        cmp     cx, 1                   ; One selector only?
        jne     short gs_selblock

        dec     ax
        mov     di, ax
        mov     word ptr [di].dsc_access, DSC_USED      ; Mark it used
        mov     di, word ptr [di]       ; Unlink it
        mov     word ptr [si], di
        mov     si, ax
        jmp     got_my_sel

gs_selblock:                            ; Following stolen from DOSX
        mov     bx, si                  ; Start of list of free sels
        lea     si, [si+DSC_LEN]        ; Start search here!
        mov     di, ds
        lsl     di, di                  ; limit of LDT
        and     di, NOT 7
gs_jail:
        mov     ax, si                  ; Starting selector
        mov     cx, dx                  ; number to check
gs_sb0:
        cmp     word ptr ds:[si].dsc_access, MY_SEL     ; This one free?
        jnz     short gs_sb1            ;   nope, keep looking

        lea     si, [si+DSC_LEN]
        cmp     si, di                  ; Falling off the end?
        jae     short gs_searchfailed
        loop    gs_sb0                  ; All we wanted?
        jmps    gs_gotblock

gs_sb1:
        lea     si, [si+DSC_LEN]        ; Restart scan after this selector
        cmp     si, di
        jb      short gs_jail
        jmps    gs_searchfailed
                                        ; Got our block, now blast them out
gs_gotblock:                            ; of the free list
        mov     cx, dx                  ; # selectors
        push    cx
        shl     dx, 3                   ; Length of our array of selectors
        add     dx, ax                  ; First selector after our array
        mov     si, [bx]                ; Next selector in free list
gs_blast:
        inc     si
        jz      short gs_blasted        ; Gone thru whole list
        dec     si
        cmp     si, ax                  ; See if in range
        jb      short gs_noblast
        cmp     si, dx
        jb      short gs_unlink
gs_noblast:
        mov     bx, si
        mov     si, [si]                ; Follow the link
        jmps    gs_blast

gs_unlink:                              ; This one is in range
        mov     si, [si]                ; Unlink it
        mov     [bx], si
        loop    gs_blast                ; Stop search when unlinked them all

gs_blasted:
        pop     cx
        mov     si, ax
        lea     si, [si].dsc_access     ; Now mark them used
gs_markused:
        mov     byte ptr [si], DSC_USED
        lea     si, [si+DSC_LEN]
        cmp     si, dx
        jb      short gs_markused

        mov     si, ax
        jmps    got_my_sel
        
gs_searchfailed:                        ; Failed from our list, try WIN386
        mov     cx, dx

;;;%out Take me out later
;;;     mov     ds, gdtdsc
;;;     UnSetKernelDS

gs_slow:
ifdef WOW
;; Calling DPMI to do anything is very slow, so lets grab at minimum 256
;; selectors at a time, that way we don't have to call again for a while

        call    SetKernelDSProc         ; Must call direct in this file
        ReSetKernelDS

        push    cx
        test    fbooting,1              ; Don't do optimization during boot
                                        ; since free_Sel will return them to
                                        ; DPMI.
        jnz     gs_0100

        add     cx,256                  ; get more than we need

        DPMICALL 0000h
        jc      gs_0100                 ; Failed, then just grab the required
        mov     bx, ax                  ;  number.
gs_free_loop:
        cCall   free_sel,<bx>           ; Got the selectors, put them on
        lea     bx, [bx+DSC_LEN]        ;   our free list the easy way...
        loop    gs_free_loop
        pop     cx
        jmp     gs_retry_get_sel

gs_0100:
        pop     cx
endif; WOW
        DPMICALL 0000h                    ; Call DPMI to get one
        and     al, NOT SEG_RING_MASK
        mov     si, ax

        or      si, si                  ; Did we get it?
        jnz     short got_dpmi_sel
if KDEBUG
        push    es
        pusha
        kerror  0,<Out of selectors>
        popa
        pop     es
        jmp     gs_exit
else
        jmps    gs_exit
endif

; Try to avoid running out of selectors under Enhanced mode by keeping
; 256 selectors free.  This will hopefully allow win386 to grow the
; LDT while there is still memory to do so.

got_my_sel:
        SetKernelDS
        sub     CountFreeSel, cx
ifndef WOW
;; See above WOW code which grabs chunks of 256 selectors from DOSX
;; we don't need to do this.
        test    byte ptr WinFlags, WF_ENHANCED  ; Standard mode can't grow the
        jz      got_either_sel                  ;   LDT so don't bother
        cmp     CountFreeSel, 256
        jae     got_either_sel
        lsl     bx, gdtdsc              ; LDT already full size?
        cmp     bx, 0F000h
        ja      got_either_sel
        push    ax
        push    cx
        mov     cx, 256
        DPMICALL 0000h
        jc      gs_after_free
        mov     bx, ax
gs_free_it:
        cCall   free_sel,<bx>           ; Got the selectors, put them on
        lea     bx, [bx+DSC_LEN]        ;   our free list the easy way...
        loop    gs_free_it
gs_after_free:
        pop     cx
        pop     ax
endif; NOT WOW
        jmps    got_either_sel

got_dpmi_sel:
        SetKernelDS

got_either_sel:
        cmp     SelTableLen, 0
        je      short gs_exit           ; Not set yet
        push    eax
        .ERRNZ  DSC_LEN-8
        lea     eax, [esi+ecx*DSC_LEN][-DSC_LEN] ; AX has last selector
        shr     ax, 1                   ; ignore high word...
        cmp     ax, SelTableLen
        pop     eax
        jb      short gs_exit           ; Can associate this selector

if KDEBUG
        int 3
endif
        mov     bx, si
        xor     si, si
        or      bl, SEG_RING
as_free:
        DPMICALL 0001h                  ; Free selector
                                        ; Give to WIN386 since we can't use it
        lea     bx, [bx+DSC_LEN]
        loop    as_free

gs_exit:
        mov     ds, gdtdsc
        UnSetKernelDS

        mov     MySel, si
        popa
        mov     si, MySel
        or      si, si                  ; Set ZF for caller
cEnd


;-----------------------------------------------------------------------;
; alloc_disc_data_sel
; alloc_data_sel
; alloc_data_sel32
; alloc_disc_CS_sel
; alloc_CS_sel
; alloc_NP_data_sel
; alloc_NP_CS_sel
;
;       Set appropriate access rights flags then use
;       alloc_sel to get a selector.
;
; Entry:
;       Base address and Limit OR Owner
;
; Returns:
;       Selector in AX
;
; Registers Destroyed:
;       AX
;
; History:
;  Fri 15-Jul-1988 21:05:19  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

if ROM
;
;   there is a bunch of selector allocating in the ROM initialization
;   so have a couple functions for 16 bit limits...
;

cProc   far_alloc_data_sel16, <PUBLIC,FAR>

    parmD   base
    parmW   limit

cBegin

    movzx   eax, limit
    shl     eax, 4
    mov     edx, base
    cCall   alloc_data_sel, <edx, eax>

cEnd

cProc   alloc_data_sel16, <PUBLIC, NEAR>

    parmD   base
    parmW   limit

cBegin
    movzx   eax, limit
    shl     eax, 4                  ;; this is is paragraphs...
    mov     edx, base
    cCall   alloc_data_sel, <edx, eax>
cEnd

endif


public  alloc_data_sel32
alloc_data_sel32        label   near
cProc   alloc_data_sel,<PUBLIC,NEAR>
;       parmD   Address
;       parmD   Limit
cBegin nogen
        mov     ax,DSC_PRESENT+DSC_DATA
        jmps    alloc_sel
cEnd nogen


;-----------------------------------------------------------------------;
; alloc_sel                                                             ;
;                                                                       ;
; Entry:                                                                ;
;       AL = flags                                                      ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,CX,DX,DI,SI,DS,ES                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu 07-Apr-1988 21:33:27    -by-  David N. Weise   [davidw]          ;
; Added the GlobalNotify check.                                         ;
;                                                                       ;
;  Sun Feb 01, 1987 07:48:39p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   alloc_sel,<PUBLIC,NEAR>,<bx,dx,si,di,ds,es>
        parmD   Address
        parmD   Limit
        localV  DscBuf,DSC_LEN
cBegin
        push    ecx
        mov     cx, 1
        test    al, DSC_PRESENT
        jz      short as_oneonly

        mov     ecx, Limit              ; Calculate how many selectors required
        cmp     ecx, 100000h            ; More than 1Mb?
        jb      short as_byte

        add     ecx, 0FFFh              ; Round to 4K pages
        and     cx, not 0FFFh
        mov     Limit, ecx
        shr     Limit, 12               ; # 4K pages
        or      ah, DSC_GRANULARITY     ; 4K granularity!
as_byte:
        dec     Limit                   ; Came in as length, now limit
        add     ecx, 0FFFFh
        shr     ecx, 16                 ; # selectors in array

as_oneonly:
        call    get_sel
        jz      short a_s_exit          ; No selectors left


        mov     bx, si                  ; Selector in bx for DPMI
        or      bl, SEL_LDT
        lea     di, DscBuf
        smov    es, ss                  ; es:di points to descriptor buffer
        test    al, DSC_PRESENT
        jnz     short set_everything

        push    ax

if ROM
        SetKernelDS
        mov     ds, gdtdsc
        assumes ds,nothing
else
        mov     ds, gdtdsc
endif
        and     bl, not 7
        pop     word ptr [bx].dsc_access
        mov     ax, word ptr Limit
        mov     [bx].dsc_limit, ax
        mov     [bx].dsc_hbase, cl    ; Number of selectors here
ifdef WOW
        smov    es, ds                  ; es:di -> descriptor
        mov     di, bx
        or      bl, SEG_RING            ; bx selector #
        DPMICALL 000Ch                  ; Set descriptor
endif; WOW
        jmps    as_done

set_everything:
        and     ah, not 0Fh             ; Zero limit 19:16
        or      ah, byte ptr Limit+2    ; Fill in limit 19:16
        mov     word ptr DscBuf.dsc_access, ax
        mov     ax, Limit.lo
        mov     DscBuf.dsc_limit, ax
        mov     ax, Address.lo
        mov     DscBuf.dsc_lbase, ax
        mov     ax, Address.hi
        mov     DscBuf.dsc_mbase, al
        mov     DscBuf.dsc_hbase, ah

        call    fill_in_selector_array

as_done:
        or      si, SEG_RING
a_s_exit:
        mov     ax, si
        pop     ecx
cEnd


;-----------------------------------------------------------------------;
; free_sel                                                              ;
; FreeSelector                                                          ;
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc IFreeSelector,<FAR,PUBLIC>
        parmW   selector
cBegin
        xor     ax, ax
        mov     es, ax
        cCall   FreeSelArray,<selector>
cEnd

        assumes ds, nothing
        assumes es, nothing

ifdef WOW
; save cx too.

cProc   free_sel,<PUBLIC,NEAR>,<ax,bx,si,ds,cx>
else
cProc   free_sel,<PUBLIC,NEAR>,<ax,bx,si,ds>
endif
        parmW   selector
cBegin
        pushf                           ; !!! for the nonce
        mov     bx,selector             ;  must be careful in gcompact
                                        ;  to ignore error return
        call    SetKernelDSProc         ; Must call direct in this file
        ReSetKernelDS

if ROM
        ; don't free ROM selectors...
        cmp     bx, sel1stAvail
        jb      sel_freed
endif

        cmp     gdtdsc, 0
        je      short give_to_win386

        sel_check bx
        mov     si, bx
        shr     si, 1
        cmp     si, SelTableLen
if 0
        mov     si, SelTableLen
        shl     si, 1
        cmp     bx, si
endif
        jae     short give_to_win386

        mov     si, FirstFreeSel
        inc     CountFreeSel
        mov     ds, gdtdsc
        UnSetKernelDS
ifdef WOW
        mov     cx, word ptr [bx+4]
endif

                                        ; Link into list
        mov     ax, [si]                ; ax := head.next
        mov     [si], bx                ; head.next := new
        mov     [bx], ax                ; new.next := ax
        mov     word ptr [bx][2], 0
        mov     dword ptr [bx][4], MY_SEL SHL 8 ; Make it free

ifdef WOW
        cmp     cx, MY_SEL
        jz      sel_freed
        or      bl, SEG_RING            ; Ensure Table bit correct
        mov     cx, 1
        DPMICALL  WOW_DPMIFUNC_0C
endif
        jmps    sel_freed       


give_to_win386:
        or      bl, SEG_RING            ; Ensure Table bit correct
        DPMICALL 0001H
sel_freed:
        popf
cEnd


;-----------------------------------------------------------------------;
; FreeSelArray                              ;
;                                   ;
; Entry:                                ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;   AX,BX,CX,DX,DI,SI,DS,ES                     ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   FreeSelArray,<PUBLIC,NEAR>,<ax,bx>

    parmW   selector
cBegin
    push    ecx

    mov cx, 1           ; In case lar, lsl fail, one sel to free
    mov bx, selector
    Handle_To_Sel       bl

ifdef WOW
  if KDEBUG
    push ds
    SetKernelDS
    cmp  DemandLoadSel, 0   ; Skip the test if we're freeing DemandLoadSel
    UnSetKernelDS
    pop  ds
    je   short fsa_no_test
    push bx
    push ds
    mov  ds, gdtdsc
    and  bl, not 7
    mov  ch, [bx].dsc_access
    pop  ds
    pop  bx

    lar  ax, bx
    and  ah, 0feh               ;ignore access bit
    and  ch, 0feh               ;ignore access bit
    cmp  ah, ch
    je   short LDTs_match

    kerror  0, <System LDT does not match Shadow LDT>
LDTs_match:
    xor ch, ch
fsa_no_test:
  endif
endif

    lar ax, bx
    jnz short just_free_it  ; I'm completely confused...

    test    ah, DSC_CODEDATA    ; Code or data?
    jz  short just_free_it  ;  No, assume only one selector

    test    ah, DSC_PRESENT     ; Present?
    jnz short use_limit     ;  yes, calculate # sels from limit

ifdef WOW
; MarkSelNotPresent Saves Number of selectors in the dsc_hbase entry to get
; it back directly from our copy of the LDT.

    push    bx
    push    ds

    mov ds, gdtdsc
    and bl, not 7
    xor cx,cx
    mov cl,[bx].dsc_hbase   ; Get Saved # selectors

    pop ds
    pop bx
else
    push    dx          ; DPMI call 6 returns CX:DX
    DPMICALL 0006h          ; Get physical address
    shr cx, 8           ; number of selectors
    pop dx
endif; WOW
    jmps    just_free_it

use_limit:
    lsl ecx, ebx
    jnz short just_free_it  ; Not present
    Limit_To_Selectors  ecx

just_free_it:
if KDEBUG
    cmp cl,ch
    jnz short skip_zero_inc
    kerror  0, <Looping on cx=0 in FreeSelArray>
    inc cl
skip_zero_inc:
endif
just_free_it2:
    cCall   free_sel,<bx>       ; (preserves cx)
    lea bx, [bx+DSC_LEN]
    loop    just_free_it2       ; Any left to free

    pop ecx
cEnd


;-----------------------------------------------------------------------;
; GrowSelArray                                                          ;
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS,ES                                         ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GrowSelArray,<PUBLIC,NEAR>,<bx,di>
        localV  DscBuf,DSC_LEN
cBegin
        push    ecx
        mov     di, ds:[esi].pga_handle
        mov     bx, di
        Handle_To_Sel           di
        lsl     eax, edi
        Limit_To_Selectors      eax
if KDEBUG
        cmp     al, ds:[esi].pga_selcount
        je      short gsa_count_ok
        int 3
        int 3
gsa_count_ok:
endif
        mov     ecx, edx                ; New size
        add     ecx, 0FFFFh
        shr     ecx, 16                 ; new # selectors
        cmp     ax, cx                  ; Same # of selectors required?
        je      short gsa_done          ;  yes, just return!

        push    si
        push    es
        push    ds
        push    di                      ; Argument to FreeSelArray

        cmp     cx, 255                 ; Max array is 255.
        jae     short gsa_nosels
        
        call    get_sel                 ; get a new selector array
        jz      short gsa_nosels
        
        push    bx
        mov     bx, di                  ; DI had original selector

        push    ds
if ROM
        SetKernelDS
        mov     es,gdtdsc
        mov     ds,gdtdsc
        assumes ds,nothing
else
        mov     ds,gdtdsc
        mov     es,gdtdsc
endif
        push    si
        mov     di,si
        and     di, not 7
        mov     si,bx
        and     si, not 7
        MovsDsc
        pop     si
        pop     ds
ifdef WOW
        push    cx
        push    bx
        mov     cx, 1
        mov     bx, si
        or      bx, SEG_RING_MASK
        DPMICALL WOW_DPMIFUNC_0C
        pop     bx
        pop     cx
endif

        mov     di, si                  ; New selector in DI
        pop     bx
        pop     si
        pop     ds
        cCall   AssociateSelector32,<si,0,0>
        pop     es
        pop     si
        mov     ax, bx
        and     ax, SEG_RING_MASK       ; Ring bits
        or      ax, di                  ; New handle
        mov     ds:[esi].pga_handle, ax
        mov     ds:[esi].pga_selcount, cl
        cCall   AssociateSelector32,<ax,esi>
        jmps    gsa_done

gsa_nosels:
        pop     di
        pop     ds
        pop     es
        pop     si
        xor     ax, ax                  ; Indicate failure
        jmps    gsa_ret

gsa_done:
        mov     ax, ds:[esi].pga_handle
        or      ax, ax                  ; Success
gsa_ret:
        pop     ecx
cEnd


;=======================================================================;
;                                                                       ;
; SELECTOR ALIAS ROUTINES                                               ;
;                                                                       ;
;=======================================================================;


;-----------------------------------------------------------------------;
; PrestoChangoSel
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 08-Dec-1988 14:17:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IPrestoChangoSelector,<PUBLIC,FAR>,<di,si>
        parmW   sourcesel
        parmW   destsel
        localV  DscBuf,DSC_LEN
cBegin
ifdef WOW
        smov    es, ss
        lea     di, DscBuf
        mov     bx, sourcesel
        DPMICALL 000Bh                          ; LATER change this to a single
        xor     DscBuf.dsc_access, DSC_CODE_BIT ; DPMI call, read from gdtdsc
        mov     bx, destsel
        DPMICALL 000Ch
        mov     ax, bx
else
        push    bx

        push    ds
if ROM
        SetKernelDS
        mov     es, gdtdsc
        mov     ds, gdtdsc
        assumes ds, nothing
else
        mov     ds, gdtdsc
        mov     es, gdtdsc
endif
        mov     si, sourcesel
        and     si, not 7
        mov     di, destsel
        and     di, not 7
        MovsDsc
        lea     bx,[di-DSC_LEN]
        xor     ds:[bx].dsc_access,DSC_CODE_BIT ; Toggle CODE/DATA
        pop     ds
        or      bl, SEG_RING
        mov     ax, bx
        pop     bx
endif; WOW
        smov    es,0
cEnd



;-----------------------------------------------------------------------;
; AllocAlias                                                            ;
; AllocCStoDSAlias                                                      ;
; AllocDStoCSAlias                                                      ;
;       All these routines return an alias selector for the             ;
;       given selector.                                                 ;
;                                                                       ;
; Entry:                                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX is alias selector                                            ;
;       DX is original selector (compatibility thing)                   ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,CX,DI,SI,DS                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ES destroyed                                                    ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

labelFP <PUBLIC,IAllocDStoCSAlias>
        ;** AllocDStoCSAlias has an interesting hack.  A fix was made to
        ;** not allow apps to GlobalAlloc fixed memory.  This was done
        ;** for performance reasons.  The only reason we can ascertain
        ;** for an app needing fixed GlobalAlloc'ed memory is in the case
        ;** of alias selectors.  We assume that all apps needing alias
        ;** selectors will use this function to make the alias.  So, if
        ;** we see a DStoCS alias being made, we make sure the DS is fixed.
        push    bp
        mov     bp, sp                  ;Create the stack frame
        push    WORD PTR [bp + 6]       ;Get handle/selector
IF KDEBUG
        call    GlobalHandleNorip       ;Make sure it's really a handle
ELSE
        call    IGlobalHandle           ;Make sure it's really a handle
ENDIF
        test    ax, 1                   ;Fixed blocks have low bit set
        jnz     SHORT ADCA_Already_Fixed ;It's already a fixed block!

        ;** If the block is not fixed, it may be locked so we must check this.
        push    ax                      ;Save returned selector
        push    ax                      ;Use as parameter
        call    IGlobalFlags            ;Returns lock count if any
        or      al, al                  ;Non-zero lock count?
        pop     ax                      ;Get selector back
        jnz     SHORT ADCA_Already_Fixed ;Yes, don't mess with it

        ;** Fix the memory.  Note that we're only doing this for the
        ;**     apps that are calling this on non-fixed or -locked memory.
        ;**     This will cause them to rip on the GlobalFree call to this
        ;**     memory, but at least it won't move on them!
        push    ax                      ;Fix it
        call    IGlobalFix
ADCA_Already_Fixed:
        pop     bp              ;Clear our stack frame

        ;** Flag which type of alias to make and jump to common routine
        mov     dl, 1
        jmps    aka

labelFP <PUBLIC,IAllocCStoDSAlias>
        xor     dl, dl

cProc   aka,<FAR,PUBLIC>, <bx,cx,si,di,ds>
        parmW   sourceSel
        localV  DscBuf,DSC_LEN
        localB  flag            ; 0 for data, !0 for code
cBegin
        mov     flag, dl

        mov     cx, 1
        call    get_sel
        mov     ax, si                  ; in case it failed
        jz      short aka_nope
        or      si, SEG_RING

ifdef WOW                               ; LATER Single DPMI call
        push    si                      ; save Target Selector
        smov    es,ss
        lea     di,DscBuf
        mov     bx,sourceSel
        DPMICALL 000Bh                  ; Read the Selector into DscBuf
        and     es:[di].dsc_access,NOT DSC_CODE_BIT    ; Toggle CODE/DATA
        cmp     flag, 0
        jz      @F
        or      es:[di].dsc_access,DSC_CODE_BIT
@@:
        pop     bx                      ; restore Target Selector
        DPMICALL 0000Ch
else
if ROM
        SetKernelDS
        mov     es, gdtdsc
        mov     ds, gdtdsc
        assumes ds, nothing
else
        mov     ds, gdtdsc
        mov     es, gdtdsc
endif
        mov     bx, si
        mov     di, si
        and     di, not 7
        mov     si, sourceSel
        and     si, not 7
        MovsDsc
        and     es:[di][-DSC_LEN].dsc_access,NOT DSC_CODE_BIT    ; Toggle CODE/DATA
        cmp     flag, 0
        jz      @F
        or      es:[di][-DSC_LEN].dsc_access,DSC_CODE_BIT
@@:
endif; WOW
        mov     ax, bx
        smov    es,0
aka_nope:
        mov     dx,sourceSel
cEnd


cProc   AllocAlias,<FAR,PUBLIC>, <bx,cx,si,di,ds>
        parmW   selector
cBegin
ifdef WOW
        push    bx      ; Whitewater tool ObjDraw needs this too
endif
        mov     cx, 1
        call    get_sel
        jz      short aca_nope
        or      si, SEG_RING
        cCall   IPrestoChangoSelector,<selector,si>
aca_nope:
        ; WhiteWater Resource Toolkit (shipped with Borland's Turbo
        ; Pascal) depends on dx being the data selector which was true
        ; in 3.0 but in 3.1 validation layer destroys it.
        mov     dx,selector
ifdef WOW
        pop     bx
endif
cEnd

;=======================================================================;
;                                                                       ;
; SELECTOR MANPULATION ROUTINES                                         ;
;                                                                       ;
;=======================================================================;


;-----------------------------------------------------------------------;
; fill_in_selector_array                                                ;
;                                                                       ;
; Entry:                                                                ;
;       AX      = Limit for object                                      ;
;       DH      = Discard bit for descriptors                           ;
;       DL      = Access bits                                           ;
;       BX:DI   = 32 bit base address of object                         ;
;       SI      = index into LDT                                        ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       SI, DI, DS, ES                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,BX,CX,DX                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   fill_in_selector_array,<PUBLIC,NEAR>
cBegin  nogen

        push    ds
        mov     ds, gdtdsc
        push    bx
        push    cx

        mov     dh, es:[di].dsc_hlimit          ; For granularity
next_sel:

;;        DPMICALL 000Ch                          ; Set this descriptor

        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
        pop     bx

        lea     bx, [bx+DSC_LEN]                ; On to next selector
        add     es:[di].dsc_mbase, 1            ; Add 64kb to address
        adc     es:[di].dsc_hbase, 0

        test    dh, DSC_GRANULARITY             ; Page granular?
        jz      short byte_granular

        sub     es:[di].dsc_limit, 16           ; 64K is 16 4K pages
        sbb     es:[di].dsc_hlimit, 0           ; Carry into hlimit
        loop    next_sel

        jmps    fisa_ret

byte_granular:
        dec     es:[di].dsc_hlimit              ; subtract 64kb from limit
        loop    next_sel

fisa_ret:
        pop     cx
        pop     bx
        DPMICALL WOW_DPMIFUNC_0C
        pop     ds

        ret

cEnd    nogen


;-----------------------------------------------------------------------;
; GetSelectorBase
; get_physical_address
;
;
; Entry:
;
; Returns:
;       DX:AX   32 bit physical address
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetSelectorBase,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall   get_physical_address, <selector>
cEnd

cProc   get_physical_address,<PUBLIC,NEAR>
        parmW   selector
cBegin
        push    bx
        push    cx
        mov     bx, selector

        push    ds                      ; Get Segment Base Address
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        assumes ds, nothing
else
        mov     ds, gdtdsc
endif
        and     bl, not 7
        mov     ax, ds:[bx].dsc_lbase
        mov     dl, ds:[bx].dsc_mbase
        mov     dh, ds:[bx].dsc_hbase
        pop     ds
        pop     cx
        pop     bx
cEnd


;-----------------------------------------------------------------------;
; get_selector_length16
;
;
; Entry:
;
; Returns:
;       AX      16 bit segment length
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_selector_length16,<PUBLIC,NEAR>
        parmW   selector
cBegin
        mov     ax, -1
        lsl     ax, selector
        inc     ax                      ; length is one bigger!
cEnd

;-----------------------------------------------------------------------;
; set_physical_address
;
;
; Entry:
;       DX:AX  32 bit physical address
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   far_set_physical_address,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall set_physical_address,<selector>
cEnd

cProc   set_physical_address,<PUBLIC,NEAR>,<bx,di>
        parmW   selector
cBegin
        push    ecx
        mov     bx, selector
        CheckLDT bl
        lsl     ecx, ebx
if KDEBUG
        jz      short spa_ok
        int 3
spa_ok:
endif
        Limit_To_Selectors      ecx

        mov     di, cx
        mov     cx, dx                  ; CX:DX has new address
        mov     dx, ax

        push    ds
        push    bx
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        assumes ds, nothing
else
ifdef WOW
set_bases:
        DPMICALL 0007h                  ; Set selector base
else
        mov     ds, gdtdsc
set_bases:
        and     bl, not 7
        mov     ds:[bx].dsc_lbase, dx
        mov     ds:[bx].dsc_mbase, cl
        mov     ds:[bx].dsc_hbase, ch
endif; WOW
        lea     bx, [bx+DSC_LEN]        ; On to next selector
        inc     cx                      ; Add 64k to base
        dec     di
        jnz     set_bases

        pop     bx
        pop     ds
endif; ROM
        mov     ax, dx                  ; Restore AX and DX
        mov     dx, cx
        pop     ecx
cEnd


;-----------------------------------------------------------------------;
; set_selector_address32
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 16:40:59  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_selector_address32,<PUBLIC,NEAR>,<ax,dx>
        parmW   selector
        parmD   addr
cBegin
        mov     dx, addr.sel
        mov     ax, addr.off
        cCall   set_physical_address,<selector>
cEnd


;-----------------------------------------------------------------------;
; set_sel_limit
;
;
; Entry:
;       CX:BX = length of segment
; Returns:
;
; Registers Destroyed:
;       CX
;
; History:
;  Fri 15-Jul-1988 19:41:44  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_sel_limit,<PUBLIC,NEAR>,<ax,dx,si,di,es,ds>
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin
        push    ebx
        push    ecx

        push    bx                      ; Get existing descriptor
        smov    es, ss
        lea     di, DscBuf
        mov     bx, selector

        push    ds                      ; Get Descriptor
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        assumes ds,nothing
else
        mov     ds, gdtdsc
endif
        push    si
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
        pop     bx
        mov     dx, word ptr [DscBuf.dsc_access]
        and     dh, 0F0h                        ; Zap hlimit bits
        test    dl, DSC_PRESENT
        jz      short ssl_set_limit1            ; Not present, just one to set

        and     dh, NOT DSC_GRANULARITY         ; Byte granularity
        shl     ecx, 16
        mov     cx, bx                          ; DWORD length
        mov     ebx, ecx
        cmp     ecx, 100000h                    ; More than 1Mb?
        jb      short ssl_byte

        add     ecx, 0FFFh                      ; Round to 4k pages
        and     cx, not 0FFFh
        mov     ebx, ecx
        shr     ebx, 12                         ; # 4k pages
        or      dh, DSC_GRANULARITY             ; Set 4k granularity
ssl_byte:
        add     ecx, 0FFFFh
        shr     ecx, 16                         ; # selectors in array
        cmp     cx, 1
        je      short ssl_set_limit1
        
        dec     ebx                             ; length to limit
        mov     ax, bx                          ; low 16 bits of limit
        shr     ebx, 16
        or      dh, bl                          ; Bits 19:16 of limit

        mov     word ptr DscBuf.dsc_access, dx
        mov     DscBuf.dsc_limit, ax
        mov     bx, Selector

        call    fill_in_selector_array
        jmps    ssl_done

ssl_set_limit1:                                 ; Fast out for one only
        dec     bx                              ; Came in as length
        mov     DscBuf.dsc_limit, bx            ; and limit
        mov     word ptr DscBuf.dsc_access, dx  ; Access, Discard and hlimit
        mov     bx, Selector
        DPMICALL 000Ch

ssl_done:
        smov    ss,ss                           ; It may be SS we're changing
        pop     ecx
        pop     ebx
cEnd


;-----------------------------------------------------------------------;
; set_selector_limit32
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Fri 15-Jul-1988 19:41:44  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_selector_limit32,<PUBLIC,NEAR>,<cx,bx>
        parmW   selector
        parmD   sel_len
cBegin
        mov     cx, sel_len.hi
        mov     bx, sel_len.lo
        cCall   set_sel_limit,<selector>
cEnd

;-----------------------------------------------------------------------;
; mark_sel_NP
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;       BX
;
; History:
;  Fri 15-Jul-1988 21:37:22  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   mark_sel_NP,<PUBLIC,NEAR>,<ds>
        parmW   selector
        parmW   owner
        localV  DscBuf,DSC_LEN
cBegin
        push    ecx
        mov     bx, selector
        Handle_To_Sel           bl
        lsl     ecx, ebx                ; How many selectors do we have now?
        Limit_To_Selectors      ecx
        
        push    ax
        push    es
        push    di

        push    ds
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        assumes ds, nothing
else
        mov     ds, gdtdsc
endif
        push    bx
        and     bl, not 7
        mov     [bx].dsc_hbase, cl      ; Save # selectors
        mov     [bx].dsc_hlimit, DSC_DISCARDABLE
        and     [bx].dsc_access, NOT DSC_PRESENT
        mov     cx, owner
        mov     [bx].dsc_owner, cx      ; Set owner in descriptor

ifdef WOW
;
;   Now the copy of the LDT has the correct info set VIA DPMI the real NT
;   LDT Entry

        smov    es,ds
        mov     di,bx                   ; es:di->selector
        or      bx, SEG_RING            ; BX = selector
        DPMICALL 000Ch

endif; WOW
        pop     bx
        pop     ds

        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector32,<bx,0,cx>   ; Save owner in selector table
        pop     di
        pop     es
        pop     ax
        pop     ecx
cEnd


;-----------------------------------------------------------------------;
; mark_sel_PRESENT
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Fri 15-Jul-1988 21:37:22  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   mark_sel_PRESENT,<PUBLIC,NEAR>,<dx,di,es>
        parmD   arena_ptr
        parmW   selector
        localV  DscBuf,DSC_LEN
cBegin
        push    eax
        push    ebx
        push    ecx
        
        smov    es, ss
        lea     di, DscBuf
        mov     bx, selector
        DPMICALL 000Bh                          ; Get existing descriptor
        mov     ax, word ptr DscBuf.dsc_access  ; Access and hlimit
        or      al, DSC_PRESENT                 ; Mark it present
        and     ah, NOT DSC_GRANULARITY         ; Assume byte granular
                
        mov     esi, arena_ptr
        CheckDS
        mov     ecx, ds:[esi].pga_size
        mov     ebx, ecx
        cmp     ecx, 100000h                    ; New size more than 1Mb?
        jb      short msp_byte
                
        add     ebx, 0FFFh                      ; Round to 4k pages
        and     bx, not 0FFFh
        shr     ebx, 12                         ; # 4k pages
        or      ah, DSC_GRANULARITY             ; Set 4k granularity
msp_byte:                                               
        dec     ebx
        mov     DscBuf.dsc_limit, bx            ; Fill in new limit fields
        shr     ebx, 16
        and     bl, 0Fh
        and     ah, NOT 0Fh
        or      ah, bl
        mov     word ptr DscBuf.dsc_access, ax  ; Fill in new hlimit and access

        dec     ecx
        Limit_To_Selectors ecx                  ; New number of selectors
        mov     ds:[esi].pga_selcount, cl
        mov     bl, DscBuf.dsc_hbase            ; Old number of selectors
        sub     bl, cl          
        je      short go_ahead                  ; Same number, just fill in array
        jb      short get_big
        
; here to get small

        xor     bh, bh
        xchg    bx, cx
        shl     bx, 3                   ; Offset of first selector
        .errnz  DSC_LEN - 8
        add     bx, selector            ; First selector to free
@@:     cCall   free_sel,<bx>
        lea     bx, [bx+DSC_LEN]
        loop    @B
        jmps    go_ahead                ; And fill in remaining selectors

get_big:
        mov     ax, word ptr DscBuf.dsc_access  ; Access bits in ax
        mov     ebx, ds:[esi].pga_address       ; Get base address
        mov     ecx, ds:[esi].pga_size
        cCall   alloc_sel,<ebx,ecx>             ; Access bits in ax
        mov     si, ax
        or      ax, ax                  ; did we get a set?
        jz      short return_new_handle
        or      si, SEG_RING            ; Set ring bits like old selector
        test    selector, IS_SELECTOR
        jnz     short @F
        StoH    si
        HtoS    selector
@@:
        cCall   AssociateSelector32,<selector,0,0>
        cCall   FreeSelArray,<selector>         ; Zap old handle
        jmps    return_new_handle
        
go_ahead:
        mov     ebx, ds:[esi].pga_address       ; Fill in selector array with
        mov     DscBuf.dsc_lbase, bx            ; new base and limit
        shr     ebx, 16
        mov     DscBuf.dsc_mbase, bl
        mov     DscBuf.dsc_hbase, bh
        mov     bx, selector
        movzx   cx, ds:[esi].pga_selcount

        call    fill_in_selector_array
        mov     si, selector                    ; return old selector in SI
return_new_handle:

        pop     ecx
        pop     ebx
        pop     eax
cEnd

;-----------------------------------------------------------------------;
; cmp_sel_address
;
;       Compares the physical addresses corresponding to two selectors
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 09-Jul-1988 19:10:14  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   cmp_sel_address,<PUBLIC,NEAR>
        parmW   sel1
        parmW   sel2
cBegin
        push    ax
        push    ebx
        push    edx
        cCall   get_physical_address,<sel1>
        mov     bx, dx
        shl     ebx, 16
        mov     bx, ax                  ; First address in EBX
        cCall   get_physical_address,<sel2>
        shl     edx, 16
        mov     dx, ax                  ; Second address in EDX
        cmp     ebx, edx
        pop     edx
        pop     ebx
        pop     ax
;;;     mov     ds,gdtdsc
;;;     mov     si,sel1
;;;     mov     di,sel2
;;;     sel_check si
;;;     sel_check di
;;;     mov     al,[si].dsc_hbase
;;;     cmp     al,[di].dsc_hbase
;;;     jne     short csa_done
;;;     mov     al,[si].dsc_mbase
;;;     cmp     al,[di].dsc_mbase
;;;     jne     short csa_done
;;;     mov     ax,[si].dsc_lbase
;;;     cmp     ax,[di].dsc_lbase
;;;csa_done:
cEnd

;-----------------------------------------------------------------------;
; pdref                                                                 ;
;                                                                       ;
; Dereferences the given global handle, i.e. gives back abs. address.   ;
;                                                                       ;
; Arguments:                                                            ;
;       DX    = selector                                                ;
;       DS:DI = BURGERMASTER                                            ;
;                                                                       ;
; Returns:                                                              ;
;       ESI = address of arena header                                   ;
;       AX = address of client data                                     ;
;       CH = lock count or 0 for fixed objects                          ;
;       CL = flags                                                      ;
;       DX = handle, 0 for fixed objects                                ;
;                                                                       ;
; Error Returns:                                                        ;
;       ZF = 1 if invalid or discarded                                  ;
;       AX = 0                                                          ;
;       BX = owner of discarded object                                  ;
;       SI = handle of discarded object                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   pdref,<PUBLIC,NEAR>

cBegin nogen
        mov     si, dx
        sel_check si
        or      si, si                  ; Null handle?
        mov     ax, si
        jz      short pd_exit           ; yes, return 0

        lar     eax, edx
        jnz     short pd_totally_bogus
        shr     eax, 8

; We should beef up the check for a valid discarded sel.

        xor     cx,cx
        test    ah, DSC_DISCARDABLE
        jz      short pd_not_discardable
        or      cl, GA_DISCARDABLE
                                                ; Discardable, is it code?
        test    al, DSC_CODE_BIT
        jz      short pd_not_code
        or      cl,GA_DISCCODE
pd_not_code:

pd_not_discardable:
        test    al, DSC_PRESENT
        jnz     short pd_not_discarded

; object discarded

        or      cl,HE_DISCARDED
ifdef WOW
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

        move    ax,es                           ; save es
        mov     bx,dx
        mov     es,cs:gdtdsc
        and     bl, not 7
        mov     bx,es:[bx].dsc_owner
        mov     es,ax                           ; restore
else
        lsl     bx, dx                          ; get the owner
endif
        or      si, SEG_RING-1                  ; Handles are RING 2
        xor     ax,ax
        jmps    pd_exit

pd_not_discarded:
        cCall   get_arena_pointer32,<dx>
        mov     esi, eax
        mov     ax, dx
        or      esi, esi                        ; Unknown selector
        jz      short pd_maybe_alias
        mov     dx, ds:[esi].pga_handle
        cmp     dx, ax                          ; Quick check - handle in header
        je      short pd_match                  ; matches what we were given?

        test    al, IS_SELECTOR                 ; NOW, we MUST have been given
        jz      short pd_totally_bogus          ; a selector address.
        push    ax
        StoH    al                              ; Turn into handle
        cmp     dx, ax
        pop     ax
        jne     short pd_nomatch
pd_match:
        or      cl, ds:[esi].pga_flags
        and     cl, NOT HE_DISCARDED            ; same as GA_NOTIFY!!
        mov     ax, dx                          ; Get address in AX
        test    dl, GA_FIXED                    ; DX contains handle
        jnz     short pd_fixed                  ; Does handle need derefencing?
        mov     ch, ds:[esi].pga_count
        HtoS    al                              ; Dereference moveable handle
        jmps    pd_exit
pd_totally_bogus:
        xor     ax,ax
pd_maybe_alias:
ife ROM
if KDEBUG
        or      dx,dx
        jnz     short dref_invalid
endif
endif
pd_nomatch:                                     ; Handle did not match...
        xor     dx, dx
;;;     mov     dx, ax                          ; Must be an alias...
pd_fixed:
;;;     xor     si, si
;;;     xor     dx, dx
pd_exit:
        or      ax,ax
        ret
if KDEBUG
dref_invalid:
        push    ax
        kerror  ERR_GMEMHANDLE,<gdref: invalid handle>,0,dx
        pop     ax
        jmps    pd_nomatch
endif
cEnd nogen

cProc   Far_pdref,<PUBLIC,FAR>
cBegin nogen
        call    pdref
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; get_rover_2                                                           ;
;                                                                       ;
; Entry:                                                                ;
;         ES Selector to get rover for                                  ;
; Returns:                                                              ;
;         ES (kr2dsc) is rover DATA and PRESENT                         ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   get_rover_2,<PUBLIC,NEAR>,<di>
        localV  DscBuf,DSC_LEN
cBegin
        push    ax
        push    bx
        mov     bx, es                  ; Selector to get rover for
        push    ds
        SetKernelDS ds
        mov     di, kr2dsc
        mov     es, gdtdsc
        mov     ds, gdtdsc
        UnSetKernelDS ds
        push    si
        mov     si, bx
        and     si, not 7
        and     di, not 7
        MovsDsc
        lea     bx, [di-DSC_LEN]
        mov     es:[bx].dsc_access, DSC_PRESENT+DSC_DATA
        or      bl, SEG_RING
        pop     si
ifdef WOW
        push    cx
        mov     cx, 1
        DPMICALL WOW_DPMIFUNC_0C
        pop     cx
endif; WOW
        pop     ds
        mov     es, bx                  ; Return with ES containing rover
        pop     bx
        pop     ax
cEnd


;-----------------------------------------------------------------------;
; get_rover_232                                                         ;
;                                                                       ;
; Entry:                                                                ;
;       ds:esi                                                          ;
; Returns:                                                              ;
;         ES:0                                                          ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,BX,CX,DX,DI,SI,DS                                            ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;
ifndef WOW_x86
        assumes ds,nothing
        assumes es,nothing
cProc   get_rover_232,<PUBLIC,NEAR>,<di>
        localV  DscBuf,DSC_LEN
cBegin
        push    eax
        push    bx
        SetKernelDS es
        mov     bx, kr2dsc
        or      bl, SEG_RING
        smov    es, ss
        UnSetKernelDS es
        lea     di, DscBuf                      ; ES:DI -> descriptor
        mov     eax, ds:[esi].pga_address
        mov     [DscBuf].dsc_lbase, ax          ; Fill in base address
        shr     eax, 16
        mov     [DscBuf].dsc_mbase, al
        mov     [DscBuf].dsc_hbase, ah
        mov     [DscBuf].dsc_limit, 1000h               ; Real big limit
        mov     [DscBuf].dsc_hlimit, DSC_GRANULARITY
        mov     [DscBuf].dsc_access,DSC_PRESENT+DSC_DATA
        DPMICALL 000Ch                          ; Set descriptor
        mov     es, bx
        pop     bx
        pop     eax
cEnd
endif; WOW

cProc   far_get_temp_sel,<FAR,PUBLIC>
cBegin
        cCall   get_temp_sel
cEnd

cProc   get_temp_sel,<PUBLIC,NEAR>,<ax,cx,di,si>
        localV  DscBuf,DSC_LEN
cBegin
        mov     cx, 1
        DPMICALL 0000h                     ; Get us a selector
        push    bx
        mov     si, ax                  ; New selector
        mov     bx, es                  ; Old selector

ifdef WOW                               ; LATER Make single dpmicall
        smov    es, ss
        lea     di, DscBuf

        DPMICALL 000Bh                  ; Get existing descriptor

        mov     DscBuf.dsc_access,DSC_PRESENT+DSC_DATA
        mov     DscBuf.dsc_limit,0ffffh
        or      DscBuf.dsc_hlimit, 0Fh    ; Max length

        mov     bx, si
        or      bl, SEG_RING

        DPMICALL 000Ch                  ; Set new descriptor
else
        push    ds
if ROM
        SetKernelDS
        mov     es, gdtdsc
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
        mov     es, gdtdsc
endif
        mov     di, si
        and     di, not 7
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     bx, [di-DSC_LEN]
        mov     [bx].dsc_access,DSC_PRESENT+DSC_DATA
        mov     [bx].dsc_limit,0ffffh
        or      [bx].dsc_hlimit, 0Fh    ; Max length
        or      bl, SEG_RING
        pop     ds
endif; WOW
        mov     es, bx
        pop     bx
cEnd

cProc   far_free_temp_sel,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall   free_sel,<selector>
cEnd

;-----------------------------------------------------------------------;
; get_blotto
;
;
; Entry:
;       EAX = arena header
;
; Returns:
;       BX = Selector points to pga_address (size pga_arena)
; Registers Destroyed:
;
; History:
;  Sun 31-Jul-1988 16:20:53  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifndef WOW_x86
;; On WOW_x86 we try to avoid setting selectors since it is slow, we use selector
;; 23h to write to anywhere in VDM memory.


cProc   get_blotto,<PUBLIC,NEAR>,<di>
        localV  DscBuf,DSC_LEN
cBegin
        push    es
        push    bx
        lea     di, DscBuf
        SetKernelDS es
        mov     bx, blotdsc
        smov    es, ss
        UnSetKernelDS es
        or      bl, SEG_RING
        push    eax
        mov     eax, ds:[eax].pga_address
        mov     [DscBuf].dsc_lbase,ax
        shr     eax, 16
        mov     [DscBuf].dsc_mbase,al
        mov     [DscBuf].dsc_hbase,ah

        ; Convert pga_size to limit in page granularity

        pop     eax
        mov     eax, ds:[eax].pga_size  ; Get Size in Bytes
        add     eax, 4096-1             ; Round up to 4k multiple
        shr     eax, 3*4
        mov     [DscBuf].dsc_limit,ax
        shr     eax,16
        or      al, DSC_GRANULARITY

        mov     [DscBuf].dsc_hlimit, al
        mov     [DscBuf].dsc_access,DSC_PRESENT+DSC_DATA
        DPMICALL 000Ch                          ; Set up the descriptor
        mov     ax, bx
        pop     bx
        pop     es
cEnd
endif;


;-----------------------------------------------------------------------;
; LongPtrAdd
;
; Performs segment arithmetic on a long pointer and a DWORD offset
; The resulting pointer is normalized to a paragraph boundary.
; The offset cannot be greater than 16 megabytes (current Enh Mode
; limit on size of an object).
;
; Entry:
;
; Returns:
;       DX:AX new segment:offset
;
; Error returns:
;       DX:AX = 0
;
; Registers Destroyed:
;       BX,CX
;
; History:
;  Mon 19-Dec-1988 18:37:23  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifdef WOW

LPTRADDWOW_SETBASE equ 01h

;cProc  LongPtrAddWOW,<PUBLIC,FAR>,<si,di>
;       parmD   long_ptr
;       parmD   delta
;       parmW   RefSelector
;       parmW   flBaseSetting
;
;  effectively pops RefSelector and flBaseSetting  into dx and ax.
;  and jumps to longptrAddWorker.
;
;  RefSelector is used only if the descriptor needs to be set.
;

labelFP <PUBLIC,LongPtrAddWOW>
       pop ax
       pop dx           ; far return address
       mov bx,sp
       xchg ax, ss:[bx]    ; replace the 'dword' with the return address
       xchg dx, ss:[bx+2]
       jmps LongPtrAddWorker ; ax = flags; dx = reference selector

labelFP <PUBLIC,LongPtrAdd>
     mov ax, LPTRADDWOW_SETBASE
     xor dx, dx
     ; fall through

cProc   LongPtrAddWorker,<PUBLIC,FAR>,<si,di>
        parmD   long_ptr
        parmD   delta
        localV  DscBuf,DSC_LEN
        localW  flBaseSetting
        localW  RefSelector
cBegin
        mov     flBaseSetting, ax          ; save in localvariables
        mov     RefSelector, dx
        or      dx, dx                     ; if RefSelector is nonzero
        jz      @F                         ; use it for querying descriptor info.
        xchg    dx, word ptr long_ptr[2]   ; and store the selector to be set in
        mov     RefSelector, dx            ; the localvariable
@@:
else

cProc   LongPtrAdd,<PUBLIC,FAR>,<si,di>
        parmD   long_ptr
        parmD   delta
        localV  DscBuf,DSC_LEN
cBegin

endif
        mov     bx,word ptr long_ptr[2]
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh                  ; Pick up old descriptor
        mov     ax,word ptr long_ptr[0] ; get the pointer into SI:AX
        and     ax,0FFF0h

        mov     si, DscBuf.dsc_lbase    ; DX:SI gets old base
        mov     dl, DscBuf.dsc_mbase
        mov     dh, DscBuf.dsc_hbase

        add     si, ax                  ; Add in old pointer offset
        adc     dx, 0

        mov     cx, word ptr delta[2]   ; add the segment and MSW
        test    cx, 0FF00h              ; bigger than 16Meg?
ifdef WOW
        jz      @F
        test    flBaseSetting, LPTRADDWOW_SETBASE
        jnz     lptr_mustset
        jmp     short lpa_too_big
@@:
else
        jnz     short lpa_too_big
endif

        add     si, word ptr delta[0]   ; add the offset and LSW
        adc     dx, cx

ifdef WOW
lptr_mustset:
endif

        mov     cx, 1                   ; Calculate # selectors now in array
        lsl     ecx, dword ptr long_ptr[2]
        jnz     short trash
        Limit_to_Selectors      ecx
trash:
ifdef WOW
        test    flBaseSetting, LPTRADDWOW_SETBASE
        jz      lptr_dontset
        cmp     RefSelector, 0
        jz      @F
        mov     bx, RefSelector            ; get the actual selector to be set
        mov     word ptr long_ptr[2], bx
@@:
endif
        mov     DscBuf.dsc_lbase, si    ; Put new base back in descriptor
        mov     DscBuf.dsc_mbase, dl
        mov     DscBuf.dsc_hbase, dh

        call    fill_in_selector_array
ifdef WOW
lptr_dontset:
        test    word ptr delta[2], 0ff00h
        jz      @F
        mov     cx, word ptr delta[2]
        jmps    lpa_too_big
@@:
endif
        mov     dx,word ptr long_ptr[2]
        mov     ax,word ptr long_ptr[0]
        and     ax, 0Fh
        jnc     short lpa_exit

lpa_too_big:
        xor     ax,ax
        xor     dx,dx
lpa_exit:
        smov    es,0
cEnd


;-----------------------------------------------------------------------;
; SetSelectorBase
;
; Sets the base and limit of the given selector.
;
; Entry:
;       parmW   selector
;       parmD   selbase
;
; Returns:
;       AX = selector
;
; Error Returns:
;       AX = 0
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetSelectorBase,<PUBLIC,FAR>
        parmW   selector
        parmD   selbase
cBegin
        push    bx
        push    cx
        push    dx
        mov     cx, selbase.hi
        mov     dx, selbase.lo
        mov     bx, selector
ifdef WOW
        DPMICALL 0007h                  ; Set Segment Base Address
else
        push    ds
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        push    bx
        and     bl, not 7
        mov     ds:[bx].dsc_lbase, dx
        mov     ds:[bx].dsc_mbase, cl
        mov     ds:[bx].dsc_hbase, ch
        pop     bx
        pop     ds
endif; WOW
        pop     dx
        pop     cx
        pop     bx
        mov     ax,selector
cEnd

;-----------------------------------------------------------------------;
; GetSelectorLimit
;
; Sets the limit of the given selector.
;
; Entry:
;       parmW   selector
;
; Returns:
;       DX:AX = limit of selector
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetSelectorLimit,<PUBLIC,FAR>
        parmW   selector
cBegin
        xor     eax, eax                ; In case lsl fails
        lsl     eax, dword ptr selector
        mov     edx, eax
        shr     edx, 16
cEnd


;-----------------------------------------------------------------------;
; SetSelectorLimit
;
; Sets the limit of the given selector.
;
; Entry:
;       parmW   selector
;       parmD   sellimit
;
; Returns:
;       AX = 0 success
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetSelectorLimit,<PUBLIC,FAR>
        parmW   selector
        parmD   sellimit
        localV  DscBuf,DSC_LEN
cBegin

ifdef WOW
        mov     bx, selector
        mov     dx, word ptr sellimit[0]
        mov     cx, word ptr sellimit[2]
        DPMICALL 0008h
else
        push    es
        push    di
        mov     bx,selector

        push    ds
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        and     bl, not 7
        mov     ax,sellimit.lo
        mov     [bx].dsc_limit,ax
        mov     ax,sellimit.hi
        and     al,0Fh                          ; AND out flags
        and     [bx].dsc_hlimit,0F0h        ; AND out hi limit
        or      [bx].dsc_hlimit,al
        pop     ds
        pop     di
        pop     es
endif; WOW
        xor     ax,ax                           ; for now always return success
cEnd


;-----------------------------------------------------------------------;
; SelectorAccessRights
;
; Sets the access and other bytes of the given selector.
;
; Entry:
;       parmW   selector
;       parmW   getsetflag
;       parmD   selrights
;
; Returns:
;       AX = 0 success
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 21:10:29  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SelectorAccessRights,<PUBLIC,FAR>

        parmW   selector
        parmW   getsetflag
        parmW   selrights
cBegin

        mov     bx, selector
        lar     eax, ebx                ; Get current access rights
        shr     eax, 8                  ; in AX

        cmp     getsetflag,0
        jnz     short sar_set

        and     ax, 0D01Eh              ; Hide bits they can't play with
        jmps    sar_exit

sar_set:
        mov     cx, selrights
        and     cx, 0D01Eh              ; Zap bits they can't set and
        and     ax, NOT 0D01Eh          ; get them from existing access rights
        or      cx, ax
        DPMICALL 0009h                  ; Set new access rights
        xor     ax,ax                   ; for now always return success

sar_exit:

cEnd


cProc   SetKernelCSDwordProc,<PUBLIC,NEAR>,<ax,bx,ds>
        parmw   addr
        parmw   hiword
        parmw   loword
cBegin
        SetKernelDS
        mov     ds, MyCSAlias
        UnSetKernelDS
        mov     bx, addr
        mov     ax, loword
        mov     [bx], ax
        mov     ax, hiword
        mov     [bx+2], ax
cEnd

cProc   GetKernelDataSeg,<PUBLIC,NEAR>
cBegin nogen
        mov     ax, cs:MyCSDS
        ret
cEnd nogen

cProc   SetKernelDSProc,<PUBLIC,NEAR>
cBegin nogen
        mov     ds, cs:MyCSDS
        ret
cEnd nogen

cProc   SetKernelESProc,<PUBLIC,NEAR>
cBegin nogen
        mov     es, cs:MyCSDS
        ret
cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   PreallocArena,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        push    eax
        cCall   alloc_arena_header,<eax>
        call    SetKernelDSProc
        ReSetKernelDS
        mov     temp_arena, eax
        or      eax, eax                        ; Set flags for caller
        pop     eax
        pop     ds
        UnSetKernelDS
        ret
cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   alloc_arena_header,<PUBLIC,NEAR>,<es>
        parmD   Address
        localV  DscBuf,DSC_LEN
cBegin
        SetKernelDS es
        push    ebx

        xor     eax, eax
        cmp     temp_arena, eax                 ; Have one waiting?
        je      short aah_look                  ;  no, get one
        xchg    temp_arena, eax                 ; Use the waiting selector
        jmp     aah_found

aah_look:
        cmp     FreeArenaCount, 0
        jnz     aah_ok
                                        ; Out of arenas, try to get
        push    ecx
        push    si
        push    di
        xor     bx, bx
        mov     cx, ARENA_INCR_BYTES
        DPMICALL 0501h
        jc      short aah_no_memory

if 0
        push    si
        push    di
        mov     ax, 0600h               ; Page lock it
        mov     di, ARENA_INCR_BYTES
        xor     si, si
        int     31h
        pop     di
        pop     si
        jnc     short aah_got_memory
                
give_it_back:
        DPMICALL 0502h               ; No good, give it back
else
        jmp     short aah_got_memory
endif

aah_no_memory:
        pop     di
        pop     si
        pop     ecx
        xor     eax, eax                ; We are REALLY out of arenas!
        jmp     aah_exit

aah_got_memory:
        shl     ebx, 16
        mov     bx, cx                  ; Address of our new arenas
        cCall   get_arena_pointer32,<ds>; Arena of burgermaster
        sub     ebx, [eax].pga_address  ; Above present arenas?

        lea     ecx, [ebx+ARENA_INCR_BYTES+0FFFh]
        shr     ecx, 12                 ; #pages selector must cover
        dec     ecx                     ; limit with page granularity
        cmp     ecx, HighestArena
        jbe     short aah_limitOK


        mov     HighestArena, ecx
        push    es
        push    bx
        mov     bx, ds
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh                  ; Get DS descriptor
        mov     [DscBuf].dsc_limit, cx  ; Set the new limit in the descriptor
        shr     ecx, 16
        and     cl, 0fh                 ; hlimit bits
        and     [DscBuf].dsc_hlimit, not 0fh; Zap old ones
        or      cl, DSC_GRANULARITY     ; Granularity bit
        or      [DscBuf].dsc_hlimit, cl
        DPMICALL 000Ch                  ; Set new limit
        pop     bx
        pop     es

aah_limitOK:
        mov     cx, ARENA_INCR_BYTES
        shr     cx, 5                   ; # arenas to add
aah_loop:
        cCall   free_arena_header,<ebx> ; Free up all our new arenas
        add     ebx, size GlobalArena32
        loop    aah_loop

        pop     di
        pop     si
        pop     ecx
        
aah_ok:
        mov     eax, FreeArenaList
if KDEBUG
        inc     eax
        jnz     short aah_ook
        int 3
        int 3
aah_ook:
        dec     eax
endif
        mov     ebx, ds:[eax.pga_next]
        mov     FreeArenaList, ebx
        dec     FreeArenaCount
aah_found:
        mov     ebx, Address
        mov     ds:[eax.pga_address], ebx
        mov     dword ptr ds:[eax.pga_count], 0
aah_exit:
        pop     ebx
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   free_arena_header,<PUBLIC,NEAR>,<es>
        parmD   arena
cBegin
        push    eax
        push    ebx
        SetKernelDS es
        CheckDS

        mov     ebx, arena
        mov     eax, FreeArenaList
        mov     ds:[ebx.pga_next], eax
        mov     FreeArenaList, ebx
        inc     FreeArenaCount
        pop     ebx
        pop     eax
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   FarAssociateSelector32,<PUBLIC,FAR>
        parmW   Selector
        parmD   ArenaPtr
cBegin
        cCall   AssociateSelector32,<Selector,ArenaPtr>
cEnd

cProc   AssociateSelector32,<PUBLIC,NEAR>,<ds,es>
        parmW   Selector
        parmD   ArenaPtr
cBegin
        CheckDS
        SetKernelDS es
        push    eax
        push    ebx
        movzx   ebx, Selector
        and     bl, NOT SEG_RING_MASK
        shr     bx, 1
if KDEBUG
        cmp     bx, SelTableLen
        jb      short as_ok
        INT3_NEVER
        INT3_NEVER
as_ok:
endif
        add     ebx, SelTableStart
        mov     eax, ArenaPtr
        mov     ds:[ebx], eax
        pop     ebx
        pop     eax
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   far_get_arena_pointer32,<PUBLIC,FAR>
        parmW   Selector
cBegin
        cCall   get_arena_pointer32,<Selector>
cEnd

cProc   get_arena_pointer32,<PUBLIC,NEAR>
        parmW   Selector
cBegin
        CheckDS
        push    es
        SetKernelDS es
        push    ebx
        movzx   ebx, Selector
        and     bl, not SEG_RING_MASK
        shr     bx, 1
        cmp     bx, SelTableLen
        jb      short gap_ok
        xor     eax, eax                        ; Bogus, return null
        jmps    gap_exit
gap_ok:
        add     ebx, SelTableStart
        mov     eax, ds:[ebx]

if ROM
        ; hack for ROM-owned selectors.  these do not have arenas
        ; but the owner is stored in the low word.  ack ack ack!!
        ;
        cmp     eax, 0FFFF0000h
        jb      short @F
        xor     eax, eax
@@:
endif

if KDEBUG
        or      eax, eax
        jz      short gap_exit                  ; Bogus, return null
        push    si
        mov     si, ds:[eax].pga_handle
        sel_check si
        or      si, si
        jz      short gap32_match               ; Boot time...
        sub     ebx, SelTableStart
        shl     bx, 1
        cmp     bx, si
        je      short gap32_match
        xor     eax, eax                ; put back in 5 feb 90, alias avoided
;;;     xor     eax, eax                        ; Removed - may be an alias!
gap32_match:
        pop     si
endif

gap_exit:
        pop     ebx
        pop     es
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   FarGetOwner,<PUBLIC,FAR>,<bx>
        parmW   Selector
cBegin
        cCall   GetOwner,<Selector>
cEnd

cProc   GetOwner,<PUBLIC,NEAR>,<bx,es>
        parmW   Selector
cBegin
        GENTER32
        ;;;push    eax      ;; why??? ax gets trashed anyway.
        cCall   get_arena_pointer32,<Selector>
if ROM
        or      eax, eax
        jnz     short @F
        cCall   GetROMOwner,<selector>
        jmp     short go_solong
@@:
endif
        or      eax, eax
        jz      go_solong
        mov     bx, ds:[eax].pga_owner
        ;;;pop     eax
        mov     ax, bx
go_solong:
        GLEAVE32
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   FarSetOwner,<PUBLIC,FAR>
        parmW   Selector
        parmW   owner
cBegin
        cCall   SetOwner,<Selector,owner>
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   SetOwner,<PUBLIC,NEAR>,<ds,es>
        parmW   Selector
        parmW   owner
cBegin
        GENTER32                        ; Assume ds not set!
        push    eax
        cCall   get_arena_pointer32,<Selector>
        push    owner
        pop     ds:[eax].pga_owner
        pop     eax
        GLEAVE32
cEnd


        assumes ds, nothing
        assumes es, nothing

cProc   PageLockLinear,<PUBLIC,NEAR>,<ax,bx,cx,si,di>
        parmD   address
        parmD   len
cBegin
        mov     bx, word ptr address+2
        mov     cx, word ptr address
        mov     si, word ptr len+2
        mov     di, word ptr len
        DPMICALL 0600h
                                ; Let it return with carry flag from int 31h
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   FarValidatePointer,<PUBLIC,FAR>
        parmD   lpointer
cBegin
        cCall   ValidatePointer,<lpointer>
cEnd

cProc   ValidatePointer,<PUBLIC,NEAR>
        parmD   lpointer
cBegin
        lar     ax, lpointer.sel
        jnz     short bad_p             ; Really bad selector
        test    ah, DSC_PRESENT         ; Must be present
        jz      short bad_p
        lsl     eax, dword ptr lpointer.sel
        movzx   ecx, lpointer.off
        cmp     eax, ecx                ; Is the offset valid?
        jae     short good_p
bad_p:
        xor     ax, ax
        jmps    vp_done
good_p:
        mov     ax, 1
vp_done:
cEnd


        assumes ds, nothing
        assumes es, nothing

OneParaBytes    dw      10h


cProc   SelToSeg,<PUBLIC,NEAR>,<dx>
        parmW   selector
cBegin
        cCall   get_physical_address,<selector>
        div     cs:OneParaBytes                 ; Smaller than rotates
cEnd
        

cProc   SegToSelector,<PUBLIC,NEAR>,<bx,cx,di,ds>
        parmW   smegma
cBegin
        mov     bx, smegma
        DPMICALL 0002h                  ; Make win386 do it

cEnd


;-----------------------------------------------------------------------;
; set_discarded_sel_owner
;
; Sets the owner of a selector that points to a discarded object,
; which lives in the limit field.
;
; Entry:
;       BX = selector to mark
;       ES = owner
;
; Returns:
;       nothing
;
; Registers Destroyed:
;       BX
;
; History:
;  Sun 03-Dec-1989 21:02:24  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   set_discarded_sel_owner,<PUBLIC,FAR>
        localV  DscBuf,DSC_LEN
cBegin
        push    cx
        push    di
        mov     cx, es

if KDEBUG
ifdef WOW
        lea     di, DscBuf
        smov    es, ss
        DPMICALL 000Bh
        push    cx
        xor     cx,cx                       ; For debug build write 0 to LDT
        mov     DscBuf.dsc_owner, cx
        DPMICALL 000Ch
        pop     cx
endif
endif
        push    ds
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        push    bx
        and     bl, not 7
        mov     [bx].dsc_owner, cx
        pop     bx
        pop     ds
        push    ds
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector32,<bx,0,cx>   ; And save in selector table
        pop     ds
        mov     es, cx
        pop     di
        pop     cx
cEnd

;-----------------------------------------------------------------------;
; SetResourceOwner
;
; Sets the owner of a selector that points to a not present resource
;
; Entry:
;
; Returns:
;       nothing
;
; Registers Destroyed:
;
; History:
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SetResourceOwner,<PUBLIC,NEAR>,<ax,bx,cx,di,ds,es>
        parmW   selector
        parmW   owner
        parmW   selCount
        localV  DscBuf,DSC_LEN
cBegin
        mov     bx, selector
        mov     cx, owner
ifdef WOW
        smov    es, ss
        lea     di, DscBuf
        DPMICALL 000Bh                  ; Get current descriptor
        mov     DscBuf.dsc_owner, cx
        mov     word ptr DscBuf.dsc_access, (DSC_DISCARDABLE SHL 8) + DSC_DATA
        mov     cx,selCount
        mov     DscBuf.dsc_hbase, cl      ; Save number of selectors here
        DPMICALL 000Ch                  ; Set it with new owner
else
        push    ds
if ROM
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        push    bx
        and     bl, not 7
        mov     [bx].dsc_owner, cx
        mov     word ptr [bx].dsc_access, (DSC_DISCARDABLE SHL 8) + DSC_DATA
        mov     cx, selCount
        mov     [bx].dsc_hbase, cl      ; Save number of selectors here
        pop     bx
        pop     ds
endif; WOW
        SetKernelDS
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   AssociateSelector32,<bx,0,owner> ; And save in selector table
cEnd                                            

cProc   GetAccessWord,<PUBLIC,NEAR>
        parmW   selector
cBegin
        lar     eax, dword ptr selector         ; 386 or better, can use LAR
        shr     eax, 8
cEnd


;-----------------------------------------------------------------------;
; DPMIProc
;
; Called NEAR by the DPMICALL macro -
; this is better than intercepting int 31h
;
; By sheer fluke, all intercepts return with
; Carry clear ie no error.
;
;-----------------------------------------------------------------------;
cProc   DPMIProc,<PUBLIC,NEAR>
cBegin nogen
if 0
        cmp     ax,WOW_DPMIFUNC_0C
        jne     @f

        INT3_TEST
        push    ds
        SetKernelDS ds
        cmp     high0c,cx
        ja      popit

        mov     high0c,cx
popit:
        pop     ds
@@:
endif

ifdef WOW
        cmp     ax,501h
        jne     normal

        push    eax
        push    edx

    shl ebx,16          ; ebx = bx:cx
        mov     bx,cx

        xor     eax,eax
        mov     ecx,PAGE_READWRITE
        mov     edx,MEM_COMMIT_RESERVE
        cCall   VirtualAlloc,<eax,ebx,edx,ecx>

        mov     bx,dx                   ; DPMI returns BX:CX - linear Address
        mov     cx,ax

        mov     si,dx                   ; FAKE dpmi "handle" - linear Address
        mov     di,ax

        or      ax,dx                   ; NULL is Error
        pop     edx
        pop     eax

        clc
        jnz     @f                      ; OK Jump
        stc                             ; else set error
@@:
        ret

normal:
endif  ; WOW

        or      ah, ah

        jz      @F
ife KDEBUG
ifdef WOW_x86

        ;
        ; If it is the wow set selector call we will just set the selector
        ; directly using int 2a (only for the single selector case)
        ;
        cmp     ax,WOW_DPMIFUNC_0C 
        jne     CallServer
        
        cmp     cx,1
        jne     CallServer

        call    WowSetSelector
        jc      CallServer
        ret
endif        
endif
CallServer:
ifndef WOW
        int     31h                     ; Nope, call DPMI server
        ret
else
        test    word ptr [prevInt31Proc + 2],0FFFFh
        jz      dp30
dp20:
        pushf
        call    [prevInt31Proc]
        ret
endif
@@:
ifdef WOW
        cmp     gdtdsc, 0               ; Can we party?
        jz      CallServer              ; Nope
endif
        push    ds
        mov     ds, gdtdsc
ifdef WOW

        or      al, al
        jnz     @F
        mov     ax, WOW_DPMIFUNC_00
        pop     ds
        jmp     CallServer
@@:
endif
        cmp     al, 0Bh
        jne     short @F

        push    si                      ; Get Descriptor - used very often!
        mov     si, bx
        and     si, not 7
        MovsDsc
        lea     di, [di-DSC_LEN]        ; Restore DI
        pop     si
        pop     ds
        ret
ifndef WOW
@@:
        cmp     al, 0Ch
        jne     @F

        push    bx                      ; Set Descriptor
        and     bl, not 7
        mov     ax, es:[di]             ; This looks slow but it isn't...
        mov     ds:[bx], ax
        mov     ax, es:[di][2]
        mov     ds:[bx][2], ax
        mov     ax, es:[di][4]
        mov     ds:[bx][4], ax
        mov     ax, es:[di][6]
        mov     ds:[bx][6], ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
        ret

@@:
        cmp     al, 07h         ; Set Segment Base Address
        jne     @F
        push    bx
        and     bl, not 7
        mov     ds:[bx].dsc_lbase, dx
        mov     ds:[bx].dsc_mbase, cl
        mov     ds:[bx].dsc_hbase, ch
        pop     bx
        pop     ds
        ret
endif
@@:
        cmp     al, 06h                 ; Get Segment Base Address
        jne     @F
        push    bx
        and     bl, not 7
        mov     dx, ds:[bx].dsc_lbase
        mov     cl, ds:[bx].dsc_mbase
        mov     ch, ds:[bx].dsc_hbase
        pop     bx
        pop     ds
        ret
ifndef WOW
@@:
        cmp     al, 09h                 ; Set Descriptor Access Rights
        jne     @F
        push    bx
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     bx
        pop     ds
        ret
endif
@@:
        pop     ds
        jmp     CallServer

ifdef WOW
dp30:   int     31h
        ret
endif
cEnd nogen

ife KDEBUG
ifdef WOW_x86
;-----------------------------------------------------------------------;
; WowSetSelector
;
;   Entry
;       BX contains selector #
;
;   Exit
;       CY clear for success
;
;
;-----------------------------------------------------------------------;
cProc   WowSetSelector,<PUBLIC,NEAR>
cBegin nogen
        
        push    ds
        push    es
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    ebp
        
        SetKernelDS ds
        ;
        ; Check to see if we can do this
        ;
        mov     edx, FlatAddressArray
        or      edx, edx
        stc     
        jz      wss50
        
        ;       
        ; put the base of the selector in the flat address array
        ;
        mov     es,gdtdsc
        and     bx, NOT SEG_RING
        mov     ax, FLAT_SEL
        mov     ds, ax
        mov     ah, es:[bx].dsc_hbase
        mov     al, es:[bx].dsc_mbase
        shl     eax,16
        mov     ax, es:[bx].dsc_lbase
        movzx   ecx,bx
        shr     ecx,1                   ; dword index from selector index
        add     ecx, edx                ; point to proper spot in array
        mov     [ecx], eax

        ; 
        ; Form the limit of the selector 
        ;
        movzx   dx, byte ptr es:[bx].dsc_hlimit
        and     dx,0fh                  ; remove gran etc.
        shl     edx, 16
        mov     dx, es:[bx].dsc_limit
        
        ;
        ; Adjust for granularity
        ;
        test    es:[bx].dsc_hlimit, DSC_GRANULARITY
        jz      wss10
        
        shl     edx,12
        or      edx,0fffh
        
        ;
        ; Verify that the base/limit combination is allowed
        ; duplicate of code in dpmi32/i386/dpmi386.c <DpmiSetDescriptorEntry>
        ;
wss10:  cmp     edx,07ffeffffh
        ja      wss30
        
        mov     ecx,eax
        add     ecx,edx
        cmp     ecx,07ffeffffh
        jb      wss40
        
        ; 
        ; Limit is too high, so adjust it downward
        ;
wss30:  mov     edx,07ffeffffh
        sub     edx,eax
        sub     edx,0fffh
        
        ;
        ; fix for granularity
        ;
        test    es:[bx].dsc_hlimit, DSC_GRANULARITY
        jz      wss35
        
        shr     edx,12
        
        ;
        ; store the new limit in the descriptor table
        ;
wss35:  mov     es:[bx].dsc_limit,dx
        shr     edx,16
        movzx   ax,es:[bx].dsc_hlimit
        and     ax,0f0h                         ; mask for gran etc
        and     dx,00fh                         ; mask for limit bits
        or      dx,ax                           ; put back gran etc
        mov     es:[bx].dsc_hlimit,dl

        ;
        ; Call the system to set the selector
        ;
        ; int 2a special case for wow:
        ;
        ;    eax = 0xf0f0f0f1
        ;    ebp = 0xf0f0f0f1
        ;    ebx = selector
        ;    ecx = first dword of the descriptor (LODWORD)
        ;    edx = second dword of the descriptor (HIDWORD)
        
wss40:  mov     eax, 0f0f0f0f1h
        mov     ebp, 0f0f0f0f1h
        mov     ecx, dword ptr es:[bx]
        mov     edx, dword ptr es:[bx+4]
        movzx   ebx,bx
        or      bl, 3
        int     02ah
            
wss50:
        pop     ebp
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        pop     es
        pop     ds
        ret        
cEnd nogen
endif ; WOW_x86
endif
if ROM

;-----------------------------------------------------------------------------
;
;   Functions for ROM Windows
;
;

;-----------------------------------------------------------------------------
;
;   HocusROMBase
;
;-----------------------------------------------------------------------------

assumes ds,nothing
assumes es,nothing
assumes fs,nothing
assumes gs,nothing

cProc   HocusROMBase, <PUBLIC, FAR>

    parmW   selector

cBegin
    push    bx
    push    cx
    push    dx
    push    ds
    SetKernelDS
    mov     bx, selector
    DPMICALL 0006h
    mov     ax, cx
    shl     eax, 16
    mov     ax, dx
    sub     eax, lmaHiROM
    jb      not_in_hi_rom
    cmp     eax, cbHiROM
    jae     not_in_hi_rom
    add     eax, linHiROM
    mov     dx, ax
    shr     eax, 16
    mov     cx, ax
    DPMICALL 0007h
not_in_hi_rom:
    mov     ax, bx
    pop     ds
    UnsetKernelDS
    pop     dx
    pop     cx
    pop     bx
cEnd


;-----------------------------------------------------------------------------
;
;   ChangeROMHandle
;
;-----------------------------------------------------------------------------

assumes ds,nothing
assumes es,nothing
assumes fs,nothing
assumes gs,nothing

cProc   ChangeROMHandle, <FAR, PUBLIC>, <si, bx, es, di, ds>

    parmW   hold
    parmW   hnew

    localV  dscbuf, DSC_LEN

cBegin

    SetKernelDS
    mov     ds, ArenaSel
    UnsetKernelDS

    mov     bx, hold
    cCall   get_arena_pointer32, <bx>
    or      eax, eax
    jz      short crh_bummer_dude

    push    eax

    mov     si, bx
    and     si, SEG_RING_MASK
    or      si, hnew
    smov    es, ss
    lea     di, dscbuf
    DPMICALL    000Bh
    xchg    bx, si
    DPMICALL    000Ch

    cCall   AssociateSelector32, <si, 0, 0>

    pop     eax

    test    dscbuf.dsc_access, DSC_PRESENT
    jz      short @F
    mov     ds:[eax].pga_handle, bx
@@:
    cCall   AssociateSelector32, <bx, eax>
    cCall   FreeSelArray, <hold>

    mov     ax, bx

crh_bummer_dude:

cEnd


;-----------------------------------------------------------------------------
;
;   CloneROMSelector
;
;-----------------------------------------------------------------------------

assumes ds,nothing
assumes es,nothing
assumes fs,nothing
assumes gs,nothing

cProc   CloneROMSelector, <NEAR, PUBLIC>, <es, di, bx, ds>

    parmW   selROM
    parmW   selClone

cBegin

    SetKernelDS
    mov     di, selROM
    mov     es, selROMTOC
    assumes es, nothing
    and     di, NOT SEG_RING_MASK
    sub     di, es:[FirstROMSel]
    mov     es, selROMLDT
    mov     bx, selClone
    DPMICALL    000Ch

    cCall   HocusROMBase, <bx>

    mov     ds, ArenaSel
    cCall   AssociateSelector32, <bx, 0, 0>

    mov     ax, bx

cEnd

;-----------------------------------------------------------------------------
;
;   Get/SetROMOwner
;
;-----------------------------------------------------------------------------

assumes ds,nothing
assumes es,nothing
assumes fs,nothing
assumes gs,nothing

cProc   SetROMOwner, <NEAR, PUBLIC>, <ds, ebx, es>

        parmW   selector
        parmW   owner

cBegin
        GENTER32
        cCall   AssociateSelector32, <selector, 0FFFFh, owner>
        GLEAVE32
cEnd

cProc   FarSetROMOwner, <FAR, PUBLIC>

        parmW   selector
        parmW   owner

cBegin
        cCall   SetROMOwner, <selector, owner>
cEnd

cProc   GetROMOwner, <NEAR, PUBLIC>, <ds, es, ebx>

        parmW   selector

cBegin
        UnsetKernelDS
        SetKernelDS es
        mov     ds, ArenaSel
        movzx   ebx, selector
        and     bl, not SEG_RING_MASK
        shr     bx, 1
        cmp     bx, SelTableLen
        jae     short gro_nope
        add     ebx, SelTableStart
        mov     eax, ds:[ebx]
        cmp     eax, 0FFFF0000h
        jae     short gro_ok
gro_nope:
        xor     eax, eax
gro_ok:
cEnd

;-----------------------------------------------------------------------------
;
;   IsROMObject
;
;-----------------------------------------------------------------------------

assumes ds,nothing
assumes es,nothing
assumes fs,nothing
assumes gs,nothing

cProc   IsROMObject, <NEAR, PUBLIC>, <bx, di, es>

        parmW   selector
        localV  DscBuf, DSC_LEN

cBegin

if KDEBUG
        mov     ax, selector
        sel_check   ax
endif

        mov     bx, selector
        smov    es, ss
        lea     di, DscBuf
        DPMICALL    000Bh

        SetKernelDS ES

        mov     ah, DscBuf.dsc_hbase
        mov     al, DscBuf.dsc_mbase
        shl     eax, 16
        mov     ax, DscBuf.dsc_lbase
        sub     eax, linHiROM
        jc      short iro_not_rom
        sub     eax, cbHiROM
        jnc     short iro_not_rom
        mov     al, 1
        jmps    iro_exit

iro_not_rom:
        xor     eax, eax

iro_exit:
cEnd

cProc   FarIsROMObject, <FAR, PUBLIC>

        parmW   selector

cBegin
        cCall   IsROMObject, <selector>
cEnd

endif

ifdef WOW

;-----------------------------------------------------------------------------
; Grab the selector 0x47 so that we dont need to special case the biosdata
; selector (0x40) while converting seg:off address to flat 32bit address
;
; This, however should not be part of Krnl286 heap.
;
;                                                    - Nanduri Ramakrishna
;-----------------------------------------------------------------------------
cProc   AllocSelector_0x47,<PUBLIC,FAR>, <ax, bx, cx, ds>
cBegin

     ; alloc the specific selector

     mov bx, 047h
     DPMICALL 0dh
     jc  as47_exit

     ; initialize the LDT

     and     bx, not SEG_RING
     mov     ds, gdtdsc
     mov     [bx].dsc_limit, 00h          ; = 1 byte
     mov     [bx].dsc_lbase, 0400h
     mov     [bx].dsc_mbase, 00h
     mov     [bx].dsc_hbase, 00h

     mov     ax, DSC_DATA+DSC_PRESENT
     and     ah, not 0Fh                     ; Zero limit 19:16
     mov     word ptr [bx].dsc_access, ax

     ; set the LDT

     mov     cx,1
     mov     bx, 047h
     DPMICALL WOW_DPMIFUNC_0C

as47_exit:
cEnd

endif

sEnd    CODE

sBegin  NRESCODE

assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

; All the code below is to support DIB.DRV and WING.

cProc   get_sel_flags,<PUBLIC,FAR>
        parmW   selector
cBegin
    SetKernelDSNRes
    mov     ds,pGlobalHeap
    cCall   far_get_arena_pointer32,<selector>
    or      eax,eax
    jz      gsf5
    movzx   ax, byte ptr ds:[eax].pga_flags
gsf5:
    xor     dx,dx
cEnd

cProc   set_sel_for_dib,<PUBLIC,FAR>
        parmW   selector
        parmW   flags
        parmW   addressLo
        parmW   addressHi
        parmW   csel
cBegin
    SetKernelDSNRes
    push    ecx
    push    ebx
    push    fs
    push    es

    ; if the selector has a value of -1, it means we either need to allocate
    ; or deallocate an array of selectors.  If we are allocating, csel will have
    ; a count of 64k selectors.  If csel is 0, we need to deallocate the selector
    ; array pointed to by address.

    cmp     selector,-1
    jne     ssfSetDIB

    ; see if we are actually deleting the selector array

    cmp     csel,0
    jne     ssfAllocSel

    ; free selector array at addressHi

    cCall   IFreeSelector,<addressHi>

    mov     ax,1
    mov     dx,0
    jmp     ssf5

ssfAllocSel:
    ; we need to have the selector array created

    cCall   AllocSelectorArray,<csel>
    mov     selector,ax

    xor     dx,dx
    cmp     ax,0
    je      ssf5

    ; we must set the limits in the selectors.  Each selector
    ; must have a limit in bytes for the remainder of the buffer.  If there are
    ; 3 selectors, the first will be 0x0002ffff, the second 0x0001ffff, the
    ; third 0x0000ffff.

    mov     cx,csel
    mov     bx,selector

ssfSetLimit:
    sub     cx,1        ; 1 less each time
    cCall   SetSelectorLimit,<bx,cx,-1>
    add     bx,DSC_LEN  ; advance to the next selector
    cmp     cx,0        ; see if we have any more selector to set
    jne     ssfSetLimit


    mov     dx,addressHi
    mov     ax,addressLo
    push    selector
    call    far_set_physical_address

    mov     ax,0        ; return the first selector
    mov     dx,selector
    jmp     ssf5

ssfSetDIB:
    push    ds
    mov     ds,pGlobalHeap
    cCall   far_get_arena_pointer32,<selector>
    or      eax,eax
    jz      ssf5
    pop     fs
    push    eax         ; save arena ptr
    cCall   GrowHeapDib,<eax,addressHi,addressLo>
    or      eax,eax
    jnz     ssf0
    pop     eax
    xor     eax,eax
    jmp     ssf5
ssf0:
    pop     esi             ; ds:esi is arena ptr
    push    eax             ; save the new arena
    xor     edi,edi         ; ds:edi is global heap info
    cCall   Free_Object2
    mov     dx,addressHi
    mov     ax,addressLo
    cCall   far_set_physical_address,<selector>
    pop     eax
    push    eax
    cCall   FarAssociateSelector32, <selector, eax>

    ; now see that the GAH_PHANTOM flag is set in the arena
    pop     edx
    or      ds:[edx].pga_flags, GAH_PHANTOM

    ; Now check if we are operating on a local heap. If so we change the
    ; LocalNotifyDefault to LocalNotifyDib.
    push    es
    push    selector
    pop     es
    xor     edi,edi
    mov     di,word ptr es:[pLocalHeap]
    or      di,di
    jz      ssf4                    ; Its not a local heap
    cmp     edi,ds:[edx].pga_size
    jae     ssf4                    ; Its not a local heap
    cmp     word ptr es:[di].li_sig,LOCALHEAP_SIG      ; es:li_sig == LH
    jne     ssf4
if KDEBUG
    cmp     word ptr es:[di].li_notify,codeOFFSET LocalNotifyDefault
    jne     ssf2
    cmp     word ptr es:[di].li_notify+2,codeBase
    je      ssf3
ssf2:
    krDebugOut <DEB_TRACE OR DEB_KrMemMan>, "Set_Sel_For_Dib: App has hooked LocalNotifyDefault"
ssf3:
endif
    mov     word ptr es:[di].li_notify,codeOFFSET LocalNotifyDib
    mov     word ptr es:[di].li_notify+2,codeBase
ssf4:
    pop     es
    mov     eax,1
ssf5:
    pop     es
    pop     fs
    pop     ebx
    pop     ecx
cEnd

cProc   RestoreDib,<PUBLIC,FAR>
        parmW   selector
        parmW   flags
        parmD   address
        localw  hNewDib
        localw  cSel
        localD  DibSize
        localD  NewArena
        localD  OldArena
cBegin
    SetKernelDSNRes
    push    ecx
    push    ebx
    push    fs
    push    es

    ;; Allocate a new global block
    xor     eax, eax                ; In case lsl fails
    lsl     eax, dword ptr selector
    or      eax,eax
    jz      rd_fail

    inc     eax
    mov     DibSize,eax
    cCall   IGlobalAlloc,<flags,eax>
    or      ax,ax
    jz      rd_fail

    mov     hNewDib,ax

    push    ds
    pop     fs
    mov     ds,pGlobalHeap
    cCall   far_get_arena_pointer32,<selector>
    mov     OldArena,eax
    or      eax,eax
    jz      rd2
    movzx   ax, word ptr [eax].pga_selcount
    mov     cSel,ax
    cCall   far_get_arena_pointer32,<hNewDib>
    or      eax,eax
    jnz     rd5
rd2:
    cCall   IGlobalFree,<hNewDib>
    jmp     rd_fail
rd5:
    mov     NewArena,eax
    cld

    push    ds
    mov     ecx,DibSize
    mov     ax, hNewDib
    or      ax, 1
    mov     es, ax
    mov     ds, selector
    xor     esi, esi
    xor     edi, edi
    mov     eax,ecx
    shr     ecx,2           ; dwords
    rep     movs dword ptr es:[edi], dword ptr ds:[esi]
    and     eax,3
    mov     ecx,eax
    rep     movs byte ptr es:[edi], byte ptr ds:[esi]

    pop     ds

    ;; free the selector that came back with GlobalAlloc
    xor     eax,eax
    cCall   farAssociateSelector32, <hNewDib,eax>
    cCall   IFreeSelector, <hNewDib>

    ;; Map the original selector to this new block
    mov     eax,NewArena
    mov     edx,[eax].pga_address
    mov     ebx,[eax].pga_size
    dec     ebx
    mov     ax,dx
    shr     edx,16
    cCall   far_set_physical_address,<selector>
    mov     eax,NewArena
    cCall   farAssociateSelector32, <selector,eax>
    mov     cx,cSel
    mov     dx,selector
rd13:
    dec     cx
    push    bx
    push    cx
    push    dx
    cCall   SetSelectorLimit,<dx,cx,bx>
    pop     dx
    pop     cx
    pop     bx
    add     dx,DSC_LEN                      ; advance to the next selector
    jcxz    rd14
    jmp     short rd13
rd14:

    ;; Fix some values in the new arena from old arena
    mov     eax,NewArena
    mov     ebx,OldArena

    mov     ecx,dword ptr [ebx].pga_handle
    mov     dword ptr [eax].pga_handle,ecx
    mov     ecx,dword ptr [ebx].pga_count
    dec     ecx
    mov     dword ptr [eax].pga_count,ecx

    and     byte ptr [eax].pga_flags, NOT GAH_PHANTOM

    ;; Free the dib
    cCall   FreeHeapDib, <OldArena>

    ; Now check if we are operating on a local heap. If we so change the
    ; LocalNotifyDiB to LocalNotify.

    mov     edx, NewArena
    push    selector
    pop     es
    xor     edi,edi
    mov     di,word ptr es:[pLocalHeap]
    or      di,di
    jz      rd_15
    cmp     edi,ds:[edx].pga_size
    jae     rd_15                    ; Its not a local heap
    cmp     word ptr es:[di].li_sig,LOCALHEAP_SIG       ; es:li_sig == LH
    jne     rd_15
    mov     word ptr es:[di].li_notify,codeOFFSET LocalNotifyDefault
    mov     word ptr es:[di].li_notify+2,codeBase

rd_15:
    mov     eax,1
    jmp     short rd_exit

rd_fail:
    xor     eax,eax

rd_exit:
    pop     es
    pop     fs
    pop     ebx
    pop     ecx
cEnd

cProc   DibRealloc,<PUBLIC,FAR>
        parmW   Selector
        parmW   NewSize
cBegin
    SetKernelDSNRes

    push    ebx
    mov     ds,pGlobalHeap
    cCall   far_get_arena_pointer32,<Selector>
    or      eax,eax
    jz      dr20

    movzx   ebx,NewSize
    mov     ds:[eax].pga_size,bx
    add     ebx,ds:[eax].pga_address
    mov     eax,ds:[eax].pga_next
    mov     dword ptr ds:[eax].pga_address,ebx
    mov     bx,NewSize
    dec     bx
    cCall   SetSelectorLimit,<Selector,0,bx>
    mov     ax,Selector
    jmp     short drexit
dr20:
    xor     ax,ax
drexit:
    pop     ebx
cEnd


sEnd    NRESCODE


end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3ginterf.asm ===
TITLE   GINTERF - Global Memory Manager interface procedures

.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
ifdef WOW
include wow.inc
include wowkrn.inc
include vint.inc
include wowcmpat.inc

GMEMSTATUS_block        STRUC
dwLength dd ?        ;/* size in bytes of MEMORYSTATUS structure         */
dwMemoryLoad dd ?    ;/* percent of memory being used                    */
dwTotalPhys dd ?     ;/* total bytes of physical memory                  */
dwAvailPhys dd ?     ;/* unallocated bytes of physical memory            */
dwTotalPageFile dd ? ;/* total bytes of paging file                      */
dwAvailPageFile dd ? ;/* unallocated bytes of paging file                */
dwTotalVirtual dd ?  ;/* total user bytes of virtual address space       */
dwAvailVirtual dd ?  ;/* unallocated user bytes of virtual address space */
GMEMSTATUS_block        ENDS

endif
.list

.386p
include protect.inc

CheckHeap MACRO name
local   a
if KDEBUG
        extrn   CheckGlobalHeap         :near
        call    CheckGlobalHeap
        jnc     short a
        or      ax,ERR_GMEM
        xor     bx,bx
        kerror  <>,<&name: Invalid global heap>,dx,bx
a:
endif
        endm

ifdef WOW
externFP WowCursorIconOp
externFP GlobalMemoryStatus
externFP WowDdeFreeHandle

externFP FindAndReleaseDib
externNP MyGetAppWOWCompatFlags
endif

externW pStackTop
externW pStackMin
externW pStackBot

DataBegin

externB Kernel_Flags
externB fBooting
externW hGlobalHeap
externW pGlobalHeap
externW curTDB
externW loadTDB
externW hExeHead
externW WinFlags
        
GSS_SI  dw      0
GSS_DS  dw      0
GSS_RET dd      0

DataEnd


sBegin  CODE
assumes CS,CODE

if SDEBUG
externNP DebugFreeSegment
endif

externNP galloc
externNP grealloc
externNP gfree
externNP glock
externNP gunlock
externNP gfreeall
externNP galign
externNP gcompact
externNP gmovebusy
externNP gsearch
externNP genter
externNP gleave
externNP gavail
externNP glrutop
externNP glrubot
externNP glrudel
externNP glruadd
externNP gmarkfree
externNP ShrinkHeap
externNP HackCheck
        
externNP get_arena_pointer32
externNP get_physical_address
externNP pdref
externNP alloc_arena_header
externNP free_arena_header
externNP PreAllocArena
externNP MyGetAppCompatFlags
externNP DPMIProc
externW gdtdsc

if ROM
externNP GetOwner
endif

if  KDEBUG
externFP OutputDebugString

ThisIsForTurboPascal:
        db "A program has attempted an invalid selector-to-handle conversion.",13,10,"Attempting to correct this error.",13,10,0
endif

if  KDEBUG
ifndef WOW
externNP xhandle_norip
endif

ifdef ?CHECKMEM
cProc   CheckMem,<PUBLIC,NEAR>
cBegin  nogen
        or      ax,ax
        jnz     short cm_okay
        cmp     [di].hi_check,di
        je      short cm_okay
        kerror  ERR_GMEM,<GlobalAlloc or ReAlloc failed>,di,cx
        xor     ax,ax
        xor     cx,cx
        xor     dx,dx
cm_okay:
        ret
cEnd    nogen
endif
endif

cProc   GetDefOwner,<PUBLIC,NEAR>
cBegin  nogen
        CheckKernelDS   fs
        ReSetKernelDS   fs
        mov     cx,curTDB
        jcxz    xxxx
        mov     es,cx
        mov     cx,loadTDB
        jcxz    xxx
        mov     es,cx
xxx:    mov     cx,es:[TDB_PDB]
        inc     cx
xxxx:   dec     cx
        ret
        UnSetKernelDS   fs
cEnd    nogen


;-----------------------------------------------------------------------;
; gbtop                                                                 ;
;                                                                       ;
; Converts a 32-bit byte count to a 16-bit paragraph count.             ;
;                                                                       ;
; Arguments:                                                            ;
;       AX = allocation flags or -1 if called from GlobalCompact        ;
;       BX = stack address of 32-bit unsigned integer                   ;
;       DX = handle being reallocated or zero                           ;
;       DS:DI = address of GlobalInfo for global heap                   ;
;                                                                       ;
; Returns:                                                              ;
;       AX = updated allocation flags                                   ;
;       EBX = #bytes needed to contain that many bytes                  ;
;       CX = owner value to use                                         ;
;       DX = handle being reallocated or zero                           ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Dec 03, 1986 10:20:01p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   gbtop,<PUBLIC,NEAR>
cBegin nogen
        CheckKernelDS   fs
        ReSetKernelDS   fs
        mov     ebx, dword ptr ss:[bx]
        add     ebx, 15
        jc      short gbtop1
        and     bl, not 15      ; Round to 16 byte boundary
        cmp     ebx, (16*1020*1024)     ; Too big?
        jbe     short gbtop2            ;  no.
gbtop1:
        mov     ebx, 07FFFFFFFh ; Make it a ridiculous value
gbtop2:                                                 
        inc     ax
        jnz     short gbtop2a
        jmp     gbtopx          ; All done if called from GlobalCompact
gbtop2a:
        dec     ax

        mov     cx, [bp].savedCS
        push    eax
if ROM
        push    fs                      ; trashes registers!
        push    ebx
        cCall   GetOwner, <cx>
        pop     ebx
        pop     fs
        mov     si, ax
else
        cCall   get_arena_pointer32,<cx>
        mov     esi,eax
endif
        pop     eax
        
        mov     cx,hExeHead             ; CX = KERNEL exe header
        cmp     fBooting,0              ; Done booting?
        jne     short gbtop3            ; No, must be KERNEL allocating then
if ROM
        cmp     cx, si
else
        cmp     cx,ds:[esi].pga_owner   ; Is the KERNEL calling us?
endif
        je      short gbtop3            ; Yes, let him party

        and     ax,not GA_INTFLAGS      ; No, then cant use these flags
        and     al, NOT GA_ALLOCHIGH

if ROM
        mov     es, si
else
        mov     es,ds:[esi].pga_owner   ; ES -> module database
endif
        cmp     es:[di].ne_magic,NEMAGIC; Valid?
        jne     short gbtop2b           ; No

        test    es:[di].ne_flags,NENOTP ; Yes, is it an app?
        jnz     short gbtop3            ;  No, don't force it moveable
gbtop2b:
        or      al, GA_MOVEABLE         ; Force it moveable

gbtop3:
        mov     cl,GA_SEGTYPE           ; Isolate segment type bits in CL
        and     cl,al
        mov     [di].gi_cmpflags,al     ; Save flags for gcompact
        and     [di].gi_cmpflags,CMP_FLAGS
        or      [di].gi_cmpflags, COMPACT_ALLOC ; Not a call from GlobalCompact

        or      dx, dx                  ; ReAllocating?
        jnz     short gbtop4            ;  Yes, allow low
        test    al,GA_MOVEABLE          ; Is this a moveable request?
        jz      short gbtop4            ; No, then go allocate low

        test    cl,GA_DISCCODE          ; Yes, is this discardable code?
        jz      short gbtop4            ; Yes, then allocate high
        or      al,GA_ALLOCHIGH         ; No, then allocate low
        or      [di].gi_cmpflags,GA_ALLOCHIGH
        
gbtop4: 
        push    ax                      ; Under Win1.0x ANY bit in 0Fh meant
        mov     al,HE_DISCARDABLE       ;  make discardable.
        and     ah,al                   ; Under Win2.0x ONLY 01h or 0Fh means
        cmp     ah,al                   ;  discardable.
        pop     ax
        jnz     short gbtop4a
        and     ah,not HE_DISCARDABLE   ; Yes, convert to boolean value
        or      ah,GA_DISCARDABLE
gbtop4a:
gbtop4b:
        and     ah,NOT GA_SEGTYPE       ; Clear any bogus flags
        or      ah,cl                   ; Copy segment type bits
        test    ah,GA_SHAREABLE         ; Shared memory request?
        jz      GetDefOwner             ; No, default action

if ROM
        mov     cx, si                  ; the code below confuses me a little
else
        mov     cx,[bp].savedCS         ; Yes, make owner same as
        push    eax
        cCall   get_arena_pointer32,<cx>
        cmp     esi,eax
        je      short @F
        int 3
@@:
        pop     eax
        mov     cx,ds:[esi].pga_owner   ; owner of calling code segment
endif
gbtopx:
        ret
        UnSetKernelDS   fs
cEnd nogen


; The remainder of this file implements the exported interface to the
;  global memory manager.  A summary follows:

;   HANDLE      far PASCAL GlobalAlloc( WORD, DWORD );
;   HANDLE      far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
;   HANDLE      far PASCAL GlobalFree( HANDLE );
;   HANDLE      far PASCAL GlobalFreeAll( WORD );
;   char far *  far PASCAL GlobalLock( HANDLE );
;   BOOL        far PASCAL GlobalUnlock( HANDLE );
;   DWORD       far PASCAL GlobalSize( HANDLE );
;   DWORD       far PASCAL GlobalCompact( DWORD );
;   #define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )
;   HANDLE      far PASCAL GlobalHandle( WORD );
;   HANDLE      far PASCAL LockSegment( WORD );
;   HANDLE      far PASCAL UnlockSegment( WORD );


cProc   IGlobalAlloc,<PUBLIC,FAR>
        parmW   flags
        parmD   nbytes
cBegin
        GENTER32                        ; About to modify memory arena

        cCall   MyGetAppCompatFlags             ; Ignore the NODISCARD flag
        test    al, GACF_IGNORENODISCARD        ;   for selected modules
        mov     ax, flags
        jz      short @f
        call    IsKernelCalling                 ; needs caller's CS @ [bp+4]
        jz      short @f                        ; skip hack if kernel calling us
        and     al, NOT GA_NODISCARD
@@:
        xor     dx,dx                   ; No handle
        lea     bx,nbytes               ; Convert requested bytes to paragraphs
        call    gbtop                   ; ... into BX
        call    galloc
ifdef ?CHECKMEM
if KDEBUG
        call    CheckMem
endif
endif
        CheckHeap   GlobalAlloc
        GLEAVE32
if kdebug
        or      ax, ax
        jnz     @F
        push    ax
        push    bx
        mov     bx, seg_nbytes
        mov     ax, off_nbytes
        krDebugOut      <DEB_TRACE or DEB_krMemMan>, "GlobalAlloc(#bx#AX) failed for %ss2"
        pop     bx
        pop     ax
@@:
endif
cEnd

cProc   IGlobalReAlloc,<PUBLIC,FAR>
        parmW   handle
        parmD   nbytes
        parmW   rflags
cBegin
;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
        test    byte ptr handle,7
        jnz     SHORT @F
if KDEBUG
        Trace_Out "GlobalReAlloc:"
        push    seg ThisIsForTurboPascal
        push    offset ThisIsForTurboPascal
        cCall   OutputDebugString
        int     3
endif
        dec     handle
@@:

        GENTER32                ; About to modify memory arena

        cCall   MyGetAppCompatFlags             ; Ignore the NODISCARD flag
        test    al, GACF_IGNORENODISCARD        ;   for selected modules
        mov     ax, rflags
        jz      short @f
        call    IsKernelCalling                 ; needs caller's CS @ [bp+4]
        jz      short @f                        ; skip hack if kernel calling us
        and     al, NOT GA_NODISCARD
@@:

#ifdef WOW
        push    ax

	; check for suspicious dib memory
	mov     dx, handle
	call    pdref

        ; check if the obj is locked
        or      ch,ch
	jz      short gr_proceed


	; here, check for phantom flag... this might mean 
        ; it's dib sec
	test    cl, GAH_PHANTOM
	jz      short gr_proceed

	; if we are here - mem object is locked and boogie flag is set 
	; sufficient reason to check with wow32 to see if this is 
	; pesky dib section

        cCall   FindAndReleaseDib, <handle, FUN_GLOBALREALLOC>

gr_proceed:

        pop     ax
#endif
	mov     dx,handle
	; mov    ax,rflags
        lea     bx,nbytes       ; Convert requested bytes to paragraphs
        call    gbtop           ; ... into BX

        call    grealloc

gr_done:
        CheckHeap   GlobalReAlloc
        GLEAVE32
cEnd


cProc   DiscardTheWorld,<PUBLIC,NEAR>
cBegin
        GENTER32
        mov     [di].gi_cmpflags, GA_DISCCODE+COMPACT_ALLOC
        mov     edx, -1
        call    gcompact
        GLEAVE32
cEnd


;  Returns with Z flag set if ss:[bp+4] is a kernel code segment selector.
;  Uses:   DX, flags.

cProc   IsKernelCalling,<PUBLIC,NEAR>
cBegin  nogen
        mov     dx, [bp+4]                      ; CS of GlobalAlloc caller
        cmp     dx, IGROUP
        jz      @f
        cmp     dx, _NRESTEXT
        jz      @f
        cmp     dx, _MISCTEXT
@@:
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; GlobalFree                                                            ;
;                                                                       ;
; Frees the given object.  If the object lives in someone elses banks   ;
; then the argument MUST be a handle entry.                             ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   handle                                                  ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]             ;
; Added the zero'ing of ES on exit.                                     ;
;                                                                       ;
;  Sat Apr 25, 1987 10:23:13p  -by-  David N. Weise   [davidw]          ;
; Added support for EMS and added this nifty comment block.             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGlobalFree,<PUBLIC,FAR>
        parmW   handle
ifdef WOW
DsOnStack equ [bp][-2]
endif

; if you add any local params or make this nogen or something similar,
; the references to [bp][-2] to access DS on stack will need to change!

cBegin
        GENTER32                        ; About to modify memory arena
        mov     es, di                  ; We may be freeing what is in ES
        xor     ax,ax                   ; In case handle = 0.
        mov     dx,handle
        or      dx,dx
        jnz     @F
        jmp     nothing_to_free
@@:

;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
        test    dl,7
        jnz     SHORT @F
if KDEBUG
        Trace_Out "GlobalFree:"
        push    seg ThisIsForTurboPascal
        push    offset ThisIsForTurboPascal
        cCall   OutputDebugString
        int     3
endif
        dec     dx
@@:

        push    dx
        call    pdref                   ; returns dx=handle, ax=selector
        pushf                           ; save pdref Z flag return

ifdef WOW
;
;    [bp][-2] has been changed to DsOnStack
;
endif

        cmp     ax,DsOnStack            ; Are we about to free the DS on
        jz      short yup               ;  the stack and GP?
        cmp     dx,DsOnStack
        jnz     short nope
yup:    xor     dx,dx                   ; Yup, zero DS image on stack...
        mov     DsOnStack,dx
nope:
        popf                            ; flags from pdref, Z set if discarded
        pop     dx

        jz      @f                      ; discarded can be freed, but has
                                        ;   no arena pointer
        or      esi, esi                ; Handle invalid if arena ptr = 0
        jz      nothing_to_free
@@:

ifdef WOW
        or      ch,ch
        jz      short gf_checkgicon

	; here, check for phantom flag...
	test    cl, GAH_PHANTOM
	jz      gf_checkgicon

	; sufficient reason to check with wow32 to see if this is 
	; pesky dib section
        push dx ; dx is the only one that needs saving
        cCall   FindAndReleaseDib, <dx, FUN_GLOBALFREE>
        or   ax, ax             ; if true, then just bail out, else free...
        pop  dx

	jz   gf_checkgicon

        ; now call the pdref again... as dx is set to selector
        call pdref ; ret handle - also ok
        jmps gf_notdib   ; not a dib anymore...

gf_checkgicon:

endif

if KDEBUG
        test    dl, GA_FIXED
        jnz     short freeo
        or      ch,ch                   ; Debugging check for count underflow
        jz      short freeo
        pushad
        xor     bx,bx
        kerror  ERR_GMEMUNLOCK,<GlobalFree: freeing locked object>,bx,handle
        popad
freeo:
endif

ifdef WOW
    test cl, GAH_CURSORICON ; call to pdref above sets cl
                            ; Note: GAH_CURSORICON is also used for Free'ing
                            ;       Accelerators - a-craigj
    jz   gf_wowdde
    push ax                 ; save
    push bx
    push dx
    push es
    push fs                 ; fs needs saving

    push handle
    push FUN_GLOBALFREE
    call WowCursorIconOp
    or   ax, ax             ; if TRUE 'free' else 'dont free, fake success'

    pop  fs
    pop  es
    pop  dx
    pop  bx
    pop  ax                 ; restore

    jnz  gf_notglobalicon

    xor  ax, ax             ; fake success
    xor  cx, cx
    jmps nothing_to_free

gf_wowdde:
    test cl, GAH_WOWDDEFREEHANDLE
    jz   gf_noticon
    push ax
    push bx
    push dx
    push es             ; save these
    push fs

    push handle
    call WowDdeFreeHandle
    or   ax, ax             ; if TRUE 'free' else 'dont free, fake success'

    pop fs
    pop es
    pop dx
    pop bx
    pop ax

    jnz  gf_notglobalicon

    xor  ax, ax             ; fake success
    xor  cx, cx
    jmps nothing_to_free

gf_notdib:
gf_notglobalicon:
gf_noticon:
endif
        xor     cx,cx                   ; Dont check owner field
        call    gfree

nothing_to_free:
        CheckHeap   GlobalFree
    GLEAVE32

cEnd


;-----------------------------------------------------------------------;
; GlobalFreeAll                                                         ;
;                                                                       ;
; Frees all of the global objects belonging to the given owner.         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   id                                                      ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]             ;
; Added the zero'ing of ES on exit.                                     ;
;                                                                       ;
;  Sat Apr 25, 1987 10:23:13p  -by-  David N. Weise   [davidw]          ;
; Added support for EMS and added this nifty comment block.             ;
;-----------------------------------------------------------------------;

cProc   GlobalFreeAll,<PUBLIC,FAR>
        parmW   id
cBegin
        GENTER32                        ; About to modify memory arena
        mov     es, di                  ; We may be freeing what is in ES
        mov     dx,id                   ; Get id to match with
        or      dx,dx                   ; Is it zero?
        jnz     short all1                      ; No, continue
        call    GetDefOwner             ; Yes, CX = default task owner to free
        mov     dx,cx
all1:
if SDEBUG
        mov     esi,[di].phi_first      ; ES:DI points to first arena entry
        mov     cx,[di].hi_count        ; CX = #entries in the arena
all2:
        cmp     ds:[esi].pga_owner,dx
        jne     short all3
        mov     ax, ds:[esi].pga_handle
        Handle_To_Sel   al
        push    cx
        push    dx
        cCall   DebugFreeSegment,<ax,0>
        pop     dx
        pop     cx
all3:
        mov     esi,ds:[esi].pga_next   ; Move to next block
        loop    all2            ; Back for more if there (may go extra times
                                ; because of coalescing, but no great whoop)
endif
        call    gfreeall

        ; REALLY free the id selector.  MSTEST setup depends on this.

        pushf
        push    ax
        push    bx
        push    es
        push    di
        mov     di,id
        and     di,0FFF8h
        mov     es,gdtdsc
        push    es:[di]
        push    es:[di + 2]
        push    es:[di + 4]
        push    es:[di + 6]
        mov     word ptr es:[di],0
        mov     word ptr es:[di + 2],0
        mov     word ptr es:[di + 4],0
        mov     word ptr es:[di + 6],0
        mov     bx,id
        DPMICALL 000Ch
        pop     es:[di + 6]
        pop     es:[di + 4]
        pop     es:[di + 2]
        pop     es:[di]
        pop     di
        pop     es
        pop     bx
        pop     ax
        popf

gf_done:
        CheckHeap   GlobalFreeAll
        GLEAVE32
cEnd


;-----------------------------------------------------------------------;
; xhandle                                                               ;
;                                                                       ;
; Returns the handle for a global segment.                              ;
;                                                                       ;
; Arguments:                                                            ;
;       Stack = sp   -> near return return address                      ;
;               sp+2 -> far return return address of caller             ;
;               sp+6 -> segment address parameter                       ;
;                                                                       ;
; Returns:                                                              ;
;       Old DS,DI have been pushed on the stack                         ;
;                                                                       ;
;       ZF= 1 if fixed segment.                                         ;
;        AX = handle                                                    ;
;                                                                       ;
;       ZF = 0                                                          ;
;        AX = handle                                                    ;
;        BX = pointer to handle table entry                             ;
;        CX = flags and count word from handle table                    ;
;        DX = segment address                                           ;
;        ES:DI = arena header of object                                 ;
;        DS:DI = master object segment address                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0 if invalid segment address                               ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Oct 16, 1986 02:40:08p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   xhandle,<PUBLIC,NEAR>
cBegin nogen
        pop     dx                      ; Get near return address
        mov     bx,sp                   ; Get seg parameter from stack
        mov     ax,ss:[bx+4]
        cmp     ax,-1                   ; Is it -1?
        jnz     short xh1
        mov     ax,ds                   ; Yes, use callers DS
xh1:    inc     bp
        push    bp
        mov     bp,sp
        push    ds                      ; Save DS:DI
        push    edi
        push    esi
        SetKernelDS     FS
        mov     ds,pGlobalHeap          ; Point to master object
        xor     edi,edi
        inc     [di].gi_lrulock
        push    dx
        mov     dx,ax
        call    pdref
        xchg    dx,ax                   ; get seg address in DX
        jz      short xhandle_ret               ; invalid or discarded handle
        test    al, GA_FIXED
        jnz     short xhandle_fixed
        or      ax, ax
        jmps    xhandle_ret
xhandle_fixed:
        xor     bx, bx                  ; Set ZF
xhandle_ret:
        ret
        UnSetKernelDS   FS
cEnd nogen


cProc   GlobalHandleNorip,<PUBLIC,FAR>
;       parmW   seg
cBegin  nogen

ifdef WOW
        call    xhandle
else
if  KDEBUG
        call    xhandle_norip
else    ; !WOW
        call    xhandle
endif
endif   ; !WOW

        mov     ebx, esi
        jmp     xhandlex
cEnd    nogen   


cProc   IGlobalHandle,<PUBLIC,FAR>
        parmW   selector
cBegin
        cCall   MyLock,<selector>
        xchg    ax, dx
cEnd


cProc   MyLock,<PUBLIC,NEAR>
;       parmW   seg
cBegin nogen
        mov     bx, sp
        xor     ax, ax                  ; In case LAR fails
        xor     dx, dx
        lar     ax, ss:[bx+2]
        jnz     SHORT ML_End            ; LAR failed, get out
        test    ah, DSC_PRESENT
        jz      short @F

        push    ds                      ; Do quick conversion for present
        SetKernelDS                     ; selector
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   get_arena_pointer32,<ss:[bx+2]>
        or      eax, eax
        jnz     SHORT got_arena_pointer

        ;** Fix for bug #9106 and (I think) #9102
ife ROM
        ;** If we get here, it's only because get_arena_pointer failed.
        ;**     This happens with any non-heap selector.
        pop     ds
        jmp     SHORT ML_End            ;Return NULL instead of GP faulting
else
        ; in ROM, get-arena fails for ROM segments which do not have
        ; arena headers, so just assume this is the case and return the
        ; selector.
        ;
        mov     ax, ss:[bx+2]
        jmps    ml_ret
endif
got_arena_pointer:

        mov     ax, ds:[eax].pga_handle
ml_ret:
        pop     ds              
        mov     dx, ax
        Handle_To_Sel   al
ML_End:
        ret     2

@@:
        pop     ax                      ; Convert to far call for xhandle
        push    cs
        push    ax
        call    xhandle
        xchg    ax, dx
        jmp     xhandlex

cEnd nogen

cProc   ILockSegment,<PUBLIC,FAR>
;       parmW   seg
cBegin  nogen
        call    xhandle                 ; Get handle
        jnz     ls5                     ; Ignore invalid or discarded objects
        jmp     xhandlex
ls5:
        test    cl,GA_DISCARDABLE
        jz      short xhandlex
        call    glock
        jmps    xhandlex
cEnd    nogen


cProc   IGlobalFix,<PUBLIC,FAR>
;       parmW   seg
cBegin  nogen
        call    xhandle                 ; Get handle
        jz      short xhandlex          ; Ignore invalid or discarded objects
        call    glock
        jmps    xhandlex
cEnd    nogen


cProc   IUnlockSegment,<PUBLIC,FAR>
;       parmW   seg
cBegin  nogen
        call    xhandle                 ; Get handle
        jz      short xhandlex          ; Ignore invalid or discarded objects
        test    cl,GA_DISCARDABLE
        jz      short xhandlex
        call    gunlock
        jmps    xhandlex
cEnd    nogen

cProc   IGlobalUnfix,<PUBLIC,FAR>
;       parmW   seg
cBegin  nogen
        call    xhandle                 ; Get handle
        jz      short xhandlex          ; Ignore invalid or discarded objects
        call    gunlock
        jmps    xhandlex
cEnd    nogen

cProc   IGlobalSize,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle                 ; Call ghandle with handle in DX
        jnz     short gs1                       ; Continue if valid handle
        or      dx,dx
        jnz     short gs1
        xor     ax,ax                   ; Return zero if invalid handle
        jmps    xhandlex

gs1:
        or      esi, esi                ; Can't be valid if arena ptr == 0
        jz      gs2
        push    eax
        mov     eax, ds:[esi].pga_size
        shr     eax, 4
        mov     cx, ax                  ; Return number paragraphs in CX
        shr     eax, 12
        mov     dx, ax
        pop     eax
        mov     ax, word ptr ds:[esi].pga_size
        push    ds
        push    dx
        push    ax
        cCall   hackcheck,<handle>
        or      ax,ax
        jz      gsN
        pop     ax
        pop     dx
        mov     ax,04000h
        xor     dx,dx
        push    dx
        push    ax
gsN:
        pop     ax
        pop     dx
        pop     ds
        jmps    xhandlex
gs2:
        xor     ax, ax
        xor     dx, dx
        jmps    xhandlex
cEnd    nogen

cProc   IGlobalFlags,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle                 ; Call ghandle with handle in DX
        xchg    cl,ch                   ; Return lock count in low half
        mov     ax,cx                   ; Let caller do jcxz to test failure
xhandlex:
        call    gleave
        mov     es, di                  ; don't return arbitrary selector
        mov     fs, di
        pop     esi
        pop     edi
        pop     ds
        pop     bp
        dec     bp
        ret     2
cEnd    nogen

if 0

cProc   IGlobalLock,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle                 ; Call ghandle with handle in DX
        jz      short lock1                     ; Ignore invalid or discarded objects
if KDEBUG
        cmp     ch,0FFh                 ; Debugging check for count overflow
        jne     short lock0
        push    bx
        push    cx
        push    dx
        xor     cx,cx
        kerror  ERR_GMEMLOCK,<GlobalLock: Object usage count overflow>,cx,bx
        pop     dx
        pop     cx
        pop     bx
lock0:
endif
        test    cl,GA_DISCARDABLE
        jz      short lock1
        call    glock                   ; Increment lock count
lock1:
        xor     ax,ax
        mov     cx,dx
xhandlex1:
        jmp     short xhandlex
cEnd    nogen

else

cProc   IGlobalLock,<PUBLIC,FAR>,<ds>
        parmW   handle
ifdef WOW
        localW  gflags
        localW  accword
endif

cBegin
ifdef WOW
        mov     gflags,0
endif
        xor     dx, dx                  ; Assume failure
        cmp     handle, -1
        jne     short @F
        mov     handle, ds
@@:
        lar     eax, dword ptr handle
        shr     eax, 8
ifdef WOW
        mov     accword, ax
endif
        test    al, DSC_PRESENT         ; Is it present?
        jz      short GL_exit
        mov     dx, handle              ; OK, will return something
        Handle_To_Sel   dl              ; Turn parameter into a selector
ifndef WOW
        test    ah, DSC_DISCARDABLE     ; Is it discardable
        jz      short GL_exit           ;   no, Lock is a nop
endif
        SetKernelDS es
        mov     ds, pGlobalHeap
        cCall   get_arena_pointer32,<dx> ; Discardable, get its arena
        or      eax, eax                
        jz      short GL_exit           ; No arena, assume an alias
ifdef WOW
        mov     cl, ds:[eax].pga_flags
        mov     byte ptr gflags, cl
        test    accword, DSC_DISCARDABLE SHL 8
        jz      GL_exit
endif
        inc     ds:[eax].pga_count      ; Finally, do the lock
if KDEBUG
        jnz     short GL_exit           ; Rip if we overflow
        push    bx      
        mov     bx, handle
        xor     cx,cx
        kerror  ERR_GMEMLOCK,<GlobalLock: Object usage count overflow>,cx,bx
        pop     bx
endif
        UnSetKernelDS es

GL_exit:
ifdef WOW
        test    gflags, GAH_CURSORICON
        jz      GL_NotIcon
        push    dx                      ; save
        push    handle                  ; arg for CursorIconLockOp
        push    FUN_GLOBALLOCK          ; func id
        call    WowCursorIconOp
        pop     dx                      ; restore

GL_NotIcon:
endif
        xor     ax, ax
        mov     es, ax                  ; Clean out ES
        mov     cx, dx                  ; HISTORY - someone probably does a jcxz
cEnd
endif

cProc   IGlobalUnlock,<PUBLIC,FAR>,<ds>
        parmW   handle
ifdef WOW
        localW  gflags
        localW  accword
endif

cBegin
        mov     gflags,0
        cmp     handle, -1
        jne     short @F
        mov     handle, ds
@@:
;
; Does this thing have any ring bits or LDT bit?  If not, then it
; could be a selector incorrectly converted to a handle.
;
        test    byte ptr handle,7
        jnz     SHORT @F
if KDEBUG
        Trace_Out "GlobalUnlock:"
        push    seg ThisIsForTurboPascal
        push    offset ThisIsForTurboPascal
        cCall   OutputDebugString
        int     3
endif
        dec     handle
@@:
        xor     cx, cx                  ; Assume zero lock count
        lar     eax, dword ptr handle           
        shr     eax, 8
ifdef WOW
        mov     accword, ax
endif
        test    al, DSC_PRESENT         ; Is it present?
        jz      short GU_exit           ;   no, must be discarded, return 0:0
ifndef WOW
        test    ah, DSC_DISCARDABLE     ; Is it discardable
        jz      short GU_exit           ;   no, Lock is a nop
endif
        SetKernelDS es
        mov     ds, pGlobalHeap
        cCall   get_arena_pointer32,<handle> ; Discardable, get its arena
        or      eax, eax                
        jz      short GU_exit           ; No arena, assume an alias
ifdef WOW
    push cx
    mov cl,ds:[eax].pga_flags
        mov     byte ptr gflags, cl
    pop cx
        test    accword, DSC_DISCARDABLE SHL 8
        jz      GU_exit
endif
        mov     cl, ds:[eax].pga_count  ; Get current count
        dec     cl              
        cmp     cl, 0FEh
        jae     short @F
        dec     ds:[eax].pga_count      ; Finally, do the unlock
        jmps    GU_Exit         
@@:
if KDEBUG
        push    bx                      ;  then the count is wrong.
        push    dx
        mov     bx, handle
        xor     cx,cx
        kerror  ERR_GMEMUNLOCK,<GlobalUnlock: Object usage count underflow>,cx,bx
        pop     dx
        pop     bx
endif
        xor     cx, cx
        UnSetKernelDS es

GU_exit:
ifdef WOW
        test    gflags, GAH_CURSORICON
        jz      GUL_NotIcon
        push    cx                     ; save
        push    handle                 ; arg for CursorIconLockOp
        push    FUN_GLOBALUNLOCK       ;  UnLocking
        call    WowCursorIconOp
        pop     cx                     ; restore

GUL_NotIcon:
endif
        xor     ax, ax
        mov     es, ax                  ; Clean out ES
        mov     ax, cx

        ; Smalltalk V version 1.1 has a bug where they depend on dx containing
        ; the handle as it did in 3.0. Sinc STalk is a 386 only app, this is
        ; only put into the 386 kernel
        mov     dx, handle
cEnd

;-----------------------------------------------------------------------;
; GlobalWire                                                            ;
;                                                                       ;
; Locks a moveable segment and moves it down as low as possible.        ;
; This is meant for people who are going to be locking an object        ;
; for a while and wish to be polite.  It cannot work as a general       ;
; panacea, judgement is still called for in its use!                    ;
;                                                                       ;
; Arguments:                                                            ;
;       WORD    object handle                                           ;
;                                                                       ;
; Returns:                                                              ;
;       DWORD   object address                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       xhandle                                                         ;
;       gmovebusy                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Dec 03, 1986 01:07:13p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalWire,<PUBLIC,FAR>
;       parmW   handle
cBegin nogen

if KDEBUG
        push    ds
        SetKernelDS
        cmp     [fBooting], 0
        jnz     shutup
        push    bx
        mov     bx, sp
        mov     bx, ss:[bx+8]
        krDebugOut <DEB_WARN OR DEB_KrMemMan>, "GlobalWire(#BX of %BX2) (try GlobalLock)"
        pop     bx
shutup:
        pop     ds
        UnSetKernelDS
endif
        call    xhandle
        jz      short gw_done           ; Ignore invalid or discarded objects
        call    gwire                   ; Copy it low if possible
        inc     ds:[esi].pga_count      ; Lock it down.
        test    ds:[esi].pga_flags,GA_DISCCODE
        jz      short not_disccode
        call    glrudel
        and     ds:[esi].pga_flags,NOT GA_DISCCODE
not_disccode:
        mov     ax, ds:[esi].pga_handle
        Handle_To_Sel   al              ; Return address.
gw_done:
        mov     dx,ax
        xor     ax,ax                   ; Make address SEG:OFF.
        jmp     xhandlex
cEnd nogen



cProc   gwire,<PUBLIC,NEAR>
cBegin nogen
        ReSetKernelDS   fs
        or      Kernel_Flags[1],kf1_MEMORYMOVED
        push    ax                      ; Save handle
        push    cx
        test    cl,GA_DISCARDABLE
        jz      short @F
        inc     ds:[esi].pga_count      ; don't want to discard if discardable
@@:     xor     ax,ax                   ; Try to get a fixed segment.
        mov     ebx,ds:[esi].pga_size
        mov     cx,ds:[esi].pga_owner

        call    gsearch                 ; AX = segment
        pop     cx
        pop     bx                      ; Object handle.
        push    eax                     ; Return from gsearch
        cCall   get_arena_pointer32,<bx>        ; Get arena header, gsearch may
                                        ; have moved the global object!
        mov     esi,eax                 ; ESI is old block
        test    cl,GA_DISCARDABLE
        jz      short @F
        dec     ds:[esi].pga_count      ; undo lock
@@:
        pop     eax                     ; EAX is new block
        or      eax,eax
        push    bx                      ; Handle
        jz      short lock_in_place     ; Couldn't get memory.
        mov     ebx, ds:[eax].pga_address
        cmp     ebx, ds:[esi].pga_address
        jbe     short ok_to_move        ; Let's not move it up in memory!!
        cCall   PreAllocArena
        jz      short lock_in_place
        
        push    esi
        mov     esi, eax
        xor     edx, edx
        call    gmarkfree
        pop     esi
        jmp     short lock_in_place
        
ok_to_move:
        mov     edx, esi        
        mov     esi, eax
        mov     ebx,ga_next             ; This is always an exact fit.
        call    gmovebusy               ; Wire it on down.
        
lock_in_place:
        pop     bx                      ; Handle
        ret
        UnSetKernelDS   fs
cEnd nogen

;-----------------------------------------------------------------------;
; GlobalUnWire                                                          ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Sep 16, 1987 04:28:49p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalUnWire,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle
        jz      short guw_done
if 0
        mov     bx, ax
        sel_check       bx
        SetKernelDS     es
        mov     es, gdtdsc
        UnSetKernelDS   es
        test    byte ptr es:[bx+6], 10h
        jz      short guw_not_disccode
        test    byte ptr es:[bx+5], 8   ; Is it code?
        jz      short guw_not_disccode  ;  nope, no point setting it
else
        lar     ebx, eax
        shr     ebx, 8
        test    bh, DSC_DISCARDABLE
        jz      short guw_not_disccode
        test    bl, DSC_CODE_BIT        ; Is it code?
        jz      short guw_not_disccode  ;  nope, no point setting it
endif
        or      ds:[esi].pga_flags,GA_DISCCODE
        call    glruadd
guw_not_disccode:
if KDEBUG
        cmp     ch,00h                  ; Debugging check for count underflow
        jne     short unlock1
        push    bx                      ;  then the count is wrong.
        push    cx
        push    dx
        xor     cx,cx
        kerror  ERR_GMEMUNLOCK,<GlobalUnWire: Object usage count underflow>,cx,bx
        pop     dx
        pop     cx
        pop     bx
unlock1:
endif
        call    gunlock
        mov     ax, 0FFFFh      ; TRUE
        jcxz    guw_done
        inc     ax              ; FALSE
guw_done:
        jmp     xhandlex
cEnd nogen


;-----------------------------------------------------------------------;
; GlobalCompact                                                         ;
;                                                                       ;
; Compacts the global arena until a free block of the requested size    ;
; appears.  Contrary to the toolkit it ALWAYS compacts!                 ;
;                                                                       ;
; Arguments:                                                            ;
;       DWORD   minimum bytes wanted                                    ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]             ;
; Added the zero'ing of ES on exit.                                     ;
;                                                                       ;
;  Wed Dec 03, 1986 01:09:02p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   GlobalCompact,<PUBLIC,FAR>
        parmD   minBytes
        localD  DPMIbytes
cBegin
        GENTER32                        ; About to modify memory arena
        CheckHeap   GlobalCompact

        call    GetDPMIFreeSpace        ; EAX = largest free DPMI block
        and     ax, GA_MASK_BYTES
        mov     ebx, eax
        clc
        call    galign                  ; align size
        mov     eax, edx                ; EAX = aligned DPMI block
        mov     DPMIbytes, eax
        cmp     eax, minBytes           ; Q: Enough to satisfy request?
        jb      SHORT GCReallyCompact   ;    N: Really compact heap
        cmp     eax, 512*1024           ; Q: Less than 1/2 Mb of DPMI mem?
        jnb     SHORT GCWorked

GCReallyCompact:
if KDEBUG
        push    ax
        push    bx
        mov     ax, seg_minBytes
        mov     bx, off_minBytes
        krDebugOut      DEB_WARN, "%SS2 GlobalCompact(#ax#BX), discarding segments"
        pop     bx
        pop     ax
endif
        mov     ax,-1
        lea     bx,minBytes
        call    gbtop
        assumes es, nothing
        clc                             ; galign should be called with CF = 0
        call    galign
        call    gavail                  ; Returns paragraphs in DX:AX

        cmp     eax, DPMIbytes          ; Return max of gavail or DMPI free
        jae     SHORT GCWorked          ;   space
        mov     eax, DPMIbytes

GCWorked:
        mov     edx, eax
        shr     edx, 16
        mov     cx, ax
        or      cx, dx

        GLEAVE32

        pushad
        call    ShrinkHeap
        popad


cEnd

;-----------------------------------------------------------------------;
; GlobalNotify                                                          ;
;                                                                       ;
; This sets a procedure to call when a discardable segment belonging    ;
; to this task gets discarded.  The discardable object must have been   ;
; allocated with the GMEM_DISCARDABLE bit set.                          ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   NotifyProc                                              ;
;                                                                       ;
; Returns:                                                              ;
;       nothing                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,CX,DX,DI,SI,DS                                               ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,ES                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Jun 23, 1987 10:16:32p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   IGlobalNotify,<PUBLIC,FAR>

        parmD   NotifyProc
cBegin
        push    ds
        les     bx,NotifyProc       ; verify pointer
        SetKernelDS
        mov     ds,curTDB
        UnSetKernelDS
        mov     word ptr ds:[TDB_GNotifyProc][2],es
        mov     word ptr ds:[TDB_GNotifyProc][0],bx
        pop     ds
cEnd

cProc   GlobalMasterHandle,<PUBLIC,FAR>
cBegin  nogen
        push    ds
        SetKernelDS
        mov     ax,hGlobalHeap
        mov     dx,pGlobalHeap
        UnSetKernelDS
        pop     ds
        ret
cEnd    nogen


;-----------------------------------------------------------------------;
; GetTaskDS                                                             ;
;                                                                       ;
; Gets the segment of the current task's DS.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       AX = selector.                                                  ;
;       DX = selector.                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Jun 25, 1987 10:52:10p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   GetTaskDS,<PUBLIC,FAR>
cBegin nogen
        push    ds
        SetKernelDS
        mov     ds,curTDB
        UnsetKernelDS
        mov     ax,ds:[TDB_Module]
        mov     dx,ax
        pop     ds
        ret
cEnd nogen

        assumes ds,nothing
        assumes es,nothing

cProc   IGlobalLRUOldest,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle                 ; Call ghandle with handle in DX
        jz      short xhandlex2
        call    glrubot
xhandlex2:
        jmp     xhandlex
cEnd    nogen


cProc   IGlobalLRUNewest,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle                 ; Call ghandle with handle in DX
        jz      short xhandlex2
        call    glrutop
        jmp     xhandlex
cEnd    nogen


;-----------------------------------------------------------------------;
; SwitchStackTo                                                         ;
;                                                                       ;
; Switched to the given stack, and establishes the BP chain.  It also   ;
; copies the last stack arguments from the old stack to the new stack.  ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   new_ss                                                  ;
;       parmW   new_sp                                                  ;
;       parmW   stack_top                                               ;
;                                                                       ;
; Returns:                                                              ;
;       A new stack!                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,BX,CX,DX,ES                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 22, 1987 08:42:05p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;


        assumes ds,nothing
        assumes es,nothing

cProcVDO SwitchStackTo,<PUBLIC,FAR>
;       parmW   new_ss
;       parmW   new_sp
;       parmW   stack_top
cBegin  nogen

        SetKernelDS     es
        FCLI
        mov     GSS_SI,si
        mov     GSS_DS,ds
        pop     word ptr GSS_RET[0]     ; get the return address
        pop     word ptr GSS_RET[2]
        assumes es, nothing
        pop     ax                      ; stack_top
        pop     bx                      ; new_sp
        pop     dx                      ; new_ss
        mov     si,bp                   ; Calculate # of parameters on stack.
        dec     si                      ; remove DS
        dec     si
        mov     cx,si
        sub     cx,sp
        shr     cx,1
        push    bp                      ; save BP
        smov    es,ss
        mov     ds,dx                   ; new_ss
        mov     ds:[2],sp
        mov     ds:[4],ss
        mov     ds:[pStackTop],ax
        mov     ds:[pStackMin],bx
        mov     ds:[pStackBot],bx

; switch stacks

        mov     ss,dx
        mov     sp,bx
        mov     bp,bx
        xor     ax,ax
        push    ax                      ; null terminate bp chain
        jcxz    no_args
copy_args:
        dec     si
        dec     si
        push    es:[si]
        loop    copy_args
no_args:
        SetKernelDS
        mov     es,curTDB
        mov     es:[TDB_taskSS],ss
        mov     es:[TDB_taskSP],sp
        push    GSS_RET.sel
        push    GSS_RET.off             ; get the return address
        mov     si,GSS_SI
        mov     ds,GSS_DS
        FSTI
        ret

cEnd nogen

;-----------------------------------------------------------------------;
; SwitchStackBack                                                       ;
;                                                                       ;
; Switches to the stack stored at SS:[2], and restores BP.  Preserves   ;
; AX and DX so that results can be passed back from the last call.      ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       The old stack!                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       AX,DX,DI,SI,DS                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Sep 22, 1987 09:56:32p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SwitchStackBack,<PUBLIC,FAR>
cBegin nogen

        push    ds
        SetKernelDS
        FCLI
        pop     GSS_DS
        pop     GSS_RET.off             ; get the return address
        pop     GSS_RET.sel
        xor     bx,bx
        xor     cx,cx
        xchg    bx,ss:[4]
        xchg    cx,ss:[2]
        mov     ss,bx
        mov     sp,cx
        mov     es,curTDB
        mov     es:[TDB_taskSS],ss
        mov     es:[TDB_taskSP],sp
        pop     bp
        push    GSS_RET.sel
        push    GSS_RET.off             ; get the return address
        mov     ds,GSS_DS
        UnSetKernelDS
        FSTI
        ret

cEnd nogen

;-----------------------------------------------------------------------;
; GetFreeMemInfo                                                        ;
;                                                                       ;
;       Get free and unlocked pages in paging system                    ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       DX              Free pages                                      ;
;       AX              Unlocked pages                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ES                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   GetFreeMemInfo,<PUBLIC,FAR>,<di>
        localV  mem_info,30h
cBegin
        mov     ax, -1
        mov     dx, ax
        SetKernelDS es
        test    byte ptr WinFlags[1], WF1_PAGING
        jz      short gfmi_no_info
        lea     di, mem_info
        smov    es, ss
        UnSetKernelDS es
        DPMICALL 0500h               ; Get Free Memory Information
        jc      short gfmi_no_info
        mov     ax, es:[di][10h]
        mov     dx, es:[di][14h]
gfmi_no_info:   
cEnd
        

;-----------------------------------------------------------------------;
; GetFreeSpace                                                          ;
;                                                                       ;
; Calculates the current amount of free space                           ;
;                                                                       ;
; Arguments:                                                            ;
;       flags - ignored for non-EMS system                              ;
;                                                                       ;
; Returns:                                                              ;
;       DX:AX   Free space in bytes                                     ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed 26-Apr-1989 15:33:18  -by-  David N. Weise  [davidw]             ;
; Added the zero'ing of ES on exit.                                     ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   IGetFreeSpace,<PUBLIC,FAR>
        parmW   flags
cBegin
        GENTER32

        call    GetDPMIFreeSpace                ; EDX = Free DPMI heap space

        mov     esi, [di].phi_first
gfs_loop:
        mov     esi, ds:[esi].pga_next
        cmp     ds:[esi].pga_sig, GA_ENDSIG
        je      short gfs_last                  ; End of heap
        mov     ax, ds:[esi].pga_owner
        cmp     ax, GA_NOT_THERE
        je      short gfs_loop                  ; Nothing there
        or      ax, ax                          ; Free?
        jz      short gfs_include               ;   yes, include
        test    flags, 2                        ; Ignore discardable?
        jnz     short gfs_loop                  ;   yes.
        mov     bx, ds:[esi].pga_handle
        test    bl, GA_FIXED
        jnz     short gfs_loop                  ; Fixed block if odd
        cmp     ds:[esi].pga_sig, 0
        jne     short gfs_loop                  ; skip if locked
        lar     ebx, ebx
        shr     ebx, 8
        test    bh, DSC_DISCARDABLE             ; include if discardable
        jz      short gfs_loop
gfs_include:
        add     edx, ds:[esi].pga_size
        jmps    gfs_loop

gfs_last:
        test    flags, 2                        ; Ignoring discardable?
        jnz     short @F                        ;  yes, then ignore fence
        sub     edx, [di].gi_reserve            ; Subtract out that above fence
@@:
        sub     edx, 10000h                     ; Lose 64k of it for fun
        jns     short gfs_positive              ; Return zero if we
        xor     edx, edx                        ; went negative!
gfs_positive:

;
; Now check to see if this app has troubles if the value gets too huge.
; 61a8000h is 100MB
;
WOW_FREE_SPACE_CAP equ 61a8000h

        push    edx
        cCall   MyGetAppWOWCompatFlags  ; check if we need to cap it
        test    dx, WOWCF_LIMIT_MEM_FREE_SPACE SHR 16
        pop     edx
        jz      short @f

        cmp     edx, WOW_FREE_SPACE_CAP
        jb      short @f
        mov     edx, WOW_FREE_SPACE_CAP
@@:

        mov     eax, edx                        ; Return in DX:AX
        shr     edx, 16

        GLEAVE32
cEnd



;-----------------------------------------------------------------------;
; GetDPMIFreeSpace                                                      ;
;                                                                       ;
; Calculates the current amount of DPMI free space                      ;
;                                                                       ;
; Arguments:                                                            ;
;       None                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       EAX = Size of largest free block in bytes                       ;
;       EDX = Free DPMI space in bytes                                  ;
;       DI  = 0                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing
ifdef WOW
cProc   GetDPMIFreeSpace,<PUBLIC,NEAR>,<edi,esi,cx>
cBegin
        push    bp
        mov     cx, sp
        and     cx, 3                   ;prepare to align on dword
        add     cx, SIZE GMEMSTATUS_block ;length to adjust sp
        sub     sp, cx
        mov     bp, sp                  ;base pointer to structure

        mov     dwLength[bp], SIZE GMEMSTATUS_block
        cCall   GlobalMemoryStatus,<ss,bp>  ;Call NT To get Memory Info
        mov     edx,dwAvailPhys[bp]     ; if (dwAvailVirtual < dwAvailPhys +dwAvailPagefile)
        add     edx,dwAvailPageFile[bp] ;  return(dwAvailVirtual
        cmp     dwAvailVirtual[bp],edx  ; else
        ja      @f                      ;  return(dwAvailPhys +dwAvailPagefile)

        mov     edx,dwAvailVirtual[bp]
@@:
        mov     eax,dwAvailPhys[bp]     ; Not entirely accurate equivalent
                                        ; of Windows, should be OK
        add     sp, cx                  ;restore stack pointer
        pop     bp
else; NOT WOW
cProc   GetDPMIFreeSpace,<PUBLIC,NEAR>
        localV  mem_info,30h
cBegin
        xor     edx, edx                ; In case of DPMI failure
        lea     di, mem_info
        smov    es, ss
        DPMICALL 0500h               ; Get Free Memory Information
        jc      short xoredxedx

        mov     edx, dword ptr mem_info[14h]    ; Number of free pages (if not paging)
                                                
        mov     eax, dword ptr mem_info[20h]    ; Paging file size
        inc     eax
        cmp     eax, 1                          ; 0 or -1?
        jbe     short not_paging                ;  yes, no paging
        lea     edx, [eax-1]                    ;  no, paging file size in edx
;                                               
; Calculation is:
;       (Paging file size + Total physical pages)
;       - (Total linear space - Free linear space)
;

; Actually, there are two limits to total swap area. (Since Win386
; isn't a planned product, it first allocates data structures for
; linear memory, then discovers how big the page file is.)
; First, find out how many pages we have - this is the sum of
; physical pages owned by DPMI, and pages in the disk swap file.
; Next, find out how many pages are allowed for in the linear
; address data structure.  The lesser of these two values is
; the limit.  Next, subtract the already allocated pages.  This
; is found as the difference between total linear, and free linear
; space.  The final result is close to the amount of allocatable
; virtual memory.

        add     edx, dword ptr mem_info[18h]    ; Total physical pages
        cmp     edx, dword ptr mem_info[0ch]    ; Allocatable linear memory
        jl      short @F
        mov     edx, dword ptr mem_info[0ch]    ; take the smaller
@@:

        add     edx, dword ptr mem_info[1Ch]    ; Free linear space
        sub     edx, dword ptr mem_info[0Ch]    ; Total linear space

not_paging:

        mov     eax, dword ptr mem_info         ; size of largest free block

        shl     edx, 12                         ; Convert to bytes
        jns     short no_info                   ; Went negative?
        xor     edx, edx
endif: WOW
no_info:
;
; !!! HACK ALERT !!!
; We don't actually want to grab all the memory from DPMI, because then
; we won't be able to allocate DPMI memory for arena tables, if we
; need them, and WIN386 won't be able to grow the LDT.
;
        sub     edx,10000h
        ja      @F
xoredxedx:
        xor     edx,edx
@@:
        cmp     eax,edx
        jb      @F
        mov     eax,edx
@@:
        xor     di, di

cEnd


;-----------------------------------------------------------------------;
; GlobalDOSAlloc
;
; Allocates memory that is accessible by DOS.
;
; Entry:
;       parmD   nbytes          number of bytes to alloc
;
; Returns:
;       AX = memory handle
;       DX = DOS segment paragraph address
;
; History:
;  Tue 23-May-1989 11:30:57  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GlobalDOSAlloc,<PUBLIC,FAR>,<di,si>
        parmD   nbytes
cBegin
        mov     ax,GA_ALLOC_DOS shl 8
        cCall   IGlobalAlloc,<ax,nbytes>
        xor     dx, dx                  ; In case of error return
        or      ax, ax
        jz      short gda_exit
        push    ax
        cCall   get_physical_address,<ax>
REPT 4
        shr     dx, 1
        rcr     ax, 1
ENDM
        mov     dx, ax
        pop     ax
gda_exit:
cEnd

;-----------------------------------------------------------------------;
; GlobalDOSFree
;
; Frees memory allocated by GlobalDOSAlloc.
;
; Entry:
;       parmW   handle
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 23-May-1989 17:48:03  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GlobalDOSFree,<PUBLIC,FAR>,<di,si>

        parmW   handle
cBegin
        cCall   IGlobalFree,<handle>
cEnd

;-----------------------------------------------------------------------;
; GlobalPageLock
;
; Page locks the memory associated with the Handle.
;
; Entry:
;     parmW   handle
;
; Returns:
;     AX = new lock count
;
; History:
;  Wed 31-May-1989 22:14:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

      assumes ds,nothing
      assumes es,nothing

cProc IGlobalPageLock,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle
        or      ax,ax
        jz      short gpl_fail          ; Ignore invalid or discarded objects

        cmp     [esi].pga_pglock, 0FFh  ; About to overflow?
        je      short gpl_over

        push    dx
        call    gwire                   ; Move it LOW!
        pop     bx

ifndef WOW
        DPMICALL 4                   ; Page Lock it
        jc      short gpl_fail
endif

        inc     [esi].pga_count
        inc     [esi].pga_pglock
        movzx   ax, [esi].pga_pglock
        jmp     xhandlex

gpl_over:

if KDEBUG
        push    bx
        push    cx
        push    dx
        xor     cx,cx
        kerror  ERR_GMEMLOCK,<GlobalPageLock: Lock count overflow>,cx,bx
        pop     dx
        pop     cx
        pop     bx
endif

gpl_fail:
        xor     ax,ax
        jmp     xhandlex

cEnd nogen


;-----------------------------------------------------------------------;
; GlobalPageUnlock
;
; Page unlocks the memory associated with the Handle.
;
; Entry:
;     parmW   handle
;
; Returns:
;     AX = new lock count
;
; History:
;  Wed 31-May-1989 22:14:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

      assumes ds,nothing
      assumes es,nothing

cProc IGlobalPageUnlock,<PUBLIC,FAR>
;       parmW   handle
cBegin  nogen
        call    xhandle
        or      ax,ax
        jz      short gpu_fail          ; Ignore invalid or discarded objects

        cmp     [esi].pga_pglock, 0     ; About to underflow?
        je      short gpu_under

        mov     bx, dx
ifndef WOW
        DPMICALL 5
        jc      short gpu_fail
endif

        dec     [esi].pga_count
        dec     [esi].pga_pglock
        movzx   ax, [esi].pga_pglock
        jmp     xhandlex

gpu_under:

if KDEBUG
        xor     ax,ax
        push    bx
        push    cx
        push    dx
        xor     cx,cx
        kerror  ERR_GMEMUNLOCK,<GlobalPageUnlock: Lock count underflow>,cx,bx
        pop     dx
        pop     cx
        pop     bx
endif

gpu_fail:
        xor     ax, ax
        jmp     xhandlex

cEnd nogen


;
; Win95 implements GlobalSmartPageLock and GlobalSmartPageUnlock
; here in 3ginterf.asm.  These routines will page-lock the given
; global memory object only if the system is paging via DOS (as
; opposed to 32-bit Disk Access), otherwise the memory is locked
; in linear memory using GlobalFix.  Callers use these routines
; for memory which may be accessed while handling an Int 21, to
; prevent re-entering DOS.  Since we never page via Int 21, we
; simply export GlobalFix as GlobalSmartPageLock and GlobalUnfix
; as GlobalSmartPageUnlock.
;


ifdef WOW
;--------------------------------------------------------------------------;
;
; Similar to GlobalFlags
;
;--------------------------------------------------------------------------;

cProc   SetCursorIconFlag,<PUBLIC,FAR>,<ds,es,esi>
        parmW   handle
        parmW   fSet
cBegin
        SetKernelDS es
        mov     ds, pGlobalHeap
        UnSetKernelDS
        cCall   get_arena_pointer32,<handle>      ; get the owner
        or      eax,eax
        jz      sf_error

        mov     esi,eax
        mov     ax,fSet
        or      ax,ax
        jz      sf_unset
        or      ds:[esi].pga_flags, GAH_CURSORICON ;cursor, icon, or accelerator
        jmps    sf_error
sf_unset:
        and     ds:[esi].pga_flags, NOT GAH_CURSORICON
sf_error:
        xor     ax,ax
cEnd



;--------------------------------------------------------------------------;
;
; Stamp the 01h in globalarena for DDE handles. This is GAH_PHANTOM flag
; which is not used any longer.
;
;--------------------------------------------------------------------------;

cProc SetDdeHandleFlag,<PUBLIC,FAR>,<ds,es,esi>
    parmW   handle
    parmW   fSet
cBegin
    SetKernelDS es
    mov ds, pGlobalHeap
    UnSetKernelDS
    cCall   get_arena_pointer32,<handle>      ; get the owner
    or  eax,eax
    jz  sd_error

    mov esi,eax
    mov ax,fSet
        or      ax,ax
    jz  sd_unset
    or  ds:[esi].pga_flags, GAH_WOWDDEFREEHANDLE
    jmps    sd_error

sd_unset:
    and ds:[esi].pga_flags, NOT GAH_WOWDDEFREEHANDLE

sd_error:
    xor ax,ax
cEnd
endif

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\appl.inc ===
;*****************************************************************************
;*	* AppL.inc : Windows Application Fast Loader APPL structure
;*****************************************************************************

magicApplCur	EQU	'0A'		;* apploader version ("A0")

APPL	STRUC
	;* Magic value
	magicAppl	DW	?

;*	* Information filled in by Munge
	;* start of RLB info
	;* prlbCodeAppl is patched by MUNGE to point to first address
	;* will be 0 if not MUNGEd
	prlbCodeAppl	DW	?

;*	* Information filled in by Apploader
	;* address of Boot Procedure (first instance only)
	pfnBootAppl	DD	?
	;* address of Reload Procedure
	pfnReloadAppl	DD	?

;*	* Information filled in by Kernel
	;* address of pGlobalHeap
	lppsMob		DD	?
	;* address of MyAlloc() far alias
	pfnKernelAlloc	DD	?
	;* address of EntProcAddress() far alias
	pfnEntProcAddress DD	?

;*	* THE FOLLOWING ADDITIONS WERE ADDED AFTER THE Win386 release (9/15/87)

;*	* filled in by AppLoader
	pfnExitAppl	DD	?		;* exit application
						;* (i.e. last instance)

;*	* filled in by MUNGE
	cparaFixedAppl	DW	?		;* size of fixed block
	cparaPreloadAppl DW	?		;* size of preload block
	cbDgroupNonzAppl DW	?		;* real non-zero data size
	cwRlbCodeAppl	DW	?		;* size of rlbCode

;*	* THE FOLLOWING ADDITIONS WERE ADDED FOR Windows 3.0
	;* address of SetOwner() far alias
	pfnSetOwner	DD	?
 
APPL	ENDS

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\3gmemini.asm ===
include kernel.inc
include protect.inc
.list

.386p

DataBegin

externB	WinFlags
externW hGlobalHeap
externW pGlobalHeap
externW ArenaSel
externD hBmDPMI
externD FreeArenaList
externD FreeArenaCount
externD SelTableStart
externW SelTableLen
externW InitialPages

DataEnd


sBegin	INITCODE
assumes CS,CODE

externNP get_physical_address
externNP set_physical_address
externNP set_selector_address32
externNP set_selector_limit32
externNP alloc_arena_header
externNP AssociateSelector32
externNP alloc_data_sel
externNP alloc_data_sel32
externNP GrowHeap
externNP DPMIProc
externFP greserve
	 
GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = NOT GA_ALIGN_BYTES

;-----------------------------------------------------------------------;
; get_selector_address32						;
;									;
; Function to translate return of get_physical_address (DX:AX) into EAX ;
;									;
;-----------------------------------------------------------------------;
cProc	get_selector_address32,<PUBLIC,NEAR>
	parmW	selector
cBegin
	push	dx
	cCall	get_physical_address,<selector>
	shl	eax, 16
	mov	ax, dx
	ror	eax, 16
	pop	dx
cEnd

;-----------------------------------------------------------------------;
; GlobalInit								;
;									;
; Procedure to initialize the global heap.  Called with the starting	;
; and ending paragraph addresses.					;
;									;
; Arguments:								;
;	parmW	hdelta	= size (.25k) of master object			;
;	parmW	palloc	= block to mark allocated			;
;			= (ROM) Size of DS == allocated block		;
;	parmW	pstart	= first available address			;
;	parmW	pend	= last available address			;
;									;
; Returns:								;
;	AX = handle for allocated block					;
;									;
; Error Returns:							;
;									;
; Alters:								;
;	ES								;
; Calls:								;
;	ginit								;
;	hthread 							;
;	ghalloc								;
; History:								;
;									;
;  Sat Jun 20, 1987 05:55:35p  -by-  David N. Weise     [davidw]	;
; Making real EMS work with the fast boot version.			;
; 									;
;  Sun Mar 15, 1987 06:38:04p  -by-  David N. Weise	[davidw]	;
; Added support for the linked free list long ago.			;
; 									;
;  Wed Feb 18, 1987 08:09:18p  -by-  David N. Weise	[davidw]	;
; Added the initialization of the gi_alt entries.			;
; 									;
;  Mon Sep 08, 1986 07:53:41p  -by-  David N. Weise	[davidw		;
; Changed the return values so that this can be called from other than	;
; initialization code.							;
;-----------------------------------------------------------------------;

cProc	GlobalInit,<PUBLIC,NEAR>,<ds,si,di>
	parmW   hdelta
	parmW   palloc
	parmW   pstart
	parmW   pend
	localW	emspalloc
	localW	hInitMem
	localD	allocated_arena
	localW	next_block
	localW	free_hi
	localW	free_lo

cBegin
	mov	ax,palloc		; AX = block to mark allocated
	mov	bx,pstart		; BX = first available address
	mov	cx,hdelta		; CX = size (.25k) of master object
	mov	dx,pend			; DX = last available address
	call	ginit
	jc	FailGlobalInit

	SetKernelDS	es
	mov	allocated_arena,eax
	xor	edi,edi			; Initialize master object
	mov	[di].phi_first,ebx	; Fill in pointers to first and
	mov	[di].phi_last,edx	; last blocks
	mov	[di].hi_count,4		; 4 arena entries
	or	eax,eax	       	  
	jnz	short allocated_block
	mov	[di].hi_count,3		; 3 arena entries
allocated_block:	       	  
	mov	[di].gi_lruchain,edi	; Nothing in LRU list so far
	mov	[di].gi_lrucount,di
	mov	[di].gi_lrulock,di	; ...and not locked
	mov	[di].gi_reserve,edi	; No discardable code reserve area yet
	push	eax
	mov	eax, ds:[edx.pga_address]
	mov	word ptr [di].gi_disfence,ax	; gi_disfence = hi_last
	shr	eax, 16
	mov	word ptr [di].gi_disfence_hi,ax
	pop	eax

	mov	[di].gi_alt_first,-1	; Fill in pointers to first and
	mov	[di].gi_alt_last,-1	;  last blocks, the -1 is necessary!!
	mov	[di].gi_alt_count,di	; # of arena entries
	mov	[di].gi_alt_lruchain,di
	mov	[di].gi_alt_lrucount,di	; MUST be 0!
	mov	[di].gi_alt_free_count,di
	mov	[di].gi_alt_reserve,di
	mov	[di].gi_alt_disfence,di
	mov	[di].gi_alt_pPhantom,-1	; MUST be -1!

	mov	ax, ds:[esi.pga_handle] ; Pick up master objects selector
	mov	hGlobalHeap,ax
	mov	ds:[esi].pga_count,0
	mov	ds:[esi].pga_selcount,1

if ROM
	mov	esi,ds:[ebx].pga_next	; in ROM, alloced == first.next
else
	mov	esi,ds:[edx].pga_prev	; Point to allocated object before
endif
	mov	bx,ds:[esi.pga_handle]
	StoH	bx			; It is moveable
	mov	ds:[esi].pga_handle,bx
	mov	hInitMem,bx
if ROM
	mov	ds:[esi].pga_count,1	; LOCKED in ROM
else
	mov	ds:[esi].pga_count,0
endif
no_allocated_object:

; initialize free list

	mov	[di].gi_free_count,1
	mov	eax,[di].phi_first
	mov	ecx,[di].phi_last

if ROM
	mov	ebx,ds:[ecx].pga_prev
else
	mov	ebx,ds:[eax].pga_next
endif
	mov	ds:[eax].pga_freeprev,-1		; Fill in first sentinal
	mov	ds:[eax].pga_freenext,ebx

	mov	ds:[ecx].pga_freeprev,ebx		; Fill in last sentinal
	mov	ds:[ecx].pga_freenext,-1

	mov	ds:[ebx].pga_freeprev,eax		; Link in free block
	mov	ds:[ebx].pga_freenext,ecx
	pushad
	SetKernelDS fs
        mov     edx, 030000h                    ; Insist on enough for fence
	call	GrowHeap
        jc      short Failed_GrowHeap           ;garage sale machine,tough luck!

                                                ; 192k (3 segs) fixed greserve
	mov	ax, 1000h			; fence it all off. (in paras)
	push	fs
	call	greserve			; greserve will triple the no.
	pop	fs
	or 	ax, ax
	stc					; assume failure
	jz	short Failed_GrowHeap

ifdef WOW
        clc
        ; WOW isn't greedy and doesn't have gcommit_block
else
        mov     esi, ds:[edi].phi_last          ; sentinel
	mov	esi, ds:[esi].pga_prev		; not_there
	mov	esi, ds:[esi].pga_prev		; free blk
	call	gcommit_block			; commit it all
	jc	short Failed_GrowHeap		; to guarantee stable system

        ; Let's start with 20MB reserve and allocate more as reqd.
	mov	edx, 20*1024*1024		; Let's get greedy
	call	GrowHeap			  
        clc                                     ; we don't care about this fail
endif
Failed_GrowHeap:
	UnSetKernelDS fs
	popad	     
	jc	short FailGlobalInit
	mov	ax,hInitMem
	clc

FailGlobalInit:
cEnd


;-----------------------------------------------------------------------;
; ginit									;
;									;
; Procedure to initialize the global heap.				;
;									;
;   The global heap looks as follows after this procedure returns:	;
;									;
;	BX - first object in arena, alway busy, zero length.		;
;	   - free object						;
;	AX - allocated object						;
;	DS - master object						;
;	DX - last object in arena, alway busy, zero length.		;
;									;
;									;
; Arguments:								;
;	AX = address of block to mark allocated.  May be zero.		;
;	   = (ROM) length of allocated block (which is DS)		;
;	BX = address of first paragraph in arena			;
;	DX = address of last  paragraph in arena			;
;	CX = initial size of master object, in bytes			;
;									;
; Returns:								;
;	AX = aligned address of block marked allocated.			;
;	BX = aligned address of first object in arena			;
;	CX = size of master object, in bytes				;
;	DX = aligned address of last object in arena			;
;	DS = aligned address of master object				;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;	DI,SI,ES							;
; Calls:								;
;	nothing								;
; History:								;
;									;
;  Thu Sep 11, 1986 04:22:02p  -by-  David N. Weise	[davidw]	;
; Commented it, made it handle the case of no allocated block correctly.;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ginit,<PUBLIC,NEAR>

	localD	size_free
	localD	size_allocated
	localD	size_master
	localD	allocated_arena
	localW	allocated_sel
	localD	BurgerMaster_arena
	localW	BurgerMaster_sel
	localD	new_last_arena

cBegin

; ESI = the first block address (sentinel, always busy)

	SetKernelDS	es
	push	ax

	cCall	get_selector_address32,<bx>	; Start of our memory
	add	eax, GA_ALIGN_BYTES		; Align our start
	and	al, GA_MASK_BYTES
	push	eax				; Save the start address
	cCall	set_selector_address32,<bx,eax>	; This will be our arena list
	mov	ArenaSel, bx
	mov	BurgerMaster_sel, bx
	mov	si, bx

	push	bx
	push	di
	xor	bx, bx				; # physical pages available
	sub	sp, 30h
	mov	di, sp
	push	es
	smov	es, ss
	DPMICALL 0500h
	pop	es
	mov	eax, 16*1024			; Size of selector table
	jc	short default_sel_table
	mov	bx, word ptr ss:[di][10h]
	cmp	bx, 256	     
	jb	short default_sel_table
     ;;;mov	eax, 31*1024
	mov	eax, 32*1024
default_sel_table:
	mov	[InitialPages], bx
; For WOW we assume 386 Kernel is running on paging System
; So always set WF1_PAGING
ifndef WOW
	mov	ecx, ss:[di][20h]		; Paging file size
	inc	ecx
	cmp	ecx, 1				; 0 or -1?
	jbe	short @F
endif
	or	byte ptr WinFlags[1], WF1_PAGING
@@:
	mov	ecx, ss:[di][0]
	shr	ecx, 7				; Bytes reserved for arenas
	add	sp, 30h
	pop	di
	pop	bx

	add	ecx, GA_ALIGN_BYTES		; Align length of arena table
	and	cl, GA_MASK_BYTES				  
	add	eax, GA_ALIGN_BYTES		; Align length of selector table
	and	al, GA_MASK_BYTES
	mov	SelTableLen, ax
	cmp	ecx, DEFAULT_ARENA_SIZE		; Number of bytes of arenas
	jae	short @F
	mov	ecx, DEFAULT_ARENA_SIZE
@@:	 
	mov	ebx, Size GlobalInfo+GA_ALIGN_BYTES
	and	bl, GA_MASK_BYTES		; EBX start of arenas
	mov	size_master, ebx
	add	ecx, ebx
	mov	SelTableStart, ecx
	add	eax, ecx			; EAX total length of segment

	push	ecx
	push	ebx
	push	eax
	push	si
	mov	cx, ax				; Make BX:CX required
	mov	ebx, eax			; length of Burgermaster
	shr	ebx, 16
	push	bx				; Save length
	push	cx
	DPMICALL 0501h
	mov	hBmDPMI[0], di			; Save DPMI handle
	mov	hBmDPMI[2], si
	pop	di				; SI:DI now length
	pop	si
	jc	Failginit
if 0
	mov	di, 4096			; Lock first page
	xor	si, si
	DPMICALL 0600h			     ; Now page lock it
	push	bx
	push	cx
	add	cx, word ptr SelTableStart 
	adc	bx, 0
	and	cx, not 4095
	DPMICALL 0600h
	pop	cx
	pop	bx
endif

	shl	ebx, 16
	mov	bx, cx				; Address in EBX
	pop	si
	pop	eax
	cCall	set_selector_address32,<si,ebx>
	mov	edi, ebx
;;;	cCall	set_selector_limit32, <si,eax>
	push	eax
	push	dx
	dec	eax
	mov	ecx, eax			; Limit in CX:DX
	shr	ecx, 16
	mov	dx, ax
	test    cx,0fff0h 	                ; bits 20-31 set?
	jz	@F				; No.
	or	dx,0fffh			; Yes, page align limit.
@@:
	mov	bx, si				; Selector in BX
	DPMICALL 8
	pop	dx
	pop	eax
	pop	ebx	
	pop	ecx
	jc	Failginit

	mov	ds, si
	sub	ecx, ebx			; Subtract out BurgerMaster
	cCall	InitialiseArenas,<ebx,ecx>
	mov	ecx, eax
	pop	esi				; Sentinel address
	cCall	alloc_arena_header,<esi>	; Sentinel
	mov	esi, eax
	cCall	alloc_arena_header,<edi>	; BurgerMaster
	mov	BurgerMaster_arena, eax
	mov	ds:[eax].pga_handle, ds		; Save selector in handle field
	mov	ds:[eax].pga_size, ecx

	push	edi
	push	ecx
	movzx	ecx, SelTableLen
	mov	edi, SelTableStart
	push	es
	smov	es, ds				; Zero this area
	UnSetKernelDS	es
	shr	ecx, 2
	xor	eax, eax
	rep	stos	dword ptr es:[edi]
	pop	es
	ReSetKernelDS	es
	pop	ecx
	pop	edi
	cCall	AssociateSelector32,<ds,BurgerMaster_Arena>	; Set back link

; EDI = the Free block address (initial free block)

ife ROM

	mov	eax, ds:[esi].pga_address
;;;	add	eax, ecx
	cCall	alloc_arena_header,<eax>
	mov	edi, eax			; Free block arena in EDI

	movzx	eax, dx				; Get linear address
	shl	eax, 4
else
	cCall	get_selector_address32, <dx>
endif

; EDX = the last block address (sentinel, always busy)

	and	al, GA_MASK_BYTES
	push	eax
	cCall	alloc_arena_header,<eax>
	mov	new_last_arena, eax	; Save it away
	pop	ebx

if ROM
	; in ROM, the alloced segment is the data segment, and we are
	; passed the length, not the address
	;
	; the length (a word) is on the stack from that very first push way
	; up there, and we want the base in eax and the length in ebx
	;
	CheckKernelDS ES
	cCall	get_selector_address32, <es>
	and	al, GA_MASK_BYTES
	xor	ebx, ebx		; clear hi word of length
	pop	bx
	add	ebx, GA_ALIGN_BYTES
	and	bl, GA_MASK_BYTES

	cCall	set_selector_limit32, <es, ebx>
else
	pop	ax			; Allocated Block
	cCall	get_selector_address32, <ax>
	and	al, GA_MASK_BYTES	; "Align" it

	sub	ebx, eax		; Length in bytes
endif

ife ROM
	push	eax
endif
	push	eax
	cCall	alloc_arena_header, <eax>
	mov	ds:[eax].pga_size, ebx	; Record size
	mov	allocated_arena, eax
	mov	ebx, eax
	pop	eax
if ROM
	CheckKernelDS	ES
	mov	allocated_sel, es
	mov	ds:[ebx.pga_handle], es
	cCall	AssociateSelector32,<es, ebx>
else
	cCall	alloc_data_sel32, <eax, ds:[ebx].pga_size>
	mov	allocated_sel, ax
	mov	ds:[ebx.pga_handle], ax	; Save selector
	cCall	AssociateSelector32,<ax,ebx>	; Set back link
endif

if ROM
	; now deal with the free one
	mov	eax, ds:[ebx].pga_address
	add	eax, ds:[ebx].pga_size
	add	eax, GA_ALIGN_BYTES
	and	al, GA_MASK_BYTES
	cCall	alloc_arena_header, <eax>
	mov	edi, eax

	cCall	get_selector_address32, <dx>
	mov	ebx, eax
else
	pop	ebx
endif
	sub	ebx, ds:[edi].pga_address	; Length in bytes
	mov	ds:[edi].pga_size, ebx

	mov	eax, allocated_arena
	mov	ecx, BurgerMaster_arena
	mov	edx, new_last_arena

; Fill in first block

	xor	ebx, ebx
	mov	ds:[esi].pga_sig,GA_SIGNATURE
	mov	ds:[esi].pga_size,ebx
	mov	ds:[esi].pga_owner,-1
	mov	ds:[esi].pga_flags,bx
	mov	ds:[esi].pga_prev,esi	; first.prev = self
if ROM
	mov	ds:[esi].pga_next,eax	; first.next = alloced (ds)
else
	mov	ds:[esi].pga_next,edi	; first.next = free
endif
	mov	ds:[esi].pga_handle,bx
	mov	ds:[esi].pga_lrunext,ebx
	mov	ds:[esi].pga_lruprev,ebx

; Fill in the last block (sentinel block)

	mov	ds:[edx].pga_sig,GA_ENDSIG
	mov	ds:[edx].pga_size,ebx
	mov	ds:[edx].pga_owner,-1	; Always allocated
	mov	ds:[edx].pga_next,edx	; last.next = self
if ROM
	mov	ds:[edx].pga_prev,edi	; last.prev = free
else
	mov	ds:[edx].pga_prev,eax	; last.prev = alloced
endif
	mov	ds:[edx].pga_flags,bx
	mov	ds:[edx].pga_handle, bx
	mov	ds:[edx].pga_lrunext,ebx
	mov	ds:[edx].pga_lruprev,ebx

; Fill in the master object

	mov	ds:[ecx].pga_next,ecx
	mov	ds:[ecx].pga_prev,ecx
	mov	ds:[ecx].pga_sig,GA_SIGNATURE
	mov	ds:[ecx].pga_owner,-3
	mov	ds:[ecx].pga_flags,bx
	mov	ds:[ecx].pga_lruprev,ebx
	mov	ds:[ecx].pga_lrunext,ebx

; Fill in the allocated block

if ROM
	mov	ds:[eax].pga_next,edi	; next = free
	mov	ds:[eax].pga_prev,esi	; prev = first
else
	mov	ds:[eax].pga_next,edx	; next object is Sentinel
	mov	ds:[eax].pga_prev,edi	; Previous object is second block
endif
	mov	ds:[eax].pga_sig,GA_SIGNATURE
	mov	ds:[eax].pga_owner,-1
	mov	ds:[eax].pga_flags,bx
	mov	ds:[eax].pga_lruprev,ebx
	mov	ds:[eax].pga_lrunext,ebx

; Fill in free block

	mov	ds:[edi].pga_sig,GA_SIGNATURE
	mov	ds:[edi].pga_owner,bx	; This is a free block
	mov	ds:[edi].pga_flags,bx
if ROM
	mov	ds:[edi].pga_next,edx	; next = last
	mov	ds:[edi].pga_prev,eax	; prev = alloced
else
	mov	ds:[edi].pga_next,eax	; Next obj allocated block
	mov	ds:[edi].pga_prev,esi
endif
	mov	ds:[edi].pga_handle,bx
	mov	ds:[edi].pga_lruprev,ebx
	mov	ds:[edi].pga_lrunext,ebx

; Initialize master object


	mov	ecx, size_master
	mov	dx,BurgerMaster_sel
	shr	ecx, 1

	push	ecx			; save size in words

	mov	pGlobalHeap,dx
	mov	es,dx
	UnSetKernelDS	es
	xor	eax,eax
	xor	di,di			; Init master object to zero
	shr	ecx, 1
	rep	stosd

	mov	ds,dx			; Switch to master object as our DS

	pop	ecx
	shl	ecx,1			; ECX = size of master object in bytes

	mov	eax, allocated_arena	; EAX = address of allocated block
	mov	edx, new_last_arena	; EDX = address of last block
	mov	ebx, esi		; EBX = address of first block
	mov	esi, BurgerMaster_arena	; ESI = arena of BurgerMaster
	clc
Failginit:
cEnd

	assumes	ds, nothing
	assumes	es, nothing

cProc	InitialiseArenas,<PUBLIC,NEAR>
	parmD	StartOffset
	parmD	BytesAllocated
cBegin
	push	ecx
	push	esi
	push	edi
	CheckKernelDS	es
	ReSetKernelDS	es
	mov	esi, StartOffset
	mov	ecx, BytesAllocated
	add	ecx, esi
	mov	FreeArenaList, esi		; Point to list
	lea	edi, [esi+size GlobalArena32]
IA_loop:
	cmp	edi, ecx
	jae	short IA_done
	mov	[esi.pga_next], edi
	add	esi, size GlobalArena32
	add	edi, size GlobalArena32
	inc	FreeArenaCount
	jmps	IA_loop
IA_done:
	mov	ds:[esi.pga_next], -1		; Terminate list
	UnSetKernelDS	es
	pop	edi
	pop	esi
	pop	ecx
cEnd

sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\atom.asm ===
title   ATOM - atom package

include kernel.inc
include gpfix.inc

MAXINTATOM = 0C000h

PRIME      = 37

ACTION_FIND = 0
ACTION_ADD  = 1
ACTION_DEL  = 2

ATOMTABLE   STRUC
at_prime        DW  ?			; Hash modulus
at_hashTable    DW  ?			; variable length array
ATOMTABLE   ENDS

ATOM    STRUC
a_chain DW  ?
a_usage DW  ?
a_len   DB  ?
a_name  DB  ?
ATOM    ENDS


externW  <pAtomTable>


externFP <LocalAlloc,LocalFree,GlobalHandle>
externNP <MyUpper>
ifdef FE_SB
externNP MyIsDBCSLeadByte
endif

sBegin MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing

;
; This procedure should be called once by each new client program.  It
; will initialize the atom table for the caller's DS and store a pointer
; to the atom table in a reserve location in the caller's DS.
; We expect return value to be in CX as well as AX.  (jcxz!)
;
cProc	InitAtomTable,<PUBLIC,FAR>
    parmW   tblSize
cBegin
	mov     ax,ds:[pAtomTable]	; Don't create if already exists
	or      ax,ax
	jnz     initdone
	mov     bx,tblSize
	or      bx,bx
	jnz     gotsize
	mov     bl,PRIME
gotsize:
	push    bx
	inc     bx			; space for table size
	shl     bx,1
	mov     ax,LA_ZEROINIT
	cCall   LocalAlloc,<ax,bx>
	pop     dx
	jcxz    initDone		; Failure
	mov     ds:[pAtomTable],ax
	mov     bx,ax
	mov     ds:[bx].at_prime,dx	; First word in hash is hash modulus
initDone:
	mov     cx,ax
cEnd

sEnd MISCCODE


sBegin  CODE

assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


labelFP <PUBLIC,DelAtom>
	mov     cl,ACTION_DEL
	db      0BBh			; mov bx,

labelVDO AddAtom
	mov     cl,ACTION_ADD
	db      0BBh    		; mov bx,

labelVDO FindAtom
	mov     cl,ACTION_FIND
	errn$   LookupAtom
;
; Common procedure to add, find or delete an atom table entry.  Called
; with a far pointer to the name string and an action code in CL register
; Works in an SS != DS environment.
;
cProc   LookupAtom,<PUBLIC,FAR>,<ds,si,di>
    parmD   pName
    localW  hName
    localB  action
cBegin
	beg_fault_trap  la_trap

	mov     [action],cl

	mov     cx,SEG_pName		; If segment value is zero
ifdef FE_SB
	or	cx,cx
	jne	@F
	jmp	haveIntAtom
@@:
else
	jcxz    haveIntAtom 		;   ...then integer atom
endif
	mov	hName,cx
	les     si,pName   		; ES:SI = pName
	cmp     byte ptr es:[si],'#'        ; Check for integer atom
	je      parseIntAtom
	xor     ax,ax
	cmp     ds:[pAtomTable],ax          ; Make sure we have an atom table
	jne     tblokay
	cCall	InitAtomTable,<ax>
	jcxz    fail1
notIntAtom:
	les     si,pName		; ES:SI = pName
tblokay:
	xor     ax,ax   		; c = 0
	xor     cx,cx   		; size = 0
	xor     dx,dx   		; hash = 0
	cld
loop1:  				; while {
	lods    byte ptr es:[si]	; c = *pName++
	or      al,al   		; if (!c) break;
	jz      xloop1
	inc     cl      		; size++
	jz      fail1   		; if (size > 255) fail
ifdef FE_SB
	call	MyIsDBCSLeadByte	; Is first of 2byte DBCS char ?
	jnc	loop1ax			; Yes.
endif
	call    MyUpper
ifdef FE_SB
	jmp	short loop1a		; go normal
loop1ax:
	mov	bx, dx			; caluculate hash value
	rol	bx, 1
	add	bx, dx
	add	bx, ax
	ror	dx, 1
	add	dx, bx
	lods	byte ptr es:[si]	; Get Next char
	or	al, al			; end of strings ?
	jz	xloop1			; yes, break;
	inc	cl			;
	jz	fail1			; (size > 255) error
endif
loop1a:
	mov     bx,dx   		; hash =
	rol     bx,1    		;   + hash << 1
	add     bx,dx   		;   + hash
	add     bx,ax   		;   + c
	ror     dx,1    		;   + hash >> 1
	add     dx,bx
	jmp     loop1   		; } end of while loop

; Here if pName points to string of the form:  #nnnn
parseIntAtom:
	inc     si      		; pName++
	xor     cx,cx   		; sum = 0
	xor	ax,ax
loop3:
	lods    byte ptr es:[si]	; c = *pName++
	or      al,al   		; if (!c) break;
	jz      xloop3
	sub     al,'0'  		; if (!isdigit(c))
	cmp     al,9
	ja      notIntAtom      	;
	imul	cx, cx, 10		; sum = (sum * 10) + (c - '0')
	add	cx, ax
	jmp     loop3
haveIntAtom:
	mov     cx,OFF_pName    	; Get integer atom
xloop3:
	jcxz    fail1
	cmp     cx,MAXINTATOM
	jae     fail1
	mov     ax,cx   		; return sum
	jmp     do_exit

fail1:
	xor     ax,ax   		; Fail, return NULL
	jmp     do_exit

xloop1:
	jcxz    fail1   		; if (size == 0) fail
	xchg    ax,dx   		; DX:AX = hash
	mov     bx,ds:[pAtomTable]
	div     ds:[bx].at_prime
	lea     bx,ds:[bx].at_hashTable     ; pp = &hashTable[ hash % PRIME ]
	shl     dx,1
	add     bx,dx
	mov     dx,cx   		; size
	mov     ax,ss   		; Setup for cmpsb
	mov     es,ax
loop2:  				; while {
	mov     si,[bx] 		; p = *pp
	or      si,si   		; if (!p) break
	jz      xloop2

	cmp     [si].a_len,dl   	; if (p->len != size)
	jne     loop2a  		;   continue
	les     di,pName		; s2 = pName
	lea     si,[si].a_name  	; s1 = &p->name
	mov     cx,dx   		; size
loop4:
	jcxz    loop4x
	dec     cx
	lodsb   			; c1 = *s1++
ifdef FE_SB
	call	MyIsDBCSLeadByte	; first byte of 2byte ?
	jc	loop4a			; No, go normal
	mov	ah, al			; save char
	mov	al, es:[di]		; get *s2
	inc	di			; s2++
	cmp	ah, al			; compare *s1, *s2
	jne	loop4x			; not same, do next strings
	jcxz	loop4x			; not necessary but case of bad strings
	dec	cx
	lodsb				; get next char ( this must be second
	mov	ah, al			; of 2byte )
	mov	al, es:[di]
	inc	di
	cmp	ah, al
	je	loop4			; same, go next char
	jmp	loop4x			; not same, go next strings
loop4a:
endif
	call    MyUpper
	mov     ah,al
	mov     al,es:[di]
	call    MyUpper
	inc     di      		; c2 = *s2++
	cmp     ah,al
	je      loop4
loop4x:
	mov     si,[bx] 		; p = *pp
	je      xloop2
loop2a:
	lea     bx,[si].a_chain 	; pp = &p->chain
	jmp     short loop2     	; } end of while loop

xloop2:
	; Dispatch on command.
	xor     cx,cx
	mov     cl,[action]
	jcxz    do_find
	errnz   ACTION_FIND
	loop    do_delete
	errnz   ACTION_ADD-1

do_add:
	or      si,si   		; NULL?
	jz      do_insert

	inc     [si].a_usage    	; Already in list. Increment reference count.
	jmp     short do_find


do_delete:
	or      si,si   		; NULL?
	jz      short do_exit   	; Return NULL for internal errors
	dec     [si].a_usage
	jg      do_delete1
	xor     di,di
	xchg    [si].a_chain,di 	; *pp = p->chain, p->chain = 0;
	mov     [bx],di
	cCall   LocalFree,<si>  	; LocalFree( p )

do_delete1:
	xor     si,si   		; p = NULL
	jmp     short do_find

do_insert:
	mov     di,bx   		; save pp
	push    dx      		; save size
	add     dx,size ATOM    	; p = LocalAlloc( sizeof( ATOM )+size )
	mov     bx,LA_ZEROINIT
	cCall   LocalAlloc,<bx,dx>          ; LocalAlloc( ZEROINIT, size )
	pop     cx      		; restore size
	mov     si,ax
	or      si,si
	jz      do_find
	mov     [di],si 		; *pp = p
	inc     [si].a_usage    	; p->usage = 1
	mov     [si].a_len,cl   	; p->len = size
	mov     bx,si
	push    ds      		; ES = DS
	pop     es
	lea     di,[si].a_name  	; strcpy( &p->name, pName )
	xor     cx,cx
	mov     cl,[si].a_len   	; CX = #bytes to move
	inc     cx      		; include terminating null
	lds     si,pName
	cld
	rep     movsb
	push    es
	pop     ds      		; Restore DS
	mov     si,bx
do_find:
	mov     ax,si   		; return p
	shr     ax,1
	shr     ax,1
	jz      do_exit
	or      ax,MAXINTATOM
	end_fault_trap
do_exit:
cEnd
la_trap:
	fault_fix_stack
	xor     ax,ax   		; return NULL/FALSE
	jmp     do_exit

cProc	IDeleteAtom,<PUBLIC,FAR>
    parmW   atom1
    regPtr  lpName,ds,bx
cBegin
	mov     bx,atom1
	cmp     bx,MAXINTATOM
	jb      freeExit
	shl     bx,2
	lea     bx,[bx].a_name
	cCall   DelAtom,<lpName>
	jmp     short freeDone
freeExit:
	xor     ax,ax
freeDone:
cEnd


cProc	IGetAtomHandle,<PUBLIC,FAR>
    parmW   atom2
cBegin
	mov     ax,atom2
	cmp     ax,MAXINTATOM
	jae	@F
	xor	ax, ax
@@:	shl     ax,2
cEnd

cProc	IGetAtomName,<PUBLIC,FAR>,<si,di>
    parmW   atom3
    parmD   pString
    parmW   maxChars
cBegin
	beg_fault_trap  getn_trap
	cld
	les     di,pString
	cmp	maxChars,0
	je	getnFail
	xor     cx,cx
	mov     byte ptr es:[di],cl
	mov     bx,atom3
	cmp     bx,MAXINTATOM
	jb      getIntAtom
	shl     bx,2

; Parameter validation - is this a pointer to a valid local allocation
; block, and is the block in use?
nfd = la_next - la_fixedsize		; given pointer to data, get
	mov	si, [bx.nfd]		; pointer to 'next' allocation
	mov	si, [si]		; p = p->prev
	and	si, not (LA_BUSY + LA_MOVEABLE)
	sub	si, bx
	cmp	si, -la_fixedsize
	jnz	getnFail
	test	word ptr [bx-la_fixedsize], LA_BUSY
	jz	getnFail

; The usage count must be >0
	cmp     [bx].a_usage,cx
	je      getnFail
; Len must be >0
	mov     cl,[bx].a_len
	jcxz    getnFail
	cmp     maxChars,cx
	jg      getnOkay
	mov     cx,maxChars
	dec     cx
getnOkay:
	lea     si,[bx].a_name
	mov     ax,cx
	rep     movsb
	mov     byte ptr es:[di],0
	jmps	getnDone

getn_trap:
	fault_fix_stack		; Yes, fault handler can be within range
getnFail:
	mov	ax, atom3
	krDebugOut DEB_WARN, "GetAtomName(#AX,...) Can't find atom"
	xor	ax, ax
	jmps	getnDone

getIntAtom:
	; When a buffer of length "n" is passed, we must reserve space for
	; the '#' character and a null terminator;
	; Fixed Bug #6143 --SANKAR-- 11-9-89
	mov	cx, maxChars
	cmp	cx, 2		; one '#' and one '\0' are a must!
	jl	getnFail	; If it is less we fail;
	sub	cx, 2		; Allow two char spaces for '#' and '\0'
	mov	maxChars, cx

	or      bx,bx
	jz      getnFail
	mov     al,'#'
	stosb
	mov     ax,bx
	mov     bx,10
	mov	cx, maxChars
	jcxz	getIntDone
getIntLoop:
	xor     dx,dx
	div     bx
	push    dx
	dec     cx
	or      ax,ax
	jz      gotIntAtom
	jcxz    gotIntAtom
	jmp     getIntLoop
gotIntAtom:
	sub     maxChars,cx
	mov     cx,maxChars
getIntChar:
	pop     ax
	add     al,'0'
	stosb
	loop    getIntChar
getIntDone:
	xor     al,al
	stosb
	mov     ax,maxChars
	inc     ax	; For the '#' Character
	end_fault_trap
getnDone:
cEnd


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\diag.asm ===
;***************************************************************************
;*  DIAG.ASM
;*
;*      Diagnostic-mode routines used to log interesting output to a log
;*      file.  Diagnostic mode is enabled/disabled through a command line
;*      switch.
;*
;*      Created by JonT starting 19 July 1991
;*
;***************************************************************************

	TITLE	LOG - Diagnostic mode logging routines

.xlist
include kernel.inc
.list

.386p


DataBegin

externD lpWindowsDir
externW cBytesWinDir
externB szDiagStart
externB szCRLF

globalW fDiagMode,0                     ;Set in LDBOOT.ASM
szLogFileName   DB      'BOOTLOG.TXT', 0
szPath          DB      128 DUP(0)      ;Entire pathname to file
IF KDEBUG
externB	szInitSpew
ENDIF

DataEnd

externFP Int21Handler
externFP OutputDebugString

;** Note that this goes in the fixed code segment
sBegin	CODE
assumes CS,CODE

;  DiagQuery
;
;       Exported entry point that can be called to determine if in
;       diagnostic mode.  Returns TRUE iff in diagnostic mode.

cProc   DiagQuery, <FAR,PUBLIC>, <si,di,ds>
cBegin
        SetKernelDS

        mov     ax,fDiagMode            ;Return the flag
cEnd


;  DiagOutput
;
;       Exported entry point to allow a string to be written to the
;       log file.  The file is flushed after writing the string
;       guaranteeing that it always gets in there in case we abort
;       immediately after the call.

cProc   DiagOutput, <FAR,PUBLIC>, <si,di,ds>
	parmD   lpstr
	localW  wHandle
cBegin
	SetKernelDS

	;** Check for diag mode
	cmp     fDiagMode,1             ;Diag mode?
	jne     SHORT DO_End            ;Nope, get out

	;** Reopen the log file
	mov     ah,3dh                  ;Create file call
	mov     al,22h                  ;R/W, Deny W to others
	mov     dx,dataOFFSET szPath    ;File name pointer
	DOSCALL
	jc      SHORT DO_Error          ;Error, get out
	mov     wHandle,ax              ;Save the handle

	;** Seek to the end
	mov     ax,4202h                ;Seek to end of file call
	mov     bx,wHandle              ;Get the file handle
	xor     cx,cx                   ;0 bytes before end of file
	xor     dx,dx
	DOSCALL
	jc      SHORT DO_Error          ;Error, get out

	;** Get the length of the string
	xor     cx,cx                   ;Get max length
	dec     cx                      ;  (0xffff)
	les     di,lpstr                ;Point to the string
	xor     al,al                   ;Zero byte
	repnz   scasb                   ;Find the zero byte
	neg     cx                      ;Get the length
	dec     cx
	dec     cx

IF KDEBUG
        ;** Spit to debug terminal in debug KERNEL
        push    cx
        push    WORD PTR lpstr[2]
        push    WORD PTR lpstr[0]
        call    OutputDebugString
	pop     cx
ENDIF

        ;** Write the string
        push    ds                      ;Save our DS
        mov     ah,40h                  ;Write file call
        mov     bx,wHandle              ;Get the handle
        lds     dx,lpstr                ;Get the buffer pointer
        UnsetKernelDS
        DOSCALL
        pop     ds
        ResetKernelDS
        jnc     SHORT DO_Close          ;No problem

DO_Error:
        mov     fDiagMode,0             ;Clear diagnostic mode and close file

        ;** Close the file
DO_Close:
        mov     bx,wHandle              ;Handle in BX
        or      bx,bx                   ;File open?
        jz      SHORT DO_End            ;Nope, just get out
        mov     ah,3eh                  ;Close file call
        DOSCALL
DO_End:

cEnd


;  DiagInit
;
;       Called from Bootstap (LDBOOT.ASM) and is used to create the log file
;       and write the startup message to it.

cProc   DiagInit, <FAR,PUBLIC>, <ds,si,di>
        localW  wHandle
cBegin
        SetKernelDS
        smov    es,ds                   ;Point to kernel DS with ES

        ;** Get the full path name
        mov     di,dataOFFSET szPath    ;Point to destination path
        mov     cx,cBytesWinDir         ;Get the length of the directory
        lds     si,lpWindowsDir         ;Point to the Windows directory
        UnsetKernelDS
        rep     movsb                   ;Copy it
        smov    ds,es                   ;Get DS back to kernel DS
        ResetKernelDS
        mov     si,dataOFFSET szLogFileName ;Point to log file name
        cmp     BYTE PTR [di - 1],'/'   ;Check for trailing separator
        je      SHORT DI_NoSeparator    ;No separator needed
        mov     al,'\'                  ;Get the other separator
        cmp     [di - 1],al             ;Check for other separator
        je      SHORT DI_NoSeparator    ;None needed
        stosb                           ;Put a '\' in
DI_NoSeparator:
        lodsb                           ;Get the char
        stosb                           ;Write it
        or      al,al                   ;Zero byte?
        jnz     DI_NoSeparator          ;No, loop for next char

IF KDEBUG
        ;** Spit to debug terminal in debug KERNEL
        push    ds
	push    dataOFFSET szInitSpew
        call    OutputDebugString       ;Spit out the message
        push    ds
        push    dataOFFSET szPath       ;Spit out log filename
        call    OutputDebugString
        push    ds
        push    dataOFFSET szCRLF       ;Write a CR/LF
        call    OutputDebugString
ENDIF

        ;** Try to open the file.  If it exists, we use it as it
        mov     ah,3dh                  ;Open file call
        xor     cx,cx                   ;Normal file
        mov     al,22h                  ;R/W, Deny W to others
        mov     dx,dataOFFSET szPath    ;File name pointer
        DOSCALL
        jc      SHORT DI_Create         ;Error, need to create file
        mov     wHandle,ax              ;Save the handle

        ;** Seek to the end
        mov     ax,4202h                ;Seek to end of file call
        mov     bx,wHandle              ;Get the file handle
        xor     cx,cx                   ;0 bytes before end of file
        xor     dx,dx
        DOSCALL
	jmps	DI_CloseIt		;Close file now

        ;** Create the log file
DI_Create:
        mov     ah,3ch                  ;Create file call
        xor     cx,cx                   ;Normal file
        mov     dx,dataOFFSET szPath    ;File name pointer
        DOSCALL
        mov     wHandle,ax              ;Save the handle

        ;** On error, disable logging
        jc      SHORT DI_End            ;Error, get out without enabling
DI_CloseIt:
        mov     fDiagMode,1             ;We're in diag mode now

        ;** Close the file (we reopen it on each call to DiagOutput)
        mov     bx,wHandle              ;Handle in BX
        mov     ah,3eh                  ;Close file call
        DOSCALL

        ;** Now start the log file
        mov     ax,dataOFFSET szDiagStart ;Point to the string
        cCall   DiagOutput, <ds,ax>     ;Start the file

DI_End:
cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\diskio.asm ===
TITLE   DISKIO

include kernel.inc

externFP Int21Handler

sBegin  CODE

ASSUMES CS,CODE

externNP	MyAnsiToOem

cProc	I_lopen,<PUBLIC,FAR>
;       parmD   lpFilename
;       parmW   mode
;	localV	OemBuffer,128
cBegin  nogen
        mov     ch,3Dh          ; Open File
	jmps	loccommon
cEnd    nogen

cProc	I_lcreat,<PUBLIC,FAR>
;	parmD   lpFilename
;	parmW   attributes
;	localV	OemBuffer,128
cBegin  nogen
        mov     ch,3Ch          ; Create File
cEnd	nogen

	errn$	loccommon

cProc	loccommon,<PUBLIC,FAR>
	parmD   lpFilename
	parmW   attributes
	localV	OemBuffer,128
cBegin

; Common code for open and creat functions. CH = function code

	push	cx
	lea	bx, OemBuffer
	cCall	MyAnsiToOem,<lpFilename,ss,bx>
	pop	cx
	mov	cl, byte ptr attributes
        mov     ax,cx
        xor     ch,ch
	smov	ds, ss
	lea	dx, OemBuffer
	DOSCALL
        jnc     lopen_ok
        mov     ax,-1
lopen_ok:
cEnd


cProc	I_lclose,<PUBLIC,FAR>
;       parmW   fd
cBegin  nogen
        mov     bx,sp
        mov     bx,ss:[bx+4]
        mov     ah,3Eh              ; DOS file close function
	DOSCALL
        mov     ax,-1
        jc      lclose_end
        inc     ax
lclose_end:
        ret     2
cEnd    nogen

cProc	I_llseek,<PUBLIC,FAR>
;   parmW   fh
;   parmD   fileOffset
;   parmW   mode
cBegin  nogen
        mov     bx,sp
        mov     dx,ss:[bx+6]
        mov     cx,ss:[bx+8]
        mov     ax,ss:[bx+4]
        mov     bx,ss:[bx+10]
        mov     ah,42h
	DOSCALL
        jnc     lseek_ok
        mov     ax,-1
        cwd                         ; must return a long
lseek_ok:
        ret     8
cEnd    nogen

cProc	I_lwrite,<PUBLIC,FAR>
;       parmW   fh
;       parmD   lpBuf
;       parmW   bufsize
cBegin  nogen
        mov     cl,40h
        jmp	short _lrw
cEnd	nogen

cProc	I_lread,<PUBLIC,FAR>
;       parmW   fh
;       parmD   lpBuf
;       parmW   bufsize
cBegin  nogen
        mov     cl,3fh
	errn$	_lrw
cEnd    nogen

; Common code for read and write functions. CL = function code
cProc	_lrw,<PUBLIC,FAR>
cBegin nogen
        mov     bx,sp
        push    ds
	mov	ah,cl			    ; read or write operation
	mov	cx,ss:[bx+4]		    ; bufSize
	lds	dx,DWORD PTR ss:[bx+6]	    ; lpBuf
	mov	bx,ss:[bx+10]		    ; fh
	DOSCALL
        pop     ds
        jnc     lwrite_ok
        mov     ax,-1
lwrite_ok:
        ret     8
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\disasm.c ===
/* disasm.c
   Future Features -

   Current bugs -
     Data32 for
       (callf  fword ptr [mem]), (jmpf  fword ptr [mem])
     Floating point insns
     Call not tested
     jecxz disassembled as large_address, not large_data
     lidt/lgdt are 6-byte operands
     segload doesn't set memXxxxx vars
     some 0x0f opcodes should set gpSafe flag
       bt, bts, btr, btc
       SetBcc [mem]
       SHD[l,r]

Usage:
  Call DisAsm86(code ptr)

  gpRegs = 0
  gpSafe = 0
  If we can continue,
	set gpSafe = 1
	if instruction is POP SEGREG
		gpRegs |= POPSEG
	else
		gpInsLen = length of instruction
		gpRegs |= regs modified (SegLoad or String)
	endif
  endif
*/

/* #include <string.h> */
#include <windows.h>	/* wsprintf() */
/* Disasm.h - definitions for Don's Tiny Disassembler */

typedef unsigned long dword;
typedef unsigned short word;
typedef unsigned char byte;


extern word memOp;	/* actual operation performed */
extern char *memName[];	/* name corresponding to memOp */
enum { memNOP, memRead, memWrite, memRMW, memSegReg, memSegMem};

extern word memSeg;	/* value of segment of memory address */
extern dword memLinear,	/* offset of operand */
  memLinear2;
extern word memSeg2,	/* duplicate of above if dual mem op */
  memSize2, memOp2,
  memDouble;		/* true if two-mem-operand instruction */

extern word memSize;	/* bytes of memory of operation */
enum { MemByte=1, MemWord=2, MemDWord=4, MemQWord=8, MemTword=10,
	Adr4, Adr6=6};

enum { memNoSeg, memES, memCS, memSS, memDS, memFS, memGS};

enum {strCX=1, strSI=2, strDI=4, segDS=8, segES=16, segFS=32, segGS=64};
extern word gpSafe,	/* 1 if may continue instruction */
  gpRegs,		/* regs which instruction modifies as side effect */
  gpStack;		/* amount stack is changed by */

#ifdef PM386
#define SHERLOCK 1
#else
#define SHERLOCK 0
#endif


#if SHERLOCK

#define STATIC /*static*/

#ifdef WOW
// Note:  The functions in this file were moved to the _MISCTEXT code segment
//        because _TEXT was exceeding the 64K segment limit   a-craigj
STATIC void InitDisAsm86(void);
STATIC byte GetByte(void);
STATIC word GetWord(void);
STATIC long GetDWord(void);
STATIC int GetImmAdr(int w);
STATIC int GetImmData(int w);
void PopSeg(int seg);
STATIC void ModRMGeneral(byte op);
STATIC void F(void);
STATIC void DisAsmF(void);
int IsPrefix(byte op0);
int FAR DisAsm86(byte far *codeParm);
#pragma alloc_text(_MISCTEXT,DisAsm86)
#pragma alloc_text(_MISCTEXT,IsPrefix)
#pragma alloc_text(_MISCTEXT,DisAsmF)
#pragma alloc_text(_MISCTEXT,F)
#pragma alloc_text(_MISCTEXT,ModRMGeneral)
#pragma alloc_text(_MISCTEXT,PopSeg)
#pragma alloc_text(_MISCTEXT,GetImmData)
#pragma alloc_text(_MISCTEXT,GetImmAdr)
#pragma alloc_text(_MISCTEXT,GetDWord)
#pragma alloc_text(_MISCTEXT,GetWord)
#pragma alloc_text(_MISCTEXT,GetByte)
#pragma alloc_text(_MISCTEXT,InitDisAsm86)
#endif

#define NO_MEM

/* int gpTrying = 0, gpEnable = 1, gpInsLen = 0; */
extern int gpTrying, gpEnable, gpInsLen;
extern word gpSafe, gpRegs, gpStack;	/* indicate side effects of instruction */

STATIC byte lookup[256] = {0};	/* lookup table for first byte of opcode */

STATIC int dataSize=0, adrSize=0,	/* flag to indicate 32 bit data/code */
   segSize=0;			/* flag if 32 bit code segment */


enum {				/* operand decoding classes */
	UNK,    /*NOOP,   BREG,   VREG,   SREG, */  BWI,    /*BRI,    WRI,*/
	SMOV,   IMOV,   /*IBYTE,  IWORD,  JMPW,   JMPB,   LEA,    JCond,
	GrpF,*/   Grp1,   Grp2,   Grp3,   Grp4,   Grp5,   /*IADR, */  MOVABS,
	RRM,    RRMW,   /*IMUL,*/   POPMEM, /*TEST,   ENTER,  FLOP,   ARPL,
	INOUT,  IWORD1, ASCII, */ XLAT,
};


#define opBase 0
STATIC struct {
/*  char *name;           /* opcode mnemonic */
  byte base, count;	/* first table entry, number of entries */
  byte operand;		/* operand class */
} ops[] = {
#define NoText(n, b, c, o) b, c, o
  NoText("?UNKNOWN", 0, 0, UNK),
  NoText("add", 0x00, 6, BWI),
  NoText("or",  0x08, 6, BWI),
/*  NoText("FGrp", 0x0f, 1, GrpF), */
  NoText("adc", 0x10, 6, BWI),
  NoText("sbb", 0x18, 6, BWI),
  NoText("and", 0x20, 6, BWI),
  NoText("sub", 0x28, 6, BWI),
  NoText("xor", 0x30, 6, BWI),
  NoText("cmp", 0x38, 6, BWI),
/*  NoText("inc", 0x40, 8, VREG),        */
/*  "dec", 0x48, 8, VREG, */
/*  NoText("push", 0x50, 8, VREG),       */
/*  "pop", 0x58, 8, VREG, */
  NoText("bound", 0x62, 1, RRMW),
/*  "arpl", 0x63, 1, ARPL, */
/*  NoText("push", 0x68, 1, IWORD),      */
/*  "imul", 0x69, 3, IMUL, */
/*  NoText("push", 0x6a, 1, IBYTE),      */
/*  "jcond", 0x70, 16, JCond, */
  NoText("Grp1", 0x80, 4, Grp1),
  NoText("test", 0x84, 2, RRM),
  NoText("xchg", 0x86, 2, RRM),
  NoText("mov", 0x88, 4, BWI),
  NoText("mov", 0x8c, 3, SMOV),
/*  NoText("lea", 0x8d, 1, LEA), */
  NoText("pop", 0x8f, 1, POPMEM),
/*  NoText("xchg", 0x90, 8, VREG), */
/*  NoText("callf", 0x9a, 1, IADR),      */
  NoText("mov", 0xa0, 4, MOVABS),
/*  NoText("test", 0xa8, 2, TEST),       */
/*  NoText("mov", 0xb0, 8, BRI), */
/*  NoText("mov", 0xb8, 8, WRI),         */
  NoText("Grp2", 0xc0, 2, Grp2),
/*  NoText("retn", 0xc2, 1, IWORD1),     */
  NoText("les", 0xc4, 1, RRMW),
  NoText("lds", 0xc5, 1, RRMW),
  NoText("mov", 0xc6, 2, IMOV),
/*  NoText("enter", 0xc8, 1, ENTER),     */
/*  NoText("retf", 0xca, 1, IWORD1), */
/*  NoText("int", 0xcd, 1, IBYTE),       */
  NoText("Grp2", 0xd0, 4, Grp2),
/*  NoText("aam", 0xd4, 1, ASCII),       */
/*  NoText("aad", 0xd5, 1, ASCII), */
  NoText("xlat", 0xd7, 1, XLAT),
/*  NoText("float", 0xd8, 8, FLOP),      */
/*  NoText("loopne", 0xe0, 1, JMPB), */
/*  NoText("loope", 0xe1, 1, JMPB),      */
/*  NoText("loop", 0xe2, 1, JMPB), */
/*  NoText("jcxz", 0xe3, 1, JMPB),       */
/*  NoText("in", 0xe4, 2, INOUT), */
/*  NoText("out", 0xe6, 2, INOUT),       */
/*  NoText("call", 0xe8, 1, JMPW), */
/*  NoText("jmp", 0xe9, 1, JMPW),        */
/*  NoText("jmpf", 0xea, 1, IADR), */
/*  NoText("jmp", 0xeb, 1, JMPB),        */
  NoText("Grp3", 0xf6, 2, Grp3),
  NoText("Grp4", 0xfe, 1, Grp4),
  NoText("Grp5", 0xff, 1, Grp5),
};
#define opCnt (sizeof(ops)/sizeof(ops[0]))

#define simpleBase (opBase + opCnt)
STATIC struct {			/* these are single byte opcodes, no decode */
  byte val;
  /* char *name; */
} simple[] = {
#define NoText2(v, n) v
/*  NoText2(0x06, "push   es"), */
  NoText2(0x07, "pop    es"),
/*  NoText2(0x0e, "push   cs"), */
/*  NoText2(0x16, "push   ss"), */
/*  NoText2(0x17, "pop    ss"), */
/*  NoText2(0x1e, "push   ds"), */
  NoText2(0x1f, "pop    ds"),
/*  NoText2(0x27, "daa"), */
/*  NoText2(0x2f, "das"), */
/*  NoText2(0x37, "aaa"), */
/*  NoText2(0x3f, "aas"), */
/*  NoText2(0x90, "nop"), */
/*  NoText2(0x9b, "wait"), */
/*  NoText2(0x9e, "sahf"), */
/*  NoText2(0x9f, "lahf"), */
/*  NoText2(0xc3, "retn"), */
/*  NoText2(0xc9, "leave"), */
/*  NoText2(0xcb, "retf"), */
/*  NoText2(0xcc, "int    3"), */
/*  NoText2(0xce, "into"), */
/*  NoText2(0xec, "in     al), dx", */
/*  NoText2(0xee, "out    dx), al", */
/*  NoText2(0xf0, "lock"), */
/*  NoText2(0xf2, "repne"), */
/*  NoText2(0xf3, "rep/repe"), */
/*  NoText2(0xf4, "hlt"), */
/*  NoText2(0xf5, "cmc"), */
/*  NoText2(0xf8, "clc"), */
/*  NoText2(0xf9, "stc"), */
/*  NoText2(0xfa, "cli"), */
/*  NoText2(0xfb, "sti"), */
/*  NoText2(0xfc, "cld"), */
/*  NoText2(0xfd, "std"), */
};
#define simpleCnt (sizeof(simple)/sizeof(simple[0]))

#define dSimpleBase (simpleBase + simpleCnt)
#if 0
STATIC struct {			/* these are simple opcodes that change */
  byte val;			/* based on current data size */
  char *name, *name32;
} dsimple[] = {
/*  0x60, "pusha", "pushad", */
/*  0x61, "popa", "popad", */
/*  0x98, "cbw", "cwde", */
/*  0x99, "cwd", "cdq", */
/*  0x9c, "pushf", "pushfd", */
/*  0x9d, "popf", "popfd", */
/*  0xcf, "iret", "iretd", */
/*  0xed, "in     ax, dx", "in    eax, dx", */
/*  0xef, "out    dx, ax", "out   dx, eax", */
};
#define dSimpleCnt (sizeof(dsimple)/sizeof(dsimple[0]))
#endif
#define dSimpleCnt 0

#define STR_S 1				/* string op, source regs */
#define STR_D 2				/* string op, dest regs */
#define STR_D_Read	4		/* string op, reads from dest regs */
#define STR_NO_COND	8		/* rep ignores flags */
#define stringOpBase (dSimpleBase+ dSimpleCnt)
STATIC struct {
  byte val;
  /* char *name; */
  byte flag;		/* should be 'next' to op, to pack nicely */
} stringOp[] = {
#define NoText3(v, n, f) v, f
  NoText3(0x6c, "ins", STR_D | STR_NO_COND),
  NoText3(0x6e, "outs", STR_S | STR_NO_COND),
  NoText3(0xa4, "movs", STR_S | STR_D | STR_NO_COND),
  NoText3(0xa6, "cmps", STR_S | STR_D | STR_D_Read),
  NoText3(0xaa, "stos", STR_D | STR_NO_COND),
  NoText3(0xac, "lods", STR_S | STR_NO_COND),
  NoText3(0xae, "scas", STR_D | STR_D_Read),
};
#define stringOpCnt (sizeof(stringOp)/sizeof(stringOp[0]))

STATIC void InitDisAsm86(void) {
  int i, j;
  for (i=0; i<opCnt; i++) {		/* Init complex entries */
    for (j=0; j<(int)ops[i].count; j++)
      lookup[ops[i].base+j] = (byte)i + opBase;
  }

  for (i=0; i<simpleCnt; i++)		/* Init simple entries */
    lookup[simple[i].val] = (byte)(i + simpleBase);

  for (i=0; i<stringOpCnt; i++)	{	/* Init string op table */
    lookup[stringOp[i].val] = (byte)(i + stringOpBase);
    lookup[stringOp[i].val+1] = (byte)(i + stringOpBase);
  }
} /* InitDisAsm86 */

STATIC byte far *code = 0;		/* this is ugly - it saves passing current */
				/* code position to all the GetByte() funcs */

#define Mid(v) (((v) >> 3) & 7)	/* extract middle 3 bits from a byte */


  /* If you don't want to return memory access info, #def NO_MEM */
#if !defined(NO_MEM)
  /* global vars set by DisAsm() to indicate current instruction's memory */
  /* access type. */
word memSeg, memSize, memOp;	/* segment value, operand size, operation */
word memSeg2, memSize2, memOp2,	/* instruction may have two memory accesses */
  memDouble;
dword memLinear, memLinear2;	/* offset from segment of access */

STATIC dword memReg, memDisp;	/* used to pass information from GetReg()... */
char *memName[] = {		/* used to convert 'enum memOp' to ascii */
  "NOP",
  "Read",
  "Write",
  "RMW",
  "MovStr",
};

#define SetMemSize(s) memSize = s
#define SetMemSeg(s) memSeg = regs[s+9]
#define SetMemOp(o) memOp = o
#define SetMemLinear(l) memLinear = l
#define SetMemSeg2(s) memSeg2 = regs[s+9]
#define SetMemOp2(o) memOp2 = o
#define SetMemLinear2(l) memLinear2 = l
#define ModMemLinear(l) memLinear += l
#define SetMemReg(r) memReg = r
#define SetMemDisp(d) memDisp = d
#define Read_RMW(o) ((o) ? memRead : memRMW)

#else

#define SetMemSeg(s)
#define SetMemSize(s)
#define StMemOp(o)
#define SetMemLinear(l)
#define SetMemSeg2(s)
#define StMemOp2(o)
#define SetMemLinear2(l)
#define ModMemLinear(l)
#define SetMemReg(r)
#define SetMemDisp(d)
#define Read_RMW(o)	0

#endif

/******************** Register Decode *******************************/
/* These helper functions return char pointers to register names.
   They are safe to call multiple times, as the return values are not
   stored in a single buffer.  The ?Reg() functions are passed a register
   number.  They mask this with 7, so you can pass in the raw opcode.
   The ?Mid() functions extract the register field from e.g. a ModRM byte.
   The Vxxx() functions look at dataSize to choose between 16 and 32 bit
   registers.  The Xxxx() functions look at the passed in W bit, and then
   the dataSize global, do decide between 8, 16, and 32 bit registers.
*/

/************************* Opcode Fetch ***************************/
  /* GetByte(), GetWord(), and GetDWord() read from the code segment */
  /* and increment the pointer appropriately.  They also add the current */
  /* value to the hexData display, and set the MemDisp global in case the */
  /* value fetched was a memory displacement */

STATIC byte GetByte(void) {             /* Read one byte from code segment */
  return *code++;
} /* GetByte */

STATIC word GetWord(void) {		/* Read two bytes from code seg */
  word w = *(word far *)code;
  code += 2;
  return w;
} /* GetWord */

STATIC long GetDWord(void) {		/* Read four bytes from code seg */
  unsigned long l = *(long far *)code;
  code += 4;
  return l;
} /* GetDWord */

#define GetImmByte() GetByte()
#define GetImmWord() GetWord()
#define GetImmDWord() GetDWord()

STATIC int GetImmAdr(int w) {		/* Get an immediate address value */
  if (!w) return GetImmByte();
  else if (!adrSize) return GetImmWord();
  return (int)GetImmDWord();
} /* GetImmAdr */

STATIC int GetImmData(int w) {	/* Get an immediate data value */
  if (!w) return GetImmByte();
  else if (!dataSize) return GetImmWord();
  return (int)GetImmDWord();
} /* GetImmData */

/************************* Helper Functions **************************/

void PopSeg(int seg) {
  gpSafe = 1;
  gpRegs = seg;
  gpStack = 1;
} /* PopSeg */

enum {
  RegAX, RegCX, RegDX, RegBX, RegSP, RegBP, RegSI, RegDI
};

  /* Based on the second byte of opcode, width flag, adrSize and dataSize, */
  /* determine the disassembly of the current instruction, and what */
  /* memory address was referenced */
  /* needinfo indicates that we need a size override on a memory operand */
  /* for example, "mov [bx], ax" is obviously a 16 bit move, while */
  /* "mov [bx], 0" could be 8, 16, or 32 bit.  We add the proper */
  /* "mov word ptr [bx], 0" information. */
  /* The 'mem' parameter indicates the kind of operation, Read, Write, RMW */

  /* don't bother trying to understand this code without an Intel manual */
  /* and assembler nearby. :-) */
STATIC void ModRMGeneral(byte op) {
  int mod = op >> 6;
  int rm = op & 7;

  if (adrSize) {			/* do 32 bit addressing */
    if (mod == 3) return; /*XReg(w, rm);	/* register operand */

    if (rm == 4) 			/* [esp+?] is special S-I-B style */
      GetByte();

    if (mod==1) GetImmAdr(0);
    else if (mod == 2) GetImmAdr(1);
  } else {				/* do 16 bit addressing */
    if (mod == 3) return;/* XReg(w, rm);	/* register operand */
    if (mod == 0 && rm == 6) 		/* [bp] becomes [mem16] */
      GetImmAdr(1);
    else if (mod) 			/* (mod3 already returned) */
      GetImmAdr(mod-1);			/* mod==1 is byte, mod==2 is (d)word */
  }
} /* ModRMGeneral */

#define ModRMInfo(op, w, mem) ModRMGeneral(op)
#define ModRM(op, w, mem) ModRMGeneral(op)

STATIC void F(void) {
  ModRMGeneral(GetByte());
  gpSafe = 1;
} /* F */

#define ModRMF(m) F()

  /* Disassemble the 386 instructions whose first opcode is 0x0f */
  /* Sorry, but this is just too ugly to comment */
STATIC void DisAsmF(void) {
  byte op0;

  op0 = GetByte();
  switch (op0 >> 4) {			/* switch on top 4 bits of opcode */
    case 0:
#if 0
      switch (op0 & 0xf) {
	case 0: /* grp6 - scary */
	case 1: /* grp7 - scary */
	case 2: /* lar */
	case 3:	/* lsl */
	default:
      }
#endif
      break;

    case 9: /* byte set on condition */
      ModRMF(memWrite);
      return;

    case 0xa:
      switch (op0 & 0xf) {
	case 0: return; /* "push	fs"; */
	case 1:
	  PopSeg(segFS);
	  return; /* "pop	fs"; */
	case 3: case 0xb:	/* bts, bt */
	  ModRMF(memRMW);
	  return;

	case 4: case 0xc:	/* shrd, shld */
	  ModRMF(memRMW);
	  GetImmData(0);
	  return;
	case 5: case 0xd:	/* shrd, shld */
	  ModRMF(memRMW);
	  return;
	case 6:			/* cmpxchg */
	  gpSafe = 1;
	  ModRM(GetByte(), 0, memRMW);
	  return;
	case 7:			/* cmpxchg */
	  ModRMF(memRMW);
	  return;
	case 8: return; /*"push	gs";*/
	case 9:
	  PopSeg(segGS);
	  return; /*"pop	gs";*/
	case 0xf:		/* imul */
	  ModRMF(memRead);
	  return;
      }
      break;

    case 0xb:
      switch (op0 & 0xf) {
	case 2:	case 4: case 5:
	  if (op0 & 2) {
	    /* "lss"*/
	  } else { /* : (op0 &1) ? "lgs" : "lfs"; */
	    ModRMF(memRead);
	  }
	  return;
	case 3: case 0xb:	/* btc, btr */
	  ModRMF(memRMW);
	  return;
	case 6: case 7: case 0xe: case 0xf:	/* movsx, movzx */
	  dataSize = 0;
	  ModRMF(memRead);
	  return;
	case 0xa:
	  ModRMF(memRMW);
	  GetImmData(0);
	  return;
	case 0xc: case 0xd:  	/* bsr, bsf */
	  ModRMF(memRead);
	  return;
      }
      break;

    case 0xc:
      if (op0 > 0xc7) {	/* bswap */
	return;
      }
      if (op0 < 0xc2) {	/* xadd */
	ModRMF(memRMW);
	return;
      }
      break;
    default:
      break;
  }
  return;
} /* DisAsmF */


int IsPrefix(byte op0) {
  switch (op0) {			/* check for prefix bytes */

#define CSEG 0x2e
#define DSEG 0x3e
#define ESEG 0x26
#define SSEG 0x36
#define FSEG 0x64
#define GSEG 0x65
#define REP 0xf3
#define REPNE 0xf2
#define DATA32 0x66
#define ADR32 0x67

    case CSEG:  SetMemSeg(memCS); break;
    case DSEG:  SetMemSeg(memDS); break;
    case ESEG:  SetMemSeg(memES); break;
    case SSEG:  SetMemSeg(memSS); break;
    case FSEG:  SetMemSeg(memFS); break;
    case GSEG:  SetMemSeg(memGS); break;
    case REP:   gpRegs |= strCX; break;
    case REPNE: gpRegs |= strCX; break;
    case ADR32: adrSize = !adrSize; break;
    case DATA32:dataSize = !dataSize; break;
    default:
      return 0;
  }
  return 1;
} /* IsPrefix */

  /* like, call this with a pointer to the instruction, it will return */
  /* the opcode bytes used in *len, and a pointer to the disassembled insn */
int FAR DisAsm86(byte far *codeParm) {
  byte far *oldcode;
  byte op0, op1;
  byte opclass;
  static int init =0;

  if (!init) {
    InitDisAsm86();
    init = 1;
  }
  adrSize = dataSize = segSize;
  gpSafe = gpRegs = gpStack = 0;
  code = oldcode = codeParm;
  do {
    op0 = GetByte();
  } while (IsPrefix(op0));
  opclass = lookup[op0];

  StMemOp(memNOP);

  if (opclass >= simpleBase) {		/* is it special */
    if (opclass >= stringOpBase) {	/* string operations? */
      char cmd;

      opclass -= stringOpBase;
      cmd = stringOp[opclass].flag;
      if (cmd & STR_S) {
	gpRegs |= strSI;
	StMemOp(memRead);
	/* DS already set */
	SetMemLinear(memReg);
	if (cmd & STR_D) {
	  gpRegs |= strDI;
	  StMemOp2(cmd & STR_D_Read ? memRead : memWrite);
	  SetMemSeg2(memES);
	  SetMemLinear2(memReg);
	  /* memDouble = 1; */
	}
      } else {
	gpRegs |= strDI;
	StMemOp(cmd & STR_D_Read ? memRead : memWrite);
	SetMemSeg(memES);
	SetMemLinear(memReg);
      }

      if (op0 & 1) {
	if (dataSize) SetMemSize(4);
	else SetMemSize(2);
      } else SetMemSize(1);

    } else if (opclass >= dSimpleBase) {
      opclass -= dSimpleBase;
    } else {
      if (op0 == 7)
	PopSeg(segES);			/* pop ES */
      else if (op0 == 0x1f)
	PopSeg(segDS);		/* pop DS */
    }
    goto DisAsmDone;
  }

  if (op0 == 0x0f) {			/* is it an extended opcode? */
    DisAsmF();
    goto DisAsmDone;
  }

  switch (ops[opclass].operand) {
    case BWI:	/* byte/word/immediate */
      gpSafe = 1;
      if (op0 & 4) {
	GetImmData(op0&1);
      } else {
	int i;
	op1 = GetByte();
	/* if ((op0 & 0xf8) == 0x38) i = memRead;
	else if ((op0 & 0xfe) == 0x88) i = memWrite;
	else Read_RMW(op0 & 2); */
	ModRM(op1, op0&1, i);
      }
      break;

    case Grp1:	/* group 1 instructions */
      gpSafe = 1;
      op1 = GetByte();
      ModRMInfo(op1, op0&1, Mid(op1) == 7 ? memRead : memRMW);
      GetImmData((op0&3)==1);
      break;

    case Grp2:	/* group 2 instructions */
      gpSafe = 1;
      op1 = GetByte();
      ModRMInfo(op1, op0&1, memRMW);
      if (!(op0 & 0x10)) GetImmData(0);
      break;

    case Grp3:	/* group 3 instructions */
      gpSafe = 1;
      op1 = GetByte();
      ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) <2 || Mid(op1) >3));
      if (Mid(op1) < 2) GetImmData(op0&1);
      break;

    case Grp4:	/* group 4 instructions */
      op1 = GetByte();
      if (Mid(op1) > 1) ;
      else {
	ModRMInfo(op1, op0&1, memRMW);
	gpSafe = 1;
      }
      break;

    case Grp5:	/* group 5 instructions */
      op1 = GetByte();
      if (Mid(op1) < 3) {
	gpSafe = 1;
	if (Mid(op1) == 2) {
	  gpStack = -1 << dataSize;
	}
      }
      ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) >= 2));
      break;

    case SMOV:	/* segment move */
      gpSafe = 1;
      op1 = GetByte();
      dataSize = 0;
      ModRM(op1, 1, Read_RMW(op0&2));
      if (op0 & 2) {			/* if moving _to_ SREG */
	switch (Mid(op1)) {
	  case 0: gpRegs = segES; break;
	  case 3: gpRegs = segDS; break;
	  case 4: gpRegs = segFS; break;
	  case 5: gpRegs = segGS; break;
	  default: gpSafe = 0;
	}
      }
      break;

    case IMOV:	/* immediate move to reg/mem */
      gpSafe = 1;
      op1 = GetByte();
      ModRMInfo(op1, op0&1, memWrite);
      GetImmData(op0&1);
      break;

    case MOVABS: /* move between accum and abs mem address */
      gpSafe = 1;
      GetImmAdr(1);
      StMemOp(op0&2 ? memWrite : memRead);
      break;

    case POPMEM:
      gpSafe = 1;
      gpStack = 1 << dataSize;
      ModRMInfo(GetByte(), 1, memWrite);
      break;

    case RRM:	/* test and xchg */
      gpSafe = 1;
      op1 = GetByte();
      ModRM(op1, op0&1, memRMW);
      break;

    case RRMW:	/* bound, les, lds */
      op1 = GetByte();
      switch (op0) {
	case 0xc4:	/* les reg, [mem] */
	  gpRegs = segES;
	  gpSafe = 1;
	  break;
	case 0xc5:	/* lds reg, [mem] */
	  gpRegs = segDS;
	  gpSafe = 1;
	  break;
      }
      ModRM(op1, 1, memRead);
      break;

    case XLAT:
      gpSafe = 1;
      StMemOp(memRead);
      break;

    default: ;
  }
DisAsmDone:
  return (int)(code - oldcode);
} /* DisAsm86 */

#endif /* SHERLOCK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\context.asm ===
page    ,132
                title   CONTEXT - task event procedures.

.xlist
include gpfix.inc
include kernel.inc
include tdb.inc
include pdb.inc
include eems.inc
ifdef WOW
include vint.inc
include wowcmpat.inc
endif
.list

externFP CloseCachedFiles
externFP Int21Handler
externFP Far_real_dos

externFP GlobalAlloc
externFP GlobalFree
externFP GlobalLock
externFP GlobalUnlock
externFP GetAppCompatFlags
ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP IGetModuleFileName
endif

DataBegin

externB Kernel_Flags
externW cpLowHeap
externW selLowHeap
externW selHighHeap
externW selWoaPdb
externB InScheduler
externB DOS_version
externB DOS_revision
externB lpszFileName
;externW pGlobalHeap
externW winVer
externW topPDB
externW cur_dos_PDB
externW Win_PDB
externW curTDB
externW WinFlags
externW FileEntrySize
externW shell_file_TDB
externD shell_file_proc
if ROM
externD pYieldProc
endif
externD ptrace_DLL_entry
externD ptrace_app_entry
externD lpfnToolHelpProc
externD dressed_for_success
IF PMODE32
externB fTaskSwitchCalled
externW LockTDB
ENDIF
DataEnd

sBegin  CODE
assumes ds,NOTHING
assumes cs,CODE

ife ROM
externD pYieldProc
endif
ifndef WOW
externNP Reschedule
externNP DeleteTask
externNP InsertTask
endif ; WOW

ifdef WOW
externFP MyGetAppWOWCompatFlagsEx
endif

ifndef WOW
;-----------------------------------------------------------------------;
; WaitEvent                                                             ;
;                                                                       ;
; If an event is waiting on taskID, suspend the current task until      ;
; an event is ready.  Returns if an event was ready and no reschedule   ;
; occured.  Otherwise returns true to indicate a reschedule has occured.;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Mar 28, 1987 05:13:50p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   WaitEvent,<PUBLIC,FAR>,<bx,ds>
        parmW   taskID
cBegin

IF PMODE32
        push    ds
        SetKernelDS
        cmp     LockTDB, 0              ;Do we have a locked task
        jne     @F                      ;Yes, we want to be able to reboot
        mov     fTaskSwitchCalled, 1    ;Tell Reboot VxD that we're scheduling
@@:
        pop     ds
ENDIF

        mov     ax,taskID
        call    GetTaskHandle0
        mov     ds,ax
        xor     ax,ax
wait_test:
        pushf
        FCLI
        dec     ds:[TDB_nEvents]
        jge     wait_exit
        mov     ds:[TDB_nEvents],0

; go uncritical

        pop     bx
        test    bh,02                   ; the interrupt flag
        jz      leave_int_off
        FSTI
leave_int_off:

        smov    es, 0
if PMODE32
    .386
        smov    fs, 0
        smov    gs, 0
    .286
endif
        push    cs
        call    Reschedule
        mov     al,-1
        jmp     wait_test

wait_exit:
        pop     bx
        test    bh,02                   ; the interrupt flag
        jz      leave_ints_off
        FSTI
leave_ints_off:

cEnd

;-----------------------------------------------------------------------;
; DirectedYield                                                         ;
;                                                                       ;
; This does a yield and attempts to yield to the specific yo-yo.        ;
; In reschedule is checked the event count of the target task, if       ;
; non-zero then that task is started.  Else the task queue is searched  ;
; as normal.                                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW yield_to                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       nothing                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Mar 28, 1987 06:14:17p  -by-  David N. Weise   [davidw]          ;
; Fixed it for aaronr.                                                  ;
;                                                                       ;
;  Fri Feb 06, 1987 00:00:11a  -by-  David N. Weise   [davidw]          ;
; Wrote it for aaronr.                                                  ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   DirectedYield,<PUBLIC,FAR>
;       parmW yield_to
cBegin nogen

        push    bp
        mov     bp,sp
        push    ax
        push    ds

; get rid of the argument on the stack

        mov     ax,[bp][2]              ; move IP up
        xchg    [bp][4],ax
        xchg    [bp][6],ax              ; move CS up
        SetKernelDS

if ROM  ;----------------------------------------------------------------

        push    pYieldProc.sel          ; safe assumption we're going to
        push    pYieldProc.off          ;   USER's yield proc

        mov     ds,curTDB
        assumes ds,nothing
        mov     ds:[TDB_Yield_to],ax

ifdef DISABLE
        cmp     ds:[TDB_QUEUE],0
        jnz     dy_away
endif
dy_OldYield:
        mov     word ptr [bp][-8],codeOffset OldYield   ; assumption incorrect
        mov     [bp][-6],cs
dy_away:
        mov     ds,[bp][-4]             ; 'pop' ds
        mov     ax,[bp][-2]             ;   .. ax ..
        mov     bp,[bp]                 ;     .. bp ..
        retf    8                       ; 'jmp' to yield proc & clear stack

else ;ROM       ---------------------------------------------------------

        mov     ds,curTDB
        assumes ds,nothing
        mov     ds:[TDB_Yield_to],ax
;
; Since this function is used by SendMessage() to switch directly
; to and from the destination app, we don't want to call USER to recieve
; any messages, since that causes unnecessary and inefficient recursion.
;
ifdef DISABLE
        cmp     ds:[TDB_QUEUE],0
        pop     ds
        pop     ax
        pop     bp
        jz      dy_OldYield
        add     sp,2                    ; waste the space
        jmp     cs:pYieldProc           ; Jump through CS VARIABLE
else
        pop     ds
        pop     ax
        pop     bp
endif

dy_OldYield:
        add     sp,2                    ; waste the space
        jmps    OldYield                ; If no task queue, do OLD Yield.

endif ;ROM      ---------------------------------------------------------
cEnd nogen


;-----------------------------------------------------------------------;
; Yield                                                                 ;
;                                                                       ;
; Does what it says.                                                    ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat May 09, 1987 12:21:13p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;                                                                       ;
;  Wed Apr 15, 1987 12:13:00p  -by-  Raymond E. Ozzie [-iris-]          ;
; Changed Yield to work for tasks that don't ever do an INITAPP, and    ;
; thus don't have a task queue.  These are presumably tasks that do     ;
; some sort of background computational activity that don't have a      ;
; window associated with them.                                          ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   Yield,<PUBLIC,FAR>
cBegin nogen

if ROM  ;----------------------------------------------------------------

        push    bp
        mov     bp,sp
        push    ds
        SetKernelDS

        push    pYieldProc.sel          ; safe assumption we're going to
        push    pYieldProc.off          ;   USER's yield proc

        mov     ds,curTDB
        assumes ds, nothing
        mov     ds:[TDB_Yield_to],0
        cmp     ds:[TDB_QUEUE],0
        jz      y_oldyield
y_away:
        mov     ds,[bp][-2]             ; 'pop' ds
        mov     bp,[bp]                 ;   .. and bp ..
        retf    4                       ; off to yield proc & clean stack

y_oldyield:
        mov     word ptr [bp][-6],codeOffset OldYield    ; bad assumption
        mov     [bp][-4],cs
        jmps    y_away

else ;ROM       ---------------------------------------------------------

        push    ds
        SetKernelDS
        mov     ds,curTDB
        assumes ds, nothing
        mov     ds:[TDB_Yield_to],0
        cmp     ds:[TDB_QUEUE],0
        pop     ds
        jz      OldYield                ; If no task queue, do OLD Yield.
        jmp     cs:pYieldProc           ; Pass to USER Jump through CS VARIABLE

endif ;ROM      ---------------------------------------------------------
cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   OldYield,<PUBLIC,FAR>,<ds>
cBegin
        SetKernelDS
        xor     ax,ax
        cmp     InScheduler,al          ; can't yield if inside scheduler
        jnz     yld3                    ; just return false
        cmp     CurTDB,0                ; did it kill itself?
        jz      @F
        mov     ds,CurTDB
        assumes ds, nothing
        inc     ds:[TDB_nEvents]

@@:     smov    es, ax
if PMODE32
    .386
        smov    fs, ax
        smov    gs, ax
    .286
endif
        push    cs
        call    Reschedule
        dec     ds:[TDB_nEvents]
        mov     ax,-1                   ; TRUE
yld3:
cEnd

endif           ; !WOW

        assumes ds, nothing
        assumes es, nothing

GetTaskHandle2:
        mov     bx,sp
        mov     ax,ss:[bx+8]
        mov     bx,ss:[bx+6]
        jmps    GetTaskHandle0
GetTaskHandle1:
        mov     bx,sp
        mov     ax,ss:[bx+6]
GetTaskHandle0:
        or      ax,ax
        jnz     gt1
        SetKernelDS     es
        mov     ax,curTDB
gt1:    mov     es,ax
        assumes es, nothing
;       cmp     es:[TDB_sig],TDB_SIGNATURE
;       jne     gt2
        ret
;gt2:   kerror  ERR_TASKID,<GetTaskHandle: Invalid task handle>
;       ret

ifndef WOW

;;
;; PostEvent( taskID ) - increment the event counter for a task.  Return
;; false if invalid task handle passed.  Otherwise return true, after
;; setting the scheduler flag that says a new task might be ready to
;; run.
;;
        assumes ds, nothing
        assumes es, nothing

cProc   PostEvent,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
        call    GetTaskHandle1
        inc     es:[TDB_nEvents]        ; indicate one more event
        ret     2
cEnd    nogen

endif           ; !WOW

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueue,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
        call    GetTaskHandle1
        mov     ax,es:[TDB_queue]
        ret     2
cEnd    nogen

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle into DS
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueueDS,<PUBLIC,FAR>
cBegin  nogen
        SetKernelDS
        mov     ds,curTDB
        assumes ds, nothing
        mov     ds,ds:[TDB_queue]
        ret
cEnd    nogen

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle into ES
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueueES,<PUBLIC,FAR>
cBegin  nogen
        SetKernelDS     es
        mov     es,curTDB
        assumes es,nothing
        mov     es,es:[TDB_queue]
        ret
cEnd    nogen

        assumes ds, nothing
        assumes es, nothing

cProc   SetTaskSignalProc,<PUBLIC,FAR>
;       parmW   taskID
;       parmD   signalProc
cBegin  nogen
        mov     bx,sp
        mov     ax,ss:[bx+8]
        call    GetTaskHandle0
        mov     ax,ss:[bx+4]
        mov     dx,ss:[bx+6]
        xchg    ax,es:[TDB_USignalProc].off
        xchg    dx,es:[TDB_USignalProc].sel
        ret     6
cEnd    nogen

;--------------------------------------------------------
;
;  Set (and Get) the Task pull model event queue handle
;
        assumes ds, nothing
        assumes es, nothing

cProc   SetTaskQueue,<PUBLIC,FAR>
;       parmW   taskID
;       parmW   hQueue
cBegin  nogen
        call    GetTaskHandle2
        mov     ax,bx
        xchg    ax,es:[TDB_queue]
        ret     4
cEnd    nogen

ifndef WOW

;--------------------------------------------------------
;
;  Set (and Get) Task Priority
;
        assumes ds, nothing
        assumes es, nothing

cProc   SetPriority,<PUBLIC,FAR>
;       parmW   taskID
;       parmW   newPri
cBegin  nogen
        call    GetTaskHandle2
        add     bl,es:[TDB_priority]
        cmp     bl,-32
        jge     stp1
        mov     bl,-32
stp1:   cmp     bl,15
        jle     stp2
        mov     bl,15
stp2:   push    bx
        mov     bh,1                    ; put at back of priority queue
        cmp     es:[TDB_priority],bl    ; SetPriority( 0 )?
        jne     stp3                    ; No, continue
        mov     ax,es                   ; Yes, is this the current task?
        push    ds
        SetKernelDS
        cmp     ax,curTDB
        pop     ds
        assumes ds, nothing
        je      stp4                    ; Yes, exit without doing anything
        mov     bh,0                    ; No, put at front of priority queue
stp3:
        add     bl,bh
        mov     es:[TDB_priority],bl
        push    bx
        push    es
        cCall   DeleteTask,<es>
        cCall   InsertTask,<ax>
        pop     es
        pop     ax
        sub     es:[TDB_priority],ah
stp4:
        pop     ax
        cbw
        ret     4
cEnd    nogen

endif ; WOW - the above code is not required in WOW

;;
;; Aaron Reynolds 7/20/87 - Added so folks like USER can ask if this is Winoldap
;;
;; IsWinoldapTask( taskID ) - Is this a Winoldap Task?
;; false if not a Winoldap task, else true
;; This works by returning the low bit in the Global Heap pointer of the task's
;; PDB. Nobody in KERNEL sets this bit (it is always initialized to 0). It is
;; up to WINOLDAP to mark its tasks by setting the low bit itself.
;;
        assumes ds, nothing
        assumes es, nothing

cProc   IsWinoldapTask,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
ifdef WOW
        xor ax, ax                      ; always return false
else
        call    GetTaskHandle1
        mov     es,es:[TDB_PDB]         ; Get PDB pointer from task handle
        mov     ax,word ptr es:[PDB_GlobalHeap] ; Get low word of Global heap ptr
        and     ax,0000000000000001B    ; Mask to low bit
endif
        ret     2
cEnd    nogen


;----------------------------------------------------------------------------;
; IsTask
;
; OLE 1.0 DLLs check whether the task they are talking to is a genuine one
; or not. This they do by calling IsTask(). So, I look for -1 as the hTask,
; which was returned from GetWindowTask() as BOGUSGDT for the 32 bit tasks
; and for the 16 bit tasks a correct value was returned.
;
; So, if we find hTask on this function as -1, we should return TRUE to
; keep OLE DLLs happy.
;
; ChandanC Feb 9th 1993.
;
;----------------------------------------------------------------------------;


; Validate a task handle
; davidds
cProc   IsTask,<PUBLIC, FAR>
;       parmW  taskID
cBegin  nogen
        mov    bx,sp
        mov    ax,ss:[bx+4]

        or      ax,ax
        jz      IT_err

ifdef WOW
        test   al, 0100b        ; Check for task aliases (see WOLE2.C) or BOGUSGDT
        jnz    task_check

task_ok:
        mov    ax, 1
        jmp    SHORT IT_exit

task_check:
endif

.286p
        lsl    bx,ax
        jnz    IT_err
        cmp    bx,size TDB
        jl     IT_err
        mov    es,ax
        cmp    es:[TDB_sig],TDB_SIGNATURE
        jne    IT_err
        jmp    short IT_exit

IT_err:
        xor    ax,ax

IT_exit:
        ret    2
cEnd    nogen

;-----------------------------------------------------------------------;
; CVW_Hack
;
; This is a little hack for the next rev of CVW.  This is a cheap
; way to break into an app just before it really starts up.  We
; call off to the ptrace DLL and then jump off to the real entry
; point.
;
; Entry:
;       none
;
; Returns:
;       none
;
; Registers Preserved:
;       all
;
; Registers Destroyed:
;
; History:
;
;  Mon 27-Feb-1989 20:22:06  -by-  David N. Weise  [davidw]
; Wrote it.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   CVW_Hack,<PUBLIC,FAR>

cBegin nogen
        sub     sp, 4
        ;** See if we should call the TOOLHELP hook first
        push    ds
        SetKernelDS
        test    Kernel_Flags[2],KF2_TOOLHELP ;TOOLHELP.DLL?
        jz      st_NoToolHelp           ;Nope
        push    ax                      ;Save regs we use
        push    cx
        push    bx

        push    Win_PDB                 ; Preserve Win_TDB across ToolHelp call
        cmp     curTDB,0
        jz      @F
        push    es
        mov     es,curTDB
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:
        mov     ax,SDM_LOADTASK
        mov     bx,WORD PTR ptrace_app_entry[0] ;Task start address in CX:DX
        mov     cx,WORD PTR ptrace_app_entry[2]

        call    lpfnToolHelpProc        ;Do it

        pop     Win_PDB

        pop     bx
        pop     cx
        pop     ax

        ;** Since we got here, we know that at least one of the two
        ;**     (WINDEBUG, TOOLHELP) or both are here.  Since we know
        ;**     TOOLHELP is here, we still need to check for WINDEBUG.
        ;**     If it's here, act as if TOOLHELP were not
        cmp     WORD PTR ptrace_DLL_entry[2],0 ;WINDEBUG present?
        jnz     st_NoToolHelp           ;Yes, give it a turn

        ;** Since we have no one else to call, simply start the task
        ;**     Stack:  AX[-2] BP[0] DS[2] RETFIP[4] RETFCS[6]
        push    bp
        mov     bp,sp
        push    ax
        mov     ax,WORD PTR ptrace_app_entry[0] ;Get the IP value
        mov     [bp + 4],ax             ;Put in place of RETFIP
        mov     ax,WORD PTR ptrace_app_entry[2] ;Get the CS value
        mov     [bp + 6],ax             ;Put in place of RETFCS
        pop     ax                      ;Clean up and start up the task
        pop     bp
        pop     ds
        retf

st_NoToolHelp:
        pop     ds
        add     sp, 4

        ;** Now call CVW's hook (WINDEBUG.DLL)
        push    ax
        push    bx
        push    cx
        push    ds
        mov     bx,ds
        SetKernelDS
        push    ptrace_app_entry.sel    ; push real app entry point
        push    ptrace_app_entry.off

        push    cs                      ; push return to return
        push    codeOffset cvwh_clever



        push    ptrace_DLL_entry.sel    ; push call into ptrace
        push    ptrace_DLL_entry.off

        push    ptrace_app_entry.sel
        push    ptrace_app_entry.off
        mov     ds,bx
        UnsetKernelDS
        mov     ax,59h
        pop     bx
        pop     cx
        retf                            ; 'call' ptrace
cvwh_clever:
        mov     bx,sp
        mov     ax,ss:[bx].10
        mov     cx,ss:[bx].06
        mov     bx,ss:[bx].08
        retf    8                       ; return to real entry point

cEnd nogen

;-----------------------------------------------------------------------;
; FileCDR_notify
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 08-Jun-1989 17:04:49  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FileCDR_notify,<PUBLIC,FAR>,<ax,bx,cx,dx,si,di,ds,es>
        localW  hHunkOMemory
        localD  lpDestFile
cBegin
        mov     hHunkOMemory, 0                 ; Handle/flag for RENAME
        mov     SEG_lpDestFile, es
        mov     OFF_lpDestFile, di
        mov     si,dx                           ; DS:SI points to [source] file
        SetKernelDS     es
        cmp     word ptr shell_file_proc[2],0
        jnz     @F
fcdr_no_exitj:
        jmp     fcdr_no_exit
@@:
        mov     di,dataOffset lpszFileName      ; Where we will copy filename
        cmp     ah, 56h                         ; RENAME?
        jne     fcdr_no_alloc

        mov     ax, 256                         ; Get enough for two filenames
        xor     bx, bx
        mov     cx, (GA_SHAREABLE SHL 8)+GA_MOVEABLE+GA_NOCOMPACT+GA_NODISCARD
        cCall   GlobalAlloc,<cx, bx, ax>
        or      ax, ax
        jz      fcdr_no_exitj
        mov     hHunkOMemory, ax
        cCall   GlobalLock,<ax>
        mov     es, dx
        UnSetKernelDS   es
        mov     di, ax
        mov     ah, 56h
fcdr_no_alloc:

        cld
        push    ax                      ; push arguments to call
        push    es
        push    di
        cmp     byte ptr ds:[si][1],':'
        jnz     nodrive
ifdef FE_SB
        mov     al, byte ptr ds:[si][0]
        call    FarMyIsDBCSLeadByte
        jnc     nodrive
endif
        lodsb
        inc     si
        or      al,20h                  ; convert to lower case
        sub     al,'a'                  ; convert to number
        jmps    gotdrive
nodrive:
        mov     ah,19h
        DOSCALL
gotdrive:
        mov     dl,al
        inc     dl
        add     al,'A'                  ; convert to ascii
        mov     ah,':'
        stosw
        mov     bx,'/' shl 8 + '\'
        mov     al,ds:[si]

        cmp     al,bh
        jz      getpath
        cmp     al,bl
        jz      getpath
        mov     al,bl
        stosb
        mov     cx,ds
        xchg    si,di
        smov    ds,es
        mov     ah,47h
        DOSCALL
        mov     ds,cx
        xchg    si,di
        xor     al,al
ifdef FE_SB
; seek pointer to final byte of path.
        xor     ah,ah                   ; flag to indicate last char is dbc
bsl_1:
        mov     al,es:[di]
        test    al,al                   ; end of string?
        jz      bsl_2                   ; jump if so
        inc     di
        xor     ah,ah
        call    FarMyIsDBCSLeadByte     ; DBC?
        jc      bsl_1                   ; jump if not
        inc     ah                      ; indicate 'DBC'
        jmp     bsl_1
bsl_2:
        test    ah,ah                   ; last char is DBC?
        jnz     getpath                 ; yes - don't test '\/'
else
        mov     cx,-1
        repnz   scasb
        dec     di
endif
        mov     al,es:[di-1]
        cmp     al,bh
        je      getpath
        cmp     al,bl
        je      getpath
        mov     al,bl
        stosb
getpath:

@@:     lodsb
        or      al,al
        stosb
        jnz     @B

        cmp     hHunkOMemory, 0
        jz      no_second_file

        lds     si, lpDestFile                  ; Tack destination file name
copy_second:                                    ; after source file name
        lodsb
        stosb
        or      al, al
        jnz     copy_second

no_second_file:
        SetKernelDS     es

if KDEBUG

        call    shell_file_proc

else    ; KDEBUG
;
; The call to shell_file_proc can blow up if the variable has not
; been updated properly, and we generate an invalid call fault.
;
        beg_fault_trap  bad_shell_file_proc

        call    shell_file_proc

        jmps    good_shell_file_proc

bad_shell_file_proc:

        fault_fix_stack
;
; If shell_file_proc has a bad non-zero value, then zero it out
; so USER doesn't get confused.
;
        xor     si,si
        mov     word ptr [shell_file_proc],si
        mov     word ptr [shell_file_proc+2],si

        end_fault_trap

good_shell_file_proc:

endif   ; KDEBUG

        mov     si, hHunkOMemory                ; Free up memory if necessary
        or      si, si
        jz      fcdr_no_exit
        cCall   GlobalUnlock,<si>
        cCall   GlobalFree,<si>

fcdr_no_exit:
cEnd

;-----------------------------------------------------------------------;
; InitTask1
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 04-Feb-1990 23:47:37  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   InitTask1,<PUBLIC,FAR>

;       parmD   callback
cBegin nogen
        mov     bx,sp
        push    ds
        SetKernelDS
        mov     ax,ss:[bx].4
        mov     dressed_for_success.off,ax
        mov     ax,ss:[bx].6
        mov     dressed_for_success.sel,ax
        pop     ds
        ret     4
cEnd nogen

ifdef WOW
;-----------------------------------------------------------------------;
; IsTaskLocked								;
; 									;
; Another hack procedure to determine if the current task is locked.	;
; A non-NULL value is returned if the task is locked and NULL is	;
; returned is the task is not locked.					;
;                                                                       ;
; This will always return null, because we will always have more than   ;
; one WOW app. (wowexec is always running                               ;
;                                                                       ;
; This api is used by QuickC                                            ;
;                                                         - Nanduri     ;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	IsTaskLocked,<PUBLIC,FAR>
cBegin  nogen
        xor ax,ax
	ret
cEnd    nogen

endif           ; WOW


        assumes ds, nothing
        assumes es, nothing

cProc   GetVersion,<PUBLIC,FAR>
cBegin nogen
        push    ds
        SetKernelDS
        cCall   GetAppCompatFlags,<0>
        test    dx, HIW_GACF_WINVER31
        jz      gv0
        mov     ax, 0a03h               ; Win ver 3.10 if app hack set
        jmps    gv1

gv0:
        mov     ax, 5f03h               ; Win ver 3.95
;       mov     ax,winVer
;       xchg    ah,al
gv1:
        mov     dh,DOS_version
        mov     dl,DOS_revision

        pop     ds
        UnSetKernelDS
        ret
cEnd nogen


sEnd    CODE



sBegin  MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

ExternNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
;
; SetErrorMode - set the current task's error mode
;
; Entry:
;       parmW   errMode 0001h = fail critical errors to app
;                       0002h = don't put up pmode fault message
;                       8000h = don't promt for file in OpenFile
;
; Returns:
;       AX = old flags
;
; History:
;  Sun 11-Feb-1990 19:01:12  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   ISetErrorMode,<PUBLIC,FAR>
        parmW   errMode
cBegin
        cCall   MISCMapDStoDATA
        ResetKernelDS
        mov     ax,errMode
        mov     ds,CurTDB
        UnSetKernelDS
        xchg    ds:[TDB_ErrMode],ax
cEnd


;-----------------------------------------------------------------------;
; GetWinFlags
;
; Gets the WinFlags for those wimps that can't import
; __WinFlags properly!
;
; Entry:
;       none
;
; Returns:
;       AX = WinFlags
;
; History:
;  Wed 05-Jul-1989 20:19:46  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetWinFlags,<PUBLIC,FAR>
cBegin nogen
        push    ds
        cCall   MISCMapDStoDATA
        ResetKernelDS
; Comment out this app hack since toolbook is no longer hacked...
; above is from Win95 source, why is toolbook no longer hacked? -DaveHart

        xor	ax, ax
	push	ax			; NULL => current task
	cCall	GetAppCompatFlags
        test    ax, GACF_HACKWINFLAGS
        mov     ax,WinFlags
        jz      @f

ifdef WOW
        ; fixes toolbook for WOW  -BobDay
;        and     ah, not ( WF1_WINNT or WF1_PAGING )
        and     ah, not WF1_WINNT ; fixes some apps that think they can't run on NT
else
        and     ah, not WF1_PAGING      ; fixes toolbook
endif

@@:
        xor     dx,dx
        pop     ds
        ret
cEnd nogen


;--------------------------------------------------------
;
;  GetExeVersion - return the current task's expected Windows version
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetExeVersion,<PUBLIC,FAR>
cBegin  nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     ds, CurTDB
        UnSetKernelDS
        mov     ax, ds:[TDB_ExpWinVer]
        pop     ds
        ret
cEnd    nogen

ifndef WOW
;-----------------------------------------------------------------------;
; WinOldApCall                                                          ;
;                                                                       ;
; This gives WinOldAp the information it needs to run in Expanded       ;
; Memory.                                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       (Real Mode)                                                     ;
;       BX    = XMS Handle of segment cache block                       ;
;       CX    = Size (in K bytes) of segment cache block                ;
;       DS:SI = pointer to original Int 21h handler                     ;
;       DI    = DOS System File Table Entry size                        ;
;                                                                       ;
;       (Protected Mode)                                                ;
;       AX    = Selector to low (lower 640k) heap block                 ;
;       BX    = paragraph count of low heap block                       ;
;       CX    = Selector to high (above 1024k & HMA) heap block         ;
;       DX    = Selector to fixed low PDB block for WOA use             ;
;       DS:SI = pointer to original Int 21h handler                     ;
;       DI    = DOS System File Table Entry size                        ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Mar 25, 1987 03:03:57p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   WinOldApCall,<PUBLIC,FAR>
;       parmW   func
cBegin nogen

        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     bx,sp                   ; check function code
        cmp     word ptr ss:[bx+6],0    ;  0 - get WOA info call
        jz      get_info                ; !0 - close cached files call

        push    Win_PDB                 ; Save current PDB
        cCall   CloseCachedFiles,<topPDB> ; close the cached files--really
        pop     Win_PDB                 ; 'Set' it back
;;;     mov     bx, Win_PDB
;;;     mov     ah, 50h                   ; Reset the PDB
;;;     call    far_real_DOS
;;;     mov     cur_dos_PDB, bx           ; Keep variables in sync
        jmps    woa_exit                  ;  closes them when passed topPDB

get_info:

        mov     ax,selLowHeap
        mov     bx,cpLowHeap
        mov     cx,selHighHeap
        mov     dx,selWoaPdb

        mov     di,FileEntrySize        ;DOS version specific SFT entry size

woa_exit:
        pop     ds
        ret     2

cEnd nogen
endif


;-----------------------------------------------------------------------;
; RegisterPtrace
;
; The ptrace engine DLL gets calls on behalf of the KERNEL.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Fri 02-Feb-1990 23:41:54  -by-  David N. Weise  [davidw]
; We'll get this right one of these days.
;
;  Mon 27-Feb-1989 20:22:06  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   RegisterPtrace,<PUBLIC,FAR>

;       parmD   ptrace_proc

cBegin nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     bx,sp
        or      Kernel_flags[2],KF2_PTRACE
        mov     ax,ss:[bx][6]
        mov     ptrace_DLL_entry.off,ax
        or      ax,ss:[bx][8]           ; is there one?
        mov     ax,ss:[bx][8]
        mov     ptrace_DLL_entry.sel,ax

        jnz     rp_done

        ;** If TOOLHELP's still installed, we don't really want to clear the
        ;**     flag.  If it's unhooked, clear the flag
        test    Kernel_flags[2], KF2_TOOLHELP
        jnz     rp_done
        and     Kernel_flags[2],NOT KF2_PTRACE
rp_done:
        pop     ds
        ret     4
cEnd nogen


;-----------------------------------------------------------------------;
; ToolHelpHook
;
;       Allows TOOLHELP.DLL to get PTrace notifications BEFORE the
;       normal PTrace hook used by WINDEBUG.DLL.  The WINDEBUG.DLL
;       hook is now obsolete and is maintained only for backward
;       compatibility.
;
;       TOOLHELP calls this function with a valid lpfn or with NULL
;       when it is ready to unhook.
;
;       July 25, 1991 [jont]
;-----------------------------------------------------------------------;

cProc   ToolHelpHook,<PUBLIC,FAR>, <ds,si,di>
        parmD   lpfn
cBegin
        SetKernelDSMisc

        ;** Set/clear the ToolHelp hook installed flag + we also set the
        ;*      PTrace flag because the ToolHelp hook is just a new
        ;*      PTrace hook.  We can only clear it, though, if BOTH PTrace
        ;**     hooks are now clear.
        or      Kernel_Flags[2],KF2_TOOLHELP OR KF2_PTRACE ;Set the flags
        mov     ax,WORD PTR lpfn[0]     ;Get the offset
        mov     dx,WORD PTR lpfn[2]     ;  and the selector
        mov     bx,ax                   ;Get a copy to trash
        or      bx,dx                   ;NULL?
        jnz     THH_Installed           ;No
        and     Kernel_Flags[2],NOT KF2_TOOLHELP ;Clear the flag
        cmp     WORD PTR ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking?
        jnz     THH_Installed           ;Yes, don't clear PTrace flag
        and     Kernel_Flags[2],NOT KF2_PTRACE ;Clear the flag
THH_Installed:

        ;** Install the hook and return the old one
        xchg    ax,WORD PTR lpfnToolHelpProc[0]
        xchg    dx,WORD PTR lpfnToolHelpProc[2]
cEnd

;-----------------------------------------------------------------------;
; FileCDR
;
; Allows the shell to set a procedure that gets called when
; a file or directory is created, moved, or destroyed.
;
; Entry:
;       parmD   lpNotifyProc    call back function
;
; Returns:
;       AX != 0 success
;
; History:
;  Mon 05-Jun-1989 22:59:33  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FileCDR,<PUBLIC,FAR>
;       parmD   lpNotifyProc
cBegin nogen
        mov     bx,sp
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     ax,ss:[bx][6]
        cmp     ax,-1                           ; is sel == -1, return current
        jne     @F                              ; proc
        mov     ax,shell_file_proc.off
        mov     dx,shell_file_proc.sel
        jmps    fcdr_exit

@@:
        xchg    shell_file_proc.sel,ax
        or      ax,ax
        jz      @F
        mov     cx,curTDB
        cmp     cx,shell_file_TDB
        jnz     fcdr_error
@@:     mov     ax,ss:[bx][4]
        mov     shell_file_proc.off,ax
        mov     ax,curTDB
        mov     shell_file_TDB,ax
        mov     ax,1
        jmps    fcdr_exit

fcdr_error:
        xchg    shell_file_proc.sel,ax  ; replace what was there
        xor     ax,ax

fcdr_exit:
        pop     ds
        UnSetKernelDS
        retf    4
cEnd nogen


sEnd    MISCCODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\aliases.asm ===
;-----------------------------------------------------------------------;
; add_alias
;
;
; Entry:
;	AX = alias
;	BX = base
;
; Returns:
;	AX = 1 success
;
; Error Returns:
;	AX = 0
;
; Registers Destroyed:
;
; History:
;  Sat 13-May-1989 09:16:09  -by-  David N. Weise  [davidw]
; Stole it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	add_alias,<PUBLIC,NEAR>,<ax>

cBegin
	SetKernelDS ES
	mov	dx,ax
	mov	es,sel_alias_array
	UnSetKernelDS ES
aa_look:
	mov	cx,es:[sa_size]
	shr	cx,1
	mov	di, SIZE SASTRUC
	xor	ax,ax
	repnz	scasw
	jcxz	aa_grow
	and	bl,NOT 07h		; remove RPL bits
	and	dl,NOT 07h		; remove RPL bits
	mov	es:[di][-2].sae_sel,bx
	mov	es:[di][-2].sae_alias,dx
	mov	ax,1			; return success
	jmps	aa_exit

aa_grow:
	xor	di,di
	mov	ax,es:[di].sa_size
	add	ax,SIZE SASTRUC + ((SIZE SAENTRY) * 8)
	push	ax
	push	bx
	push	dx
	push	es
	cCall	GlobalRealloc,<es,di,ax,GA_MOVEABLE>
	pop	es
	pop	dx
	pop	bx
	or	ax,ax			; did we get the memory?
	pop	ax
	jz	aa_exit
	sub	ax,SIZE SASTRUC
	mov	es:[di].sa_size,ax	; reset the size
	jmps	aa_look

aa_exit:

cEnd


;-----------------------------------------------------------------------;
; delete_alias
;
; Checks to see if the passed selector is an alias, if
; so it frees the entry in the array.
;
; Entry:
;	AX = selector to free
; Returns:
;	ES:DI => alias struct
;
; Registers Destroyed:
;
; History:
;  Sat 13-May-1989 09:16:09  -by-  David N. Weise  [davidw]
; Stole it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	delete_alias,<PUBLIC,NEAR>
cBegin
;	int	3
	SetKernelDS ES
	mov	es,sel_alias_array
	xor	di,di
	mov	cx,es:[di].sa_size
	shr	cx,1
	mov	di, SIZE SASTRUC
	and	al,NOT 07h		; remove RPL bits
da_keep_looking:
	repnz	scasw
	jcxz	da_exit
	.errnz	sae_sel - 0
	.errnz	sae_alias - 2
	.errnz	(SIZE SASTRUC) - 4
	test	di,2			; we avoid problems this way
	jnz	da_keep_looking
	sub	di,4
	xor	ax,ax
	mov	es:[di].sae_alias,ax
	mov	es:[di].sae_sel,ax
da_exit:
cEnd


;-----------------------------------------------------------------------;
; get_alias_from_original
;
;
; Entry:
;	AX = original selector
;
; Returns:
;	BX = alias
;	   = 0 if no alias
;	ES:DI => alias struct
;
; Registers Destroyed:
;
; History:
;  Sat 13-May-1989 09:16:09  -by-  David N. Weise  [davidw]
; Stole it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	get_alias_from_original,<PUBLIC,NEAR>

cBegin nogen
;	int	3
	SetKernelDS ES
	mov	es,sel_alias_array
	UnsetKernelDS ES
	xor	di,di
	mov	cx,es:[di].sa_size
	mov	di,SIZE SASTRUC
	shr	cx,1
	and	al,NOT 07h		; remove RPL bits
gafo_keep_looking:
	cld
	repnz	scasw
	xor	bx,bx
	jcxz	gafo_exit
	.errnz	sae_sel - 0
	.errnz	sae_alias - 2
	.errnz	(SIZE SASTRUC) - 4
	test	di,2			; we avoid problems this way
	jz	gafo_keep_looking
	sub	di,2
;	 int	 3
	mov	bx,es:[di].sae_alias
gafo_exit:
	ret

cEnd nogen


;-----------------------------------------------------------------------;
; get_original_from_alias
;
;
; Entry:
;	AX = alias selector
;
; Returns:
;	BX = original selector
;	   = 0 if no alias
;	ES:DI => alias struct
;
; Registers Destroyed:
;
; History:
;  Sat 13-May-1989 09:16:09  -by-  David N. Weise  [davidw]
; Stole it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	get_original_from_alias,<PUBLIC,NEAR>

cBegin nogen
;	int	3
	SetKernelDS ES
	mov	es,sel_alias_array
	xor	di,di
	mov	cx,es:[di].sa_size
	mov	di,SIZE SASTRUC
	shr	cx,1
	and	al,NOT 07h		; remove RPL bits
gofa_keep_looking:
	cld
	repnz	scasw
	xor	bx,bx
	jcxz	gofa_exit
	.errnz	sae_sel - 0
	.errnz	sae_alias - 2
	.errnz	(SIZE SASTRUC) - 4
	test	di,2			; we avoid problems this way
	jnz	gofa_keep_looking
	sub	di,4
;	 int	 3
	mov	bx,es:[di].sae_sel
gofa_exit:
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; check_for_alias
;
;
; Entry:
;	parmW	selector that moved
;	parmD	new address
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 17-Jan-1990 02:07:41  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	check_for_alias,<PUBLIC,NEAR>,<ds,es>

	parmW	selector
	parmD	new_address
cBegin
;	int	3
	pusha
	pushf
	mov	ax,selector
	call	get_alias_from_original
	or	bx,bx
	jz	cfa_exit
;	 int	 3
	mov	dx,new_address.hi
	mov	ax,new_address.lo
	cCall	set_physical_address,<bx>
cfa_exit:
	popf
	popa
cEnd


;-----------------------------------------------------------------------;
; wipe_out_alias
;
; This little routine is called when a global memory object
; is being freed.  We search for an alias, if one is found
; then it is freed.
;
; Entry:
;	DX = handle that might have an alias associated with it
;
; Returns:
;	nothing
;
; Registers Destroyed:
;
; History:
;  Thu 18-Jan-1990 00:43:13  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	wipe_out_alias,<PUBLIC,NEAR>,<dx,di>
cBegin
;	 int	 3
	mov	ax,dx
	call	get_alias_from_original
	or	bx,bx
	jz	woa_exit
;	 int	 3
	xor	ax,ax
	mov	es:[di].sae_sel,ax
	xchg	es:[di].sae_alias,ax
	cCall	FreeSelector,<ax>
woa_exit:

cEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\eems.inc ===
; some useful constants for EEMS

KBYTES			equ	1024
PARAGRAPH		equ	16
LOG2_KBYTES		equ	10
LOG2_PARAGRAPH		equ	4

EMSPageShift		equ	10			; Insist on 16k pages
EMSPageSize		equ	(1 shl EMSPageShift)	; Insist on 16k pages

; parameters for EEMS

LOWEST_SWAP_AREA	equ	384
EEMS_DEBUG		equ	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\dosinit.asm ===
title	DOSINIT - Initialize dos specific static data.

.xlist
include kernel.inc
include pdb.inc
.list

externFP GetModuleHandle
externFP GetProcAddress
externFP Int21Handler
externFP GlobalDOSAlloc
externFP GetFreeSpace
ifdef FE_SB
externFP GetSystemDefaultLangID
endif   ;FE_SB
ifdef WOW
externNP ExitKernel
endif

DataBegin

externB graphics
externB Kernel_flags
externB DOS_version
externB DOS_revision
externB KeyInfo
externB fFarEast
ifdef	FE_SB
externB fDBCSLeadTable
externB DBCSVectorTable
endif ;FE_SB
externB fBreak
externB fNovell
externB CurDOSDrive
externB DOSDrives
externW cur_dos_PDB
externW Win_PDB
externW f8087
externW FileEntrySize
externW topPDB
externW headPDB
externW hExeHead
externW MyCSDS
externW hGDI
externW hUser
externD pTimerProc
externD pSftLink
externD pFileTable
externD myInt2F
externD pMBoxProc
externD pSysProc
externD pGetFreeSystemResources
externD plstrcmp
ifdef	JAPAN
externD pJpnSysProc
endif
externD pKeyProc
externD pKeyProc1
externD pSErrProc
externD pDisableProc
externD pExitProc

externD pMouseTermProc
externD pKeyboardTermProc
externD pKeyboardSysReq
externD pSystemTermProc
externD pDisplayCritSec
externD pUserInitDone
externD pPostMessage
externD pSignalProc
externD pIsUserIdle
externD pUserGetFocus
externD pUserGetWinTask
externD pUserIsWindow
externD curDTA
externD InDOS

if ROM
externD pYieldProc
externD pStringFunc
externD prevInt21Proc
externD prevInt00proc
externD prevInt24Proc
externD prevInt2FProc
externD prevInt02proc
externD prevInt04proc
externD prevInt06proc
externD prevInt07proc
externD prevInt3Eproc
externD prevInt75proc
endif

ifdef	JAPAN
; Need this variable in order to make Kernel to hardware independent
externW WinFlags
endif

DataEnd

DataBegin INIT

; Win.com does version check, so this does not need to be internationalized.

externB	szDosVer
;msg0	DB	'Incorrect DOS version:  DOS 3.1 or greater required.',13,10,'$'

handles dw  10 dup(0)

find_string db	'CON '
name_string db	'CON',0

DataEnd INIT


sBegin	CODE
assumes cs,CODE

ife ROM
externD pYieldProc
externD pStringFunc
externD prevInt21Proc
externD prevInt00proc
externD prevInt24Proc
externD prevInt2FProc
externD prevInt02proc
externD prevInt04proc
externD prevInt06proc
externD prevInt07proc
externD prevInt3Eproc
externD prevInt75proc
ifdef WOW
externD prevInt31proc
endif
endif

sEnd	CODE

externNP DebugSysReq
externNP SetOwner

;----------------------------------------------------------------------------;
; define any constans used in the file.					     ;
;----------------------------------------------------------------------------;

SFT_GROW_LIM_IN_64K	equ	8	;if memory < 8*64k, grow to 100 handles
				 	;else grow upto 127 handles
SFT_HIGH_LIM		equ	127	;grow upto 127 when enough memory
SFT_LOW_LIM		equ	100	;grow upto 100 when low in memory


;----------------------------------------------------------------------------;
; define any macros used in the file.					     ;
;----------------------------------------------------------------------------;

SaveVec	MACRO	vec
	mov	ax,35&vec&h
	pushf
	call	prevInt21proc
if ROM
	mov	prevInt&vec&proc.off,bx
	mov	prevInt&vec&proc.sel,es
else
	mov	ax,codeOffset prevInt&vec&proc
	SetKernelCSDword	ax,es,bx
endif
	ENDM

;----------------------------------------------------------------------------;

DataBegin INIT

sysmodstr	DB  'SYSTEM',0
keymodstr	DB  'KEYBOARD',0
displaymodstr	DB  'DISPLAY',0
mousemodstr	DB  'MOUSE',0
gdimodstr	DB  'GDI',0
usermodstr	DB  'USER',0

inqprocstr	label	byte
msgprocstr	label	byte		; MessageBox in USER
sysprocstr	DB  '#1',0		; sysprocstr = InquireSystem
timerprocstr	DB  '#2',0		; timerprocstr = CreateSystemTimer
keydisstr	label	byte		; keydisstr = DisableKeyboard
mousedisstr	DB  '#3',0		; mouseprocstr = DisableMouse
disprocstr	DB  '#4',0		; DisableOEMLayer in USER
extprocstr	label	byte		; ExitWindows in USER
coprocessor	DB  '#7',0		; Get80x87SaveSize in system
kbdfocus	DB  '#23',0		; GetFocus in USER
wintask 	DB  '#224',0		; GetWindowTask in USER
iswindow	DB  '#47',0		; IsWindow in USER
signalproc	DB  '#314',0		; SignalProc in user
isuseridle	DB  '#333',0		; IsUserIdle in user
getfreesysrsc	DB  '#284',0		; GetFreeSystemResources in user
userlstrcmp     DB  '#430',0            ; lstrcmp in user
stringfunc	DB  '#470',0		; StringFunc in User.

sysdisstr	DB  '#5',0              ; sysdisstr = DisableSystemTimers
pmprocstr	DB  '#110',0		; pmprocstr = PostMessage
keysysreq	DB  '#136',0		; keysysreq = EnableKBSysReq
syserrorstr     DB  '#320',0            ; syserrorstr = SysErrorBox in USER
yldprocstr	DB  '#332',0		; yldprocstr = UserYield in USER
udnprocstr	DB  '#400',0		; tell user that initialization done
displaycrit	DB  '#500',0		; win386 interaction craziness
ifdef	JAPAN
jpnsysprocstr	db  'JapanInquireSystem',0 ; Kernel.JapanInquireSystem entry
endif

DataEnd INIT

sBegin	INITCODE
assumes CS,CODE
;-----------------------------------------------------------------------;
; InitFwdRef								;
; 									;
; Initializes the far call pointers to SYSTEM, USER, KEYBOARD.		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 06, 1987 04:21:13p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InitFwdRef,<PUBLIC,NEAR>,<si,di>
cBegin
	SetKernelDS

	mov	ax,352Fh
	pushf
	call	prevInt21proc
	mov	myInt2F.sel,es
	mov	myInt2F.off,bx

; Save current Int 00h, 21h, 24h, and 2Fh.

	SaveVec 00
;;;	SaveVec 21
	SaveVec 24

; Get address of procedures in USER and SYSTEM modules that we will need.

	regptr	pStr,ds,bx

	mov	bx,dataOffset sysmodstr
	cCall	GetModuleHandle,<pStr>
	mov	si,ax

	mov	bx,dataOffset sysprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	pSysProc.off,ax
	mov	pSysProc.sel,dx

ifdef	JAPAN
	mov	bx,dataOffset jpnsysprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	pJpnSysProc.off,ax
	mov	pJpnSysProc.sel,dx
endif

	mov	bx,codeOffset ifr4
	push	cs			; push return address
	push	bx
	mov	bx,dataOffset coprocessor
	cCall	GetProcAddress,<si,pStr>
	push	dx
	push	ax		; push address to call
	ret_far			; call 8087 info
ifr4:
	mov	f8087,ax
ifdef	JAPAN
;;;	int	1		; debugging purpose only
	; Since Japanese OEMs have non-IBM clone machines, Windows
	; cannot use standard Bios interrupt to get system informations.
	; In BootStrap (see LDBOOT.ASM), it uses Int 11h to obtain MCP's
	; availability. However, Windows cannot use Int 11h (becase of
	; IBM-dependant), MSKK has removed Int 11h from BootStrap.
	;
	; At this point, AX register contains MCP's availability, i.e.
	; if AX has value zero, no MCP is installd. if AX has value except
	; zero, MCP is installed. The following codes will update WinFlags
	; and its exported variables by using AX register.

	test	ax,ax			; MCP is installed?
	jz	@F			; jump if not
	mov	ax,WF1_80x87 shl 8	; set MCP present bit
@@:
	or	WinFlags,ax		; update internal variable
	xor	ax,ax
	mov	dx,178			; #178 is __WinFlags location for public use
	cCall	GetProcAddress,<hExeHead,ax,dx>
	mov	ax,WinFlags
	mov	es:[bx],ax
endif

	mov	bx,dataOffset timerprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	pTimerProc.off,ax
	mov	pTimerProc.sel,dx

	mov	bx,dataOffset sysdisstr
        cCall   GetProcAddress,<si,pStr>
	mov	pSystemTermProc.off,ax
	mov	pSystemTermProc.sel,dx

	cmp	graphics,0	; Graphics?
	jne	grp
	jmp	nographics

grp:
ifndef WOW
	mov	bx,dataOffset displaymodstr	; display stuff
	cCall	GetModuleHandle,<pStr>
	mov	bx,dataOffset displaycrit

	cCall	GetProcAddress,<ax,pStr>
	mov	pDisplayCritSec.off,ax
	mov	pDisplayCritSec.sel,dx

	mov	bx,dataOffset mousemodstr	; mouse stuff
        cCall   GetModuleHandle,<pStr>
        mov     si,ax

	mov	bx,dataOffset mousedisstr
        cCall   GetProcAddress,<si,pStr>
	mov	pMouseTermProc.off,ax
	mov	pMouseTermProc.sel,dx
endif
	mov	bx,dataOffset gdimodstr
	cCall	GetModuleHandle,<pStr>
	mov	hGDI,ax

	mov	bx,dataOffset usermodstr	; user stuff
	cCall	GetModuleHandle,<pStr>
	mov	hUser,ax
	mov	si,ax

	mov	bx,dataOffset msgprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	pMBoxProc.off,ax
	mov	pMBoxProc.sel,dx

	mov	bx,dataOffset syserrorstr
	cCall	GetProcAddress,<si,pStr>
        mov     word ptr pSErrProc[0],ax
        mov     word ptr pSErrProc[2],dx

	mov	bx,dataOffset extprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pExitProc[0],ax
	mov	word ptr pExitProc[2],dx

	mov	bx,dataOffset disprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pDisableProc[0],ax
	mov	word ptr pDisableProc[2],dx

	mov	bx,dataOffset yldprocstr
	cCall	GetProcAddress,<si,pStr>
ife ROM
	mov	bx, codeOFFSET pYieldProc
	SetKernelCSDword	bx,dx,ax
else
	mov	pYieldProc.off,ax
	mov	pYieldProc.sel,dx
endif

	mov	bx,dataOffset udnprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pUserInitDone[0],ax
	mov	word ptr pUserInitDone[2],dx

	mov	bx,dataOffset pmprocstr
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pPostMessage[0],ax
	mov	word ptr pPostMessage[2],dx

	mov	bx,dataOffset signalproc
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pSignalProc[0],ax
	mov	word ptr pSignalProc[2],dx

	;   These are never called in WOW

ifndef WOW
	mov	bx,dataOffset isuseridle
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pIsUserIdle[0],ax
	mov	word ptr pIsUserIdle[2],dx

	mov	bx,dataOffset getfreesysrsc
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pGetFreeSystemResources[0],ax
	mov	word ptr pGetFreeSystemResources[2],dx
endif

        mov     bx,dataOffset userlstrcmp
        cCall   GetProcAddress,<si,pStr>
        mov     word ptr plstrcmp[0],ax
        mov     word ptr plstrcmp[2],dx

	mov	bx,dataOffset stringfunc
	cCall	GetProcAddress,<si,pStr>
if ROM
	mov	pStringFunc.off,ax
	mov	pStringFunc.sel,dx
else
	mov	bx, codeOFFSET pStringFunc
	SetKernelCSDword	bx,dx,ax
endif

	mov	bx,dataOffset kbdfocus
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pUserGetFocus[0],ax
	mov	word ptr pUserGetFocus[2],dx

	mov	bx,dataOffset wintask
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pUserGetWinTask[0],ax
	mov	word ptr pUserGetWinTask[2],dx

	mov	bx,dataOffset iswindow
	cCall	GetProcAddress,<si,pStr>
	mov	word ptr pUserIsWindow[0],ax
	mov	word ptr pUserISWindow[2],dx

	mov	bx,dataOffset keymodstr
	cCall	GetModuleHandle,<pStr>
	mov	si,ax

	mov	bx,dataOffset keydisstr
        cCall   GetProcAddress,<si,pStr>
        mov     word ptr [pKeyboardTermProc],ax
        mov     word ptr [pKeyboardTermProc+2],dx

	mov	bx,dataOffset keysysreq
        cCall   GetProcAddress,<si,pStr>
	mov	pKeyboardSysReq.off,ax
	mov	pKeyboardSysReq.sel,dx

	mov	ax,4
	cCall	pKeyboardSysReq,<ax>	; tell kbd to pass SysReq to CVWBreak

	mov	bx,dataOffset KeyInfo
	push	ds
	push	bx			; push argument to keyboard.inquire
	mov	bx,codeOffset ifr1
	push	cs			; push return address
	push	bx
	mov	bx,dataOffset inqprocstr
	cCall	GetProcAddress,<si,pStr>
	push	dx
	push	ax		; push address to call
	ret_far			; call keyboard inquire
ifr1:
ifndef JAPAN
; This is DBCS kernel. So do not get information from keyboard
; driver. This K/B spec is old one and should be ignored.
; We use DOS DBCS vector instead of K/B table.
; 071191 Yukini
;
;ifndef KOREA			    ;Korea might want to remove this too.

;!!!! Note to Taiwan developers !!!
;      The following code fragment is necessary for those countries
;      who want to run DBCS Windows on top of SBCS MS-DOS.
;      For example, Taiwan might need this feature.
;      Japan and Korea are safe to remove this fragment as Japanese
;      and Hangeul Windows all assume DBCS MS-DOS.

	mov	si,dataOffset KeyInfo+KbRanges
	lodsw
	cmp	al,ah
	jbe	ifr2
	lodsw
	cmp	al,ah
	ja	ifr3
ifr2:	inc	fFarEast
ifdef	FE_SB
;
;	setup DBCS lead byte flag table after keyboard driver is loaded
;
	mov	di, dataOffset fDBCSLeadTable ; clear table before begin...
	mov	cx, 128
	xor	ax, ax
	push	es
	push	ds
	pop	es
	cld
	rep	stosw
	pop	es
	mov	si, dataOffset KeyInfo+KbRanges
	mov	cx, 2
idr1:
	lodsw			; fetch a DBCS lead byte range
	cmp	al, ah		; end of range info?
	ja	idr3		; jump if so.
	call	SetDBCSVector
	loop	idr1		; try another range
idr3:
endif	;FE_SB
endif	;NOT JAPAN
	jmps	ifr3

;
; Substitute dummy procs if user/gdi/keyboard/display not present
;
if 0
externFP <DummyKeyboardOEMToAnsi>
endif
externFP <OldYield>
nographics:
ife ROM
	push	di
	push	bx
if 0
	mov	bx, codeOffset pKeyProc
	mov	di, codeOffset DummyKeyboardOEMToAnsi
;	 SetKernelCSDword	 bx,cs,di
endif
	mov	bx, codeOffset pYieldProc
	mov	di, codeOffset OldYield
	SetKernelCSDword	bx,cs,di
	pop	bx
	pop	di
else
	mov	pYieldProc.off,codeOffset OldYield
	mov	pYieldProc.sel,cs
endif
ifr3:
	call	DebugSysReq
cEnd


	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
; InitDosVarP								;
; 									;
; Records for future use various DOS variables.				;
; 									;
; Arguments:								;
;	ES = PDB of Kernel						;
; 									;
; Returns:								;
;	AX != 0 if successful						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 23:50:20  -by-  David N. Weise  [davidw]		;
; Removed more dicking around by removing WinOldApp support.		;
;									;
;  Tue Feb 03, 1987 10:45:31p  -by-  David N. Weise   [davidw]		;
; Removed most of the dicking around the inside of DOS for variable	;
; locations.  Variables are now got and set the right way: through DOS	;
; calls.  This should allow Windows to run in the DOS 5 compatibility	;
; box as well as under future versions of real mode DOS.		;
; 									;
;  Tue Jan 06, 1987 04:33:16p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InitDosVarP,<PUBLIC,NEAR>,<bx,cx,dx,si,di,es>
cBegin

	ReSetKernelDS

; Save our PDB pointer in the code segment

	mov	ax,es
	mov	topPDB,ax
	mov	headPDB,ax
	mov	es:[PDB_Chain],0	; the buck stops here

; record current PDB

	mov	cur_dos_PDB,ax
	mov	Win_PDB,ax

; record current DTA

	mov	curDTA.sel,ax
	mov	curDTA.off,80h

; disable ^C checking as fast as possible

	mov	ax,3300h		; remember ^C state
	int	21h
	mov	fBreak,dl

	mov	ax,3301h		; disable ^C checking
	mov	dl,0
	int	21h

; record in_dos pointer

	mov	ah,34h
	int	21h
	mov	InDOS.sel,es
	mov	InDOS.off,bx

	mov	ah, 19h
	int	21h
	mov	CurDOSDrive, al		; Initialize current drive tracking
	mov	dl, al
	mov	ah, 0Eh
	int	21h
	mov	DOSDrives, al		; For returning from Select Disk calls

; To avoid beaucoup thought, let's init prevInt21Proc right now!
;
;  This was done as a last minute hack to 2.10.  I forget the
;  motivation for it, other than it fixed a couple of bugs
;  having to do with error recovery.  It did introduce one
;  bug with one error path having to do with Iris, but I don't
;  remember that either.  Interested parties can grep for
;  prevInt21Proc and think hard and long.
;
; Since we now call through prevInt21Proc in many places rather
; than use int 21h (saves ring transitions), this had better stay here!
; See the DOSCALL macro.
;

	mov	ax, 3521h
	int	21h
if ROM
	mov	prevInt21Proc.off,bx
	mov	prevInt21Proc.sel,es
else
	mov	ax,codeOffset prevInt21Proc
	SetKernelCSDword ax,es,bx
endif

ifdef WOW
;
; We save the int 31 vector here to avoid emulation of int 31 instructions.
; THIS WILL BREAK INT 31 HOOKERS.  Currently we don't beleive that any 
; windows apps hook int 31.
	mov	ax, 3531h
	int	21h

	mov	ax,codeOffset prevInt31Proc
	SetKernelCSDword ax,es,bx
endif

		; moved here 8 feb 1990 from InitFwdRef, no good reason for
		;  leaving 0 behind, except that's the way we did it in 2.x.

; Save current Int 02h, 04h, 06h, 07h, 3Eh, and 75h.

	SaveVec 02
	SaveVec 04
	SaveVec 06
	SaveVec 07
	SaveVec 3E
	SaveVec 75

; get the 2F
				; this slime is an old novell hack
	SaveVec 2F		;  and can probably be removed!

; See if we are under NOVELL

	mov	ah, 0DCh
	int	21h
	mov	fNovell, al

; Get MSDOS version number

	mov	ah,30h
	int	21h
ifdef TAKEN_OUT_FOR_NT
	cmp	al,10			; is it the DOS 5 compatibility box?
	jae	got_ver
	cmp	al,4			; > 4.xx?
	jae	got_ver
	cmp	al,3			; < 3.0 ?
	jb	dos_version_bad
	cmp	ah,10
	jae	got_ver 		; < 3.1 ?
dos_version_bad:
	jmps	fail
endif

got_ver:

	mov	DOS_version,al
	mov	DOS_revision,ah

; Remember where the end of the SFT table is, so if we decide to
; add file handles we can remove them on exit
;
; DOS 3.10 =< version =< DOS 3.21  => FileEntrySize = 53
; DOS 3.21  < version  < DOS 4.00  => unknown
; DOS 4.00 =< version =< DOS 4.10  => FileEntrySize = 58
; DOS 4.10  < version              => unknown
;             version =  DOS 10    => FileEntrySize = 00

; OS|2
	xor	bx,bx
ifdef TAKEN_OUT_FOR_NT
	cmp	al,10			; OS|2 can't mess with SFTs
	jae	have_file_size

; DOS 3
	cmp	al,3
	ja	DOS_4

	mov	bx,56
	cmp	ah,0
	jz	have_file_size
	mov	bx,53
	cmp	ah,31
	jbe	have_file_size
	jmps	unknown_DOS

DOS_4:					; REMOVED FOLLOWING! DOS 3.4 will be
					; called 4.0 so we don't know the size!
;;;	mov	bx,58
;;;	cmp	ah,1			; DOS 4
;;;	jbe	have_file_size

unknown_DOS:
	push	ax
	call	GetFileSize
	mov	bx,ax
	pop	ax
	cmp	bx,-1
	jz	fail
endif

have_file_size:
	mov	FileEntrySize,bx

	mov	al,10			; don't want to mess with SFT's!
ifdef FE_SB
;During boot,
;Use thunked API GetSystemDefaultLangID() to set DBCS leadbyte table        
    cCall   GetSystemDefaultLangID   
    xor     bx,bx

Search_LangID:
    mov	    dx,word ptr DBCSVectorTable[bx]	;get language ID
    test    dx,dx                               ;if end of table,
    jz      DBCS_Vector_X                       ;exit
    cmp     ax,dx                               ;match LangID?
    jz      LangID_Find                         ;yes
    add     bl, DBCSVectorTable[bx+2]           ;point to next DBCS vector
    add     bl, 3                               ;point to DBCS leadbyte range
    jmps    Search_LangID                       ;continue search

LangID_Find:
    mov     cl, DBCSVectorTable[bx+2]           ;get DBCS vector size
Set_DBCS_Vector:
    sub     cl, 2
    jc      DBCS_Vector_X
    mov     ax, word ptr DBCSVectorTable[bx+3]  ;set DBCS vector
    push    bx
    call    SetDBCSVector
    pop     bx
    add     bl, 2
    jmps    Set_DBCS_Vector

DBCS_Vector_X:
endif ;FE_SB

	mov	ax,-1
	jmps	initdone
fail:
	mov	dx,dataOffset szDosVer	;msg0
	mov	ah,09
	int	21h
	xor	ax,ax
initdone:
cEnd

ifdef FE_SB
;-----------------------------------------------------------------------;
; SetDBCSVector								;
; 									;
; Setup fDBCSLeadTable							;
;									;
; Arguments:								;
;	AL = First DBCS lead byte					;
;	AH = Final DBCS lead byte					;
;									;
; Returns:								;
;	NONE								;
;									;
; Registers Destroyed:							;
;	BX								;
; Calls:								;
;	NONE								;
;									;
;-----------------------------------------------------------------------;

cProc	SetDBCSVector,<PUBLIC,NEAR>

cBegin	nogen

	mov	bl, al		;
	xor	bh, bh		;
idr2:
	mov	byte ptr fDBCSLeadTable[bx], 1	; set "DBCS lead byte"
	inc	bl
	cmp	bl, ah		; end of range?
	jle	idr2		; jump if not
	mov	fFarEast,1	; I am in DBCS world. 071191 Yukini.

	ret

cEnd	nogen

endif

;-----------------------------------------------------------------------;
; GetFileSize								;
; 									;
; Measures the SFT entry size for DOS versions we don't know about.	;
;									;
; Arguments:								;
;	none								;
;									;
; Returns:								;
; 	AX = SFT size							;
;									;
; Error Returns:							;
;	AX = -1								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Aug 03, 1987 02:42:15p  -by-  David N. Weise   [davidw]          ;
; Rickz wrote it.							;
;								        ;
; Modifications:						        ;
; -by- Amit Chatterjee.						        ;
;								        ;
; The original method of opening 5 files and looking for 3 consecutive  ;
; ones would not succeed always. IRMALAN when run as a TSR from standar-;
; -d mode Windows would leave a file open (it probably opens 3 files    ;
; when pooped into the host and leaves the third one open). Next time   ;
; on starting windows, the index of the above 5 files that this routine ;
; would open would be 3,4,5,6 & 8 (SFT entry no). Of these the first    ;
; 2 would be in one node so this woutine would not find 3 consecutive   ;
; entries and Windows would not start up.				;
;									;
; To work around this, we try to open 5 at first. If we fail, then we   ;
; leave the 5 open and open another 5.					;
;								        ;
; !!! At some point we should try to figure out why IRMALAN leaves a    ;
; file open.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetFileSize,<PUBLIC,NEAR>

cBegin	nogen

	CheckKernelDS
	ReSetKernelDS

	mov	si,dataOffset handles
	cCall	GetFileSize1	
	cmp	ax,-1			;did it succeed ?
	jnz	@f			;yes.
	mov	si,dataOffset handles+10;place for another five
	cCall	GetFileSize1		;try to get it
@@:
	push	ax			;save return value

; close files that were opened

	mov	si,dataOffset handles
	mov	cx,10

close_file_loop:		; close the file for each handle

	mov	ax,3E00h
	mov	bx,[si]
	or	bx,bx		; no more open ?
	jz	close_file_done
	int	21h
	add	si,2
	loop	close_file_loop

close_file_done:

	pop	ax		;get  back return value
	ret

cEnd	nogen



cProc	GetFileSize1,<PUBLIC,NEAR>

cBegin nogen

	mov	dx,dataOffset name_string
	mov	cx,5
open_file_loop:			; open the console four times
	mov	ax,3D00H
	int	21h
	mov	[si],ax		; save the handle
	add	si,2
	loop	open_file_loop

	xor	di,di		; start searching from 0:0


; get a selector for searching from 0:0

	mov	ax,0			;get a free slector
	mov	cx,1			;only 1 selector to allocate
	int	31h			;ax has selector
	xor	cx,cx			;hiword of initial base
	push	dx
	xor	dx,dx			;loword of initial base
	mov	bx,ax			;get the selector
	call	SetSelectorBaseLim64k	;base is at 0:0
	pop	dx
	mov	es,bx			

get_first:
	call	find_con	; find first 'CON\0'
	cmp	ax,-1
	jz	no_table

	cmp	ax,-2
	jnz	get_second
search_again:

	push	bx
	mov	bx,es		;get the slector

; add FFD paragraphs to the base to get to next segment

	mov	ax,0FFDh	;paragraphs to offset base by
	push	dx
	call	AddParaToBase	;update base
	pop	dx
	mov	es,bx		;have the updated selector
	pop	bx
	xor	di,di
	jmp	get_first

get_second:

	mov	bx,ax		; bx is location of first 'CON\0'
	and	bx,000Fh
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	push	bx		;save
	mov	bx,es		;get the base
	push	dx
	call	AddParaToBase	;add AX paras to base
	pop	dx
	mov	es,bx		;have the updated base
	pop	bx		;restore
	mov	di,bx
	add	di, 3		; kludge for the size of desired string
	call	find_con	; find second 'CON\0'
	cmp	ax,-1
	jz	no_table
	cmp	ax,-2
	jz	search_again

	mov	dx,ax		; dx is location of second 'CON\0'
	sub	dx,bx
	cmp	dx,100h		; file entries are within 100h bytes of another
	ja	get_second
	mov	bx,dx		; bx is distance between the first two
	mov	dx,ax		; dx is location of second 'CON\0'
get_third:
	call	find_con
	cmp	ax,-1
	jz	no_table
	cmp	ax,-2
	jz	search_again
	mov	cx,ax		; ax & cx = location of third 'CON\0'
	sub	cx,dx		; cx is distance between the 2nd & 3rd
	sub	bx,cx		; bx = the difference in distances
	jz	found
	cmp	cx,100h		; file entries are within 100h bytes of another
	ja	get_second
	mov	bx,cx		; bx is distance between the two
	mov	dx,ax		; dx is location of the last 'CON\0'
	jmp	get_third

found:
	mov	ax,cx		; store file table entry size in ax

no_table:

; if the temp selector had been allocated free it.

	push	bx
	push	ax
	mov	bx,es
	xor	ax,ax
	mov	es,ax
	or	bx,bx		;allocated ?
	jz	@f		;no.
	mov	ax,1		;free selector
	int	31h		;free it
@@:
	pop	ax
	pop	bx		;restore
	ret

find_con:
	mov	ax,es
	push	dx			;save
	push	bx
	mov	bx,ax			;get the slector
	call	GetSelectorSegment	;DX returns segment value
	mov	ax,dx			;get the segment value
	pop	bx
	pop	dx			;restore
	cmp	ax,8000h
	ja	not_found
	xor	ax,ax
	mov	al, byte ptr [find_string] 
try_again:
	mov	cx,0FFF0h
	sub	cx,di
	repnz	scasb 		; search for the first letter ('C')
	jz	continue
	mov	ax,-2
	jmps	temp_ret
;	ret
continue:
	mov	cx,3
	mov	si, dataOffset find_string+1
	repz	cmpsb		; search for the next three letters
	jnz	find_con
	lea	ax,[di-4]	; return the string's location in ax
temp_ret:
	ret

not_found:

	mov	ax,-1
	ret

cEnd nogen
;----------------------------------------------------------------------------;
; AddParaToBase:							     ;
;									     ;
; Given a selector in BX and a para value in AX, it updates the base of the  ;
; selector by AX paras. In real mode, it just adds AX to BX. The modified    ;
; selector/segment is returned in BX.					     ;
;----------------------------------------------------------------------------;

AddParaToBase  proc near
	push	ax		;save
	mov	ax,6		;get base address code
	int	31h		;cx:dx has current base address
	pop	ax		;get back the offset in para
	push	bx		;use as work register
	xor	bx,bx		;zero out
	shl	ax,1		;shift out a bit
	rcl	bx,1		;gather into bx
	shl	ax,1		;shift out a bit
	rcl	bx,1		;gather into bx
	shl	ax,1		;shift out a bit
	rcl	bx,1		;gather into bx
	shl	ax,1		;shift out a bit
	rcl	bx,1		;gather into bx
	add	dx,ax		;add low word of offset
	adc	cx,0		;update hiword
	add	cx,bx		;update hiword of offset
	pop	bx		;get back selector
	mov	ax,7		;set selector base code
	int	31h		;the base of the selector has been set
	inc	ax		;set selector limit code
	mov	dx,-1		;64-1k limit
	xor	cx,cx		;cx:dx=64-1k
	int	31h		;limit set to 64-1k
	ret

AddParaToBase	endp
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; GrowSFTToMax:								     ;
;									     ;
; This routine is invoked only in protected mode and grows the SFT to its max;
; size by linking in one more tanle entry.				     ;
;----------------------------------------------------------------------------;

	assumes ds,nothing
	assumes	es,nothing

cProc	GrowSFTToMax,<NEAR,PUBLIC,PASCAL>,<es,ax,di>

	localW	NewHandles		;# of extra handles being allocated
	localW	NewTableSize		;size of newtable
	localB	GrowLimit		;size to grow sft to

cBegin
	ReSetKernelDS

; get the amount of free space and decide on the number of handle entries that
; we want to add. If the memory space is more than 8*64K, make the total number 
; of handle entries 256 else make it 100.

	mov	GrowLimit,SFT_HIGH_LIM	;assume we will grow upto 255
	xor	bx,bx			;dummy parameter
	cCall	GetFreeSpace,<bx>	;dx:ax returns free area size
	cmp	dx,SFT_GROW_LIM_IN_64K	;is it more than or equal (in 64k incs)
	jae	@f		        ;yes
	mov	GrowLimit,SFT_LOW_LIM	;low on memory, grow till 100
@@:
	  
; allocate a free selector.

	xor	ax,ax			;allocate selector function code
	mov	cx,1			;need to get 1 selector
	int	31h			;ax has the selector

; get the address of the first in the SFT chain.

	push	ax			;save the slector
	mov	ah,52h			;get SYSVARS call
	int	21h			;es:bx points to DOS SYSVAR structure
	lea	bx,[bx+sftHead]		;es:bx points to the start of the sft
	mov	cx,es:[bx][2]		;get the segment
	mov	dx,es:[bx]		;get the offset
	pop	ax			;get back the free selector

; modify the base of the free selector to point to the first link in the system
; file table list.

	mov	bx,ax			;get the selector here
	call	SetSelectorBaseLim64k	;set selector base and limit.

; now get into a loop, to find out the number of file handles that the system
; currently.

	xor	ah,ah			;will count handles here.
	mov	es,bx			;es points to the first entry

CountNumHandles:

	xor	bx,bx			;es:bx points to first table
	mov	cx,es:[bx].sftCount	;get the number of handles
	add	ah,cl			;accumulate no of handles here
	cmp	word ptr es:[bx],-1	;end of chain ?
	jz	AddOneMoreSFTLink	;end of current list reached
	mov	cx,word ptr es:[bx].sftLink[2];get the segment of next node
	mov	dx,word ptr es:[bx].sftLink[0];get the offset of the next node
	mov	bx,es			;get the selector
	call	SetSelectorBaseLim64k	;modify sel to point to next node
	jmp	short CountNumHandles	;continue

AddOneMoreSFTLink:

; find out the number of extra handles for which we will allocate space

	mov	al,GrowLimit		;max number of handles
	cmp	ah,al			;is it already more than limit ?
	jae	GrowSFTToMaxRet		;no need to grow any more.

ifdef WOW
	xchg	ah,al
	xor	ah,ah
	Debug_Out "GrowSFTToMax: At least 128 files handles required in CONFIG.SYS only specified #AX"
	jmp	ExitKernel
else
	sub	al,ah			;al has the no of extra handles
	xor	ah,ah			;ax has no of extra handles
	mov	NewHandles,ax		;save it.
	mul	FileEntrySize		;dx:ax has size of table
	add	ax,(SIZE SFT) - 1	;size of the initial header
	mov	NewTableSize,ax		;save size
	regptr	dxax,dx,ax

	save	<es,bx>
	cCall	GlobalDOSAlloc,<dxax>	;allocate the block
	jcxz	GrowSFTToMaxRet		;no memory to allocate

	cCall	SetOwner,<ax,hExeHead>

; store the pointer to the new link in the current link.

	push	bx			;save
	mov	bx,ax			;get the new selector
	call	GetSelectorSegment	;returns segment of sel in ax, in dx
	pop	bx			;restore 
	mov	word ptr es:[bx].sftLink[2],dx
	mov	word ptr es:[bx].sftLink[0],0

; we have to save the address of this last original link so that it can be
; restored to be the last at DisableKernel time. We will save the current 
; selector and delete it at disable time

	mov	word ptr [pSftLink],bx	;save
	mov	word ptr [pSftLink+2],es

	mov	bx,es			;get the selector
	mov	es,ax			;es points to new link

; initialize memory tp all zeros

	xor	di,di			;es:di points to new buffer
	mov	cx,NewTableSize		;size of buffer
	xor	al,al			;want to initialize to 0's
	rep	stosb			;initialized

; prepare the header for the new table.

	xor	bx,bx			;es:bx points to the new table
	mov	cx,-1			;link terminator code
	mov	word ptr es:[bx].sftLink[2],cx
	mov	word ptr es:[bx].sftLink[0],cx
	mov	cx,NewHandles		;# of handles in this node
	mov	es:[bx].sftCount,cx
endif; WOW

GrowSFTToMaxRet:

cEnd
;----------------------------------------------------------------------------;
; SetSelectorBaseLim64k:						     ;
;									     ;
; Given a selector value in bx and a real mode lptr in cx:dx, it sets the ba-;
; -se of the selector to that value and sets it to be a 64k data segment. AX ;
; is preserved.								     ;
;									     ;
;----------------------------------------------------------------------------;

SetSelectorBaseLim64k	proc  near

	push	ax			;save

; calculate the linear base address.

	xor	ax,ax			;will have high nibble of shift
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	add	cx,dx			;add in the offset
	adc	ax,0			;ax:cx has the base
	mov	dx,cx			;get into proper registers
	mov	cx,ax			;cx:dx has the base
	mov	ax,7			;set selector base code
	int	31h			;the base of the selector has been set
	inc	ax			;set selector limit code
	mov	dx,-1			;64-1k limit
	xor	cx,cx			;cx:dx=64-1k
	int	31h			;limit set to 64-1k

	pop	ax			;restore ax
	ret

SetSelectorBaseLim64k endp
;----------------------------------------------------------------------------;
; GetSelectorSegment:							     ;
;									     ;
; Given a slector in bx pointing to DOS memory, this function returns the    ;
; real mode segment value in DX. AX,BX is preserved.			     ;
;----------------------------------------------------------------------------;

GetSelectorSegment  proc near

	push	ax			;save
	push	bx			;save
	mov	ax,6			;get selector base
	int	31h			;cx:dx has base
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	pop	bx			;restore
	pop	ax			;dx has segment value
	ret

GetSelectorSegment endp
;----------------------------------------------------------------------------;


sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\fixexe.c ===
/***	FIXEXE.C
 *
 *	Copyright (c) 1991 Microsoft Corporation
 *
 *	DESCRIPTION
 *	Patches specified .EXE file as required to load Windows KERNEL.EXE
 *	Removes requirement for LINK4 from Build
 *	It also produces same effect as EXEMOD file /MAX 0
 *
 *	Set DOS .EXE size to size of file +512
 *	Set MAX alloc to Zero
 *
 *
 *	MODIFICATION HISTORY
 *	03/18/91    Matt Felton
 */

#define TRUE 1

#include <stdio.h>


main(argc, argv)
int argc;
char **argv;
{
    FILE *hFile;
    long lFilesize;
    int iLengthMod512;
    int iSizeInPages;
    int iZero;

    iZero= 0;

    if (argc == 1)
	fprintf(stderr, "Usage: fixexe [file]\n");

    while (++argv,--argc) {
	hFile = fopen(*argv, "rb+");
	if (!hFile) {
	    fprintf(stderr, "cannot open %s\n", *argv);
	    continue;
	}
	printf("Processing %s\n", *argv);

	/* calculate the .EXE file size in bytes */

	fseek(hFile, 0L, SEEK_END);
	lFilesize = ftell(hFile);
	iSizeInPages = (lFilesize + 511) / 512;
	iLengthMod512 = lFilesize % 512;

	printf("Filesize is %lu bytes, %i pages, %i mod\n",lFilesize,iSizeInPages,iLengthMod512);

	/* set DOS EXE File size to size of file + 512 */
	fseek(hFile, 2L, SEEK_SET);
	fwrite( &iLengthMod512, sizeof(iLengthMod512), 1, hFile );
	fwrite( &iSizeInPages, sizeof(iSizeInPages), 1, hFile );

	/* Now perform EXEMOD file /MAX 0 equivalent */
	fseek(hFile, 12L, SEEK_SET);
	fwrite( &iZero, sizeof(iZero), 1, hFile);

	fclose(hFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\gpcont.asm ===
; GPCont.asm - code to allow continuation after GP faults

.xlist
include kernel.inc
include newexe.inc	; ne_restab
include gpcont.inc
.list

if SHERLOCK

FAULTSTACKFRAME struc

fsf_BP		dw	?	; Saved BP
fsf_msg		dw	?	; Near pointer to message describing fault
fsf_prev_IP	dw	?	; IP of previous fault handler
fsf_prev_CS	dw	?	; CS of previous fault handler
fsf_ret_IP	dw	?	; DPMI fault handler frame follows
fsf_ret_CS	dw	?
fsf_err_code	dw	?
fsf_faulting_IP dw	?
fsf_faulting_CS dw	?
fsf_flags	dw	?
fsf_SP		dw	?
fsf_SS		dw	?

FAULTSTACKFRAME ends

fsf_DS	equ	word ptr -10
fsf_ES	equ	word ptr -10
fsf_FS	equ	word ptr -10
fsf_GS	equ	word ptr -10

;flag bits set in gpRegs
strCX	=	1
strSI	=	2
strDI	=	4
segDS	=	8
segES	=	16
segFS	=	32
segGS	=	64


ifdef WOW
sBegin  MISCCODE

externFP DisAsm86

    assumes ds,nothing
    assumes es,nothing

;-----------------------------------------------------------------------;
; allows DisAsm86 to be called from _TEXT code segment
cProc Far_DisAsm86,<PUBLIC,FAR>,<dx>
    parmD   cp
cBegin
    mov     ax,cp.off
    mov     dx,cp.sel
    cCall   <far ptr DisAsm86>,<dx,ax>
cEnd

sEnd MISCCODE
endif ;; WOW



DataBegin
externB szGPCont
szKernel db	6,'KERNEL'
szUser	db	4,'USER'
szDrWatson db	'DRWATSON'


externW	gpTrying	; retrying current operation
externW gpEnable	; user has enabled GP continue
externW gpSafe		; current instruction is safe
externW gpInsLen	; length of faulting instruction
externW gpRegs		; bit field of modified regs
externD	pSErrProc	; pointer to SysErrBox in USER
DataEnd

externFP IsBadCodePtr
externFP FarFindExeInfo

sBegin	CODE
assumes	CS,CODE

ifndef WOW
externNP DisAsm86
endif
externNP GetOwner

;extern int far pascal SysErrorBox(char far *text, char far *caption,
;		int b1, int b2, int b3);
SEB_OK         = 1	; Button with "OK".
SEB_CANCEL     = 2	; Button with "Cancel"
SEB_YES        = 3	; Button with "&Yes"
SEB_NO         = 4	; Button with "&No"
SEB_RETRY      = 5	; Button with "&Retry"
SEB_ABORT      = 6	; Button with "&Abort"
SEB_IGNORE     = 7	; Button with "&Ignore"
SEB_CLOSE      = 8	; Button with "Close"
SEB_DEFBUTTON  = 8000h	; Mask to make this button default

SEB_BTN1       = 1	; Button 1 was selected
SEB_BTN2       = 2	; Button 1 was selected
SEB_BTN3       = 3	; Button 1 was selected

;Name:	int PrepareToParty(char *modName)
;Desc:	Checks whether we can continue the current app by skipping an
;	instruction.  If so, it performs the side effects of the
;	instruction.  This must be called after a call to DisAsm86() has
;	set the gpXxxx global vars.
;Bugs:	Should do more checking, should check for within a device driver,

cProc PrepareToParty,<PUBLIC,NEAR>,<si,di>
	parmD	modName
	parmD	appName
cBegin
	ReSetKernelDS

	mov	ax, [gpEnable]		; User enabled continue
	test	ax, 1			; We know how to continue
	jz	ptp_poop

	cld
	dec	[modName.off]		; include length byte in compare
	les	di, [modName]

	test	ax, 4			; can continue in KERNEL?
	jnz	@F
	lea	si, szKernel
	mov	cx, 7
	repe	cmpsb
	jz	ptp_poop		; fault in Kernel is fatal

@@:	test	ax, 8			; can continue in USER?
	jnz	@F
	mov	di, modName.off
	lea	si, szUser
	mov	cx, 5
	repe	cmpsb
	jz	ptp_poop		; fault in User is fatal

@@:	cmp     [gpTrying], 0
	jne	ptp_exit		; AX != 0 - do it again

	cmp	pSErrProc.sel, 0	; Is USER loaded?
	je	ptp_poop

	mov	ax, dataoffset szGPCont
	mov	bx, SEB_CLOSE or SEB_DEFBUTTON	; dumb cmacros
	cCall	[pSErrProc],<ds, ax, appName, bx, 0, SEB_IGNORE>
	cmp	ax, SEB_BTN3
	jne	ptp_poop
;	mov	[gpTrying], 100
	jmps	ptp_exit		; AX != 0

ptp_poop:				; every party needs a pooper
	xor	ax, ax
ptp_exit:
cEnd
	UnSetKernelDS


cProc	SafeDisAsm86,<NEAR,PUBLIC>
	parmD	cp
cBegin
	ReSetKernelDS
	mov	[gpSafe], 0		; assume unsafe

	mov	bx, cp.off		; make sure we can disassemble
	add	bx, 10			; at least a 10-byte instruction
	jc	sda_exit		; offset wrap-around - failed

	cCall	IsBadCodePtr,<seg_cp, bx>
	or	ax, ax
	jnz	sda_exit

ifdef WOW
	cCall	<far ptr Far_DisAsm86>,<cp>
else
	cCall	DisAsm86,<cp>
endif
	mov	[gpInsLen], ax
sda_exit:
cEnd


; return value in DX:AX and ES:AX (your choice), sets Z flag if failure
cProc	FindSegName,<NEAR,PUBLIC>,<ds>
	parmW	segval
cBegin
	cCall	GetOwner,<segval>
	mov	dx, ax
	or	ax, ax
	jz	fsn_exit
	mov	es, ax
	mov	ax, es:[ne_restab]
	inc	ax
fsn_exit:
cEnd

	public	GPContinue
GPContinue proc	near
	push	si			; instruction length
	test	[gpEnable], 1
	jz	s_fail

	cCall	SafeDisAsm86,<[bp].fsf_faulting_CS,[bp].fsf_faulting_IP>
	test	[gpSafe], 1
	jz	s_fail

	push	ds
	push	dataoffset szDrWatson
	push	8
	Call	FarFindExeInfo
	or	ax, ax
	jnz	s_fail

	cCall   FindSegName,<[bp].fsf_faulting_CS>
	jz	s_fail
	push	dx
	push	ax

	cCall	FindSegName,<[bp].fsf_SS>
	jz	s_fail4
	push	dx
	push	ax

	cCall   PrepareToParty
	or	ax, ax
	jz	s_fail

; Perform side-effects

	mov	ax, [gpRegs]		; Invalid value to DS?
	test	ax, segDS
	jz	@F
	mov	[bp].fsf_DS, 0

@@:	test	ax, segES               ; Invalid value to ES?
	jz	@F
	mov	[bp].fsf_ES, 0

if PMODE32
	.386p
@@:	xor	bx, bx                  ; Invalid value to FS?
	test	ax, segFS
	jz	short @F
	mov	fs, bx

@@:	test	ax, segGS               ; Invalid value to GS?
	jz	short @F
	mov	gs, bx
	.286p
endif
@@:
	test	ax, 0
; check other reg side effects
	mov	bx, [gpInsLen]		; Fixup IP for instruction length
	add	[bp].fsf_faulting_IP, bx
	mov	ax, 1
	jmps	s_end

s_fail4:
	add	sp, 4
s_fail:
	xor	ax, ax
s_end:
	pop	si
	ret
GPContinue endp

sEnd	CODE



endif		; SHERLOCK
	end

    regs.ip += faultlen;		/* set at top of func - don't reuse
    if ((int)gpStack < 0) {
      for (i=0; i<8; i++) stack[i+gpStack] = stack[i];
    } else if (gpStack) {
      for (i=7; i>=0; i--) stack[i+gpStack] = stack[i];
    }
    regs.sp += gpStack << 1;
    if (gpRegs & strCX) {
      len = regs.cx * memSize;
      regs.cx = 0;
    } else len = memSize;
    if (gpRegs & strSI) {		/* doesn't handle 32 bit regs
      regs.si += len;
      if (regs.si < (word)len)		/* if overflow, set to big value
	regs.si = 0xfff0;		/* so global vars in heap don't get
    }					/* trashed when we continue
    if (gpRegs & strDI) {
      regs.di += len;
      if (regs.di < (word)len) regs.di = 0xfff0;
    }
  }

  return party;
} /* Sherlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\gpcont.inc ===
ifndef PM386
	SHERLOCK = 0
  else
	SHERLOCK = 1
  endif



;  SHERLOCK = PM386	; GPContinue only on Krnl386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\gacheck.asm ===
.xlist
include kernel.inc
.list

if KDEBUG

DataBegin

externB  fBooting
externW	 pGlobalHeap
;externW  hGlobalHeap

DataEnd

sBegin	CODE
assumes	CS,CODE

externW  gdtdsc

externNP check_lru_list
externNP check_free_list
externNP get_physical_address

;externFP ValidateFreeSpaces


;-----------------------------------------------------------------------;
; CheckGlobalHeap                                                       ;
; 									;
; The Global Heap is checked for consistency.  First the forward links	;
; are examined to make sure they lead from the hi_first to the hi_last.	;
; Then the backward links are checked to make sure they lead from the	;
; hi_last to the hi_first.  Then the arenas are sequentially checked	;
; to see that the moveable entries point to allocated handles and that	;
; said handles point back.  The handle table is then checked to see	;
; that the number of used handles match the number of referenced	;
; handles, and that the number of total handles matches the sum of the	;
; free, discarded, and used handles.  Finally the free list of handles	;
; is checked.								;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	CF = 0 everything is just fine					;
;	all registers preserved						;
; 									;
; Error Returns:							;
;	CF = 1								;
;	DX = offending arena header					;
;	AX = 01h Forward links invalid					;
;	     02h Backward links invalid					;
;	     04h ga_handle points to free handle			;
;	     08h arena points to handle but not vice versa		;
;	     80h ga_sig is bad						;
;	DX = 0								;
;	AX = 10h allocated handles don't match used handles		;
;	     20h total number of handles don't match up			;
;	     40h total number of free handles don't match up		;
;									;
; Registers Preserved:							;
;	All								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Nov 01, 1986 02:16:46p  -by-  David N. Weise   [davidw]          ;
; Rewrote it from C into assembly.					;
;-----------------------------------------------------------------------;

cProc	CheckGlobalHeap,<PUBLIC,NEAR>
cBegin nogen
	push	ax
	push	dx
	push	bx
	push	cx
	push	di
	push	si
	push	ds
	push	es

	xor	ax,ax
	xor	dx,dx
	xor	di,di
	SetKernelDS
	cmp	pGlobalHeap,di
	jnz	there_is_a_GlobalHeap
	jmp	all_done
there_is_a_GlobalHeap:
	cmp	fBooting, 1
	jz	no_check
	mov	ds,pGlobalHeap
	UnSetKernelDS
	cmp	[di].hi_check,di
	jnz	checking_enabled
no_check:
	jmp	all_done
checking_enabled:
	mov	cx,[di].hi_count
	mov	dx,[di].hi_first
	mov	es, dx
forward_ho:
	push	cx
	cCall	get_physical_address, <es>
	add	ax, 10h
	adc	dx, 0
	mov	bx, es:[di].ga_size
	xor	cx, cx
rept 4
	shl	bx, 1
	rcl	cx, 1
endm
	cmp	es:[di].ga_owner, di
	je	no_limit_check
	cmp	es:[di].ga_handle, di
	je	no_limit_check
	push	bx
	push	cx
	push	si
	push	ds
	smov	ds, gdtdsc
	mov	si, es:[di].ga_handle
	sel_check	si
	sub	bx, 1
	sbb	cx, 0
	or	cx, cx				; More than 1 selector?
	jz	@F  
	mov	bx, -1
@@:
	cmp	[si], bx
	jne	bad_limit
	mov	ch, [si+6]
	and	cx, 0F0Fh
	cmp	ch, cl
	je	ok_limit
bad_limit:
	Debug_Out "gacheck: Bad limit for #SI"
ok_limit:
	pop	ds
	pop	si
	pop	cx
	pop	bx
no_limit_check:

	cmp	es:[di].ga_owner,GA_NOT_THERE	;286pmode has some of these
	jnz	check_size			;  with 0 size
	pop	cx
	jmp	short size_ok

check_size:
	add	bx, ax
	adc	cx, dx
	cCall	get_physical_address, <es:[di].ga_next>
	cmp	cx, dx
	pop	cx
	mov	dx, es
	xchg	ax, dx
	jne	forward_size_mismatch
	cmp	dx, bx
	jne	forward_size_mismatch

size_ok:
	mov	ax, es
	mov	dx, es:[di].ga_next
	mov	es, dx
	cmp	ax, es:[di].ga_prev
	jz	size_and_next_match
forward_size_mismatch:
	cmp	cx,1
	jnz	forward_links_invalid
size_and_next_match:
	loop	xxxx
	cmp	ax,[di].hi_last
	jz	forward_links_okay
forward_links_invalid:
	Debug_Out "gacheck: Forward links invalid"
	mov	dx,ax
	mov	ax,1
	jmp	all_done
xxxx:
	jmp	forward_ho

forward_links_okay:

	xor	ax, ax
clear_dx_all_done:
	xor	dx,dx
all_done:
	pop	es
	pop	ds
	pop	si
	pop	di
	pop	cx
	pop	bx
	or	ax,ax
	jnz	cgh_error
	pop	dx
	pop	ax
	ret
cgh_error:
	int	3
	add	sp,4
	stc
	ret
cEnd nogen

sEnd	CODE

endif

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\enable.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
include eems.inc
ifdef WOW
include vint.inc
endif
.list

externFP KillLibraries
ifndef WOW
externFP WriteOutProfiles
endif

DataBegin

externB PhantArray
externB kernel_flags
externB fBreak
externB fInt21
ifndef WOW
externB fProfileMaybeStale
endif
externW curTDB
externW headPDB
externW topPDB
ife PMODE32
externW hXMMHeap
endif
externD lpInt21
externD pSftLink
externD lpWinSftLink
externD pSysProc
externD pMouseTermProc
externD pKeyboardTermProc
externD pSystemTermProc
externW MyCSAlias

externD myInt2F

if ROM
externD prevInt00Proc
externD prevInt21Proc
externD prevInt24Proc
externD prevInt2FProc
externD prevInt3FProc
externD prevInt67Proc
externD prevInt02Proc
externD prevInt04Proc
externD prevInt06Proc
externD prevInt07Proc
externD prevInt3EProc
externD prevInt75Proc
externD prevInt0CProc
externD prevInt0DProc
externD prevIntx6Proc
externD prevInt0EProc
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes ds, nothing
assumes es, nothing

ife ROM
externD prevInt00Proc
externD prevInt21Proc
externD prevInt24Proc
externD prevInt2FProc
externD prevInt3FProc
externD prevInt67Proc
externD prevInt02Proc
externD prevInt04Proc
externD prevInt06Proc
externD prevInt07Proc
externD prevInt3EProc
externD prevInt75Proc
externD prevInt0CProc
externD prevInt0DProc
externD prevIntx6Proc
externD prevInt0EProc
ifdef WOW
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
endif
endif


if ROM
externFP PrevROMInt21Proc
endif

externNP real_DOS
externNP Enter_gmove_stack
externNP TerminatePDB

;-----------------------------------------------------------------------;
; InternalEnableDOS
;
;
; Entry:
;       none
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 21-Sep-1989 20:44:48  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

SetWinVec  MACRO   vec
        externFP Int&vec&Handler
        mov     dx, codeoffset Int&vec&Handler
        mov     ax, 25&vec&h
        pushf
if ROM
        call    PrevROMInt21Proc
else
        call    prevInt21Proc
endif
        endm

        assumes ds, nothing
        assumes es, nothing

cProc   InternalEnableDOS,<PUBLIC,FAR>
cBegin  nogen

        push    si
        push    ds
        SetKernelDS

        mov     al,1
        xchg    al,fInt21               ; set hook count to 1
        or      al,al                   ; was it zero?
        jz      @f
        jmp     ena21                   ; no, just leave
@@:

; now link back nodes to SFT if kernel had done it before. InternalDisableDOS
; saves the link in the DWORD variable lpWinSftLink. If this variable is NULL
; then either this is the first time InternalEnableDOS is being called or
; else the SFT had not been grown.

        cmp     lpWinSftLink.sel,0      ;was it allocated ?
        jz      @f                      ;no.
        push    ds                      ;save
        mov     cx,lpWinSftLink.sel     ;get the selector
        mov     dx,lpWinSftLink.off     ;get the offset
        lds     bx,[pSftLink]           ;place where we hooked new entry
        mov     word ptr ds:[bx][0],dx  ;restore offset
        mov     word ptr ds:[bx][2],cx  ;restore segment
        pop     ds                      ;restore data segment
@@:


; WARNING!! The ^C setting diddle MUST BE FIRST IN HERE......
;   If you do some other INT 21 call before this you will have
;   a "^C window", so don't do it....

        mov     ax,3301h                ; disable ^C checking
        mov     dl,0
        call    real_DOS

        mov     bx,TopPDB
        mov     ah,50h
        call    real_DOS                ; This way, or TDB_PDB gets set wrong

ifndef WOW
ends1:  mov     ah,6                    ; clean out any pending keys
        mov     dl,0FFh
        call    real_DOS
        jnz     ends1
endif

        mov     es,curTDB
        mov     bx,es:[TDB_PDB]
        mov     ah,50h
        int     21h

        push    ds
        lds     dx,myInt2F
        mov     ax,252Fh
        int     21h

        smov    ds,cs                   ; Pick up executable sel/seg
        UnSetKernelDS
        SetWinVec 24
        SetWinVec 00
        SetWinVec 02
        SetWinVec 04
        SetWinVec 06
        SetWinVec 07
        SetWinVec 3E
        SetWinVec 75
        pop     ds
        ReSetKernelDS

        mov     bx,2                    ; 2 = Enable/Disable one drive logic
        xor     ax,ax                   ; FALSE = Disable
        cCall   [pSysProc],<bx,ax>      ; NOTE: destroys ES if DOS < 3.20

; Set up the PhantArray by calling inquire system for each drive letter

        mov     bx,dataOffset PhantArray + 25   ; Array index
        mov     cx,26                           ; Drive #
SetPhant:
        dec     cx
        push    cx
        push    bx
        mov     dx,1                            ; InquireSystem
        cCall   [pSysProc],<dx,cx>
        pop     bx
        pop     cx
        mov     byte ptr [bx],0                 ; Assume not Phantom
        cmp     ax,2
        jae     NotPhant                        ; Assumption correct
;       or      dx,dx                           ; Drive just invalid?
;       jz      NotPhant                        ; Yes, assumption correct
        mov     byte ptr [bx],dl                ; Drive is phantom
NotPhant:
        dec     bx                              ; Next array element
        jcxz    phant_done
        jmp     SetPhant
phant_done:

        lds     dx,lpInt21
        UnSetKernelDS
        mov     ax,2521h
        int     21h
ena21:
        pop     ds
        pop     si
        ret
cEnd    nogen



;-----------------------------------------------------------------------;
; InternalDisableDOS                                                    ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 16, 1989 11:04:50  -by-   Amit Chatterjee  [amitc]           ;
;  InternalDisableDOS now takes away any nodes that kernel would have   ;
;  added to the SFT. InternalEnableDOS puts the nodes backs. Previously ;
;  the delinking was done by DisableKernel, but no one linked it back!  ;
;                                                                       ;
;  Sat May 09, 1987 02:00:52p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;                                                                       ;
;  Thu Apr 16, 1987 11:32:00p  -by-    Raymond E. Ozzie  [-iris-]       ;
; Changed InternalDisableDOS to use real dos for 52h function, since    ;
; DosTrap3 doesn't have 52h defined and PassOnThrough will croak if the ;
; current TDB's signature is 0, as it is during exit after the last     ;
; task has been deleted.                                                ;
;-----------------------------------------------------------------------;

ReSetDOSVec  MACRO   vec
        lds     dx,PrevInt&vec&proc
        mov     ax,25&vec&h
        int     21h
        endm

        assumes ds, nothing
        assumes es, nothing

cProc   InternalDisableDOS,<PUBLIC,FAR>
cBegin
        SetKernelDS     es
        xor     ax,ax
        xchg    al,fInt21               ; set hook count to zero
        or      al,al                   ; was it non zero?
        jnz     @F
        jmp     dis21                   ; no, just leave
@@:
        mov     bx,2                    ; 2 = Enable/Disable one drive logic
        mov     ax,1                    ; TRUE = Enable
        push    es
        cCall   pSysProc,<bx,ax>
        pop     es

        mov     ax,3301h                ; disable ^C checking
        mov     dl,0
        pushf
ife PMODE32
        FCLI
endif
        call    [prevInt21Proc]

        mov     ax,2521h
        lds     dx,prevInt21Proc
        pushf
ife PMODE32
        FCLI
endif
        call    [prevInt21Proc]

        push    es
        mov     ax,352Fh
        int     21h
        mov     ax,es
        pop     es
        mov     myInt2F.sel,ax
        mov     myInt2F.off,bx

        ReSetDOSVec 00                  ; as a favor in win2 we restored this
        ReSetDOSVec 24
        ReSetDOSVec 2F
        ReSetDOSVec 02
        ReSetDOSVec 04
        ReSetDOSVec 06
        ReSetDOSVec 07
        ReSetDOSVec 3E
        ReSetDOSVec 75

        mov     dl,fBreak               ; return state of ^C checking
        mov     ax,3301h
        int     21h

dis21:
cEnd

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  EnableDOS

EnableDOS       Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call EnableDOS"
endif
        retf

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  DisableDOS

DisableDOS      Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call DisableDOS"
endif
        retf

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  EnableKernel

EnableKernel    Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call EnableKernel"
endif
        retf


;-----------------------------------------------------------------------;
; DisableKernel                                                         ;
;                                                                       ;
; This call is provided as a Kernel service to applications that        ;
; wish to totally unhook Windows in order to do something radical       ;
; such as save the state of the world and restore it at a later         ;
; time.  This is similar in many ways to the way OLDAPP support         ;
; works, with the addition that it also unhooks the kernel.             ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat May 09, 1987 02:34:35p  -by-  David N. Weise    [davidw]         ;
; Merged changes in.  Most of this came from ExitKernel.                ;
;                                                                       ;
;  Tue Apr 28, 1987 11:12:00a  -by-  R.E.O. SpeedWagon [-????-]         ;
; Changed to indirect thru PDB to get JFN under DOS 3.x.                ;
;                                                                       ;
;  Mon Apr 20, 1987 11:34:00p  -by-  R.E.O. SpeedWagon [-????-]         ;
; Set PDB to topPDB before final int 21/4C; we were sometimes exiting   ;
; with a task's PDB, and thus we came back to ExitCall2 instead of      ;
; going back to DOS!                                                    ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   DisableKernel,<PUBLIC,FAR>,<si,di>
cBegin

        SetKernelDS
        or      Kernel_flags[2],KF2_WIN_EXIT    ; prevent int 24h dialogs
        cmp     prevInt21Proc.sel,0
        je      nodisable
        call    InternalDisableDOS
nodisable:

        SetKernelDS
        mov     ax,0203h                ; Reset not present fault.
        mov     bl,0Bh
        mov     cx,prevInt3Fproc.sel
        mov     dx,prevInt3Fproc.off
        int     31h

        mov     ax,0203h                ; Reset stack fault.
        mov     bl,0Ch
        mov     cx,prevInt0Cproc.sel
        mov     dx,prevInt0Cproc.off
        int     31h

        mov     ax,0203h                ; Reset GP fault.
        mov     bl,0Dh
        mov     cx,prevInt0Dproc.sel
        mov     dx,prevInt0Dproc.off
        int     31h

        mov     ax,0203h                ; Reset invalid op-code exception.
        mov     bl,06h
        mov     cx,prevIntx6proc.sel
        mov     dx,prevIntx6proc.off
        int     31h

        mov     ax,0203h                ; Reset page fault.
        mov     bl,0Eh
        mov     cx,prevInt0Eproc.sel
        mov     dx,prevInt0Eproc.off
        int     31h

ifdef WOW
        mov     ax,0203h                ; Reset divide overflow traps
        mov     bl,00h
        mov     cx,oldInt00proc.sel
        mov     dx,oldInt00proc.off
        int     31h

        mov     ax,0203h                ; Reset single step traps
        mov     bl,01h
        mov     cx,prevInt01proc.sel
        mov     dx,prevInt01proc.off
        int     31h

        mov     ax,0203h                ; Reset breakpoint traps
        mov     bl,03h
        mov     cx,prevInt03proc.sel
        mov     dx,prevInt03proc.off
        int     31h
endif

        mov     dx, [HeadPDB]
        SetKernelDS     es
        UnSetKernelDS
exk1:
        mov     ds,dx
        cmp     dx, [topPDB]            ; Skip KERNEL, he is about to get
        je      exk3                    ; a 4C stuffed down his throat

        push    ds
        call    TerminatePDB
        pop     ds

exk3:
        mov     dx,ds:[PDB_Chain]       ; move to next PDB in chain
        or      dx,dx
        jnz     exk1

        mov     bx,[topPDB]             ; set to initial DOS task PDB
        mov     ah,50h                  ; set PDB function
        int     21h
        and     Kernel_flags[2],NOT KF2_WIN_EXIT        ; prevent int 24h dialogs
;
; Close all files on Kernel's PSP, 'cause we're gonna shrink the SFT and
; quit ourselves afterwards.
;
        mov     ds,[topPDB]
        mov     cx,ds:[PDB_JFN_Length]
exk4:   mov     bx,cx                   ; close all file handles
        dec     bx
        cmp     bx,5                    ; console-related handle?
        jb      exk5                    ; yup, don't close it (AUX, etc.)
        mov     ah,3eh
        int     21h
exk5:   loop    exk4

; kernel could have added some nodes to the SFT. Delink them by removing
; the link from the last DOS link in the chain. We need to remember the 
; current pointer there so that InternalEnableDOS can put it back.

        lds     bx,[pSftLink]           ;place where we hooked new entry
        assumes ds,nothing
        mov     cx,ds                   ;this could have been unitialized too
        jcxz    exk6                    ;if unitialized, nothing to do
        mov     dx,ds:[bx].off          ;get the current offset
        mov     cx,ds:[bx].sel          ;get the current segment
        mov     ds:[bx].off,-1          ;remove windows SFT link
        mov     ds:[bx].sel, 0          ;remove windows SFT link
        mov     lpWinSftLink.off,dx     ;save the offset
        mov     lpWinSftLink.sel,cx     ;save the segment
exk6:

        UnSetKernelDS   es
cEnd

;------------------------------------------------------------------
;
; ExitKernel -- Bye, bye.
;
;------------------------------------------------------------------
ifndef WOW  ; If we are closing down WOW then we don't want to go back to the DOS Prompt
            ; We want to kill the NTVDM WOW Process - so we don't need/want this code.

        assumes ds, nothing
        assumes es, nothing

cProc   ExitKernel,<PUBLIC,FAR>
;       parmW   exitcode
cBegin  nogen
        SetKernelDS
        or      Kernel_flags[2],KF2_WIN_EXIT    ; prevent int 24h dialogs
        call    KillLibraries           ; Tell DLLs that the system is exiting

        mov     si,sp
        mov     si,ss:[si+4]            ; get exit code

; Call driver termination procs, just to make sure that they have removed
; their interrupt vectors.

        push    si
        mov     ax,word ptr [pMouseTermProc]
        or      ax,word ptr [pMouseTermProc+2]
        jz      trm0
        call    [pMouseTermProc]
        CheckKernelDS
trm0:   mov     ax,word ptr [pKeyboardTermProc]
        or      ax,word ptr [pKeyboardTermProc+2]
        jz      trm1
        call    [pKeyboardTermProc]
        CheckKernelDS
trm1:   mov     ax,word ptr [pSystemTermProc]
        or      ax,word ptr [pSystemTermProc+2]
        jz      trm2
        call    [pSystemTermProc]
        CheckKernelDS
trm2:   pop     si

        call    WriteOutProfiles
        mov     fProfileMaybeStale,1             ; Make sure we check the
                                                ;  INI file next time around
;;;     cCall   CloseCachedFiles,<topPDB>

; Close open files and unhook kernel hooks

; get on a stack that's not in EMS land

        call    Enter_gmove_stack

        cCall   DisableKernel
        CheckKernelDS

        cmp     si,EW_REBOOTSYSTEM      ; Reboot windows?
        jnz     exitToDos

ifndef WOW
if PMODE32
        mov     ax,1600h
        int     2Fh
        test    al,7Fh
        jz      NotRunningEnhancedMode
        cmp     al,1
        je      exitToDos               ;RunningWindows3862x
        cmp     al,-1
        je      exitToDos               ;RunningWindows3862x
        xor     di,di                   ; Zero return regs
        mov     es,di
        mov     bx,0009h                ; Reboot device ID
        mov     ax,1684h                ; Get device API entry point
        int     2Fh
        mov     ax,es
        or      ax,di
        jz      exitToDos               ; Reboot vxd not loaded. Exit to dos

        ; Call the reboot function
        mov     ax,0100h
        push    es
        push    di
        mov     bx,sp
        call    DWORD PTR ss:[bx]

        jmp     short exitToDos         ; Reboot didn't work just exit to dos

NotRunningEnhancedMode:
endif
endif ; WOW

        mov     ah, 0Dh                 ; Disk Reset so that Smartdrv etc buffers
        int     21h                     ; are written to disk

        mov     ax, 0FE03h              ; Flush Norton NCache
        mov     si, "CF"
        mov     di, "NU"
        stc                             ; Yes!  Really set carry too!
        int    2Fh

ifdef   NEC_98
        mov     al,92h
        out     37h,al
        mov     al,07h
        out     37h,al
        mov     al,0bh
        out     37h,al
        mov     al,0fh
        out     37h,al
        mov     al,08h
        out     37h,al
        out     50h,al

        mov     al,05h
        out     0a2h,al                         ; graph off
        out     62h,al                          ; text off

        xor     cx, cx
        loop    $
        loop    $
        loop    $
        loop    $
        mov     al, 00h
        out     0f0h, al                        ; CPU Reset
        jmp     $
else    ; NEC_98
        int     19h                     ; Reboot via int 19h
endif   ; NEC_98


exitToDos:
        mov     ax,si
        mov     ah,4Ch                  ; Leave Windows.
        int     21h
cEnd    nogen

endif   ; NOT WOW

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\gpfix.asm ===
; gpfix.asm - pointer validation routines

	include gpfix.inc
	include kernel.inc
	include tdb.inc
	include newexe.inc


sBegin  GPFIX0
__GP	label	word
;gpbeg   dw	0, 0, 0, 0	; for use in handler
public __GP
sEnd    GPFIX0

sBegin  GPFIX1
gpend	dw	0
sEnd    GPFIX1

sBegin DATA
;this segment is page locked and will be accessible during a GP fault
;has the names of modules that are allowed to use our funky GP fault handling
; mechanism. Format: length byte, module name. The table is zero-terminated.
gp_valid_modules label	byte
db	3, "GDI"
db	4, "USER"
db	6, "KERNEL"
db	6, "PENWIN"
db	7, "DISPLAY"
db	8, "MMSYSTEM"
db	0	;end of table
sEnd   DATA

ifdef DISABLE
sBegin	DATA
;ExternW wErrorOpts
sEnd	DATA
endif


;public  gpbeg, gpend


sBegin  CODE
assumes CS,CODE

externA __AHINCR

externNP GetOwner
externNP EntProcAddress
externFP GetExePtr
externFP SetSelectorLimit

;===============================================================
;
;
cProc   IsBadReadPtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmW	cb
cBegin
beg_fault_trap  BadRead1
	les	bx,lp		; check selector
	mov	cx,cb
	jcxz	ReadDone1
	dec	cx
	add	bx,cx
	jc      BadRead		; check 16 bit overflow
	mov	al,es:[bx]	; check read permission, limit
end_fault_trap
ReadDone1:
        xor     ax,ax
ReadDone:
cEnd

BadRead1:
	fault_fix_stack
BadRead:
        mov     ax,1
	jmp	short ReadDone

;===============================================================
;
;
cProc   IsBadWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmW	cb
cBegin
beg_fault_trap  BadWrite1
	les	bx,lp		; check selector
	mov	cx,cb
	jcxz	WriteDone1
	dec	cx
	add	bx,cx
	jc      BadWrite	; check 16 bit overflow
	or	es:byte ptr [bx],0 ; check write permission, limit
end_fault_trap
WriteDone1:
	xor     ax, ax
WriteDone:
cEnd

BadWrite1:
	fault_fix_stack
BadWrite:
	mov	ax,1
	jmp	short WriteDone

;===============================================================
; BOOL IsBadFlatReadWritePtr(VOID HUGE*lp, DWORD cb, WORD fWrite)
; This will validate a Flat pointer plus a special hack for Fox Pro
; to detect their poorly tiled selector (ie. all n selector with 
; limit of 64K) (Our tiling is such that you can access up to end of
; the block using any one of the intermediate selectors flat)
; if we detect such a case we will fix up the limit on the first sel
; so GDI can access all of the memory as a 1st_sel:32-bit offset

cProc	IsBadFlatReadWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD	cb
ParmW	fWrite
cBegin
beg_fault_trap  frp_trap
	les	bx,lp		; check selector
	.386p

	mov	eax,cb
	movzx	ebx, bx

	test	eax,eax		; cb == 0, all done.
	jz	frp_ok

	add	ebx,eax
	dec	ebx

	cmp	fWrite, 0
	jne	frp_write

	mov	al,es:[ebx]		; read last byte
	jmp	frp_ok

frp_write:
	or	byte ptr es:[ebx], 0	; write last byte

frp_ok:
	xor	ax,ax
end_fault_trap
frp_exit:
cEnd

frp_trap:
	fault_fix_stack
frp_bad:
	push	ebx
	mov	ecx, ebx			; get cb
	shr	ecx, 16				; get high word
	jecxz	frp_bade			; if < 64K then bad ptr

	mov	ax, es
	lsl	eax, eax			; get limit on 1st sel
	jnz	frp_bade			; bad sel?
	cmp	ax, 0ffffh			; 1st of poorly tiled sels?
	jne	frp_bade			; N: return bad ptr
	; now we have to confirm that this is indeed the first of a bunch
	; of poorly tiled sels and fix up the limit correctly of the first sel

	movzx	ebx, ax				; ebx = lim total of tiled sels
	inc	ebx				; make it 10000
	mov	dx, es

frp_loop:

	add	dx,__AHINCR			; next sel in array
	lsl	eax, edx
	jnz	frp_bade
	cmp	ecx, 1				; last sel?
	je	@f
	; if its not the last sel, then its limit has to be ffffh
	; otherwise it probably is not a poorly tiled sel.
	cmp	eax, 0ffffh
	jne	frp_bade
@@:
	add	ebx, eax			; upd total limit
	inc	ebx				; add 1 for middle sels

	loop	frp_loop
	dec	ebx				; take exact limit of last sel

	pop	edx				; get cb
	cmp	edx, ebx
	jg	frp_bade_cleaned

	; set limit of 1st sel to be ebx
	push	es
	push	ebx
	call	SetSelectorLimit

if KDEBUG
	mov	ax, es
	krDebugOut DEB_WARN, "Fixing poorly tiled selector #AX for flat access"
endif

	jmp	frp_ok


frp_bade:
	pop	ebx
frp_bade_cleaned:

	.286p
	mov	ax,1
	jmp	frp_exit

;===============================================================
; BOOL IsBadHugeReadPtr(VOID HUGE*lp, DWORD cb)
;
cProc   IsBadHugeReadPtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD   cb
cBegin
beg_fault_trap  hrp_trap
	les	bx,lp		; check selector

        mov     ax,off_cb
        mov     cx,seg_cb

        mov     dx,ax           ; if cb == 0, then all done.
        or      dx,cx
        jz      hrp_ok

        sub     ax,1            ; decrement the count
        sbb     cx,0

        add     bx,ax           ; adjust cx:bx by pointer offset
	adc     cx,0
	jc      hrp_bad 	; (bug #10446, pass in -1L as count)

	jcxz    hrplast         ; deal with leftover
hrploop:
        mov     al,es:[0ffffh]  ; touch complete segments.
        mov     dx,es
        add     dx,__AHINCR
        mov     es,dx
        loop    hrploop
hrplast:
        mov     al,es:[bx]
hrp_ok:
        xor     ax,ax
end_fault_trap
hrp_exit:
cEnd

hrp_trap:
	fault_fix_stack
hrp_bad:
	mov     ax,1
        jmp     hrp_exit

;===============================================================
; BOOL IsBadHugeWritePtr(VOID HUGE*lp, DWORD cb)
;
cProc   IsBadHugeWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD   cb
cBegin
beg_fault_trap  hwp_trap
	les	bx,lp		; check selector

        mov     ax,off_cb
        mov     cx,seg_cb

        mov     dx,ax           ; if cb == 0, then all done.
        or      dx,cx
        jz      hwp_ok

	sub     ax,1            ; decrement the count
	sbb     cx,0

	add     bx,ax           ; adjust cx:bx by pointer offset
	adc     cx,0
	jc      hwp_bad 	; (bug #10446, pass in -1L as count)

	jcxz    hwplast         ; deal with leftover
hwploop:
	or      byte ptr es:[0ffffh],0   ; touch complete segments.
	mov     dx,es
	add     dx,__AHINCR
	mov     es,dx
	loop    hwploop
hwplast:
	or      byte ptr es:[bx],0
hwp_ok:
	xor     ax,ax
end_fault_trap
hwp_exit:
cEnd

hwp_trap:
	fault_fix_stack
hwp_bad:
	mov     ax,1
        jmp     hwp_exit

;===============================================================
;
;
cProc	IsBadCodePtr,<PUBLIC,FAR,NONWIN>
ParmD	lpfn
cBegin
beg_fault_trap  BadCode1
	mov	cx,seg_lpfn
	lar	ax,cx
	jnz     BadCode		; Oh no, this isn't a selector!

	test	ah, 8
	jz	BadCode		; Oh no, this isn't code!

	mov	es,cx		; Validate the pointer
	mov	bx,off_lpfn
	mov	al,es:[bx]

end_fault_trap
	xor     ax, ax
CodeDone:
cEnd

BadCode1:
	fault_fix_stack
BadCode:
	mov	ax,1
	jmp	short CodeDone


;========================================================
;
; BOOL IsBadStringPtr(LPSTR lpsz, UINT cch);
;
cProc	IsBadStringPtr,<PUBLIC,FAR,NONWIN>,<DI>
ParmD   lpsz
ParmW   cchMax
cBegin
beg_fault_trap	BadStr1
	les	di,lpsz 	; Scan the string.
	xor	ax,ax
	mov	cx,-1
	cld
	repnz	scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,cchMax
        ja      BadStr          ; if string length > cchMax, then bad string.
bspexit:
cEnd

BadStr1:
	fault_fix_stack
BadStr:
        mov     ax,1
        jmp     bspexit

;-----------------------------------------------------------------------;
; HasGPHandler								;
; 									;
; See if GP fault handler is registered for faulting address.		;
;									;
; This scheme can only be used by registered modules. You register 	;
; a module by adding an entry containing a length byte followed by	;
; the module name in the gp_valid_modules table defined above.		;
; 									;
; Arguments:								;
;	parmD   lpFaultAdr						;
; 									;
; Returns:								;
;	AX = New IP of handler						;
;	AX = 0 if no handler registered					;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
; 	AX,BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetOwner							;
;	EntProcAddress							;
;									;
;	The __GP table has the format of 4 words per entry, plus a	;
;	zero word to terminate the table.  The 'seg' value should be	;
;	the actual selector (it must be fixed up by the linker),	;
;	and the offset values should be relative to the start of the	;
;	segment or group.  The handler must be in the same code segment	;
;	as the fault range (this ensures that the handler is present	;
;	at GP fault time).						;
;									;
;    __GP label word							;
;    public __GP							;
;	    seg, offset begin, offset end, handler      		;
;	    ... 							;
;	    0   							;
;       								;
;	The symbol '__GP' needs to be in the resident name table, so    ;
;	it should be added to the DEF file like this (with an   	;
;	appropriate ordinal value):     				;
;       								;
;	EXPORTS 							;
;	  __GP @??? RESIDENTNAME					;
;       								;
; 									;
; History:								;
;	?? Jun 91 Don Corbitt [donc] Wrote it				;
;	30 Jul 91 Don Corbitt [donc] Added support for __GP table	;
;-----------------------------------------------------------------------;


cProc	HasGPHandler,<PUBLIC,FAR,NONWIN>,<ds,si,di>
ParmD	lpfn
cBegin
	cCall	GetOwner, <SEG_lpfn>	; find owner of faulting code
	or	ax, ax
        jz      to_fail ;HH_fail

        lar     bx, ax                  ; make sure segment is present
	jnz	to_fail ;HH_fail
	test	bx, 8000h
	jz      to_fail ;HH_fail

        mov     es, ax
	cmp	es:[ne_magic], NEMAGIC
	jz	@f
to_fail:	
	jmp	HH_fail
@@:

	; check if the faulting module is allowed to use this scheme
	SetKernelDS
	mov	di, es:[ne_restab]
	mov	bx, di
	inc	bx		; save ptr to module name
	xor	cx,cx
	xor	ax,ax
	mov	si, offset gp_valid_modules
	mov	al, es:[di]
	cld
friend_or_fiend:
	mov	cl, [si]
	jcxz	HH_fail
	cmp	al,cl
	jnz	next_friend
	mov	di, bx		; need to keep restoring di
	inc	si		; skip len byte
	repe	cmpsb
	jz	we_know_this_chap
	dec	si		; point to the mismatch
next_friend:
	add	si, cx
	inc	si		
	jmp	short friend_or_fiend
we_know_this_chap:

	xor	cx, cx
	mov	si, es:[ne_restab]	; restore si
	jmp	short @F		; start in middle of code

HH_nextSym:
	add	si, cx			; skip name
	add	si, 3			; and entry point
@@:	mov	cl, es:[si]		; get length of symbol
	jcxz	HH_fail			; end of table - not found
	cmp	cl, 4			; name length
	jnz	HH_nextSym
	cmp	es:[si+1], '__'		; look for '__GP'
	jnz	HH_nextSym
	cmp	es:[si+3], 'PG'
	jnz	HH_nextSym
	mov	ax, es:[si+5]		; get ordinal for '__GP'
if	KDEBUG
        cCall   EntProcAddress,<es,ax,1>
else
	cCall	EntProcAddress,<es,ax>	; I hate conditional assembly....
endif
	mov	cx, ax
	or	cx, dx
	jz	HH_fail			; This shouldn't ever fail, but...

	lar	bx, dx			; make sure segment is present
	jnz	HH_fail
	test	bx, 8000h
	jz	HH_fail

	mov	ds, dx
	mov	si, ax
	mov	ax, SEG_lpfn
	mov	dx, OFF_lpfn
next_fault_val:
	mov	cx, [si]
	jcxz	HH_fail
	cmp	cx, ax			; does segment match?
	jnz	gp_mismatch
	cmp	[si+2], dx		; block start
	ja	gp_mismatch
	cmp	[si+4], dx		; block end
	jbe	gp_mismatch
	mov	ax, [si+6]		; get new IP
	jmp	short HH_done

gp_mismatch:
	add	si, 8
	jmp	short next_fault_val

HH_fail:
	xor	ax, ax
HH_done:
cEnd

;========================================================================
;
; BOOL IsSharedSelector(HGLOBAL h);
;
; Makes sure the given selector is shareable. Currently, we just check
; if it is owned by a DLL. We also need to check GMEM_SHARE bit but 
; this isn't saved...
;
cProc	IsSharedSelector,<PUBLIC,FAR,NOWIN>
ParmW   sharedsel
cBegin
	push	sharedsel
	call	GetExePtr
        or      ax,ax                   ; bogus handle: exit.
	jz	ISS_Done
	mov	es,ax
	xor	ax,ax
	test	es:[ne_flags],NENOTP
	jz	ISS_Done		; Not a DLL
	inc	ax			; Yup a DLL

ISS_Done:
cEnd

sEnd    CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\handle.asm ===
TITLE	HANDLE - Handle Table Manager



.xlist
include kernel.inc
.list

sBegin	CODE
assumes CS,CODE
;-----------------------------------------------------------------------;
; hthread 								;
; 									;
; Threads together a list of free handles.				;
;									;
; Arguments:								;
;	DI = start of chain						;
;	CX = #handle entries in chain					;
; 									;
; Returns:								;
;	AX = address of first handle entry on free list			;
;	CX = 0								;
;	DI = address of first word after handle block			;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Oct 27, 1986 10:09:23a  -by-  David N. Weise   [davidw]		;
; Restructured as a result of separating handle.asm and lhandle.asm.	;
; 									;
;  Tue Oct 14, 1986 04:11:46p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;									;
;  Wed Jul  8, 1987 14:36      -by-  Rick  N. Zucker  [rickz]		;
; changed to hthread from ghthead to be used by local handle entries    ;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	hthread,<PUBLIC,NEAR>
cBegin nogen
	push	di			; Save first free handle entry
	smov	es,ds
	cld
ht1:					; Chain entries together via he_link
	errnz	<he_link>
	errnz	<he_link - lhe_link>
	lea	ax,[di].SIZE HandleEntry
	stosw
	mov	ax,HE_FREEHANDLE
	errnz	<2 - he_flags>
	errnz	<he_flags - lhe_flags>
	stosw
	errnz	<4 - SIZE HandleEntry>
	errnz	<SIZE HandleEntry - SIZE LocalHandleEntry>
	loop	ht1
					; Null terminate free list
	mov	[di-SIZE HandleEntry].he_link,cx
	pop	ax			; Return free handle address
	ret
cEnd nogen

sEnd	CODE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\error.c ===
#include "kernel.h"

#define WINAPI _far _pascal _loadds
typedef unsigned int UINT;
typedef const char _far* LPCSTR;
typedef HANDLE HTASK;

#include "logerror.h"

int  WINAPI FatalExitC(WORD);
void WINAPI OutputDebugString(LPCSTR);

void DebugLogParamError(VOID FAR* param, FARPROC lpfn, WORD err);
void DebugLogError(WORD err, VOID FAR* lpInfo);
int  WINAPI GetOwnerName(WORD sel, char far *buf, WORD buflen);
int  WINAPI FarGetOwner(WORD sel);

#define CODESEG             _based(_segname("_CODE"))

#define SELECTOROF(lp)	    HIWORD(lp)
#define OFFSETOF(lp)        LOWORD((DWORD)lp)
#define MAKELONG(a, b)	    ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define MAKELP(sel, off)    ((VOID FAR *)MAKELONG(off, sel))

#if KDEBUG

UINT DebugOptions = 0;
UINT DebugFilter = 0;

#define FMT_WORD    0
#define FMT_DWORD   1
#define FMT_LP      2

struct TYPEMAP
{
    UINT err;
    char CODESEG* szType;       // Compiler bug: this can't be _based
    char CODESEG* szFmt;
};

static char CODESEG szParam[] = "parameter";
static char CODESEG szD16[] = "%s: Invalid %s: %d\r\n";
static char CODESEG szD32[] = "%s: Invalid %s: %ld\r\n";
static char CODESEG szX16[] = "%s: Invalid %s: %#04x\r\n";
static char CODESEG szX32[] = "%s: Invalid %s: %#08lx\r\n";
static char CODESEG szLP[]  = "%s: Invalid %s: %#04x:%#04x\r\n";

static char CODESEG sz_value[] = "value";
static char CODESEG sz_index[] = "index";
static char CODESEG sz_flags[] = "flags";
static char CODESEG sz_selector[] = "selector";
static char CODESEG sz_pointer[] = "pointer";
static char CODESEG sz_function_pointer [] = "function pointer";
static char CODESEG sz_string_pointer [] = "string pointer";
static char CODESEG sz_HINSTANCE[] = "HINSTANCE";
static char CODESEG sz_HMODULE[] = "HMODULE";
static char CODESEG sz_global_handle [] = "global handle";
static char CODESEG sz_local_handle [] = "local handle";
static char CODESEG sz_atom[] = "atom";
static char CODESEG sz_HWND[] = "HWND";
static char CODESEG sz_HMENU[] = "HMENU";
static char CODESEG sz_HCURSOR[] = "HCURSOR";
static char CODESEG sz_HICON[] = "HICON";
static char CODESEG sz_HGDIOBJ[] = "HGDIOBJ";
static char CODESEG sz_HDC[] = "HDC";
static char CODESEG sz_HPEN[] = "HPEN";
static char CODESEG sz_HFONT[] = "HFONT";
static char CODESEG sz_HBRUSH[] = "HBRUSH";
static char CODESEG sz_HBITMAP[] = "HBITMAP";
static char CODESEG sz_HRGN[] = "HRGN";
static char CODESEG sz_HPALETTE[] = "HPALETTE";
static char CODESEG sz_HANDLE[] = "HANDLE";
static char CODESEG sz_HFILE[] = "HFILE";
static char CODESEG sz_HMETAFILE[] = "HMETAFILE";
static char CODESEG sz_CID[] = "CID";
static char CODESEG sz_HDRVR[] = "HDRVR";
static char CODESEG sz_HDWP[] = "HDWP";

static char CODESEG*pszLP = szLP;
static char CODESEG*pszD32 = szD32;
static char CODESEG*pszX32 = szX32;

#define DEFMAP(err, type, fmt) \
    { err, type, fmt }
struct TYPEMAP CODESEG typemap[] =
{
    DEFMAP(ERR_BAD_VALUE,        sz_value,        szD16),
    DEFMAP(ERR_BAD_INDEX,        sz_index,        szD16),
    DEFMAP(ERR_BAD_FLAGS,        sz_flags,        szX16),
    DEFMAP(ERR_BAD_SELECTOR,     sz_selector,     szX16),
    DEFMAP(ERR_BAD_DFLAGS,       sz_flags,        szX32),
    DEFMAP(ERR_BAD_DVALUE,       sz_value,        szD32),
    DEFMAP(ERR_BAD_DINDEX,       sz_index,        szD32),
    DEFMAP(ERR_BAD_PTR,          sz_pointer,      szLP),
    DEFMAP(ERR_BAD_FUNC_PTR,     sz_function_pointer, szLP),
    DEFMAP(ERR_BAD_STRING_PTR,   sz_string_pointer, szLP),
    DEFMAP(ERR_BAD_HINSTANCE,    sz_HINSTANCE,    szX16),
    DEFMAP(ERR_BAD_HMODULE,      sz_HMODULE,      szX16),
    DEFMAP(ERR_BAD_GLOBAL_HANDLE,sz_global_handle, szX16),
    DEFMAP(ERR_BAD_LOCAL_HANDLE, sz_local_handle, szX16),
    DEFMAP(ERR_BAD_ATOM,         sz_atom,         szX16),
    DEFMAP(ERR_BAD_HWND,         sz_HWND,         szX16),
    DEFMAP(ERR_BAD_HMENU,        sz_HMENU,        szX16),
    DEFMAP(ERR_BAD_HCURSOR,      sz_HCURSOR,      szX16),
    DEFMAP(ERR_BAD_HICON,        sz_HICON,        szX16),
    DEFMAP(ERR_BAD_GDI_OBJECT,   sz_HGDIOBJ,      szX16),
    DEFMAP(ERR_BAD_HDC,          sz_HDC,          szX16),
    DEFMAP(ERR_BAD_HPEN,         sz_HPEN,         szX16),
    DEFMAP(ERR_BAD_HFONT,        sz_HFONT,        szX16),
    DEFMAP(ERR_BAD_HBRUSH,       sz_HBRUSH,       szX16),
    DEFMAP(ERR_BAD_HBITMAP,      sz_HBITMAP,      szX16),
    DEFMAP(ERR_BAD_HRGN,         sz_HRGN,         szX16),
    DEFMAP(ERR_BAD_HPALETTE,     sz_HPALETTE,     szX16),
    DEFMAP(ERR_BAD_HANDLE,       sz_HANDLE,       szX16),
    DEFMAP(ERR_BAD_HFILE,        sz_HFILE,        szX16),
    DEFMAP(ERR_BAD_HMETAFILE,    sz_HMETAFILE,    szX16),
    DEFMAP(ERR_BAD_CID,          sz_CID,          szX16),
    DEFMAP(ERR_BAD_HDRVR,        sz_HDRVR,        szX16),
    DEFMAP(ERR_BAD_HDWP,         sz_HDWP,         szX16)
};

int (_cdecl _far *wsprintf)(LPSTR, LPCSTR, ...) = NULL;
int (WINAPI *wvsprintf)(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams) = NULL;

#define ORD_WSPRINTF	420
#define ORD_WVSPRINTF   421

BOOL _fastcall LoadWsprintf(void)
{
    static char CODESEG rgchUSER[] = "USER";

    HANDLE hmod;

    hmod = GetModuleHandle(rgchUSER);

    if (!hmod)
	return FALSE;

    (FARPROC)wsprintf = GetProcAddress(hmod, MAKELP(NULL, ORD_WSPRINTF));
    (FARPROC)wvsprintf = GetProcAddress(hmod, MAKELP(NULL, ORD_WVSPRINTF));

    if (!SELECTOROF(wsprintf))
    {
        static char CODESEG rgch[] = "KERNEL: Can't call wsprintf: USER not initialized\r\n";
        OutputDebugString(rgch);
        return FALSE;
    }
    return TRUE;
}

typedef struct
{
    UINT flags;
    LPCSTR lpszFmt;
    WORD args[1];
} DOPARAMS;

#define BUFFERSLOP  32

BOOL DebugOutput2(DOPARAMS FAR* pparams)
{
    UINT flags = pparams->flags;
    BOOL fBreak = FALSE;
    BOOL fPrint = TRUE;
    char rgch[80*2 + BUFFERSLOP];    // max 2 lines (don't want to hog too much stack space)
    static char CODESEG szCRLF[] = "\r\n";
    char far *prefix, far *prefix1;

    switch (flags & DBF_SEVMASK)
    {
    case DBF_TRACE:
	// If the flags don't match the debug filter,
	// don't print the trace message.
	// If the trace matches the filter, check for TRACEBREAK.
	//
	prefix = "t ";
	if (!((flags & DBF_FILTERMASK) & DebugFilter))
	    fPrint = FALSE;
	else if (DebugOptions & DBO_TRACEBREAK)
	    fBreak = TRUE;
	break;

    case DBF_WARNING:
	prefix = "wn ";
	if (DebugOptions & DBO_WARNINGBREAK)
	    fBreak = TRUE;
	break;

    case DBF_ERROR:
	prefix = "err ";
	if (!(DebugOptions & DBO_NOERRORBREAK))
	    fBreak = TRUE;
	break;

    case DBF_FATAL:
	prefix = "fatl ";
	if (!(DebugOptions & DBO_NOFATALBREAK))
	    fBreak = TRUE;
	break;
    }

    // If DBO_SILENT is specified, don't print anything.
    //
    if (DebugOptions & DBO_SILENT)
	fPrint = FALSE;

    if ((lstrlen((LPSTR)pparams->lpszFmt) <= sizeof(rgch) - BUFFERSLOP) &&
            (SELECTOROF(wsprintf) || LoadWsprintf()) && (fPrint || fBreak))
    {
	int hinst = HIWORD(pparams);

	for (prefix1 = rgch; *prefix; ) *prefix1++ = *prefix++;
	prefix1 += GetOwnerName(hinst, prefix1, 16);
	*prefix1++ = ' ';
	wvsprintf(prefix1, pparams->lpszFmt, (void FAR*)pparams->args);
	OutputDebugString(rgch);
	OutputDebugString(szCRLF);
    }

    if (fBreak)
    {
        // If we are supposed to break with an int 3, then return TRUE.
        //
        if (DebugOptions & DBO_INT3BREAK)
            return TRUE;

        return FatalExitC(flags);
    }
    return FALSE;
}

BOOL LogParamError2(WORD err, FARPROC lpfn, VOID FAR* param, WORD caller)
{
    BOOL fBreak;

    fBreak = FALSE;
    if (err & ERR_WARNING)
    {
	if (DebugOptions & DBO_WARNINGBREAK)
	    fBreak = TRUE;
    }
    else
    {
	if (!(DebugOptions & DBO_NOERRORBREAK))
	    fBreak = TRUE;
    }

    // If we're not breaking and SILENT is specified, just return.
    //
    if (!fBreak && (DebugOptions & DBO_SILENT))
        return FALSE;

    if (SELECTOROF(wsprintf) || LoadWsprintf())
    {
	char rgch[128];
	char rgchProcName[50], far *rpn;
	char CODESEG* pszType;          // compiler bug: see above
	char CODESEG* pszFmt;
	int i, hinst;
	WORD errT;
	void FAR GetProcName(FARPROC lpfn, LPSTR lpch, int cch);
	char far *prefix1;

	GetProcName(lpfn, rgchProcName, sizeof(rgchProcName));
	  /* if we got a real proc name, then copy just the proc name */
	for (rpn = rgchProcName; *rpn && (*rpn != '(') && (*rpn != ':'); rpn++)
	  ;
	if (*rpn == ':') {
	  lstrcpy(rgchProcName, rpn+1);
	}

	pszFmt  = szX32;
	pszType = szParam;
	errT = (err & ~ERR_WARNING);
	for (i = 0; i < (sizeof(typemap) / sizeof(struct TYPEMAP)); i++)
	{
	    if (typemap[i].err == errT)
	    {
		pszFmt = typemap[i].szFmt;
		pszType = typemap[i].szType;
		break;
	    }
	}
        if (err & ERR_WARNING) {
	  lstrcpy(rgch, "wn ");
	  prefix1 = rgch+3;
	} else {
	  lstrcpy(rgch, "err ");
	  prefix1 = rgch+4;
	}
	hinst = HIWORD(prefix1);
	prefix1 += GetOwnerName(hinst, prefix1, 16);
	if (FarGetOwner(hinst) != FarGetOwner(caller)) {
	    *prefix1++ = '-';
	    *prefix1++ = '>';
	    prefix1 += GetOwnerName(caller, prefix1, 16);
	}
	*prefix1++ = ' ';

	if (pszFmt == pszLP)
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, SELECTOROF(param), OFFSETOF(param));
	else if (pszFmt == pszD32 || pszFmt == pszX32)
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, (DWORD)param);
	else
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, (WORD)(DWORD)param);

	OutputDebugString(rgch);
    }

    if (fBreak)
    {
        // If we are supposed to break with an int 3, then return TRUE.
        //
        if (DebugOptions & DBO_INT3BREAK)
            return TRUE;

        return FatalExitC(err);
    }
    return FALSE;
}

extern HTASK allocTask;
extern DWORD allocCount;
extern DWORD allocBreak;
extern char  allocModName[8];

void FAR _loadds SetupAllocBreak(HTASK htask);
char far* GetTaskModNamePtr(HTASK htask);

BOOL WINAPI IGetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags)
{
    int i;

    lpwdi->flags = flags;

    if (flags & WDI_OPTIONS)
        lpwdi->dwOptions = DebugOptions;

    if (flags & WDI_FILTER)
        lpwdi->dwFilter = DebugFilter;

    if (flags & WDI_ALLOCBREAK)
    {
        lpwdi->dwAllocBreak = allocBreak;
        lpwdi->dwAllocCount = allocCount;
        for (i = 0; i < 8; i++)
            lpwdi->achAllocModule[i] = allocModName[i];
    }
    return TRUE;
}

BOOL WINAPI ISetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi)
{
    int i;

    if (lpwdi->flags & WDI_OPTIONS)
        DebugOptions = (UINT)lpwdi->dwOptions;

    if (lpwdi->flags & WDI_FILTER)
        DebugFilter = (UINT)lpwdi->dwFilter;

    if (lpwdi->flags & WDI_ALLOCBREAK)
    {
        allocTask = NULL;
        allocBreak = lpwdi->dwAllocBreak;
        allocCount = 0;     // Always reset count to 0.

        for (i = 0; i < 8; i++)
            allocModName[i] = lpwdi->achAllocModule[i];

        {
            extern HTASK headTDB;
            HTASK htask;

            // Enumerate all current tasks to see if any match
            //
            #define TDB_next    0
            for (htask = headTDB; htask; htask = *((HTASK FAR*)MAKELP(htask, TDB_next)))
                SetupAllocBreak(htask);
        }
    }
    return TRUE;
}

void FAR _loadds SetupAllocBreak(HTASK htask)
{
    int i;
    char far* pchAlloc;
    char far* pchTask;

    // If alloc break task already set up, exit.
    //
    if (allocTask)
        return;

    // If no alloc break in effect, nothing to do.
    //
    if (allocModName[0] == 0)
        return;

    pchAlloc = allocModName;
    pchTask = GetTaskModNamePtr(htask);

    for (i = 8; --i != 0; pchAlloc++, pchTask++)
    {
        char ch1 = *pchAlloc;
        char ch2 = *pchTask;

        if (ch1 >= 'a' && ch1 <= 'z')
            ch1 -= ('a' - 'A');

        if (ch2 >= 'a' && ch2 <= 'z')
            ch2 -= ('a' - 'A');

        if (ch1 != ch2)
            return;

        if (ch1 == 0 || ch2 == 0)
            break;
    }

    // Set the alloc break task, and init the count to 0.
    //
    allocTask = htask;
    allocCount = 0;
}

#else   // !KDEBUG

BOOL WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags)
{
    return FALSE;
}

BOOL WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi)
{
    return FALSE;
}

#endif  // !KDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\hmem.asm ===
title	HMem
;HMem.asm - huge memory functions HMemCpy, etc

include	gpfix.inc
include	kernel.inc

externFP Int21Handler

DataBegin
externW WinFlags
ifdef WOW
externD pFileTable
externW cur_dos_PDB
externW Win_PDB
endif
DataEnd

ifdef WOW
externFP WOWFileRead
externFP WOWFileWrite
endif

sBegin CODE
assumes cs,CODE

ifdef WOW
externD  prevInt21proc
endif


externA  __AHINCR


cProc	hMemCpy,<PUBLIC,FAR>,<ds, si, di>
	parmD	dest			; to ES:DI
	parmD	src			; to DS:SI
	parmD	cnt			; to DX:AX
	localW	flags
cBegin
	SetKernelDS
	mov	bx, WinFlags
	mov	flags, bx
	mov	dx, seg_cnt		; DX:AX is 32 bit length
	mov	ax, off_cnt
	xor	cx, cx			; 0 if fault loading operands
beg_fault_trap hmc_trap
	lds	si, src
	les	di, dest
	cld
hmc_loop:
	mov	cx, 8000h		; try to copy 32K

	cmp	cx, si			; space left in source?
	jae	@F
	mov	cx, si

@@:	cmp	cx, di			; space left in dest?
	jae	@F
	mov	cx, di

@@:     neg	cx			; convert bytes left to positive

	or	dx, dx			; >64K left to copy?
	jnz	@F

	cmp	cx, ax			; At least this much left?
	jbe	@F
	mov	cx, ax

@@:	sub	ax, cx			; Decrement count while we're here
	sbb	dx, 0

	test	flags, WF_CPU386 + WF_CPU486 + WF_ENHANCED
	jnz	hmc_do32

	shr	cx, 1			; Copy 32KB
	rep	movsw
	adc	cx, 0
	rep	movsb
	jmps	hmc_copied

hmc_do32:
	.386p
	push	cx
	shr	cx, 2
	rep	movsd
	pop	cx
	and	cx, 3
	rep	movsb
	.286p

hmc_copied:
	mov	cx, ax			; At end of copy?
	or	cx, dx
	jz	hmc_done

	or	si, si			; Source wrap-around?
	jnz	@F
	mov	bx, ds
	add	bx, __AHINCR
	mov	ds, bx

@@:	or	di, di			; Dest wrap-around?
	jnz	@F
	mov	bx, es
	add	bx, __AHINCR
	mov	es, bx
end_fault_trap
@@:     jmps	hmc_loop

hmc_trap:
	fault_fix_stack			; DX:AX = bytes left if failure
	krDebugOut DEB_ERROR, "hMemCopy: Copy past end of segment"
	add	ax, cx
	adc	dx, 0
hmc_done:				; DX:AX = 0 if success

cEnd

ifdef W_Q21
cProc	_HREAD, <PUBLIC, FAR, NODATA>, <ds>
	parmW	h
	parmD	lpData
	parmD	dwCnt
cBegin
	SetKernelDS ds
	push	bx
	mov	bx, Win_PDB
	cmp	bx, cur_dos_PDB
	je	HR_PDB_ok

	push	ax
	mov	cur_dos_PDB,bx
	mov	ah,50h
	pushf
	call	cs:prevInt21Proc	; JUMP THROUGH CS VARIABLE
	pop	ax
HR_PDB_OK:
	pop	bx

	cCall	WowFileRead,<h,lpData,dwCnt,cur_dos_PDB,0,pFileTable>

;   DX:AX = Number Bytes Read
;   DX = FFFF, AX = Error Code

	inc	dx
	jnz	@f

	xor	dx,dx
	or	ax, -1
@@:
	dec	dx
cEnd

cProc	_HWRITE, <PUBLIC, FAR, NODATA>, <ds>
	parmW	h
	parmD	lpData
	parmD	dwCnt
cBegin
	SetKernelDS ds

	push	bx			; Setting the DOS PDB can probably
	mov	bx, Win_PDB		; be removed just pass Win_PDB to
	cmp	bx, cur_dos_PDB 	; the WOW thunk
	je	HW_PDB_ok

	push	ax
	mov	cur_dos_PDB,bx
	mov	ah,50h
	pushf
	call	cs:prevInt21Proc	; JUMP THROUGH CS VARIABLE
	pop	ax
HW_PDB_OK:
	pop	bx

	cCall	WowFileWrite,<h,lpData,dwCnt,cur_dos_PDB,0,pFileTable>

;   DX:AX = Number Bytes Read
;   DX = FFFF, AX = Error Code

	inc	dx
	jnz	@f

	xor	dx,dx
	or	ax, -1
@@:
	dec	dx
cEnd

else
public	_HREAD, _HWRITE

_HREAD:
	mov	bx, 3f00h
	jmps	hugeIO

_HWRITE:
	mov	bx, 4000h

cProc   hugeIO, <FAR, NODATA>, <ds, si, di, cx>
	parmW	h
	parmD	lpData
	parmD	dwCnt
	localD	dwTot
	localW	func
cBegin
	mov	func, bx		; read from a file
	mov	bx, h
	xor	cx, cx
	mov	seg_dwTot, cx
	mov	off_dwTot, cx
beg_fault_trap hr_fault
	lds	dx, lpData
	mov	si, seg_dwCnt
	mov	di, off_dwCnt

hr_loop:
	mov	cx, 8000h		; try to do 32KB

	cmp	cx, dx			; space left in data buffer
	jae	@F
	mov	cx, dx
	neg	cx

@@:	or	si, si			; at least 64K left
	jnz	@F
	cmp	cx, di
	jbe	@F
	mov	cx, di

@@:	mov	ax, func		; talk to DOS
	DOSCALL
	jc	hr_oops

	add     off_dwTot, ax		; update transfer count
	adc	seg_dwTot, 0

	cmp	ax, cx			; end of file?
	jnz	hr_done

	sub	di, ax			; decrement count
	sbb	si, 0

	mov	cx, si			; end of count
	or	cx, di
	jz	hr_done

	add	dx, ax			; update pointer to data
	jnz	@F			; wrapped to next segment
	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
end_fault_trap
@@:	jmps	hr_loop

hr_fault:
	pop	dx
	pop	ax
;	krDebugOut DEB_ERROR, "File I/O past end of memory block"
	krDebugOut DEB_ERROR, "GP fault in _hread/_hwrite at #DX #AX"
;	fault_fix_stack

hr_oops:
	or	dx, -1
	mov	seg_dwTot, dx
	mov	off_dwTot, dx

hr_done:
	mov	dx, seg_dwTot
	mov	ax, off_dwTot
cEnd
endif ; WOW

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\i21file.asm ===
title	INT21 - INT 21 handler for scheduler

.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include	eems.inc
include kdos.inc
ifdef WOW
include vint.inc
endif
.list

externFP FileCDR_notify

DataBegin

externB PhantArray
externB DOSDrives
externB CurDOSDrive
externW curTDB

DataEnd

assumes DS,NOTHING
sBegin	CODE
assumes CS,CODE

;externNP GrowSFT
externNP PassOnThrough
externNP final_call_for_DOS
externNP real_DOS
externNP MyUpper
externNP Int21Handler

ifdef FE_SB
externNP MyIsDBCSLeadByte		    ;near call is fine
endif

externFP ResidentFindExeFile
externFP GetModuleHandle
externFP FlushCachedFileHandle
externFP WOWDelFile

public ASSIGNCALL
public NAMETRANS
public DLDRIVECALL1
public DLDRIVECALL2
public XENIXRENAME
public FCBCALL
public PATHDSDXCALL
public PATHDSSICALL
public SetCarryRet
public SetErrorDrvDSDX


;-----------------------------------------------------------------------;
; Select_Disk		(DOS Call 0Eh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jan 28, 1987 00:40:48a  -by- David N. Weise    [dnw]		;
; Rewrote it.  It used to save and restore the current disk inside of	;
; DOS on task swaps.  Now it will restore on demand.			;
; 									;
;  Sat Jan 17, 1987 08:19:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Select_Disk,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	cmp	dl, CurDOSDrive		; Must set if not this!
	jne	MustSetIt
					; See if it matches saved drive for TDB
	cmp	[CurTDB], 0		; See if we have a TDB
	je	MustSetIt
	push	es
	mov	es, [CurTDB]
	cmp	es:[TDB_sig], TDB_SIGNATURE
	jne	DeadTDB
	push	ax     
	mov	al, es:[TDB_Drive]
	and	al, 7Fh		  	; Zap save drive flag
	cmp	al, dl			; Drive the same?
	pop	ax
	pop	es			
	jne	MustSetIt		;  no, set it
	mov	al, DOSDrives		; Return number of logical drives
	jmp	DriveErrorRet		; Well, it really just returns!
DeadTDB:
	pop	es
MustSetIt:
	push	dx
	inc	dx			; A=1
	call	CheckDriveDL
	pop	dx
	jnc	cd_no_drive_check
	call	SetErrorDLDrv
	jmp	DriveErrorRet
cEnd nogen


;-----------------------------------------------------------------------;
; Change_Dir		(DOS Call 3Bh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jan 28, 1987 00:40:48a  -by- David N. Weise    [dnw]		;
; Rewrote it.  It used to save and restore the current directory	;
; on task swaps.  Now it will restore on demand.			;
; 									;
;  Sat Jan 17, 1987 08:21:13p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Change_Dir,<PUBLIC,NEAR>
cBegin nogen
	call	PathDrvDSDX
	jnc	cd_no_drive_check	; Drive OK
	call	SetErrorDrvDSDX
	jmp	SetCarryRet
cd_no_drive_check:
	SetKernelDS
	mov	ds,CurTDB
	UnSetKernelDS
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jne	Change_Dir1
	and	ds:[TDB_Drive],01111111b	; indicate save needed
Change_Dir1:
	jmp	PassOnThrough
cEnd nogen


;-----------------------------------------------------------------------;
; FileHandleCall	(DOS Calls 3Eh,42h,45h,46h,57h,5Ch)		;
;									;
; Checks to see if the token in the PDB is 80h.  80h represents a	;
; file that was closed on a floppy by us in order to prompt for a	;
; file (see CloseOpenFiles).  If the token is 80h then it is set	;
; to FFh.								;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Sep 29, 1987 03:30:46p  -by-  David N. Weise      [davidw]	;
; Changed the special token from FEh to 80h to avoid conflict with	;
; Novell netware that starts with SFT FEh and counts down.		;
; 									;
;  Tue Apr 28, 1987 11:12:00a  -by-  Raymond E. Ozzie [-iris-]		;
; Changed to indirect thru PDB to get JFN under DOS 3.x.		;
;									;
;  Sat Jan 17, 1987 01:54:54a  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FileHandleCall,<PUBLIC,NEAR>
cBegin nogen
if1
; %OUT    FileHandleCall DISABLED
endif
	jmp	final_call_for_DOS
cEnd nogen


;-----------------------------------------------------------------------;
; Xenix_Status		(DOS Call 44h)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	FileHandleCall							;
;	PassOnThrough							;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 23:45:48  -by-  David N. Weise  [davidw]		;
; Removed WinOldApp support.						;
;									;
;  Sat Jan 17, 1987 10:17:31p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Xenix_Status,<PUBLIC,NEAR>
cBegin nogen
	cmp	al,4
	jb	xs1
	cmp	al,7
	jz	xs1
	cmp	al,10
	jz	xs1
	jmp	PassOnThrough

xs1:	jmp	FileHandleCall
cEnd nogen


;********************************************************************
;
; Phantom drive Traps
;
;********************************************************************

;**
;
; AssignCall -- Trap for Define Macro Call 5F03h
;
; ENTRY:
;	Regs for 5F03h except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
AssignCall:
	cmp	ax,5F03h		; Only care about 03 call
	jnz	AssignCall_OK
	cmp	bl,4			; With BL = 4 (assign block)
	jnz	AssignCall_OK
	cmp	byte ptr [si],0		; Ignore this special case
	jz	AssignCall_OK
	push	dx
	mov	dx,si
	call	PathDrvDSDX
	pop	dx
	jc	AssignCall_bad
AssignCall_OK:
	jmp	PassOnThrough

AssignCall_bad:
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; Set error
	pop	word ptr [si]		; reset string
	jmp	SetCarryRet


;**
;
; NameTrans -- Trap for NameTrans Call 60h
;
; ENTRY:
;	Regs for 60h except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
NameTrans:
	push	dx
	mov	dx,si			; Point with DS:DX to call PathDrvDSDX
	call	PathDrvDSDX
	pop	dx
	jc	@F
	jmp	POTJ1			; Drive OK
@@:
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	word ptr [si]		; Restore users drive
	jmp	SetCarryRet		; Error

si_no_good:
	call	SetErrorDrvDSDX 	; Set error
	pop	dx
	jmp	SetCarryRet		; Error

PathDSSICall:				; Simple clone of PathDSDXCall
	push	dx			; but start with offset in SI,
	mov	dx, si			; and we know this is a file open
	call	PathDrvDSDX		; call.
	jc	si_no_good
	pop	dx
	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset si_back_here ; Now have IRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
	jmp	PassOnThrough		; Do the DOS call
si_back_here:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	ax, [bp][4]
	jc	@F
	push	dx
	mov	dx, si
	call	FileCDR_notify
	pop	dx
@@:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret


;**
;
; PathDSDXCall -- Trap for Calls which point to a path with DS:DX
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
PathDSDXCall:
	call	PathDrvDSDX
	jnc	@f
	jmp    pd_drive_no_good        ; Drive not OK
@@:
	;   If OPEN with SHARING, check to see if this could be a file in
	;   the file handle cache.  GetModuleHandle is fairly quick as
	;   opposed to fully qualifying the path involved, but that would
	;   mean two DOS calls in addition to the open.  Kernel opens modules
	;   in compatibility mode, so sharing bits will barf if the file
	;   is in the cache.  why is this a problem?  CVW opens modules
	;   with sharing modes and we broke em when we fixed the fh cache.
	;   won't worry about other DOS calls like create or delete since
	;   they will damage things anyway.
	;
ife SHARE_AWARE
	cmp	ah,3Dh			; open call?
	jnz	maybe_notify
	test	al, 01110000b		; sharing bits?
	jz	maybe_notify

	call	DealWithCachedModule

endif

maybe_notify:
ifdef WOW
	cmp	ah,41h			; Delete call?
	jnz	not_delete

	call	DealWithCachedModule	; Yes Flush it out of our cache

not_delete:
endif; WOW
	cmp	ah,5Bh
	ja	no_notify_jmp		; DOS call we don't know
	cmp	ah,3Dh
	jnz	nd_101
	jmp	diddle_share_bits	; Don't notify on open file.
nd_101:
	cmp	ah,4Eh
	jz	no_notify_jmp		; Don't notify on find first.
	cmp	ah,56h
	jz	no_notify_jmp		; Handle rename specially.
	cmp	ax, 4300h		; Get File Attributes
	jz	no_notify_jmp
	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset back_here ; Now have IRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
POTJ1:
	jmp	PassOnThrough		; Do the DOS call

no_notify_jmp:
	jmps	no_notify


back_here:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	ax, [bp][4]
	jc	call_failed
	call	FileCDR_notify
call_failed:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret

diddle_share_bits:			; Make ALL opens use SHARE bits
if SHARE_AWARE
	test	al, 70h			; Any share bits now?
	jnz	no_notify		;  yes, fine.

	or	al, OF_SHARE_DENY_NONE	; For Read access
	test	al, 3			; Write or Read/Write access?
	jz	no_notify		;  no, SHARE_DENY_NONE is fine
					;  yes, want SHARE_DENY_WRITE
	xor	al, OF_SHARE_DENY_WRITE OR OF_SHARE_DENY_NONE
endif
no_notify:
	jmps	POTJ			; Drive OK

pd_drive_no_good:
	call	SetErrorDrvDSDX 	; Set error
	jmps	SetCarryRet		; Error

;**
;
; DLDriveCall1 -- Trap for Calls which have a drive number (A = 1) in DL
;			and carry NOT set if error.
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY not
;		diddled
; USES:
;	Flags and via DOS if error
;
DLDriveCall1:
	call	CheckDriveDL
	jnc	POTJ			; Drive OK
	call	SetErrorDLDrv		; Set error
	jmps	DriveErrorRet		; Error

;**
;
; DLDriveCall2 -- Trap for Calls which have a drive number (A = 1) in DL
;			and carry set if error.
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY set
; USES:
;	Flags and via DOS if error
;
DLDriveCall2:
	call	CheckDriveDL
	jnc	POTJ			; Drive OK
	call	SetErrorDLDrv		; Set error
	jmps	SetCarryRet		; Error

;**
;
; FCBCall -- Trap for Calls which point to an FCB with DS:DX
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
FCBCall:
	push	dx
	push	si
	mov	si,dx
	cmp	byte ptr [si],0FFh	; Extended FCB?
	jnz	NotExt			; No
	add	si,7			; Point to drive
NotExt:
	mov	dl,byte ptr [si]	; Get drive
	or	dl,dl
	jz	FCBOK			; default drive
	call	CheckDriveDL
	jc	FCBBad
FCBOK:
	pop	si
	pop	dx
POTJ:
	jmp	PassOnThrough

FCBBad:
	push	dx			; Save drive
	mov	dx,si			; Point to standard FCB
	mov	byte ptr [si],0F0h	; Known bogus drive
	call	real_DOS
	pop	dx
	mov	byte ptr [si],dl	; Restore user drive
	pop	si
	pop	dx
	jmps	DriveErrorRet


SetCarryRet:
	or	User_FL,00000001b	; Set carry
	jmps	DriveErrorRet


DriveErrorRet:
	pop	ds
	pop	bp
	dec	bp
	FSTI
	jmp	f_iret


;**
;
; XenixRename -- Trap for Call 56h
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY set
; USES:
;	Flags and via DOS if error
;
XenixRename:

; On rename we MUST deal with BOTH strings to prevent access to any
;	 phantom drives.

	call	PathDrvDSDX		; Check DS:DX drive
	xchg	di,dx			; ES:DI <-> DS:DX
	push	ds
	push	es
	pop	ds
	pop	es
	jnc	XR_010
	jmp	RenameError		; bad
XR_010:
	call	PathDrvDSDX		; Check ES:DI drive
	jnc	XR_020
	jmp	RenameError
XR_020:
	xchg	di,dx			; ES:DI <-> DS:DX
	push	ds
	push	es
	pop	ds
	pop	es

	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset back_here1 ; Now have FIRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
	jmp	PassOnThrough		; Do the DOS call
back_here1:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	[bp][4], ax
	jc	call_failed1

;;;	mov	ah,41h			; delete file
	call	FileCDR_notify
;;;	push	ds
;;;	push	es
;;;	pop	ds
;;;	pop	es
;;;	xchg	di,dx
;;;	mov	ah,5Bh			; create new file
;;;	call	FileCDR_notify
;;;	push	ds
;;;	push	es
;;;	pop	ds
;;;	pop	es
;;;	xchg	di,dx

call_failed1:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret

RenameError:
	xchg	di,dx			; DS:DX <-> ES:DI
	push	ds
	push	es
	pop	ds
	pop	es

; We patch the ES:DI drive letter even if it isn't there.
;   Since we are setting an error anyway this is OK.

	push	word ptr ES:[di]
	mov	byte ptr ES:[di],'$'	; Bogus drive letter
	call	SetErrorDrvDSDX		; Set error
	pop	word ptr ES:[di]
	jmp	SetCarryRet		; Error

;**
;
; PathDrvDSDX -- Check a path pointed to by DS:DX for phantom drives
;
; ENTRY:
;	DS:DX points to path
; EXIT:
;	Carry set if phantom drive detected
;	Carry clear if no phantom drives detected
; USES:
;	Flags
;
	public	PathDrvDSDX
PathDrvDSDX:
	push	si
	mov	si,dx		; Point with SI
	mov	dx,word ptr [si]; Get first two chars
	or	dl,dl		; NUL in first byte?
	jz	PDROK		; yes, OK
ifdef FE_SB
	push	ax
	mov	al,dl
	call	MyIsDBCSLeadByte    ; see if char is DBC.
	pop	ax
	jnc	PDROK		; jump if char is a DBC
endif
	or	dh,dh		; NUL in second byte?
	jz	PDROK		; yes, OK
	cmp	dh,':'		; Drive given?
	jnz	PDROK		; No, OK
	or	dl,20h		; to lower case
	sub	dl,60h		; DL is drive #, A=1
	call	CheckDriveDL	; Check it out
	jmps	PDPPRET

PDROK:
	clc
PDPPRET:
	mov	dx,si
	pop	si
	ret

;**
;
; SetErrorDrvDSDX -- Set an error on a DS:DX call by calling the DOS
;
; ENTRY:
;	DS:DX points to path with phantom drive
;	All other regs approp for INT 21 CALL
; EXIT:
;	DOS called to set up error
; USES:
;	Flags
;	Regs as for INT 21 CALL
;
SetErrorDrvDSDX:
	push	si
	mov	si,dx
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	word ptr [si]		; Restore users drive
	pop	si
	ret

;**
;
; SetErrorDLDrv -- Set an error on a DL call by calling the DOS
;
; ENTRY:
;	DL is drive # (A=1) of a phantom drive.
;	All other regs approp for INT 21 CALL
; EXIT:
;	DOS called to set up error
; USES:
;	Flags
;	Regs as for INT 21 CALL
;
SetErrorDLDrv:
	push	dx
	mov	dl,0F0h			; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	dx			; Restore users drive
ret43:	ret

;**
;
; CheckDriveDL -- Check DL drive (A = 1)
;
; ENTRY:
;	DL is drive # (A=1)
; EXIT:
;	Carry Set if phantom drive
;	Carry Clear if NOT phantom drive
; USES:
;	Flags
;
CheckDriveDL:
	push	bx
	mov	bx,dx
	dec	bl			; A = 0
	cmp	bl,26			; 0 >= DL < 26?
	jae	OKDRV			; No, cant be phantom then
	xor	bh,bh
	add	bx,dataOffset PhantArray; Index into PhantArray
	push	ds
	SetKernelDS
	cmp	byte ptr ds:[bx],0	; Non-zero entry means phantom
	pop	ds
	UnSetKernelDS
	stc
	jnz	BadDrv
OKDRV:
	clc
BadDrv:
	pop	bx
	ret


ife SHARE_AWARE

;**
;
; DealWithCachedModule -- closes a cached module if it looks like a filename
;
;   ENTRY:
;	Same as PathDSDXCall
;
;   EXIT:
;	Unchanged
;
;   USES:
;	None
;
;   SIDE EFFECT:
;	Closes entry in file handle cache if it has the same base name
;
public DealWithCachedModule
DealWithCachedModule:
	pusha
	push	ds
	push	es			; save all registers

	mov	si, dx			; point ds:si to string
	sub	sp, 130 		; big number for paranoia
	mov	di, sp
	push	ss
	pop	es			; es:di to string
	cld				; forwards

copy_name_loop:
	lodsb				; get a char
	cmp	al, 0			; end of string?
	jz	end_of_name
	cmp	al, ':' 		; path seperator?
	jz	path_sep
	cmp	al, '\'
	jz	path_sep
	cmp	al, '/'
	jz	path_sep
	call	MyUpper 		; upcase the char
	stosb

ifdef FE_SB
	call	MyIsDBCSLeadByte
	jc	copy_name_loop		; copy second byte in east
	movsb
endif

	jmp	short copy_name_loop
path_sep:
	mov	di, sp			; point back to beginning
	jmp	short copy_name_loop
end_of_name:
	stosb
	mov	di, sp			; point back to beginning

	SetKernelDS

	cCall	ResidentFindExeFile, <ss,di>	; find it
	or	ax, ax
	jz	@F

	cCall	FlushCachedFileHandle, <ax> ; flush it
@@:
	add	sp, 130

	pop	es
	pop	ds			; restore registers
	popa
	UnsetKernelDS
	ret

endif

f_iret:
	FIRET

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ikernel.h ===
#define API	_far _pascal _loadds

HANDLE	API IGlobalAlloc(WORD, DWORD);
DWORD	API IGlobalCompact(DWORD);
HANDLE	API IGlobalFree(HANDLE);
DWORD	API IGlobalHandle(WORD);
LPSTR	API IGlobalLock(HANDLE);
HANDLE	API IGlobalReAlloc(HANDLE, DWORD, WORD);
DWORD	API IGlobalSize(HANDLE);
BOOL	API IGlobalUnlock(HANDLE);
WORD	API IGlobalFlags(HANDLE);
LPSTR	API IGlobalWire(HANDLE);
BOOL	API IGlobalUnWire(HANDLE);
HANDLE	API IGlobalLRUNewest(HANDLE);
HANDLE	API IGlobalLRUOldest(HANDLE);
VOID	API IGlobalNotify(FARPROC);
WORD	API IGlobalPageLock(HANDLE);
WORD	API IGlobalPageUnlock(HANDLE);
VOID	API IGlobalFix(HANDLE);
BOOL	API IGlobalUnfix(HANDLE);
DWORD	API IGlobalDosAlloc(DWORD);
WORD	API IGlobalDosFree(WORD);
HANDLE	API IGetModuleHandle(LPSTR);
int	API IGetModuleUsage(HANDLE);
int	API IGetModuleFileName(HANDLE, LPSTR, int);
FARPROC API IGetProcAddress(HANDLE, LPSTR);
FARPROC API IMakeProcInstance(FARPROC, HANDLE);
void	API IFreeProcInstance(FARPROC);
void	API IOutputDebugString(LPSTR);
//LPSTR   API Ilstrcpy( LPSTR, LPSTR );
//LPSTR   API Ilstrcat( LPSTR, LPSTR );
//int     API IlstrOriginal( LPSTR, LPSTR );
//int     API Ilstrlen( LPSTR );
int	API I_lopen( LPSTR, int );
int	API I_lclose( int );
int	API I_lcreat( LPSTR, int );
LONG	API I_llseek( int, long, int );
WORD	API I_lread( int, LPSTR, int );
WORD	API I_lwrite( int, LPSTR, int );

#define GlobalAlloc		     IGlobalAlloc
#define GlobalFree		     IGlobalFree
#define GlobalHandle		     IGlobalHandle
#define GlobalLock		     IGlobalLock
#define GlobalReAlloc		     IGlobalReAlloc
#define GlobalSize		     IGlobalSize
#define GlobalUnlock		     IGlobalUnlock
#define GlobalFlags		     IGlobalFlags
#define GlobalWire		     IGlobalWire
#define GlobalUnWire		     IGlobalUnWire
#define GlobalLRUNewest 	     IGlobalLRUNewest
#define GlobalLRUOldest 	     IGlobalLRUOldest
#define GlobalNotify		     IGlobalNotify
#define GlobalPageLock		     IGlobalPageLock
#define GlobalPageUnlock	     IGlobalPageUnlock
#define GlobalFix		     IGlobalFix
#define GlobalUnfix		     IGlobalUnfix
#define GetProcAddress		     IGetProcAddress
#define GetModuleHandle 	     IGetModuleHandle
#define GetModuleUsage		     IGetModuleUsage
#define GetModuleFileName	     IGetModuleFileName
#define GetFreeSpace		     IGetFreeSpace
#define GetTempFileName 	     IGetTempFileName
//#define lstrcpy                      Ilstrcpy
//#define lstrcat                      Ilstrcat
//#define lstrOriginal                 IlstrOriginal
//#define lstrlen                      Ilstrlen
#define _lopen			     I_lopen
#define _lclose 		     I_lclose
#define _lcreat 		     I_lcreat
#define _llseek 		     I_llseek
#define _lread			     I_lread
#define _lwrite 		     I_lwrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ikernel.inc ===
AllocCStoDSAlias	     equ  <IAllocCStoDSAlias>
AllocDStoCSAlias	     equ  <IAllocDStoCSAlias>
FreeSelector		     equ  <IFreeSelector>
ChangeSelector		     equ  <IChangeSelector>
LoadResource		     equ  <ILoadResource>
AccessResource		     equ  <IAccessResource>
FindResource		     equ  <IFindResource>
AllocResource		     equ  <IAllocResource>
FreeResource		     equ  <IFreeResource>
LockResource		     equ  <ILockResource>
SetResourceHandler	     equ  <ISetResourceHandler>
SizeofResource		     equ  <ISizeofResource>
;AddAtom                      equ  <IAddAtom>
DeleteAtom		     equ  <IDeleteAtom>
;FindAtom                     equ  <IFindAtom>
GetAtomName		     equ  <IGetAtomName>
GetAtomHandle		     equ  <IGetAtomHandle>
;Catch                        equ  <ICatch>
;Throw                        equ  <IThrow>
FreeModule		     equ  <IFreeModule>
FreeLibrary		     equ  <IFreeLibrary>
FatalAppExit		     equ  <IFatalAppExit>
GlobalAlloc		     equ  <IGlobalAlloc>
GlobalFree		     equ  <IGlobalFree>
GlobalHandle		     equ  <IGlobalHandle>
GlobalLock		     equ  <IGlobalLock>
GlobalReAlloc		     equ  <IGlobalReAlloc>
GlobalSize		     equ  <IGlobalSize>
GlobalUnlock		     equ  <IGlobalUnlock>
GlobalFlags		     equ  <IGlobalFlags>
GlobalWire		     equ  <IGlobalWire>
GlobalUnWire		     equ  <IGlobalUnWire>
GlobalLRUNewest 	     equ  <IGlobalLRUNewest>
GlobalLRUOldest 	     equ  <IGlobalLRUOldest>
GlobalNotify		     equ  <IGlobalNotify>
GlobalPageLock		     equ  <IGlobalPageLock>
GlobalPageUnlock	     equ  <IGlobalPageUnlock>
GlobalFix		     equ  <IGlobalFix>
GlobalUnfix		     equ  <IGlobalUnfix>
LockSegment		     equ  <ILockSegment>
UnlockSegment		     equ  <IUnlockSegment>
GetWindowsDirectory	     equ  <IGetWindowsDirectory>
GetSystemDirectory	     equ  <IGetSystemDirectory>
MakeProcInstance	     equ  <IMakeProcInstance>
FreeProcInstance	     equ  <IFreeProcInstance>
GetCodeInfo		     equ  <IGetCodeInfo>
GetProcAddress		     equ  <IGetProcAddress>
GetModuleHandle 	     equ  <IGetModuleHandle>
GetModuleUsage		     equ  <IGetModuleUsage>
GetModuleFileName	     equ  <IGetModuleFileName>
GetInstanceData 	     equ  <IGetInstanceData>
GetFreeSpace		     equ  <IGetFreeSpace>
GetTempFileName 	     equ  <IGetTempFileName>
;lstrcpy                      equ  <Ilstrcpy>
;lstrcat                      equ  <Ilstrcat>
;lstrlen                      equ  <Ilstrlen>
_lopen			     equ  <I_lopen>
_lclose 		     equ  <I_lclose>
_lcreat 		     equ  <I_lcreat>
_llseek 		     equ  <I_llseek>
_lread			     equ  <I_lread>
_lwrite 		     equ  <I_lwrite>
LoadLibrary		     equ  <ILoadLibrary>
;LoadModule		     equ  <ILoadModule> ;;; ATM: Can't call internal function
LocalAlloc		     equ  <ILocalAlloc>
LocalFree		     equ  <ILocalFree>
LocalLock		     equ  <ILocalLock>
LocalReAlloc		     equ  <ILocalReAlloc>
LocalSize		     equ  <ILocalSize>
LocalUnlock		     equ  <ILocalUnlock>
LocalFlags		     equ  <ILocalFlags>
LocalNotify		     equ  <ILocalNotify>
OpenFile		     equ  <IOpenFile>
;SwitchStackTo                equ  <ISwitchStackTo>
SetHandleCount               equ  <ISetHandleCount>
SetErrorMode		     equ  <ISetErrorMode>
SwapRecording		     equ  <ISwapRecording>
WinExec 		     equ  <IWinExec>
GetProfileInt		     equ  <IGetProfileInt>
GetProfileString	     equ  <IGetProfileString>
GetPrivateProfileInt	     equ  <IGetPrivateProfileInt>
GetPrivateProfileString      equ  <IGetPrivateProfileString>
WriteProfileString       equ  <IWriteProfileString>
WritePrivateProfileString    equ  <IWritePrivateProfileString>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\i21entry.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
include eems.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

ifdef WOW
;
; Int 21 tracing control.  If TraceInt21 is defined, ifdef's cause
; extra debugging output before/after the DOS call.
;
; TraceInt21 equ 1 ; uncomment this line to log Int 21 operations.
endif


DataBegin

externB PhantArray
externB kernel_flags
externB Kernel_InDOS
externB Kernel_InINT24
externB fInt21
externB InScheduler
externB CurDOSDrive
externB DOSDrives
externW curTDB
externW curDTA
;externW headPDB
;externW topPDB
externW Win_PDB
externW cur_dos_PDB
externW cur_drive_owner
externW LastExtendedError
ifndef WOW
externB WinIniInfo
externB PrivateProInfo
externB fProfileMaybeStale
externB fWriteOutProfilesReenter
endif
externB fBooting
;externD lpWinSftLink

if ROM
externD prevInt21Proc
endif

ifdef WOW
externD pPMDosCURDRV
externD pPMDosPDB
externD pPMDosExterr
externD pPMDosExterrLocus
externD pPMDosExterrActionClass

externD pFileTable
externW WinFlags
externW fLMdepth
externW WOWLastError
externB WOWErrClass
externB WOWErrAction
externB WOWErrLocation
endif

DataEnd

externFP WriteOutProfiles
ifdef WOW
externFP WOWFileRead
externFP WOWFileWrite
externFP WOWFileLSeek
externFP WOWFileCreate
externFP WOWFileOpen
externFP WOWFileClose
externFP WOWFileGetAttributes
externFP WOWFileSetAttributes
externFP WOWFileGetDateTime
externFP WOWFileSetDateTime
externFP WOWFileLock
externFP WOWDelFile
externFP WOWFindFirst
externFP WOWFindNext
externFP WOWSetDefaultDrive
externFP WOWGetCurrentDirectory
externFP WOWSetCurrentDirectory
externFP WOWGetCurrentDate
externFP WOWDeviceIOCTL
endif

SetDosErr macro ErrorCode,ErrorCodeLocus,ErrorCodeAction,ErrorCodeClass
        push es
        push di
        push ax
        mov  ax, pPMDosExterr.sel
        mov  es, ax
        pop  ax

        mov di, pPMDosExterr.off
        mov word ptr es:[di], ErrorCode
        mov WOWLastError, ErrorCode

        ifnb <ErrorCodeLocus>
           mov di, pPMDosExterrLocus.off
           mov byte ptr es:[di], ErrorCodeLocus
        endif
        ifnb <ErrorCodeAction>
           mov di, pPMDosExterrActionClass.off
           mov byte ptr es:[di], ErrorCodeAction
           mov byte ptr es:[di+1], ErrorCodeClass
        endif
        pop di
        pop es
endm

CheckDosErr macro
        push es
        push di
        push ax
        mov  ax, pPMDosExterr.sel
        mov  es, ax
        pop  ax
        mov  di, pPMDosExterr.off
        cmp  word ptr es:[di], 0
        pop  di
        pop  es
endm


GetDosErr macro regCode,regCodeLocus,regCodeAction,regCodeClass
        push es
        push di
        push ax
        mov ax, pPMDosExterr.sel
        mov es, ax
        pop ax

        mov di, pPMDosExterr.off
        mov regCode, word ptr es:[di]
        ; mov regCode, WOWLastError

        ifnb <regCodeLocus>
             mov di, pPMDosExterrLocus.off
             mov regCodeLocus, byte ptr es:[di]
        endif

        ifnb <regCodeAction>
             mov di, pPMDosExterrActionClass.off
             mov regCodeAction, byte ptr es:[di]
             mov regCodeClass,  byte ptr es:[di+1]
        endif

        pop di
        pop es
endm


sBegin  CODE
assumes CS,CODE
assumes ds, nothing
assumes es, nothing

ife ROM
externD prevInt21Proc
endif

ifdef WOW
externFP WOWLFNEntry

externNP DPMIProc
endif


;***********************************************************************;
;                                                                       ;
;                       WINDOWS mediated system calls.                  ;
;                                                                       ;
;   Windows mediates certain system calls.   Several matters complicate ;
;   the mediation:                                                      ;
;                                                                       ;
;   a.  MSDOS uses registers to pass arguments.  Thus, registers AND    ;
;       ANY RETURN VALUES in registers must be preserved across tasks.  ;
;                                                                       ;
;   b.  MSDOS stores global state information that must be preserved    ;
;       on a task by task basis.                                        ;
;                                                                       ;
;   c.  To handle multiple exec calls, the notion of a "parent" task    ;
;       is introduced.                                                  ;
;                                                                       ;
;                                                                       ;
;***********************************************************************;

entry   macro   fred
if1
        dw      0
else
ifndef  fred
        extrn   fred:near
endif
        dw      CODEOffset fred
endif
        endm

sEnd    CODE


sBegin  DATA
DosTrap1        label   word
;;;             entry   not_supported           ; 00  abort call
;;;             entry   not_supported           ; 01  read keyboard and echo
;;;             entry   not_supported           ; 02  display character
;;;             entry   not_supported           ; 03  aux input
;;;             entry   not_supported           ; 04  aux output
;;;             entry   not_supported           ; 05  printer output
;;;             entry   not_supported           ; 06  direct console IO
;;;             entry   not_supported           ; 07  direct console input
;;;             entry   not_supported           ; 08  read keyboard
;;;             entry   not_supported           ; 09  display string
;;;             entry   not_supported           ; 0A  buffered keyboard input
;;;             entry   not_supported           ; 0B  check keyboard status
;;;             entry   not_supported           ; 0C  flush keyboard buffer
;;;             entry   PassOnThrough           ; 0D  disk reset
                entry   Select_Disk             ; 0E
                entry   not_supported           ; 0F  open file FCB
                entry   not_supported           ; 10  close file FCB
                entry   FCBCall                 ; 11  search first FCB
                entry   not_supported           ; 12  search next FCB
                entry   not_supported           ; 13  delete file FCB
                entry   not_supported           ; 14  read FCB
                entry   not_supported           ; 15  write FCB
                entry   not_supported           ; 16  create file FCB
                entry   not_supported           ; 17  rename file FCB
                entry   not_supported           ; 18  ???
                entry   PassOnThrough           ; 19  current disk
                entry   Set_DTA                 ; 1A
                entry   not_supported           ; 1B  allocation table info
                entry   not_supported           ; 1C  allocation table info
                entry   not_supported           ; 1D  ???
                entry   not_supported           ; 1E  ???
                entry   not_supported           ; 1F  ???
                entry   not_supported           ; 20  ???
                entry   not_supported           ; 21  read FCB
                entry   not_supported           ; 22  write FCB
                entry   not_supported           ; 23  file size FCB
                entry   not_supported           ; 24  set record field FCB
                entry   Set_Vector              ; 25
                entry   not_supported           ; 26
                entry   not_supported           ; 27  random read FCB
                entry   not_supported           ; 28  random write FCB
                entry   not_supported           ; 29  parse filename FCB
                entry   PassOnThrough           ; 2A  get date
                entry   PassOnThrough           ; 2B  set date
                entry   PassOnThrough           ; 2C  get time
                entry   PassOnThrough           ; 2D  set time
                entry   PassOnThrough           ; 2E  set verify
                entry   PassOnThrough           ; 2F  get DTA
                entry   PassOnThrough           ; 30  get DOS version
                entry   not_supported           ; 31  TSR
                entry   DLDriveCall1            ; 32
                entry   not_supported           ; 33  break state
                entry   not_supported           ; 34  ???
                entry   Get_Vector              ; 35
                entry   DLDriveCall1            ; 36
                entry   not_supported           ; 37  ???
                entry   not_supported           ; 38  country info
                entry   PathDSDXCall            ; 39
                entry   PathDSDXCall            ; 3A
                entry   Change_Dir              ; 3B
                entry   PathDSDXCall            ; 3C
                entry   PathDSDXCall            ; 3D
                entry   FileHandleCall          ; 3E
                entry   PassOnThrough           ; 3F
                entry   PassOnThrough           ; 40
                entry   PathDSDXCall            ; 41
                entry   FileHandleCall          ; 42
                entry   PathDSDXCall            ; 43
                entry   Xenix_Status            ; 44
                entry   FileHandleCall          ; 45
                entry   FileHandleCall          ; 46
                entry   DLDriveCall2            ; 47
                entry   not_supported           ; 48  allocate memory
                entry   not_supported           ; 49  free memory
                entry   not_supported           ; 4A  reallocate memory
                entry   ExecCall                ; 4B
                entry   ExitCall                ; 4C
                entry   not_supported           ; 4D  get return code
                entry   PathDSDXCall            ; 4E
                entry   PassOnThrough           ; 4F  find next
                entry   set_PDB                 ; 50
                entry   get_PDB                 ; 51
                entry   not_supported           ; 52  ???
                entry   not_supported           ; 53  ???
                entry   PassOnThrough           ; 54  get verify
                entry   not_supported           ; 55  ???
                entry   XenixRename             ; 56
                entry   FileHandleCall          ; 57
                entry   not_supported           ; 58  ???
                entry   PassOnThrough           ; 59  extended error
                entry   PathDSDXCall            ; 5A  create unique file
                entry   PathDSDXCall            ; 5B  create new file
                entry   FileHandleCall          ; 5C  lock/unlock file access
                entry   not_supported           ; 5D  ???
                entry   PassOnThrough           ; 5E  network stuff
                entry   AssignCall              ; 5F  network stuff
                entry   NameTrans               ; 60
                entry   not_supported           ; 61  ???
                entry   get_PDB                 ; 62
                entry   PassOnThrough           ; 63
                entry   PassOnThrough           ; 64
                entry   PassOnThrough           ; 65
                entry   PassOnThrough           ; 66
                entry   SetMaxHandleCount               ; 67
                entry   PassOnThrough           ; 68
                entry   PassOnThrough           ; 69
                entry   PassOnThrough           ; 6a
                entry   PassOnThrough           ; 6b
                entry   PathDSSICall            ; 6c  Extended File Open
                entry   PassOnThrough           ; 6d
                entry   PassOnThrough           ; 6e
                entry   PassOnThrough           ; 6f
                entry   PassOnThrough           ; 70
                entry   PassOnThrough           ; 71  LFN API
TableEnd = 71h


ifdef W_Q21
QuickDispatchTable      label   word
QD_FIRST equ    0eh
        dw      offset QuickSetDefaultDrive     ;0e
        dw      offset Not_WOW_Handled          ;0f
        dw      offset Not_WOW_Handled          ;10
        dw      offset Not_WOW_Handled          ;11
        dw      offset Not_WOW_Handled          ;12
        dw      offset Not_WOW_Handled          ;13
        dw      offset Not_WOW_Handled          ;14
        dw      offset Not_WOW_Handled          ;15
        dw      offset Not_WOW_Handled          ;16
        dw      offset Not_WOW_Handled          ;17
        dw      offset Not_WOW_Handled          ;18
        dw      offset QuickGetDefaultDrive     ;19
        dw      offset Not_WOW_Handled          ;1a
        dw      offset Not_WOW_Handled          ;1b
        dw      offset Not_WOW_Handled          ;1c
        dw      offset Not_WOW_Handled          ;1d
        dw      offset Not_WOW_Handled          ;1e
        dw      offset Not_WOW_Handled          ;1f
        dw      offset Not_WOW_Handled          ;20
        dw      offset Not_WOW_Handled          ;21
        dw      offset Not_WOW_Handled          ;22
        dw      offset Not_WOW_Handled          ;23
        dw      offset Not_WOW_Handled          ;24
        dw      offset Not_WOW_Handled          ;25
        dw      offset Not_WOW_Handled          ;26
        dw      offset Not_WOW_Handled          ;27
        dw      offset Not_WOW_Handled          ;28
        dw      offset Not_WOW_Handled          ;29
        dw      offset QuickGetDate             ;2a
        dw      offset Not_WOW_Handled          ;2b
        dw      offset Not_WOW_Handled          ;2c
        dw      offset Not_WOW_Handled          ;2d
        dw      offset Not_WOW_Handled          ;2e
        dw      offset Not_WOW_Handled          ;2f
        dw      offset Not_WOW_Handled          ;30
        dw      offset Not_WOW_Handled          ;31
        dw      offset Not_WOW_Handled          ;32
        dw      offset Not_WOW_Handled          ;33
        dw      offset Not_WOW_Handled          ;34
        dw      offset Not_WOW_Handled          ;35
        dw      offset Not_WOW_Handled          ;36
        dw      offset Not_WOW_Handled          ;37
        dw      offset Not_WOW_Handled          ;38
        dw      offset Not_WOW_Handled          ;39
        dw      offset Not_WOW_Handled          ;3a
        dw      offset QuickSetCurrentDirectory ;3b
        dw      offset QuickCreate              ;3c
        dw      offset QuickOpen                ;3d
        dw      offset QuickClose               ;3e
        dw      offset QuickRead                ;3f
        dw      offset Quickwrite               ;40
        dw      offset QuickDelete              ;41
        dw      offset QuickLSeek               ;42
        dw      offset QuickGetSetAttributes    ;43
        dw      offset QuickDeviceIOCTL         ;44
        dw      offset Not_WOW_Handled          ;45
        dw      offset Not_WOW_Handled          ;46
        dw      offset QuickGetCurrentDirectory ;47
        dw      offset Not_WOW_Handled          ;48
        dw      offset Not_WOW_Handled          ;49
        dw      offset Not_WOW_Handled          ;4a
        dw      offset Not_WOW_Handled          ;4b
        dw      offset Not_WOW_Handled          ;4c
        dw      offset Not_WOW_Handled          ;4d
        dw      offset QuickFindFirstFile       ;4e
        dw      offset QuickFindNextFile        ;4f
        dw      offset Not_WOW_Handled          ;50
        dw      offset Not_WOW_Handled          ;51
        dw      offset Not_WOW_Handled          ;52
        dw      offset Not_WOW_Handled          ;53
        dw      offset Not_WOW_Handled          ;54
        dw      offset Not_WOW_Handled          ;55
        dw      offset Not_WOW_Handled          ;56
        dw      offset QuickFileDateTime        ;57
        dw      offset Not_WOW_Handled          ;58
        dw      offset QuickExtendedError       ;59
        dw      offset Not_WOW_Handled          ;5a
        dw      offset Not_WOW_Handled          ;5b
        dw      offset QuickLock                ;5c

ifdef IGROUP_HAS_ENOUGH_ROOM
        dw      offset Not_WOW_Handled          ;5d
        dw      offset Not_WOW_Handled          ;5e
        dw      offset Not_WOW_Handled          ;5f
        dw      offset Not_WOW_Handled          ;60
        dw      offset Not_WOW_Handled          ;61
        dw      offset Not_WOW_Handled          ;62
        dw      offset Not_WOW_Handled          ;63
        dw      offset Not_WOW_Handled          ;64
        dw      offset Not_WOW_Handled          ;65
        dw      offset Not_WOW_Handled          ;66
        dw      offset Not_WOW_Handled          ;67
        dw      offset Not_WOW_Handled          ;68
        dw      offset Not_WOW_Handled          ;69
        dw      offset Not_WOW_Handled          ;6a
        dw      offset Not_WOW_Handled          ;6b
        dw      offset Not_WOW_Handled          ;6c
        dw      offset Not_WOW_Handled          ;6d
        dw      offset Not_WOW_Handled          ;6e
        dw      offset Not_WOW_Handled          ;6f
        dw      offset Not_WOW_Handled          ;70
        dw      offset QuickLFNApiCall          ;71

QD_LAST equ     71h

else

QD_LAST equ     5ch
QD_LFNAPI equ   71h

endif


QuickDispatchAddr       dw      ?
endif

sEnd    DATA

sBegin  CODE

;-----------------------------------------------------------------------;
;                                                                       ;
;                       Interrupt 21h handler.                          ;
;                                                                       ;
;-----------------------------------------------------------------------;

labelFP <PUBLIC,Int21Handler>

;-----------------------------------------------------------------------;
; Int21Entry                                                            ;
;                                                                       ;
; The is the dispatcher for our INT 21h handler.                        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 07-Aug-1989 23:48:06  -by-  David N. Weise  [davidw]             ;
; Made it use a jump table!!                                            ;
;                                                                       ;
;  Thu Apr 16, 1987 07:44:19p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   Int21Entry,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        SetKernelDS
        cmp     fInt21, 0
        je      not_me
        pop     ds
        UnSetKernelDS
        inc     bp
        push    bp
        mov     bp, sp
        push    ds
        push    bx                      ; Will be exchanged later
        SetKernelDS
        cmp     ah,12h
        jbe     dont_reset_InDOS
        mov     Kernel_InDOS,0
        mov     Kernel_InINT24,0
dont_reset_InDOS:
        cmp     Kernel_InDOS,0
        jz      not_in_INT24
        mov     kernel_InINT24,1
not_in_INT24:
ifndef WOW ; FOR WOW All the Profile Stuff is handled by Win 32
        ;** On every DOS call, the profile string buffers may become stale
        ;**     in case the app does a DOS call on the INI file.
        ;**     We set the stale profile file and on the next profile read
        ;**     or write, we will check to see if the file is dirty.
        ;**     27-Nov-1991 [JonT]
        mov     ds:[fProfileMaybeStale], 1

        ;** In a similar situation to the above, DOS calls done after
        ;**     profile string calls but before task switches may depend on
        ;**     the data being flushed to the INI file from the buffer.
        ;**     So, here we do a fast check to see if the profile buffers
        ;**     have unflushed information.  If they do, we flush them.
        ;**     Note that 2 is PROUNCLEAN taken from UP.C
        ;**     27-Nov-1991 [JonT]
        test    WinIniInfo.ProFlags, 2          ;Win.INI dirty?
        jnz     I21_Flush_It                    ;Yes, flush it
        test    PrivateProInfo.ProFlags, 2      ;Private profile dirty?
        jz      I21_Done_Flushing               ;No. Neither.

        ;** When writing out profiles we trash pretty much all the registers
        ;**     and since we can't do this for a DOS call, we save everything
I21_Flush_It:
        cmp     fWriteOutProfilesReenter, 0     ;Ignore if reentering
        jne     I21_Done_Flushing               ;  because of profile strings
        pusha
        push    es
if PMODE32
        .386
        push    fs
        push    gs
endif
        cCall   WriteOutProfiles
if PMODE32
        pop     gs
        pop     fs
        .286p
endif
        pop     es
        popa
endif ; NOT WOW
I21_Done_Flushing:

        mov     bx, CODEOffset PassOnThrough
        cmp     ah,TableEnd                     ; Table is for call 0Eh to 6ch
        ja      let_it_go
        cmp     ah, 0Eh
        jb      let_it_go
        mov     bh, 0
        mov     bl, ah
        add     bx, bx                          ; Word index in bx
        mov     bx, word ptr DosTrap1[bx][-0Eh*2]
let_it_go:
        xchg    bx, [bp-4]                      ; 'pop bx' and push proc addr
        mov     ds, [bp-2]                      ; Restore DS
        UnSetKernelDS
if 1 ; PMODE32 - always want to avoid sti in WOW
        push    ax
        pushf
        pop     ax
        test    ah, 2
        pop     ax
        jnz     short ints_are_enabled
endif ; WOW
        FSTI
ints_are_enabled:
        ret
not_me:
        pop     ds
;;;     jmp     prevInt21Proc
        call    real_dos
        retf    2
cEnd nogen

;-----------------------------------------------------------------------;
; not_supported
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 06-Aug-1989 13:26:19  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   not_supported,<PUBLIC,NEAR>
cBegin nogen
        jmps    PassOnThrough
;;;     cmp     ah,55h
;;;     jnz     @F
;;;     jmp     PassOnThrough
;;;@@:  int     3
cEnd nogen


;-----------------------------------------------------------------------;
; PassOnThrough                                                         ;
;                                                                       ;
; This doesn't quite pass on through anymore.  It calls down to DOS.    ;
; In this fashion we know when we are in DOS.  In addition this routine ;
; does the delayed binding of DOS variables after task switches.        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 25-Mar-1990 15:31:49  -by-  David N. Weise  [davidw]             ;
; added the check for 2Fh, GetDTA, so that the correct one is gotten!   ;
;                                                                       ;
;  Tue Feb 03, 1987 10:32:25p  -by-  David N. Weise   [davidw]          ;
; Put in the delayed binding of DOS variables.                          ;
;                                                                       ;
;  Tue Feb 03, 1987 10:26:01p  -by-  David N. Weise   [davidw]          ;
; Rewrote it and added this nifty comment block.                        ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

f_iret:
        FIRET

cProc   PassOnThrough,<PUBLIC,NEAR>
cBegin nogen

        SetKernelDS
        test    Kernel_Flags,KF_restore_disk
        jnz     maybe_restore_disk

PUBLIC final_call_for_DOS
final_call_for_DOS:
        pop     ds
        UnSetKernelDS
        push    [bp][6]
        and     [bp][-2],NOT CPUF_TRAP
        popf                            ; Correct input flags back in flags
        pop     bp
        dec     bp
        call    real_DOS
        push    bp                      ; pass back the correct flags
        mov     bp,sp
        pushf
        pop     [bp][6]
if 1 ; PMODE32 - always for WOW
        test    [bp][6], 200h           ; Interrupts on?
        pop     bp
        jnz     short no_sti
else
        pop     bp
endif
        FSTI
no_sti:
        jmp     f_iret

maybe_restore_disk:

; Note, caller's DS is on stack, current DS == kernel DS

        cmp     ah,2Fh                  ; get DTA, don't hit disk but
        jz      OnThrough               ;  DTA must be set correctly!

        cmp     ah,29h                  ; for system calls 29h -> 30h ....
        jb      OnThrough
        cmp     ah,30h                  ; don't restore directory...
        jbe     final_call_for_DOS              ; ...they don't hit disk

        cmp     ah,3Fh                  ; file handle read
        jz      final_call_for_DOS
        cmp     ah,40h                  ; file handle write
        jz      final_call_for_DOS
        cmp     ah,50h                  ; for system calls 50h -> 51h ....
        jz      final_call_for_DOS
        cmp     ah,51h                  ; don't restore directory...
        jz      final_call_for_DOS              ; ...they don't hit disk

; restore the DOS environment

OnThrough:
        push    ax
        push    bx
        push    dx
        push    es

        SetKernelDS     es
        cmp     [CurTDB], 0
        je      DeadTDB
        and     Kernel_Flags,NOT KF_restore_disk
        mov     ds,[CurTDB]
        cmp     ds:[TDB_sig],TDB_SIGNATURE
        jz      @F
DeadTDB:
        jmp     done_restoring_dos
@@:

; restore DTA

        mov     ax,ds:[TDB_DTA].sel
        mov     dx,ds:[TDB_DTA].off
        cmp     dx,curDTA.off
        jnz     restore_DTA
        cmp     ax,curDTA.sel
        jz      dont_restore_DTA
restore_DTA:
        mov     curDTA.sel,ax
        mov     curDTA.off,dx
        push    ds
        mov     ds,ax
        mov     ah,1Ah
        call    real_DOS
        pop     ds
dont_restore_DTA:


; restore drive and directory

;-----------------------------------------------------------------------;
; We now need to perform a little check.                                ;
; On DOS >= 3.20 it is possible that the phantom drive state            ;
; has changed since we stored this tasks current drive and current      ;
; directory in his task header. UNDER NO CIRCUMSTANCES do we want       ;
; to SetDrive or CHDIR on a phantom drive if the first level of hooks   ;
; are in (to allow this results in the "Please Insert Disk..." message) ;
; so we check out the SetDrive drive number.                            ;
; If it is phantom we will NOT restore drive or directory.              ;
;-----------------------------------------------------------------------;

        xor     dx,dx
        mov     dl,ds:[TDB_Drive]
        and     dl,01111111b
        mov     bx,dx                   ; Index into PhantArray
        CheckKernelDS   es
        cmp     byte ptr PhantArray[bx],0
        jnz     done_restoring_dos

no_drive_check:

        mov     ax,ds
        cmp     ax,cur_drive_owner
        jz       hasnt_been_changed

        inc     InScheduler             ; prevent Int 24h dialog boxes

        lar     ax, cur_drive_owner     ; Ensure we have valid TDB
        jnz     restore_dos             ; in cur_drive_owner
        test    ah, DSC_PRESENT
        jz      restore_dos
        lsl     ax, cur_drive_owner
        cmp     ax, TDBsize-1
        jb      restore_dos
        push    es
        mov     es, cur_drive_owner
        UnsetKernelDS   es
        cmp     es:[TDB_sig], TDB_SIGNATURE
        jne     restore_dos0            ; Dead TDB, can't compare
        mov     al, es:[TDB_Drive]
        ; these messages allow to track current drive problems
        ; krDebugOut DEB_WARN, "Current Drive Owner: #ES Current TDB #DS"
        ; krDebugOut DEB_WARN, "Current Drive Owner: Drive #AX"
        ; krDebugOut DEB_WARN, "Current TDB: Drive #DX"
        and     al,01111111b
        cmp     al, dl
        jne     restore_dos0            ; Drive the same?

        push    cx                      ; Compare directories
        push    si
        push    di
        mov     si, TDB_LFNDirectory
        mov     di, si
        xor     al, al                  ; Scan for end of string
        mov     cx, size TDB_LFNDirectory
        cld
        ; Current drive problem trace
        ; krDebugOut DEB_WARN, "Current Drive Owner: @es:di / Current TDB: @ds:si"
        repne   scasb
        mov     cx, di                  ; Calculate length
        sub     cx, si

        mov     di, si
        rep     cmpsb
        pop     di
        pop     si
        pop     cx
        pop     es
        ResetKernelDS   es
        jnz     restore_directory       ; We know the drive is the same
        jmps    have_new_owner


restore_dos0:
        pop     es
restore_dos:
        mov     ah,0Eh
        call    real_DOS                ; select the disk

restore_directory:
        mov     dx,TDB_LFNDirectory

        ; current directory problem trace
        ; krDebugOut DEB_WARN, "Restoring directory @ds:dx"

        mov     ah,3Bh
        call    real_DOS                ; change directory

have_new_owner:
        dec     InScheduler             ; allow int 24's
        mov     cur_drive_owner,ds

hasnt_been_changed:

done_restoring_dos:

        ; current drive/dir problem trace
        ; krDebugOut DEB_WARN, "Done restoring dos"

        pop     es
        UnSetKernelDS   es
        pop     dx
        pop     bx
        pop     ax
        jmp     final_call_for_DOS

cEnd nogen


;-----------------------------------------------------------------------;
; real_DOS                                                              ;
;                                                                       ;
; Calls the real DOS.                                                   ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 07-Aug-1989 23:45:48  -by-  David N. Weise  [davidw]             ;
; Removed WinOldApp support.                                            ;
;                                                                       ;
;  Mon Apr 20, 1987 07:59:00p  -by-  R. O.           [      ]           ;
; Set cur_dos_PDB when we call DOS to change it, for efficiency.        ;
;                                                                       ;
;  Sun Jan 11, 1987 07:18:19p  -by-  David N. Weise  [davidw]           ;
; Put the per task maintenance of ^C here instead of in the switcher.   ;
;                                                                       ;
;  Sun Jan 04, 1987 01:19:16p  -by-  David N. Weise  [davidw]           ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   far_real_dos,<PUBLIC,FAR>
cBegin nogen
        call    real_dos
        ret
cEnd nogen

cProc   real_dos,<PUBLIC,NEAR>
cBegin nogen
        pushf
        push    ds
        SetKernelDS
        mov     Kernel_InDOS,1

        push    bx
if KDEBUG
        cmp     ah, 50h                 ; SET PSP
        jne     OK_PDB                  ; No, all's fine
        cmp     bx, Win_PDB             ; It is Win_PDB, isn't it?
        je      OK_PDB
        int 3
        int 3
OK_PDB:
endif
        mov     bx, Win_PDB
        cmp     bx, cur_dos_PDB
        je      PDB_ok

        push    ax
        mov     cur_dos_PDB,bx
ifdef W_Q21
        call    SetPDBForDOS
else

        mov     ah,50h
        pushf
ifndef WOW
ife PMODE32
        FCLI
endif
endif
if ROM
        call    prevInt21Proc
else
        call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
endif
endif ;WOW
        pop     ax


PDB_OK:
        pop     bx


ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        test    fBooting,1
        jnz     @f

        krDebugOut DEB_WARN, "DOS Call        #AX bx #BX cx #CX dx #DX"

        cmp     ah,3dh                  ; Open ?
        jnz     @f

        pop     ds                      ; USERs DS
        push    ds
        UnSetKernelDS

        krDebugOut DEB_WARN,"Opening File @DS:DX"

        SetKernelDS
@@:

        cmp     ah,3ch                  ; Create ?
        jnz     @f

        pop     ds                      ; USERs DS
        push    ds
        UnSetKernelDS

        krDebugOut DEB_WARN,"Creating File @DS:DX"

        SetKernelDS
@@:

endif


ifdef W_Q21
;   If we are the running in protected mode then there is no need to
;   switch to v86 mode and then to call the DOSKrnl for most Int 21
;   operations - since mode switches are slow and DOSX has to read
;   into a buffer in low memory and copy it high.   Since we just want
;   to call the Win32 file system we can stay in protected mode.
;   For some DOS calls which don't happen very frequently we don't
;   bother intercepting them.

        cmp     ah,59h                  ; GetExtendedError ?
        jz      short @f
        ; SetDosErr 0h
        mov     WOWLastError,0h
@@:

;-----------------------------------------------------------------------------
; Dispatch code for WOW quick entry points
;-----------------------------------------------------------------------------

        cmp     ah, QD_FIRST
        jb      really_call_dos
        cmp     ah, QD_LAST
        ja      really_call_dos
        push    bx
        xor     bh, bh
        mov     bl, ah
        sub     bx, QD_FIRST
        shl     bx, 1
        mov     bx, QuickDispatchTable[bx]
        mov     QuickDispatchAddr, bx
        pop     bx
        jmp     word ptr QuickDispatchAddr

really_call_dos:

ifndef IGROUP_HAS_ENOUGH_ROOM
        cmp     ah, QD_LFNAPI
        je      QuickLFNApiCall
endif

        jmp     Not_WOW_Handled

;-----------------------------------------------------------------------------
; WOW quick entry points
;-----------------------------------------------------------------------------

QuickLFNApiCall:
        ; first, we emulate dos to reduce size of 32-bit required processing
        ; then we don't care for many other fun things like retrying anything
        ; through dos as we call into dem from here and thus result is
        ; likely to be the same

        ; this is a place-holder for user flags - see demlfn.c for details
        pushf

        push ES

        ; next goes user ds - we need to get it off the stack - it however is
        ; already there... we need to replicate it's value somehow

        push ax ; there will it be - bogus value for now
                ; could have been a sub sp, 2

        push bp
        push di
        push si
        push dx
        push cx
        push bx
        push ax
        mov bx, sp
        mov dx, ss:[bx+20] ; dx - user ds
        mov ss:[bx + 14], dx ; shove user ds into the right place

        ; this call takes ss:sp as a pointer to a dos-like user stack frame
        ;

        cCall WOWLFNEntry,<ss, bx>

        ; return is dx:ax, where ax is non-zero for errors and
        ; dx is 0xffff for hard error
        ; if hard error case is encountered, the procedure turns to
        ; "real dos" then, allowing for int24 to be fired properly
        ; To continue in real_dos we need to restore regs
        ; dem does not touch registers on failed calls thus
        ; we can pop them off the stack and continue
        ;
        SetDosErr ax
        ; mov WOWLastError, ax

        ; resulting flags are :
        ;   - if no carry then no error
        ;   - if carry then error
        ;      - if zero then harderror


        pop ax ; restore ax
        pop bx ;
        pop cx
        pop dx
        pop si
        pop di

        ; here we need to preserve flags so they stay after the stack
        ; adjustment
        add sp, 6 ; the rest are not important to retrieve

        ; now get the mod flags
        popf

        .386
        jnc QuickDone

        ; carry - this is an error

        jz Not_WoW_Handled ; if zero - hard error there

        ; here zero is not set - the just return error

        .286p

        ; here is error condition to be returned to the app

        ; restore error code and return to the app
        mov ax, WOWLastError
        jmp QerrRet


QuickDelete:
        push    dx
        push    bx
        push    ax
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WOWDelFile,<BX,DX>

;       DX = FFFF, AX = Error Code      if failure
;       AX = 0                          if success

        inc     dx
        jnz     qdf_ok

        jmp     DoDos

qdf_ok:
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

        regptr  cxdx,cx,dx
        regptr  axdx,ax,dx

QuickExtendedError:

        ; CheckDosErr
        cmp     WOWLastError, 0
        jnz     DoExtendedError
        jmp     Not_WOW_Handled

DoExtendedError:
        GetDosErr ax, ch, bl, bh
        ; mov     ax,WOWLastError ;load values for extended error
        ; mov     bh,WOWErrClass
        ; mov     bl,WOWErrAction
        ; mov     ch,WOWErrLocation ; location
        jmp     QuickDone

QuickGetDate:
        cCall   WowGetCurrentDate
        push    dx                              ;year
        mov     dl, ah                          ;monthday
        mov     ah, al                          ;
        mov     cl, 4                           ;shift count
        shr     ah, cl
        mov     dh, ah                          ;month
        and     al, 0fh                         ;weekday
        mov     ah, 2ah                         ;reload ah
        pop     cx                              ;cx is now the year
        jmp     QuickDone


QuickGetDefaultDrive:
        call    GetDefaultDriveFromDOS
        mov     CurDOSDrive, al
        jmp     QuickDone

GetDefaultDriveFromDOS:
        push    di
        push    es
        les     di, pPMDosCURDRV
        mov     al, byte ptr es:[di]            ;get drive number from DOS

        ; GetDefaultDriveFromDos trace
        ; pusha
        ; xor     ah, ah
        ; krDebugOut DEB_WARN, "GetDefaultDriveFromDos: ret #ax"
        ; popa

        pop     es
        pop     di
        ret

QuickSetPSPAddress:
        call    SetPDBForDOS
        jmp     QuickDone

SetPDBForDOS:
        push    es
        push    di
        push    cx
        push    dx
        push    bx

        DPMICALL 0006h                  ; Get physical address

        mov     bx,cx                   ; hiword of address
        mov     cx,4                    ; shift count
        shr     dx,cl
        mov     cx,12                   ; for high nibble
        shl     bx,cl
        or      dx,bx                   ; now real mode segment

        les     di, pPMDosPDB           ; get pointer to PDB in DOS
        mov     word ptr es:[di],dx     ; set new PDB

        pop     bx
        pop     dx
        pop     cx
        pop     di
        pop     es
        ret

QuickSetDefaultDrive:
        push    dx
        push    ax

        call    GetDefaultDriveFromDOS
        cmp     dl, al                          ;doing a NOP?
        jz      short @f                        ;yes, skip call to WOW

        cCall   WowSetDefaultDrive,<DX>

        mov     CurDOSDrive, al                 ;returned from SetDefaultDrive
@@:
        pop     ax
        mov     al, 26                          ;this is what DOS does
        pop     dx
        jmp     QuickDone

QuickGetCurrentDirectory:
        push    ax
        push    dx
        push    bx
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WowGetCurrentDirectory,<DX,BX,SI>

        pop     bx
        inc     dx                              ;DX=FFFF on error
        pop     dx
        jz      short qgcd_err                  ;jif error
        pop     ax
        mov     al, 0                           ;this is what DOS does
        jmp     QuickDone

QuickSetCurrentDirectory:
        push    ax
        push    dx
        push    bx
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WowSetCurrentDirectory,<BX,DX>

        pop     bx
        inc     dx                              ;DX=FFFF on error
        pop     dx
        jz      short qgcd_err                  ;jif error
        pop     ax
        mov     al, 0                           ;BUGBUG is this what DOS does?
        jmp     QuickDone

qgcd_err:
        add     sp, 2                           ;leave error code in AX
        SetDosErr ax, 9, 1ch, 1
        ; mov     WOWLastError,ax                ;use this for filefind errors
        ; mov     WOWErrClass,1                   ;this is what DOS seems to do
        ; mov     WOWErrAction,1ch
        ; mov     WOWErrLocation,9
        jmp     QErrRet

QuickDeviceIOCTL:
        cmp     al, 8                           ;removeable media only
        jz      short @f
        jmp     Not_WOW_Handled
@@:
        push    dx

        cCall   WowDeviceIOCTL,<BX,AX>

        inc     dx
        pop     dx
        jnz     short @f
        jmp     QErrRet
@@:
        jmp     QuickDone


QuickFindFirstFile:
        push    dx
        push    bx
        push    si
        push    di
        mov     si, curDTA.sel
        mov     di, curDTA.off
        mov     bx,sp
        mov     bx,ss:[bx + 8]  ; BX = USER DS

ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        test    fBooting,1
        jnz     @f

        mov     ds,bx                ; USERs DS
        UnSetKernelDS
        krDebugOut DEB_WARN, "QuickFindFirstFile looking for @DS:DX"
        SetKernelDS
@@:
endif

        cCall   WowFindFirst,<CX,BX,DX,SI,DI>

ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        or      ax, ax
        jnz     @f
        mov     bx, curDTA.off
        mov     si, curDTA.sel
        mov     ds, si
        UnSetKernelDS
        mov     si, bx
        mov     bx, 18h
        mov     di, [si+bx]
        mov     bx, 16h
        mov     dx, [si+bx]
        mov     bx, 1Eh
        add     bx, si
        krDebugOut DEB_WARN, "QuickFindFirstFile found @DS:BX, date #DI, time #DX"
        mov     bx, 1Ah
        mov     di, [si+bx]
        mov     bx, 1Ch
        mov     dx, [si+bx]
        mov     bx, 15h
        mov     bl, [si+bx]
        xor     bh, bh
        krDebugOut DEB_WARN, "                     attribute #BX size #DX:#DI"
        SetKernelDS
@@:
endif

        pop     di
        pop     si
        pop     bx
        pop     dx
        or      ax, ax
        jnz     qfErr
        jmp     QuickDone

QuickFindNextFile:
        push    si
        push    di

        mov     si, curDTA.sel
        mov     di, curDTA.off
        cCall   WowFindNext,<SI,DI>
        pop     di
        pop     si
        or      ax, ax
        jnz     qfErr
        jmp     QuickDone
qfErr:
        SetDosErr ax,2,3,8
        ; mov     WOWLastError,ax                ;use this for filefind errors
        ; mov     WOWErrClass,8
        ; mov     WOWErrAction,3  ; file or item not found, prompt user
        ; mov     WOWErrLocation,2 ; location is block device

        krDebugOut DEB_WARN, "QFindErr: #AX"

        jmp     QErrRet

QuickLSeek:
        push    dx
        push    bx
        push    ax

        xor     ah,ah
        cCall   WowFileLSeek,<BX,CXDX,AX,cur_dos_PDB,0,pFileTable>

;       DX:AX = File Position           if success
;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jnz     LSeekFinish
        jmp     DoDos
LSeekFinish:
        dec     dx
        add     sp,6
        jmp     QuickDone

QuickCreate:
        push    dx
        push    bx
        push    ax

        test    cx, 8           ; ATTR_VOLUME?
        jz      short @f        ; no, ok
        jmp     DoDos           ; yes, not supported in wow32
@@:

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileCreate,<CX,BX,DX,cur_dos_PDB,0,pFileTable>

;       AX = FileHandle                 if success
;       AX = FFFF                       if path was a device
;       DX = FFFF, AX = Error Code      if failure

        cmp     ax,0FFFFh
        jnz     short @f        ;
        jmp     DoDos           ; Device case, just go through DOS
@@:
        inc     dx              ; Set the zero flag on error.
        jz      QOpenError      ;   Error occured
        add     sp,2            ; discard AX
        pop     bx
        pop     dx
ifdef TraceInt21
        jmp     QuickDone       ; Success
else
        jmp     QuickDone       ; Success
endif

QuickOpen:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        xor     ah,ah           ; clear AH leaving file-access in AX
        cCall   WowFileOpen,<BX,DX,AX,cur_dos_PDB,0,pFileTable>

;       AX = FileHandle                 if success
;       AX = FFFF                       if path was a device
;       DX = FFFF, AX = Error Code      if failure

        cmp     ax,0FFFFh
ifdef TraceInt21
        jnz     @f
        jmp     DoDos
@@:
else
        .386
        jz      DoDos           ; Device case, just go through DOS
        .286p
endif
        inc     dx              ; Set the zero flag on error.
        jz      QOpenError      ;   Error occured
        add     sp,2            ; discard AX
        pop     bx
        pop     dx
        jmps    QuickDone       ; Success

QOpenError:
        cmp     ax, 3           ; If the error is not file_not_found or path_not_found
ifdef TraceInt21
        jbe     @f
        jmp     DoDos
@@:
else
        .386
        ja      DoDos           ; then go through DOS again for the open.
        .286p
endif
        cmp     ax, 2
        jb      DoDos

        SetDosErr ax,2,3,8
        ; mov     WOWLastError,ax
        ; mov     WOWErrClass,8
        ; mov     WOWErrAction,3  ; file or item not found, prompt user
        ; mov     WOWErrLocation,2 ; location is block device

        add     sp,2            ; discard saved AX, since AX = Error Code
        pop     bx
        pop     dx
QErrRet:
ifdef TraceInt21
        krDebugOut DEB_WARN, "Q21 fails    AX #AX bx #BX cx #CX dx #DX (t)"
endif
        pop     ds
        popf
        stc                     ; Set Carry = ERROR
        ret

QuickRead:
        pop     ax              ; AX = USER DS
        push    ax
        push    dx                      ; save user pointer
        cCall   WowFileRead,<BX,AXDX,0,CX,cur_dos_PDB,0,pFileTable>

;       AX = Number Bytes Read
;       DX = FFFF, AX = Error Code

        inc     dx
        pop     dx              ; restore user pointer
        jz      QRError
QuickDone:
ifdef TraceInt21
        krDebugOut DEB_WARN, "Q21 succeeds AX #AX bx #BX cx #CX dx #DX (t)"
endif
        pop     ds
        popf
        clc                     ; Clear Carry - OK Read
        ret

QuickClose:
        push    dx
        push    bx
        push    ax
        cCall   WowFileClose,<BX,cur_dos_PDB,0,pFileTable>

;       DX = FFFF, AX = Error Code      if failure
;       AX = FFFF                       if path was a device

        cmp     ax,0FFFFh
        jz      DoDos           ; Device opens go through DOS
        inc     dx              ; Sets zero flag on error.
        jz      DoDos           ; Let DOS Handle Close Errors
        pop     bx              ; Throw old AX out
        pop     bx
        pop     dx
        mov     ah,3Eh          ; bogus multiplan fix
        jmps    QuickDone       ; Success

DoDos:
        pop     ax
        pop     bx
        pop     dx
        jmp     Not_WOW_Handled

QRError:
        mov     ah,3Fh          ; On Error Retry Operation Via DOEem
        jmp     Not_WOW_Handled

QuickGetSetAttributes:
        cmp     al, 0
        jz      short qget_attr
        cmp     al, 1
        jz      short qset_attr
        jmp     Not_WOW_Handled

qget_attr:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileGetAttributes,<BX,DX>

;       AX = Attributes                 if success
;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jz      DoDos           ; if failure retry through DOS
        mov     cx,ax           ; move result into CX
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

qset_attr:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileSetAttributes,<CX,BX,DX>

;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jz      DoDos           ; if failure retry through DOS
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone


QuickFileDateTime:
        cmp     al, 0
        jz      short qget_datetime
        cmp     al, 1
        jz      short qset_datetime
        jmp     Not_WOW_Handled

qget_datetime:
        push    dx
        push    bx
        push    ax
        cCall   WowFileGetDateTime,<BX,cur_dos_PDB,0,pFileTable>

;       AX = Time, DX = Date            if success
;       AX = FFFF                       if failure

        cmp     ax,0FFFFh
        jz      DoDos
        mov     cx,ax
        pop     ax
        pop     bx
        add     sp,2            ; throw away saved DX
        jmp     QuickDone

qset_datetime:
        push    dx
        push    bx
        push    ax
        cCall   WowFileSetDateTime,<BX,CX,DX,cur_dos_PDB,0,pFileTable>

;       AX = 0                          if success
;       AX = FFFF                       if failure

        cmp     ax,0FFFFh
        jnz     short @f
        jmp     DoDos
@@:
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

QuickLock:
        push    dx
        push    bx
        push    ax
        cCall   WowFileLock,<AX,BX,CX,DX,SI,DI,cur_dos_PDB,0,pFileTable>

;       DX = FFFF, AX = Error Code      if failure
;       AX = 0                          if success

        inc     dx
        jnz     FinishLock
        cmp     ax, 21h                 ;is this lock violation?
        jz      short @f                ;yes, give it back to app
        jmp     DoDos
@@:
        add     sp,2            ; discard saved AX, since AX = Error Code
        pop     bx
        pop     dx
        SetDosErr ax,2,2,10
       ; mov     WOWLastError,ax
       ; mov     WOWErrClass,10          ;ext. err info for lock violation
       ; mov     WOWErrAction,2
       ; mov     WOWErrLocation,2
        jmp     QErrRet

FinishLock:
        add     sp,2            ; throw out old AX
        pop     bx
        pop     dx
        jmp     QuickDone

QuickWrite:
        pop     ax              ; AX = USER DS
        push    ax
        push    dx
        cCall   WowFileWrite,<BX,AXDX,0,CX,cur_dos_PDB,0,pFileTable>

;       AX = Number Bytes Read
;       DX = FFFF, AX = Error Code

        inc     dx
        pop     dx              ; restore user pointer
        jz      RetryWrite
        jmp     QuickDone

RetryWrite:
        mov     ah,40h          ; On Error Retry Operation Via DOEem

;-----------------------------------------------------------------------------
; END OF WOW quick entry points
;-----------------------------------------------------------------------------

Not_WOW_Handled:
endif  ; W_Q21

;
; Intercept Select Disk and Get Current Disk
;
        cmp     ah, 0Eh
        je      rd_Select
        cmp     ah, 19h
        je      rd_Get
rd_no_intercept:

;;;     test    Kernel_flags,kf_restore_CtrlC
;;;     jz      no_need_to_set_CtrlC
;;;     and     Kernel_flags,not kf_restore_CtrlC
;;;
;;;     push    ax
;;;     push    bx
;;;     push    es
;;;     mov     es,curTDB
;;;     cmp     es:[TDB_sig],TDB_SIGNATURE
;;;     jne     PDB_okay
;;;
; restore PDB
;;;
;;;     mov     bx,Win_PDB
;;;     cmp     bx,cur_dos_PDB
;;;     jz      PDB_okay
;;;if KDEBUG
;;;     cmp     bx,es:[TDB_PDB]
;;;     jz      @F
;;;     int     1
;;;@@:
;;;endif
;;;     mov     cur_dos_PDB,bx
;;;     mov     ah,50h
;;;     pushf
;;;ife PMODE32
;;;     cli
;;;endif
;;;     call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
;;;PDB_okay:
;;;
;;;     pop     es
;;;     pop     bx
;;;     pop     ax
;;;no_need_to_set_CtrlC:

        pop     ds
        UnSetKernelDS
ifndef WOW
ife PMODE32
        FCLI
endif
endif
if ROM
        cCall    <far ptr PrevROMInt21Proc>
else
        call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
ifdef TraceInt21
        pushf
        jc      rd_Trace_CarrySet
        krDebugOut DEB_WARN, "DOS succeeds AX #AX bx #BX cx #CX dx #DX"
        jmp     @f
rd_Trace_CarrySet:
        krDebugOut DEB_WARN, "DOS fails    AX #AX bx #BX cx #CX dx #DX"
@@:
        popf
endif
endif
rd_after_DOS:
        push    ds
        SetKernelDS
rd_after_DOS1:
        push    ax
        mov     al,kernel_inINT24
        mov     Kernel_InDOS,al         ; dont change flags!
        pushf
        or      al, al                  ; If in int 24h, don't
        jnz     @F                      ; reset extended error yet
        cmp     LastExtendedError[2],-1 ; Flag to indicate saved status
        je      @F

        push    dx
        lea     dx, LastExtendedError
        mov     ax, 5D0Ah
        pushf
if ROM
        call    prevInt21Proc
else
        call    cs:prevInt21Proc
endif
        mov     LastExtendedError[2], -1        ; Forget the status
        pop     dx
@@:
        popf
        pop     ax
        pop     ds
        UnSetKernelDS
        ret

rd_Select:
        ReSetKernelDS
        cmp     dl, CurDOSDrive         ; Setting to current drive?
        jne     rd_invalidate           ;  no, invalidate saved value

        mov     al, DOSDrives           ;  yes, emulate call

rd_intercepted:
        pop     ds                      ; Return from the DOS call
        UnSetKernelDS
        popf
        jmps    rd_after_DOS

rd_invalidate:
        ReSetKernelDS
        mov     CurDOSDrive, 0FFh       ; Invalidate saved drive
        jmps    rd_no_intercept

rd_Get:
        ReSetKernelDS
        cmp     CurDOSDrive, 0FFh       ; Saved drive invalid?
        jne     rd_have_drive           ;  no, return it

        pop     ds                      ;  yes, call DOS to get it
        UnSetKernelDS
ifndef WOW
ife PMODE32
        FCLI
endif
endif
if ROM
        cCall    <far ptr PrevROMInt21Proc>
else
        call    cs:prevInt21Proc
endif
        push    ds
        SetKernelDS
        mov     CurDOSDrive, al         ; And save it
        jmps    rd_after_DOS1

rd_have_drive:
        ReSetKernelDS
        mov     al, CurDOSDrive         ; We have the drive, emulate call
        jmps    rd_intercepted          ; and return

cEnd nogen

if ROM  ;----------------------------------------------------------------


;-----------------------------------------------------------------------;
; PrevROMInt21Proc                                                      ;
;                                                                       ;
; Calls the routine pointed to by the PrevInt21Proc DWORD.  Used by     ;
; ROM Windows kernel to when PrevInt21Proc is not a CS variable, and    ;
; kernel's DS is not addressable.                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   PrevROMInt21Proc,<PUBLIC,FAR>
cBegin nogen

        push    ds
        SetKernelDS

        push    bp
        mov     bp,sp

        push    PrevInt21Proc.sel
        push    PrevInt21Proc.off

        mov     ds,[bp][2]
        UnSetKernelDS
        mov     bp,[bp]
        retf    4

cEnd   nogen


endif ;ROM      ---------------------------------------------------------


;**
;
; NoHookDOSCall -- Issue an INT 21 circumventing all Windows Hooks
;
;       This call is provided as a Kernel service to Core routines
;       which wish to issue DOS INT 21h calls WITHOUT the intervention
;       of the Windows INT 21h hooks.
;
;   ENTRY:
;       All registers as for INT 21h
;
;   EXIT:
;       All registers as for particular INT 21h call
;
;   USES:
;       As per INT 21h call
;
;
cProc   NoHookDOSCall,<PUBLIC,FAR>
cBegin
        call    real_DOS
cEnd


;**
;
; DOS3CALL -- Issue an INT 21 for caller
;
;       This call is provided as a Kernel service to applications that
;       wish to issue DOS INT 21h calls WITHOUT coding an INT 21h, which
;       is incompatible with protected mode.
;
;   ENTRY:
;       All registers as for INT 21h
;
;   EXIT:
;       All registers as for particular INT 21h call
;
;   USES:
;       As per INT 21h call
;
;
cProc   DOS3CALL,<PUBLIC,FAR>
cBegin  nogen
        DOSCALL
        retf
cEnd    nogen


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\i21task.asm ===
.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include kdos.inc
include eems.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

externFP LoadLibrary
externFP LoadModule
externFP GlobalFree,
externFP GlobalFreeAll
externFP GlobalCompact
externFP FreeModule
externFP GlobalDOSFree
externFP FreeSelector
externFP GetProcAddress                  ; WIN32S
externFP ISetErrorMode                   ; WIN32S
externFP ISetHandleCount

externFP ExitKernelThunk
externNP DPMIProc

extrn   BUNNY_351:FAR

ifdef WOW
DRIVE_REMOTE    equ 4
externW  headTDB
externFP lstrlen
externFP WOWSetIdleHook
externFP GetDriveType
externFP WowShutdownTimer
externFP WowTrimWorkingSet
externB  fShutdownTimerStarted
externW cur_drive_owner
endif

externW pStackBot
;externW pStackMin
externW pStackTop

DataBegin

externB Kernel_flags
externB num_tasks
externB Kernel_InDOS
externB Kernel_InINT24

externB WOAName
externB grab_name
externB fBooting
externB graphics
externB fExitOnLastApp

externW cur_dos_PDB
externW Win_PDB
externW headPDB
externW topPDB
externW curTDB
externW curDTA
externW PHTcount
externW gmove_stack
externW MyCSSeg
externW wExitingTDB
externD lpSystemDir

if KDEBUG
externW allocTask
endif

if ROM
externD prevInt21Proc
endif

externD lpint21
externD pExitProc
if PMODE32
externD pDisplayCritSec
externW	PagingFlags
externD lpReboot
endif

ifdef FE_SB
ifndef KOREA
externD pJpnSysProc
endif
endif

DataEnd

sBegin  DATA
externW gmove_stack


ifdef   PMODE32
ifndef WOW
WIN32S = 1           ; enable code for Win32S support
endif
endif

ifdef WIN32S
; Win32S support
selExecPE       DW      0
offExecPE       DW      0
endif

sEnd    DATA

assumes DS,NOTHING
sBegin	CODE
assumes CS,CODE

ife ROM
externD prevInt21Proc
endif

externNP Real_DOS
externNP PathDrvDSDX
externNP SetErrorDrvDSDX
externNP SetCarryRet
externNP ExitSchedule
externNP UnlinkObject
externNP final_call_for_DOS

externNP cmp_sel_address
externNP free_sel
externNP SegToSelector

if SDEBUG
externNP DebugExitCall
endif
externNP DeleteTask


;-----------------------------------------------------------------------;
; Set_DTA		(DOS Call 1Ah)					;
; 									;
; Simply records on a task basis the DTA.				;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Jan 10, 1987 09:19:36p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds, nothing
	assumes es, nothing

cProc	Set_DTA,<PUBLIC,NEAR>
cBegin nogen
	push	es
	SetKernelDS	es
	mov	curDTA.off,dx
	mov	curDTA.sel,ds
	mov	es,curTDB
	UnSetKernelDS	es
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jne	Set_DTA_noTDB
	mov	es:[TDB_DTA].off,dx
	mov	es:[TDB_DTA].sel,ds
Set_DTA_noTDB:
	pop	es
	jmp	final_call_for_DOS
cEnd nogen


;-----------------------------------------------------------------------;
; SaveRegs								;
; 									;
; Does what it says.							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 16, 1987 09:57:49p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	SaveRegs,<PUBLIC,NEAR>
cBegin nogen

	xchg	dx, user_DX		; Return address in DX
	push	es
	push	bx
	push	ax
	push	cx
	push	si
	push	di
	and	USER_FL,11111110b	; clc flag
	push	dx
	mov	dx, user_DX		; Rescue DX for what it's worth
	cld

	ret
cEnd nogen

;-----------------------------------------------------------------------;
; RestoreRegs								;
; 									;
; Does what it says and (used to cli).					;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 16, 1987 10:00:41p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	RestoreRegs,<PUBLIC,NEAR>
cBegin nogen

	pop	di			; Return address
	xchg	di, user_BP		; Insert for ret later, get saved BP
	mov	bp, di
	dec	bp
	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	bx
	pop	es
	pop	dx
	pop	ds
	ret				; SP points to user_BP
cEnd nogen

;-----------------------------------------------------------------------;
;                                                                       ;
;  Handle the Int21 func 67 call "Set Maximum Handle Count"             ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   SetMaxHandleCount,<PUBLIC,NEAR>
cBegin  nogen
        pop     ds
        pop     bp                              ; clean up stack
        dec     bp

        cmp     bx, 255
        ja      smhc_err1

        push    bx
        push    cx
        push    dx

        cCall   ISetHandleCount,<bx>
        pop     dx
        pop     cx
        pop     bx

        cmp     ax, bx                          ; did we get everything?
        jne     smhc_err2
        clc
        jmp     smhcexit

smhc_err1:
        mov     ax,4                            ; too many open files
        stc                                     ; set carry flag
        jmp     smhcexit

smhc_err2:
        mov     ax,8                            ; not enough memory
        stc                                     ; set carry flag
smhcexit:
        STIRET
        ret


cEnd    nogen


;-----------------------------------------------------------------------;
; Set_Vector		(DOS Call 25h)					;
; Get_Vector		(DOS Call 35h)					;
;									;
;									;
; Arguments:								;
;									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Jan 17, 1987 01:48:29a  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Set_Vector,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	es
	call	IsItIntercepted
	jnz	notintercepted
	SetKernelDS es
	mov	es, CurTDB		; We intercepted it, change
	UnSetKernelDS es		; vector in the TDB
	mov	es:[di].off, dx
	mov	es:[di].sel, ds
	jmps	sv_done 		; And just return
notintercepted:
	SetKernelDS es
	cmp	fBooting,1
	jz	sv_no_restrictions
	cmp	graphics,0		; in the stand alone OS/2 box?
	jz	@F
;ifdef   JAPAN
ifdef   NOT_USE_BY_NT_JAPANESE
        push    ax
        push    bx                      ; 04/23/91 -yukini
        mov     bx,0
        cCall   [pJpnSysProc], <bx,ax>  ; call System.JapanInquireSystem to
                                        ; get vector can be modified or not.
        test    ax,ax
        pop     bx
        pop     ax
        jz      sv_done                 ; jump if cannot be modified
else
	cmp	al,1Bh
	jz	sv_done
	cmp	al,1Ch
	jz	sv_done
endif
@@:	cmp	al,21h			; trying to reset our traps?
	jz	sv_done
	cmp	al,24h			; trying to reset our traps?
        jz      sv_done
        cmp     al,2fh                  ; setting idle detect vector?
        jnz     sv_no_restrictions      ; no, proceed normally
        push    ax
        push    dx
        push    ds
        cCall   WOWSetIdleHook          ; set the real hook back in Win32
        pop     ds
        pop     dx
        pop     ax
        jmp     bodacious_cowboys
sv_no_restrictions:
	cmp	al,21h
	jnz	bodacious_cowboys
	mov	lpint21.off,dx
	mov	lpint21.sel,ds
bodacious_cowboys:
	call	real_DOS

sv_done:
	pop	es
	pop	di
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET

cEnd nogen

	assumes	ds, nothing
	assumes	es, nothing

cProc	Get_Vector,<PUBLIC,NEAR>
cBegin nogen
	pop	ds
	pop	bp			; clean up stack
	dec	bp
	push	di
	call	IsItIntercepted
	jnz	notintercepted1
	push	ds			; We intercepted it, get the
	SetKernelDS			; vector from the TDB
	mov	ds, CurTDB
	UnSetKernelDS
	mov	bx, [di]
	mov	es, [di+2]
	pop	ds
	pop	di
	jmps	gv_done
notintercepted1:
	pop	di
	call	real_DOS
gv_done:
        STIRET

cEnd nogen



cProc	IsItIntercepted,<PUBLIC,NEAR>
cBegin nogen
	mov	di, TDB_INTVECS
	cmp	al, 00h
	je	yes_intercepted
	add	di, 4
	cmp	al, 02h
	je	yes_intercepted
	add	di, 4
	cmp	al, 04h
	je	yes_intercepted
	add	di, 4
	cmp	al, 06h
	je	yes_intercepted
	add	di, 4
	cmp	al, 07h
	je	yes_intercepted
	add	di, 4
	cmp	al, 3Eh
	je	yes_intercepted
	add	di, 4
	cmp	al, 75h
yes_intercepted:
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; ExecCall		(DOS Call 4Bh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to WinOldApp.			;
;									;
;  Sat Jan 17, 1987 01:39:44a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ExecCall,<PUBLIC,NEAR>
cBegin nogen
	call	PathDrvDSDX		; Check drive
	jnc	EC1			; Drive OK
	call	SetErrorDrvDSDX 	; Set up errors
	jmp	SetCarryRet		; Error

EC1:	call	SaveRegs
	call	far ptr FarExecCall
	call	RestoreRegs
        STIRET
cEnd nogen


;-----------------------------------------------------------------------;
; TerminatePDB								;
;									;
; It calls DOS to terminate the current task.				;
;									;
; Arguments:								;
;	DI = exit code							;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothing								;
; Registers Preserved:							;
;	none								;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	TerminatePDB,<PUBLIC,NEAR>
cBegin	nogen

	SetKernelDS	ES
	mov	bx, ds				; DS is PDB being terminated
	cmp	cur_dos_PDB, bx			; Ensure DOS/anyone on the
	je	short @F			; int 21h chain has correct PDB
	mov	ah, 50h
	pushf
	call	prevInt21Proc
@@:
	mov	ax, ds:[PDB_Parent_PID]		; Parent PDB
	mov	Win_PDB, ax			; These will be changed by DOS
	mov	cur_dos_PDB, ax

	or	Kernel_Flags[2],KF2_WIN_EXIT
	mov	ax,di			; AL = exit code
	mov	ah, 0			; Alternative exit for PMODE which returns
	call	real_DOS		; let DOS clean up
	UnSetKernelDS	es

	errn$	DosExitReturn

cEnd	nogen

;
; The DOS terminate call above will return to
; the following label, DosExitReturn.  This is
; a separate procedure in order to be declared FAR.
;
	assumes	ds, nothing
	assumes	es, nothing

cProc	DosExitReturn,<PUBLIC,FAR>
cBegin nogen

	SetKernelDS ES
	mov	Kernel_InDOS,0
	mov	Kernel_InINT24,0
	and	Kernel_Flags[2],NOT KF2_WIN_EXIT
	retn

cEnd nogen

;-----------------------------------------------------------------------;
; ExitCall		(DOS Call 4Ch)					;
;									;
; It terminates the current task.					;
;									;
; Arguments:								;
;	AL = exit code							;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothing								;
; Registers Preserved:							;
;	none								;
; Registers Destroyed:							;
;	none								;
; Calls:								;
;	TerminatePDB							;
;	GlobalFreeAll							;
;	UnlinkObject							;
;	DeleteTask							;
;	GlobalFree							;
;	FreeModule							;
; History:								;
;									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Removed WinOldApp support.						;
;									;
;  Sun Apr 26, 1987 03:20:05p  -by-  David N. Weise   [davidw]		;
; Made it switch stacks to the temp_stack because of EMS.		;
; 									;
;  Mon Sep 29, 1986 04:06:08p  -by-  Charles Whitmer  [chuckwh]		;
; Made it kill all threads in the current process.			;
;									;
;  Mon Sep 29, 1986 03:27:12p  -by-  Charles Whitmer  [chuckwh]		;
; Made it call UnlinkObject rather than do the work inline.		;
;									;
;  Mon Sep 29, 1986 09:22:08a  -by-  Charles Whitmer  [chuckwh]		;
; Documented it.							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ExitCall,<PUBLIC,NEAR>
cBegin          nogen

ifdef WOW
        ; Set to a Known DIR so that if an app was running over the network
        ; the user can disconnect once the app terminates.
        ; This also allows a subdirectory to be removed after a Win16 app
        ; had that dir as the current dir, but was terminated.

        SetKernelDS

        push    ax
        push    si
        push    dx
        push    ds

        lds     si,lpSystemDir          ; ds:si points to system directory
        mov     dl,[si]                 ; put drive letter into AL
        add     dl,-65                  ; subtract 'A' to get drive number
        mov     ah,0Eh
        call    real_DOS                ; select disk

        add     si,2                    ; let SI point to the first '\' past d:

        mov     al,[si + 1]             ; save first character after '\'
        push    ax

        mov     byte ptr [si + 1],0     ; null-terminate string after root dir
        mov     dx,si
        mov     ah,3Bh
        call    real_DOS                ; select directory

        pop     ax
        mov     [si + 1],al             ; restore string to its original state
        ;
        ; During task exit/abort ntdos $abort notifies the debugger of the
        ; "module unload" of the EXE using the full path to the EXE that
        ; follows the environment block.  We don't want ntdos to make the
        ; module unload callout because we do it ourself during our
        ; DelModule of the EXE module.  So we have a protocol, we zero
        ; the environment selector in our PDB, DPMI translates this to
        ; segment zero properly, and ntdos skips the callout if the environment
        ; segment is zero.
        ;
        pop     ds
        ReSetKernelDS
        mov     es,[curTDB]               ; DS = current TDB
        mov     es, es:[TDB_PDB]
        xor     ax,ax
        mov     word ptr es:[PDB_environ], ax

        pop     dx
        pop     si
        pop     ax
endif


if SDEBUG
        ;** Save the TDB of the currently exiting task.  We check for this
        ;**     in DebugWrite so that we don't get recursive
        ;**     debug strings at task exit time.  This is a gross hack
        ;**     for QCWin and their numerous param validation errors.
        mov     bx,curTDB               ;Get current task handle
        mov     wExitingTDB,bx          ;Save as exiting TDB
        cCall   DebugExitCall           ;Passes exit code in AL
endif ; SDEBUG

if PMODE32
        .386
        smov    fs, 0
        smov    gs, 0
        .286p

        xchg    di,ax                   ; DI = exit code

        cmp     graphics,1              ; is there a display driver around?
        jnz     @F
	mov	ax,1
ifndef WOW ; WOW doesn't have a display dirver to call
	cCall	pDisplayCritSec,<ax>	; tell display driver to shut up
endif
        or      Kernel_Flags[2],KF2_WIN386CRAZINESS
@@:     mov     ds,curTDB               ; DS = current TDB
        assumes ds,nothing
else
        xchg    di,ax                   ; DI = exit code
        mov     ds,curTDB               ; DS = current TDB
        UnSetKernelDS
endif

; We may have gotten here due to stack checking.  Let's make sure
;  that we are on a stack we can deal with.

        test    ds:[TDB_flags],TDBF_OS2APP
        jz      @F
        mov     ax,sp
        mov     ss:[pStackBot],ax
@@:     xor     ax,ax
        mov     ss:[pStackTop],ax

; remove the PDB from the chain

        mov     es,ds:[TDB_PDB]
        mov     dx,PDB_Chain
        mov     bx,dataOffset HeadPDB
        call    UnlinkObject

        xor     si,si                   ; source of zero

; Dec total # of tasks, if last task in system, then quit Windows completely.

        smov    es,ds
        assumes es,nothing
	SetKernelDS
ifdef WOW
	cmp	fExitOnLastApp,0	; Quit WOW when the last app dies ?
	jz	@f

	cmp	num_tasks,2		; Last Task (ingnoring WOWEXEC) ?
	jz	last_task
@@:
endif
        dec     num_tasks
	jnz	not_the_last_task

last_task:
IF PMODE32
        ;** Unhook local reboot VxD stuff
        cmp     WORD PTR lpReboot[2], 0 ;Reboot handler installed?
        je      @F                      ;No
        push    es
        mov     ax, 0201h               ;Reboot VxD #201:  Set callback addr
        xor     di, di                  ;Zero CS means no SYS VM local
        mov     es, di
        call    [lpReboot]              ;  reboot handler
        pop     es
@@:
ENDIF

        call    BUNNY_351

ifndef WOW				; For WOW ex just want to get out of here - no need to call USER16 or GDI16
	cCall	pExitProc,<si,si>	; this does not return
endif
        cCall   ExitKernelThunk,<si>

        assumes es, nothing
not_the_last_task:

; Signal( hTask, SG_EXIT, ExitCode, 0, Queue ) if we have a user signal proc

        push    es
        cmp     es:[si].TDB_USignalProc.sel,si
        jz      no_signal_proc
        mov     bx,SG_EXIT
        cCall   es:[si].TDB_USignalProc,<es,bx,di,es:[si].TDB_Module,es:[si].TDB_Queue>
no_signal_proc:

	pop	es

	mov	bl,6
	DPMICALL    0202h		 ; DPMI get exception handler vector
        push    cx
        push    dx

        mov     cx,cs
        lea     dx,exit_call_guts
        mov     bl,6
	DPMICALL    0203h		 ; DPMI set exception handler vector

        pop     dx
        pop     cx
;
; Generate an invalid opcode exception fault.  This causes DPMI to call
; our "exception handler."
;
	db	0fh,0ffh
exit_call_guts:
        FSTI                     ; we're called with ints disabled
        mov     bp,sp           ; BP -> RETIP RETCS EC IP CS FL SP SS
;
; Restore the previous invalid exception handler vector.
;
	mov	bl,6
	DPMICALL 0203h
;
; Point the return stack at Kernel's temporary stack.
;
        mov     ax,dataOffset gmove_stack
        mov     [bp+12],ax
        mov     ax,seg gmove_stack
        mov     [bp+14],ax
;
; Replace the return address on the DPMI fault handler routine with
; our exit code.
;
        lea     ax,ExitSchedule
        mov     [bp+6],ax
        mov     [bp+8],cs

        push    es

        cCall   GlobalFreeAll,<si>      ; free up all task data
        pop     es

; Remove from queue.

        push    es
        cCall   DeleteTask,<es>
        pop     es
        mov     ds,es:[TDB_PDB]         ; DS = current PDB

	UnsetKernelDS			; DS is PDB to terminate

	call	TerminatePDB		; Call DOS to close down files etc.

	ReSetKernelDS ES		; TerminatePDB returned with ES set

	xor	bp,bp			; set up valid frame
	mov	ds,curTDB

; If this task has a PHT, decrement the PHT count and clear the pointer
;  and zap the PHT pointer so we don't look at it anymore.
;  NOTE - BP contains a convenient zero.

	mov	ax,ds:[TDB_PHT].sel
	or	ax,ds:[TDB_PHT].off
	jz	no_PHT
	mov	ds:[TDB_PHT].sel,bp
	mov	ds:[TDB_PHT].off,bp
	dec	PHTcount		; dec # tasks with PHT's
no_PHT:
	UnSetKernelDS	es
	cCall	FreeModule,<ds:[TDB_Module]>	; Free the module for this task
	xor	ax,ax
	mov	ds:[TDB_sig],ax 	; Mark TDB as invalid

        ;** Nuke any JFN that is outside the PDB.  We can tell that the
        ;**     JFN points outside the PDB if the offset is zero.  PDB
        ;**     JFN's never have a zero offset and outside ones always do.
	push	ds
	mov	ds, ds:[TDB_PDB]
        cmp     WORD PTR ds:[PDB_JFN_Pointer][0], 0 ;JFN pointer into PDB?
        jne     EC_NoFreeJFN            ;Yes, don't free anything
        push    WORD PTR ds:[PDB_JFN_Table] ;Get our selector
        call    GlobalDOSFree
EC_NoFreeJFN:

	SetKernelDS
 
        cmp     num_tasks,1             ; Last task? (except wowexec)
        jne     @f                      ; branch if not last task
if 0
        ; This code is unneeded because if we're a separate VDM, we exit above when
        ; the last task exited.
        cmp     fExitOnLastApp, 0       ; Shared WOW?
        jne     @F                      ; branch if not shared WOW
endif

        cCall   WowShutdownTimer, <1>       ; start shutdown timer
        mov     fShutdownTimerStarted, 1
        cCall   GlobalCompact,<-1, -1>      ; free up as many pages as possible
        cCall   WowTrimWorkingSet           ; trim working set to minimum
@@:
	mov	bx, topPDB
	mov	Win_PDB, bx
	mov	cur_dos_PDB, bx
	mov	ah, 50h
	pushf
	call	prevInt21Proc		; Set PDB to KERNEL's
	pop	ds
	UnSetKernelDS
	xchg	bx, ds:[TDB_PDB]
	cCall	free_sel,<bx>		; Free the PDB selector

	call	far ptr FreeTDB		; Tosses PDB's memory
        SetKernelDS
ifndef WOW
        mov     curTDB,0        ; We can use this, setting curTDB = 0
else
        ;; We do this a little later - see tasking.asm exitschedule
endif
    if PMODE32			;  in rmode as well in the next rev
	or	PagingFlags, 8	;  to save a few bytes.
    endif	

        ;** Task has been nuked.  Clear the DebugWrite task exiting flag
        mov     wExitingTDB,0

        ; fix current drive owner
        mov     ax, cur_drive_owner
        cmp     ax, curTDB
        jnz     @f
        ; so it is the owner of a current drive -- nuke it
        mov     cur_drive_owner, 0
@@:

if 0    ; We could call this on every task exit -- need to see if
        ; it slows down Winstone 94, if it's needed after we use MEM_RESET
        ; If you enable this call, disable the similar call just above.
        cCall   WowTrimWorkingSet           ; trim working set to minimum
endif

        retf                    ; To ExitSchedule
cEnd nogen	

	assumes	ds, nothing
	assumes	es, nothing

cProc	FreeTDB, <PUBLIC,FAR>
cBegin nogen

	cCall	FreeSelector,<ds:[TDB_MPI_Sel]>
	mov	ax,ds
if KDEBUG
;
; If we're freeing the alloc break task, zero out the global.
;
        SetKernelDS
        cmp     ax,allocTask
        jnz     @F
        mov     allocTask,0
@@:
        UnSetKernelDS
endif
	smov	ds,0
	cCall	GlobalDOSFree,<ax>
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; set_PDB			(DOS Call 50h)				;
; 									;
; This is an undocumented DOS call to set the current PDB.		;
; DOS does not check for ^C's on this call, in fact it never turns	;
; on the interrupts.							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 23, 1987 07:07:14p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	set_PDB,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	mov	cur_dos_PDB,bx
	mov	Win_PDB,bx
	mov	ds,curTDB
	assumes ds,nothing
	mov	ds:[TDB_PDB],bx
	call	real_DOS
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET
cEnd nogen


;-----------------------------------------------------------------------;
; get_PDB								;
;									;
; This is an undocumented DOS call to set the current PDB.		;
; DOS does not check for ^C's on this call, in fact it never turns	;
; on the interrupts.							;
; Trapping this is superfluous is real mode but necessary in protect	;
; mode since the DOS extender may not be doing the segment		;
; translation properly. 						;
;									;
; Entry:								;
;									;
; Returns:								;
;									;
; Registers Destroyed:							;
;									;
; History:								;
;  Tue 13-Jun-1989 18:22:16  -by-  David N. Weise  [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	get_PDB,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	call	real_DOS
	mov	bx,cur_dos_PDB
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET
cEnd nogen

sEnd code

sBegin NRESCODE
assumes cs, NRESCODE
assumes	ds, nothing
assumes	es, nothing

externNP MapDStoDATA


;-----------------------------------------------------------------------;
; BuildPDB								;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 20:15:27  -by-  David N. Weise  [davidw]		;
; Made it avoid closing cached files if the PDB being copied is not	;
; the topPDB.  This is for supporting inheriting a parents files.	;
;									;
;  Mon 11-Sep-1989 19:13:52  -by-  David N. Weise  [davidw]		;
; Removed returning validity in AX, and removed copying of FCBs.	;
;									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to WinOldApp.			;
;									;
;  Sun Jan 18, 1987 00:27:52a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	BuildPDB,<PUBLIC,FAR>,<si,di>
	ParmW	oldPDB
	ParmW	newPDB
	ParmD	ParmBlock
	ParmW	newSize
        ParmW   fWOA
cBegin
	call	MapDStoDATA
	ReSetKernelDS

	push	Win_PDB			; Save current PDB

	mov	bx,oldPDB		; set current PDB for copy
	mov	Win_PDB, bx

	mov	dx,newPDB
	mov	si,newSize
	mov	ah,55h			; duplicate PDB
	int	21h

	mov	bx, oldPDB
	mov	dx, newPDB
	mov	cur_dos_PDB, dx		; DOS call 55h sets the PDB to this

nothing_to_close:

	pop	Win_PDB			; restore former PDB

	xor	di,di

	mov	cx, MyCSSeg
	mov	ds,dx
	UnSetKernelDS
	mov	es,dx
	add	si,dx
	mov	ax,oldPDB
	mov	[di].PDB_Parent_PID,ax	; parent = OldPDB
	mov	[di].PDB_Block_Len,si

	mov	[di].PDB_Exit.off,codeOffset DosExitReturn
	mov	[di].PDB_Exit.sel, cx

; No private global heap yet.

	mov	[di].PDB_GlobalHeap.lo,di
	mov	[di].PDB_GlobalHeap.hi,di

; Set up proper command line stuff.

	lds	si,ParmBlock
	lds	si,ds:[si].lpcmdline	; command line
	mov	di,PDB_DEF_DTA
        mov     cx,di
        cmp     fWOA,0
	jz	@F			; Winoldap can have long command line
        mov     cx,ds:[si]              ; get byte count
        cld
        movsb                           ; copy count byte
        inc     cx
        inc     si
@@:     rep     movsb                   ; Store command line.

cEnd


cProc	FarExecCall,<PUBLIC,FAR>
cBegin nogen

; Check if file extension is .COM, .BAT, .PIF, if so it needs emulation...

        cld
        les     di,User_DSDX


ifdef WOW
;
;  Wow LoadModule handles all forms of exec including
;  pe images, com, bat, pif files etc.
;
        lds     si,User_ESBX
	regptr	esdx,es,dx
	regptr	dssi,ds,si
        cCall   LoadModule,<esdx,dssi>
        cmp     ax, LME_MAXERR          ; check for error...
        jae     ex8
        jmp short ex7                     ; no, return error

else

        mov     cx,-1
	xor	al,al
	repnz	scasb			; scan to end of string
	neg	cx
	dec	cx			; cx has length (including null)
	mov	ax,es:[di-5]
	or	ah,20h
	mov	bx,es:[di-3]		; complete check for .COM
	or	bx,2020h		; convert to lower case

	cmp	ax,'c.' 		; check for .COM file extension
	jnz	ex1b			; no match...attempt load module
	cmp	bx,'mo'
	jz	ex4			; yes! go immediatly to GO

ex1b:	cmp	ax,'b.' 		; check for .BAT extension...
	jnz	ex1c
	cmp	bx,'ta'
	jz	ex4

ex1c:	cmp	ax,'p.' 		; check for .PIF extension...
	jnz	ex2
	cmp	bx,'fi'
        jz      ex4

ex2:    lds     si,User_ESBX
	regptr	esdx,es,dx
	regptr	dssi,ds,si
        push    cx                      ; save length of string
	cCall	LoadModule,<esdx,dssi>
        pop     cx
        cmp     ax, LME_MAXERR          ; check for error...
	jb	ex3
	jmp	ex8
ex3:    cmp     ax, LME_INVEXE		; wrong format?
	jz	ex4
	cmp     ax, LME_EXETYPE		; quick basic app
        jz      ex4

        cmp     ax, LME_PE              ; Win32 PE format
        jz      @F
	jmp	ex7			; no, return error
@@:


ifdef WIN32S
	push    cx
; Win32S support -  (AviN)   11-19-91

        lds     si,User_DSDX
	push	ds
        push    si
        lds     si,User_ESBX
        push    ds:[si+4]           ; CmdLine sel
        push    ds:[si+2]           ;         offset

        les     bx, ds:[si+6]       ; FCB1
        push    es:[bx+2]           ; nCmdShow

        call    FAR PTR ExecPE
        pop     cx

        cmp     ax, 32
        jbe     @F
        jmp     ex8
@@:
        cmp     ax, 11                  ; NOT PE
        je      @F
        jmp     ex7

@@:

; end of Win32S support
endif

ex4:

; Run an old application
;
; If we are running in the OS/2 3x box, we do not support running old
; apps.  If someone trys this, put up a nasty message and return with
; an error.  (Thu 12-Nov-1987 : bobgu)


	mov	dx,cx			; save length of file name
	sub	sp,256			; make room for command line
	smov	es,ss
	mov	di,sp
	lds	si,User_ESBX
	lds	si,ds:[si].lpcmdline
	xor	ax,ax
	xor	cx,cx
	mov	cl,ds:[si]
	inc	cx
        movsb
        stosb
        rep     movsb
	mov	cx,dx
	lds	si,User_DSDX
	rep	movsb
	mov	byte ptr es:[di][-1],10	; terminate with line feed
	mov	di,sp
	add	es:[di],dx

	mov	bx,es
	push	ds
	call	MapDStoDATA
	smov	es, ds
	pop	ds
        ReSetKernelDS es

        test    Kernel_flags[2],KF2_DOSX ; DOSX winoldap doesn't need special
	jnz	@F			 ;  special handling
	mov	ax,dataOffset grab_name
	push	bx
	push	dx
	push	es
	cCall	LoadLibrary,<es,ax>
	pop	es
	pop	dx
	pop	bx
	cmp	ax,32
	jae	@F
	add	sp, 256			; undo damage to stack
	jmps	ex7
@@:

        or      Kernel_flags[1],KF1_WINOLDAP
        lds     si,User_ESBX
	mov	ds:[si].lpcmdline.off,di
	mov	ds:[si].lpcmdline.sel,bx
	mov	dx,dataOffset WOAName
	regptr	esdx,es,dx
	regptr	dssi,ds,si
	cCall	LoadModule,<esdx,dssi>
	assumes	es, nothing
	add	sp,256
	cmp	ax,32			; check for error...
	jae	ex8
	cmp	ax,2			; file not found?
	jnz	ex7			; no, return error
        mov     al,23                   ; flag WINOLDAP error

;; ndef wow
endif

ex7:    or      User_FL,1               ; set carry flag
	or	ax,ax			; out of memory?
	jnz	ex8
	mov	ax,8h			; yes, return proper error code
ex8:	mov	User_AX,ax		; return AX value

	ret
cEnd nogen


ifdef WIN32S
SZW32SYS        db  "W32SYS.DLL", 0
ExecPEOrd       equ  3

;-----------------------------------------------------------------------;
; ExecPE
; Get ExecPE address in W32SYS.DLL, and call it
; 11-13-91   AviN   created
;-----------------------------------------------------------------------;

cProc   ExecPE,<PUBLIC,FAR>
cBegin	nogen
	push	ds
        mov     ax, SEG selExecPE
        mov     ds, ax

assumes DS, DATA

        mov     dx, selExecPE          ; check for a valid address
        or      dx, dx
        jnz     ep_x

        mov     ax, offExecPE
        or      ax, ax
        jnz     ep_err                 ; already failed, don't try again


        cCall   ISetErrorMode, <8000h>
        push    ax

        lea     ax, SZW32SYS
        cCall   LoadLibrary,<cs, ax>

        pop     dx
        push    ax
        cCall   ISetErrorMode,<dx>      ; restore original error mode
        pop     ax

        cmp     ax, 32
        jbe     ep_err

        push    ax
        push    0
        push    ExecPEOrd
        cCall   GetProcAddress
        or      dx,dx
        jz      ep_err
        mov     selExecPE, dx
        mov     offExecPE, ax
ep_x:

        pop     ax                      ; saved DS
        push    selExecPE               ; jmp to ExecPE
        push    offExecPE
        mov     ds, ax
        retf

ep_err:
                                        ; if w32sys support no available return
        mov     ax, 11                  ; invalid module format
        mov     offExecPE, ax           ; and record for next time

        pop     ds
	retf    10                      ; pop ExecPE parameters


assumes DS,NOTHING
cEnd    nogen
endif


sEnd NRESCODE

sBegin MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
;                                                                       ;
;  Get the Current PDB without doing a DOS call.                        ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   GetCurrentPDB,<PUBLIC,FAR>
cBegin  nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     dx,TopPDB
        mov     ds,curTDB
        UnSetKernelDS
        mov     ax,ds:[TDB_PDB]
        pop     ds
        ret
cEnd    nogen


sEnd MISCCODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\int24.asm ===
;-----------------------------------------------------------------------;
;									;
;		    Windows Critical Error Handler			;
;									;
;-----------------------------------------------------------------------;

.xlist
include kernel.inc
include tdb.inc
ifdef WOW
include vint.inc
endif
.list

DEVSTRC struc
devLink dd	?
devAttr dw	?
devPtr1 dw	?
devPtr2 dw	?
devName db	8 dup (?)
DEVSTRC ends

IDABORT	 =   3
IDRETRY	 =   4
IDIGNORE =   5

;-----------------------------------------------------------------------;
;									;
; XENIX calls all return error codes through AX.  If an error occurred	;
; then the carry bit will be set and the error code is in AX.		;
; If no error occurred then the carry bit is reset and AX contains	;
; returned info.							;
;									;
; Since the set of error codes is being extended as we extend the	;
; operating system, we have provided a means for applications to ask	;
; the system for a recommended course of action when they receive an	;
; error.								;
;									;
; The GetExtendedError system call returns a universal error, an error	;
; location and a recommended course of action.	The universal error	;
; code is a symptom of the error REGARDLESS of the context in which	;
; GetExtendedError is issued.						;
;									;
; These are the universal int 24h mappings for the old INT 24 set of	;
; errors.								;
;									;
;-----------------------------------------------------------------------;

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready			EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

; These are the new 3.0 error codes reported through INT 24h

error_sharing_violation		EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35

; New OEM network-related errors are 50-79

error_not_supported		EQU	50

; End of INT 24h reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

; New 3.0 network related error codes

error_out_of_structures		EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter		EQU	87
error_NET_write_fault		EQU	88

error_I24_write_protect		EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0Dh is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh

; THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24h

Allowed_FAIL			EQU	00001000b
Allowed_RETRY			EQU	00010000b
Allowed_IGNORE			EQU	00100000b

;NOTE: ABORT is ALWAYS allowed

I24_operation			EQU	00000001b	;Z if READ,NZ if Write
I24_area			EQU	00000110b	; 00 if DOS
							; 01 if FAT
							; 10 if root DIR
DataBegin

externB SysErr
externB msgWriteProtect
externB drvlet1
externB msgCannotReadDrv
externB drvlet2
externB msgCannotWriteDrv
externB drvlet3
externB msgShare
externB drvlet4
externB msgNetError
externB drvlet5
externB msgCannotReadDev
externB devenam1
externB msgCannotWriteDev
externB devenam2
externB devenam3
externB msgNetErrorDev
externB msgNoPrinter
externB OutBuf
externB Kernel_Flags
externB Kernel_InDOS
externB Kernel_InINT24
externB InScheduler
externB cdevat
externB errcap
externB fNovell
externB fDW_Int21h
externW pGlobalHeap
externW CurTDB
;externW MyCSDS
externW LastExtendedError
if 0; EarleH
externW LastCriticalError
endif ; 0
externD pSErrProc
externD InDOS

fDialogShown	db	0	; NZ if end user sees dialog box

if ROM
externD prevInt21Proc
endif

DataEnd

INT24STACK	STRUC
Int24_IP	dw	?
Int24_CS	dw	?
Int24_FG	dw	?
Int24_AX	dw	?
Int24_BX	dw	?
Int24_CX	dw	?
Int24_DX	dw	?
Int24_SI	dw	?
Int24_DI	dw	?
Int24_BP	dw	?
Int24_DS	dw	?
Int24_ES	dw	?
INT24STACK	ENDS


sBegin	code
	assumes cs,code
	assumes ds,nothing
	assumes es,nothing

ife ROM
externD prevInt21Proc
endif

externNP AppendFirst
externNP GetKernelDataSeg

;-----------------------------------------------------------------------;
; Int24Handler								;
; 									;
; This is the default disk error handling code available to all		;
; users if they do not try to intercept interrupt 24h.			;
; The two options given the user are RETRY and FAIL.  Retry goes back	;
; to DOS.  If FAIL is chosen then for DOS 3.XX we return to DOS, but	;
; for DOS 2.XX we do the fail ourselves and return to the APP.		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Feb 03, 1987 10:10:09p  -by-  David N. Weise   [davidw]		;
; Removed the poking around in DOS by using Kernel_InDOS.		;
; 									;
;  Tue Jan 27, 1987 07:58:56p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Int24Handler,<PUBLIC,NEAR>
cBegin nogen

	push	ds
	SetKernelDS
	mov	fDialogShown, 0 	; Assume no dialog box
	inc	InScheduler		; Prevent recursion
	cmp	InScheduler,1		; Well are we?
	jz	NotInSched		; No, then handle this one
	jmp	ReturnError		; Yes, return abort

NotInSched:
	mov	Kernel_InINT24,1
        FSTI
	cld
	push	es
	push	dx
	push	cx
	push	bx

; Save away the return capabilities mask.

	mov	errcap,ah		; save the capabilities mask
	push	di
	mov	ds,bp
	UnSetKernelDS
	SetKernelDS	es
	mov	cx,[si].devAttr
	mov	cdevat,ch
	mov	di,dataOffset devenam1
	mov	cx,8
	add	si,devName		; pull up device name (even on block)
	push	si
	rep	movsb
	pop	si
	mov	di,dataOffset devenam2
	mov	cl,8
	push	si
	rep	movsb
	pop	si
	mov	di,dataOffset devenam3
	mov	cl,8
	rep	movsb
	pop	di

	SetKernelDS
	UnSetKernelDS	es
if 0; EarleH
	mov	LastCriticalError, di
endif

	add	al,'A'			; compute drive letter (even on character)
	mov	drvlet1,al
	mov	drvlet2,al
	mov	drvlet3,al
	mov	drvlet4,al
	mov	drvlet5,al

; At app exit time we will Ignore any critical errors.	This is
;  because errors that usually occur at app exit time are generally
;  due to the network beeping death.  Trying to put up the dialog
;  hangs Windows because USER doesn't think the task exists any more.
;  THIS IS AN INCREADABLE HACK!!  We don'r really know if we can
;  ignore all critical errors, but hey, nobodies complained yet.

	test	Kernel_flags[2],KF2_WIN_EXIT	; prevent int 24h dialogs
	jz	SetMsg
	xor	ax,ax
	jmp	eexit

SetMsg: test	ah,1
	jz	ReadMes

WriteMes:
	mov	si,dataOffset msgCannotWriteDev
	test	cdevat,10000000b
	jnz	Gotmes
	mov	si,dataOffset msgCannotWriteDrv
	jmps	Gotmes

ReadMes:
	mov	si,dataOffset msgCannotReadDev
	test	cdevat,10000000b
	jnz	Gotmes
	mov	si,dataOffset msgCannotReadDrv
Gotmes:

; reach into DOS to get the extended error code

;;;	les	bx,InDOS
;;;	mov	ax,es:[bx].3

	push	es				; DOS may trash these...
	push	ds
	push	si
	push	di
	xor	bx, bx
	mov	ah, 59h
	pushf	      
	call	prevInt21Proc
	mov	LastExtendedError, ax
	mov	LastExtendedError[2], bx
	mov	LastExtendedError[4], cx
	pop	di		      
	pop	si
	pop	ds
	pop	es
		
	mov	dx,dataOffset msgWriteProtect
	cmp	ax,error_write_protect
	jz	prmes				; Yes
	mov	dx,dataOffset msgNoPrinter
	cmp	al,error_out_of_paper
	jz	prmes				; Yes
	mov	dx,dataOffset msgShare
	cmp	al,error_sharing_violation
	jz	prmes				; Yes
	cmp	al,error_lock_violation
	jz	prmes				; Yes
	mov	dx,dataOffset msgNetError
	test	cdevat,10000000b
	jz	check_net_error
	mov	dx,dataOffset msgNetErrorDev
check_net_error:
	cmp	al,50
	jb	not_net_error
	cmp	al,80
	ja	not_net_error
	test	Kernel_Flags[2],KF2_APP_EXIT
	jz	prmes
	jmps	ReturnError

not_net_error:

	mov	dx,si			; Message in SI is correct

prmes:	call	AppendFirst		; print error type

	mov	es,curTDB		; Point to current task
	mov	ax,es:[TDB_errMode]	; See if wants default error processing
	test	al,1			; Low-order bit = zero means
	jz	ask			; ...put up dialog box
	mov	al,2
	jmps	eexit			; <> 0  means return error from call

ask:	mov	es,pGlobalHeap
	inc	es:[hi_freeze]		; freeze global heap
	call	ShowDialogBox
	mov	fDialogShown, dl	; will be 0 if dialog box NOT shown
	mov	es,pGlobalHeap
	dec	es:[hi_freeze]		; thaw global heap

eexit:	pop	bx
	pop	cx
	pop	dx
	pop	es
	cmp	al,2			; retry, ignore?
	jb	aexit			; yes, return to dos

	cmp	fNovell, 0
	je	ReturnError		; Not NOVELL
	test	errcap, Allowed_FAIL
	jnz	ReturnError		; We CAN fail, so we do.
	push	ax
	mov	ax, di
	cmp	al, 0Ch			; General failure
	pop	ax
	jne	ReturnError
	cmp	word ptr devenam1[0], 'EN'
	jne	ReturnError
	cmp	word ptr devenam1[2], 'WT'
	jne	ReturnError
	cmp	word ptr devenam1[4], 'RO'
	jne	ReturnError
	cmp	word ptr devenam1[6], 'K'
	jne	ReturnError
	mov	al, 2			; ABORT because NOVELL doesn't like FAIL
	jmps	aexit

ReturnError:
	mov	al,3			; change to return error code

; If the user canceled an error generated by the Int 21h to AUX: in kernel's
; DebugWrite routine, set a flag telling DebugWrite not to do that anymore.

	cmp	fDialogShown, 0 	; Did end user see dialog box?
	jz	not_krnl
	cmp	fDW_Int21h, 0		; fDW_Int21h will == 0 if caused by
	jnz	not_krnl		;  Int 21h/Write to AUX: in DebugWrite.
	mov	fDW_Int21h, 2		; Prevent DebugWrite from trying again
not_krnl:				;  (any value >= 2, <= 0FEh works)

aexit:	mov	Kernel_InINT24,0
	dec	InScheduler
	pop	ds
	UnSetKernelDS	ds
        FSTI
	iret
cEnd nogen


;-----------------------------------------------------------------------;
; ShowDialogBox
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 02-Dec-1989 15:28:51  -by-  David N. Weise  [davidw]
; Removed the stack switching because of the new WinOldAp support,
; and added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	ShowDialogBox,<PUBLIC,NEAR>

cBegin nogen

	CheckKernelDS
	ReSetKernelDS

	mov	ax,3			; assume no USER therefor CANCEL
	xor	dx, dx
	cmp	pSErrProc.sel,0 	; is there a USER yet?
	jz	sdb_exit

	push	bp
	xor	bp,bp
	push	bp
	mov	bp,sp
	push	ds
	mov	ax,dataOffset OutBuf	; lpText
        push    ax
	push	ds
	mov	ax,dataOffset SysErr	; lpCaption
        push    ax

; Set up the buttons based on the capabilities mask.  Cancel is always
;  availible.  Retry and Ignore are not always available.

	mov	ax,SEB_CANCEL+SEB_DEFBUTTON ; cancel is always allowed
        push    ax
	xor	ax,ax			; assume no second button
if 0 ; 05 feb 1990, ignoring is not user friendly, win 2.x did not allow it
	test	errcap,20h		; is ignore allowed?
	jz	button_2
	mov	ax,SEB_IGNORE		; ignore is the second button
endif

button_2:
        push    ax

	xor	ax,ax			; assume no third button
	test	errcap,10h		; is retry allowed?
	jz	button_3
	mov	ax,SEB_RETRY		; retry is the third button
button_3:
        push    ax
dobox:
	call	[pSErrProc]		; USER.SysErrorBox()
	mov	dx, ax

; We need to map the return as follows:
;   button 1 (Cancel) =>  3  3
;   button 2 (Retry)  =>  1  0
;   button 3 (Ignore) =>  0  1

	sub	al,2
	jnb	codeok
	mov	al,3
codeok:
	pop	bp
	pop	bp
sdb_exit:
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; GetLPErrMode								;
; 									;
; This routine returns a long pointer to the Kernel_InDOS and		;
; Kernel_InINT24 bytes inside the KERNEL.  It is used by 386 WINOLDAP	;
; to prevent switching while inside INT 24 errors from other VMs.	;
; 									;
; NOTE: Do not change this call without talking to the WIN/386 group.	;
; NOTE: USER also uses this call to determine whether PostMessage       ;
;       can call FatalExit.                                             ;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	DX:AX = pointer to Kernel_InDOS followed by Kernel_InINT24	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 27, 1987 07:13:27p  -by-  David N. Weise   [davidw]          ;
; Rewrote it and added this nifty comment block.			;
;									;
;  7/23/87 -by- Arron Reynolds [aaronr], updated comments to desired	;
;	state.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetLPErrMode,<PUBLIC,FAR>
cBegin	nogen
	call	GetKernelDataSeg
	mov	dx, ax
	mov	ax,dataOffset Kernel_InDOS
	ret
cEnd	nogen

sEnd	code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\intnn.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
.list

DataBegin

externW curTDB

DataEnd

sBegin  CODE
externD prevInt10proc
assumes CS,CODE
assumes	ds, nothing
assumes	es, nothing

;-----------------------------------------------------------------------;
; IntnnHandlers - Handlers for int 0, 2, 4, 6, 7, 10, 3E, 75		;
;									;
; Slimed in here for lack of a better place.				;
; Merely jump through the vector saved in the TDB			;
;									;
;-----------------------------------------------------------------------;

cProc	Int00Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS
IntnnCommon:
	sub	sp, 2			; Make room for dword (saved bx is
	push	bp			;		       other word)
	mov	bp, sp
	push	ds

	SetKernelDS
	mov	ds, CurTDB
	UnSetKernelDS
	push	[bx]			; Fill in dword with vector contents
	pop	[bp+2]
	mov	bx, [bx+2]
	xchg	bx, [bp+4]		; Fill in segment, recover bx
	pop	ds
	pop	bp
	retf
cEnd nogen

cProc	Int02Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+4
	jmps	IntnnCommon
cEnd nogen

cProc	Int04Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+8
	jmps	IntnnCommon
cEnd nogen

cProc	Int06Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+12
	jmps	IntnnCommon
cEnd nogen

cProc	Int07Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+16
	jmps	IntnnCommon
cEnd nogen

cProc	Int3EHandler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+20
	jmps	IntnnCommon
cEnd nogen

cProc	Int75Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+24
	jmps	IntnnCommon
cEnd nogen

ifdef WOW

cProc   Int10Handler,<PUBLIC,FAR>

;; QuattroPro for windows does direct VGA programming if they detect
;; that the monitor they are running on is a VGA.   On NT if they program
;; the VGA we trap all the operations in NTVDM - but it makes QuattroPro
;; look very slow.   So we lie to them here bl = 0 No monitor.   That way
;; they don't do direct VGA programming and run fast.
;;       - mattfe june 93
;;
;; if function == 1h (get monitor type)
;;      then return 0 - No monitor
;; else
;;      chain into real int10 handler

cBegin nogen
        cmp     ah,1ah
        jne     int10h_dontbother

        mov     bl,00h
        IRET

int10h_dontbother:
        jmp     cs:prevInt10proc
cEnd nogen

endif; WOW

;-----------------------------------------------------------------------;
; FOR INT HANDLER	SEE						;
;									;
;	21h		i21entry.asm					;
;	3Fh		ldint.asm					;
;									;
;-----------------------------------------------------------------------;


sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kdata.asm ===
TITLE   KDATA - Kernel data area

win3debdata=1
include gpfix.inc               ; include first to define segment order
include kernel.inc
include gpcont.inc              ; do we alloc Sherlock data items?

extrn __ahshift:ABS             ; Pull in LDBOOT.ASM next from KERNOBJ.LIB

sBegin  CODE
externFP Int21Handler
sEnd    CODE

public  __acrtused
        __acrtused = 9697

;------------------------------------------------------------------------
; Segment definations to define labels at the segment start.  Don't put
; any code or data here.
;------------------------------------------------------------------------

sBegin  INITCODE
labelB  <PUBLIC,initcode>
labelB  <PUBLIC,beg_initcode>
sEnd    INITCODE

DataBegin INIT
labelB  <PUBLIC,initdata>
labelB  <PUBLIC,beg_initdata>
DataEnd INIT


;------------------------------------------------------------------------
;       D A T A   S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

DataBegin

; The following items must remain in the same location and order.  These
; items also appear in the initial paragraph of each application's DS.

        ORG     0

        DW  0
  globalW       oOldSP,0
  globalW       hOldSS,5
  globalW       pLocalHeap,0
  globalW       pAtomTable,0
  globalW       pStackTop,<dataOffset gmove_stack_top>
  globalW       pStackMin,<dataOffset gmove_stack>
  globalW       pStackBot,<dataOffset gmove_stack>

;------------------------------------------------------------------------
if KDEBUG
; If this word gets trashed, then we overflowed our stack

globalW gmove_stack_sig,STACK_SIGNATURE,16
endif

labelB  <PUBLIC,lpszFileName>   ; Used in FileCDR_notify
        gmove_stack_top label byte

        EVEN

        DW      256 DUP (0)     ; gmove requires at least 64 words

globalW gmove_stack,0

globalW prev_gmove_SP,0
globalW prev_gmove_SS,0
globalW ss_sel,0

;------------------------------------------------------------------

; The debugger requires that the following items remain in the same
; relative order.

  labelW        <PUBLIC,THHOOK> ; So ToolHelp can find this stuff, too.
  globalW hGlobalHeap,0 ; Handle to master object
  globalW pGlobalHeap,0 ; Current physical address of master object
  globalW hExeHead,0    ; Head of module list maintained by Load/Free Module
  globalW hExeSweep,0   ; ... 1st module for LRU sweep to examine

  globalW topPDB,0      ; DOS PDB on entry
  globalW headPDB,0     ; link list of PDBs
  globalW topsizePDB,0  ; DOS PDB size upon entry
  globalW headTDB,0     ; head of task queue
  globalW curTDB,0      ; handle for currently running task
  globalW loadTDB,0     ; handle for currently loading task
  globalW LockTDB,0     ; handle of super task
  globalW SelTableLen,0 ; DONT MOVE THIS
  globalD SelTableStart,0       ; DONT MOVE THIS
  if PMODE32
    globalD     hBmDPMI,0       ; DPMI handle to BurgerMaster
  endif

;------------------------------------------------------------------------
globalW winVer,400h     ; Windows version number for KERNEL.EXE header
globalW fWinx,0         ; Flag from ldboot.asm
globalW f8087,0         ; non zero if 8087 installed
globalW PHTcount,0      ; Count of tasks with a PHT
globalW hGDI,0          ; module handle of GDI
globalW hUser,0         ; module handle of User
globalW hShell,0        ; module handle of Shell
globalW fLMdepth,0      ; # of recursive LoadModules
globalW wDefRIP,0       ; Value to return from RIP in Debug
globalB num_Tasks,0     ; number of tasks (i.e. TDB's) in system
globalB InScheduler,0   ; True if inside scheduler
globalB graphics,1      ; True if user/keyboard/gdi/display loaded
        DB 0
globalB fastfp,1        ; True if suppress FWAIT before FOp

;globalW PID_for_fake,0          ; the PID allocated for the fake task
;globalW EMS_calc_swap_line,0    ; The calculated swap line
;globalW EMSCurPID,0             ; The current PID.

globalW MaxCodeSwapArea,0       ; The max paragraphs SetSwapAreaSize can set.

globalW selLowHeap,0            ; selector to Windows Low ( < 640k) heap block
globalW cpLowHeap,0             ; count of paragraphs of Low heap block
globalW selHighHeap,0           ; selector to Windows High ( >640k) heap block
globalW selWoaPdb,0             ; selector to fixed low PDB for WinOldApp
globalW sel_alias_array,0       ; the selector alias array (286 only)
globalW temp_sel,0              ; Single pre-allocated selector
globalD dressed_for_success,0   ; callback into OS/2 mapping layer at app start
ife PMODE32
globalW hXMMHeap,0              ; XMS handle to secondary extended heap block
endif


globalD InDOS,0                 ; -> in dos flags and stuff
globalD pSftLink,0              ; -> end of Sft chain when we started
globalD lpWinSftLink,0          ; -> first node in chain that windows adds

ifdef WOW
globalD pDosWowData,0           ; -> rmode pointer to DosWowData in DOSDATA
globalD pPMDosCDSCNT,0          ; -> DOS CDS Count variable
globalD pPMDosCURDRV,0          ; -> DOS CurDrv variable
globalD pPMDosPDB,0             ; -> pointer to PDB in DOSDATA
globalD pPMDosExterr,0          ; -> pointer to DOS Exterr var (word)
globalD pPMDosExterrLocus, 0    ; -> pointer to DOS ExterrLocus var (byte)
globalD pPMDosExterrActionClass,0 ; -> pointer to DOS ExterrActionClass (word, byte each)
endif

globalD pFileTable,0            ; -> beginning of Sft chain
globalW FileEntrySize,0         ; size of one sft entry
globalD curDTA,0                ; what DOS thinks is the current DTA
globalW cur_dos_PDB,0           ; what DOS thinks is the current PDB
globalW Win_PDB,0               ; what we want the PDB to be
globalW cur_drive_owner,0       ; last TDB to change the disk or directory
globalB fBreak,0                ; state of dos break flag between e&d dos
globalB LastDriveSwapped,0      ; drive letter of last drive where disk swap
globalB DOS_version,0           ; DOS major version number
globalB DOS_revision,0          ; DOS minor version number
globalB fInt21,0                ; Flag indicating INT 21 hooks are installed
globalB fNovell,0               ; Have Novell network
globalB fPadCode,0              ; Pad code segments for 286 chip bug
globalB CurDOSDrive,0FFh        ; Current drive according to DOS
globalB DOSDrives,26            ; number of logical drives from DOS

;----------------------------------------------------------------------

; PhantArray is a byte array indexed by zero based drive number.
;  A non-zero value indicates the drive is phantom.

globalB PhantArray,0,26


; Keyboard inquire structure
globalB fFarEast,0              ; non zero means far eastern keyboard
ifdef   FE_SB

labelB  <PUBLIC,DBCSVectorTable> ;LanguageId, SizeOfDBCSVector, [BeginRange, EndRange] []
dw 411h                          ;JAPAN
db 4, 81h, 9Fh, 0E0h, 0FCh
dw 412h                          ;KOREA
db 2, 81h, 0FEh
dw 404h                          ;TAIWAN
db 2, 81h, 0FEh
dw 804h                          ;PRC
db 2, 81h, 0FEh
dw 0C04h                         ;HONGKONG
db 2, 81h, 0FEh
db 0                             ;End of table

globalB fDBCSLeadTable,0,256    ; DBCS lead byte index table

endif   ;FE_SB
globalB KeyInfo,0,%(SIZE KBINFO)

; Procedure addresses initialized by InitFwdRef

        ALIGN 4

globalD pSysProc,0              ; -> SYSTEM.InquireSystem
globalD pTimerProc,0            ; -> SYSTEM.CreateTimer
globalD pSystemTermProc,0       ; -> SYSTEM.Disable
globalD pKeyProc,0              ; -> KEYBOARD.AnsiToOem
globalD pKeyProc1,0             ; -> KEYBOARD.OemToAnsi
globalD pKeyboardTermProc,0     ; -> KEYBOARD.Disable
globalD pKeyboardSysReq,0       ; -> KEYBOARD.EnableKBSysReq
globalD pDisplayCritSec,0       ; -> DISPLAY.500
globalD pMouseTermProc,0        ; -> MOUSE.Disable
globalD pMBoxProc,0             ; -> USER.MessageBox
globalD pSErrProc,0             ; -> USER.SysErrorBox
globalD pExitProc,0             ; -> USER.ExitWindows
globalD pDisableProc,0          ; -> USER.DisableOEMLayer
globalD pUserInitDone,0         ; -> USER.routine to call when init is done
globalD pPostMessage,0          ; -> USER.PostMessage function
globalD pSignalProc,0           ; -> USER.SignalProc function
globalD pIsUserIdle,0           ; -> USER.IsUserIdle function
globalD pUserGetFocus,0         ; -> USER.GetFocus function
globalD pUserGetWinTask,0       ; -> USER.GetWindowTask function
globalD pUserIsWindow,0         ; -> USER.IsWindow function
globalD pGetFreeSystemResources,0 ; -> USER.GetFreeSystemResources function
globalD plstrcmp,0              ; -> USER.lstrcmp function

if ROM
  globalD pYieldProc,0          ; -> USER.UserYield
  globalD pStringFunc,0         ; -> USER.StringFunc function

  globalD prevInt21proc,0               ; -> previous INT 21h handler
  globalD prevInt24proc,0               ; -> previous Int 24h handler
  globalD prevInt2Fproc,0       ; -> previous Int 24h handler
  globalD prevInt3Fproc,0       ; -> previous Int 3Fh handler
  globalD prevInt67proc,0       ; -> previous Int 67h handler
  globalD prevInt00proc,0       ; -> previous INT 00h handler   !! don't move
                                  ;                             !! don't move
  globalD prevInt02proc,0       ; -> previous INT 02h handler   !! don't move
  globalD prevInt04proc,0       ; -> previous INT 04h handler   !! don't move
  globalD prevInt06proc,0       ; -> previous INT 06h handler   !! don't move
  globalD prevInt07proc,0       ; -> previous INT 07h handler   !! don't move
  globalD prevInt3Eproc,0       ; -> previous INT 3Eh handler   !! don't move
  globalD prevInt75proc,0       ; -> previous INT 75h handler   !! don't move
  globalD prevIntx6proc,0       ; -> previous invalid op-code Fault handler
  globalD prevInt0Cproc,0       ; -> previous stack fault handler
  globalD prevInt0Dproc,0       ; -> previous GP Fault handler
  globalD prevInt0Eproc,0       ; -> previous Page Fault handler
endif

globalD lpInt21,0               ; support for NOVELL stealing int 21h
globalD myInt2F,0               ; support for NOVELL swapping with DOS apps
globalD FatalExitProc,0         ; Intercept for FatalExit()

globalD ptrace_dll_entry,0      ; -> ptrace engine DLL entry
globalD ptrace_app_entry,0      ; -> real entry point for app
globalD lpfnToolHelpProc,0      ; TOOLHELP.DLL PTrace function
globalW wExitingTDB,0           ; Flag for DebugWrite--no debug strings at exit
globalD shell_file_proc,0       ; -> shell for file create/del notify
globalW shell_file_TDB,0        ; shell TDB
if SWAPPRO
  globalD prevIntF0proc,0       ; -> previous Int F0h handler
  globalW hSwapPro,-1           ; file handle for swap profiler
  globalB fSwappro,0            ; 0 = no swap info, 1 = swaps, 2 = all
          DB    0
endif

globalD gcompact_start,0        ; start to measure swapping
globalD gcompact_timer,0        ; time spent in gcompact to measure swapping

ifdef  FE_SB
ifndef KOREA
  globalD pJpnSysProc,0         ; -> SYSTEM.JapanInquireSystem
endif
endif

globalW WinFlags,0              ; see kernel.inc for defs of these

globalB Kernel_Flags,0,4        ; see kernel.inc for defs of these
;
; WARNING!! Do not disturb the order of the next two variables....
;    See GetLPErrormode in INT24.ASM  ARR 7/23/87
;
globalB Kernel_InDOS,0          ; set when we call the REAL DOS
globalB Kernel_InINT24,0        ; set when Int 24h calls DOS funcs < 13

; fBooting bits:
; bit 1 (2h) is reset after kernel is loaded (for fixed blks alloc strategy)
; fBooting is zeroed as a whole after full booting by bootdone
globalB fBooting,3              ; Set to zero by bootdone
globalB fChkSum,0               ; Flag set if segment checksumming enabled
globalB fCheckFree,1            ; Set to zero by slowboot
globalB cdevat,0                ; Int 24 state
globalB errcap,0                ; Int 24 error capabilities mask
ifndef WOW
; profile APIs are thunked
globalB fProfileDirty,0         ; Profiles need writing
globalB fProfileMaybeStale,0    ; Profiles MAY need to be reread
globalB fWriteOutProfilesReenter,0 ; Are we currently in WriteOutProfiles?
endif
globalB fPokeAtSegments,1       ; Idle time load of segments
globalB fTaskSwitchCalled, 0    ; Local Reboot only works when task switching
globalD WinAppHooks,0           ; winapps can hook this for std winoldap.

public WOAName
WOAName     DB 'WINOLDAP.MOD',0
globalB grab_name,0,128

ALIGN 4

globalD lpWindowsDir,0          ; -> to WFP of where win.ini lives
globalD lpSystemDir,0           ; -> to WFP of where kernel lives
globalW cBytesWinDir,0          ; length of WFP for windows dir
globalW cBytesSysDir,0          ; length of WFP for system dir
ifdef WOW
globalD lpSystemRootDir,0       ; -> value of SystemRoot environment var
globalD lpSystem16Dir,0         ; -> to WFP of \windows\system
globalD lpSystemWx86Dir,0       ; \windows\system32\Wx86
globalW cBytesSystemRootDir,0   ; length of SystemrootEnvironment var
globalW cBytesSys16Dir,0        ; in WOW lpSystemDir points to \windows\system32
globalW cBytesSysWx86Dir,0      ; in WOW Windows\system32\Wx86
public Sys16Suffix
Sys16Suffix DB '\system'        ; append to WinDir to get lpSystem16Dir
public cBytesSys16Suffix
cBytesSys16Suffix DW ($ - dataoffset Sys16Suffix)
public SysWx86Suffix
SysWx86Suffix DB '\Sys32x86'    ; append to WinDir to get lpSystemWx86Dir
public cBytesSysWx86Suffix
cBytesSysWx86Suffix DW ($ - dataoffset SysWx86Suffix)

endif


globalD lpGPChain,0             ; GP fault hack for WEPs - chain to this addr

if SHERLOCK
  globalW gpTrying,0            ; Trying to continue after a GP fault
  globalW gpEnable, 1           ; Enable GP continuation
  globalW gpInsLen, 0           ; Length of faulting instruction
  globalW gpSafe, 0             ; OK to skip current instruction
  globalW gpRegs, 0             ; Regs modified by faulting insn
  globalW gpStack, 0            ; movement of stack by faulting insn
endif

ifndef WOW
; The profile APIs are thunked for WOW
globalB WinIniInfo,0,%(size PROINFO)
globalB PrivateProInfo,0,%(size PROINFO)
endif ; ndef WOW
public szUserPro
szUserPro   DB 'WIN.INI',0
ifndef WOW
            DB  72 dup (0)      ; Room for a long path
;;;globalB      fUserPro,0              ; Current Profile is WIN.INI
;;;globalD lpszUserPro,0
endif
; ndef WOW

ifdef WOW
globalW hWinnetDriver, 0
endif ;WOW

globalW BufPos,0                ; buffer pointer with OutBuf
globalB OutBuf,0,70             ; 70 character out buffer

EVEN
globalW MyCSAlias,0             ; Kernel's CS/DS Alias
globalW MyCSSeg,0               ; Kernel's CS as a segment
globalW MyDSSeg,0               ; Kernel's DS as a segment
globalW hLoadBlock,0            ; Handle that points to in memory file image
globalW segLoadBlock,0          ; Segment address of file image
globalW wMyOpenFileReent, 0     ; Reentrant flag for MyOpenFile

ife ROM
  globalW cpShrink,0
  globalW cpShrunk,0            ; Delta from beginning of file to hLoadBlock
endif

if ROM
  externD <lmaExtMemROM,cbExtMemROM>
  globalD lmaHiROM,lmaExtMemROM
  globalD cbHiROM,cbExtMemROM
  globalW selROMTOC,0
  globalW selROMLDT,0
  globalW sel1stAvail,0
  globalD linHiROM, 0
endif

if PMODE32
  globalW PagingFlags,0
  globalW ArenaSel,0
  globalW FirstFreeSel,0
  globalW CountFreeSel,0
  globalD FreeArenaList,0
  globalD FreeArenaCount,0
  globalD HighestArena,0
  globalD temp_arena,0
  globalD NextCandidate,-1
  globalW Win386_Blocks,0
  globalW InitialPages,0
  globalD lpReboot,0                      ; Reboot VxD address
endif

globalW BaseDsc,0
globalW kr1dsc,0
globalW kr2dsc,0
globalW blotdsc,0
globalW DemandLoadSel,0

globalW fhcStealNext,<(MAXFHCACHELEN-1)*size fhCacheStruc+dataOffset fhCache>   ; Next fhCache entry to use
globalW fhCacheEnd,<MAXFHCACHELEN*size fhCacheStruc+dataOffset fhCache> ; End of the cache
globalW fhCacheLen,MINFHCACHELEN
globalB fhCache,0,%(MAXFHCACHELEN*size fhCacheStruc)

if KDEBUG
  globalB fLoadTrace, 0
  globalB fPreloadSeg, 0
  globalB fKTraceOut, 0                 ; Used by DebugWrite to ignore traces
                                        ;   to be sent to PTrace
endif
globalB fDW_Int21h, 0FFh            ; FF if okay for DebugWrite to use Int 21h

if ROM and PMODE32
  globalW gdtdsc,0
endif

    ALIGN 2

if 0; EarleH
globalW LastCriticalError,-1
endif
globalW LastExtendedError,-1,3          ; Don't move this
globalW Reserved,0,8                    ; Don't move this

ifdef WOW
;------------------------------------------------------------------------
;       W O W    G L O B A L   D A T A
;------------------------------------------------------------------------
public  achTermsrvWindowsDir   ; per user windows directory (for .ini files)
achTermsrvWindowsDir DB MaxFileLen dup (0)

globalW wCurTaskSS,0    ; Currently Running Task SS
globalW wCurTaskBP,0    ; Currently Running Task BP
globalD Dem16to32handle,0 ; -> DOS Emulation 16 to 32 bit handle convertion
globalD FastBop,0       ; eip value for fast bop entry point
globalW FastBopCS,0     ; CS value for fast bop entry point
globalD FastWOW,0       ; eip for fast WOW32 entry point when doing thunk call
globalW FastWOWCS,0     ; CS value for fast wow entry point
globalD FastWOWCbRet,0  ; eip for fast WOW32 entrypoint to return from callback
globalW FastWOWCbRetCS,0; cs for above
globalW WOWFastBopping,0; non-zero if fast call to WOW32 enabled
                        ; Jmp indirect through here for faster bops
globalB fExitOnLastApp,0    ; Close WOW when the last app exits (not WOWEXEC)
globalB fShutdownTimerStarted,0 ; 1 if the shutdown timer is running (shared WOW)

;; do not rearrange these or stick anything in the middle!
;;
;;
wowtablemodstart label byte
globalW MOD_KERNEL    ,0    ; kernel must be first!
globalW MOD_DKERNEL   ,0
globalW MOD_USER      ,0
globalW MOD_DUSER     ,0
globalW MOD_GDI       ,0
globalW MOD_DGDI      ,0
globalW MOD_KEYBOARD  ,0
globalW MOD_SOUND     ,0
globalW MOD_SHELL     ,0
globalW MOD_WINSOCK   ,0
globalW MOD_TOOLHELP  ,0
globalW MOD_MMEDIA    ,0
globalW MOD_COMMDLG   ,0
ifdef FE_SB
globalW MOD_WINNLS    ,0
globalW MOD_WIFEMAN   ,0
endif ; FE_SB
globalW ModCount      ,<($ - dataoffset wowtablemodstart) / 2>
;;
;;
;; do not rearrange these or stick anything in the middle!

globalW DebugWOW,1      ; bit 0 = 1 WOW is being debugged, 0 = WOW is not
globalW TraceOff,0      ; bit 0 = 1 turn off trace interrupts during apis

globalW WOWLastError,0 ; Last error returned by int 21
globalB WOWErrClass, 0
globalB WOWErrAction, 0
globalB WOWErrLocation, 0

endif
DataEnd


;------------------------------------------------------------------------
;       C O D E   S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

sBegin  CODE
assumes cs,CODE

        EVEN

        dw      18h dup(0F4CCh) ; Catch them jmps, calls & rets to 0
                                ; and offset segment for putting in HMA
if ROM

globalW MyCSDS,<seg _DATA>      ; Kernel's DS
ife PMODE32
externW selLDTAlias
globalW gdtdsc,selLDTAlias      ; Data alias to LDT
endif
else
globalW MyCSDS,0                ; Kernel's DS
globalW gdtdsc,0
endif

        ALIGN   4

ife ROM
globalD pYieldProc,0            ; -> USER.UserYield
globalD pStringFunc,0           ; -> USER.StringFunc function

globalD prevInt21proc,0         ; -> previous INT 21h handler
globalD prevInt24proc,0         ; -> previous Int 24h handler
globalD prevInt2Fproc,0         ; -> previous Int 24h handler
globalD prevInt3Fproc,0         ; -> previous Int 3Fh handler
globalD prevInt67proc,0         ; -> previous Int 67h handler
globalD prevInt00proc,0         ; -> previous INT 00h handler   !! don't move
                                ;                               !! don't move
globalD prevInt02proc,0         ; -> previous INT 02h handler   !! don't move
globalD prevInt04proc,0         ; -> previous INT 04h handler   !! don't move
globalD prevInt06proc,0         ; -> previous INT 06h handler   !! don't move
globalD prevInt07proc,0         ; -> previous INT 07h handler   !! don't move
globalD prevInt3Eproc,0         ; -> previous INT 3Eh handler   !! don't move
globalD prevInt75proc,0         ; -> previous INT 75h handler   !! don't move
globalD prevIntx6proc,0         ; -> previous invalid op-code Fault handler
globalD prevInt0Cproc,0         ; -> previous stack fault handler
globalD prevInt0Dproc,0         ; -> previous GP Fault handler
globalD prevInt0Eproc,0         ; -> previous Page Fault handler
ifdef WOW
globalD prevInt31proc,0         ; used to speed dpmi calls
globalD oldInt00proc,0          ; for debugging traps
globalD prevInt01proc,0         ; for debugging traps
globalD prevInt03proc,0         ; for debugging traps
globalD prevInt10proc,0         ; -> previous INT 10 handler
endif
endif ;!ROM

if 0
        PUBLIC DummyKeyboardOEMToAnsi
DummyKeyboardOEMToAnsi proc far
        ret                 ; used for non-graphics version
DummyKeyboardOEMToAnsi endp
endif

sEnd    CODE


;------------------------------------------------------------------------
;       I N I T D A T A    S E G M E N T    V A R I A B L E S
;------------------------------------------------------------------------

DataBegin INIT

globalW oNRSeg,0
globalW oMSeg,0
globalD lpBootApp,0             ; Long pointer to app to run after booting
ifndef WOW
; WOW doesn't muck with WOAName buffer, we leave it as WINOLDAP.MOD
labelB  <PUBLIC,woa_286>
        db 'WINOLDAP.MOD'
labelB  <PUBLIC,woa_386>
        db 'WINOA386.MOD'
endif
labelB  <PUBLIC,bootExecBlock>
        EXECBLOCK <0,0,0,0>
globalW win_show,2
        dw      1               ; show open window

DataEnd INIT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kdataend.asm ===
TITLE	KDATAEND - Kernel ending data area


; This file contains the kernel data items that must be at the end of
; their respective segments.  This file is last in the link order.

include kernel.inc


; The PADDATA segment performs two functions:  it provides ginit with
; space to create the ending global heap sentinel, and it forces the
; linker to fully expand DGROUP in the .EXE file.  Kernel uses DGROUP
; before it's actually loaded by LoadSegment, so it needs to be fully
; expanded when loaded by the DOS EXEC call of kernel.

sBegin	PADDATA

	DB	32 DUP (0FFh)			; Room for final arena entry

sEnd	PADDATA

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kdos.inc ===
SG_EXIT       = 20H

TASKREG STRUC
TASKDX  DW      ?
TASKBX  DW      ?
TASKES  DW      ?
TASKCX  DW      ?
TASKAX  DW      ?
TASKDI  DW      ?
TASKSI  DW      ?
TASKDS  DW      ?
TASKBP  DW      ?
TASKREG ENDS

; Exit codes in upper byte

Exit_terminate	    EQU	    0
Exit_abort	    EQU	    0
Exit_Ctrl_C	    EQU	    1
Exit_Hard_Error	    EQU	    2
Exit_Keep_process   EQU	    3

user_FG     equ  word ptr [bp+6]
user_FL     equ  byte ptr [bp+6]
user_CS     equ  word ptr [bp+4]
user_IP     equ  word ptr [bp+2]
user_BP     equ  word ptr [bp]
user_DS     equ  word ptr [bp-2]
user_DX     equ  word ptr [bp-4]
user_DSDX   equ dword ptr [bp-4]
user_ES     equ  word ptr [bp-6]
user_BX     equ  word ptr [bp-8]
user_ESBX   equ dword ptr [bp-8]
user_AX     equ  word ptr [bp-10]
user_AL     equ  byte ptr [bp-10]
user_CX     equ  word ptr [bp-12]
user_SI     equ  word ptr [bp-14]
user_DI     equ  word ptr [bp-16]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kernel.h ===
/*
 *  KERNEL.H - C header file for all C kernel files
 *
 */

/*
 * The following is defined as the null string as the kernel is compiled
 * with the -PLM switch
 */
#ifndef PASCAL
#define PASCAL
#endif

#define BUILDDLL 1
#define	PMODE	 1
/*
 * Define the following non-zero and the debugging support in the kernel
 * is enabled
 */
#ifndef WINDEBUG
#define KDEBUG 0
#else
#define KDEBUG 1
#endif

#ifdef ROMWIN
#define ROM 1
#else
#define ROM 0
#endif

/* Register definition. */
#define REG
#define LONG       long
#define NULL       0

/* Define common constants. */
#define TRUE    1
#define FALSE   0

/* Far and Near dummy pointer attributes. */
#define FAR  far
#define NEAR near
typedef char far *FARP;
typedef char *NEARP;
typedef char far *LPSTR;
typedef char *PSTR;
typedef int ( far PASCAL * FARPROC )();
typedef int ( near PASCAL * NEARPROC )();
/* Standard types. */
typedef unsigned long     DWORD;
typedef unsigned short int WORD;
typedef WORD *pWORD;
typedef unsigned char      BYTE;
typedef int  BOOL;
#define VOID void

typedef WORD HANDLE;

typedef struct {
    WORD Offset;
    WORD Segment;
    } FARADDR;
typedef FARADDR *pFARADDR;

/*
 * Internel near kernel procedures
 */

FARPROC StartProcAddress( HANDLE, int );
HANDLE  StartTask( HANDLE, HANDLE, HANDLE, FARPROC );
HANDLE  StartLibrary( HANDLE, FARP, FARPROC );
HANDLE  FindExeInfo( FARP, WORD );
FARP    GetStringPtr( HANDLE, int, WORD );
HANDLE  AddModule( HANDLE );
HANDLE  DelModule( HANDLE );
void    IncExeUsage( HANDLE );
void    DecExeUsage( HANDLE );
void    PreloadResources( HANDLE, int );
HANDLE  GetExePtr( HANDLE );
DWORD   GetStackPtr( HANDLE );
WORD    GetInstance( HANDLE );
HANDLE  LoadExeHeader( int, int, FARP );
HANDLE  TrimExeHeader( HANDLE );
int     AllocAllSegs( HANDLE );
HANDLE  LoadSegment( HANDLE, WORD, int, int );
WORD    MyLock( HANDLE );
HANDLE  MyFree( HANDLE );
HANDLE  MyResAlloc( HANDLE, WORD, WORD, WORD );


/*
 * Undocumented, exported kernel procedures
 */

#if KDEBUG
#ifdef WOW
LPSTR far GetDebugString( int );
#else
LPSTR GetDebugString( int );
#endif
BOOL far   PASCAL GlobalInit( WORD, WORD, WORD, WORD );
WORD far * PASCAL GlobalInfoPtr( void );
#define GlobalFreeze( dummy ) ( *(GlobalInfoPtr()+1) += 1 )
#define GlobalMelt( dummy )   ( *(GlobalInfoPtr()+1) -= 1 )
#endif

void        PASCAL PatchStack( WORD far *, WORD, WORD );
WORD far *  PASCAL SearchStack( WORD far *, WORD );

int         far PASCAL SetPriority( HANDLE, int );
HANDLE      far PASCAL LockCurrentTask( BOOL );
HANDLE      far PASCAL GetTaskQueue( HANDLE );
HANDLE      far PASCAL SetTaskQueue( HANDLE, HANDLE );
WORD        far PASCAL GetCurrentPDB( void );
WORD        far PASCAL BuildPDB( WORD, WORD, FARP, WORD );
void        far PASCAL EnableDOS( void );
void        far PASCAL DisableDOS( void );
BOOL        far PASCAL IsScreenGrab( void );

HANDLE      far PASCAL CreateTask( DWORD, FARP, HANDLE);
HANDLE      far PASCAL GetDSModule( WORD );
HANDLE      far PASCAL GetDSInstance( WORD );
void        far PASCAL CallProcInstance( void );
FARPROC     far PASCAL SetTaskSignalProc( HANDLE, FARPROC );
FARPROC     far PASCAL SetTaskSwitchProc( HANDLE, FARPROC );
FARPROC     far PASCAL SetTaskInterchange( HANDLE, FARPROC );
void        far PASCAL ExitKernel( int );


/*
 * Exported procedures for KERNEL module
 */

/*
 * Interface to FatalExit procedure
 */

void far PASCAL FatalExit( int );
void far PASCAL ValidateCodeSegments();

/* Interface to Catch and Throw procedures */

typedef int CATCHBUF[ 9 ];
typedef int FAR *LPCATCHBUF;
int         FAR PASCAL Catch( LPCATCHBUF );
void        FAR PASCAL Throw( LPCATCHBUF, int );


/*
 * Interface to local memory manager
 */

#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LNOTIFY_OUTOFMEM 0
#define LNOTIFY_MOVE     1
#define LNOTIFY_DISCARD  2

BOOL    far PASCAL LocalInit( WORD, char *, char * );
HANDLE  far PASCAL LocalAlloc( WORD, WORD );
HANDLE  far PASCAL LocalReAlloc( HANDLE, WORD, WORD );
HANDLE  far PASCAL LocalFree( HANDLE );
char *  far PASCAL LocalLock( HANDLE );
BOOL    far PASCAL LocalUnlock( HANDLE );
WORD    far PASCAL LocalSize( HANDLE );
HANDLE  far PASCAL LocalHandle( WORD );
WORD    far PASCAL LocalCompact( WORD );
FARPROC far PASCAL LocalNotify( FARPROC );
int     far PASCAL LocalNotifyDefault( int, HANDLE, WORD );
#define LocalDiscard( h ) LocalReAlloc( h, 0, LMEM_MOVEABLE )

extern WORD * PASCAL pLocalHeap;

#define dummy 0
#define LocalFreeze( dummy ) ( *(pLocalHeap+1) += 1 )
#define LocalMelt( dummy )   ( *(pLocalHeap+1) -= 1 )
#define LocalHandleDelta( delta ) ( (delta) ? (*(pLocalHeap+9) = (delta)) : *(pLocalHeap+9))

#define calloc( n,size )    LocalAlloc( LMEM_ZEROINIT, n*(size) )
#define malloc( size )      LocalAlloc( 0, size )
#define free( p )           LocalFree( p )
#define realloc( p, size )  LocalReAlloc( p, size, LMEM_ZEROINIT )

/*
 * Interface to global memory manager
 */

#define GMEM_FIXED          0x0000
#define GMEM_ALLOCHIGH      0x0001      /* Kernel use only */
#define GMEM_MOVEABLE       0x0002
#define GMEM_DISCCODE       0x0004
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_SHARE          0x1000
#define GMEM_SHAREALL       0x2000

#define GNOTIFY_OUTOFMEM 0
#define GNOTIFY_MOVE     1
#define GNOTIFY_DISCARD  2

#define HIWORD(l)  ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOWORD(l)  ((WORD)(DWORD)(l))

HANDLE      far PASCAL GlobalAlloc( WORD, DWORD );
HANDLE      far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
HANDLE      far PASCAL GlobalFree( HANDLE );
HANDLE      far PASCAL GlobalFreeAll( WORD );
char far *  far PASCAL GlobalLock( HANDLE );
BOOL        far PASCAL GlobalUnlock( HANDLE );
DWORD       far PASCAL GlobalSize( HANDLE );
DWORD       far PASCAL GlobalHandle( WORD );
DWORD	    far PASCAL GlobalHandleNoRIP( WORD );
HANDLE      far PASCAL LockSegment( WORD );
HANDLE      far PASCAL UnlockSegment( WORD );
DWORD       far PASCAL GlobalCompact( DWORD );
#define LockData( dummy )   LockSegment( 0xFFFF )
#define UnlockData( dummy ) UnlockSegment( 0xFFFF )
#define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )


/*
 * Interface to the task scheduler
 */

BOOL        far PASCAL Yield( void );
BOOL        far PASCAL WaitEvent( HANDLE );
BOOL        far PASCAL PostEvent( HANDLE );
HANDLE      far PASCAL GetCurrentTask( void );
BOOL        far PASCAL KillTask( HANDLE );


/*
 * Interface to the dynamic loader/linker
 */

HANDLE      far PASCAL LoadModule( LPSTR, LPSTR );
void        far PASCAL FreeModule( HANDLE );
HANDLE      far PASCAL GetModuleHandle( LPSTR );
FARPROC     far PASCAL GetProcAddress(  HANDLE, LPSTR );
FARPROC     far PASCAL MakeProcInstance( FARPROC, HANDLE );
void        far PASCAL FreeProcInstance( FARPROC );
int         far PASCAL GetInstanceData( HANDLE, PSTR, int );
int         far PASCAL GetModuleUsage( HANDLE );
int         far PASCAL GetModuleFileName( HANDLE, LPSTR, int );


/*
 * Interface to the resource manager
 */

HANDLE      far PASCAL FindResource( HANDLE, LPSTR, LPSTR );
HANDLE      far PASCAL LoadResource( HANDLE, HANDLE );
BOOL        far PASCAL FreeResource( HANDLE );

char far *  far PASCAL LockResource( HANDLE );

FARPROC     far PASCAL SetResourceHandler( HANDLE, LPSTR, FARPROC );
HANDLE      far PASCAL AllocResource( HANDLE, HANDLE, DWORD );
WORD        far PASCAL SizeofResource( HANDLE, HANDLE );
int         far PASCAL AccessResource( HANDLE, HANDLE );

#define MAKEINTRESOURCE(i)  (LPSTR)((unsigned long)((WORD)i))

/* Predefined resource types */
#define RT_CURSOR       MAKEINTRESOURCE( 1 )
#define RT_BITMAP       MAKEINTRESOURCE( 2 )
#define RT_ICON         MAKEINTRESOURCE( 3 )
#define RT_MENU         MAKEINTRESOURCE( 4 )
#define RT_DIALOG       MAKEINTRESOURCE( 5 )
#define RT_STRING       MAKEINTRESOURCE( 6 )
#define RT_FONTDIR      MAKEINTRESOURCE( 7 )
#define RT_FONT         MAKEINTRESOURCE( 8 )


/*
 * Interface to the user profile

int         far PASCAL GetProfileInt( LPSTR, LPSTR, int );
int         far PASCAL GetProfileString( LPSTR, LPSTR, LPSTR, LPSTR, int );
void        far PASCAL WriteProfileString( LPSTR, LPSTR, LPSTR );
 */


/*
 * Interface to the atom manager
 */

typedef WORD ATOM;

BOOL        far PASCAL InitAtomTable( int );
ATOM        far PASCAL FindAtom( LPSTR );
ATOM        far PASCAL AddAtom( LPSTR );
ATOM        far PASCAL DeleteAtom( ATOM );
WORD        far PASCAL GetAtomName( ATOM, LPSTR, int  );
HANDLE      far PASCAL GetAtomHandle( ATOM );

#define MAKEINTATOM(i)  (LPSTR)((unsigned long)((WORD)i))

#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;

extern ATOMTABLE * PASCAL pAtomTable;


/*
 * Interface to the string functions
 */

int         far PASCAL lstrcmp( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcat( LPSTR, LPSTR );
int         far PASCAL lstrlen( LPSTR );
LPSTR       far PASCAL lstrbscan( LPSTR, LPSTR );
LPSTR       far PASCAL lstrbskip( LPSTR, LPSTR );

/*
 * Interface to the file I/O functions
 */

int         far PASCAL OpenPathname( LPSTR, int );
int         far PASCAL DeletePathname( LPSTR );
int         far PASCAL _lopen( LPSTR, int );
void        far PASCAL _lclose( int );
int         far PASCAL _lcreat( LPSTR, int );
LONG        far PASCAL _llseek( int, long, int );
WORD        far PASCAL _lread( int, LPSTR, int );
WORD        far PASCAL _lwrite( int, LPSTR, int );
BOOL        FAR PASCAL AnsiToOem( LPSTR, LPSTR );
BOOL        FAR PASCAL OemToAnsi( LPSTR, LPSTR );
BYTE        FAR PASCAL AnsiUpper( LPSTR );
BYTE        FAR PASCAL AnsiLower( LPSTR );
LPSTR       FAR PASCAL AnsiNext( LPSTR );
LPSTR       FAR PASCAL AnsiPrev( LPSTR, LPSTR );

typedef struct  {
        BYTE    cBytes;                 /* length of structure */
        BYTE    fFixedDisk;             /* non-zero if file located on non- */
                                        /* removeable media */
        WORD    nErrCode;               /* DOS error code if OpenFile fails */
        BYTE    reserved[ 4 ];
        BYTE    szPathName[ 128 ];
} OFSTRUCT;
typedef OFSTRUCT      *POFSTRUCT;
typedef OFSTRUCT NEAR *NPOFSTRUCT;
typedef OFSTRUCT FAR  *LPOFSTRUCT;

int         FAR PASCAL GetTempFileName( BYTE, LPSTR, WORD, LPSTR );
int         FAR PASCAL OpenFile( LPSTR, LPOFSTRUCT, WORD );
int        NEAR PASCAL MyOpenFile( LPSTR, LPOFSTRUCT, WORD );

/* Flags for GetTempFileName */

#define TF_FORCEDRIVE   (BYTE)0x80  /* Forces use of current dir of passed */
                                    /* drive */
/* Flags for OpenFile */

#define OF_REOPEN       0x8000
#define OF_EXIST        0x4000
#define OF_PROMPT       0x2000
#define OF_CREATE       0x1000
#define OF_CANCEL       0x0800
#define OF_VERIFY       0x0400
#define OF_DELETE       0x0200
/* Can use these with _lopen too */
#define	OF_SHARE_COMPAT	    0x00
#define	OF_SHARE_EXCLUSIVE  0x10
#define	OF_SHARE_DENY_WRITE 0x20
#define	OF_SHARE_DENY_READ  0x30
#define	OF_SHARE_DENY_NONE  0x40
#define	OF_NO_INHERIT	    0x80
			     	
#define READ        0       /* Flags for _lopen */
#define WRITE       1
#define READ_WRITE  2

#if KDEBUG
int PASCAL KernelError( int, LPSTR, LPSTR );
void far PASCAL FarKernelError( int, LPSTR, LPSTR );
#else
#define FarKernelError( a, b, c ) FatalExit( a )
#endif

/* See KERNEL.INC for parallel definitions */

#define ERR_LMEM        0x0100      /* Local memory manager errors */
#define ERR_GMEM        0x0200      /* Global memory manager errors */
#define ERR_TASK        0x0300      /* Task scheduler errors */

#define ERR_LD          0x0400      /* Dynamic loader/linker errors */
#define ERR_LDBOOT      0x0401      /* Error booting */
#define ERR_LDLOAD      0x0401      /* Unable to load a file */

#define ERR_RESMAN      0x0500      /* Resource manager errors */
#define ERR_MISSRES     0x0501      /* Missing resource table */
#define ERR_BADRESTYPE  0x0502      /* Bad resource type */
#define ERR_BADRESNAME  0x0503      /* Bad resource name */
#define ERR_BADRESFILE  0x0504      /* Bad resource file */
#define ERR_BADDEFAULT  0x0506      /* Bad parameter to profile routine */

#define ERR_ATOM        0x0600      /* Atom manager errors */
#define ERR_IO          0x0700      /* I/O package errors */

#define ERR_PARAMETER   0x0800      /* Parameter checking RIP */

#define HE_DISCARDED    0x40
#define HE_SHAREALL     0x20
#define HE_SHARE        0x10
#define HE_DISCARDABLE  0x0F

#define HE_FREEHANDLE   0xFFFF

#define LHE_DISCARDED    0x40
#define LHE_SHAREALL     0x20
#define LHE_SHARE        0x10
#define LHE_DISCARDABLE  0x0F

#define LHE_FREEHANDLE   0xFFFF

#define HANDLEENTRY struct handleentry
#define HANDLETABLE struct handletable
#define LOCALHANDLEENTRY struct localhandleentry
#define LOCALHANDLETABLE struct localhandletable
#define FREEHANDLEENTRY struct freehandleentry
#define LOCALFREEHANDLEENTRY struct localfreehandleentry

HANDLEENTRY {
    WORD    he_address;
    BYTE    he_flags;
    BYTE    he_seg_no;
};
typedef HANDLEENTRY *PHANDLEENTRY;

HANDLETABLE {
    WORD    ht_count;
    HANDLEENTRY    ht_entry[ 1 ];
};
typedef HANDLETABLE *PHANDLETABLE;

LOCALHANDLEENTRY {
    WORD    lhe_address;
    BYTE    lhe_flags;
    BYTE    lhe_count;
};
typedef LOCALHANDLEENTRY *PLOCALHANDLEENTRY;

LOCALHANDLETABLE {
    WORD    ht_count;
    LOCALHANDLEENTRY    ht_entry[ 1 ];
};
typedef LOCALHANDLETABLE *PLOCALHANDLETABLE;

FREEHANDLEENTRY {
    WORD    he_link;
    WORD    he_free;
};
typedef FREEHANDLEENTRY *PFREEHANDLEENTRY;

LOCALFREEHANDLEENTRY {
    WORD    lhe_link;
    WORD    lhe_free;
};
typedef LOCALFREEHANDLEENTRY *PLOCALFREEHANDLEENTRY;

#define LOCALARENA struct localarena

LOCALARENA {
    LOCALARENA         *la_prev;
    LOCALARENA         *la_next;
    LOCALHANDLEENTRY   *la_handle;
};
typedef LOCALARENA *PLOCALARENA;

#define LOCALARENAFREE struct localarenafree

LOCALARENAFREE {
    LOCALARENAFREE     *la_prev;	/* previous block */
    LOCALARENAFREE     *la_next;	/* next block */
    int 		la_size;	/* size of block (includes header) */
    LOCALARENAFREE     *ls_free_prev;	/* previous free entry */
    LOCALARENAFREE     *la_free_next;	/* next free entry */
};
typedef LOCALARENAFREE *PLOCALARENAFREE;

#define LOCALSTATS struct localstats

LOCALSTATS {
    WORD ls_ljoin;
    WORD ls_falloc;
    WORD ls_fexamine;
    WORD ls_fcompact;
    WORD ls_ffound;
    WORD ls_ffoundne;
    WORD ls_malloc;
    WORD ls_mexamine;
    WORD ls_mcompact;
    WORD ls_mfound;
    WORD ls_mfoundne;
    WORD ls_fail;
    WORD ls_lcompact;
    WORD ls_cloop;
    WORD ls_cexamine;
    WORD ls_cfree;
    WORD ls_cmove;
};

typedef struct {
    WORD                hi_check;
    WORD                hi_freeze;
    WORD                hi_count;
    PLOCALARENA         hi_first;
    PLOCALARENA         hi_last;
    BYTE                hi_ncompact;
    BYTE                hi_dislevel;
    WORD                hi_distotal;
    LOCALHANDLETABLE   *hi_htable;
    LOCALHANDLEENTRY   *hi_hfree;
    WORD                hi_hdelta;
    NEARPROC            hi_hexpand;
    LOCALSTATS         *hi_pstats;

    FARPROC             li_notify;
    WORD                li_lock;
    WORD                li_extra;
    WORD		li_minsize;
} LOCALINFO;

typedef LOCALINFO *PLOCALINFO;

#define LA_BUSY     1
#define LA_MOVEABLE 2
#define LA_ALIGN   (LA_MOVEABLE+LA_BUSY)
#define LA_MASK    (~ LA_ALIGN)

typedef HANDLEENTRY     far *LPHANDLEENTRY;
typedef HANDLETABLE     far *LPHANDLETABLE;
typedef FREEHANDLEENTRY far *LPFREEHANDLEENTRY;

typedef LOCALHANDLEENTRY     far *LPLOCALHANDLEENTRY;
typedef LOCALHANDLETABLE     far *LPLOCALHANDLETABLE;
typedef LOCALFREEHANDLEENTRY far *LPLOCALFREEHANDLEENTRY;

#define GLOBALARENA struct globalarena

GLOBALARENA {
    BYTE            ga_count;
    WORD            ga_owner;
    WORD            ga_size;
    BYTE            ga_flags;
    WORD            ga_prev;
    WORD            ga_next;
    HANDLEENTRY    *ga_handle;
    HANDLEENTRY    *ga_lruprev;
    HANDLEENTRY    *ga_lrunext;
};

#define ga_sig ga_count

typedef GLOBALARENA far *LPGLOBALARENA;

typedef struct {
    WORD            hi_check;
    WORD            hi_freeze;
    WORD            hi_count;
    WORD            hi_first;
    WORD            hi_last;
    BYTE            hi_ncompact;
    BYTE            hi_dislevel;
    WORD            hi_distotal;
    HANDLETABLE    *hi_htable;
    HANDLEENTRY    *hi_hfree;
    WORD            hi_hdelta;
    NEARPROC        hi_hexpand;
    WORD           *hi_pstats;

    WORD            gi_lrulock;
    HANDLEENTRY    *gi_lruchain;
    WORD            gi_lrucount;
    WORD            gi_reserve;
    WORD            gi_disfence;
    WORD	    gi_alt_first;
    WORD	    gi_alt_last;
    WORD	    gi_alt_count;
    HANDLEENTRY	   *gi_alt_lruchain;
    WORD	    gi_alt_lrucount;
    WORD	    gi_alt_reserve;
    WORD	    gi_alt_disfence;
} GLOBALINFO;

typedef GLOBALINFO far *LPGLOBALINFO;

#define GA_SIGNATURE    0x4D
#define GA_ENDSIG       0x5A

#define GA_FIXED 1
#define GA_ALIGN GA_FIXED
#define GA_MASK  (~ GA_ALIGN)

#define lpGlobalArena( w ) (LPGLOBALARENA)((DWORD)(w) << 16)
#define lpHandleEntry( w ) (LPHANDLEENTRY)(pMaster | (WORD)(w))
#define lpHandleTable( w ) (LPHANDLETABLE)(pMaster | (WORD)(w))

/*
 * Structure passed between user profile routines
 */
typedef	struct {
	LPSTR	lpProFile;	/* Pointer to INI filename */
	LPSTR	lpBuffer;	/* Pointer to buffer containing file */
	int	hBuffer;	/* Handle of buffer */
	unsigned BufferLen;	/* Length of buffer */
	int	FileHandle;	/* File handle - -1 if not open */
	int	ProFlags;	/* Open, writing etc */
    WORD wClusterSize;  /* Cluster size on this drive */
	OFSTRUCT ProBuf;	/* OpenFile info */
} PROINFO;

/* WinFlags[0] */

#define	WF_PMODE	0x01	/* Windows is running in Protected Mode */
#define	WF_CPU286	0x02	/* Windows is running on an 80286 cpu */
#define	WF_CPU386	0x04	/*    "     "	"     "  " 80386 cpu */
#define	WF_CPU486	0x08	/* Windows is running on an 80486 cpu */
#define	WF_STANDARD	0x10	/* Running Windows/286 */
#define	WF_ENHANCED	0x20	/* Running Windows/386 */
#define	WF_CPU086	0x40	/* Windows is running on an  8086 cpu */
#define	WF_CPU186	0x80	/* Windows is running on an 80186 cpu */
			  	
/* WinFlags[1] */

#define	WF1_LARGEFRAME	0x01	/* Running in EMS small frame */
#define	WF1_SMALLFRAME	0x02	/* Running in EMS large frame */
#define	WF1_80x87	0x04	/* There is a co-processor present */
			  
#ifndef WINDEBUG

#include "ikernel.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kernel.inc ===
; Include file for kernel assembler source files.

?PLM = 1
?WIN = 1
?NODATA = 1
?DF = 1
?386regs = 1
ifndef WINDEBUG
	KDEBUG = 0
	WDEBUG = 0
	DOS5 = 1		; Do not mark far stack frames.
else
	KDEBUG = 1
	WDEBUG = 1
endif

SHARE_AWARE = 0

BUILDDLL	equ	1
PMODE		equ	1

include cmacros.inc
include logerror.inc
include vint.inc

DEB_ERROR       equ DBF_ERROR
DEB_WARN        equ DBF_WARNING
DEB_TRACE       equ DBF_TRACE
DEB_FERROR      equ DBF_FATAL
DEB_krMemMan    equ DBF_KRN_MEMMAN
DEB_krLoadMod   equ DBF_KRN_LOADMODULE
DEB_krLoadSeg   equ DBF_KRN_SEGMENTLOAD
DEB_IERROR      equ DBF_ERROR
DEB_IWARN       equ DBF_WARNING
DEB_ITRACE      equ DBF_TRACE
DEB_IFERROR     equ DBF_FATAL

;DEB_ERROR       =  1
;DEB_WARN        =  2
;DEB_TRACE       =  4
;DEB_FERROR      =  8    ;; fatal error - terminate app
;DEB_IERROR      = 10h
;DEB_IWARN       = 20h
;DEB_ITRACE      = 40h
;DEB_IFERROR     = 80h ;; fatal error - terminate app
;DEB_FERRORS     = DEB_FERROR or DEB_IFERROR
;DEB_ERRORS      = DEB_ERROR OR DEB_IERROR OR DEB_FERRORS
;DEB_WARNS       = DEB_WARN OR DEB_IWARN
;DEB_TRACES      = DEB_TRACE OR DEB_ITRACE
;DEB_NOCRLF      = 8000h ;; No CR/LF in string
DEB_BREAKLEVEL  = 099h
DEB_INFOLEVEL   = 099h or 022h

if KDEBUG
  ;include win3deb.inc
  ;declare_debug kr
  ;declare_areas Kernel, kr, <MemMan, LoadMod, LoadSeg>

ifndef win3deb
externFP    _krDebugTest
endif

BegData	macro
  _DATA	SEGMENT PARA PUBLIC 'DATA'
endm

EndData	macro
  _DATA ENDS
endm

krDebugOut    macro   flags,msg
    local   a, b
    BegData
a label byte
ife ((flags and DBF_SEVMASK) - DBF_FATAL)
	db	"fatl"
elseife ((flags and DBF_SEVMASK) - DBF_ERROR)
	db	"err"
elseife ((flags and DBF_SEVMASK) - DBF_WARNING)
	db	"wn"
else
	db	"t"
endif
ifdef WOW
    db	    " W16Kernel: "
else
    db	    " Kernel: "
endif
    db	    msg
    db	    0ah
    db	    0
    EndData
    push    flags or DBF_KERNEL
    push    offset a
    call    _krDebugTest
endm

else
  krDebugOut macro flag, str, vals
  endm
endif

if1
ifndef ?DFSTACK
 ?DFSTACK1 = 0
else
 ?DFSTACK1 = 1
endif
endif

; Define IGROUP segments

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE,IGROUP
createSeg   _INITTEXT,INITCODE,WORD,PUBLIC,CODE,IGROUP

defGrp IGROUP,CODE


; Define Non-resident segments (after "defGrp IGROUP")

createSeg   _NRESTEXT,NRESCODE,WORD,PUBLIC,CODE
createSeg   _MISCTEXT,MISCCODE,WORD,PUBLIC,CODE

; Define DGROUP segments

createSeg   _DATA,DATA,PARA,PUBLIC,DATA,DGROUP
createSeg   _GPFIX0,GPFIX0,WORD,PUBLIC,DATA,DGROUP  ; GP fault trapping
createSeg   _GPFIX,GPFIX,WORD,PUBLIC,DATA,DGROUP
createSeg   _GPFIX1,GPFIX1,WORD,PUBLIC,DATA,DGROUP
createSeg   _INITDATA,INITDATA,WORD,PUBLIC,DATA,DGROUP
if ?DFSTACK1
  createSeg   STACK,STACK,PARA,PUBLIC,DATA,DGROUP
endif
createSeg   _PADDATA,PADDATA,BYTE,PUBLIC,DATA,DGROUP

defGrp	    DGROUP,DATA


if ?CHKSTK1
externP <chkstk>
endif


DISCARD_HIGH	= 1
TONYS_EMS_STUFF = 0

if KDEBUG
RSHORT	equ	<>
else
RSHORT	equ	short
endif

.286

	.286p
	INTBASE = 90h
	RNTBASE = 45h

  ifndef PM386
	PMODE32 = 0
  else
	PMODE32 = 1
  endif

  ifndef ALIASTRACKING
	ALIASES = 0
  else
	ALIASES = 1
  endif


if1

ifdef FE_SB
	FFDBCS = 1
else
	FFDBCS = 0
endif

KRNLDS	EQU	<DATA>

ifdef ROMWIN
	ROM = 1
	if PMODE
	%OUT ROM Kernel requires Protect Mode
	.err
	endif
else
	ROM = 0
endif

outif	ROM,0,<ROM Windows kernel>

outif	KDEBUG,0,<Debug Kernel.>

outif	FFDBCS,0,<DBCS code enabled>

; The following three are obsolete, but they need to have the
; proper values so dead code doesn't get assembled, and live
; code does.

SDEBUG		equ	1

LDCHKSUM	equ	0

SWAPPRO		equ	0

endif

 ERR_LMEM  =   00100h  ; Local memory errors
 ERR_LMEMCRIT  =   00140h  ; Local heap is busy
 ERR_LMEMHANDLE  =   00180h  ; Invalid local handle
 ERR_LMEMLOCK  =   001C0h  ; LocalLock count overflow
 ERR_LMEMUNLOCK  =   001F0h  ; LocalUnlock count underflow

 ERR_GMEM  =   00200h  ; global memory errors
;ERR_GMEMCRIT  =   00240h  ; Critical section problems
 ERR_GMEMHANDLE  =   00280h  ; Invalid global handle
 ERR_GMEMLOCK  =   002C0h  ; globalLock count overflow
 ERR_GMEMUNLOCK  =   002F0h  ; globalUnlock count underflow

;ERR_TASK  =   00300h  ; task schedule errors
;ERR_TASKID  =   00301h  ; Invalid task ID
;ERR_TASKEXIT  =   00302h  ; Invalid exit system call
;ERR_TASKFRAME =   00303h  ; Invalid BP chain

;ERR_LD    =   00400h  ; dynamic loader/linker errors
;ERR_LDBOOT  =   00401h  ; Error during boot process
;ERR_LDLOAD  =   00402h  ; Error loading a module
;ERR_LDORD =   00403h  ; Invalid ordinal reference
;ERR_LDNAME  =   00404h  ; Invalid entry name reference
;ERR_LDPROC  =   00405h  ; Invalid start proc
ERR_LDMODULE	=   00406h	; Invalid module handle
;ERR_LDRELOC =   00407h  ; Invalid relocation record
;ERR_LDFWDREF  =   00408h  ; Error saving forward reference
;ERR_LDREADSEG =   00409h  ; Error reading segment contents
;ERR_LDREADREL =   00410h  ; Error reading segment contents
;ERR_LDDISK  =   00411h  ; Insert disk for specified file
ERR_LDNRTABLE	=   00412h	; Error reading non-resident table
;ERR_LDFILES =   00413h  ; Out of files
;ERR_LDINT3F =   004FFh  ; INT 3F handler unable to load segment

;ERR_RESMAN  =   00500h  ; resource manager/user profile errors
;ERR_MISSRES =   00501h  ; Missing resource table
;ERR_BADRESTYPE  =   00502h  ; Bad resource type
;ERR_BADRESNAME  =   00503h  ; Bad resource name
ERR_BADRESFILE	=   00504h	; Bad resource file
ERR_BADRESREAD	=   00505h	; Error reading resource
ERR_BADDEFAULT	=   00506h	; Bad default pointer for profile routine

;ERR_ATOM  =   00600h  ; atom manager errors

;ERR_IO    =   00700h  ; I/O package errors

ERR_PARAMETER   =   00800h      ; Internal KERNEL parameter validation

;** PTrace notification indexes.  See 2lddebug and 3lddebug
SDM_RIN 	=  9
SDM_BANKLINE	=  10
SDM_NEWTASK	=  11
SDM_FLUSHTASK	=  12
SDM_SWITCHOUT	=  13
SDM_SWITCHIN	=  14
SDM_KEYBOARD	=  15
SDM_MAXFUNC	=  15
SDM_LOADSEG	=  50h
SDM_MOVESEG	=  51h
SDM_FREESEG	=  52h
SDM_RELEASESEG	=  5Ch
SDM_GLOBALHEAP	=  3
SDM_CONWRITE	=  12h
SDM_CONREAD	=  1
SDM_DGH 	=  56h
SDM_DFL 	=  57h
SDM_DLL 	=  58h
SDM_LOADTASK	=  59h
SDM_POSTLOAD	=  60h
SDM_EXITCALL	=  62h
SDM_INT2	=  63h
SDM_LOADDLL	=  64h
SDM_DELMODULE	=  65h
; New notifications
SDM_LOGERROR	=  66h	    ; cx = error code, dx:bx = ptr to optional info
SDM_LOGPARAMERROR = 67h     ; es:bx = ptr to struct { err, lpfn, param };

if1
outif	?RIPAUX,0
endif

; DataBegin/End macros are used to bracket data items.	Examples:
;
; DataBegin			; in segment DATA
;	globalD flarp,0
; DataEnd
;
; DataBegin	INIT		; in segment INITDATA
;	globalW who_cares,1022
; DataEnd	INIT

DataBegin	macro	type
% sBegin  &type&%KRNLDS
assumes ds, %KRNLDS
	endm

DataEnd 	macro	type
assumes ds,nothing
sEnd	&type&%KRNLDS
	endm

;-----------------------------------------------------------------------
; cProcVDO  - cProc "Validate Debug Only"
;
; Same as cProc, except used for "Validate in Debug Only" entry points.
; Declares Iname if debug, name if retail.
;
cProcVDO macro  name,opts,savelist
  if KDEBUG
        cProc   <I&name>,<opts>,<savelist>
  else
        LabelFP <PUBLIC, I&name>
        cProc   <name>,<opts>,<savelist>
  endif
endm


;-----------------------------------------------------------------------
; LabelVDO
;
; Similar to LabelFP, except used for "validate in debug only" entry points.
; Declares Iname if debug, name if
;
LabelVDO macro  name
  if KDEBUG
        LabelFP <PUBLIC, I&name>
  else
        LabelFP <PUBLIC, I&name>
        LabelFP <PUBLIC, name>
  endif
endm
if KDEBUG

ife ?RIPAUX
externFP FarKernelError
ifndef WOW
externNP NearKernelError
endif
externFP	KOutDSStr
endif

ifdef WOW
externFP	<KernelError>
else
externNP	<KernelError>
endif

DataBegin
externB	szFKE	; "**** Fatal Kernel Error ****" - Only define the string once
DataEnd

kerror	macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	    <segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

  ifdef WOW
	call	FarKernelError		;; Call Kernel Error
  else
	call	NearKernelError		;; Call Kernel Error
  endif
endm

fkerror macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	<segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

	call	FarKernelError		;; Call Kernel Error
endm

mkerror macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	    <segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

	call	FarKernelError		;; Call Kernel Error
endm

else  ;; not KDEBUG

ifdef WOW ; For WOW we call FatalExitC which thunks to WK32FatalExit.
externFP        <FatalExitC>
kerror  macro   errcode,msg,segarg,offarg       ;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm

fkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm

mkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm
else  ;; not WOW
    ife ?RIPAUX		 ; Dont declare external in RIPAUX.ASM
        externFP	<FatalExitDeath>
    endif
kerror	macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm

fkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm

mkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm
endif  ;; not WOW
endif  ;; not KDEBUG

; define misc. register pairs
;
regptr	esax,es,ax
regptr	esbx,es,bx
regptr	essi,es,si
regptr	esdi,es,di
regptr	dsax,ds,ax
regptr	dsbx,ds,bx
regptr	dsdx,ds,dx
regptr	dssi,ds,si
regptr	dsdi,ds,di
regptr	csbx,cs,bx
regptr	csdx,cs,dx
regptr	cssi,cs,si
regptr	csdi,cs,di
regptr	dxax,dx,ax
regptr	ssbx,ss,bx
regptr	ssdi,ss,di

;	The jmpnext macro and associated symbols are used to generate
;	the fall-through chain and generate the labels required for
;	error checking.

??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e>					;;If not the end of the chain
	db	03Dh			;;cmp ax, next two bytes
errn$	??ji&j,+2			;;next label must be two bytes away
endif
??ji=j					;;increment counter
endm

smov	macro	segreg1,segreg2
	push	segreg2
	pop	segreg1
endm

jmps	macro	n
	jmp	short n
endm

ret_far	macro	add_2_stack
ifnb	<add_2_stack>
	db	0CAh
	dw	add_2_stack
else
	db	0CBh
endif
	endm


entry	macro	routine
	extrn	routine		:near
	dw	Offset IGROUP:routine
	endm


STACK_SIGNATURE equ	'WD'
MPIT_SIGNATURE	equ	'TP'

INT21	macro
	int	21h		; Force an actual int 21h
	endm

DOSCALL	macro
	pushf
	push	cs
	call	near ptr Int21Handler	; Call our handler directly!
	endm

DOSFCALL	macro
	pushf
	call	far ptr Int21Handler	; Call our handler directly!
	endm

SetKernelDSNRes	macro	segreg   	; usable in kernel NRES segment
ifndef KDataSeg
externW KDataSeg
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:KDataSeg
else
	mov	es, cs:KDataSeg
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:KDataSeg
	assumes ds, %KRNLDS
endif
	endm

SetKernelDSMisc	macro	segreg		; usable in kernel MISC segment
ifndef MKDataSeg
externW MKDataSeg
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:MKDataSeg
else
	mov	es, cs:MKDataSeg
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:MKDataSeg
	assumes ds, %KRNLDS
endif
	endm

SetKernelDS	macro	segreg
ifndef MyCSDS
externW MyCSDS
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:MyCSDS
else
	mov	es, cs:MyCSDS
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:MyCSDS
	assumes ds, %KRNLDS
endif
	endm

UnSetKernelDS	macro	segreg
ifnb	<segreg>
	assumes	<segreg>, nothing
else
	assumes	ds, nothing
endif
	endm

ReSetKernelDS	macro	segreg
ifnb	<segreg>
	assumes <segreg>, %KRNLDS
else
	assumes ds, %KRNLDS
endif
	endm

CheckKernelDS	macro	segreg
	local	ok
if KDEBUG
ifndef MyCSDS
externW MyCSDS
endif
	push	ax
ifnb	<segreg>
	mov	ax, segreg
else
	mov	ax, ds
endif
	cmp	ax, cs:MyCSDS
	je	short ok
	int 3
ok:
	pop	ax
endif
	endm

SetKernelCSDword	macro	pdw, dwseg, dwoff
ifndef SetKernelCSDwordProc
externNP SetKernelCSDwordProc
endif
	cCall	SetKernelCSDwordProc,<pdw,dwseg,dwoff>
	endm

Critical_check	macro
	local	hey_dude
if KDEBUG
	push	ds
	mov	ds,pGlobalHeap
	cmp	ds:[gi_lrulock],0	; Make sure we're critical!
	jnz	short hey_dude
	int	3
hey_dude:
	pop	ds
endif
endm

TDB_check_ES	macro
	local	hey_dude
if KDEBUG
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

TDB_check_DS	macro
	local	hey_dude
if KDEBUG
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

NE_check_ES	macro
	local	hey_dude
if KDEBUG
	cmp	es:[ne_magic],NEMAGIC
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

NE_check_DS    macro
	local	hey_dude
if KDEBUG
	cmp	ds:[ne_magic],NEMAGIC
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

ife 3-3
sel_check	macro reg
	local	hey_dude, aaarrrggghhh
if KDEBUG
	or	reg, reg
	jz	short hey_dude
	test	reg, 4h				; Must be LDT
	jz	short aaarrrggghhh
	test	reg,2h				; Must be ring 2 or 3
	jnz	short hey_dude			; yes, fine
aaarrrggghhh:
	int 3
        xor     reg, reg                    ; HACK!! bug 5896
hey_dude:
endif
	and	reg, not 7
endm

else

sel_check	macro reg
	local	hey_dude, aaarrrggghhh
if KDEBUG
	or	reg, reg
	jz	short hey_dude
	test	reg, 4h				; Must be LDT
	jnz	short hey_dude
	int 3
hey_dude:
endif
	and	reg, not 7
endm

endif

KBINFO		STRUC
kbRanges	DB	4 dup (0)  ; Far East ranges for KANJI
kbStateSize	DW	0	; #bytes of state info maintained by TOASCII
KBINFO		ENDS


EXECBLOCK	struc
envseg		dw	?	; seg addr of environment
lpcmdline	dd	?	; pointer to asciz command line
lpfcb1		dd	?	; default fcb at 5C
lpfcb2		dd	?	; default fcb at 6C
EXECBLOCK	ends

SYSINITVAR	STRUC
dpbhead		DD	?	; Head of DPB-FAT list
sfthead		DD	?	; Head of SFT table list
pclockdev	DD	?	; pointer to clock device
pcondev		DD	?	; pointer to console device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SYSINITVAR	ENDS
;
; system file table
;
SFT		STRUC
sftLink		DD	?
sftCount	DW	?	; number of entries
sftFile		DB	?
SFT		ENDS

SFT_ENTRY3	STRUC
sf_ref_count3	DW	?	; number of processes sharing fcb
sf_mode3	DW	?	; mode of access
sf_attr3	DB	?	; attribute of file
sf_flags	DW	?
sf_devptr	DD	?
		DB	21 dup (?)	; this is 21 for DOS 3.1
sf_name		DB	?
SFT_ENTRY3	ENDS

DPB	STRUC
dpb_drive	DB	?	; Logical drive # assoc with DPB (A=0,B=1,...)
DPB	ENDS

devid_device	EQU	0080H	; true if a device
sf_isnet	EQU	8000H	; true if network drive


	INTVECTOR	= 00Bh
	INTSIZE 	= 8


HILO	STRUC
lo	DW	?
hi	DW	?
HILO	ENDS

SEGOFF	STRUC
off	DW	?
sel	DW	?
SEGOFF	ENDS


; CPU flags

CPUF_CARRY		= 0000000000000001b
;			= 0000000000000010b
CPUF_PARITY		= 0000000000000100b
;			= 0000000000001000b
CPUF_AUXCARRY		= 0000000000010000b
;			= 0000000000100000b
CPUF_ZERO		= 0000000001000000b
CPUF_SIGN		= 0000000010000000b
CPUF_TRAP		= 0000000100000000b
CPUF_INTERRUPT		= 0000001000000000b
CPUF_DIRECTION		= 0000010000000000b
CPUF_OVERFLOW		= 0000100000000000b
CPUF_IOPL		= 0011000000000000b
CPUF_NESTEDTASK 	= 0100000000000000b
;			= 1000000000000000b

; WM_FILESYSCHANGE message wParam value

WM_FILESYSCHANGE	= 0034h

FSC_CREATE		= 0
FSC_DELETE		= 1
FSC_RENAME		= 2
FSC_ATTRIBUTES		= 3
FSC_NETCONNECT		= 4
FSC_NETDISCONNECT	= 5
FSC_REFRESH		= 6
FSC_MKDIR		= 7
FSC_RMDIR		= 8

;  MessageBox type flags

MB_OK			= 0000H
MB_OKCANCEL		= 0001H
MB_ABORTRETRYIGNORE	= 0002H
MB_YESNOCANCEL		= 0003H
MB_RETRYCANCEL		= 0005H
MB_ICONHAND		= 0010H
MB_ICONQUESTION		= 0020H
MB_ICONEXCLAMATION	= 0030H
MB_ICONASTERISK		= 0040H
MB_DEFBUTTON1		= 0000H
MB_DEFBUTTON2		= 0100H
MB_DEFBUTTON3		= 0200H
MB_SYSTEMMODAL		= 1000H
MB_TASKMODAL            = 2000H

;  Conventional dialog box and message box command IDs

IDOK		=   1
IDCANCEL	=   2
IDABORT 	=   3
IDRETRY 	=   4
IDIGNORE	=   5
IDYES		=   6
IDNO		=   7

; SysErrorBox type flags

SEB_OK		= 0001h ; Button with "OK".
SEB_CANCEL	= 0002h ; Button with "Cancel"
SEB_YES 	= 0003h ; Button with "&Yes"
SEB_NO		= 0004h ; Button with "&No"
SEB_RETRY	= 0005h ; Button with "&Retry"
SEB_ABORT	= 0006h ; Button with "&Abort"
SEB_IGNORE	= 0007h ; Button with "&Ignore"
SEB_CLOSE       = 0008h ; Button with "Close"
SEB_DEFBUTTON	= 8000h ; Mask to make this button default

; ExitKernel/ExitWindows flags
EW_REBOOTSYSTEM = 43h

; Kernel Flags[0]

kf_restore_CtrlC	EQU	01h	; A task switch has occured.
kf_restore_disk		EQU	02h	; A task switch has occured.
kf_mondrian		EQU	04h	; Windows was started under Mondrian.
kf_check_free		EQU	08h	; Free memory checking requested.
kf_pUID			EQU	10h	; Time to call pUserInitDone.
kf_EMS_debug		EQU	20h	; Tell symdeb about pseudo discards.
kf_search_inst_stacks	EQU	40h	; In patchstack search module stacks.
kf_useslim32		EQU	80h	; Uses LIM 3.2 API (Intel Above Board)

; Kernel Flags[1]

kf1_WIN386		EQU	01h	; we are running under Windows/386
kf1_WINOLDAP		EQU	02h	; the app being loaded is WinOldAp
kf1_ABORTION		EQU	04h	; loading the automatic data segment?
kf1_HAVEHMA		EQU	08h	; High Memory Area is available
kf1_GLOBALNOTIFY	EQU	10h	; We're calling the app's notify proc.
kf1_MEMORYMOVED 	EQU	20h	; global memory was moved by gmove
;
kf1_A20ON		EQU	80h	; We have A20 on

; Kernel Flags[2]

KF2_GH_NORIP		EQU	01h	; don't rip in gdref if invalid handle
KF2_WIN_EXIT		EQU	02h	; we're past ExitKernel
KF2_APP_EXIT		EQU	04h	; we're in DOS 4C quitting an app
KF2_SYMDEB		EQU	08h	; symdeb or somesuch in installed
KF2_PTRACE		EQU	10h	; ptrace.dll is installed
KF2_DOSX		EQU	20h	; running under 286 DOS extender
KF2_WIN386CRAZINESS	EQU	40h	; i hate async notification!
KF2_TOOLHELP            EQU     80h     ; TOOLHELP.DLL callback installed

; WinFlags[0]

WF_PMODE		EQU	01h	; Windows is running in Protected Mode
WF_CPU286		EQU	02h	; Windows is running on an 80286 cpu
WF_CPU386		EQU	04h	;    "     "	"     "  " 80386 cpu
WF_CPU486		EQU	08h	; Windows is running on an 80486 cpu
WF_STANDARD		EQU	10h	; Running Windows/286
WF_ENHANCED		EQU	20h	; Running Windows/386
WF_CPU086		EQU	40h	; Windows is running on an  8086 cpu
WF_CPU186		EQU	80h	; Windows is running on an 80186 cpu

; WinFlags[1]

WF1_LARGEFRAME		EQU	01h	; Running in EMS small frame
WF1_SMALLFRAME		EQU	02h	; Running in EMS large frame
WF1_80x87		EQU	04h	; There is a co-processor present
WF1_PAGING		EQU	08h	; Paging is enabled
ifdef WOW
WF1_WINNT		EQU	40h	; Running on Windows NT WOW layer
endif

ifdef WOW
; DebugWOW
DW_DEBUG                EQU     0001h   ; 32-bit Debugger debugging wow
endif

; Note, WF_WIN286 + WF_PMODE indicates running under the 286 DOS extender

;  Flags for OpenFile

OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_NO_INHERIT	    = 0080H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

MaxFileLen      equ     128

OPENSTRUC	STRUC
opLen	db	?
opDisk	db	?
opXtra	dw	?
opDate	dw	?
opTime	dw	?
opFile	db	?
OPENSTRUC	ENDS

; GetAppCompatFlags/TDB_CompatFlags flag values

GACF_IGNORENODISCARD	EQU	0001h	; Ignore GA_NODISCARD on GlobalAlloc
GACF_HACKWINFLAGS       EQU     0400h   ; mask out new win31 flags ie. WF_PAGING
GACF_WINVER31           equ     00200000h ;Lie about windows version
HIW_GACF_WINVER31       equ     0020h
GACFE_INCREASESTACK	EQU     0040h   ; Increase the stack size for ALDUS
GACF_31VALIDMASK        EQU     0FFE484AFh       ; valid bits for 3.1+ apps
HIW_GACF_31VALIDMASK    EQU     0FFE4h
LOW_GACF_31VALIDMASK    EQU         084AFh
GACF_IGNOREFAULTS	EQU	002000000h
GACF_ALWAYSZEROINIT	EQU	000400000h ;Always do GA_ZEROINIT on GlobalAlloc (overloads GACF_INCREASESTACK)
GACF_MODULESPECIFIC     equ     000040000h ;Module-specific hack

; Look for module in Module Compatibilty section of win.ini
MCF_FIXEDSEGLOW       = 00001h  ; Win31 behaviour for FIXED segs
MCF_MODPATCH          = 00002h  ; Look for module patches in the registry
MCF_NODISCARD         = 00004h  ; Make all segments in the module not discardable
MCF_MODPATCH_X86      = 08000h  ; Apply this module patch on x86 only
MCF_MODPATCH_RISC     = 04000h  ; Apply this module patch on RISC only

ifdef	JAPAN
;
; INT 41H SIGNATURE
; Some Japanese OEM want to use interrupt vector other than 41h for
; debugger hook since this vector already used by system hardware.
; We won't disclose sources for Kernel, OEM should change vector
; number by 'patch'ing. The following macro appears below the 'INT 41H'
; instruction so that OEM can find the patch position by searching this
; signature string.
INT41SIGNATURE macro
	jmp	short @F
	db	'DEB41PATCH'
@@:
	endm
endif	;JAPAN

DebInt	macro	val
  ifnb	<val>
	mov	ax, val
  endif
	int	41h
  ifdef	JAPAN
	jmp	short @F
	db	'DEB41PATCH'
  @@:
  endif
endm


;
; Structure passed between user profile routines
;
PROINFO	struc
	lpProFile	dd	?	; Pointer to INI filename
	lpBuffer	dd	?	; Pointer to buffer containing file
	hBuffer		dw	?	; Handle of buffer
	BufferLen	dw	?	; Length of buffer
	FileHandle	dw	? 	; File handle - -1 if not open
	ProFlags	dw	?	; Open, writing etc
        wClusterSize    dw      ?       ; Bytes/cluster on current disk
	ProBuf		db	(SIZE OPENSTRUC + MaxFileLen - 1) dup(?)
PROINFO	ends

; -------------------------------------------------------
; This macro displays a string if DEBUG
;

Trace_Out MACRO String, nocrlf
  LOCAL a
IF KDEBUG
  _DATA SEGMENT PARA PUBLIC 'DATA' ;; (not jump around)
    a label byte
ifdef WOW
    db	"W16KERNEL: "
endif
    db  String
    IFB <nocrlf>
	    db	0dh, 0ah
    ENDIF
    db	0
  _DATA ENDS
	push	dataOffset a
	call    KOutDSStr
ENDIF
	ENDM

move	MACRO	reg,var
	mov	reg,var
	endm

WOWTrace MACRO	String,args
	LOCAL	String_Offset, Skip
IFDEF WOWDEBUGTRACE
	irp	arg,<args>
	move	arg
	endm

	jmps	Skip
String_Offset db	"W16KERNEL:",String,0Dh,0Ah,0
Skip:
	push	ds
	pushf
	pusha

	mov	ax,cs			; make sure string is addressable
	mov	ds,ax

	lea	si, String_Offset	; LEA to stop link whining
		
ifndef	KOutDebugStr
externFP KOutDebugStr
endif

	call	KOutDebugStr
	
	popa		
	popf
	pop	ds
ENDIF
	ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;

Debug_Out MACRO String
IF KDEBUG
	Trace_Out   <String>
	int	3
ENDIF
	ENDM

;
; Error reporting constants (from windows.h)
;
; Error option flags (set by [kernel] ErrorOptions win.ini variable)

ERO_PARAM_ERROR_BREAK	equ 0001h
ERO_BUFFER_FILL 	equ 0002h

; Debug fill constants

DBGFILL_ALLOC		equ 0fdh
DBGFILL_FREE		equ 0fbh
DBGFILL_BUFFER		equ 0f9h
DBGFILL_STACK		equ 0f7h

include winkern.inc

if ROM
include krom.inc
endif

ifndef WINDEBUG
include ikernel.inc
endif

ifdef WOW
STIRET	MACRO
	LOCAL	Dont_Do_STI
	push	ax
	pushf
	pop	ax
	test	ah, 2
	pop	ax
	jnz	SHORT Dont_Do_STI
        FSTI
Dont_Do_STI:
	FIRET
	ENDM
else
STIRET	MACRO
	LOCAL	Dont_Do_STI
if PMODE32
	push	ax
	pushf
	pop	ax
	test	ah, 2
	pop	ax
	jnz	SHORT Dont_Do_STI
        FSTI
Dont_Do_STI:
endif
	FIRET
	ENDM
endif; WOW


ife ?RIPAUX
externFP 	LogError
endif

KernelLogError  macro   flags, errcode, msg
    krDebugOut <flags>,<msg>
    push    errcode
    push    0
    push    0
    call    LogError
endm

; Load Module error return codes
; Used by LD.asm, LDHEADER.asm, etc.
LME_MEM 	= 0	; Out of memory					;
LME_FNF		= 2	; File not found
LME_LINKTASK 	= 5	; can't link to task				;
LME_LIBMDS 	= 6	; lib can't have multiple data segments		;
LME_VERS 	= 10	; Wrong windows version				;
LME_INVEXE 	= 11	; Invalid exe					;
LME_OS2 	= 12	; OS/2 app					;
LME_DOS4 	= 13	; DOS 4 app					;
LME_EXETYPE 	= 14	; unknown exe type				;
LME_RMODE 	= 15	; not a pmode windows app 			;
LME_APPMDS 	= 16	; multiple data segments in app			;
LME_EMS 	= 17	; scum app in l-frame EMS 			;
LME_PMODE 	= 18	; not an rmode windows app			;
LME_COMP	= 19	; compressed EXE file				;
LME_INVCOMP 	= 20	; invalid DLL (component) caused EXE load fail	;
LME_PE		= 21	; Windows Portable EXE app - let them load it	;
LME_MAXERR      = 32    ; for comparisons                               ;

LME_WOAWOW32    = 23    ; For wow special handling of WOA

PEMAGIC = 4550h	; 'PE'


;
; Use these macros instead of a raw "int 3" and maybe we can tell
; later what is happening when we hit one!
;

; Put there by davidw or tonyg or even earlier.  Nobody knows
; what this is.
;
INT3_ANCIENT	macro
	int	3
endm


;
; Used find out what happens when a code path is executed.
; Should be ignoreable, but call a developer to make sure.
;
INT3_TEST	macro
	int	3
endm


;
; This code path should "never" be executed.
;
INT3_NEVER	macro
	int	3
endm


;
; Something strange, but not fatal.  Should be changed to output
; a message.
;
INT3_WARN	macro
	int	3
endm


;
; This is bad, real bad.
;
INT3_FATAL	macro
	int	3
endm


;
; Break in to debugger
;
INT3_DEBUG	macro
	int	3
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kflatstb.asm ===
TITLE   KFLATSTB.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; KTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .386p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowkrn.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE


;---------------------------------------------------------------------
;
;  BOOL ThunkConnect16(LPSTR     pszDll16,
;                      LPSTR     pszDll32,
;                      HINSTANCE hInstance,
;                      DWORD     dwReason,
;                      LPVOID    lpThunkData16,
;                      LPSTR     pszThunkData32Name,
;                      WORD      hModuleCS)
;
;  Exported kernel routine: called from the DllEntryPoint()'s
;  of 16-bit dll's that depend on a 32-bit partner with which
;  they share thunks
;
;---------------------------------------------------------------------

cProc ThunkConnect16, <PUBLIC, FAR, PASCAL>, <ds,si,di>
        parmD pszDll16
        parmD pszDll32
        parmW hInstance
        parmD dwReason
        parmD lpThunkData16
        parmD pszThunkData32Name
        parmW hModuleCS



; ThunkConnect16  proc FAR PASCAL PUBLIC USES ds si di, pszDll16:DWORD,
;                                                      pszDll32:DWORD,
;                                                      hInstance:WORD,
;                                                      dwReason:DWORD,
;                                                      lpThunkData16:DWORD,
;                                                      pszThunkData32Name:DWORD,
;                                                      hModuleCS:WORD
cBegin nogen
        xor ax, ax
        ret
;ThunkConnect16 endp
cEnd nogen

;; C16ThkSL01
;
; This is the 16-bit rewriter code for orthogonal 16->32 thunks.
;
; Entry:
;   cx = offset in flat jump table
;   edx = linear address of THUNKDATA16
;   eax = cs:ip of common thunk entry point
;   bx  = NOT USED
;
; Exit:
;   This "routine" doesn't really exit. It jumps back to eax (which now
;   holds the rewritten code). When it does this, cx, di, si, bp, ds and the D
;   flag must all hold the same values they had on entry.
;
;
; This routine only runs when the 16-bit thunk entry point has been
; freshly loaded, or restored after a discard. This routine patches
; its caller code so that it jumps straight to C32ThkSL in kernel32.
;


cProc C16ThkSL01, <PUBLIC,FAR>
cBegin nogen
        ; just return
        ret
cEnd nogen

sEnd CODE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\krom.inc ===
; Kernel / ROM Windows specific include file


ROMEXTRASTACKSZ =	2048		; Extra stack space for kernel

include ..\inc\rom.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kernstub.asm ===
TITLE   KERNSTUB - Assembly stub program for KERNEL.EXE

.xlist
?DF = 1
SWAPPRO = 0

include cmacros.inc

; NOTE: This code is always assembled in real mode, so it'll run on any machine.
;
PMODE32=0

include newexe.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

createSeg   _TEXT,CODE,PARA,PUBLIC,CODE
createSeg   STACK,STACK,PARA,STACK,STACK

sBegin  STACK
        DB  128 DUP (?)
stacktop    LABEL   BYTE
sEnd    STACK

sBegin  CODE
assumes CS,CODE
assumes DS,CODE


KERNSTUB        PROC    FAR
        push    cs
        pop     ds
        mov     si,codeOFFSET stacktop
        add     si,1FFh
        and     si,not 1FFh
	cmp	cs:[si].ne_magic,NEMAGIC
	je	@F
	jmp	ksfail
@@:

	mov	ax,ds

	cli
        mov     ss,ax
        mov     sp,si
	sti

        mov     bx,ds:[si].ne_autodata      ; Get number of automatic DS
        dec     bx
        jl      ksg11                       ; Continue if no DS
        shl     bx,1
        shl     bx,1
        shl     bx,1
	.errnz	8 - SIZE new_seg
        add     bx,ds:[si].ne_segtab        ; DS:BX -> seg. tab. entry for DS
        mov     ax,ds:[si+bx].ns_sector     ; Compute paragraph address of DS
        cmp     ds:[si].ne_align,0
        jne     ksg10
        mov     ds:[si].ne_align,NSALIGN    ; in DI
ksg10:
        mov     cx,ds:[si].ne_align         ; Convert sectors to paragraphs
        sub     cx,4
        shl     ax,cl
        mov     di,cs                       ; Add to paragraph address of old
        sub     di,20h                      ; exe header
        add     di,ax
ksg11:
	push	cx
	mov	bx,word ptr cs:[si].ne_csip+2	; Get number of CS
        dec     bx
        jl      ksfail                      ; Error if no CS
        shl     bx,1
        shl     bx,1
        shl     bx,1
	.errnz	8 - SIZE new_seg
	add	bx,cs:[si].ne_segtab	    ; DS:BX -> seg. tab. entry for CS
	mov	ax,cs:[si+bx].ns_sector     ; Compute paragraph address of CS
	mov	cx,cs:[si].ne_align	    ; Convert sectors to paragraphs
        sub     cx,4
        shl     ax,cl
	pop	bx

	mov	dx,cs			    ; Add to paragraph address of old
        sub     dx,20h                      ; exe header
        add     dx,ax
        push    dx                          ; Push far address of start proc
        push    word ptr cs:[si].ne_csip
        mov     ds,di                       ; DS:0 points to automatic DS
        mov     cx,si                       ; CX = file offset of new header
        add     cx,200h
        jmp     short ksgo
	org	0A0h
ksgo:

;!!! The old CS selector should be freed up at some point!

        mov	ax, "KO"
        ret                                 ; FAR return to start proc

ksfail:
        call    ks1
        DB      'KERNSTUB: Error during boot',13,10,'$'
ks1:    pop     dx
        push    cs
        pop     ds          ; DS:DX -> error message
        mov     ah,9        ; Print error message
        int     21h
        mov     ax,4C01h    ; Terminate program, exit code = 1
        int     21h

KERNSTUB        ENDP

sEnd    CODE

END KERNSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kold.asm ===
; Kernel OLD routines, NOPs, but exist in KERNEL.DEF, so I can't kill them


.xlist
include kernel.inc
include tdb.inc
;include eems.inc
include newexe.inc
.list

if 0
sBegin  CODE
assumes cs,CODE
assumes ds,NOTHING
assumes es,NOTHING

;-----------------------------------------------------------------------;
; EMSCopy                                                               ;
;                                                                       ;
;       This routine is the continuation of ems_glock.  It is intended  ;
; to be called from the clipboard (in C) or from ems_glock              ;
;                                                                       ;
; Arguments:                                                            ;
;       SourcePID  = The EMS PID of the source banks.                   ;
;       RegSet     = EMS register set of source object                  ;
;       handle     = handle to global object                            ;
;       segaddr    = address of object                                  ;
;       EmsSavAddr = address of ems save area (TDB_EEMSSave)            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon July 20, 1987 15:10:23  -by-  Rick N. Zucker  [rickz]            ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   EMSCopy,<PUBLIC,FAR>,<di,si>
        parmW   SourcePID
        parmW   RegSet
        parmW   handle
        parmD   segaddr
        parmD   EmsSavAddr
cBegin

cEnd

sEnd CODE
endif

sBegin  CODE
assumes cs,CODE

;-----------------------------------------------------------------------;
; LimitEmsPages                                                         ;
;                                                                       ;
; Limits the total number of EMS pages a task may have.                 ;
;                                                                       ;
; Arguments:                                                            ;
;       Maximum amount of memory in Kbytes that this task wants.        ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Jun 26, 1987 01:53:15a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   LimitEmsPages,<PUBLIC,FAR>
;       parmD   amount
cBegin nogen
        xor     ax,ax

        cwd
        ret     4
cEnd nogen


;-----------------------------------------------------------------------;
; KbdReset                                                              ;
;                                                                       ;
; Keyboard driver calls here when Ctl+Alt+Del is happening.             ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   KbdRst,<PUBLIC,FAR>
cBegin nogen

        ret
cEnd nogen


;-----------------------------------------------------------------------;
; GetCurPID                                                             ;
;       A utility routine for EMS functions needed from user routines   ;
;                                                                       ;
;   function =                                                          ;
;       0 - return the current PID in ax                                ;
;       1 - copy the TDB_EEMSSave area into a new block and return      ;
;           the new block's handle in ax                                ;
;       2 - do not free the banks of the current app                    ;
;       3 - free the given PID's banks                                  ;
;       4 - do an HFree on the given handle                             ;
;       5 - get expanded memory sizes                                   ;
;       6 -                                                             ;
;       7 - do an EMS_save                                              ;
;       8 - do an EMS_restore                                           ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       None                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       see above                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ax,bx,cx,di,si,ds,es                                            ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Jul 17, 1987 11:02:23a  -by-  Rick N. Zucker [rickz]             ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   GetCurPID,<PUBLIC,FAR>,<di,si>
        parmW   function
        parmW   gcpArg
cBegin
        xor     ax,ax
        xor     dx,dx

cEnd

sEnd CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lacheck.asm ===
.xlist
include kernel.inc
include gpfix.inc
.list

externW	pLocalHeap

DataBegin

externB kernel_flags
;externW MyCSDS

DataEnd

sBegin	CODE
assumes	CS,CODE

if KDEBUG

;-----------------------------------------------------------------------;
; CheckLocalHeap							;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 01, 1980 10:58:28p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly.					;
;-----------------------------------------------------------------------;

cProc	CheckLocalHeap,<PUBLIC,NEAR>,<di,si>

	localW	nrefhandles
	localW	nhandles
	localW	nfreehandles
	localW	nusedhandles
	localW	ndishandles
	localW  pbottom

cBegin
	beg_fault_trap  clh_trap
	xor	di,di
	xor	dx,dx			; For error codes.
	mov	bx,[di].pLocalHeap
	or	bx,bx
	jnz	have_a_heap
	jmp	clh_ret
have_a_heap:

        cmp     di,[bx].hi_check
	jnz	do_heap_check
	jmp	clh_ret
do_heap_check:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_first
	test	[si].la_prev,LA_BUSY
	jnz	first_should_be_busy
	or	dx,1			; Forward links invalid.
first_should_be_busy:

check_forward_links:
	mov	ax,[si].la_next
	cmp	ax,si
	jbe	end_of_line
	mov	si,ax
	loop	check_forward_links
end_of_line:

	cmp	ax,[bx].hi_last
	jnz	forward_bad
	cmp     cx,1
	jz      forward_good
;	jcxz	forward_good
forward_bad:
	or	dx,1			; Forward links invalid.
forward_good:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_last
	test	[si].la_prev,LA_BUSY
	jnz	last_should_be_busy
	or	dx,2			; Backward links invalid.
last_should_be_busy:

check_backward_links:
	mov	ax,[si].la_prev
	and	ax,0FFFCh
	cmp	ax,si
	jae	begin_of_line
	mov	si,ax
	loop	check_backward_links
begin_of_line:

	cmp	ax,[bx].hi_first
	jnz	backward_bad
	cmp	cx,1
	jz	backward_good
;	jcxz	backward_good
backward_bad:
	or	dx,2			; Backward links invalid.
backward_good:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_first
	mov	nrefhandles,0
count_referenced_handles:
	test	[si].la_prev,LA_BUSY
	jz	no_handle
	test	[si].la_prev,LA_MOVEABLE
	jz	no_handle
	mov	di,[si].la_handle
	cmp	[di].lhe_free,LHE_FREEHANDLE
	jnz	handle_not_free
	or	dx,4			; Block points to free handle.
	jmps	no_handle
handle_not_free:
	mov	ax,si
	add	ax,SIZE LocalArena
	cmp	ax,[di].lhe_address
	jz	handle_points_back
	or	dx,8			; Block -> handle but not vice versa
	jmps	no_handle
handle_points_back:
	inc	nrefhandles
no_handle:
	mov	si,[si].la_next
	loop	count_referenced_handles

	mov	di,[bx].hi_htable
	mov	nhandles,0
	mov	ndishandles,0
	mov	nusedhandles,0
	mov	nfreehandles,0

handle_block_loop:
	or	di,di
	jz	no_more_handle_blocks
	lea	si,[di].ht_entry[0]
	mov	cx,[di].ht_count
	add	nhandles,cx

handle_entry_loop:
	jcxz	next_handle_block
	dec	cx
	cmp	[si].lhe_free,LHE_FREEHANDLE
	jnz	not_free
	inc	nfreehandles
	jmps	next_handle_entry
not_free:
	test	[si].lhe_flags,LHE_DISCARDED
	jz	not_discarded
	inc	ndishandles
	jmps	next_handle_entry
not_discarded:
	inc	nusedhandles
next_handle_entry:
	add	si,SIZE LocalHandleEntry
	jmp	handle_entry_loop
next_handle_block:
	mov	di,[si].lhe_address
	jmp	handle_block_loop

no_more_handle_blocks:

	mov	ax,nusedhandles
	cmp	ax,nrefhandles
	jz	handles_match
	or	dx,10h			; allocated handles != used handles
handles_match:
	add	ax,nfreehandles
	add	ax,ndishandles
	cmp	ax,nhandles
	jz	total_number_okay
	or	dx,20h			; total number of handles dont add up
total_number_okay:

	xor	cx,cx
	mov	si,[bx].hi_hfree
count_free:
	or	si,si
	jz	counted_free
	inc	cx
	mov	si,[si].lhe_link
	jmp	count_free
counted_free:
	cmp	cx,nfreehandles
	jz	free_add_up
 	or	dx,40h			; total # of free handles dont add up
free_add_up:

; now check the free block list

	mov	si,[bx].hi_first
	mov	si,[si].la_free_next	; Sentinals not free.
	mov	ax,[bx].hi_last
	mov	pbottom,ax

check_free_list:
	cmp	si,[si].la_free_next
	jz	check_free_list_done
	mov	ax,[si].la_next
	sub	ax,si
	cmp	ax,[si].la_size
	jnz	free_list_corrupted	; invalid block size

        cmp     [bx].hi_check,2         ; if hi_check >= 2, check free.
        jb      dont_check_free

	mov	di,si
	add	di,SIZE LocalArenaFree
	mov	cx,[si].la_next
	sub	cx,di
        mov     al,DBGFILL_FREE
	smov	es,ds
	repz	scasb
	jnz	free_list_corrupted	; free block corrupted
dont_check_free:
	mov	ax,[si].la_free_next
	cmp	ax,si
	jbe	free_list_corrupted
	mov	si,ax
	cmp	ax,pbottom
	jbe	check_free_list

free_list_corrupted:
	krDebugOut	DEB_FERROR, "Local free memory overwritten at #ES:#DI"
	or	dx,80h

	end_fault_trap

check_free_list_done:
clh_ret:
	mov	ax,dx
cEnd
clh_trap:
	fault_fix_stack
	mov     dx, 80h
	jmp     clh_ret

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kthunks.asm ===
TITLE   KTHUNKS.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; KTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .286p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowkrn.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE


; Internal WOW Thunks

    DKernelThunk WowInitTask        ; Task Creation
    DKernelThunk WowKillTask,0      ; Task Destruction
    DKernelThunk WOWFreeResource
    DKernelThunk WowFileRead
    DKernelThunk WowFileWrite
    DKernelThunk WowFileLSeek
    DKernelThunk WowKernelTrace
    DKernelThunk WOWOutputDebugString
    DKernelThunk WowCursorIconOp
    DKernelThunk WowFailedExec,0
    DKernelThunk WowCloseComPort
    DKernelThunk WowFileOpen
    DKernelThunk WowFileClose
    DKernelThunk WowIsKnownDLL
    DKernelThunk WowDdeFreeHandle
    DKernelThunk WowFileGetAttributes
    DKernelThunk WowFileGetDateTime
    DKernelThunk WowFileLock
    DKernelThunk WowFindFirst
    DKernelThunk WowFindNext
    DKernelThunk WowSetDefaultDrive
    DKernelThunk WowGetCurrentDirectory
    DKernelThunk WowSetCurrentDirectory
    DKernelThunk WowWaitForMsgAndEvent
    DKernelThunk WowMsgBox
    DKernelThunk WowGetCurrentDate,0
    DKernelThunk WowDeviceIOCTL
    DKernelThunk WowFileSetAttributes
    DKernelThunk WowFileSetDateTime
    DKernelThunk WowFileCreate
    DKernelThunk WowDosWowInit
    DKernelThunk WowCheckUserGdi
    DKernelThunk WowPartyByNumber
    DKernelThunk GetShortPathName
    DKernelThunk FindAndReleaseDib
    DKernelThunk WowReserveHtask
    DKernelThunk WOWLFNEntry, %(size WOWLFNFRAMEPTR16)
    DKernelThunk WowShutdownTimer
    DKernelThunk WowTrimWorkingSet, 0
    DKernelThunk SetAppCompatFlags
ifdef FE_SB ;Add GetSystemDefaultLangID()
    DKernelThunk GetSystemDefaultLangID,0
endif
    DKernelThunk TermsrvGetWindowsDir,%(size TERMSRVGETWINDIR16)
;-----------------------------------------------------------------------;
; WOWGetNexVdmCommand
;
; Returns the Next App Name for the Requested 32 Bit Exec
;
; Arguments:
;   FARP lpReturnedString = LPSTR points to the buffer that receives the character strin
;   int  nSize = Size of the lpReturnedString buffer
;
; Returns:
;   DX:AX = TRUE Success, sting is present
;   DX:AX = NULL, buffer size was not large enough
;
; Error Returns:
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Sun Jan 19, 1992 11:00:06a   -by-  Matthew Felton [MattFe]
;   New API for Multi Tasking Exec by 32 bit app of 16 bit app
;-----------------------------------------------------------------------;

    DKernelThunk WowGetNextVdmCommand

;-----------------------------------------------------------------------;
; WowRegisterShellWindowHandle
;
; Tells WOW the Windows Handle To Post Messages to For Execing 16 bit
; apps.   (see WOWEXEC and WK32NotifyThread)
;
; Arguments:
;   hwndShell = Shell Window Handle
;
; Returns:
;   nothing
;
; Error Returns:
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  thu mar 19, 1992 11:11:06a   -by-  Matthew Felton [MattFe]
;   New API for Multi Tasking Exec by 32 bit app of 16 bit app
;-----------------------------------------------------------------------;

    DKernelThunk WowRegisterShellWindowHandle

;-----------------------------------------------------------------------;
; WOWLoadModule32
;
; Loads a module or creates a new instance of an existing module.
;
; Arguments:
;   FARP p   = name of module or handle of existing module
;   FARP lpPBlock = Parameter Block to pass to CreateTask
;   HWND hwndWinOldAp = hwnd to send WM_USER to when app exits.
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32 LoadModule
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWLoadModule

;-----------------------------------------------------------------------;
; WOWSetIdleHook
;
; Calls WK32SetIdleHook For 16 Bit App
;
; Arguments:
;   none
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 01-Dec-1992 16:30:00  -by-  Russ Blake  [russbl}
;-----------------------------------------------------------------------;

    DKernelThunk WOWSetIdleHook,0

;-----------------------------------------------------------------------;
; WOWQueryPerformanceCounter
;
; Calls NTQueryPerformanceCounter For 16 Bit App
;
; Arguments:
;   FARP p   = name of module or handle of existing module
;   FARP lpPBlock = Parameter Block to pass to CreateTask
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWQueryPerformanceCounter

;-----------------------------------------------------------------------;
; WOWGetFastAddress
;
; Calls into WOW32 to determine the address of WOWBopEntry on the 32-bit side.
;
; Arguments:
;   none
;
; Returns:
;   AX = LOWORD of address
;   DX = HIWORD of address
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWGetFastAddress, 0

    DKernelThunk WOWGetFastCbRetAddress, 0
    DKernelThunk WOWGetTableOffsets

;-----------------------------------------------------------------------;
; WOWKillRemoteTask
;
; Tells the 32-bit thread to die and save its context so that later remote
; threads can be created to use this context.
;
; Arguments:
;   none
;
; Returns:
;   Nothing
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWKillRemoteTask

;-----------------------------------------------------------------------;
; WOWNotifyWOW32
;
; Tells the 32-bit world some cool stuff about the 16-bit world.
;
; Arguments:
;   none
;
; Returns:
;   Nothing
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWNotifyWOW32

    DKernelThunk KSYSERRORBOX

    DKernelThunk WOWDelFile
    DKernelThunk VirtualAlloc
    DKernelThunk VirtualFree
    DKernelThunk GlobalMemoryStatus
    DKernelThunk GetDriveType
    DKernelThunk LoadLibraryEx32W
    DKernelThunk FreeLibrary32W
    DKernelThunk GetProcAddress32W
    DKernelThunk GetVDMPointer32W
    DKernelThunk ICallProc32W,0

; 3.1 and earlier kernel APIs which are thunked (not many!)

    DKernelThunk Yield,0
    DKernelThunk OldYield,0
    KernelThunk  GetProfileString
    KernelThunk  GetProfileInt
    KernelThunk  GetPrivateProfileInt
    KernelThunk  GetPrivateProfileString
    KernelThunk  WritePrivateProfileString
    KernelThunk  WriteProfileString


; These Thunks Shouldn't be Called - They are Thunked to Trap Them.

    DKernelThunk PostEvent
    DKernelThunk WaitEvent
    DKernelThunk SetPriority
    DKernelThunk DirectedYield
    DKernelThunk LockCurrentTask
    DKernelThunk WriteOutProfiles,0

;
; ExitKernel is small wrapper which takes exit status in AX and pushes it
; for the convenience of ExitKernelThunk, a regular WOW stack-based thunk.
; The FUN_ aliasing below allows us to generate the thunk with the name
; ExitKernelThunk while using the arguments and thunk table entry already
; set up for ExitKernel.
;

    FUN_ExitKernelThunk equ FUN_ExitKernel
    DKernelThunk ExitKernelThunk, %(size EXITKERNEL16)

; FatalExitC is called by FatalExit and takes the same one word parameter
; indicating fatalexit code.

    FUN_FatalExitC equ FUN_FatalExit
    DKernelThunk FatalExitC, %(size FATALEXIT16)

; Thunk for WowGetModuleFileName reuses the GetModuleFileName slot.

    FUN_WowGetModuleFileName equ FUN_GetModuleFileName
    DKernelThunk WowGetModuleFileName, %(size GetModuleFileName16)

; Thunk for WowGetModuleHandle reuses the GetModuleHandle slot.

    FUN_WowGetModuleHandle equ FUN_GetModuleHandle
    DKernelThunk WowGetModuleHandle


;-----------------------------------------------------------------------;
; CallProc32W
;
; Generic Thunk Routine
; Transitions to 32 bits and calls specified routine
;
; Arguments:
;   Variable number of Parameters for function they want to call
;   up to 32.
;
;   DWORD fAddressConvert - Bit Field, for 16:16 address Convertion
;                           eg (bit 1 means convert parameter 1 from 16:16
;                               to flat address before calling routine)
;   DWORD cParams         - Number of DWORD parameters (so we can clean the stack
;                           and so 32 bit land know how many params to copy to
;                           32 bit stack before call.
;   DWORD lpProcAddress   - 32 bit native address to call (use LoadLibraryEx32W
;                           and GetProcAddress32W to figure this out).
;
; Returns:
;   What ever the API returned on 32 bit side in AX:DX
;
; Error Returns:
;   AX = 0, more than 32 parameters.
;
; Registers Preserved:
; Registers Destroyed:
;
; History:
;  Mon 12-Mar-1993 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   CallProc32W,<PUBLIC,FAR>
;       PARMD cParams
cBegin nogen
        push    bp
        mov     bp,sp

        ; Disable CDECL source bit
        and     word ptr [bp+8],NOT CPEX32_SOURCE_CDECL

        cCall   ICallProc32W

;   Clean Up Callers Stack to remove Parameters Passed

        mov  bx, WORD PTR [bp+6]    ; get the # of DWORDS this API took
        shl  bx, 2          ; convert it to offset into aRets table
        add  bx, codeoffset aRets
        pop  bp
        jmp  bx             ; dispatch to the right RETF n

CRETENTRIES equ 021h
; generate the retf n codetable

    bytes = 0
    REPT CRETENTRIES
        IFE  bytes
aRets:
        ENDIF
        retf bytes + 4*3    ; 4*3 - Always
        nop
    bytes = bytes + 4
    ENDM

cEnd

    public _CallProcEx32W

_CallProcEx32W PROC FAR
        push    bp
        mov     bp,sp

        ; Enable CDECL source bit
        or      word ptr [bp+8],CPEX32_SOURCE_CDECL

        cCall   ICallProc32W

        pop     bp
        ret
_CallProcEx32W ENDP

    ; get the address of the array containing the selector bases
    DKernelThunk WOWGetFlatAddressArray, 0


assumes CS,NOTHING
sEnd    CODE

;
; All the thunks above are in Kernel's primary code segment (IGROUP/TEXT),
; the ones below are in the second code segment, NRESTEXT.
;

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
assumes CS,_NRESTEXT
assumes DS,NOTHING
assumes ES,NOTHING


;
; New-for-NT5 thunks for Win95 compatibility.  Many of these are unimplemented.
;

    DKernelThunk GetVersionEx
    DKernelThunk GetPrivateProfileSectionNames
    DKernelThunk CreateDirectory
    DKernelThunk RemoveDirectory
    DKernelThunk DeleteFile
    DKernelThunk SetLastError
    DKernelThunk GetLastError,0
    DKernelThunk Local32Init
    DKernelThunk Local32Alloc
    DKernelThunk Local32ReAlloc
    DKernelThunk Local32Free
    DKernelThunk Local32Translate
    DKernelThunk Local32Size
    DKernelThunk Local32ValidHandle
    KernelThunk  RegEnumKey32
    KernelThunk  RegOpenKey32
    KernelThunk  RegCreateKey32
    KernelThunk  RegDeleteKey32
    DKernelThunk RegCloseKey32
    KernelThunk  RegSetValue32
    KernelThunk  RegDeleteValue32
    KernelThunk  RegEnumValue32
    KernelThunk  RegQueryValue32
    KernelThunk  RegQueryValueEx32
    KernelThunk  RegSetValueEx32
    KernelThunk  RegLoadKey32
    KernelThunk  RegUnloadKey32
    KernelThunk  RegSaveKey32
    DKernelThunk RegFlushKey32
    DKernelThunk ComputeObjectOwner
    DKernelThunk Local32GetSel
    DKernelThunk InvalidateNLSCache,0
    DKernelThunk GetProductName
    DKernelThunk IsSafeMode,0
    DKernelThunk OpenFileEx
    DKernelThunk FastAndDirtyGlobalFix
    DKernelThunk WritePrivateProfileStruct
    DKernelThunk GetPrivateProfileStruct
    DKernelThunk GetCurrentDirectory
    DKernelThunk SetCurrentDirectory
    DKernelThunk FindFirstFile
    DKernelThunk FindNextFile
    DKernelThunk FindClose
    DKernelThunk WritePrivateProfileSection
    DKernelThunk WriteProfileSection
    DKernelThunk GetPrivateProfileSection
    DKernelThunk GetProfileSection
    DKernelThunk GetFileAttributes
    DKernelThunk SetFileAttributes
    DKernelThunk GetDiskFreeSpace
    DKernelThunk IsPEFormat
    DKernelThunk FileTimeToLocalFileTime
    DKernelThunk UniToAnsi
    DKernelThunk CreateThread
    DKernelThunk LeaveEnterWin16Lock,0
    DKernelThunk GetWin16Lock,0
    DKernelThunk LoadLibrary32
    DKernelThunk GetProcAddress32
    DKernelThunk CreateWin32Event
    DKernelThunk SetWin32Event
    DKernelThunk ResetWin32Event
    DKernelThunk WaitForSingleObject
    DKernelThunk WaitForMultipleObjects
    DKernelThunk GetCurrentThreadID,0
    DKernelThunk GetThreadQueue
    DKernelThunk SetThreadQueue
    DKernelThunk NukeProcess
    DKernelThunk ExitProcess
    DKernelThunk GetCurrentProcessID,0
    DKernelThunk MapHINSTLS,0
    DKernelThunk MapHINSTSL,0
    DKernelThunk CloseWin32Handle
    DKernelThunk LoadSystemLibrary32
    DKernelThunk FreeLibrary32
    DKernelThunk GetModuleFilename32
    DKernelThunk GetModuleHandle32
    DKernelThunk RegisterServiceProcess
    DKernelThunk InitCB
    DKernelThunk GetStdCBLS
    DKernelThunk GetStdCBSL
    DKernelThunk GetExistingStdCBLS
    DKernelThunk GetExistingStdCBSL
    DKernelThunk GetFlexCBSL
    DKernelThunk GetStdCBLSEx
    DKernelThunk GetStdCBSLEx
    DKernelThunk Callback2
    DKernelThunk Callback4
    DKernelThunk Callback6
    DKernelThunk Callback8
    DKernelThunk Callback10
    DKernelThunk Callback12
    DKernelThunk Callback14
    DKernelThunk Callback16
    DKernelThunk Callback18
    DKernelThunk Callback20
    DKernelThunk Callback22
    DKernelThunk Callback24
    DKernelThunk Callback26
    DKernelThunk Callback28
    DKernelThunk Callback30
    DKernelThunk Callback32
    DKernelThunk Callback34
    DKernelThunk Callback36
    DKernelThunk Callback38
    DKernelThunk Callback40
    DKernelThunk Callback42
    DKernelThunk Callback44
    DKernelThunk Callback46
    DKernelThunk Callback48
    DKernelThunk Callback50
    DKernelThunk Callback52
    DKernelThunk Callback54
    DKernelThunk Callback56
    DKernelThunk Callback58
    DKernelThunk Callback60
    DKernelThunk Callback62
    DKernelThunk Callback64
    DKernelThunk WowPassEnvironment
    DKernelThunk WowSyncTask
_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lalloc.asm ===
TITLE	LALLOC - Local memory allocator

include kernel.inc

.errnz	 la_prev		; This code assumes la_prev = 0

externW pLocalHeap

DataBegin

externB Kernel_flags

DataEnd

sBegin	CODE
assumes CS,CODE

externNP lalign 	; LINTERF.ASM
externNP lnotify	; LINTERF.ASM
externNP lcompact	; LCOMPACT.ASM

if KDEBUG
externNP CheckLAllocBreak   ; LINTERF.ASM
endif

;-----------------------------------------------------------------------;
; ljoin									;
; 									;
; Join two blocks together, by removing one.				;
; 									;
; Arguments:								;
;	BX = address of block to remove					;
;	SI = address of block that points to the one to remove		;
; 									;
; Returns:								;
;	BX = address of block following [SI], after join		;
;	Updated hi_count field in the local arena info structure	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon March 9, 1987  -by-  Bob Gunderson (bobgu)			;
; Added free list stuff.						;
;									;
;  Tue Oct 14, 1986 05:20:56p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ljoin,<PUBLIC,NEAR>
cBegin nogen

    IncLocalStat    ls_ljoin

	push	di
	dec	[di].hi_count		; remove free block from arena
	mov	di,bx			; save ptr to block removing
	mov	bx,[bx].la_next		; Get address of block after
	and	[bx].la_prev,LA_ALIGN	; one we are removing.
	or	[bx].la_prev,si		; Change it's back link
	mov	[si].la_next,bx		; and change the forward link

; If it is free, remove the block at [DI] from the free list

	test	[di].la_prev,LA_BUSY
	jnz	join1
	xchg	bx,di
	call	lfreedelete		; delete from free list
	xchg	bx,di
join1:

; if the block at [SI] is free, set its new larger free block
; size.  If not free, then block at [DI] is about to become part
; of the previous busy block.

	test	[si].la_prev,LA_BUSY	; is it busy?
	jnz	joinexit		; yes

	push	ax
	mov	ax,bx
	sub	ax,si			; length of new free block
	mov	[si].la_size,ax
	pop	ax

if KDEBUG

; Fill new free block with DBGFILL_ALLOC

	xchg	si,bx
	call	lfillCC
	xchg	si,bx
endif

joinexit:
	pop	di
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lrepsetup                                                             ;
; 									;
; Sets up for a block store or move of words.				;
; 									;
; Arguments:								;
;	CX = #bytes							;
; 									;
; Returns:								;
;	CX = #words							;
;	ES = DS								;
;	DF = 0								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 05:23:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lrepsetup,<PUBLIC,NEAR>
cBegin nogen
	shr	cx,1
	push	ds
	pop	es
	cld
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lzero									;
; 									;
; Fills a block with zeros.						;
; 									;
; Arguments:								;
;	BX = address of last word +1 to zero				;
;	CX = address of first word to zero				;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,ES								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 05:25:30p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lzero,<PUBLIC,NEAR>
cBegin nogen
	push	di
	mov	di,cx		; DI = destination
	sub	cx,bx		; CX = - #bytes
	jae	zero1		; Do nothing if BX less than or equal to CX
	push	ax
	neg	cx
	xor	ax,ax
	call	lrepsetup	; Setup for stosw
	rep	stosw		; Zero it out
	pop	ax
zero1:
	pop	di
	ret
cEnd nogen


if KDEBUG
;-----------------------------------------------------------------------;
; lallocfill                                                            ;
; 									;
; Fills a block with DBGFILL_ALLOC                                      ;
; 									;
; Arguments:								;
;	BX = address of last word +1 to zero				;
;	CX = address of first word to zero				;
; 									;
; Registers Destroyed:							;
;	CX,ES								;
; 									;
;-----------------------------------------------------------------------;

cProc   lallocfill,<PUBLIC,NEAR>
cBegin  nogen
	push	di
	mov	di,cx		; DI = destination
	sub	cx,bx		; CX = - #bytes
        jae     @F              ; Do nothing if BX less than or equal to CX
	push	ax
	neg	cx
        mov     ax,(DBGFILL_ALLOC or (DBGFILL_ALLOC shl 8))
	call	lrepsetup	; Setup for stosw
	rep	stosw		; Zero it out
	pop	ax
@@:
	pop	di
	ret
cEnd    nogen

endif   ;KDEBUG

;-----------------------------------------------------------------------;
; lalloc								;
; 									;
; Actually allocates a local object.  Called from within the local	;
; memory manager's critical section.					;
; 									;
; Arguments:								;
;	AX = allocations flags						;
;	BX = #bytes							;
;	DI = address of local arena information structure		;
; 									;
; Returns:								;
;	AX = data address of block allocated or NULL			;
;	DX = allocation flags or size of largest free block		;
;	     if AX = 0							;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon March 9, 1986  -by- Bob Gunderson (bobgu)			;
; Changed the search algorithm to use the free list and added calls	;
; to add/remove blocks from the free list				;
;									;
;  Tue Oct 14, 1986 05:27:40p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lalloc,<PUBLIC,NEAR>
cBegin nogen

if KDEBUG
        call    CheckLAllocBreak
        jnc     @F
        xor     ax,ax
        ret
@@:
endif

	push	si
	push	ax
	push	bx
	test	al,LA_MOVEABLE		; Moveable?
;	jnz	scanbwd 		; Yes, search backwards
	jz	@F
	jmp	scanbwd
@@:
    IncLocalStat    ls_falloc
	add	bx,la_fixedsize		; Room for fixed header
	call	lalign			; Get requested size in DX
	mov	bx,[di].hi_first	; No, start with first entry

; use free list to find a block to allocate
afwdloop:
	mov	ax,[bx].la_free_next	; get next free block
	cmp	ax,bx			; are we at end of arena ?
	jz	afwdcmp 		; yes try to compact....

    IncLocalStat    ls_fexamine
	mov	bx,ax
	cmp	dx,[bx].la_size 	; is it big enough?
	ja	afwdloop		; no, loop for next

; Here when we have a block big enough.
;   BX = address of block
;   DX = requested size, including fixed header

afwdfound:

if KDEBUG

; verify the block is filled with DBGFILL_FREE

	call	lcheckCC
	jz	afwdfound1		; all OK
        kerror  ERR_LMEM,<LocalAlloc: Local free memory overwritten>
afwdfound1:

endif

    IncLocalStat    ls_ffound
	mov	ax,la_fixedsize
	mov	cx,[bx].la_next 	; mov	cx,[bx].la_next
	sub	cx,LA_MINBLOCKSIZE	; CX = as low as we will go for free
	mov	si,bx			; Calculate address of new block
	add	si,dx			; (current block + requested size)
	cmp	si,cx			; Is it past the current next block
;;;;;;; jae	aexit1			; yes, use the whole block
	jb	afwdfound2
	jmp	aexit1
afwdfound2:

; Here with two blocks.
;   BX = address of existing block
;   SI = address of new block to add to arena as free space

    IncLocalStat    ls_ffoundne
	push	bx
	jmp	aexit


afwdcmp:
    IncLocalStat    ls_fcompact
	call	lcompact		; End of arena.	 Try compacting.
	cmp	ax,dx			; Room for requested size?
	jae	afwdfound		; Yes, exit search loop
afail:					; No, fail.
	push	ax			; Remember size of largest free block
	xor	bx,bx
	.errnz	LN_OUTOFMEM		; Notify client procedure
	xchg	ax,bx			; BX = size of largest free block
	mov	cx,dx			; CX = size we are looking for
	call	lnotify
	pop	dx			; DX = size of largest free block
	pop	bx			; BX = requested size
	pop	ax			; AX = flags
	pop	si			; Restore SI
;	jnz	lalloc			; Try again if notify procedure said to
	jz	@F
	jmp	lalloc
@@:
    IncLocalStat    ls_fail
	xor	ax,ax			; O.W. return zero, with Z flag set
	ret


scanbwd:
    IncLocalStat    ls_malloc
	add	bx,SIZE LocalArena	; Room for moveable header
	call	lalign			; Get requested size in DX
	mov	bx,[di].hi_last

; use free chain to find a block to aloocate

abwdloop:
    IncLocalStat    ls_mexamine
	mov	ax,[bx].la_free_prev	; previous free block
	cmp	ax,bx			; are we at beginning of arena ?
	jz	abwdcmp 		; yes try to compact....

	mov	bx,ax
	cmp	dx,[bx].la_size 	; Room for requested size?
	ja	abwdloop		; no, loop to previous free block
	jmps	abwdfound		; yes, alloocate the memory

; Beginning of arena.  Try compacting.	If that fails then too bad

abwdcmp:
    IncLocalStat    ls_mcompact
	call	lcompact
	cmp	ax,dx			; Room for requested size?
	jb	afail			; No, fail
	mov	si,ax			; Yes, get free size in SI

abwdfound:

if KDEBUG

; verify the block is filled with DBGFILL_FREE

	call	lcheckCC
	jz	abwdfound1		; all OK
        kerror  ERR_LMEM,<LocalAlloc: Local free memory overwritten>
abwdfound1:
endif

    IncLocalStat    ls_mfound
	mov	ax,SIZE LocalArena
	mov	si,[bx].la_size 	; size of block found
	sub	si,dx			; SI = size of free block = total size
					; less requested size (includes header)
	mov	cx,si			; save what's left over
	add	si,bx			; SI = address of new block
	cmp	cx,LA_MINBLOCKSIZE	; enough room for another?
	jb	aexit1			; no, use entire block
	push	si

    IncLocalStat    ls_mfoundne

; Here with two blocks, in following order
;   BX = address of existing free block to make smaller
;   SI = address of new block to add to arena as busy
;   CX = address of block after new block

aexit:
	mov	cx,si
	xchg	[bx].la_next,cx
	mov	[si].la_prev,bx
	mov	[si].la_next,cx

; Here with allocated block
;   BX = address of found block
;   SI = address of new block after found block
;   CX = address of block after new block

	xchg	si,cx			; SI = block after new block
	and	[si].la_prev,LA_ALIGN	; CX = new block
	or	[si].la_prev,cx		; Point to new block
	inc	[di].hi_count		; We added an arena entry
	mov	si,bx			; SI = previous free block
	mov	bx,cx			; BX = new block after found block
	call	lfreeadd		; add this new block to free list
	sub	bx,si
	mov	[si].la_size,bx 	; set new free block size
	pop	bx			; BX = block we are allocating

aexit1:
	call	lfreedelete		; remove this block from free list
	add	ax,bx
	or	byte ptr [bx].la_prev,LA_BUSY	; Mark block as busy
	pop	dx			; Flush requested size
	pop	dx			; Restore flags
if KDEBUG
        test    dl,LA_ZEROINIT
        jnz     @F
        mov     cx,ax
        mov     bx,[bx].la_next
        call    lallocfill
        jmp     short aexit2
@@:
endif
	test	dl,LA_ZEROINIT		; Want it zeroed?
	jz	aexit2			; No, all done
	mov	cx,ax			; Yes, CX = 1st word to zero
	mov	bx,[bx].la_next		; BX = last word+1 to zero
	call	lzero			; Zero them
aexit2:
	pop	si
	or	ax,ax			; Return AX points to client portion
	ret				; of block allocated or zero
cEnd nogen


;-----------------------------------------------------------------------;
; lfree                                                                 ;
; 									;
; Marks a block as free, coalescing it with any free blocks before	;
; or after it.								;
; 									;
; Arguments:								;
;	BX = block to mark as free.					;
;	DI = address of local arena information structure		;
; 									;
; Returns:								;
;	SI = 0 if freed a fixed block.  				;
;	SI = handle table entry, for moveable blocks.			;
;	ZF =1 if SI = 0							;
;	Updated hi_count field in local arena information structure	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
;									;
;  Mon March 9, 1987  -by- Bob Gunderson (bobgu)			;
; Freed blocks are placed back on the free list 			;
;									;
;  Tue Oct 14, 1986 05:31:52p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfree,<PUBLIC,NEAR>
cBegin nogen
	mov	si,bx
	or	si,si
	jz	free4
	push	dx

	push	[bx].la_handle		; push possible handle

; Add block to free list

	push	si
	xor	si,si
	call	lfreeadd		; add this block to free list
	pop	si

; Clear any existing LA_BUSY and LA_MOVEABLE bits

	mov	dx,LA_BUSY + LA_MOVEABLE
	and	dx,[bx].la_prev
	xor	[bx].la_prev,dx
	and	dl,LA_MOVEABLE		; Moveable?
	pop	dx			; restore handle
	jnz	free1			; Yes, return handle in DX
	xor	dx,dx			; No, return 0 in DX
free1:
	mov	si,[bx].la_next		; SI = next block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	free2			; No, continue
	xchg	bx,si
	call	ljoin			; Yes, coelesce with block in BX
	mov	bx,si
free2:
	mov	si,[bx].la_prev		; SI = previous block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	free3			; No, continue
	call	ljoin			; Yes, coelesce with block in BX
free3:
	mov	si,dx			; Return 0 or handle in BX
	pop	dx			; restore DX
free4:
	or	si,si			; Set Z flag if SI = zero
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfreeadd								;
;									;
; Links a block onto the free block chain. This routine assumes that	;
; the block to add already has the la_next and la_prev fields set	;
; to their proper values.  An extended free block header is written	;
; into the block.							;
;									;
; Arguments:								;
;	BX = Address of block to add to free list			;
;	SI = 0 to search for insertion point, else contins the address	;
;	       of the previous free block.				;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfreeadd,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	di
	push	ax
	push	cx

	or	si,si			; need to search for insertion point?
	jnz	lfa1			; no

; We first need to find the previous free block so that we can insert this
; block into the proper place.

	mov	si,ds:pLocalHeap	; get local arena info block address

if KDEBUG

; Range check the insertion point

	cmp	bx,[si].hi_first
	jb	lfadie
	cmp	bx,[si].hi_last
	jb	lfaok
lfadie:
	kerror	ERR_LMEM,<lfreeadd : Invalid local heap>
lfaok:
endif

	mov	si,[si].hi_first    ; get first block address (free list header)
lfaloop:
	mov	ax,[si].la_free_next ; get address of next free block
	cmp	bx,ax		    ; will next block be past new block?
	jb	lfa1		    ; yes, DI contains block to insert AFTER
	mov	si,ax
	jmp	lfaloop 	    ; loop on next block

; At this point, BX = block to insert, SI = block to insert after

lfa1:
	mov	di,[si].la_free_next	; get next free block
	mov	[bx].la_free_next,di	;
	mov	[si].la_free_next,bx	; set new next block

	mov	[bx].la_free_prev,si	; set new previous block
	mov	[di].la_free_prev,bx	; ditto

	mov	ax,[bx].la_next 	; next block (not necessarily free)
	sub	ax,bx
	mov	[bx].la_size,ax 	; set the size of this block

if KDEBUG

; now fill the new free block with DBGFILL_ALLOC

	call	lfillCC
endif

	pop	cx
	pop	ax
	pop	di
	pop	si
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfreedelete								;
;									;
; Removes a specified block from the free list.  This routine assums	;
; that the specified block is indeed on the free list			;
;									;
; Arguments:								;
;	BX = Address of block to remove from the free list		;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfreedelete,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	si

	mov	di,[bx].la_free_prev
	mov	si,[bx].la_free_next

	mov	[di].la_free_next,si
	mov	[si].la_free_prev,di

	pop	si
	pop	di
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfillCC								;
;									;
; Fills all the bytes in the specified block with DBGFILL_FREE          ;
;									;
; Arguments:								;
;	BX = Address of block to fill					;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

if KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfillCC,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	cx
	push	ax

; if heap free checking is off, don't fill the block.

	mov	di,pLocalHeap
        cmp     [di].hi_check,2         ; 2 -> checkfree
        jb      fillexit

	lea	di,[bx].la_freefixedsize
	mov	cx,[bx].la_next
	cmp	cx,bx			    ; marker block ?
	jz	fillexit
	sub	cx,di
        mov     al,DBGFILL_FREE
	push	ds
	pop	es
	cld
	rep	stosb

fillexit:
	pop	ax
	pop	cx
	pop	di
	ret
cEnd nogen

endif


;-----------------------------------------------------------------------;
; lcheckCC								;
;									;
; checks all bytes in the specified block for the value DBGFILL_FREE    ;
;									;
; Arguments:								;
;	BX = Address of block to check					;
;									;
; Returns:								;
;	ZF = 0 if block does not contain all 0CCh values, else ZF = 1	;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

if KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc	lcheckCC,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	cx
	push	ax

; if heap checking is off, don't check the block

	mov	si,pLocalHeap
        xor     cx,cx           ; cx == 0 for ok return
        cmp     [si].hi_check,2
        jb      testexit

	lea	si,[bx].la_freefixedsize
	mov	cx,[bx].la_next
        cmp     cx,bx           ; sentinel block ?
        jz      testexit2       ; yes: return ZF = 1 for success
	sub	cx,si
	push	ds
	pop	es
	cld
testloop:
	lodsb
        cmp     al,DBGFILL_FREE
	loope	testloop

testexit:
	or	cx,cx		; ZF = 1 if ok, ZF = 0 if failed test
testexit2:
	pop	ax
	pop	cx
	pop	si
	ret
cEnd nogen

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\layer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

ifdef WINDEBUG
DEBUG	equ <1>
endif

PMODE	equ <1>

include gpfix.inc
include klayer.inc

createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
createSeg _GPFIX,GPFIX,WORD,PUBLIC,DATA,DGROUP

.list

LAYER_START

include kernel.api

LAYER_END

LAYER_EXPAND	TEXT
LAYER_EXPAND	NRESTEXT
LAYER_EXPAND	MISCTEXT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lcompact.asm ===
TITLE	LCOMPACT - Local memory allocator, compaction procedures

include kernel.inc

errnz	la_prev			; This code assumes la_prev = 0

sBegin	CODE
assumes CS,CODE

; These are all the external subroutines needed by this source file.
;
externNP    <henum>		; HANDLE.ASM
externNP    <ljoin,lfree,lfreeadd,lfreedelete>	; LALLOC.ASM
externNP    <lnotify,lalign>	; LINTERF.ASM
externFP    <GlobalHandle, GlobalRealloc>
;externFP    <LocalHeapSize>

; These are all of the internal subroutines defined in this source file.
;
	PUBLIC	lmove, lbestfit, lcompact

;-----------------------------------------------------------------------;
; lmove                                                                 ;
; 									;
; Moves a moveable block into the top part of a free block.		;
; 									;
; Arguments:								;
;	BX = address of free block					;
;	SI = address of busy block to move				;
; 									;
; Returns:								;
;	SI = old busy address (new free block)				;
;	DI = new busy address						;
;	BX = old free block						;
;	AX = block after old free block					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 06:22:28p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lmove,<PUBLIC,NEAR>
cBegin nogen
	mov	cx,[si].la_next	    ; Calculate #bytes in busy block
	sub	cx,si

	add	si,cx		    ; SI = bottom of busy block
	mov	di,[bx].la_next	    ; DI = bottom of free block
	cmp	si,bx		    ; Are the busy and free blocks adjacent?
	je	move1		    ; Yes, always room for free header
	mov	ax,di		    ; Calculate the new busy block location
	sub	ax,cx
	sub	ax,LA_MINBLOCKSIZE  ; See if there is room for two blocks
	cmp	ax,bx		    ; in this free block
	jae	move1		    ; Yes, continue
	mov	ax,di		    ; No, AX = block after free block
	mov	di,bx		    ; New busy block will replace free block
	add	di,cx		    ; with some extra slop at end
	jmp	short move2
move1:
	mov	ax,di		    ; AX = block after free block
move2:
	dec	si		    ; Predecrement for moving backwards
	dec	si		    ; on bogus Intel hardware
	dec	di
	dec	di
	shr	cx,1		    ; Move words
	push	ds		    ; Initialize for rep movsw
	pop	es
	std			    ; Move down as may overlap
	rep	movsw
	cld			    ; Don't hose careless ones
	inc	si		    ; More bogosity.
	inc	si		    ; SI = old busy address (new free block)
	inc	di		    ; DI = new busy address
	inc	di		    ; BX = old free block
movex:				    ; AX = block after old free block
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; lbestfit                                                              ;
; 									;
; Searches backwards for the largest moveable block that will fit	;
; in the passed free block.						;
;									;
; Arguments:								;
;	BX = free block							;
;	CX = #arena entries left to examine				;
; 									;
; Returns:								;
;	SI = address of moveable block or zero				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 06:25:46p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	lbestfit,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	cx
	push	dx
	xor	si,si		    ; Have not found anything yet
	push	si
	mov	dx,[bx].la_next	    ; Compute max size to look for
	sub	dx,bx
bfloop:
	mov	ax,[bx].la_prev	    ; Get previous block pointer
	test	al,LA_BUSY	    ; Is this block busy?
	jz	bfnext		    ; No, continue
	test	al,LA_MOVEABLE	    ; Is this block moveable?
	jz	bfnext		    ; No, continue
	mov	si,[bx].la_handle   ; Yes, is this block locked?
	cmp	[si].lhe_count,0
	jne	bfnext		    ; No, continue
	mov	ax,[bx].la_next	    ; Yes, compute size of this moveable block
	sub	ax,bx		    ; Compare to size of free block
	cmp	ax,dx		    ; Is it bigger?
	ja	bf2		    ; Yes, continue
	pop	si		    ; No, Recover largest block so far
	or	si,si		    ; First time?
	jz	bf0		    ; Yes, special case
	add	ax,si		    ; No, is this block better than
	cmp	ax,[si].la_next	    ; ...the best so far?
	jbe	bf1		    ; No, continue
bf0:	mov	si,bx		    ; Yes, remember biggest block
bf1:	push	si		    ; Save largest block so far
bf2:	mov	ax,[bx].la_prev	    ; Skip past this block
bfnext:
	and	al,LA_MASK
	mov	bx,ax
	loop	bfloop
bfexit:
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; lcompact                                                              ;
; 									;
; Compacts the local heap.						;
; 									;
; Arguments:								;
;	DX = minimum #contiguous bytes needed				;
;	DI = address of local heap information				;
; 									;
; Returns:								;
;	AX = size of largest contiguous free block			;
;	BX = arena header of largest contiguous free block		;
;	DX = minimum #contiguous bytes needed				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,SI,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed March 11, 1987  -by- Bob Gunderson [bobgu]			;
; Added code to maintain free list while compacting.			;
;									;
;  Tue Oct 14, 1986 06:27:37p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lcompact,<PUBLIC,NEAR>
cBegin nogen
x = LHE_DISCARDABLE+1
x = x shl 8
x = x or 1
    IncLocalStat    ls_lcompact
	push	si
	mov	word ptr [di].hi_ncompact,x
	errnz	<hi_ncompact-hi_dislevel+1>
	cmp	[di].hi_freeze,0    ; Is the heap frozen?
	je	compact1	    ; No, continue
	dec	[di].hi_ncompact    ; Yes, prevent discarding
compact1:
    IncLocalStat    ls_cloop
	push	dx		    ; Save what we are looking for
	xor	ax,ax		    ; Haven't found a free block yet
	push	ax		    ; Remember what we have found here
	mov	bx,[di].hi_last	    ; Start at end of arena
	mov	cx,[di].hi_count
; Loop to find the next free block
;
cfreeloop:
    IncLocalStat    ls_cexamine
	mov	ax,[bx].la_prev
	test	al,LA_BUSY
	jz	cfreefound
	and	al,LA_MASK
	mov	bx,ax
cflnext:
	loop	cfreeloop

compact2:
	pop	bx		    ; Recover largest free block so far
	pop	dx		    ; Recover size needed
	mov	ax,bx		    ; Compute size in AX
	or	ax,ax		    ; Did we find a free block?
	jz	cexit1		    ; No, done
	sub	ax,[bx].la_next	    ; Yes, compute size of largest free block
	neg	ax
	dec	[di].hi_ncompact    ; Any other possibilities?
	jl	cexit		    ; No, get out now
	cmp	ax,dx		    ; Yes, Did we get size we needed?
	jb	compact3	    ; No, try next possibility
cexit:
cexit1:
	pop	si
	ret			    ; Yes, return to caller

compact3:
	push	dx
	push	bx

	dec	[di].hi_dislevel    ; Down to next discard level
	jz	compact2	    ; Ooops, no more, try next step
	inc	[di].hi_ncompact    ; Still discarding
	xor	si,si		    ; Start enumerating handle table entries
cdloop:
	call	henum		    ; Get next discardable handle
	jz	cdexit		    ; No, more see if we discarded anything
	push	cx		    ; Got one, see if okay to discard
	mov	cl,LN_DISCARD	    ; AX = LN_DISCARD
	xchg	ax,cx		    ; CX = discardable flags
	mov	bx,si		    ; BX = handle
	call	lnotify
	pop	cx
	or	ax,ax		    ; Is it still discardable?
	jz	cdloop		    ; No, skip this handle
	mov	bx,[si].lhe_address  ; Get true address of a block
	sub	bx,SIZE LocalArena  ; BX = address of block to free
	call	lfree		    ; Free the block associated with this handle
	xor	ax,ax		    ; Zero the true address field in the
	mov	[si].lhe_address,ax
	or	[si].lhe_flags,LHE_DISCARDED  ; and mark as discarded
	or	[di].hi_ncompact,80h	; Remember we discarded something
	jmp	cdloop
cdexit:
	test	[di].hi_ncompact,80h	; No, did we discarded something?
	jz	compact2
	xor	[di].hi_ncompact,80h	; Yes, clear flag
	pop	bx
	pop	dx
	jmp	compact1		; and try compacting again

; Here when we have a free block.  While the preceeding block is
; moveable, then move it down and put the free space in it place.
; When the preceeding block is not moveable, then search backwards
; for one or more moveable blocks that are small enough to fit
; in the remaining free space.	Advance to previous block when
; no more blocks to examine.
cfreefound:
    IncLocalStat    ls_cfree
	cmp	[di].hi_freeze,0    ; Is the heap frozen?
	jne	cffexit		    ; No, continue

;	and	al,LA_MASK	    ; Already clear for free blocks
	mov	si,ax		    ; SI = previous block
	test	byte ptr [si].la_prev,LA_MOVEABLE
	jz	cfreefill	    ; Skip if not moveable
	mov	si,[si].la_handle   ; Point to handle table entry
	cmp	[si].lhe_count,0    ; Is it locked?
	jne	cfreefill	    ; Yes, skip this block

; Here if previous block is moveable.  Slide it up to the top of the
; free block and make the old busy block free.	This is easy as
; we are not really adding or taking anything away from the arena
;
	push	cx		    ; Save loop state regs
	push	di
	mov	si,ax		    ; SI = busy block before free block
	call	lfreedelete	    ; remove [BX] from free list
	call	lmove		    ; Move busy block down
	mov	[di].la_prev,si	    ; Link in new busy block
	or	byte ptr [di].la_prev,LA_MOVEABLE+LA_BUSY
	mov	bx,ax
	mov	[di].la_next,bx	    ; la_next field from old free block
	and	[bx].la_prev,LA_ALIGN
	or	[bx].la_prev,di

	mov	[si].la_next,di	    ; Link in old busy block (new free block)
	and	byte ptr [si].la_prev,LA_MASK	; mark it free

	push	si
	push	bx
	mov	bx,si
	xor	si,si
	call	lfreeadd	    ; add new free block to free list
	pop	bx
	pop	si

	mov	bx,[di].la_handle   ; Modify handle table entry to point
	lea	ax,[di].SIZE LocalArena
	mov	[bx].lhe_address,ax  ; to new location of client data

	pop	di		    ; Restore arena info pointer
    IncLocalStat    ls_cmove
	mov	al,LN_MOVE	    ; Tell client we moved it
	lea	cx,[si].SIZE LocalArena	    ; CX = old client data
	call	lnotify		    ; BX = handle

	pop	cx		    ; restore #arena entries left
	mov	bx,si		    ; BX = address of free block
	mov	si,[bx].la_prev	    ; SI = previous block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	cffnext		    ; No, continue
	call	ljoin		    ; Yes, coelesce with block in BX
;;; DO NOT change cx, ljoin leaves BX pointing after the free block
;;;	dec	cx		    ; ...keep CX in sync
cffnext:
	jmp	cflnext		    ; Go process next free block

; Here when done with a free block.  Keep track of the largest free block
; seen so far.
;
cffexit:
	pop	si		    ; Recover largest free block so far
	cmp	si,bx		    ; Same as current?
	je	cff1		    ; Yes, no change then
	test	[bx].la_prev,LA_BUSY	; No, is current free?
	jnz	cff1			; No, ignore it then
	or	si,si		    ; Yes, First time?
	jz	cff0		    ; Yes, special case
	mov	ax,[si].la_next	    ; No, compute size of largest free block
	sub	ax,si
	add	ax,bx		    ; Compare to size of this free block
	cmp	[bx].la_next,ax	    ; Is it bigger?
	jbe	cff1		    ; No, do nothing
cff0:	mov	si,bx		    ; Yes, remember biggest free block
cff1:	push	si		    ; Save largest free block so far
cff2:	mov	bx,[bx].la_prev	    ; Skip past this free block
	and	bl,LA_MASK	    ; (it might not be a free block)
	jmp	cffnext

; Here if previous block is NOT moveable.  Search backwards for the
; largest moveable block that will fit in this free block.  As long
; as a block is found, move it to the top of the free block, free it
; from it's old location and shrink the current free block to accomodate
; the change.
;
cfreefill:
	call	lbestfit	    ; Search for best fit
	or	si,si		    ; Find one?
	jz	cffexit		    ; No, all done with this free block
	push	cx		    ; Save loop state regs
	push	di
	push	[bx].la_prev	    ; Save busy block before free block
	call	lfreedelete	    ; remove [BX] from free list
	call	lmove		    ; Move it down
	; SI = old busy address (new free block)
	; DI = new busy address
	; BX = old free block
	; AX = block after old free block
	pop	cx		    ; Recover la_prev field of old free block
	cmp	bx,di		    ; Did we consume the free block?
	je	cff		    ; Yes, then CX has what we want
	mov	cx,bx		    ; No, then busy block will point to what
	mov	[bx].la_next,di	    ; is left of the free block and vs.
cff:
	mov	[di].la_prev,cx	    ; Link in new busy block
	or	byte ptr [di].la_prev,LA_MOVEABLE+LA_BUSY
	mov	[di].la_next,ax	    ; la_next field from old free block
	xchg	di,ax
	and	[di].la_prev,LA_ALIGN
	or	[di].la_prev,ax
	xchg	di,ax

	lea	cx,[di].SIZE LocalArena

	cmp	bx,di		    ; Did we create a free block?
	je	cffff
	push	si
	xor	si,si
	call	lfreeadd	    ; Add [BX] to free list
	pop	si
cffff:

	cmp	bx,di		    ; Did we create a free block?

	    mov	    bx,di		; Current block is busy block
	    mov	    di,[di].la_handle	; Modify handle table entry to point
	    xchg    [di].lhe_address,cx	; to new location of client data
	    pop	    di			; Restore arena info pointer
	    pop	    ax			; restore #arena entries left
	je	cfff		    ; No, arena count okay
	inc	ax		    ; Keep arena count on target
	inc	[di].hi_count
cfff:
	push	bx		    ; Save current block pointer
	push	ax		    ; Save #arena entries left
	mov	al,LN_MOVE	    ; Tell client we moved it (CX = old addr)
	mov	bx,[bx].la_handle   ; BX = handle
	call	lnotify
	pop	cx		    ; restore #arena entries left
	and	byte ptr [si].la_prev,not LA_MOVEABLE	; Clear moveable bit
	mov	bx,si		    ; BX = address of old busy block to free
	push	[di].hi_count
	call	lfree		    ; Mark it as free
	pop	si
	sub	si,[di].hi_count
	sub	cx,si		    ; Keep arena count on target
	pop	bx		    ; BX = current block
	jmp	cff2		    ; Move to previous block.
cEnd nogen

;-----------------------------------------------------------------------;
; lshrink								;
; 									;
; Shrinks the local heap.						;
; 									;
; Arguments:								;
;	DS:DI = address of local heap information block 		;
;	BX = Minimum size to shrink heap				;
; 									;
; Returns:								;
;	AX = New size of local heap					;
; 									;
; Error Returns:							;
;	None.								;
;									;
; Registers Preserved:							;
;	None								;
; Registers Destroyed:							;
;	All								;
; Calls:								;
; 									;
; History:								;
;									;
;   Fri July 17, 1987 -by- Bob Gunderson [bobgu]			;
;	Changed logic so we don't call lcompact every time we move      ;
;	a block, just call it whenever we can't find room.              ;
;									;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]			;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	lshrink,<PUBLIC,NEAR>
cBegin nogen

    ; Bound the minimum size to the size specified at LocalInit() time.
	mov	ax,[di].li_minsize
	cmp	ax,bx		    ; specified smaller than min ?
	jbe	lshr_around	    ; no - use what's specified
	mov	bx,ax		    ; yes - use real min.
lshr_around:
	push	bx		    ; Save minimum heap size
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[di].hi_first    ; ax = current heap size
	cmp	ax,bx		    ; already small enough ?
	ja	lshr_around1
	jmp	lshr_exit	    ; yes - that was quick...
lshr_around1:

    ; local compact to get as much contiguous free space as possible.
	stc
	call	lalign
	call	lcompact	    ; compact everything
	xor	dx,dx		    ; start with null flag

    ; Start with last block in heap.
	mov	si,[di].hi_last

loop1:

    ; SI = address of block just moved.

    ; This section moves moveable blocks (one at a time) up
    ; into free blocks below (higher addresses) all fixed blocks.
    ; The blocks they vacate are freed.  The sentenal block is then
    ; moved, the heap is re-compacted.	Then a test is made to see if
    ; the heap has shrunk enough, if not
    ; we start this loop again.  We continue this until we can't
    ; move anything or we have moved enough to satisfy the minimum
    ; size specified by BX when called.

	mov	si,[si].la_prev 	; get next block to move
	and	si,LA_MASK		; zap the flag bits
	mov	ax,[si].la_prev 	; get this blocks flags
	test	ax,LA_BUSY		; is this block free?
	jz	lshr_gobblefree 	; yes - gobble this free block
	test	ax,LA_MOVEABLE		; is it moveable ?
	jz	lshr_cantmove		; no - exit
	mov	bx,[si].la_handle	; get its handle
	cmp	[bx].lhe_count,0	; is it locked ?
	jnz	lshr_cantmove		; yes - exit

	mov	cx,[si].la_next
	sub	cx,si			; get block size in cx

    ; Find the first free block (after fixed blocks) that is big
    ; enough for this block
loop2:
	call	lfirstfit
	jnc	lshr_gotblock		; got one - continue

    ; If we have already tried compacting, nothing more to do
	or	dx,dx
	jnz	lshr_cantmove		; nothing more to do...

    ; Not enough room found, recompact the local heap and test again
	push	si
	push	cx
	stc
	call	lalign
	call	lcompact		; compact everything
	pop	cx
	pop	si
	mov	dx,1			; flag to say we have done this
	jmp	loop2			; try again

    ;	DI = local arena info block address
    ;	SI = block we didn't move (next is last block moved)
lshr_cantmove:
	mov	si,[si].la_next 	; get last block moved
	jmp	lshr_alldone		; cleanup and exit

lshr_gobblefree:
    ; SI = address of free block
    ; Block to move is already free, remove it from the free list and mark
    ; it a busy.
	mov	bx,si
	call	lfreedelete
	or	[bx].la_prev,LA_BUSY
	jmps	lshr_shiftup

lshr_gotblock:
    ;	DI - Arena info block address
    ;	SI - Address of block to move
    ;	BX - Address of free block to use
    ;	CX - Size of block to move

	call	lfreedelete		; remove it from the free list
	xchg	di,bx
	mov	ax,[di].la_next
	sub	ax,cx
	sub	ax,LA_MINBLOCKSIZE	; Room to split free block into
	cmp	ax,di			; two blocks ?
	jb	lshr_nosplit		; no - don't split the block
	push	bx
	push	si
	mov	bx,cx
	lea	bx,[bx+di]		; bx = address of new free block to add
	; link this new block in
	mov	[bx].la_prev,di
	mov	ax,[di].la_next
	mov	[bx].la_next,ax
	mov	[di].la_next,bx
	xchg	ax,bx
	and	[bx].la_prev,LA_ALIGN	; Zap only high bits
	or	[bx].la_prev,ax 	; and set new previous pointer
	mov	bx,ax
	mov	si,[di].la_free_prev	; previous free block
	call	lfreeadd		; add the new smaller free block
	pop	si
	pop	bx
	inc	[bx].hi_count		; bump the block count (we added
					;   a block)
lshr_nosplit:
    ;	BX - Arena info block address
    ;	SI - Address of block to move
    ;	DI - Address of free block to use
    ;	CX - Size of block to move

    ; copy the flags from the old block
	mov	ax,[si].la_prev
	and	ax,LA_ALIGN
	or	[di].la_prev,ax

	push	si
	push	di
    ; don't copy the block headers (but do copy the handle)
	add	si,la_fixedsize
	add	di,la_fixedsize
	sub	cx,la_fixedsize
    ; We can take # bytes/2 as # words to move because all blocks
    ; start on even 4 byte boundary.
	shr	cx,1			; bytes / 2 = words
	push	ds
	pop	es			; same segment
	cld				; auto-increment
	rep	movsw			; Head 'em up!  Move 'em out!
	pop	di
	pop	si
    ;	BX - Arena info block address
    ;	SI - Address of block to move
    ;	DI - Address of free block to use

    ; Fixup the handle table pointer
	push	bx
	mov	bx,[si].la_handle
	lea	ax,[di].SIZE LocalArena
	mov	[bx].lhe_address,ax
	pop	di			; DI = info block address

    ; Mark the old block as busy fixed
	and	[si].la_prev,LA_MASK	; clear old bits
	or	[si].la_prev,LA_BUSY	; put in busy fixed bit
	jmps	lshr_shiftup

    ; Time to shift the setenal block up, recompact and look for more
    ; space...
    ;	DI = local arena info block address
    ;	SI = block just freed
    public foo
foo:
lshr_shiftup:
	mov	ax,[di].hi_last
	mov	bx,ax
	sub	bx,si			; less what is already removed
	sub	ax,bx
	add	ax,SIZE LocalArenaFree	; size of sentenal block
	sub	ax,[di].hi_first	; ax = current heap size
	pop	bx			; get min size
	push	bx			; and put it back on stack
	cmp	ax,bx			; already small enough ?
	jbe	lshr_alldone		; yes - exit
	xor	dx,dx			; localcompact flag
	jmp	loop1			; and back for more

lshr_alldone:
    ;	DI = local arena info block address
    ;	SI = last block moved

    ; Time to shift the sentenal block up and realloc our heap
	pop	bx		    ; Minimum size of the heap
	push	bx
	call	slide_sentenal	    ; slide the sentenal block up

    ; get our data segment handle
	push	ds
	call	GlobalHandle	    ; ax = handle of DS
	or	ax,ax
	jz	lshr_exit	    ; this can't happen.....
	push	ax		    ; hMem

    ; determine how big we should be
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	xor	cx,cx
	push	cx
	push	ax		    ; # bytes in DS
	push	cx		    ; no wFlags
	call	GlobalRealloc

    ; local compact to get as much contiguous free space as possible.
lshr_exit:
	stc
	call	lalign
	call	lcompact		; compact everything
	pop	ax			; clean the stack
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[di].hi_first	; ax = current heap size
	ret
cEnd nogen

;-------------------------------------------------------------------------
; Find first free block after last fixed block.  We do this by scanning
; through the free list looking for a free block with the next physical
; block being moveable (remember we just did a compact...).  Then, starting
; with this free block, find the first free block that is at least
; CX bytes long.
;
; Entry:
;	DI = local arena header info block address
;	CX = # bytes needed
;
; Exit:
;	BX = Address of free block to use
;
; Error Return:
;	Carry set if no free block big enough
;
; History:
;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]
; Wrote it.
;-------------------------------------------------------------------------

cProc	lfirstfit,<PUBLIC,NEAR>
cBegin nogen
	push	ax

	mov	bx,[di].hi_last
	mov	bx,[bx].la_free_prev
;	mov	bx,[di].hi_first
;	mov	bx,[bx].la_free_next
lffloop:
	cmp	bx,[bx].la_free_prev
;	cmp	bx,[bx].la_free_next
	jz	lff_err_exit
	cmp	cx,[bx].la_size
	jbe	lff_exit
	mov	bx,[bx].la_free_prev
;	mov	bx,[bx].la_free_next
	jmp	lffloop
lff_err_exit:
	stc
	jmps	lff_done
lff_exit:
	clc			    ; good return
lff_done:
	pop	ax
	ret
cEnd nogen


;-------------------------------------------------------------------------
;   slide_sentenal
;	This routine is called during the LocalShrink() operation.
;	Make all the blocks between the one at SI and the sentenal go
;	away.  Then check to see if we have shrunk the heap too much.  If
;	so, then add a free block at SI big enough to bump the size up (this
;	will be moved later by LocalCompact).  Now move the sentenal block
;	up after the last block.
;
; Entry:
;	BX = requested minimum size of the heap
;	SI = last block actually moved (put sentenal here)
;	DI = local arena info block address
;
; Exit:
;
; Error Return:
;
; History:
;
;   Fri Aug 14, 1987 -by- Bob Gunderson [bobgu]
; Changed things again to insure we don't shrink to heap too much.
;
;   Fri July 17, 1987 -by- Bob Gunderson [bobgu]
; Was too slow, so changed the logic.
;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]
; Wrote it.
;-------------------------------------------------------------------------

cProc	slide_sentenal,<PUBLIC,NEAR>
cBegin nogen

	push	bx

    ; Get sentenal block
	mov	bx,[di].hi_last

    ; Insure that we aren't trying to move to ourselves
	cmp	si,bx
	jz	slide_exit	    ; nothing to do....

    ; count the number of block we are removing so that we can update
    ; the block count in the arena header.
	push	si
	xor	cx,cx
slide_loop:
	cmp	si,bx
	jz	slide_loop_exit
	inc	cx
	mov	si,[si].la_next
	jmp	slide_loop
slide_loop_exit:
	pop	si

	sub	[di].hi_count,cx    ; decrement the count of blocks

    ; Would the heap be too small if the sentenal were moved to the block
    ; pointed to by si?  If so, add a free block at SI to make up the
    ; difference.
	mov	ax,si
	sub	ax,[di].hi_first
	add	ax,la_freefixedsize ; size of heap in ax
	pop	bx		    ; minimum in bx
	cmp	ax,bx
	ja	slide_ok	    ; everything is ok...
	sub	bx,ax		    ; bx = size to grow
	cmp	bx,LA_MINBLOCKSIZE
	jbe	slide_ok	    ; not enough for a block
	clc
	call	lalign		    ; make it even 4 byte boundary
	mov	bx,dx
    ; add a free block of bx bytes
	lea	ax,[si+bx]	    ; address of new "next" block
	mov	[si].la_next,ax     ; make block point at "next"
	and	[si].la_prev,LA_MASK  ; make it a free block
	xor	bx,bx
	xchg	si,bx		    ; bx = block to add, si = 0
	call	lfreeadd	    ; preserves ax
	inc	[di].hi_count	    ; bump block count
	mov	si,ax		    ; and bump si to "next" block
	mov	[si].la_prev,bx     ; set new block's previous pointer

slide_ok:
    ; move the sentenal block up by copying the words.
	mov	bx,[di].hi_last 	; old sentenal block
	mov	[si].la_next,si 	; new sentenal points to self
	and	[si].la_prev,LA_MASK	; remove any old flags
	or	[si].la_prev,LA_BUSY	; make it busy
	mov	ax,[bx].la_size
	mov	[si].la_size,ax 	; move in the size
	mov	bx,[bx].la_free_prev
	mov	[si].la_free_prev,bx	; move in previous free block
	mov	[bx].la_free_next,si	; point prev free block to this one
	mov	[si].la_free_next,si	; point to itself

    ; Now fixup the arena header block to point to the new setenal
    ; position.

	mov	[di].hi_last,si

    ; And we are done...
	jmps	slide_exit1

slide_exit:
	pop	bx
slide_exit1:
	ret
cEnd nogen

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ld.asm ===
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
include eems.inc
include protect.inc
.list

NEWEPME = NEPRIVLIB			; flag saying Call WEP on exit

externW pLocalHeap
externW pStackTop

DataBegin

externB num_tasks
externB graphics
externB fBooting
externB Kernel_flags
externB WOAName
externW fLMdepth
externW headPDB
externW curTDB
externW loadTDB
externW Win_PDB
externW topPDB
externW hExeHead
;externW EMS_calc_swap_line
externW WinFlags
externW hGDI
externW hUser
ifdef WOW
externW OFContinueSearch
endif
externD pMBoxProc
externD pGetFreeSystemResources
externD dressed_for_success
externD lpGPChain

;** Diagnostic mode stuff
externW fDiagMode
externB szLoadStart
externB szCRLF
externB szLoadSuccess
externB szLoadFail
externB szFailCode
externB szCodeString

if ROM
externW selROMTOC
endif

; Look for module in Module Compatibilty section of win.ini
szModuleCompatibility   DB  'ModuleCompatibility',0
DataEnd

if ROM and PMODE32
externFP HocusROMBase
endif

externFP Yield
externFP CreateTask
externFP GlobalAlloc
externFP GlobalSize
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalFree
externFP LocalAlloc
externFP LocalFree
externFP LocalCountFree
externFP LoadModule
externFP lstrlen
externFP _lclose
externFP FreeModule
externFP GetModuleHandle
externFP LoadExeHeader
externFP GetExePtr
externFP GetProcAddress
externFP MyOpenFile
externFP FarGetCachedFileHandle
externFP FarEntProcAddress
externFP FlushCachedFileHandle
externFP FarMyLock
externFP FarMyFree
externFP FarMyUpper
externFP FarLoadSegment
externFP FarDeleteTask
externFP FarUnlinkObject
externFP Far_genter
externFP AllocSelector
externFP FreeSelector
externFP LongPtrAdd
externFP GetProfileInt

if ROM
externFP ChangeROMHandle
externFP UndefDynLink
externFP GetProcAddress
externFP IPrestoChangoSelector
externFP far_alloc_data_sel16
externFP far_free_temp_sel
endif

ifdef WOW
externFP StartWOWTask
externFP WowIsKnownDLL
externFP LongPtrAddWOW
externFP AllocSelectorWOW
externFP WOWLoadModule
externFP WowShutdownTimer
externB  fShutdownTimerStarted
externB  fExitOnLastApp
externFP WowSyncTask
endif

ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

externFP FreeTDB

;** Diagnostic mode
externFP DiagOutput

sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

sEnd	CODE

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externB szProtectCap
externB msgRealModeApp1
externB msgRealModeApp2

externNP MapDStoDATA
externNP FindExeFile
externNP FindExeInfo
externNP AddModule
externNP DelModule
externNP GetInstance
externNP IncExeUsage
externNP DecExeUsage
externNP AllocAllSegs
externNP PreloadResources
externNP StartProcAddress
externNP StartLibrary
externNP GetStackPtr
externNP StartTask

IFNDEF NO_APPLOADER
externNP BootAppl
ENDIF ;!NO_APPLOADER


;-----------------------------------------------------------------------;
; OpenApplEnv								;
; 	Calls CreateTask						;
; 	Allocates temporary stack					;
; Arguments:								;
; 									;
; Returns:								;
; 	ax = selector of load-time stack				;
; Error Returns:							;
; 	ax = 0								;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue 16-Jan-1990 21:13:51  -by-  David N. Weise  [davidw]		;
; Ya know, it seems to me that most of the below ain't necessary        ;
; for small frame EMS.	But it's too late to change it now.             ;
;									;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]		;
; Added support for task ExeHeaders above The Line in Large		;
; Frame EMS.								;
;									;
;  Tue Oct 20, 1987 07:48:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

LOADSTACKSIZE = 2048

	assumes ds,nothing
	assumes es,nothing

cProc	OpenApplEnv,<PUBLIC,NEAR>,<ds,si,di>
	parmD   lpPBlock
	parmW	pExe
	parmW	fWOA
;	localW  myCodeDS
;	localW  myCurTDB
;	localW  myLoadTDB
cBegin
	ReSetKernelDS			; Assume DS:KRNLDS

	cCall	CreateTask,<lpPBlock,pExe,fWOA>
	or	ax,ax
	jz	oae_done

	test	kernel_flags,KF_pUID	; All done booting?
	jz	oae_done

	xor	ax,ax
	mov	bx,LOADSTACKSIZE
	mov	cx,(GA_ALLOC_LOW or GA_SHAREABLE) shl 8 or GA_ZEROINIT or GA_MOVEABLE
	cCall	GlobalAlloc,<cx,ax,bx>
	or	ax,ax
	jz	oae_done
	cCall	GlobalLock,<ax>
	mov	ax,dx
	push	es			; added 13 feb 1990
	mov	es,loadTDB
	mov	es:[TDB_LibInitSeg],ax
	mov	es:[TDB_LibInitOff],10h
	mov	es,dx
	mov	es:[pStackTop],12h
	pop	es
oae_done:
cEnd


;-----------------------------------------------------------------------;
; CloseApplEnv								;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
;	AX = hExe							;
;	BX = ?								;
;	DX = TDB							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	..., ES, ...							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]		;
; Added support for task ExeHeaders above The Line in Large		;
; Frame EMS.								;
;									;
;  Tue Oct 20, 1987 07:48:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CloseApplEnv,<PUBLIC,NEAR>,<ds,si,di>
	parmW   hResult
	parmW   hExe
	localW  myCurTDB
	localW	cae_temp
	localW  myLoadTDB
cBegin

	ReSetKernelDS

; Copy DS variables to stack, since we may need DS
	mov	cx,curTDB
	mov	myCurTDB,cx
	mov	cx,loadTDB
	mov	myLoadTDB,cx
	mov	cae_temp, si

	mov	ax, myLoadTDB
	or	ax, ax			; Not set if LMCheckHeap failed
	jz	cae_done
	mov	ds, ax
	mov	ax, ds:[TDB_LibInitSeg]
	or	ax, ax
	jz	cae_free_stack1
	mov	ds, ax
	cmp	ds:[pStackTop], 12h
	jne	cae_free_stack1
	mov	ds,myLoadTDB
	push	ax
	cCall	GlobalUnlock,<ax>
	call	GlobalFree			; parameter pushed above
cae_free_stack1:
	mov	ds,myLoadTDB
	mov	ds:[TDB_LibInitSeg],ax
	mov	ds:[TDB_LibInitOff],10h

; Copy correct return address

cae_done:
	SetKernelDSNRES
	xor	dx,dx
	xchg	loadTDB,dx		; Done loading this guy

	mov	ax,hResult		; if hResult < 32, it's not a real
	cmp	ax,LME_MAXERR		;  handle, and in fact is the invalid
	jb	cae_cleanup		;  format return code. (11).

	mov	es,dx

; Start this guy up!  TDB_nEvents must be set here, and not before
; because message boxes may be put up if we can't find libraries,
; which would have caused this app to prematurely start.

        push    es
ifdef WOW
        cmp     num_tasks, 1            ; First task? (except wowexec)
        jne     @F                      ; branch if not first task
        cmp     fExitOnLastApp, 0       ; Shared WOW?
        jne     @F                      ; branch if not shared WOW
        cmp     fShutdownTimerStarted, 1; Is the timer running?
        jne     @F                      ; branch if not running
        cCall   WowShutdownTimer, <0>   ; stop shutdown timer
        mov     fShutdownTimerStarted, 0
@@:
endif
        mov     es:[TDB_nEvents],1
        inc     num_tasks               ; Do this here or get it wrong.

	test	es:[TDB_flags],TDBF_OS2APP
	jz	@F
	cmp	dressed_for_success.sel,0
	jz	@F
	call	dressed_for_success

ifdef WOW
	; Start Up the New Task
@@:	cCall	StartWOWTask,<es,es:[TDB_taskSS],es:[TDB_taskSP]>
	or	ax,ax			; Success ?
	jnz	@f			; Yes

	mov	hResult,ax		; No - Fake Out of Memory Error 0
					;      No error matches failed to create thread
	pop	dx			; restore TDB
	dec	num_tasks		;
	jmps	cae_cleanup		;

endif; WOW

@@:	test	kernel_flags,KF_pUID	; All done booting?
	jz	@F			; If booting then don't yield.
	cCall	WowSyncTask             

@@:
	assumes ds,nothing
	pop	dx			; return TDB
	jmps	cae_exit

; Failure case - undo the damage
cae_cleanup:
	or	dx,dx			; Did we even get a TDB?
	jz	cae_exit		; No.
	mov	ds,dx
	assumes ds,nothing
	mov	ds:[TDB_sig],ax		; mark TDB as invalid
	cCall	FarDeleteTask,<ds>
	mov	es,ds:[TDB_PDB]
	mov	dx,PDB_Chain
	mov	bx,dataOffset HeadPDB	; Kernel PDB
	cCall	FarUnlinkObject
	cCall	FreeTDB

cae_exit:
	xor	ax,ax
	mov	es,ax			; to avoid GP faults in pmode
if PMODE32
.386
	mov	fs, ax
	mov	gs, ax
.286
endif
	mov	ax,hResult
	mov	bx, cae_temp
cEnd


;-----------------------------------------------------------------------;
; StartModule								;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
;	AX = hExe or StartLibrary					;
;									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
;	BX,DI,SI,DS							;
;									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	FarLoadSegment							;
;	StartProcAddress						;
;	StartLibrary							;
;									;
; History:								;
; 									;
;  Tue Jan 01, 1980 03:04:49p  -by-  David N. Weise   [davidw]		;
; ReWrote it from C into assembly and added this nifty comment block.	;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	StartModule,<PUBLIC,NEAR>,<di,si>
	parmW	hPrev
	parmD	lpPBlock
	parmW	hExe
	parmW	fh
	localD	pf
cBegin
	mov	ax,hExe
	mov	es,ax
	assumes es,nothing
	cmp	es:[ne_csip].sel,0
	jz	start_it_up

; Make sure DGROUP loaded before we need to load the start segment.

	mov	cx,es:[ne_autodata]
	jcxz	start_it_up		; no automatic data segment
	cCall	FarLoadSegment,<es,cx,fh,fh>
	or	ax,ax
	jnz	start_it_up		; auto DS loaded OK
	mov	ax,fh
	inc	ax
	jz	sm_ret1 		; return NULL
	dec	ax
	cCall	_lclose,<ax>
	xor	ax,ax
sm_ret1:
	jmps	sm_ret			; return NULL

start_it_up:
	cCall	StartProcAddress,<hExe,fh> ; just because it's preloaded
	mov	pf.sel,dx		   ;  doesn't mean it's still around!
	mov	pf.off,ax
	or	dx,ax
	push	dx
	mov	ax,fh
	cmp	ax,-1
	jz	sm_nothing_to_close
	cCall	_lclose,<ax>
sm_nothing_to_close:
	pop	dx
	mov	es,hExe
	assumes es,nothing
	test	es:[ne_flags],NENOTP
	jnz	start_library
	or	dx,dx
	jz	nothing_to_start
	cCall	GetStackPtr,<es>
	cCall	StartTask,<hPrev,hExe,dx,ax,pf>
	jmps	sm_ret

start_library:
	mov	es, hExe
	or	es:[ne_flags], NEWEPME	; Need to call my WEP on exit
	cCall	StartLibrary,<hExe,lpPBlock,pf>
	jmps	sm_ret

nothing_to_start:
	mov	ax,hExe
	test	es:[ne_flags],NENOTP
	jnz	sm_ret
	xor	ax,ax
sm_ret:
cEnd

if 0	; too late to include in 3.1, add for next Windows release (donc)
cProc	GetProcAddressRes, <PUBLIC, FAR>, <ds, si, di>
parmW	hExe
parmD	pname	; pass in Pascal string
cBegin
	les	di, [pname]		; ES:DI = name to find

	mov	cx, 255			; CH = 0
	xor	ax, ax
	push	di
	repne	scasb
	pop	di
	jnz	GPAR_fail
	not	cl
	dec	cl
	mov	al, cl			; AX = length of name

	mov	ds, [hExe]		; DS:SI = res name table
	mov	bx, ds:[ne_restab]	; (actually DS:BX first time through)

GPAR_nextsym:
	mov	si, bx			; next entry to check
	mov	cl, [si]		; string length
	jcxz	GPAR_fail
	lea	bx, [si+3]
	add	bx, cx			; BX points to next (last + len + 3)
	cmp	cx, ax
	jnz	GPAR_nextsym		; length diff - no match
	inc	si			; skip length byte
	push	di
	rep	cmpsb
	pop	di
	jnz	GPAR_nextsym
	lodsw				; get ordinal number
;if	KDEBUG
;	cCall   FarEntProcAddress,<ds,ax,1>
;else
	cCall	FarEntProcAddress,<ds,ax>	; I hate conditional assembly....
;endif
	mov	cx, ax
	or	cx, dx
	jmps	GPAR_exit

GPAR_fail:
	xor	ax, ax
	cwd
GPAR_exit:
cEnd
endif

;-----------------------------------------------------------------------;
; CallWEP								;
;									;
; Call WEP of DLL if appropriate					;
;									;
; Arguments:								;
;	HANDLE hExe = HEXE of module about to close			;
;	WORD WEPVal = 0, 1 pass to WEP, 2 check for WEP			;
;									;
; Returns:								;
;	AX = status 							;
;									;
; Error Returns:							;
;	AX = 		Not a DLL					;
;	AX = 		No WEP						;
;	AX = 		Module not started				;
;-----------------------------------------------------------------------;

cProc	CallWEP, <PUBLIC,FAR>, <ds>
	parmW	hExe
	parmW	WEPVal
	localV	szExitProc,4
	localD	pExitProc
	localW  bogusIBMAppSp
cBegin
	mov	ds, hExe		; Robustify this!

	CWErr = 1
	mov	ax, 1			; exit code
	cmp	ds:[ne_expver], 300h	; 3.0 libraries only
	jb	CW_noWEP

	CWErr = CWErr+1
	inc	ax
	test	ds:[ne_flags], NENOTP	; is it a DLL?
	jz	CW_noWEP

	CWErr = CWErr+1
	inc	ax			; Font, etc
	cmp	ds:[ne_cseg],0
	jz	CW_noWEP

	CWErr = CWErr+1
	inc	ax
	mov	bx, ds:[ne_pautodata]	; Make sure auto data loaded
	or	bx, bx
	jz	@F
	test	ds:[bx].ns_flags, NSLOADED
	jz	CW_noWEP
@@:

	CWErr = CWErr+1
	inc	ax
	NoWepErr = CWErr
	mov	[szExitProc].lo, 'EW'	; If the module has a procedure
	mov	[szExitProc].hi, 'P'	; named 'WEP', call it.
	lea	bx, szExitProc
	push	ax
	cCall	GetProcAddress, <ds, ss, bx>
	mov	[pExitProc].off, ax
	mov	[pExitProc].sel, dx
	or	ax, dx
	pop	ax
	jnz	CW_WEP
CW_noWEP:
	jmps	CW_noWEP1

CW_WEP:
	cmp	WEPVAL,2		; If I'm just looking for WEP
	jz	CW_OK			; return 0

	inc	ax
	test	ds:[ne_flags], NEWEPME	; don't call wep if libmain
	jz	CW_noWEP		; wasn't called

	and	ds:[ne_flags], NOT NEWEPME ; only call WEP once

	SetKernelDSNRES			; Save old GP chaine
	pusha
	push	lpGPChain.sel
	push	lpGPChain.off
	push	cs
	push	offset cw_BlowChunks
	mov	lpGPChain.sel, ss	; and insert self in the chain
	mov	lpGPChain.off, sp
	UnSetKernelDS

	mov	ax, ss
	mov	ds, ax
	mov	es, ax
	mov     bogusIBMAppSP,sp	; Save sp cause some apps (Hollywood)
					; don't retf 2 correctly when we
					; call their wep
	cCall	pExitProc, <WEPVal> 	; fSystemExit

	mov     sp,bogusIBMAppSp

	add	sp, 4			; remove the CS:IP for error handler
cw_BlowChunks:
	SetKernelDSNRES
	pop	lpGPChain.off	; restore GPChain
	pop	lpGPChain.sel
	popa
	UnSetKernelDS
CW_OK:
	xor	ax, ax

CW_noWEP1:
	cmp	WEPVAL, 2		; if we checked for whining
	jnz	CW_done
	or	ax, ax			; if we found, then OK
	jz	CW_done
	cmp	ax, NoWepErr		; anything other than NoWep is OK
	jz	CW_done
	xor	ax, ax

CW_done:
cEnd


;-----------------------------------------------------------------------;
; LoadModule								;
; 									;
; Loads a module or creates a new instance of an existing module.	;
; 									;
; Arguments:								;
;	FARP p	 = name of module or handle of existing module		;
;	FARP lpPBlock = Parameter Block to pass to CreateTask		;
; 									;
; Returns:								;
;	AX = instance handle or module handle				;
; 									;
; Error Returns:							;
;LME_MEM 	= 0	; Out of memory					;
;LME_FNF	= 2	; File not found
;LME_LINKTASK 	= 5	; can't link to task				;
;LME_LIBMDS 	= 6	; lib can't have multiple data segments		;
;LME_VERS 	= 10	; Wrong windows version				;
;LME_INVEXE 	= 11	; Invalid exe					;
;LME_OS2 	= 12	; OS/2 app					;
;LME_DOS4 	= 13	; DOS 4 app					;
;LME_EXETYPE 	= 14	; unknown exe type				;
;LME_RMODE 	= 15	; not a pmode windows app 			;
;LME_APPMDS 	= 16	; multiple data segments in app			;
;LME_EMS 	= 17	; scum app in l-frame EMS 			;
;LME_PMODE 	= 18	; not an rmode windows app			;
;LME_INVCOMP 	= 20	; invalid DLL caused fail of EXE load		;
;LME_PE32	= 21	; Windows Portable EXE app - let them load it	;
;LME_MAXERR 	= 32	; for comparisons				;
; 									;
; Registers Preserved:							;
;	DI, SI, DS							;
; Registers Destroyed:							;
;	BX, CX, DX, ES							;
; 									;
; Calls:								;
;	AllocAllSegs							;
;	CreateInsider							;
;	DecExeUsage							;
;	DelModule							;
;	FindExeFile							;
;	FindExeInfo							;
;	FreeModule							;
;	GetExePtr							;
;	GetInstance							;
;	GetStringPtr							;
;	IncExeUsage							;
;	LoadExeHeader							;
;	LoadModule							;
;	FarLoadSegment							;
;	lstrlen								;
;	FarMyFree							;
;	MyOpenFile							;
;	PreloadResources						;
;	StartModule							;
;	_lclose								;
; 									;
; History:								;
;  Sun 12-Nov-1989 14:19:04  -by-  David N. Weise  [davidw]		;
; Added the check for win87em.						;
;									;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]		;
; Added support for task ExeHeaders above The Line in Large		;
; Frame EMS.								;
;									;
;  Tue Oct 13, 1987 05:00:00p  -by-  David J. Habib [davidhab]		;
; Added check for FAPI applications.					;
; 									;
;  Sat Jul 18, 1987 12:04:15p  -by-  David N. Weise   [davidw]		;
; Added support for multiple instances in different EMS banks.		;
; 									;
;  Tue Jan 01, 1980 06:57:01p  -by-  David N. Weise   [davidw]		;
; ReWrote it from C into assembly.					;
; 									;
;  Wed Sep 17, 1986 03:31:06p  -by-  Charles Whitmer  [chuckwh]		;
; Modified the original LoadModule code to only allow INSIDERs to	;
; allocate segments for a new process.	An INSIDER is a new process	;
; stub which bootstraps up a new instance of an application.		;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	ILoadLibrary,<PUBLIC,FAR>
	parmD	pLibName
	localV	szExitProc,4
cBegin
	mov	ax,-1
	cCall	<far ptr LoadModule>,<pLibName,ax,ax>
	cmp	ax, LME_INVEXE		; Invalid format?
	jnz	@F
	mov	ax, LME_INVCOMP		; Invalid component
@@:
if KDEBUG
	SetKernelDSNRes
	cmp	fBooting, 0
	jne	ll_fail			; No check while booting
	cmp	ax, LME_MAXERR
	jb	ll_fail			; No library, so no WEP()

	push	ax			; Now check for WEP
	cCall	GetExePtr,<ax>
	mov	es, ax
	test	es:[ne_flags],NEPROT	; ignore for OS/2 apps
	jnz	ll_noWhine
	cmp	es:[ne_usage], 0
	jne	ll_noWhine     		; Only check on first load!
	push	dx
	push	ax
	cCall	CallWEP,<ax,2>		; Just check for WEP, don't call it
	or	ax, ax
	pop	ax
	pop	dx
	jz	ll_noWhine
	trace_out "No WEP in library - > %AX0 %AX1"
;	fkerror	0,<No WEP in library - >,ax,dx
ll_noWhine:
	pop	ax			; return value of LoadModule

ll_fail:
endif	; KDEBUG
cEnd



os2calls DB 'DOSCALLS'		; Used for FAPI detection
mgxlib	 DB 'MGXLIB'		; Used for lib large entry table detection
win87em  DB 'WIN87EM.DLL',0	; Used for win87em.exe detection

	assumes ds,nothing
	assumes es,nothing

?SAV5	=	?DOS5		; Adobe Type Manager check the LoadModule
?DOS5	=	0		;   prolog and expects to see INC BP there...

public	LMAlreadyLoaded, LMLoadExeFile, LMCheckHeader, LMRamNMods
public	LMImports, LMSegs, LMLetsGo, LMPrevInstance, LMCleanUp

cProc	ILoadModule,<PUBLIC,FAR>,<di,si>
	parmD	lpModuleName
	parmD	lpPBlock
	localW	fh			; close if failed
	localW	pExe			; point to NE header in RAM
;	localW	hExe			; prev module if already loaded
	localW	hResult			; temp return value
	localW	hDepFail		; return of implicit link loads
	localW	abortresult		; temp return value
	localW	ffont			; flag if loading a *.fon
	localW	fexe			; flag if loading a *.exe
ifdef notyet
	localW	dll			; flag if loading a *.dll
endif
	localW	hBlock			; fastload block from LoadExeHeader
	localW	AllocAllSegsRet
	localW	exe_type		; from LoadExeHeader
	localW	hTDB			; dx from CloseApplEnv
	localW	SavePDB			; save caller's pdb, switch to krnl's
	localW	fWOA			; save flag if we're loading WOA
if ROM
	localW	selROMHdr
	localW	fLoadFromDisk
	localW	fReplaceModule
endif
ifdef WOW
        LocalD  pszKnownDLLPath
        LocalW  fKnownDLLOverride
        localW  RefSelector
        localW  LMHadPEDLL
        localW  hPrevInstance           ; previous 16-bit module handel with the same name
endif
        localD  FileOffset              ; offset to start of ExeHdr
	localW	OnHardDisk		; don't cache FH if on floppy
	localV	namebuf,136		; SIZE OPENSTRUC + 127
    localW  fModCompatFlags     ; used by LMRamNMods


cBegin
	SetKernelDSNRES

	mov	al,Kernel_Flags[1]	; solve re-entrancy #10759
	and	ax,KF1_WINOLDAP
	mov	fWOA,ax
	and	Kernel_Flags[1],NOT KF1_WINOLDAP

	inc	fLMdepth		; # current invocations

	;** Log this entry only if in diagnostic mode
	mov	ax, fDiagMode		; Only log if booting and diag mode
        and al, fBooting
        jz  @F

	;** Write out the string
	mov     ax,dataOFFSET szLoadStart ; Write the string
	cCall   DiagOutput, <ds,ax>
	push    WORD PTR lpModuleName[2]
	push    WORD PTR lpModuleName[0]
	cCall   DiagOutput
	mov     ax,dataOFFSET szCRLF
        cCall   DiagOutput, <ds,ax>

; Zero out flags and handles
@@:
ifdef WOW
        mov     LMHadPEDLL,0
        mov     hPrevInstance,0
lm_restart:
endif
        xor     ax,ax
;	mov	hExe,ax
	mov	pExe,ax
	mov	abortresult,ax		; default 0 == out of memory
	mov	ffont,ax
	mov	fexe,ax
ifdef notyet
	mov	dll,ax
endif
	mov	hBlock,ax
	mov	hTDB,ax
if ROM
	mov	selROMHdr,ax
	mov	fLoadFromDisk, ax	; PATCHING
	mov	fReplaceModule, ax
endif

; Some flags are default -1
	dec	ax
	mov	fh, ax
	mov	SavePDB, ax

; First, see if we were passed in a handle in the filename
        les     si,lpModuleName         ; point to the file name
	mov	ax,es
	or	ax,ax			; Was a  handle passed in low word?
	jnz	@F
	cCall	GetExePtr,<si>		; Valid handle?
	or	ax, ax
	jnz	prev_instance
	mov	al, LME_FNF		; call this file not found??
        jmp     ilm_ret

; No handle, see if filename is already loaded
@@:     call    LMAlreadyLoaded         ; es:si -> modname on stack
	cmp	ax, LME_MAXERR
	jb	@F			; Not found, try to load it

; a 16-bit module with the same name is loaded
; if module is being loaded is a dll, use the loaded instance
; else if module is being loaded is a task
;         if it is a 32-bit task then load it from disk
;         else use the loaded instance


ifdef WOW
        mov     hPrevInstance, ax       ; store previous instance handle
        mov     ax,lpPBlock.off         ; check if this is a dll or a task
        and     ax,lpPBlock.sel         
        inc     ax
        jnz     @F                      ; non-zero means it is a task
                                        ; so check first if it is a 16-bit task
prev_instance_16task:
        mov     ax, hPrevInstance
endif
prev_instance:
	call	LMPrevInstance
        jmp     ilm_ret

; Wasn't loaded, see if we can load it
@@:     call    LMLoadExeFile           ; fh in DI, AX = 0 or error code
        or      ax, ax
        jz      @F
        jmp     ilm_ret                 ; can't find it - return error
@@:

if ROM
	mov	ax, di
	cmp	di, -1
	jnz	lm_disk_exe_header
	mov	ax, selROMHdr
lm_disk_exe_header:

; Here to deal with a new library or task module.
; We found the file, now load and scan the header
@@:	lea	si,namebuf
	cCall	LoadExeHeader,<ax,di,ss,si>
	cmp	ax,LME_MAXERR
	jb	ilm_ret

	cmp	di, -1
	jnz	lm_disk_header_loaded

	or	es:[ne_flags], NEMODINROM
lm_disk_header_loaded:
else

; Here to deal with a new library or task module.
; We found the file, now load and scan the header
@@:	lea	si,namebuf
        cCall   LoadExeHeader,<di,di,ss,si>
ifdef WOW
        cmp     ax,LME_PE
        jne     @F
; If we find the module is a Win32 binary (PE), check to see
; if we're trying to load a task or DLL.  If it's a DLL
; we will continue searching for a Win16 copy of this DLL
; on the path.  If we're unsuccessful we'll eventually
; munge the file not found error code back to LME_PE.

        mov     ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        mov     ax,LME_PE
        jnz     @F  ; have a PBlock, must be doing LoadModule
        cmp     LMHadPEDLL,0
        je      lm_retry_pe
        mov     LMHadPEDLL,0
        mov     OFContinueSearch,0
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Found Win32 DLL again after continuing search."
        jmps    ilm_ret
@@:     jmps    @F
lm_retry_pe:
; Tell OpenFile to restart last search at next search location.
        mov     OFContinueSearch,1
        mov     LMHadPEDLL,1
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Found Win32 DLL, continuing search for Win16 copy."
; Close open Win32 DLL file handle
        cCall   My_lclose,<fh>
; Switch back to caller's PDB
        mov     si, -1
        xchg    si, SavePDB
        mov     Win_PDB, si
        or      fh, -1
        jmp     lm_restart
@@:
endif
        cmp     ax,LME_MAXERR
	jb	ilm_ret

endif

ifdef WOW
        cmp     hPrevInstance, 0    ; if there is a previous 16-bit task
        je      @F                  ; 
        cCall   My_lclose,<fh>      ; close opened file before invoking previous instance
        jmp     prev_instance_16task
endif
; Header is loaded, now see if valid for Windows
@@:     call	LMCheckHeader
	cmp	ax, LME_MAXERR
	jb	ilm_ret

; Now allocate segs, check for special modules, etc
@@:     call	LMRamNMods
	cmp	ax, LME_MAXERR
	jb	ilm_ret

; Load import libraries (scary code here)
@@:	call	LMImports
	cmp	ax, LME_MAXERR
	jb	ilm_ret

; Load and relocate segments
@@:	call	LMSegs
	cmp	ax, LME_MAXERR
	jb	ilm_ret

; Load resources, schedule execution
@@:	call	LMLetsGo

; Everyone comes through ILM_RET - we free the fastload block, etc
ilm_ret:
        call    LMCleanUp
	jmp	LoadModuleEnd


abort_load0:
	pop	fLMdepth
abort_load:
	cmp	fLMdepth, 1		; If a recursive call, nothing
	jne	abort_load_A		; has been incremented!
	cCall	DecExeUsage,<pExe>
abort_load_A:
	cCall	My_lclose,<fh>
	mov	es,pExe
	push	es:[ne_flags]
	cCall	DelModule,<es>
	mov	pExe, 0
	pop	bx
abort_load_B:				; If app, close environment
	test	bx,NENOTP
	jnz	lm_ab
	mov	si, -1
	xchg	si, SavePDB		; Saved PDB?
	inc	si
	jz	@F			;  nope.
	dec	si
	mov	Win_PDB, si		;  yes, restore it
@@:
	mov	si, fLMdepth
	mov	fLMdepth, 0
	cCall   CloseApplEnv,<abortresult,es>
	mov	fLMdepth, bx
lm_ab:	mov	ax, abortresult
	retn
;	add	sp, 2
;	jmps	ilm_ret			; ax = abortresult. (0 normal, 11 fapi)


ifdef WOW
winspool db     "WINSPOOL.EXE"              ; Trying to Load Winspool ?
size_winspool equ $-winspool
        db      0h                          ; NULL Terminate

endif ;WOW

;----------------------------------------------------------------------
;
;	LMAlreadyLoaded - internal routine for LoadModule
;	See if a module is already loaded by looking for the file name
;	or the module name.
;  Entry:
;	ES:SI points to filename
;  Exit:
;	AX = handle of previous instance
;	SS:SI -> uppercase filename
;  Error:
;	AX = error value < LME_MAXERR
;
;-----------------------------------------------------------------------
LMAlreadyLoaded:
; We check if this Module is already loaded.  To do so we get the
;  name off of the end of the string, omitting the extension.

	krDebugOut <DEB_TRACE OR DEB_KrLoadMod>, "Loading @ES:SI"
	cCall	lstrlen,<es,si>		; Get the length of the string.
	or	ax,ax			; NULL string?
	jnz	@F
	mov	al,LME_FNF		; return file not found error
	retn

ifdef FE_SB
;
; Backword search '\' or ':' is prohibited for DBCS version of
; Windows. Some DBCS 2nd byte may have '\' or ':'. So we search
; these characters from beginning of string.
;
@@:
	cld
	mov	bx,si
delinator_loop_DBC:
	lods	byte ptr es:[si]	; fetch a character
	test	al,al
	jz	found_end_DBC
	cmp	al,"\"
	jz	found_delinator_DBC
	cmp	al,'/'
	jz	found_delinator_DBC
	cmp	al,":"
	jz	found_delinator_DBC
	call	FarMyIsDBCSLeadByte	; see if char is DBC...
	jc	delinator_loop_DBC
	inc	si			; skip 2nd byte of DBC
	jmp	delinator_loop_DBC

found_delinator_DBC:
	mov	bx,si			; update delinator pointer
if ROM
	inc	fLoadFromDisk		; PATCHING
endif
	jmp	delinator_loop_DBC
found_end_DBC:
	mov	si, bx			; ES:SI -> beginning of name..
else
@@:	mov	cx,ax
	add	si,ax
	dec	si			; ES:SI -> end of string
	std
delineator_loop:			; look for beginning of name
	lods	byte ptr es:[si]
	cmp	al,"\"
	jz	found_delineator
	cmp	al,'/'
	jz	found_delineator
	cmp	al,":"
	jz	found_delineator
	loop	delineator_loop
	dec	si
if ROM
	dec	fLoadFromDisk		;PATCHING
endif
found_delineator:			; ES:SI -> before name
if ROM
	inc	fLoadFromDisk		;PATCHING
endif
	cld
	inc	si
	inc	si			; ES:SI -> beginning of name
endif
	xor	di,di
	xor	bx,bx
copy_name_loop:
	lods	byte ptr es:[si]	; Copy and capitalize to temp buffer.
	or	al,al
	jz	got_EXE_name
	cmp	al,"."
	jne	@F
	lea	bx,namebuf[di]
ifdef notyet
	cmp	dll, 0			; Was it .DLL and failed to open it?
	jz	@F			;  no, no hacking
	mov	byte ptr es:[si], 'E'	;  yes, change it to .EXE
	mov	word ptr es:[si+1],'EX'
	mov	dll, 0
endif
@@:
ifdef	FE_SB
;
; Do not capitalize if a character is DBC.
;
	call	FarMyIsDBCSLeadByte
	jnc	@F
	call	FarMyUpper		; capitalize if SBC..
	jmps	is_a_SBC
@@:
	mov	namebuf[di],al
	inc	di
	lods	byte ptr es:[si]	; copy 2nd byte also
is_a_SBC:
	mov	namebuf[di],al
else
	call	FarMyUpper
	mov	namebuf[di],al
endif
	inc	di
	jmps	copy_name_loop

; Finally call FindExeInfo to see if it's already loaded!

got_EXE_name:
	cmp	namebuf[di][-2],'NO'	; .fons are allowed to be
	jnz	@F			; non protect mode
	cmp	namebuf[di][-4],'F.'
	jnz	@F
	mov	ffont,bp		; make non-zero
@@:
	cmp	namebuf[di][-2],'EX'	; .exes will not get
	jnz	@F			;  prompted
	cmp	namebuf[di][-4],'E.'
	jnz	@F
	mov	fexe,bp 		; make non-zero
@@:
ifdef	NOTYET
	cmp	namebuf[di][-2],'LL'
	jne	@F
	cmp	namebuf[di][-4],'D.'
	jne	@F
	mov	dll, di
@@:
endif
ifdef WOW

; apps will expect to find WINSPOOL.DRV, which is a 32-bit driver.
; we need to intercept this and change it WINSPOOL.EXE, which is our 16-bit
; stub that contains a few entrypoints.

if 0
        ; Bitstreams's MakeUp extracts the printer driver from the [devices]
        ; section of win.ini    the line looks like this:
        ;    HP Laserjet Series II=winspool,FILE:
        ; and then it calls LoadLibrary(drivername)  ie LoadLibrary("winspool")
        ; so we need to allow no extension when checking for "winspool"
endif

	cmp	namebuf[di][-2],'VR'
        jne     checkfornoext
	cmp	namebuf[di][-4],'D.'
        jne     @f

        jmp     short gotadrv

checkfornoext:
   ;     int     3
        cmp     di,8
        jc      @f
        cmp     namebuf[di][-2],'LO'
        jne     @f
        cmp     namebuf[di][-4],'OP'
        jne     @f
        cmp     namebuf[di][-6],'SN'
        jne     @f
        cmp     namebuf[di][-8],'IW'
        jne     @f

        ; the last 8 characters are 'WINSPOOL'.  tack on '.EXE' and proceed.

        add     di,4
        mov     namebuf[di][-2],'EX'    ; Changed Uppercased String
        mov     namebuf[di][-4],'E.'

        push    cx
        mov     lpModuleName.hi,cs
	lea	cx,winspool		;
	mov	lpModuleName.lo,cx
        pop     cx
        jmp     short @f

gotadrv:
	push	es
	push	ds
	push	si
	push	cx
	push	di

	smov	es,ss
        lea     di,namebuf[di][-(size_winspool)]
	smov	ds,cs
        lea     si,winspool
        mov     cx,size_winspool-4      ; match WINSPOOL?
	rep	cmpsb

	pop	di
	jnz	not_winspool

	mov	namebuf[di][-2],'EX'	; Changed Uppercased String
	mov	namebuf[di][-4],'E.'

	mov	lpModuleName.hi,cs	; Used by Myopenfile below
	lea	cx,winspool		;
	mov	lpModuleName.lo,cx

not_winspool:
	pop	cx
	pop	si
	pop	ds
	pop	es
@@:
endif; WOW
	mov	namebuf[di],al		; Null terminate file name
	lea	si,namebuf
	push	bx
	cCall	FindExeFile,<ss,si>
	pop	bx
	or	ax,ax
	jnz	al_end
	or	bx,bx			; extension specified?
	jz	@F			; No, DI correct then
	sub	bx,si			; DI = length of name portion
	mov	di,bx
@@:
	cCall	FindExeInfo,<ss,si,di>
al_end:
	retn

;----------------------------------------------------------------------
;
;	LMLoadExeFile - internal routine for LoadModule
;	Try to open an EXE file
;  Enter:
;	SS:SI -> uppercase filename
;  Exit:
;	AX=0
;	DI = fh = handle of open EXE file
;  Error:
;  	AX = error code
;  Effects:
;	Set Win_PDB to kernel PDB to open the file
;
;-----------------------------------------------------------------------
; if here then not yet loaded, see if we can open the file
LMLoadExeFile:
if ROM
	cCall	<far ptr FindROMExe>,<ss,si>	; Module exist in ROM?
	mov	selROMHdr,ax			; selector mapping ROM
	or	ax,ax				;   copy of EXE header if yes
	jz	@F
					; PATCHING
	cmp	fLoadFromDisk, 0	; Loading this from disk?  If so, go
	jz	in_rom
@@:	jmp	not_in_rom		; do it, but remember selROMHdr
					; cause that's what we're patching
in_rom:
	smov	es,ss			; LoadExeHeader expects an OPENSTRUC
	cCall	lstrlen,<es,si> 	;   containing the module file name.
	add	si,ax			;   namebuf (ss:si) already contains
	.erre	opFile			;   a capitalized name string, shift
	lea	di,[si].opFile		;   it down to make room for the other
	mov	bx,di			;   OPENSTRUC fields.
	mov	cx,ax
	inc	cx
	std
	rep movs byte ptr es:[di],es:[si] ; I don't think this is safe!

	.errnz	opLen
	lea	si,namebuf		; Now set the length field, doesn't
	sub	bx,si			;   include terminating null
	mov	es:[si].opLen,bl

	.erre	opFile-1
	lea	di,[si.opLen+1] 	; Zero out fields between length and
	mov	cx,opFile-1		;   the file name
	xor	al,al
	cld
	rep stosb

	mov	di,-1					; no file handle in di
	sub	ax, ax					; 0 => success

	retn

not_in_rom:
endif
	mov	ax, topPDB
	xchg	Win_PDB, ax		; Switch to Kernel's PDB,
	mov	SavePDB, ax		; saving current PDB
	xor	ax,ax
ifdef notyet
	cmp	dll, ax 		; Don't prompt for .DLL, if it fails we
	jnz	@F			; try for .EXE which we will prompt for
endif
	cmp	fexe,ax                 ; Don't prompt for EXE file
	jnz	@F
	mov	ax,OF_CANCEL		; If DLL, let them cancel
	mov	es,curTDB
	test	es:[TDB_ErrMode],08000h ; did app say not to prompt??
	jnz	@F
	mov	ax,OF_CANCEL or OF_PROMPT 
@@:
if SHARE_AWARE
	or	ax, OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
	or	ax, OF_NO_INHERIT
endif
ifdef WOW
        ; Ask WOW32 to check the filename to see if it is
        ; a Known DLL,
        ;
        ; If it is, WowIsKnownDLL will point pszKnownDLLPath
        ; at a just-allocated buffer with the full path to
        ; the DLL in the system32 directory and return with
        ; AX nonzero.  This buffer must be freed with a
        ; call to WowIsKnownDLL with the filename pointer
        ; zero, and pszKnownDLLPath as it was left by the
        ; first call to WowIsKnownDLL.
        ;
        ; If it's not a known DLL, pszKnownDLLPath will be
        ; NULL and AX will be zero.

        push    ax
        cmp     fBooting,0              ; Known DLLs take effect
        je      lef_look_for_known_dll  ; after booting is complete.

        mov     fKnownDLLOverride,0     ; We're booting, make sure
        jmps    lef_dll_not_known       ; we know not to call
                                        ; WowIsKnownDLL the second time.

lef_look_for_known_dll:
        push    si
        smov    es,ss
        lea     bx,pszKnownDLLPath
        cCall   WowIsKnownDLL,<lpModuleName,esbx>
        mov     fKnownDLLOverride,ax
        cmp     ax,0
        pop     si
        je      lef_dll_not_known

        pop     ax
        cCall   MyOpenFile,<pszKnownDLLPath,ss,si,ax>
        jmps    @f

lef_dll_not_known:
        pop     ax
        cCall   MyOpenFile,<lpModuleName,ss,si,ax>
@@:
else
        cCall   MyOpenFile,<lpModuleName,ss,si,ax>
endif

ifdef notyet
	mov	di, dll
	or	di, di
	jz	no_second_chance
	cmp	ax, -1
	jne	no_second_chance	; open succeeded
	xchg	ax, SavePDB		; Restore original PDB	(AX == -1)
	mov	Win_PDB, ax	   
	les	si, lpModuleName
	pop	ax
	jmp	pointer_to_name		; Start again!
no_second_chance:
endif
	xor	dh, dh
	mov	dl, ss:[si].opDisk
	mov	OnHardDisk, dx
	mov	fh,ax
	mov	di,ax			; DI gets preserved, AX doesn't!
	inc	ax			; -1 means error or invalid parsed file
	mov	ax, 0
	jnz	@F			; OK, return 0
					; MyOpenFile failed
	mov	ax,ss:[si].[opXtra]	; SI = &namebuf
	or	ax,ax			; What is the error value?
	jnz	@F
	mov	ax,LME_FNF		; unknown, call it file not found
@@:
ifdef WOW
        push    ax
        mov     ax,fKnownDLLOverride
        cmp     ax,0
        je      lef_no_need_to_free

        push    bx
        push    dx
        push    di

        smov    es,ss
        lea     bx,pszKnownDLLPath
        cCall   WowIsKnownDLL, <0,0,esbx>

        pop     di
        pop     dx
        pop     bx
lef_no_need_to_free:
        pop     ax
endif
	retn

;----------------------------------------------------------------------
;
;	LMCheckHeader - internal routine for LoadModule
;	Loading new module - see if header values are OK
;  Enter:
;	ax = exeheader in RAM
;	bx = 0 or FastLoad ram block selector
;	cx = file offset of header
;	dx = exe_type
;  Exit:
;
;
;-----------------------------------------------------------------------
LMCheckHeader:
	mov	exe_type,dx
	mov	hBlock,bx		; fast-load block
	mov	pExe,ax			; exeheader in RAM
	mov	es,ax
	mov	ax, cx			; file offset of header
	mov	cx, es:[ne_align]
	mov	bx, ax			; BX:AX  <=  AX shl CL
	shl	ax, cl
	neg	cl
	add	cl, 16
	shr	bx, cl

	mov	FileOffset.sel, bx
	mov	FileOffset.off, ax
if ROM
	test	es:[ne_flags], NEMODINROM
	jnz	@F
	cmp	selROMHdr, 0
	jnz	ch_patch_file
@@:	jmp	ch_not_patch_file

ch_patch_file:
	test	es:[ne_flagsothers], NEGANGLOAD
	jnz	ch_replace_mod
if 0
	; ack: loadexeheader trashes this...
	mov	ax, es:[ne_cseg]
	mov	ah, 2
	cmp	ax, es:[ne_gang_start]
endif
	jz	ch_check_rom_header

	; here for a replacement file with matching file name
ch_replace_mod:
	inc	fReplaceModule
	jmp	ch_not_patch_file

ch_check_rom_header:
	push	ds
	push	si

	mov	cx, es:[ne_cseg]
	mov	ds, selROMHdr

	; make sure that the various patching flags match up to
	; what they are supposed to be

	; RIB clears this bit, check
	test	ds:[ne_flagsothers], NEGANGLOAD
	jnz	ch_patch_error

	; does it have a patch table
	test	byte ptr ds:[ne_gang_start+1], 1
	jnz	ch_is_patchable

	; if no one links to this file, its ok, don't need to patch
	test	byte ptr ds:[ne_gang_start+1], 4
	jnz	ch_patch_error

ch_not_really_a_patch_file:
	pop	si
	pop	ds
	jmp	ch_not_patch_file

ch_patch_error:
	pop	si
	pop	ds
	mov	ax, LME_INVEXE
	retn

ch_is_patchable:
	; must be the right segment
	mov	ax, ds:[ne_cseg]
	cmp	al, byte ptr ds:[ne_gang_start]
	jnz	ch_patch_error
    
ch_whack_segment_table:
	mov	si, ds:[ne_segtab]
	mov	bx, es:[ne_segtab]

ch_ps_patch_loop:
	test	es:[bx].ns_flags, NSINROM
	jz	ch_patch_loop_pass
	mov	ax, ds:[si].ns_flags
	and	ax, NSCOMPR or NSRELOC or NSLOADED or NSALLOCED
	or	es:[bx].ns_flags, ax

	mov	ax, ds:[si].ns_cbseg
	mov	es:[bx].ns_cbseg, ax

	mov	ax, ds:[si].ns_minalloc
	mov	es:[bx].ns_minalloc, ax

	mov	ax, ds:[si].ns_sector
	mov	es:[bx].ns_sector, ax
	test	es:[bx].ns_flags, NSLOADED
	jz	ch_patch_loop_pass
	cmp	es:[bx].ns_handle, 0
	jnz	ch_patch_loop_pass
	mov	es:[bx].ns_handle, ax
ch_patch_loop_pass:
	add	si, size new_seg
	add	bx, size new_seg1
	loop	ch_ps_patch_loop

	pop	si
	pop	ds
ch_not_patch_file:
endif

; Is this module PMode-compatible?
	cmp	es:[ne_expver],300h	; by definition
	jae	@F
	test	dh,NEINPROT		; by flag
	jnz	@F
	cmp	ffont,0 		; are we loading a font?
	jnz	@F
	mov	cx,ss
	lea	bx,namebuf
	call	WarnRealMode
	cmp	ax,IDCANCEL
	jnz	@F			; yes, user says so
	mov	ax, LME_RMODE		; no, die you pig
	retn

ifdef WOW
@@:
        ;
        ; if WOA invoked by app (not fWOA) fail it
        ;
        cmp     fWOA,0                  ; fWOA
        jnz     @F

        cld
        push    si
        push    di
        mov     di, es:[ne_restab]
        inc     di
        mov     si, dataOffset WOAName
        mov     cx, 4
        repe    cmpsw
        pop     di
        pop     si
        jnz     @F
        mov     ax, LME_WOAWOW32
        retn
endif

; Are we dynalinking to a task?
@@:


        test    es:[ne_flags],NENOTP
	jnz	ch_not_a_process
	or	es:[ne_flags],NEINST	; for safety sake
	mov	ax,lpPBlock.off
	and	ax,lpPBlock.sel
	inc	ax
	jnz	ch_new_application	; not linking
	mov	ax, LME_LINKTASK
	retn

; Error if multiple instance EXE is a library module.
ch_not_a_process:
	mov	ax, 33			; Any value > 32
	test	es:[ne_flags],NEPROT	; is it an OS/2 exe?
	jnz	ch_ok			;  windows doesn't do this right
	test	es:[ne_flags],NEINST
	jz	ch_ok
	mov	ax, LME_LIBMDS		; I think this error code is wrong
ch_ok:
	retn

; Create environment for new application task.
ch_new_application:
        call    LMCheckHeap
	or	ax,ax
	jz	@F
	cCall	OpenApplEnv,<lpPBlock,pExe,fWOA>
	mov	es,pExe
	or	ax,ax			; AX is a selector, therefor > 32
	jnz	ch_ok
@@:
	jmp	abort_load_A


;----------------------------------------------------------------------
;
;	LMRamNMods - internal routine for LoadModule
;	Load segments, check for special modules
;  Enter:
;	EX = pexe


;  Exit:
;	CX = number of import modules
;	AX = status
;
;
;-----------------------------------------------------------------------
LMRamNMods:
	push	es
	cCall	AddModule,<pExe>
	pop	es
	or	ax,ax
	jnz	@F
	push	es:[ne_flags]		; AddModule failed - out of memory
	mov	dx,ne_pnextexe
	mov	bx,dataOffset hExeHead
	call	FarUnlinkObject
	pop	bx
	jmp	abort_load_B		; clean this up

@@:
        cmp     es:[ne_expver],400h
        jae     rm_skip_modulecompat

    ; Look for Module in ModuleCompatibilty section
    ; and get its compat flags
    push    es          ; save es
    push    ds
    push    dataoffset szModuleCompatibility
    push    es
    mov bx,es:[ne_restab]   ; module name is 1st rsrc
    inc bx          ; Skip length byte
    push    bx
    xor ax, ax
    push    ax          ; default = 0
    call    GetProfileInt
@@:
    pop es          ; restore es
        ; Set the module's patch bit if the INI file says to.
if KDEBUG
        test    es:[ne_flagsothers], NEHASPATCH
        jz      @F
        push    ax
        mov     ax, es:[ne_restab]
        inc     ax
        krDebugOut  DEB_TRACE,"ILoadModule: module patch bit for @es:ax already set, clearing it"
        pop     ax
@@:
endif
        and     es:[ne_flagsothers], not NEHASPATCH     ; clear module patch bit
ifdef WOW_x86
        test    ax, MCF_MODPATCH + MCF_MODPATCH_X86
else
        test    ax, MCF_MODPATCH + MCF_MODPATCH_RISC
endif
        jz      rm_after_modpatch
if KDEBUG
        push    ax
        mov     ax, es:[ne_restab]
        inc     ax
        krDebugOut  DEB_WARN,"ILoadModule: setting module patch bit for @es:ax"
        pop     ax
endif
        or      es:[ne_flagsothers], NEHASPATCH
rm_after_modpatch:

        ; See if we need to make the module's segments not discardable
        test    ax, MCF_NODISCARD
        jz      rm_after_nodiscard

        mov     cx, es:[ne_cseg]                ; cx = number of segs
        jcxz    rm_after_nodiscard
        mov     bx, es:[ne_segtab]              ; es:bx = seg table start
rm_loop:
        and     es:[bx].ns_flags, not NSDISCARD ; clear the discard flag
        add     bx, SIZE NEW_SEG1               ; es:bx = seg table next entry
        loop    rm_loop
rm_after_nodiscard:

rm_skip_modulecompat:

    mov bx, -1
if ROM
	cmp	bx,fh
	jz	@F
endif
	cCall	FarGetCachedFileHandle,<es,bx,fh>	; Set file handle cache up
	mov	fh, bx			; Use cached file handle from now
	xchg	SavePDB, bx		; Back to original PDB (BX == -1)
	mov	Win_PDB, bx
@@:	xor	bx,bx
	mov	hDepFail,-1		 ; Assume success
	mov	cx,es:[bx].ne_cmod
	jcxz	@F
	test	kernel_flags,KF_pUID	; All done booting?
	jnz	@F			; Yes
	or	es:[bx].ne_flags,NEALLOCHIGH ; No, GDI and USER are party
					     ; dynlinks that can alloc high
@@:	xor	ax,ax
IFNDEF NO_APPLOADER
	test	es:[ne_flags],NEAPPLOADER
	jnz	rm_no_segs_to_alloc
ENDIF
	cmp	ax,es:[ne_cseg]
	jz	rm_no_segs_to_alloc
	push	es
	mov	es:[ne_usage],1
	cCall	AllocAllSegs,<es>	; AX is count of segs
	pop	es
	mov	es:[ne_usage],8000h
	inc	ax
	jnz	@F
	jmp	abort_load
@@:
	dec	ax
rm_no_segs_to_alloc:
	mov	AllocAllSegsRet, ax

	xor	bx, bx
	mov	di,es:[bx].ne_modtab	 ; ES:DI = pModIdx
	mov	cx,es:[bx].ne_cmod
	or	cx,cx
	jz	lm_ret_ok

; this small chunk of code goes thru the imported names table
; and looks for DOSCALLS.  if DOSCALLS is found, then the app
; is an FAPI "bound" application and not a windows app, and
; loadmodule should return an error for "invalid format".
; This will force it to run in a DOS box
; coming in:
;   cx = cmod
;   di = modtab

	test	es:[bx].ne_flags,NENOTP ; only test apps, not libraries.
	jnz	lm_ret_ok
        mov     ax,exe_type             ; UNKNOWN may be OS/2 in disguise.
	cmp	al,NE_UNKNOWN
	jnz	@F
	push	ds
	smov	ds,cs
	mov	ax,8
	mov	si,NRESCODEoffset os2calls ; DS:SI = "DOSCALLS"
	call	search_mod_dep_list
	pop	ds
	jnc	@F
	mov	abortresult,LME_INVEXE	; store invalid format code for return
	jmp	abort_load

; In order to make it easier on our ISV to migrate to pmode
;  we must deal with win87em specially because the win 2.x
;  version gp faults.  Since we have never shipped them a clean
;  one to ship with their apps we must compensate here.
; If we are loading a win 2.x app in pmode we force the load
;  of win87em.dll.  For compatibility in real mode we just load
;  the one they would have gotten anyway.

@@:	cmp	es:[bx].ne_expver,300h	; no special casing win3.0 apps
	jae	rm_no_win87em_here

	push	ds
	smov	ds,cs
	mov	ax,7
	mov	si,NRESCODEoffset win87em ; DS:SI = "WIN87EM"
	call	search_mod_dep_list
	pop	ds
	jnc	rm_no_win87em_here
	push	bx			; Load Win87em.dll
	push	es
	cCall	ILoadLibrary,<cs,si>
	cmp	ax,LME_MAXERR
	jae	@F
	mov	hDepFail,ax
@@:	pop	es
	pop	bx
rm_no_win87em_here:
lm_ret_ok:
	mov	di,es:[bx].ne_modtab	; ES:DI = pModIdx
	mov	cx,es:[bx].ne_cmod	; What is AX?
	mov	ax, es
	retn

;----------------------------------------------------------------------
;
;	LMImports - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMImports:
	or	cx, cx
	jnz	im_inc_dependencies_loop
	jmp	im_end_dependency_loop
im_inc_dependencies_loop:
	push	cx
	mov	si,es:[di]
	push	es
	or	si,si
	jz	im_next_dependencyj
	add	si,es:[ne_imptab]	; ES:SI = pname
	xor	ax,ax
	mov	al,es:[si]		; get length of name
	inc	si
	mov	cx, ax
	mov	bx, es			; pExe

;;;; Load the imported library.

	push	ds			; Copy the name and .EXE to namebuf
	push	di
	smov	es,ss
	mov	ds,bx
	UnSetKernelDS
	lea	di,namebuf
	mov	bx,di	
	cld
	rep	movsb
	mov	byte ptr es:[di], 0		; Null terminate
	push	bx
	push	es
	cCall	GetModuleHandle,<es,bx>
	pop	es
	pop	bx
	or	ax, ax
	jz	@F
	pop	di
	pop	ds
	jmps	im_imported_exe_already_loaded
	
@@:	cmp	ds:[ne_expver], 300h	; USE .DLL for 3.0, .EXE for lower
	jae	im_use_dll

	mov	es:[di][0],"E."
	mov	es:[di][2],"EX"
	jmps	im_done_extension
im_use_dll:
	mov	word ptr ss:[di][0],"D."
	mov	word ptr ss:[di][2],"LL"
im_done_extension:
	mov	byte ptr es:[di][4],0
			   
	pop	di
	pop	ds
	ResetKernelDS
	cCall	ILoadLibrary,<ss,bx>
	cmp	ax,LME_MAXERR
	jae	im_imported_exe_loaded
	mov	hDepFail,ax
	xor	ax,ax
im_next_dependencyj:
	jmps	im_next_dependency

im_imported_exe_already_loaded:
;;;	push	ax
;;;	cCall	IncExeUsage,<ax>
;;;	pop	ax

im_imported_exe_loaded:
	cCall	GetExePtr,<ax>
	mov	es,ax
	assumes es,nothing			; assume that dep libraries
	or	es:[ne_flags],NEALLOCHIGH	;  are smart

im_next_dependency:
	pop	es
	assumes es,nothing
	mov	es:[di],ax
	inc	di
	inc	di
	pop	cx
	dec	cx
	jz	im_end_dependency_loop
	jmp	im_inc_dependencies_loop

im_end_dependency_loop:
	mov	es:[ne_usage], 0
	cmp	fLMdepth, 1
	jne	@F
	push	es				; Now set usage count of this
	cCall	IncExeUsage,<es>		; module and dependants
	pop	es
@@:
	mov	cx,hDepFail
	inc	cx
	jz	im_libs_ok
	dec	cx
	mov	abortresult,cx
im_abort_loadj:
	jmp	abort_load
im_libs_ok:
	retn

;----------------------------------------------------------------------
;
;	LMSegs - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMSegs:
; Do something about all those segments in the module.

IFNDEF NO_APPLOADER
	test	es:[ne_flags],NEAPPLOADER
	jz	@F
;*	* special boot for AppLoader
	push	Win_PDB
	push	fLMdepth
	mov	fLMdepth, 0
	mov	ax, -1
	cCall	FarGetCachedFileHandle,<es,ax,ax>
	Save	<es>
	cCall	BootAppl,<es, ax>	;* returns BOOL
	cCall	FlushCachedFileHandle,<es>
	pop	fLMdepth      
	pop	Win_PDB
	or	ax,ax
	jnz     lms_done
	jmp	abort_load
;	retn
@@:
ENDIF ;!NO_APPLOADER

	mov	cx, AllocAllSegsRet
	jcxz	lms_done

lms_preload_segments:

	mov	si,es:[ne_segtab]	; ES:SI = pSeg
	mov	cx,es:[ne_cseg]
	xor	di,di
lms_ps_loop:
	inc	di
if ROM
	mov	bx,es:[si].ns_flags	; Load the segment now if it's execute
	and	bx,NSINROM OR NSLOADED	;   in place in the ROM.
	cmp	bx,NSINROM OR NSLOADED
	je	lms_ReadFromRom
endif
	test	es:[si].ns_flags,NSPRELOAD
	jz	lms_next_segment
if ROM
	test	byte ptr es:[si].ns_flags+1,(NSINROM SHR 8)
	jnz	lms_ReadFromRom
endif
	cmp	es:[ne_align], 4	; Must be at least paragraph aligned
	jb	lms_ReadFromFile
	cmp	hBlock, 0
	jne	lms_ReadFromMemory
	jmps	lms_ReadFromFile

lms_next_segment:
	add	si,SIZE new_seg1
	loop	lms_ps_loop
lms_done:
	retn

if ROM
lms_ReadFromRom:
	push	cx
	push	es
	cCall	FarLoadSegment,<es,di,0,-1>
	jmps	lms_DoneLoad
endif

lms_ReadFromFile:
	push	cx
	push	es
	cCall	FarLoadSegment,<es,di,fh,fh>
	jmps	lms_DoneLoad

lms_ReadFromMemory:
	push	cx
	push	es
	cCall	GlobalLock,<hBlock>
	or	dx, dx
	jnz	lms_still_here
	cCall	GlobalFree,<hBlock>
	mov	hBlock, 0
	pop	es
	pop	cx
	jmps	lms_ReadFromFile

lms_still_here:
ifdef WOW
	cCall	AllocSelectorWOW,<dx>  ; same as allocselector. but the 
        mov     RefSelector, dx        ; new descriptor is not set.
else
	cCall	AllocSelector,<dx>
endif
	pop	es
	mov	bx, es:[si].ns_sector
	xor	dx, dx
	mov	cx, es:[ne_align]
	push	es
@@:
	shl	bx, 1
	rcl	dx, 1
	loop	@B

	sub	bx, off_FileOffset
	sbb	dx, seg_FileOffset
	push	ax
	push	es
ifdef WOW
        ; same as longptradd. but the descriptor 'RefSelector' is used 
        ; to set the descriptor of 'ax'
	cCall	LongPtrAddWOW,<ax,cx,dx,bx, RefSelector, 1>	; (cx is 0)
else
	cCall	LongPtrAdd,<ax,cx,dx,bx>	; (cx is 0)
endif
	pop	es
	dec	cx
	cCall	FarLoadSegment,<es,di,dx,cx>
	pop	cx
	push	ax
	cCall	FreeSelector,<cx>
	cCall	GlobalUnlock,<hBlock>
	pop	ax
lms_DoneLoad:
	pop	es
	pop	cx
	or	ax,ax
	jz	lms_abort_load1
	jmp	lms_next_segment
lms_abort_load1:
	jmp	abort_load

;-----------------------------------------------------------------------
;
;	LMLetsGo -
;
;-----------------------------------------------------------------------
LMLetsGo:
	push	es
	push	Win_PDB			; Save current PDB
	push	topPDB			; Set it to Kernel's
	pop	Win_PDB
if ROM
	;
	;   the cases are:
	;
	;   1 loading a ROM module:
	;	selROMHdr <> 0, fLoadFromDisk == fReplaceModule == 0
	;
	;   2 loading a patch module:
	;	selROMHdr, fLoadFromDisk <> 0, fReplaceModule == 0
	;
	;   3 loading an override module with same name:
	;	selROMHdr <> 0, fReplaceModule <> 0, fLoadFromDisk == ?
	;
	;   4 loading an override module with a different name:
	;	selROMHdr == fReplaceModule == 0
	;
	;   5 loading a module not in rom at all
	;	selROMhdr == fReplaceModule == 0

	;   is it case 4 or 5

	mov	ax, selROMHdr
	or	ax, fReplaceModule
	jnz	lg_no_rom_header

	; never replace a process
	test	es:[ne_flags],NENOTP
	jz	lg_file_load_res

	push	es
	cCall	<far ptr FindROMModule>, <es>
	pop	es

	;   is it case 5
	inc	ax				; -1 = not found
	jz	lg_file_load_res
	dec	ax				; 0 = couldn't alloc selector
	jnz	lg_found_rom_same_name

	; ax == 0 => out of memory
	mov	ax, LME_MEM
	retn

lg_found_rom_same_name:
	mov	selROMHdr, ax
	mov	fReplaceModule, ax

lg_no_rom_header:
	;   is it case 3 or 4
	cmp	fReplaceModule, 0
	jz	@F

	push	es
	cCall	<near ptr ReplacePatchTable>, <es,selROMHdr>
	pop	es
	or	ax, ax
	jmp	lg_file_load_res

	;   is it case 1 or 2?
	sub	cx, cx
@@:	cmp	fLoadFromDisk, 0
	jz	lg_resFromFile

	; loading a patch file; set the patch table selector, then
	; fall through to load resources
	push	ds
	mov	ds, selROMHdr
	mov	si, ds:[ne_cseg]
	dec	si
	shl	si, 3
	add	si, ds:[ne_segtab]
	mov	bx, ds:[si].ns_sector
	pop	ds

	.errnz 2 + size new_seg - size new_seg1
	; also assumes both exehdrs have same ne_segtab!!!!

	add	si, es:[ne_cseg]
	add	si, es:[ne_cseg]
	sub	si, 2
	mov	ax, es:[si].ns_handle
	Sel_To_Handle ax

	cCall	ChangeROMHandle, <ax,bx>
	mov	es:[si].ns_handle, bx

lg_file_load_res:
endif
	mov	ax, -1
	cCall	FarGetCachedFileHandle,<es,ax,ax>
if ROM
	mov	cx, selROMHdr
endif
	cmp	hBlock,0
	je	lg_resFromFile

if ROM
	cCall	PreloadResources,<es,ax,hBlock,FileOffset,0>
else
	cCall	PreloadResources,<es,ax,hBlock,FileOffset>
endif
	jmps	lg_gotRes

lg_resFromFile:
	xor	dx, dx
if ROM
	cCall	PreloadResources,<es,ax,dx,dx,dx,cx>
else
	cCall	PreloadResources,<es,ax,dx,dx,dx>
endif
lg_gotRes:
	pop	Win_PDB			; Restore PDB
	pop	es
	mov	ax,lpPBlock.off
	mov	dx,lpPBlock.sel
	and	ax,dx
	inc	ax
	jnz	lg_huh
	mov	lpPBlock.off,ax
	mov	lpPBlock.sel,ax
lg_huh:	xor	ax,ax			; free 0
	push	fLMdepth
	mov	fLMdepth, 0
	push	es
	cCall	StartModule,<ax,lpPBlock,es,fh>
	pop	es
	mov	hResult,ax
	or	ax,ax
	jnz	@F
	jmp	abort_load0

@@:	test	es:[ne_flags],NENOTP
	jnz	lg_not_a_process2

	pop	si
	cCall	CloseApplEnv,<hResult,pExe>
	push	bx
	mov	hResult,ax
	mov	hTDB,dx
lg_not_a_process2:
	pop	fLMdepth
	retn


;----------------------------------------------------------------------
;
;  LMPrevInstance - internal routine for LoadModule
;	Load an app/dll if a previous instance in memory
;  Entry:
;	ax = handle of previous instance
;  Exit:
;	ax = status to return
;	dx = hTDB = TDB
;  Error:
;	ax < LME_MAXERR
;
;-----------------------------------------------------------------------
LMPrevInstance:
	mov	es,ax
	mov	dx,es:[ne_flags]
	mov	si,ax
	mov	pExe,ax			; why store in pExe and hExe?
	mov	hResult,0

if ROM
; Error if multiple instance of ROM app with instance or auto data
; (actually this might be okay if there are no entry points that need
;  to be patched--would require checks like in PatchCodeHandle).

	test	dh,(NENOTP SHR 8)	; okay if not a process
	jnz	@F
	test	dl,NEMODINROM		; module in rom?
	jz	@F

	test	dl,NEINST		; app have instance data?
	jnz	pi_mds
	cmp	es:[ne_autodata],0	; how about an autodata segment?
	jnz	pi_mds			; can't patch the ROM code so can't
					;   run the 2nd instance
@@:
endif

; Error if dynamically linking to non-library module.
	mov	ax,lpPBlock.off
	and	ax,lpPBlock.sel
	inc	ax
	jnz	pi_app
	test	dx,NENOTP
	jnz	@F
	mov	ax, LME_LINKTASK	; can't dynalink to a task
	retn

@@:	mov	lpPBlock.off,ax		; AX == 0
	mov	lpPBlock.sel,ax
pi_app:
	test	dx,NEINST
	jnz	@F
	jmp	pi_not_inst
@@:	call	LMCheckHeap
	or	ax, ax
	jnz	@F
	mov	ax, LME_MEM		; Out of (gdi/user) memory
        retn
@@:

ifdef WOW
        ;
        ; if WOA invoked by app (not fWOA) fail it
        ;
        cmp     fWOA,0                  ; fWOA
        jnz      pi_not_multiple_data

        cld
        push    si
        push    di
        mov     di, es:[ne_restab]
        inc     di
        mov     si, dataOffset WOAName
        mov     cx, 4
        repe    cmpsw
        pop     di
        pop     si
        jnz     @F
        mov     ax, LME_WOAWOW32
        retn
@@:
endif



; We refuse to load multiple instances of apps that have
;  multiple data segments.  This is because we cannot do
;  fixups to these other data segments.  What happens is
;  that the second copy of the app gets fixed up to the
;  data segments of the first application.  For the case
;  of read-only data segments we make an exception since
;  what does it matter who the segments belong to?

        mov     ax, 2                   ; if we have >= 2 dsegs we die
	mov	es,si
	mov	cx,es:[ne_cseg]
	mov	bx,es:[ne_segtab]
pi_next_seg:
	test	es:[bx].ns_flags,NSDATA ; scum! this barely works!
	jz	@F
	test	es:[bx].ns_flags,NSERONLY
	jnz	@F
	dec	ax
	jnz	@F			; two data segments is one too many!
pi_mds:	mov	ax, LME_APPMDS
	retn

@@:	add	bx,SIZE NEW_SEG1
	loop	pi_next_seg

pi_not_multiple_data:			; Prepare the application
	cCall	OpenApplEnv,<lpPBlock,si,fWOA>
	cCall	GetInstance,<si>	; Why do we call this?
	mov	di,ax
	cCall	IncExeUsage,<si>
	cCall	AllocAllSegs,<si>	; Can we get memory?
	inc	ax
	jnz	@F
	cCall	DecExeUsage,<si>	; AllocAllSegs failed, Dec Usage
	jmps	pi_mem			; Must have failed from no memory

@@:	mov	ax,-1
	cCall	StartModule,<di,lpPBlock,si,ax>
;	mov	hResult,ax
	or	ax,ax
	jnz	@F
	mov	es,si			; StartModule failed, FreeModule
	mov	si,es:[ne_pautodata]
	cCall	FreeModule,<es:[si].ns_handle>
pi_mem:	mov	ax, LME_MEM
	retn

@@:	mov	si, fLMdepth
	mov	fLMdepth, 0
	cCall	CloseApplEnv,<ax,pExe>
	mov	fLMdepth, bx
	mov	hTDB,dx
	retn

pi_not_inst:
	mov	ax,es:[ne_autodata]	; Make sure data segment is loaded.
	or	ax,ax
	jz	@F
	or	bx,-1
	push	es
	cCall	FarLoadSegment,<es,ax,bx,bx>
	pop	es
	or	ax,ax
	jz	pi_end			; yes, AX is already 0, but ...
@@:
	push	es			; for GetInstance
	cCall	IncExeUsage,<es>
	cCall	GetInstance		; ,<pExe>
pi_end:
	retn

;----------------------------------------------------------------------
;
;	LMCleanUp - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMCleanUp:
ifdef WOW
        cmp     LMHadPEDLL,0
        je      @F
        cmp     ax, LME_MAXERR
        jae     @F
        mov     ax,LME_PE               ; Reflect real error we tried to mask
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Could not find Win16 copy of Win32 DLL, returning LME_PE."
@@:
endif
	push	ax			; save status for future
	cmp	ax, LME_MAXERR
	jae	@F
	cCall	my_lclose,<fh>
	or	fh, -1

; Restore PDB if needed
@@:	mov	ax, -1
	xchg	SavePDB, ax
	inc	ax
	jz	@F
	dec	ax
	mov	Win_PDB, ax

; Free FastLoad block if allocated
@@:     cmp	hBlock,0
	je	@F
	cCall	GlobalFree,<hBlock>
	mov	hBlock,0

if ROM
; Free ROM selector if allocated
@@:
	mov	ax,selROMHdr		; FindROMExe allocates a selector
	or	ax,ax			;   to the ROM Exe Header if found.
	jz	@F			;   Free it here.
	cCall	far_free_temp_sel,<ax>
endif

; Free app environment if failure and this was an app
@@:
	pop	ax
	cmp	ax,LME_MAXERR
	jae	@F
if KDEBUG
        cmp     ax, LME_INVEXE          ; invalid format (WinOldAp)
	jz	cu_fred
	cmp	ax, LME_PE		; Win32 Portable Exe - try to load it
	jz	cu_fred
        push    ax
	push	bx
	push	es
	les	bx, lpModuleName
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Error 0x#ax loading @ES:BX"
        pop     es
	pop	bx
        pop     ax
endif
cu_fred:
	cmp	loadTDB,0
	je	@F
	mov	bx,pExe
	cmp	bx,LME_MAXERR		; Did we load an ExeHeader?
	jbe	@F
	mov	es,bx
	test	es:[ne_flags],NENOTP
	jnz	@F
	mov	si, fLMdepth
	mov	fLMdepth, 0
	cCall	CloseApplEnv,<ax,es>
	mov	fLMdepth, bx

; shouldn't cache file handles on removable devices cause it
; makes share barf when the user swaps disks.  this kills some
; install apps.  CraigC 8/8/91
@@:
	push	ax
	cmp	ax, LME_MAXERR 		; real?
	jbe	@F
	cmp	OnHardDisk, 0		; is it on a removable device?
	jne	@F
	cCall	GetExePtr, <ax> 	; get module handle
	cCall	FlushCachedFileHandle, <ax> ; blow it off

;** Log this entry only if in diagnostic mode
@@:
	cmp     fDiagMode,0             ; Only log if in diag mode
	je      LM_NoDiagExit
    cmp     fBooting,0              ; Only log if booting
    je      LM_NoDiagExit

	pop	ax                      ; Get the return code early
	push    ax

	pusha                           ; Save all the registers
	push    ds
	push    es

	;** Write out the appropriate string
	mov     si,ax                   ; Save the return value
	cmp     ax,LME_MAXERR
	jae     LM_DiagSuccess
	mov     ax,dataOFFSET szLoadFail ; Write the string
	jmp     SHORT LM_DiagOutput
LM_DiagSuccess:
	mov     ax,dataOFFSET szLoadSuccess ; Write the string
LM_DiagOutput:
	cCall   DiagOutput, <ds,ax>
	cCall   DiagOutput, <lpModuleName>
	cmp     si,LME_MAXERR		; Don't do this on success
	jae     SHORT LM_DiagSuccessSkip

	;** Log a message complete with the failure code
	mov     ax,si                   ; Get the failure code
	shr	al, 4
	mov     bx,dataOFFSET szCodeString ; Point to the second digit
	push	NREScodeOffset afterHex
	call	toHex
	mov	ax, si
	inc     bx
toHex:
	and     al,0fh                  ; Get low hex digit
	add     al,'0'                  ; Convert to ASCII
	cmp     al,'9'                  ; Letter?
	jbe     @F			; Yes
	add     al,'A' - '0'            ; Make it a letter
@@:	mov     [bx],al                 ; Save the digit
	retn
afterHex:
	mov     ax,dataOFFSET szFailCode ; Get the string 'Failure code is '
	cCall   DiagOutput, <ds,ax>
LM_DiagSuccessSkip:
	mov     ax,dataOFFSET szCRLF
	cCall   DiagOutput, <ds,ax>

	pop     es
	pop     ds
	popa

LM_NoDiagExit:
	pop	ax
	dec	fLMdepth
	mov	dx,hTDB
	retn

;@@end

;shl_ax16:			; shift AX into DX:AX by cl bits
;	mov	dx, ax
;	shl	ax, cl
;	neg	cl
;	add	cl, 16		; cl = 16 - cl
;	shr	dx, cl
;	retn

LoadModuleEnd:                          ; jmp here to clean up stack and RET

ifdef WOW
        cmp     ax, LME_MAXERR
        jb      @F
lmntex:
        jmp     LoadModuleExit
@@:

;
;   Exec For Non 16 Bit Windows Apps
;
        ;
        ; WIN 32S App ?  yes -> let NT load it
        ;
        cmp     ax,LME_PE
        je      LM_NTLoadModule


        ;
        ; if an app is spawning WOA (NOT our internal load-fWOA),
        ; Patch lpModuleName to -1 let NT load it
        ;
        cmp     ax,LME_WOAWOW32
        jne     @F
        mov     word ptr lpModuleName[2], -1    ; patch lpModuleName
        mov     word ptr lpModuleName[0], -1
        jmp short LM_NTLoadModule
@@:

        ; Errors 11-15 -> let NT load it
        cmp     ax,LME_RMODE
        jae     lmntex

        cmp     ax,LME_VERS
        jbe     lmntex


        public  LM_NTLoadModule
LM_NTLoadModule:
;
; WOW Execs non-windows apps using WINOLDAP.
;

; First check for loading of a 32bit DLL. lpPBlock will be -1
; in such a case.

        push    ax
	mov	ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        pop     ax
        jz      LoadModuleExit

;
; This is an EXE, but the LME_PE failure code might have come from
; an implicitly linked DLL.  If so, we don't want to try having
; Win32 lauch the win16 EXE, as it will just come back to us.
;
        cmp     ax,LME_PE
        jne     @F
        cmp     ax,hDepFail
        je      short LoadModuleExit
@@:
        sub     sp, 80                  ; alloc space for cmdline
        mov     di, sp
        smov    es, ss
        mov     word ptr es:[di], 0     ; set WindOldApp CmdLine to NULL
        regptr  esdi,es,di
        cCall   WowLoadModule,<lpModuleName, lpPBlock, esdi>

        ;
        ;  if ax < 33 an error occurred
        ;
        cmp     ax, 33
        jb      ex8

        or      Kernel_flags[1],KF1_WINOLDAP
        mov     ax, ss
        les     si,lpPBlock
        mov     es:[si].lpcmdline.off,di
        mov     es:[si].lpcmdline.sel,ax
        mov     si,dataOffset WOAName
        regptr  dssi,ds,si
        cCall   LoadModule,<dssi, lpPBlock>
        cmp     ax,32                   ; check for error...
        jae     ex8

        ;
        ; LoadModule of WinOldApp failed
        ; Call WowLoadModule to clean up process handle
        ;
        push    ax
        mov     ax, ss
        regptr  axdi,ax,di
        cCall   WowLoadModule,<0, lpPBlock, axdi>
        pop     ax

        cmp     ax,2                    ; file not found?
        jnz     ex7                     ; no, return error
        mov     al, LME_WOAWOW32        ; flag WINOLDAP error
ex7:
        or      ax,ax                   ; out of memory?
        jnz     ex8
        mov     ax,8h                   ; yes, return proper error code
ex8:
        add     sp,80                   ; free space for cmdline
endif; WOW

LoadModuleExit:

cEnd

?DOS5	=	?SAV5

;-----------------------------------------------------------------------;
; My_lclose
;
; Close file handle if it isn't -1.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	My_lclose,<PUBLIC,NEAR>
	parmW	fh
cBegin
	mov	ax,fh
	inc	ax
	jz	mlc_exit

	cCall	_lclose,<fh>
mlc_exit:
cEnd


if ROM

;-----------------------------------------------------------------------;
; FindROMExe
;
; Locates the ROM EXE header for a module in ROM.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	FindROMExe,<PUBLIC,FAR>,<ds,es,di,si>
	parmD	lpFileName
cBegin
	xor	ax,ax				; calculate length of
	mov	cx,-1				;   file name, include
	les	di,lpFileName			;   terminating null in count
	cld
	repne scasb
	not	cx
	jcxz	fre_exit

	cmp	cx,File_Name_Len		; can't be in rom if name
	ja	fre_exit			;   is too long

	call	MapDStoDATA
	ReSetKernelDS

	mov	ds,selROMTOC			; search ROM TOC for matching
	UnSetKernelDS				;   module name
	mov	bx,ds:[cModules]		; # modules in ROM TOC
	mov	ax,ModEntries+FileNameStr	; offset in ROM TOC of 1st name

	les	di,lpFileName
	mov	dx,cx

fre_next:
	mov	si,ax				; search ROM TOC, entry by entry
	push	ax
next_chr:
	mov	al, es:[di]
	call	FarMyUpper			; case insensitive 
	cmp	al, ds:[si]
	jne	@f
	inc	si
	inc	di
	loop	next_chr
	pop	ax
	jmps	fre_got_it
@@:
	pop	ax
	dec	bx
	jz	fre_failed
	mov	cx,dx
	add	ax,size MODENT
	mov	di,lpFileName.off
	jmps	fre_next

fre_failed:
	xor	ax,ax				; no matching module, return 0
	jmps	fre_exit

fre_got_it:
	mov	si,ax				; return selector pointing
	sub	si,FileNameStr
	mov	ax,word ptr [si.lmaExeHdr]	;   to ROM copy of module
	mov	dx,word ptr [si.lmaExeHdr+2]	;   EXE header
	cCall	far_alloc_data_sel16,<dx,ax,1000h>
if PMODE32
	cCall	HocusROMBase, <ax>
endif

fre_exit:

cEnd

endif ;ROM



if ROM

;-----------------------------------------------------------------------;
; FindROMFile
;
; Locates the start of a file in ROM ( for true-type files esp.)
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
; adapted from FindROMExe -- 8/8/91 -- vatsanp
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	FindROMFile,<PUBLIC,FAR>,<ds,es,di,si>
	parmD	lpFileName
	parmD	lpfsize
cBegin
	xor	ax,ax				; calculate length of
	mov	cx,-1				;   file name, include
	les	di,lpFileName			;   terminating null in count
	cld
	repne scasb
	not	cx
	jcxz	frf_failed			; to frf_exit

	cmp	cx,File_Name_Len		; can't be in rom if name
	ja	frf_exit			;   is too long

	call	MapDStoDATA
	ReSetKernelDS

	mov	ds,selROMTOC			; search ROM TOC for matching
	UnSetKernelDS				;   file name
	mov	bx,ds:[cModules]		; # modules in ROM TOC
	mov	ax, SIZE MODENT
	mul	bx
	mov	bx,ModEntries+fname		; offset in ROM TOC of 1st name
	add	ax, bx
	mov	bx,ds:[cFiles]			; # Files in ROM TOC

	les	di,lpFileName
	mov	dx,cx

frf_next:
	mov	si,ax				; search ROM TOC, entry by entry
	cld
	repe cmpsb
	je	frf_got_it
	dec	bx
	jz	frf_failed
	mov	cx,dx
	add	ax,size FILENT
	mov	di,lpFileName.off
	jmps	frf_next

frf_failed:
	xor	ax,ax				; no matching module, return 0
	jmps	frf_exit

frf_got_it:
	mov	si,ax				; return selector pointing
	sub	si,fname
	les	di,lpfsize
	mov	cx, word ptr [si.fsize]		; massage fsize into paras
	mov	word ptr es:[di], cx
	mov	ax, word ptr [si.fsize+2]
	mov	word ptr es:[di+2], ax
	shl	ax, 12
	add	cx, 15				; round off
	shr	cx, 4
	or	cx, ax
	mov	ax,word ptr [si.lma]		;   to ROM copy of file
	mov	dx,word ptr [si.lma+2]	
	cCall	far_alloc_data_sel16,<dx,ax,cx>
if PMODE32
	add	cx, 0FFFh		; compute #sels allocated
	rcr	cx, 1			
	shr	cx, 11			; cx = # of sels allocated
	mov	dx, ax			; save
anudder_sel:
	cCall	HocusROMBase, <ax>	; for each of those sels
	add	ax, 8			; next sel
	loop	anudder_sel
	mov	ax, dx			; restore
endif

frf_exit:

cEnd

endif ;ROM
;-----------------------------------------------------------------------;
; WarnRealMode
;
; Trayf for files in the form "Insert WIN.EXE disk in drive A:"
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 07-Oct-1989 17:12:43  -by-  David N. Weise  [davidw]
; Wrote it!  A month or so ago.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	WarnRealMode,<PUBLIC,NEAR>
cBegin nogen
	ReSetKernelDS
	push	Win_PDB
	push	fLMDepth
	cld
	mov	ax,IDCANCEL		; assume booting
	test	fBooting,1
	jnz	promptly_done
	cmp	pMBoxProc.sel,0 	; is there a USER around yet?
	jz	promptly_done
	push	di
	push	si
	push	es
	mov	es,cx
ifdef	FE_SB
;Japan and Korea declare that they need more space for DBCS msg.
;It sounds like this is one of common requirement for DBCS enabling
;although Taiwan doesn't claim she has the same requirement.
;I enclosed this code fragment under DBCS and it can be removed
;if somebody thinks it is not necessary.
	sub	sp, 530
else
	sub	sp,512
endif
	mov	di,sp
	mov	si,offset msgRealModeApp1
	push	ds
	smov	ds,cs
	UnSetKernelDS
	call	StartString
	smov	ds,cs
	mov	si,offset msgRealModeApp2
	call	Append
	pop	ds
	ReSetKernelDS

	mov	bx,sp
	xor	ax,ax
	push	ax			; Null hwnd
	push	ss
	push	bx			; (lpstr)text
	push	cs
	mov	ax,offset szProtectCap
	push	ax			; (lpstr)caption
	mov	ax,MB_OKCANCEL or MB_ICONEXCLAMATION or MB_DEFBUTTON2 or MB_SYSTEMMODAL
	push	ax			; wType				    
	call	[pMBoxProc]		; Call USER.MessageBox
ifdef	FE_SB
	add	sp, 530
else
	add	sp,512
endif
	pop	es
	pop	si
	pop	di

promptly_done:
	pop	fLMDepth
	pop	Win_PDB
	ret

cEnd nogen


	assumes ds,nothing
	assumes es,nothing

StartString:
	call	Append			; append first string

; Now append the file name

	push	di
	lea	di,[bx].opFile		; skip past length, date, time

	call	NResGetPureName 	; strip off drive and directory
	smov	ds,es
	mov	si,di
	pop	di

;  Append ASCIIZ string to output buffer, DS:DX points to string

	assumes ds,nothing
	assumes es,nothing

Append: lodsb
	stosb
	or	al,al
	jnz	Append
	dec	di
	ret


	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
; NResGetPureName
;
; Returns a pointer the the filename off the end of a path
;
; Entry:
;	ES:DI => path\filename
; Returns:
;	ES:DI => filename
; Registers Destroyed:
;
; History:
;  Wed 18-Oct-1989 20:01:25  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	NResGetPureName,<PUBLIC,NEAR>
cBegin nogen

ifdef FE_SB
;
; It is not possible to search filename delimiter by backword search
; in case of DBCS version. so we use forword search instead.
;
	mov	bx,di
iup0:
	mov	al,es:[di]
	test	al,al			; end of string?
	jz	iup2			; jump if so
	inc	di
	cmp	al,'\'
	jz	iup1
	cmp	al,'/'
	jz	iup1
	cmp	al,':'
	jz	iup1
	call	FarMyIsDBCSLeadByte	; see if char is DBC
	jc	iup0			; jump if not a DBC
	inc	di			; skip to detemine 2nd byte of DBC
	jmp	iup0
iup1:
	mov	bx,di			; update purename candidate
	jmp	iup0
iup2:
	mov	di,bx			; di points purename pointer
	ret
else
	cld
	xor	al,al
	mov	cx,-1
	mov	bx,di
	repne	scasb
	inc	cx
	inc	cx
	neg	cx
iup0:	cmp	bx,di			; back to beginning of string?
	jz	iup1			; yes, di points to name
	mov	al,es:[di-1]		; get next char
	cmp	al,'\'			; next char a '\'?
	jz	iup1			; yes, di points to name
	cmp	al,'/'			; next char a '/'
	jz	iup1
	cmp	al,':'			; next char a ':'
	jz	iup1			; yes, di points to name
	dec	di			; back up one
	jmp	iup0
iup1:	ret
endif

cEnd nogen

;-----------------------------------------------------------------------;
; search_mod_dep_list
;
; Searches the dependent module list for the passed in name.
;
; Entry:
;	AX    = length of name to search for
;	CX    = count of modules
;	DS:SI => module name to search for
;	ES:DI => module table
; Returns:
;
; Registers Preserved:
;	AX,BX,CX,DI,SI,ES
;
; Registers Destroyed:
;
; History:
;  Sat 07-Oct-1989 17:12:43  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	search_mod_dep_list,<PUBLIC,NEAR>
cBegin nogen

	push	bx
	push	cx
	push	di
	mov	bx,di

search_mod_loop:
	mov	di,es:[bx]		; es:di = offset into imptable
	add	di,es:[ne_imptab]
	cmp	es:[di],al		; does len of entry = sizeof(doscalls)
	jnz	get_next_entry

	push	cx			; cx holds count of module entries.
	push	si
	inc	di			; es:di = import module name
	mov	cx,ax
	rep	cmpsb
	pop	si
	pop	cx
	stc
	jz	got_it

get_next_entry:
	inc	bx
	inc	bx
	loop	search_mod_loop
	clc
got_it: pop	di
	pop	cx
	pop	bx
	ret

cEnd nogen


;-----------------------------------------------------------------------;
; LMCheckHeap
;
; This checks for 4K free space in both USER's and GDI's data
; segments.  If this space does not exist then we will not load
; the app.  This is better than the hose-bag way we did things
; under win 1 and 2.
;
; Entry:
;	nothing
;
; Returns:
;	AX != 0  lots o'space
;
; Registers Destroyed:
;	BX,CX
;
; History:
;  Sat 28-Oct-1989 17:49:09  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

MIN_RSC = 10
cProc	LMCheckHeap,<PUBLIC,NEAR>,<ds>
cBegin
	SetKernelDSNRES
ifdef WOW
					; USER32 and GDI32 can deal with memory alloc no need check heaps on WOW
	mov	ax,-1			; WOW doesn't have GDI or User heaps
else					; so don't check them.
	mov	ax, MIN_RSC
	cmp	word ptr pGetFreeSystemResources[2],0
	jz      @F
	cCall	pGetFreeSystemResources,<0>
	cmp	ax, MIN_RSC
	jae	@F
if kdebug               		; test low memory code if DEBUG
	krDebugOut	DEB_WARN, "Resources #ax% - this tests your error handling code"
	or	al, 1
else
	xor	ax, ax			; you failed - g'bye
endif
@@:
endif ; WOW
	ReSetKernelDS
cEnd

if 0
cProc	check_gdi_user_heap_space,<PUBLIC,NEAR>
cBegin nogen

	ReSetKernelDS

ifdef WOW
					; USER32 and GDI32 can deal with memory alloc no need check heaps on WOW
	mov	ax,-1			; WOW doesn't have GDI or User heaps
else					; so don't check them.
	cmp	graphics,0
	jz	c_ret
	push	dx
	push	es
	push	ds
	mov	ds,hGDI
	UnSetKernelDS
	call	checkit_bvakasha
	or	ax,ax
	jz	c_exit
	pop	ds
	ReSetKernelDS
	push	ds
	mov	ds,hUser
	UnSetKernelDS
	call	checkit_bvakasha
c_exit: pop	ds
	pop	es
	pop	dx
c_ret:	ret

	public	checkit_bvakasha
checkit_bvakasha:
	mov	bx,ds:[ne_pautodata]
	cCall	FarMyLock,<ds:[bx].ns_handle>
	mov	ds,ax
	call	LocalCountFree
	sub	ax,4095
	ja	cguhs_exit
	neg	ax
	mov	bx,LA_MOVEABLE
	cCall	LocalAlloc,<bx,ax>
	or	ax,ax
	jz	cguhs_exit
free_User_piece:
	cCall	LocalFree,<ax>
	mov	ax,sp			; return non-zero
cguhs_exit:
endif ;WOW
	ret
cEnd nogen
endif

;-----------------------------------------------------------------------;
; GetHeapSpaces
;
;
; Entry:
;	nothing
;
; Returns:
;	AX = free space (bytes) of User heap assuming heap can grow to 64K
;	DX = free space (bytes) of GDI	heap assuming heap can grow to 64K
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:27:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetHeapSpaces,<PUBLIC,FAR>,<di,si>

	parmW	hInstance
cBegin
	call	MapDStoDATA
	ReSetKernelDS
	cCall	FarMyLock,<hInstance>
	or	ax,ax
	jz	ghs_exit
	mov	ds,ax
	cmp	ds:[ne_magic],NEMAGIC
	jnz	ghs_must_be_data
	mov	bx,ds:[ne_pautodata]
	cCall	FarMyLock,<ds:[bx].ns_handle>
	mov	ds,ax
ghs_must_be_data:
	call	LocalCountFree
	mov	si,ax
	cCall	GlobalSize,<ds>
	neg	ax
	add	ax,si			; AX = size of free assuming 64K
	mov	cx,si			; CX = size of free
	mov	dx,-1
	sub	dx,ds:[pLocalHeap]	; DX = size of heap

ghs_exit:

cEnd

if ROM

;-----------------------------------------------------------------------;
; FindROMModule
;
;   search through the the exehdr's listed in the ROM TOC for a specific
;   module name
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley	[craigc]
; Wrote it!
;-----------------------------------------------------------------------;

cProc	FindROMModule, <PUBLIC,FAR>, <si, di>
	parmW   hExe
cBegin
	push	ds
	call	MapDSToData
	ResetKernelDS
	mov	es, selROMTOC
	mov	ds, hExe
	UnsetKernelDS
	mov	cx, es:[cModules]	; get number of modules
	lea	bx, es:[ModEntries] 	; point to first module

frm_loop:
	push	cx			; save count
	lea	di, [bx].ModNameStr 	; point to module name string
	mov	si, ds:[ne_restab]	; point to res name table
	sub	cx, cx
	lodsb				; get count in name table
	mov	cl, al
	repe	cmpsb			; compare up to that length
	jnz	frm_pass		; if mismatch, next
	cmp	es:[di], cl 		; make sure there's a zero term
	jnz	frm_pass
	pop	cx
	mov	ax, word ptr es:lmaExeHdr[bx][0]
	mov	dx, word ptr es:lmaExeHdr[bx][2]
	cCall   far_alloc_data_sel16, <dx,ax,1000h>
if PMODE32
	cCall   HocusROMBase, <ax>
endif
	jmp	short frm_ret

frm_pass:
	add	bx, size MODENT
	pop	cx
	loop	frm_loop

	mov	ax, -1

frm_ret:
	pop	ds
cEnd

;-----------------------------------------------------------------------;
; ReplacePatchTable
;
;   this function generates a new patch table when a module is loaded
;   from disk to replace the one in RAM.
;
;   we do this by walking the entry table in the rom module, finding all
;   exported entry points, finding the corresponding entry point in the
;   new exe, and placing a far jump at that offset in the new segment.
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley	[craigc]
; Wrote it!
;-----------------------------------------------------------------------;

OP_FARJUMP  equ 0EAh

public enter_patch
enter_patch proc near
	push	ax
	push	bx
	push	cx
	push	dx
	push	es
	cCall   GetProcAddress,<dx,0,cx>
	pop	es
	or		dx, dx
	jz		@F
	mov	es:[di+1],ax
	mov	es:[di+3],dx
@@:	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
enter_patch endp

cProc	ReplacePatchTable, <PUBLIC>, <si, di>
	parmW   hExe
	parmW   selROMHdr

	localW  hCodeSeg
cBegin
	sub	ax, ax
	mov	es, selROMHdr
	test	es:[ne_flagsothers], NEGANGLOAD
	jnz	rpt_ok			; one of these bits is set
ifdef PATCHCHECK
	test	byte ptr es:[ne_gang_start+1], 4
	jz	rpt_ok
endif
	mov	ax, es:[ne_cseg]
	cmp	al, byte ptr es:[ne_gang_start]
	jz	rpt_has_table
ifdef PATCHCHECK
	sub	ax, ax
	jmp	short rpt_not_ok
endif
rpt_ok:
	mov	ax, 1			; doesn't have patch table
rpt_not_ok:
	jmp	rpt_exit

rpt_has_table:				; allocate memory for the
	mov	si, es:[ne_cseg]	; segment
	dec	si
	shl	si, 3
	.errnz  size new_seg - 8
	add	si, es:[ne_segtab]
	mov	ax, es:[si].ns_minalloc
	xor	dx, dx
	push	ax
	cCall   GlobalAlloc, <GA_MOVEABLE,dx,ax>
	pop	si
	or	ax, ax
	jnz	@F
	jmp	rpt_exit

@@: 	cCall   GlobalLock, <ax>	; lock it
	mov	hCodeSeg, dx
	mov	es, dx
	sub	di, di			; initialize it to JMP UNDEFDYNLINK
	cld
	sub	si, 4			; don't overrun segment
rpt_initloop:
	mov	al, OP_FARJUMP
	stosb
	mov	ax, offset UndefDynLink
	stosw
	mov	ax, seg UndefDynLink
	stosw
	cmp	di, si
	jb	rpt_initloop

	push	ds			; set up for entry table
	mov	ds, selROMHdr
	mov	si, ds:[ne_enttab]
	mov	bx, ds:[ne_cseg]

	mov	cx, 1			; first export = 1
	mov	dx, hExe

rpt_ent_loop:
	lodsw				; get count and segment
	or	al, al
	jz	rpt_ent_done		; if count 0, done

	inc	ah			; is seg == 0xFF
	jnz	rpt_not_moveable_entries

rpt_mov_ent_loop:
	test	byte ptr [si], ENT_PUBLIC
	jz	rpt_mov_ent_loop_pass
	cmp	bl, 3[si]
	jnz	rpt_mov_ent_loop_pass	; must be patch segment

	mov	di, 4[si]

	call	enter_patch

rpt_mov_ent_loop_pass:
	inc	cx
	add	si, 6
	dec	al
	jnz	rpt_mov_ent_loop
	jmp	rpt_ent_loop

rpt_not_moveable_entries:
	dec	ah			; is seg == 0
	jnz	rpt_fixed_entries

	add	cx, ax			; seg=0 = unused entries
	jmp	short rpt_ent_loop

rpt_fixed_entries:
	cmp	bl, ah			; must be in patch segment
	jz	rpt_fixed_ent_loop
	sub	ah, ah
	add	cx, ax			; update the ordinal count
	add	si, ax
	add	si, ax			; skip over entries in table
	add	si, ax
	jmp	rpt_ent_loop

rpt_fixed_ent_loop:
	test	byte ptr [si], ENT_PUBLIC
	jz	rpt_fixed_loop_pass
	mov	di, 1[si]
	call	enter_patch

rpt_fixed_loop_pass:
	inc	cx
	add	si, 3
	dec	al
	jnz	rpt_fixed_ent_loop
	jmp	rpt_ent_loop

rpt_ent_done:
	pop	ds
	cCall   IPrestoChangoSelector, <hCodeSeg,hCodeSeg>
	mov	es, selROMHdr
	mov	bx, es:[ne_cseg]
	dec	bx
	shl	bx, 3
	add	bx, es:[ne_segtab]
	cCall   ChangeROMHandle, <hCodeSeg,es:[bx].ns_sector>
rpt_exit:
cEnd

endif

;-----------------------------------------------------------------------;
; IsROMModule
;
;   Determines if an app with a given name is a ROM application
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley	[craigc]
; Wrote it!
;-----------------------------------------------------------------------;

if ROM

cProc	IsROMModule, <FAR, PUBLIC>, <si, di>
	parmD   lpModule
	parmW   fSelector

	localV   szName, 18
cBegin
	cld
	mov	cx, 13
	push	ds
	push	ss
	pop	es
	lea	di, szName
	assumes ds,nothing
	lds	si, lpModule

skip_space:			; skip leading spaces
	cmp	byte ptr [si], ' '
	jnz	find_it
	inc	si
	jmp	short skip_space

path_char:
	pop	ds
	xor	ax, ax
	jmp	short IRM_Exit

find_it:			; if : / or \, not in ROM
	lodsb
	cmp	al, ':'
	jz	path_char
	cmp	al, '\'
	jz	path_char
	cmp	al, '/'
	jz	path_char
	cmp	al, ' '		; if illegal character, end of path
	jbe	end_char
	cmp	al, '<'
	jz	end_char
	cmp	al, '>'
	jz	end_char
	cmp	al, '|'
	jz	end_char
	stosb			; store up to 13 chars
	loop	find_it

end_char:
	mov	byte ptr es:[di], 0 ; 0 terminate...
	pop	ds			; get DS back
	lea	ax, szName		; find exe header in ROMTOC
	cCall   FindROMExe, <ss, ax>
	or	ax, ax
	jz	IRM_Exit

IRM_Found:
	cmp	fSelector,0
	jnz	IRM_Exit

	cCall   FreeSelector, <ax>	; free the selector we got...
	mov	ax, 1		; return success

IRM_Exit:
cEnd

else

cProc	IsROMModule, <FAR, PUBLIC>
cBegin	<nogen>
	xor	ax, ax
	retf	6
cEnd	<nogen>

endif


if ROM

;-----------------------------------------------------------------------;
; IsROMFile
;
;   Determines if a file is in ROM
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  8/8/91 -- vatsanp -- adapted this for true-type files in ROM
;  from IsROMModule [ craigc]
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley	[craigc]
; Wrote it!
;-----------------------------------------------------------------------;

cProc	IsROMFile, <FAR, PUBLIC>, <si, di>
	parmD   lpFile
	parmD   lpfsize
	parmW   fSelector

	localV   szName, 18
cBegin

	cld
	mov	cx, 13
	push	ds
	push	ss
	pop	es
	lea	di, szName
	assumes ds,nothing
	lds	si, lpFile

skip_spc:			; skip leading spaces
	cmp	byte ptr [si], ' '
	jnz	fnd_it
	inc	si
	jmp	short skip_spc

path_chr:
	pop	ds
	xor	ax, ax
	jmp	short IRF_Exit

fnd_it: 		; if : / or \, not in ROM
	lodsb
	cmp	al, ':'
	jz	path_chr
	cmp	al, '\'
	jz	path_chr
	cmp	al, '/'
	jz	path_chr
	cmp	al, ' '		; if illegal character, end of path
	jbe	end_chr
	cmp	al, '<'
	jz	end_chr
	cmp	al, '>'
	jz	end_chr
	cmp	al, '|'
	jz	end_chr
	stosb			; store up to 13 chars
	loop	fnd_it

end_chr:
	mov	byte ptr es:[di], 0 ; 0 terminate...
	pop	ds			; get DS back
	lea	ax, szName		; find file start in ROMTOC
	cCall   FindROMFile, <ss, ax, lpfsize>
	or	ax, ax
	jz	IRF_Exit

IRF_Found:
	cmp	fSelector,0
	jnz	IRF_Exit

	cCall   FreeSelector, <ax>	; free the selector we got...
	mov	ax, 1		; return success

IRF_Exit:
cEnd

else

cProc	IsROMFile, <FAR, PUBLIC>
cBegin	<nogen>
	xor	ax, ax
	retf	6
cEnd	<nogen>

endif

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldappl.asm ===
TITLE	LDAPPL - AppLoader Interface

IFNDEF NO_APPLOADER	;* entire file for AppLoader

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include appl.inc
include protect.inc
.list

DataBegin

externW  pGlobalHeap
	 
DataEnd

sBegin	CODE
externNP SetOwner
externFP set_discarded_sel_owner
sEnd	CODE

externFP MyOpenFile
externFP FarLoadSegment
externFP FarMyAlloc
externNP Int21Handler
IF KDEBUG		;See comment below where this function is used
externFP AppLoaderEntProcAddress
ELSE
externFP FarEntProcAddress
ENDIF
externFP GlobalHandle
externFP Far_get_temp_sel
externFP Far_free_temp_sel

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDSToDATA

;-----------------------------------------------------------------------;
; BootAppl								;
; 									;
; Boots (i.e. starts) an AppLoader application				;
;  Loads (and relocates) first segment (must be CODE/FIXED/PRELOAD)	;
;  Validates the APPL magic word					;
;  Calls APPL boot procedure						;
;									;
; Arguments:								;
;	parmW   hexe (handle to exe header)				;
;	parmW	fh   (file handle)					;
; 									;
; Returns:								;
;	AX != 0 => ok							;
; 									;
; Error Returns:							;
;	AX == 0 => error						;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	various								;
; 									;
; History:								;
; 									;
;  Thu Oct 01, 1987 11:10:06a  -by-  David N. Weise	[davidw]	;
; Changed the return values to NOT return ZF.				;
; 									;
;  Thu Jul 30, 1987 11:56:34a  -by-  Scott A. Randell	[scottra]	;
; Created it.								;
;-----------------------------------------------------------------------;

cProc	BootAppl,<NEAR,PUBLIC>,<si>
	parmW   hexe
	parmW	fh
cBegin	BootAppl

	mov	es,hexe
	mov	si,es:[ne_segtab]		;* es:si => segtab
	mov	ax,es:[si].ns_flags		;* first segment
	test	ax,NSMOVE
	jnz	@f				;* PMode loader will set the
	jmp	bal_error			;*  moveable flag for us
@@:

	test	ax,NSPRELOAD
	jz	bal_error			;* must be preload

;*	* load in first segment (turn off Alloced/Loaded, and DS requirement)
	and	ax,not NSALLOCED+NSLOADED+NSUSESDATA
	mov	es:[si].ns_flags,ax		;* update flags
	mov	ax,1				;* first segment
	cCall	FarLoadSegment,<es,ax,fh,fh>
	jcxz	bal_fail			;* not enough memory

;*	* now validate APPL header
	mov	es,ax
	push	es
	cCall	Far_get_temp_sel
	xor	bx,bx				;* es:bx => first segment
	cmp	es:[bx].magicAppl,magicApplCur	;* current version ?
						;* (no backward compatibility)
	jne	bal_error_popes

;*	* fill in global information
	mov	word ptr es:[bx].lppsMob,dataOffset pGlobalHeap
	mov	ax,codeBase			;* segment address of FIXED KERNEL

	push	ds
	call	MapDStoData
	mov	word ptr es:[bx].lppsMob+2,ds	;* segment address of krnl data
	pop	ds

	mov	word ptr es:[bx].pfnKernelAlloc,codeOffset FarMyAlloc
	mov	word ptr es:[bx].pfnKernelAlloc+2,ax

        ; In DEBUG, we really want RIPs to be able to happen when we don't
        ;       find ordinals.  This saves an enormous amount of debugging
        ;       time!!  The entry point AppLoaderEntProcAddress only exists
        ;       in debug and allows RIPs to happen (unlike FarEntProcAddress
        ;       which is the same entry point used for GetProcAddress which
        ;       should not RIP).
IF KDEBUG
	mov	word ptr es:[bx].pfnEntProcAddress,codeOffset AppLoaderEntProcAddress
ELSE
	mov	word ptr es:[bx].pfnEntProcAddress,codeOffset FarEntProcAddress
ENDIF
	mov	word ptr es:[bx].pfnEntProcAddress+2,ax
;*	* extra entry for Protect Mode only
	mov	word ptr es:[bx].pfnSetOwner,codeOffset MySetOwner
	mov	word ptr es:[bx].pfnSetOwner+2,ax

	mov	ax,es
	pop	es
	cCall	Far_free_temp_sel,<ax>
;*	* call the start procedure
	cCall	es:[pfnBootAppl], <hexe, fh>	;* returns BOOL

bal_end:	;* ax
cEnd	BootAppl


bal_error_popes:	;* an error occured (pop es if in PMODE)
	mov	ax,es
	pop	es
	cCall	Far_free_temp_sel,<ax>
bal_error:	;* an error occured
if KDEBUG
	int	3
endif
bal_fail:	;* Boot failed (not enough memory)
	xor	ax,ax
	jmps	bal_end


;-----------------------------------------------------------------------;
; ExitAppl								;
; 									;
; Exit last instance of an APPLOADER application			;
;									;
; Arguments:								;
;	parmW   hexe (handle to exe header)				;
; 									;
; Returns:								;
;	N/A								;
; 									;
; History:								;
; 									;
;  Sat Sep 19, 1987 15:55:19 -by-  Scott A. Randell [scottra]		;
; Created it								;
;-----------------------------------------------------------------------;

cProc	ExitAppl,<NEAR,PUBLIC>
	parmW	hexe
cBegin	ExitAppl

; The apps with loaders don't do anything in their exit code except try
; to close a bogus file handle, so we just will not make this call
; anymore.  This call runs on the kernel PSP, so if the app picked a valid
; kernel file handle, that file got closed.  0 seems to be a popular
; handle to inadvertently close.  Newer apps do/will not have their own
; loaders.

ifdef DEAD_CODE ;--------------------------------------------------------

	mov	es,hexe
	mov	bx,es:[ne_segtab]		;* es:si => segtab

;*	* first segment is the AppLoader
	mov	ax,es:[bx].ns_handle		;* handle
	or	ax, ax				; Out of memory, couldn't load segment?
	jz	exa_error
	HtoS	ax	 			;* back to ring 1

	push	bx
	lar	bx, ax
	test	bh, DSC_PRESENT			; Fix a WinWord bug
	pop	bx
	jz	exa_error

	mov	es,ax
;*	* test to make sure that an APPL is there
	cmp	es:[magicAppl],magicApplCur
	jne	exa_error

; The following hack sets up SS to have a 64k limit before calling the
; app's exit procedure.  Added 12/18/90 to work around a bug in the
; Excel & WinWord app loader that references a bogus offset from SS.  In
; the past the stack segment at this point already had a large limit, but
; when the data segment was moved out of the kernel's code segment and
; the limit decreased to the actual DS size, the Excel/WinWord offset
; is now beyond the segment limit.

	push	ss				;save current SS
	push	es				;seg 1 handle
	smov	es,ss				;get temp selector takes
	cCall	far_get_temp_sel		;  and returns selector in ES
	smov	ss,es				;SS now has max limit
	pop	es				;seg 1 handle
	cCall	es:[pfnExitAppl], <hexe>

	mov	ax,ss				;return to original SS and
	pop	ss				;  free temp selector
	cCall	far_free_temp_sel,<ax>
exa_error:

endif	;DEAD_CODE	-------------------------------------------------

cEnd	ExitAppl

sEnd	NRESCODE


sBegin	CODE
assumes CS,CODE
;-----------------------------------------------------------------------;
; LoadApplSegment							;
; 									;
; Load an APPL segment							;
;  open file if not already open					;
;  tests to make sure 1st segment is an APPL loader			;
;  call the Apploader requesting segment be loaded			;
;  NOTE : never call for first segment					;
;									;
; Arguments:								;
;	parmW   hexe		(handle to exe header)			;
;	parmW	fh		(file handle (may be -1))		;
;	parmW	segno		(segment #)				;
; 									;
; Returns:								;
;	NZ, AX != 0 => ok, AX = segment where loaded, DX = handle of seg;
; 									;
; Error Returns:							;
;	Z, AX == 0 => error						;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	various								;
; 									;
; History:								;
; 									;
;  Thu Jul 30, 1987 11:56:34a  -by-  Scott A. Randell [scottra]		;
; Created it								;
;-----------------------------------------------------------------------;

cProc	LoadApplSegment,<NEAR,PUBLIC>,<si>
	parmW   hexe		       
	parmW	fh
	parmW	segno
	localW	myfh			;* private file handle
					;*  (if one shot open/close)
cBegin	LoadApplSegment

	mov	es,hexe
	mov	myfh,-1			;* try with what is open first
	mov	ax,fh

las_retry:	;* ax = file handle
	mov	si,es:[ne_segtab]		;* es:si => segtab
;*	* first segment is the AppLoader
	mov	si,es:[si].ns_handle		;* handle
	HtoS	si				;* back to ring 1
	mov	es,si
;*	* test to make sure that an APPL is there
	cmp	es:[magicAppl],magicApplCur	;* current version ?
						;* (no backward compatibility)
	jne	las_error

;*	* Try to reload with the handle Windows has (may be -1)
	cCall	es:[pfnReloadAppl], <hexe, ax, segno>
						;* returns AX = segment
	or	ax,ax
	jnz	las_end				;* return AX != 0
;*	* if the file handle was -1, open the file and try again
	cmp	myfh,-1
	jne	las_error			;* could not load with a file
;*	* file is not open, open up temporary file (put handle in myfh)
	mov	es,hexe
	mov	dx,es:[ne_pfileinfo]
	regptr	esdx,es,dx
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY + OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY
endif
	push	dx
	Save	<es>
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	dx
	mov	myfh,ax
	cmp	ax,-1
	jne	las_retry

las_error:	;* an error occured
;*	* close file (if myfh != -1), then return error
	debug_out "LoadApplSegment failed - better find out why!"
	xor	ax,ax

las_end: ;* ax = return value
	mov	bx,myfh
	inc	bx
	jz	las_no_temp_file
	dec	bx
	push	ax
	mov	ah,3Eh				;* close file handle
	DOSCALL
	pop	ax
las_no_temp_file:	;* ax = return code
	or	ax,ax
cEnd	LoadApplSegment

;-----------------------------------------------------------------------;



;-----------------------------------------------------------------------;
; MySetOwner								;
; 									;
; Private version of SetOwner for present/non-present selectors		;
;									;
; Arguments:								;
;	selector = selector (present or non-present)			;
;	owner = new owner field						;
; 									;
; History:								;
; 									;
;  Mon 04-Dec-1989 10:03:25  -by-  David N. Weise  [davidw]		;
; Made it call set_discarded_sel_owner instead of set_sel_limit.	;
;									;
;  Mon Jul 03 20:37:22 1989	created -by- Scott A. Randell [scottra] ;
;-----------------------------------------------------------------------;

cProc	MySetOwner,<PUBLIC,FAR>, <SI, DI>
	parmW	selector
	parmW	owner
cBegin
	cCall	GlobalHandle,<selector>
	or	dx,dx				;* 0 => not present
	jz	set_owner_NP
;*	* set owner for present selectors
	cCall	SetOwner,<selector, owner>
	jmp	short end_set_owner

set_owner_NP:
	;* NP selectors store the owner in the segment limit
	mov	bx,selector
	mov	es,owner
	call	set_discarded_sel_owner

end_set_owner:
cEnd

sEnd	CODE

endif ;!NO_APPLOADER (entire file)

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldcache.asm ===
TITLE	LDCACHE - Segment and File Handle Caching procedures

.xlist
include kernel.inc
include newexe.inc
include tdb.inc

.list

DataBegin

externW  hExeHead

externW	 topPDB
externW	 Win_PDB
externW	 curTDB
externW	 cur_dos_PDB
externB	 fhCache
externW	 fhCacheLen
externW	 fhCacheEnd
externW	 fhcStealNext

DataEnd

externFP MyOpenFile
externFP Int21Handler

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP real_DOS

;-----------------------------------------------------------------------;
; GetCachedFileHandle							;
;									;
; Look for the file handle for an EXE file in the cache of file 	;
; handles.  Sets current PDB to that of KERNEL to access the file.	;
; A handle NOT to free in order to satisfy the request can also 	;
; be given.								;
;									;
; Arguments:								;
;	parmW	hExe		handle of EXE file			;
;	parmW	keepfh		file handle not to change		;
;	parmW	fh		file handle if file already open	;
; 					    				;
; Returns:								;
;	AX == file handle						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
;  Wed 18-Oct-1989 20:40:51  -by-  David N. Weise  [davidw]		;
; Added the feature of not closing a specified handle.			;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing
ifdef WOW
	.286
else
endif

cProc	FarGetCachedFileHandle,<PUBLIC,FAR>
	parmW	hExe
	parmW	keepfh
	parmW	fh
cBegin		  
	cCall	GetCachedFileHandle,<hExe,keepfh,fh>
cEnd


cProc	GetCachedFileHandle,<PUBLIC,NEAR>,<bx,di,ds,es>
	parmW	hExe
	parmW	keepfh
	parmW	fh			; -1 if file not open
	localW	fhcFreeEntry
cBegin
	SetKernelDS
	mov	fhcFreeEntry, 0

	mov	bx, topPDB

;;;	cmp	bx, Win_PDB
;;;	je	gcfh_okPDB		; Don't bother setting if already this
;;;	mov	cur_dos_PDB, bx
;;;	mov	Win_PDB, bx		; Run on kernel's PDB for a while
;;;	mov	ah, 50h			; set PDB
;;;	call	real_DOS
;;;gcfh_okPDB:

	mov	Win_PDB, bx		; Run on kernel's PDB for a while

	mov	ax, hExe		; look for this EXE in the file
	mov	es, ax			; handle cache
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
gcfh_searchfh:
	mov	bx, [di.CacheExe]
	cmp	ax, bx
	jne	@F
	jmps	gcfh_found
@@:
	or	bx, bx			; Free entry?
	jnz	gcfh_searchnext
	cmp	fhcFreeEntry, bx	; already have a free entry?
	jne	gcfh_searchnext
	mov	fhcFreeEntry, di	; Save index for free entry
gcfh_searchnext:
	add	di, size fhCacheStruc
	loop	gcfh_searchfh
					; EXE not already in the cache
	mov	di, fhcFreeEntry	; Did we find a free entry?
	or	di, di
	jz	gcfh_stealone		;  no, steal one
	mov	fhcFreeEntry, -1	; Flag to steal one if the open fails
	jmps	gcfh_openit		; (due to out of file handles)
	
gcfh_stealone:				; No free entry, pick one on first come,
	mov	cx, fhcStealNext	; first served basis
gcfh_stealnext:
	mov	di, cx
	add	cx, 4			; Calculate next index in CX
	cmp	cx, fhCacheEnd
	jb	gcfh_oknext
	mov	cx, dataoffset fhCache	; Start back at the beginning
gcfh_oknext:	       		      
	mov	bx, [di.Cachefh]
	or	bx, bx			; If no file handle,
	jz	gcfh_stealnext		;  on to next cache entry
	cmp	bx, keepfh		; If handle not to free
	jz	gcfh_stealnext		;  on to next cache entry
	mov	fhcStealNext, cx

	mov	ah, 3Eh
	DOSCALL				; Close this file handle
	mov	fhcFreeEntry, di

gcfh_openit:
	push	ds
	mov	ax, fh
	cmp	ax, -1			; File already open?
	jne	gcfh_opened		;   yes, just put in cache

	mov	dx,es:[ne_pfileinfo]
	regptr	esdx,es,dx
;	mov	bx,OF_SHARE_DENY_WRITE or OF_REOPEN or OF_PROMPT or OF_VERIFY or OF_CANCEL
;;;	mov	bx,OF_REOPEN or OF_PROMPT or OF_VERIFY or OF_CANCEL
if 1
	smov	ds,es
	add	dx, opFile
;;;	test	es:[ne_flags],NEAPPLOADER
;;;	jnz	@F
if SHARE_AWARE
	mov	ax, 3DA0h		; open for read, deny write, no inherit
else
	mov	ax, 3D80h		; open for read, no inherit
endif
	DOSCALL
	jnc	gcfh_opened
;;;@@:
	mov	ax, 3DC0h		; try share deny none 
	DOSCALL				      
	jnc	gcfh_opened
else
	mov	bx,OF_REOPEN or OF_VERIFY
	push	es
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	es
	cmp	ax, -1
	jne	gcfh_opened
endif
	pop	ds
	cmp	fhcFreeEntry, -1	; This was a free cache entry?
	je	gcfh_stealone		;  yes, have run out of file handles
	mov	ax, -1			; fix bug #6774 donc
	jmps	gcfh_exit		;  no, a real failure
gcfh_found:
	mov	ax, [di.Cachefh]
	jmps	gcfh_exit
gcfh_opened:
	pop	ds
	mov	[di.Cachefh], ax
	mov	[di.CacheExe], es

gcfh_exit:
cEnd


;-----------------------------------------------------------------------;
; CloseCachedFileHandle							;
;									;
; Close the EXE file with the given file handle.			;
; Actually does delays closing the file until the handle is needed.	;
; Resets the current PDB to that of the current task.			;
;									;
; Arguments:								;
;	parmW	fh		file handle being 'closed'		;
; 									;
; Returns:								;
;	none								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;	AX								;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CloseCachedFileHandle,<PUBLIC,NEAR>,<bx,ds,es>
	parmW	fh
cBegin
;;;	SetKernelDS
;;;	mov	es, curTDB
;;;	mov	bx, es:[TDB_PDB]
;;;	cmp	bx, Win_PDB
;;;	je	ccfh_okPDB
;;;	mov	Win_PDB, bx
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS
;;;ccfh_okPDB:
cEnd

;-----------------------------------------------------------------------;
; FlushCachedFileHandle							;
;									;
; Look for the file handle for an EXE file in the cache of file handles	;
; If it is found, close the file.					;
;									;
; Arguments:								;
;	parmW	hExe		handle of EXE file			;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FlushCachedFileHandle,<PUBLIC,FAR>,<ax,bx,cx,di>
	parmW	hExe
cBegin
	SetKernelDS
	mov	ax, hExe
	or	ax, ax				; make sure we really
	jz      fcfh_exit			; have a hExe
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
fcfh_search:
	cmp	ax, [di.CacheExe]
	je	fcfh_found
	add	di, size fhCacheStruc
	loop	fcfh_search
	jmps	fcfh_exit			; Not cached, nothing to do
fcfh_found:

;;;	mov	bx, topPDB
;;;	cmp	bx, cur_dos_PDB
;;;	je	fcfh_okPDB
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h			; set PDB
;;;	call	real_DOS
;;;fcfh_okPDB:

	push	Win_PDB			; Save 'current' PDB

	mov	bx, topPDB
	mov	Win_PDB, bx		; Run on kernel's PDB for a while

	mov	bx, [di.Cachefh]
	mov	ah, 3Eh			; Close the file
	DOSCALL
	xor	ax, ax
	mov	[di.Cachefh], ax	; mark cache entry free
	mov	[di.CacheExe], ax

;;;	push	es
;;;	mov	es, curTDB		; and reset the PDB
;;;	mov	bx, es:[TDB_PDB]
;;;	pop	es
;;;	cmp	bx, Win_PDB
;;;	je	fcfh_exit
;;;	mov	Win_PDB, bx
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS

	pop	Win_PDB			; Restore original PDB

fcfh_exit:
cEnd


;-----------------------------------------------------------------------;
; CloseCachedFiles							;
;									;
; Close all the cached files on a duplicate PDB				;
; Leaves PDB set to new PDB						;
;									;
; Arguments:								;
;	parmW	pdb		new PDB					;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	CloseCachedFiles,<PUBLIC,FAR>,<ax,bx,cx,di,ds>
	parmW	pdb
cBegin
	SetKernelDS
	mov	bx, pdb
	mov	Win_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS		; Run on the new guy

	mov	dx, bx
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
ccf_search:
	mov	bx, [di.Cachefh]
	or	bx, bx
	je	ccf_next
	mov	ah, 3Eh			; Close the file
	call	real_DOS

	cmp	dx,topPDB		; If closing cached files on
	jne	ccf_next		;   the kernel's PDB, mark the
	xor	ax,ax			;   cache entry as free
	mov	[di.Cachefh], ax
	mov	[di.CacheExe], ax

ccf_next:
	add	di, size fhCacheStruc
	loop	ccf_search

cEnd

sEnd	CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldboot.asm ===
PAGE    ,132
    TITLE   LDBOOT - BootStrap procedure
?DFSTACK = 1
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
include eems.inc
include protect.inc
include gpcont.inc
ifdef WOW
include vint.inc
include doswow.inc
endif
.list

if 0; KDEBUG
ifdef  WOW
  BootTraceOn = 1
  BootTrace macro   char
    push ax
    mov ax,char
    int 3
    pop ax
  endm
else
  BootTraceOn = 1
  BootTrace macro   char
    push    char
    call    BootTraceChar
  endm
endif
else
  BootTrace macro   char
  endm
  BootTraceOn = 0
endif

; Note that the following public constants require special handling
; for ROM Windows.  If you add, delete, or change this list of constants,
; you must also check the ROM Image Builder.

public  __ahshift
public  __ahincr
public  __0000h
public  __0040h
public  __A000h
public  __B000h
public  __B800h
public  __C000h
public  __D000h
public  __E000h
public  __F000h
public  __ROMBIOS
public  __WinFlags
public  __flatcs
public  __flatds

public  __MOD_KERNEL
public  __MOD_DKERNEL
public  __MOD_USER
public  __MOD_DUSER
public  __MOD_GDI
public  __MOD_DGDI
public  __MOD_KEYBOARD
public  __MOD_SOUND
public  __MOD_SHELL
public  __MOD_WINSOCK
public  __MOD_TOOLHELP
public  __MOD_MMEDIA
public  __MOD_COMMDLG
ifdef FE_SB
public  __MOD_WINNLS
public  __MOD_WIFEMAN
endif ; FE_SB

    __ahshift = 3
    __ahincr  = 1 shl __ahshift
    __0000h     = 00000h
    __0040h     = 00040h
    __A000h     = 0A000h
    __B000h     = 0B000h
    __B800h     = 0B800h
    __C000h     = 0C000h
    __D000h     = 0D000h
    __E000h     = 0E000h
    __F000h     = 0F000h
    __ROMBIOS   = 0F000h
    __WinFlags  = 1
    __flatcs    = 1Bh
    __flatds    = 23h

    __MOD_KERNEL     = 0h
    __MOD_DKERNEL    = 0h
    __MOD_USER       = 0h
    __MOD_DUSER      = 0h
    __MOD_GDI        = 0h
    __MOD_DGDI       = 0h
    __MOD_KEYBOARD   = 0h
    __MOD_SOUND      = 0h
    __MOD_SHELL      = 0h
    __MOD_WINSOCK    = 0h
    __MOD_TOOLHELP   = 0h
    __MOD_MMEDIA     = 0h
    __MOD_COMMDLG    = 0h
ifdef FE_SB
    __MOD_WINNLS     = 0h    ; for IME
    __MOD_WIFEMAN    = 0h    ; for WIFEMAN
endif ; FE_SB

BOOTSTACKSIZE   =  512
EXTRASTACKSIZE  = (4096-BOOTSTACKSIZE)

MultWIN386      EQU 16h ; Reserved to Win386
MW3_ReqInstall      EQU 00h ; Installation check
MW3_ReqInstall_Ret_1    EQU 0FFh    ; Return number 1
MW3_ReqInstall_Ret_2    EQU 01h ; Return number 2
MW3_ReqInstall_Ret_3    EQU 02h ; Return number 3
MW3_ReqInstall_Ret_4    EQU 03h ; Return number 4

externFP lstrlen
externFP lstrcat
externFP lstrcpy
externFP IGlobalAlloc
externFP IGlobalFree
externFP IGlobalRealloc
externFP LoadModule
externFP IOpenFile
externFP lrusweep
externFP GetExePtr
externFP GetProfileInt
externFP GetPrivateProfileString
externFP GetPrivateProfileInt
externFP GetProcAddress
externFP GetTempDrive
externFP ExitKernel
externFP InternalEnableDOS
externFP FlushCachedFileHandle
externFP SetHandleCount
externFP IPrestoChangoSelector
externFP GPFault
externFP StackFault
externFP invalid_op_code_exception
externFP page_fault
ifdef WOW
externFP divide_overflow
externFP single_step
externFP breakpoint
endif
externFP DiagInit

ifdef WOW
externFP StartWOWTask
externFP AllocSelector_0x47
externW MOD_KERNEL
externW ModCount
externFP WOWGetTableOffsets
externFP WOWDosWowInit
externFP GetShortPathName
endif

if KDEBUG
externFP ValidateCodeSegments
endif

ifdef FE_SB
externFP GetSystemDefaultLangID
endif

externFP TermsrvGetWindowsDir


externW pStackBot
externW pStackMin
externW pStackTop

sBegin  CODE
externFP Int21Handler
externFP Int10Handler
externD  prevInt10proc
sEnd    CODE

;------------------------------------------------------------------------
;  Data Segment Variables
;------------------------------------------------------------------------

DataBegin
if SHERLOCK
  externW gpEnable
endif

externB graphics
externB fBooting
externB Kernel_flags
externB fChkSum
externB fCheckFree
externB WOAName
externB grab_name
ifndef WOW
externB szUserPro
endif
externB szBootLoad
externB szCRLF
externB szMissingMod
externB szPleaseDoIt
externB fPadCode
;externW EMScurPID
;externW PID_for_fake
externW cBytesWinDir
externW cBytesSysDir
externW pGlobalHeap
externW hExeHead
externW MaxCodeSwapArea
externW curTDB
externW f8087
externB fastFP
externW topPDB
externW headTDB
externW winVer
ifndef WOW
externB WinIniInfo
externB PrivateProInfo
endif
externW gmove_stack
externW prev_gmove_SS
externW BaseDsc
externW WinFlags
externW hUser
externW hShell
externW MyCSSeg
externW MyDSSeg
externW MyCSAlias
externB fhCache
externW fhCacheEnd
externW fhCacheLen
externB fPokeAtSegments
externB fExitOnLastApp
externW segLoadBlock
externD pKeyProc
externD pKeyProc1
externW wDefRIP

ife ROM
externW cpShrunk
externW cpShrink
externW hLoadBlock
endif

if ROM
externW selROMTOC
externW selROMLDT
externW sel1stAvail
endif

externD pTimerProc
externD pExitProc
externD pDisableProc
externD lpWindowsDir
externD lpSystemDir

if ROM
externD prevIntx6proc
externD prevInt0Cproc
externD prevInt0Dproc
externD prevInt0Eproc
externD prevInt21proc
externD prevInt3Fproc
endif

;if KDEBUG and SWAPPRO
;externD prevIntF0proc
;endif

externD lpInt21     ; support for NOVELL stealing int 21h

ifdef WOW
externD pFileTable
externW cBytesSys16Dir
externD lpSystem16Dir
externB Sys16Suffix
externW cBytesSys16Suffix
externW cBytesSysWx86Dir
externD lpSystemWx86Dir
externB SysWx86Suffix
externW cBytesSysWx86Suffix
externD pPMDosCURDRV
externD pPMDosCDSCNT
externD pPMDosPDB
externD pPMDosExterr
externD pPMDosExterrLocus
externD pPMDosExterrActionClass
externD pDosWowData

globalW cbRealWindowsDir,0

WINDIR_BUFSIZE equ 121

achWindowsDir     DB WINDIR_BUFSIZE DUP(?)
achRealWindowsDir DB WINDIR_BUFSIZE DUP(?)
achSystem16Dir    DB 128 DUP(?)
achSystemWx86Dir  DB 128 DUP(?)

public cbRealWindowsDir, achRealWindowsDir, achWindowsDir, achSystem16Dir
externB achTermSrvWindowsDir           ; windows directory path (for win.ini)


endif

DataEnd


;------------------------------------------------------------------------
;  INITDATA Variables
;------------------------------------------------------------------------

DataBegin INIT

ifndef WOW
; WOW doesn't muck with the WOAName buffer -- we just leave it
; as WINOLDAP.MOD
externB  woa_286
externB  woa_386
endif
externB  bootExecBlock
externW  oNRSeg
externW  oMSeg
externW  win_show
externD  lpBootApp

if ROM
externD  lmaROMTOC
staticD  MyLmaROMTOC,lmaROMTOC

    .errnz  opLen
    .errnz  8 - opFile
ROMKRNL db  19          ; mocked up open file structure
    db  7 dup (0)       ;   for ROM Kernel
    db  'ROMKRNL.EXE',0
endif

staticW  initTDBbias,0
staticW  initSP,0
staticW  initSSbias,0
staticW  segNewCS,0

app_name db 68 dup(0)

DataEnd INIT


;------------------------------------------------------------------------
;  EMSDATA Variables
;------------------------------------------------------------------------


;------------------------------------------------------------------------

externNP LoadSegment
externNP genter
externNP gleave
externNP GlobalInit
externNP DeleteTask
externNP BootSchedule
externNP InitFwdRef

externNP SaveState
externNP LKExeHeader
externNP GetPureName
externNP SegmentNotPresentFault

externNP LDT_Init
externNP alloc_data_sel
externNP get_physical_address
externNP set_physical_address
externNP set_sel_limit
externNP free_sel
externFP set_discarded_sel_owner
externNP SelToSeg
externNP DebugDefineSegment
externNP DebugFreeSegment

ife ROM
externNP SwitchToPMODE
externNP LKAllocSegs
endif

if ROM and PMODE32
externFP HocusROMBase
endif

ifdef WOW
externFP WOWFastBopInit
endif


if KDEBUG
ife PMODE32
externNP init_free_to_CCCC
endif

if SWAPPRO
externB fSwapPro
externW hSwapPro
externW cur_dos_pdb
endif
endif

ifdef FE_SB
externFP FarMyIsDBCSTrailByte
endif



;------------------------------------------------------------------------

sBegin  INITCODE
assumes cs,CODE


ife ROM
externD prevIntx6proc
externD prevInt0Cproc
externD prevInt0Dproc
externD prevInt0Eproc
externD prevInt21proc
externD prevInt3Fproc
ifdef WOW
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
externFP GlobalDosAlloc
externFP GlobalDosFree
endif
endif

externNP TextMode
externNP InitDosVarP
externNP GrowSFTToMax
ifndef WOW
externNP SetUserPro
endif
externNP MyLock
externNP Shrink
externNP DebugDebug
externNP NoOpenFile
externNP NoLoadHeader

if SDEBUG
externNP DebugInit
endif

;if SWAPPRO
;externNP INTF0Handler
;endif


if SDEBUG
szModName   db  'KERNEL',0
endif

if ROM
externNP ROMInit
externNP SetOwner
externNP SetROMOwner
externNP alloc_data_sel16
if KDEBUG
externNP CheckGlobalHeap
endif
endif

ifdef WOW
externNP SetOwner
endif

;-----------------------------------------------------------------------;
; Bootstrap                             ;
;                                   ;
; Determines whether we should initialize in a smaller amount of    ;
; memory, leaving room for an EEMS swap area.  If so, we rep-move the   ;
; code to a lower address, and tell the PSP to report less memory ;
; available.  It then does lots more of stuff.              ;
;                                   ;
; Arguments:                                ;
;   DS:0 = new EXE header                       ;
;   ES:0 = Program Segment Prefix block (PSP)           ;
;   SS:SP = new EXE header                      ;
;   CX = file offset of new EXE header (set by KernStub)        ;
;   DS = automatic data segment if there is one         ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Sat Jun 20, 1987 06:00:00p  -by-  David N. Weise   [davidw]      ;
; Made fast booting work with real EMS.                 ;
;                                   ;
;  Tue Apr 21, 1987 06:31:42p  -by-  David N. Weise   [davidw]      ;
; Added some more EMS support.                      ;
;                                   ;
;  Thu Apr 09, 1987 02:52:37p  -by-  David N. Weise   [davidw]      ;
; Put back in the movement down if EMS.                 ;
;                                   ;
;  Sat Mar 14, 1987 05:55:29p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

    assumes ds,DATA
    assumes es,nothing
    assumes ss,nothing


cProc   BootStrap,<PUBLIC,NEAR>
cBegin  nogen
ifndef  NEC_98
if KDEBUG
    jmp short Hello_WDEB_End
Hello_WDEB:
    db  'Windows Kernel Entry',13,10,0
Hello_WDEB_End:
    push    ax
    push    es
    push    si
    xor ax, ax
    mov es, ax
    mov ax, es:[68h*4]
    or  ax, es:[68h*4+2]
    jz  @F
    mov ax,cs
    mov es,ax
    lea si,Hello_WDEB
    mov ah,47h
    int 68h
@@:
    pop si
    pop es
    pop ax
endif
endif   ; NEC_98
    BootTrace   'a'

if ROM
    call    ROMInit     ; BX -> LDT, DS -> RAM DGROUP, SI -> start mem

else

    cmp ax, "KO"    ; OK to boot; set by kernstub.asm
    je  @F
    xor ax, ax
    retf
@@:

; Set up addressibility to our code & data segments

    mov MyCSSeg, cs
    mov MyDSSeg, ds

endif   ;ROM

ifdef WOW
; Get pointer to sft so that I can find do direct protect mode
; file IO operations

    mov CS:MyCSDS, ds

    push es
    mov     ah,52h                  ; get pointer to internal vars
    int     21h

;
;       Retrieve some pointers from the DosWowData structure in DOS.
;
        push    di
        push    dx
        mov     di, es:[bx+6ah]                 ;kernel data pointer

        mov     pDosWowData.off, di
        mov     pDosWowData.sel, es

        mov     ax, word ptr es:[di].DWD_lpCurPDB
;       mov     dx, word ptr es:[di].DWD_lpCurPDB+2
        mov     pPMDosPDB.off,ax
        mov     pPMDosPDB.sel,0                 ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpCurDrv
;       mov     dx, word ptr es:[di].DWD_lpCurDrv+2
        mov     pPMDosCURDRV.off,ax
        mov     pPMDosCURDRV.sel,0              ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpCDSCount
;       mov     dx, word ptr es:[di].DWD_lpCDSCount+2
        mov     pPMDosCDSCNT.off,ax
        mov     pPMDosCDSCNT.sel,0              ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpExterr
        mov     pPMDosExterr.off, ax
        mov     pPMDosExtErr.sel, 0

        mov     ax, word ptr es:[di].DWD_lpExterrLocus
        mov     pPMDosExterrLocus.off, ax
        mov     pPMDosExtErrLocus.sel, 0

        mov     ax, word ptr es:[di].DWD_lpExterrActionClass
        mov     pPMDosExterrActionClass.off, ax
        mov     pPMDosExtErrActionClass.sel, 0

        pop     dx
        pop     di

    lea     bx,[bx+sftHead]
    mov     pFileTable.off,bx
    mov pFileTable.sel,es
    pop es

endif   ; WOW

ife ROM
    BootTrace   'b'
    call    SwitchToPMODE   ; BX -> LDT, DS -> CS(DS), SI start of memory
    BootTrace   'c'
endif
    ReSetKernelDS

    mov BaseDsc,si
    call    LDT_Init
    BootTrace   'd'

ifdef WOW
        call    AllocSelector_0x47
        call    WOWFastBopInit
endif

if SDEBUG

; In protected mode, initialize the debugger interface NOW.  Only real mode
; needs to wait until the global heap is initialized.

    cCall   DebugInit

; In protected mode, define where our temp Code & Data segments are

    mov ax,codeOffset szModName
    cCall   DebugDefineSegment,<cs,ax,0,cs,0,0>

    mov ax,codeOffset szModName
    cCall   DebugDefineSegment,<cs,ax,3,ds,0,1>
endif
    BootTrace   'e'

if ROM

; In the ROM version, the DS selector doesn't change from now on, so we
; can tell the debugger where the special kernel data is now.

    cCall   DebugDebug
endif

    BootTrace   'f'

ifdef WOW
        push    ax
        push    bx
        mov     bx, pDosWowData.sel             ;use this segment
        mov     ax, 2
        int     31h
        mov     pPMDosPDB.sel,ax                ;make this a PM pointer
        mov     pPMDosCURDRV.sel,ax             ;make this a PM pointer
        mov     pPMDosCDSCNT.sel,ax             ;make this a PM pointer
        mov     pPMDosExterr.sel,ax
        mov     pPMDosExterrLocus.sel,ax
        mov     pPMDosExterrActionClass.sel,ax
        pop     bx
        pop     ax

        push    pDosWowData.sel
        push    pDosWowData.off
        call    WOWDosWowInit
endif

; InitDosVarP just records a few variables, it does no hooking.
;  It does dos version checking and other fun stuff that
;  must be done as soon as possible.

    call    InitDosVarP
    or  ax,ax
    jnz inited_ok
    Debug_Out "KERNEL: InitDosVarP failed"
    mov ax,4CFFh        ; Goodbye!
    INT21
inited_ok:
    BootTrace   'g'

    push    bx

    mov bx, WinFlags
ifndef  JAPAN   ; should be removed because of IBM dependent code.
ifndef  NEC_98
        ; InitFwdRef routine will set 80x87 status bit in WinFlags
        ; and exported location #178.

; Determine if there is a co-processor present.

    int 11h         ; get equipment word
    test    al,2            ; this is the IBM approved method
    jz  no_80x87        ;   to check for an 8087
    or  bh,WF1_80x87
no_80x87:
endif   ; NEC_98
endif   ;NOT JAPAN

ifdef WOW
    or  bh,WF1_WINNT    ; Set NT flag ON
endif

    mov WinFlags,bx

    pop bx

; Determine if running under Windows/386 or the 286 DOS Extender

    push    bx
    mov ax,(MultWin386 SHL 8) OR MW3_ReqInstall ; Win/386 install check
    int 2Fh
    BootTrace   'h'
    cmp al,MW3_ReqInstall_Ret_4     ; Under WIN386 in pmode?
ifdef WOW                           ; For WOW Enhanced Mode on 386
ife PMODE32
    jnz NotUnderWin386
endif
endif
    or  Kernel_flags[1],kf1_Win386
    or  byte ptr WinFlags,WF_PMODE or WF_ENHANCED
    jmps    InstallChkDone

NotUnderWin386:
    or  Kernel_flags[2],KF2_DOSX
    or  byte ptr WinFlags,WF_PMODE or WF_STANDARD

InstallChkDone:
    BootTrace   'i'
    pop bx

ifndef WOW
    ; WOW doesn't muck with the WOAName buffer -- we just leave it
    ; as WINOLDAP.MOD

    push    cx
    push    di
    push    si
    cld
    mov cx,8
    smov    es,ds
    mov di,dataOffset WOAName
    mov si,dataOffset woa_286
    test    Kernel_flags[2],KF2_DOSX
    jnz @F
    mov si,dataOffset woa_386
@@: rep movsb
    pop si
    pop di
    pop cx
endif
    BootTrace   'j'

ife ROM     ;--------------------------------------------------------

    mov ax,cx
    mov cl,4
    shr ax,cl
    mov cpShrunk,ax

; Compute paragraph address of new EXE header from SS:SP

    mov bx,sp           ; SS:SP -> new EXE header

    cCall   get_physical_address,<ss>
    add ax,bx
    adc dx,0
    BootTrace   'k'
    if PMODE32
    cCall   alloc_data_sel,<dx,ax,0,0FFFFh>
    else
    cCall   alloc_data_sel,<dx,ax,1000h>
    endif
    BootTrace   'l'

else  ; ROM ---------------------------------------------------------

; Setup selector to ROM Table of Contents

    mov ax,word ptr [MyLmaROMTOC]
    mov dx,word ptr [MyLmaROMTOC+2]
    cCall   alloc_data_sel16,<dx,ax,1000h>
if PMODE32
    cCall   HocusROMBase, <ax>
endif
    mov selROMTOC,ax

; Setup another selector to the ROM prototype LDT

    mov es,ax
    assumes es,nothing

    mov ax,word ptr es:[lmaROMLDT]
    mov dx,word ptr es:[lmaROMLDT+2]
    cCall   alloc_data_sel16,<dx,ax,1000h>
if PMODE32
    cCall   HocusROMBase, <ax>
endif
    mov selROMLDT,ax

    mov ax,es:[FirstROMsel]
    shr ax,3
    add ax,es:[cROMsels]
    shl ax,3            ; ax = 1st non-ROM selector
    mov sel1stAvail,ax

; Setup selector to KERNEL EXE header in ROM.  **ASSUMES KERNEL is 1st
; module in ROM TOC**

    mov ax,word ptr es:[ModEntries+lmaExeHdr]
    mov dx,word ptr es:[ModEntries+lmaExeHdr+2]
    cCall   alloc_data_sel16,<dx,ax,1000h>
if PMODE32
    cCall   HocusROMBase, <ax>
endif

endif ; ROM ---------------------------------------------------------

    mov segLoadBlock,ax     ; hinitexe:0 -> new EXE header

; calculate the TDB bias

    mov bx,dataOffset boottdb
    mov initTDBbias,bx

; calculate the SS bias

    mov bx,dataOffset stackbottom
    mov initSSbias,bx

; calculate the initial SP

    mov si,dataOffset stacktop
    sub si,dataOffset stackbottom
    mov initSP,si

    cCall   get_physical_address,<ds>
    add ax,bx
    adc dx,0
    BootTrace   'm'
if ROM
    cCall   alloc_data_sel16,<dx,ax,1000h>
    FCLI
else
    FCLI
    mov prev_gmove_SS, ss   ; Switch stack while we set up new SS
    smov    ss, ds
    mov sp, dataOFFSET gmove_stack
    cCall   set_physical_address,<prev_gmove_SS>
    xor ax, ax
    xchg    ax, prev_gmove_SS
endif
    BootTrace   'n'
    mov ss,ax           ; switch to new stack
    mov sp,si
    FSTI

    xor bp,bp           ; zero terminate BP chain.
    sub si,BOOTSTACKSIZE
    mov ss:[pStackBot],sp
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],si

    cld
    mov es,topPDB

externB szNoGlobalInit
if ROM  ;----------------------------------------------------------------

; In the ROM Windows version, the "allocated" block in the global heap is
; the kernel data segment, not the code segments

    mov bx,ds           ; kernel DS is first busy block
    lsl bx,bx           ; pass its size to GlobalInit
    inc bx

    cCall   GlobalInit,<MASTER_OBJECT_SIZE,bx,BaseDsc,es:[PDB_block_len]>
    jnc mem_init_ok

if KDEBUG
    Debug_Out "GlobalInit failed!"
else
    mov dx, codeoffset szNoGlobalInit
    smov    ds, cs
    mov ah, 9
    int 21h         ; Whine
    mov ax, 4CFFh
    int 21h         ; And exit
;NoGlobalInit   db  "KERNEL: Unable to initialise heap",13,10,'$'
endif

mem_init_ok:

if KDEBUG
    cCall   CheckGlobalHeap
endif

else ;ROM   ---------------------------------------------------------

    BootTrace   'o'
    mov ax, BaseDsc     ; Free memory starts after this
    mov bx,segLoadBlock     ; Make boot image be first busy block
    mov cx,es:[PDB_block_len]   ; cx is end of memory
    mov dx,MASTER_OBJECT_SIZE
    cCall   GlobalInit,<dx,bx,ax,cx>

    jc  @F          ; passed through from ginit
    or  ax,ax
    jnz mem_init_ok
@@:
    mov dx, codeoffset szNoGlobalInit
    smov    ds, cs
    mov ah, 9
    int 21h         ; Whine
    mov ax, 4CFFh
    int 21h         ; And exit
;NoGlobalInit   db  "KERNEL: Unable to initialise heap",13,10,'$'

mem_init_ok:
    mov hLoadBlock,ax       ; Save handle to first busy block

endif ;ROM  ---------------------------------------------------------
    BootTrace   'p'

    mov pExitProc.sel,cs
    mov pExitProc.off,codeOffset ExitKernel

; Find out where we live, and where win.com lives.

    mov ds,topPDB
    UnSetKernelDS
    mov bx,ds
    mov ds,ds:[PDB_environ]
    xor si,si
    cld
envloop1:
    lodsb
    or  al,al           ; end of item?
    jnz envloop1
    lodsb
    or  al,al           ; end of environment?
    jnz envloop1
    lodsw               ; ignore argc, DS:SI -> kernel path

ifdef WOW
    smov    es, ds          ; now ES:SI -> kernel path
else
    call    get_windir      ; on return, DS:DI -> windir= value

    smov    es,ds

; Record where to find the 'windows' directory.
    BootTrace   'q'

    SetKernelDS
    or  di,di
    jz  no_win_dir_yet
    mov lpWindowsDir.sel,es
    mov lpWindowsDir.off,di
    mov cBytesWinDir,cx

                    ; Now set pointer to WIN.INI to be
                    ; in the Windows directory
    push    si
    push    es
    smov    es, ds
    mov si, dataoffset szUserPro+6
    mov di, si
    inc cx
    add di, cx          ; Move up the string WIN.INI
    std
    mov cx, 4
    rep movsw
                    ; Now copy Windows directory
    cld
    mov cx, cBytesWinDir
    mov di, dataoffset szUserPro
    lds si, lpWindowsDir
    UnSetKernelDS
    rep movsb
    mov byte ptr es:[di], '\'
    pop es
    pop si
endif
    SetKernelDS
    BootTrace   'r'
no_win_dir_yet:

if ROM  ;----------------------------------------------------------------

; 'Load' the kernel exe header from ROM.

    mov si,dataOffset ROMKRNL
    cCall   LKExeHeader,<segLoadBlock,ds,si>
    or  ax,ax
    jnz hdr_ok
    jmp bootfail
hdr_ok:

else ;ROM   ---------------------------------------------------------

    sub sp,SIZE OPENSTRUC + 127
    mov di,sp
    regptr  ssdi,ss,di
    mov bx,OF_EXIST
    cCall   IOpenFile,<essi,ssdi,bx>
    BootTrace   's'
    inc ax          ; Test for -1
    jnz opn1            ; Continue if success
    mov dx, codeoffset NoOpenFile
fail1:
    push    dx                      ; Save string pointer
    call    textmode                ; Switch to text mode
    pop     dx
    smov    ds, cs
    mov ah, 9
    int 21h         ; Tell user why we're bailing out
    mov ax,4CFFh        ; Goodbye!
    INT21
opn1:

; Now simulate loading ourselves from memory

; Load new EXE header for KERNEL.EXE from memory

    cCall   LKExeHeader,<segLoadBlock,ssdi>
    BootTrace   't'
    add sp,SIZE OPENSTRUC + 127
    or  ax,ax
    jnz     @F
    mov dx, codeoffset NoLoadHeader
    jmp     SHORT fail1
@@:

endif ;ROM  ---------------------------------------------------------

    mov hExeHead,ax
    mov es,ax

ifndef WOW
; Record where to find the 'system' directory.

if ROM  ;----------------------------------------------------------------

    push    es
    mov es,selROMTOC        ; ROM system dir @ selROMTOC:offSysDir
    mov di,es:offSysDir
    mov lpSystemDir.sel,es
    mov lpSystemDir.off,di
    xor ax,ax
    mov cx,-1
    cld
    repne scasb
    not cx
    dec cx
    mov cBytesSysDir,cx
    pop es

else ;ROM   ---------------------------------------------------------

    mov di,es:[ne_pfileinfo]
    lea di,es:[di].opFile
    mov lpSystemDir.sel,es
    mov lpSystemDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesSysDir,di

endif ;ROM  ---------------------------------------------------------
    BootTrace   'u'
endif
   ; ndef WOW


; Make room at end of kernel data segment for stack--NOTE:  DGROUP is
; assumed to be segment 4!

    mov bx,es:[ne_segtab]
ife ROM
    add es:[bx+(3*size NEW_SEG1)].ns_minalloc,EXTRASTACKSIZE
endif


; Determine size of kernel's largest discardable code segment

; don't bother with swap area's anymore. Its fixed 192k (3segs)
; picked this up from Win95

    xor     ax,ax                           ; No max
    mov es:[ne_swaparea],ax
    BootTrace   'v'


ife ROM ;----------------------------------------------------------------

; Allocate memory for kernel segments

    cCall   LKAllocSegs,<es>
    mov oNRSeg,ax
    mov oMSeg, bx       ; Misc segment
    mov es,hExeHead


; If this is a pMode debug version, the code and data segments have already
; been defined to the debugger once.  We're about to LoadSegment and define
; these segments again in their final location.  Use a special form of
; DebugFreeSegment to force the debugger to pull out any breakpoints in these
; segments.  If we don't do this, any existing breakpoints become INT 3's
; in the new copy of the segment and the code has to be patched by hand.
; If only the debugger was smart enough to 'move' the breakpoints when it
; saw a second define for an already loaded segment...

if SDEBUG

    cCall   DebugFreeSegment,<cs,-1>
    cCall   DebugFreeSegment,<MyCSDS,-1>
endif

; Load kernel code segment 1 (resident code)

    mov si,1
    mov ax,-1           ; Indicate loading from memory
    cCall   LoadSegment,<es,si,cs,ax>
    or  ax,ax
    jnz ll1
fail2:  jmp bootfail
ll1:
    mov segNewCS,ax     ; Save new CS value


; Load kernel data segment (segment 4)

    mov si,4
    mov ax,-1
    cCall   LoadSegment,<hExeHead,si,ds,ax>
    or  ax,ax
    jz  fail2

    BootTrace   'w'


; locate the stack in the new segment

    mov bx,ax
    mov si,initSP
    add si,EXTRASTACKSIZE

else ;ROM   ---------------------------------------------------------

    cCall   SetOwner,<ds,hExeHead>    ;Who owns ya baby?
    cCall   SetROMOwner,<cs,hExeHead> ;IGROUP isn't loaded, but needs owner

; locate the stack at the end of the data segment

    mov ax, ds
    mov bx, ax
    mov si, initSP
    add si, ROMEXTRASTACKSZ

endif ;ROM  ---------------------------------------------------------


    cCall   get_physical_address,<ax>
    add ax,initSSbias
    adc dx,0
    sub ax,10h
    sbb dx,0
    or  ax,10h
    FCLI
    mov prev_gmove_SS, ss   ; Switch stack while we set up new SS
    smov    ss, ds
    mov sp, OFFSET gmove_stack
    cCall   set_physical_address,<prev_gmove_SS>
    push    bx
    mov bx, si
    xor cx, cx          ; cx:bx=stack len (for set_sel_limit)
    cCall   set_sel_limit,<prev_gmove_SS>
    pop bx
    xor ax, ax
    xchg    ax, prev_gmove_SS
    mov ss,ax           ; Switch to new stack location
    mov sp,si
    FSTI
    mov ax,bx


; zero the new TDB

    push    ax

    cCall   get_physical_address,<ax>
    add ax,initTDBbias
    adc dx,0
    if PMODE32
YAH_WELL =  (SIZE TDB+15) and NOT 15
    cCall   alloc_data_sel,<dx,ax,0,YAH_WELL>
    else
YAH_WELL =  (SIZE TDB+15)/16
    cCall   alloc_data_sel,<dx,ax,YAH_WELL>
    endif
    mov es,ax
    xor ax,ax
    mov di,ax
    mov cx,SIZE TDB
    cld
    rep stosb
    pop ax

; put the limits in the stack

    xor bp,bp               ; zero terminate BP chain.
    mov ss:[pStackBot],sp
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],10h
    mov ss:[0],bp       ; To mark this stack as NOT linked
    mov ss:[2],bp       ;  to another, see PatchStack.
    mov ss:[4],bp

; initialize the new TDB

    sub sp,SIZE TASK_REGS
    mov es:[TDB_taskSS],ss
    mov es:[TDB_taskSP],sp
    mov cx,topPDB
    mov es:[TDB_PDB],cx         ; save new PDB
    mov es:[TDB_DTA].off,80h        ; set initial DTA
    mov es:[TDB_DTA].sel,cx
    mov bx,1                ; BX = 1
    mov es:[TDB_nEvents],bx     ; Start this guy up!
    mov es:[TDB_pModule],-1     ; EMS requires -1
    mov bx,winVer
    mov es:[TDB_ExpWinVer],bx       ; Windows Version #
    mov es:[TDB_sig],TDB_SIGNATURE  ; Set signature word.

; initialize the task BP and DS

    push    es
    les bx,dword ptr es:[TDB_taskSP]
    mov es:[bx].TASK_BP,bp      ; initial BP = 0
    mov es:[bx].TASK_DS,bp      ; initial DS = 0
    pop es

ife ROM  ;---------------------------------------------------------------

    mov ds,ax           ; switch to new DS segment
    mov ax,segNewCS     ; recover new CS value

    push    cs          ; to free the selector

; do a far return to the new code segment

    push    ax
    mov ax,codeOffset new_code
    push    ax
    ret_far             ; FAR return to new code segment

    public new_code
new_code:

    pop ax
    push    es
    cCall   free_sel,<ax>           ; Free old CS selector
    cCall   IPrestoChangoSelector,<cs,MyCSAlias>    ; Change our CS Alias

    mov es,MyCSAlias            ; Change MyCSDS to new DS
    assumes es,CODE
    mov ax,ds
    xchg    ax,es:MyCSDS
    assumes es,nothing
    cCall   free_sel,<ax>           ; Free old DS selector

    call    DebugDebug      ; do after MyCSDS changes

    mov pExitProc.sel,cs    ; reset this!!

;;; pusha
;;; cCall   get_physical_address,<cs>
;;; add ax, codeOffset end_page_locked
;;; adc dx, 0
;;; mov bx, dx
;;; mov cx, ax
;;; mov di, cs
;;; lsl di, di
;;; sub di, codeOffset end_page_locked
;;; xor si, si
;;; mov ax, 0601h
;;; int 31h             ; Unlock some of Kernel!
;;; popa

    cCall   SelToSeg,<ds>       ; Save DS segment value
    mov MyDSSeg,ax

    cCall   SelToSeg,<cs>       ; Set segment equivalent
    mov MyCSSeg, ax

; calculate the maximum amount that we will allow SetSwapAreaSize to set

    mov ax,-1           ; They can only harm themselves.


else ;ROM   ---------------------------------------------------------

    push    es          ; code below expects this on stack

    mov ax,-1           ; They can only harm themselves.

endif ;ROM  ---------------------------------------------------------

    mov MaxCodeSwapArea,ax

ifndef WOW              ; WOW uses 32 bit profile api's

; Allocate a handle for WIN.INI

    xor ax,ax
    mov bx,GA_SHAREABLE shl 8 OR GA_MOVEABLE
    cCall   IGlobalAlloc,<bx,ax,ax>
    mov [WinIniInfo.hBuffer], ax
    or  ax,ax
    jz  nowinini
    mov bx,ax           ; put handle into base register
    mov ax,hExeHead
    mov es,ax
    call    set_discarded_sel_owner
                    ; Set up the filename
    mov word ptr [WinIniInfo.lpProFile], dataoffset szUserPro
    mov word ptr [WinIniInfo.lpProFile][2], ds
nowinini:

; Allocate a handle for Private Profiles

    xor ax,ax
    mov bx,GA_SHAREABLE shl 8 OR GA_MOVEABLE
    cCall   IGlobalAlloc,<bx,ax,ax>
    mov [PrivateProInfo.hBuffer],ax
    or  ax,ax
    jz  noprivate
    mov bx,ax           ; put handle into base register
    mov ax,hExeHead
    mov es,ax
    call    set_discarded_sel_owner
noprivate:
endif; WOW

ifdef WOW
    ; Allocate a ~128K discardable code selector to hide the
    ; GrowHeap - heap not sorted bugs, also present in Win 3.1.
    ;
    ; Since our system DLLs (like krnl386, user, gdi etc) contain a few
    ; discardable codesgements (of approx 40K), we need not be precise
    ;
    push    es
    mov     ax, 0C000H ; hiword is 01h , totalsize 0x1c000 bytes
    mov     bx, GA_MOVEABLE OR GA_DISCCODE
    cCall   IGlobalAlloc,<bx,01h,ax>
    or      ax,ax
    jz      short nogrowheap
    cCall   SetOwner, <ax, hExeHead>
nogrowheap:
    pop     es
endif; WOW

ife ROM ;----------------------------------------------------------------

; Now shrink off exe header and segment 1 of KERNEL.EXE

    mov si,2            ; Segment number
    xor ax,ax
    xchg    oNRSeg,ax
nofastboot:
    sub ax,cpShrunk
    mov cpShrink,ax     ; Amount to shrink by
    cCall   MyLock,<hLoadBlock>
    mov bx,ax
    xchg    segLoadBlock,ax
    cCall   get_physical_address,<ax>
    mov cx,dx
    xchg    bx,ax
    cCall   get_physical_address,<ax>
    sub bx,ax
    sbb cx,dx
    REPT    4
    shr cx,1
    rcr bx,1
    ENDM
    mov ax,bx
    add cpShrink,ax
    push    ax
    cCall   Shrink
    pop ax
    sub cpShrunk,ax

; Load kernel code segment 2 (non-resident code)

    cCall   MyLock,<hLoadBlock>
    mov bx,-1           ; Indicate loading from memory
    cCall   LoadSegment,<hExeHead,si,ax,bx>
    or  ax,ax
    jnz ll2
    pop es
    jmp bootfail
ll2:

    inc si          ; On to segment 3
    xor ax, ax
    xchg    ax, oMSeg       ; Once back only!
    or  ax, ax
    jnz nofastboot

else ;ROM   ---------------------------------------------------------

; The ROM kernel 'loads' the other two kernel segments now.  Currently
; LoadSegment does little more than define the segment to the debugger
; which has already been done for the primary code & data segments.

    cCall   LoadSegment,<hExeHead,2,0,-1>
    cCall   SetROMOwner,<ax,hExeHead>

    cCall   LoadSegment,<hExeHead,3,0,-1>
    cCall   SetROMOwner,<ax,hExeHead>

endif ;ROM  ---------------------------------------------------------


    pop es


    call    genter
    smov    ds, es
    UnSetKernelDS
    SetKernelDS es
     ;;;mov ax,EMScurPID           ; In case an EMS fast boot is going down.
     ;;;mov ds:[TDB_EMSPID],ax

     ;;;mov ax,ds:[TDB_EMSPID]
     ;;;mov PID_for_fake,ax
     ;;;mov EMScurPID,ax
    mov curTDB,ds
    mov headTDB,ds
    push    es

                    ; vectors
SaveVec MACRO   vec
    mov ax, 35&vec
    DOSCALL
    mov [di.off], bx
    mov [di.sel], es
    add di, 4
    ENDM

    push    di
    mov di, TDB_INTVECS
    SaveVec 00h
    SaveVec 02h
    SaveVec 04h
    SaveVec 06h
    SaveVec 07h
    SaveVec 3Eh
    SaveVec 75h

ifdef WOW
;;  Hook Int10 so we can filter calls in WOW (see intnn.asm)
    push    es
    push    ds
    mov     ax,3510h
    INT21
    mov     ax,codeOffset prevInt10proc
    SetKernelCSDword        ax,es,bx
    mov     ax,2510h
    smov    ds,cs
    mov     dx,codeOFFSET Int10Handler
    INT21
    pop     ds
    pop     es
endif

    pop di

    cCall   SaveState,<ds>
    pop es
    mov ds,pGlobalHeap
    call    gleave
    UnSetKernelDS   es

    mov ax, 32          ; Kernel wants a big handle table
    cCall   SetHandleCount,<ax>

    SetKernelDS

;
; The following variable initialization is done here to avoid having
; relocations in Kernel's data segment.
;
    mov lpInt21.off,codeOFFSET Int21Handler
    mov lpInt21.sel,cs

;
; Before we hook exception handlers, make sure the DPMI exception
; handler stack is set up the way Windows likes it.
;
    mov bl,6
    mov ax,0202h        ; DPMI get exception handler vector
    int 31h
    push    cx
    push    dx

    mov cx,cs
    lea dx,fixing_stack
    mov bl,6
    mov ax,0203h        ; DPMI set exception handler vector
    int 31h

    pop dx
    pop cx
;
; Generate an invalid opcode exception fault.  This causes DPMI to call
; our "exception handler."
;
    db  0fh,0ffh
fixing_stack:
    push    bp
    mov bp,sp       ; BP -> BP RETIP RETCS EC IP CS FL SP SS
;
; Restore the previous invalid exception handler vector.
;
    mov bl,6
    mov ax,0203h
    int 31h
;
; Replace the return address on the DPMI fault handler routine with
; our exit code.
;
    lea ax,done_fixing_stack
    mov [bp+8],ax
    mov [bp+10],cs

    lea ax,[bp+16]
    mov ss:[pStackBot],ax
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],offset pStackBot + 150

    mov sp,bp
    pop bp
    retf

done_fixing_stack:

ife ROM
    mov es, MyCSAlias
    assumes es, CODE
endif


; Hook not present fault for segment reloader.

    mov ax,0202h        ; Record old not present fault.
    mov bl,0Bh
    int 31h
    mov prevInt3Fproc.off,dx
    mov prevInt3Fproc.sel,cx

    mov ax,0203h        ; Hook not present fault.
    mov cx,cs
    mov dx,codeOffset SegmentNotPresentFault
    int 31h

; Hook GP fault in order to terminate app.

    mov bl, 0Dh         ; GP Fault
    mov ax, 0202h
    int 31h
    mov prevInt0Dproc.off, dx
    mov prevInt0Dproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset GPFault
    int 31h

; Hook invalid op-code in order to terminate app.

    mov bl, 06h         ; invalid op-code
    mov ax, 0202h
    int 31h
    mov prevIntx6proc.off, dx
    mov prevIntx6proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset invalid_op_code_exception
    int 31h

; Hook stack fault in order to terminate app.

    mov bl, 0Ch         ; stack fault
    mov ax, 0202h
    int 31h
    mov prevInt0Cproc.off, dx
    mov prevInt0Cproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset StackFault
    int 31h

; Hook bad page fault in order to terminate app.

    mov bl, 0Eh         ; page fault
    mov ax, 0202h
    int 31h
    mov prevInt0Eproc.off, dx
    mov prevInt0Eproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset page_fault
    int 31h

ifdef WOW

; Hook divide overflow trap in order to get better WOW debugging.

    mov bl, 00h         ; divide overflow
    mov ax, 0202h
    int 31h
    mov oldInt00proc.off, dx
    mov oldInt00proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset divide_overflow
    int 31h

; Hook single step trap in order to get better WOW debugging.

    mov bl, 01h         ; single step
    mov ax, 0202h
    int 31h
    mov prevInt01proc.off, dx
    mov prevInt01proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset single_step
    int 31h

; Hook breakpoint trap in order to get better WOW debugging.

    mov bl, 03h         ; page fault
    mov ax, 0202h
    int 31h
    mov prevInt03proc.off, dx
    mov prevInt03proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset breakpoint
    int 31h

endif

    assumes es, nothing

; Do a slimy fix-up of __WinFlags containing processor and protect mode flags

    xor ax,ax
    mov dx,178
    cCall   GetProcAddress,<hExeHead,ax,dx>
    mov ax,WinFlags
    mov es:[bx],ax

ifdef WOW
    ; get WOW32 thunk table offsets and do fixups

    ; WARNING: WOW32 has a dependency on this being called after
    ; kernel is done booting and addresses are fixed
    push    ds
    push    dataoffset MOD_KERNEL
    call    far ptr WOWGetTableOffsets

    mov     si, dataoffset MOD_KERNEL
    mov     cx, ModCount ; # fixups to do
    mov     di, 570      ; first ordinal of the group (DANGER hardcoded from kernel.def)

Mexico:

    push    si
    push    di
    push    cx

    push    hExeHead
    push    0
    push    di  
    call    GetProcAddress

    pop     cx
    pop     di
    pop     si
    mov     ax,[si]
    mov     es:[bx],ax

    inc     si  ; point to next word
    inc     si
    inc     di  ; get next ordinal

    loop    Mexico
endif

ife ROM ;--------------------------------

; Can't do slimy fix-ups in ROM--already done by ROM Image Builder

; Do a very slimy fix-up of the runtime constant __0000h

    cCall   GetProcAddress,<hExeHead,0,183>
    mov si,bx
    mov bx,00000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __0040h

    cCall   GetProcAddress,<hExeHead,0,193>
    mov si,bx
    mov bx,00040h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __ROMBIOS

    cCall   GetProcAddress,<hExeHead,0,173>
    mov si,bx
    mov bx,0F000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __F000h

    cCall   GetProcAddress,<hExeHead,0,194>
    mov si,bx
    mov bx,0F000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __A000h

    cCall   GetProcAddress,<hExeHead,0,174>
    mov si,bx
    mov bx,0A000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __B000h

    cCall   GetProcAddress,<hExeHead,0,181>
    mov si,bx
    mov bx,0B000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __B800h

    cCall   GetProcAddress,<hExeHead,0,182>
    mov si,bx
    mov bx,0B800h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __C000h

    cCall   GetProcAddress,<hExeHead,0,195>
    mov si,bx
    mov bx,0C000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __D000h

    cCall   GetProcAddress,<hExeHead,0,179>
    mov si,bx
    mov bx,0D000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __E000h

    cCall   GetProcAddress,<hExeHead,0,190>
    mov si,bx
    mov bx,0E000h
    mov ax,2
    int 31h
    mov es:[si],ax

endif   ;ROM    -------------------------

ifndef WOW
    cCall   SetUserPro      ; Get WIN.INI filename from environment
endif

    CheckKernelDS

; Free high memory copy of KERNEL.EXE

ife ROM
    cCall   IGlobalFree,<hLoadBlock>
    mov hLoadBlock,ax
else
    xor ax, ax
endif

if PMODE32
        .386
    mov fs, ax
    mov gs, ax
        .286p
endif

ifndef WOW
    cmp lpWindowsDir.sel,ax
    jnz got_win_dir
    mov si,dataOffset szUserPro
    mov di,dataOffset [WinIniInfo.ProBuf]
    cCall   IOpenFile,<dssi,dsdi,OF_PARSE>
    lea di,[di].opfile
    mov lpWindowsDir.sel,ds
    mov lpWindowsDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesWinDir,di
got_win_dir:
endif

ifdef WOW
; Regular Windows kernel sets up the Windows directory very early in
; boot, before WOW kernel loads WOW32.DLL.
;
; It turns out we can delay setting up the 16-bit copy of the
; windows directory (referred by lpWindowsDir) until here, where
; we're in protected mode and about to set up the system directories
; as well.  This allows us to call a GetShortPathName thunk in
; WOW32.
;

    mov ds,topPDB
    UnSetKernelDS
    mov ds,ds:[PDB_environ]

    call    get_windir      ; on return, DS:DI -> windows dir

    smov    es,ds
    SetKernelDS

; Record where to find the 'windows' directory.
    BootTrace   'q'

    mov lpWindowsDir.sel,es
    mov lpWindowsDir.off,di
    mov cBytesWinDir,cx

; Record where to find the 'system32' directory.

    mov ax,hExeHead
    mov es,ax
    mov di,es:[ne_pfileinfo]
    lea di,es:[di].opFile
    mov lpSystemDir.sel,es
    mov lpSystemDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesSysDir,di

    BootTrace   'u'

;
; Under WOW there are two system directories: \nt\system and \nt\system32.
; lpSystemDir points to \nt\system32, while lpSystem16Dir points to
; \nt\system.  We return the latter from GetSystemDirectory, since we want
; applications to install their shared stuff in \nt\system, but we want
; to search \nt\system32 before \nt\system when loading modules.
; Set up lpSystem16Dir using the Windows dir + \system.
; Note that the string pointed to by lpSystem16Dir is not null terminated!

    mov lpSystem16Dir.sel,ds
    mov lpSystem16Dir.off,dataoffset achSystem16Dir

    cld
    mov si,dataoffset achRealWindowsDir
    mov es,lpSystem16Dir.sel
    mov di,lpSystem16Dir.off
    mov cx,cbRealWindowsDir
    rep movsb                      ; copy Windows dir

    mov si,dataoffset Sys16Suffix
    mov cx,cBytesSys16Suffix
    rep movsb                      ; tack on "\system"

    mov cx,cbRealWindowsDir
    add cx,cBytesSys16Suffix
    mov cBytesSys16Dir,cx


;
; build the Wx86 system directory "Windir\Sys32x86"
;
    mov lpSystemWx86Dir.sel,ds
    mov lpSystemWx86Dir.off,dataoffset achSystemWx86Dir

    mov es,lpSystemWx86Dir.sel
    mov di,lpSystemWx86Dir.off
    mov cx,cbRealWindowsDir
    mov si,dataoffset achRealWindowsDir
    rep movsb                      ; copy System dir (Windows\System32)

    mov si,dataoffset SysWx86Suffix
    mov cx,cBytesSysWx86Suffix
    rep movsb                      ; tack on "\Wx86"

    mov cx,cbRealWindowsDir
    add cx,cBytesSysWx86Suffix
    mov cBytesSysWx86Dir,cx


@@:
;   WOW DPMI Supports wants to call GlobalDosAlloc and GlobalDosFree so that
;   We don't have to write the same code for DPMI support.   So we call DPMI
;   Here with the addresses of those routines so he can call us back.

    mov     bx,cs
    mov     si,bx

    mov     dx,codeOffset GlobalDosAlloc
    mov     di,codeOffset GlobalDosFree

    mov     ax,4f3h
    int     31h
    
; Now that we've built up the system dir from the windows dir, set 
; the windows dir to where it should be for this user.
    push  es
    cld
    mov   di,offset achTermsrvWindowsDir
    cCall TermsrvGetWindowsDir,<ds, di, MaxFileLen>
    or    ax, ax                
    jz    @F                    ; ax = 0 -> error, just leave windows dir

    smov es,ds
    mov  cx,-1
    xor  ax,ax
    repnz scasb
    not  cx
    dec  cx                     ; length of windows directory 

    mov lpWindowsDir.sel,ds
    mov lpWindowsDir.off,offset achTermsrvWindowsDir
    mov cBytesWinDir,cx
@@:
    pop  es
    
endif


; Under win 2.11 we allowed the ":" syntax to replace the shell.
;  We no longer allow this, however to avoid messing up people
;  with batch files that have ":" in them we will strip the
;  ":" out of the command line.  But we retain the :: syntax
;  for the OS/2 VM!!

; We also do the check for the /b switch here.  This puts us in "diagnostic
;  mode and we set a flag to say this.  Later, we will call the DiagInit()
;  function to open the log file, etc.

    push    ds
    cld
    mov ds,topPDB
    UnSetKernelDS
    push    ds
    pop es
    mov si,80h
    xor ax,ax
    lodsb
    or  al,al
    jz  no_colon
    mov cx,ax
@@: lodsb
    cmp al,' '
    loopz   @B
    cmp al,':'
    jnz no_colon
    cmp byte ptr [si],':'
    jz  no_colon
    mov byte ptr [si][-1],' '
no_colon:
        cmp     al,'/'                  ;Switch character?
        je      CheckSwitch             ;Yes
        cmp     al,'-'                  ;Other switch character?
        jne     NoSwitch                ;Nope.
CheckSwitch:
        lodsb                           ;Get next char
        or      al,32                   ;Convert to lowercase if necessary
        cmp     al,'b'                  ;Diagnostic mode?
        jnz     NoSwitch                ;Nope
        cCall   DiagInit                ;Initialize diagnostic mode
        mov     WORD PTR [si-2],2020h   ;Blank out the switch
NoSwitch:
    pop ds
    ReSetKernelDS

        ;** Reset secret flag for memory manager.  Fixed segments will go
        ;** >1MB after this
        and     fBooting, NOT 2

        ;** We want to grow the SFT *before* loading the modules,
        ;**     not after, like was the case previous to win3.1
    call    GrowSFTToMax        ;add to SFT chain in p mode

if 1
; old ldinit.c

    cld
    push    ds
    smov    es,ds
    xor ax,ax
    xor cx,cx
    mov ds,topPDB
    UnSetKernelDS
    mov si,80h
    lodsb
    or  al,al
    jz  gwaphics_done
    mov cl,al
    lodsb
    cmp al,' '
    mov al,ah
    jnz gwaphics_done
    lodsb
    cmp al,':'
    mov al,ah
    jnz gwaphics_done
    lodsb
    cmp al,':'
    mov al,ah
    jnz gwaphics_done

    mov di,dataOffset app_name

find_delineator:
    lodsb
    stosb
    cmp al,' '
    ja  find_delineator
    mov es:[di][-1],ah
    mov ds:[80h],ah     ; assume no arguments
    jnz gwaphics_done

    add cx,82h
    sub cx,si
    smov    es,ds
    mov di,80h
    mov al,cl
    stosb
    rep movsb

gwaphics_done:
    pop ds
    ReSetKernelDS
    or  ax,ax
    jz  @F
    mov graphics,0
@@:
else
    cld
    xor ax,ax
    xor bx,bx
endif
    jmps    SlowBoot


bootfail:
    mov al,1
    cCall   ExitKernel,<ax>
cEnd nogen

sEnd    INITCODE

;-----------------------------------------------------------------------;
; SlowBoot                              ;
;                                   ;
;                                   ;
; Arguments:                                ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Sat Mar 14, 1987 05:52:22p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

DataBegin INIT

BootSect    db  'BOOT',0
BootFile    db  'SYSTEM.INI',0
FilesCached db  'CACHEDFILEHANDLES',0
IdleSegLoad db  'LOADSEGMENTSATIDLE',0
ifdef WOW
ExitLastApp db  'CLOSEONLASTAPPEXIT',0
endif

if SHERLOCK
  szGPC     db  'GPCONTINUE',0
endif

szDebugSect db  'DEBUG',0
szOutputTo  db  'OUTPUTTO', 0
szAux       db  0 ;'AUX', 0     ; don't return a default

if KDEBUG
szKRInfo    db  'KERNELINFO', 0
szKRBreak   db  'KERNELBREAK', 0
szWin3Info  db  'WIN3INFO', 0
szWin3Break db  'WIN3BREAK', 0
endif

ife PMODE32
Standard    db  'STANDARD',0
PadCodeStr  db  'PADCODESEGMENTS',0
endif

BootBufLen  equ     80
BootBuf     db  BootBufLen dup (?)

bootmods label  byte
    DB  'SYSTEM.DRV',0
winmods label   byte
ifdef WOW
    DB  'KEYBOARD.DRV',0
szAfterKeyboardDriver label byte        ;Used so we can tell key driver loaded
    DB  'MOUSE.DRV',0

ifdef   FE_SB
szBeforeWifeMan label byte  ;Used so we can tell key driver loaded
    DB  'WIFEMAN.DLL', 0    ;WIFE manager has to be loaded before display driver
endif
    DB  'VGA.DRV',0
        DB      'SOUND.DRV',0
        DB      'COMM.DRV',0
        DB      'USER.EXE',0
        DB      'GDI.EXE',0
ifdef   FE_SB   
szBeforeWinNls label byte   ;Used so we can tell key driver loaded
    DB  'WINNLS.DLL', 0     ;bug #112335
endif

else
        DB      'KEYBOARD.DRV',0
szAfterKeyboardDriver label byte    ;Used so we can tell key driver loaded
    DB  'MOUSE.DRV',0
ifdef   FE_SB
szBeforeWifeMan label byte  ;Used so we can tell key driver loaded
    DB  'WIFEMAN.DLL', 0    ;WIFE manager has to be loaded before
                    ;display driver
endif
    DB  'DISPLAY.DRV',0
    DB  'SOUND.DRV',0
    DB  'COMM.DRV',0
    DB  'FONTS.FON',0
    DB  'OEMFONTS.FON',0    ; For Internationals use.
    DB  'GDI.EXE',0
    DB  'USER.EXE',0
ifdef   FE_SB
szBeforeWinNls label byte   ;Used so we can tell key driver loaded
    DB  'WINNLS.DLL', 0    
endif

endif

ifdef WOW
defapp  label   byte
    DB  'WOWEXEC.EXE',0
else
defapp  label   byte
    DB  'PROGMAN.EXE',0
endif

Shell   label   byte
    DB  'WOWSHELL',0

;** Ordinal strings for two of the Keyboard driver exports
keymodstr   DB  'KEYBOARD',0
keyprocstr  DB  '#5',0      ; keyprocstr = AnsiToOem
keyprocstr1 DB  '#6',0      ; keyprocstr = OemToAnsi

DataEnd INIT

sBegin  INITCODE
assumes cs,CODE
assumes ds,nothing
assumes es,nothing

if BootTraceOn
cProc   BootTraceChar,<PUBLIC,NEAR,NODATA>, <ax, dx>
    parmW   char
cBegin
    mov dx, 3fdh
@@: in  al, dx
    test    al, 20h
    jz  @B
    mov ax, char
    mov dx, 3f8h
    out dx, al
cEnd

endif   ; BootTraceOn



cProc   ttywrite,<PUBLIC,NEAR,NODATA>, <ds, si>
    parmD   s
cBegin
;   cCall   lstrlen,<s>
;   mov cx, ax
;   lds bx, s
;   mov bx,1
;   mov ah,40h
;   int 21h
    lds si, s
    cld
    mov ah, 2
tty1:
    lodsb
    mov dl, al
    or  dl, dl
    jz  tty2
    int 21h
    jmps    tty1
tty2:
cEnd

ifdef WOW
cProc   LoadFail,<PUBLIC,NEAR,NODATA>, <ds,si,di,cx>
    parmD   s
cBegin
    ;** Put Up a Dialog Box If we can't load a module

    ; since szPleaseDoIt resides in protected cs we can't concat the module
    ; name to it -- so we need to copy it to the stack

    ;szPleaseDoIt db "Please re-install the following module to your system32
    ;                 directory: ",13,10,9,9,0
    mov     di,sp      ; save current stack pointer
    sub     sp,100h    ; allocate for new concat'd string on the stack
    mov     si,sp      ; save the start of the stack string

    push    ss         ; copy szPleaseDoIt to the stack buffer
    push    si
    push    cs
    push    codeOFFSET szPleaseDoIt
    call    lstrcpy

    push    ss         ; concat module name to string on stack
    push    si
    lds     cx, s      ; get the module name
    push    ds
    push    cx
    call    lstrcat

    push    ss         ;push finished stack string now
    push    si
    push    cs         ;szMissingMod db "KERNEL: Missing 16-bit module:",0
    push    codeOFFSET szMissingMod      ; Set Caption 
    push    0                            ;No left button
    push    SEB_CLOSE + SEB_DEFBUTTON    ;Button 1 style
    push    0                            ;No right button
externFP kSYSERRORBOX
    call    kSYSERRORBOX                 ;Put up the system message

    mov     sp,di                        ; restore sp
cEnd
else  // non-WOW
cProc   LoadFail,<PUBLIC,NEAR,NODATA>, <ds>
    parmD   s
cBegin
    SetKernelDS
    cCall   TextMode
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
    mov bx, dataoffset szBootLoad
    cCall   ttywrite, dsbx
    cCall   ttywrite, s
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
cEnd
endif

cProc   SlowBoot,<PUBLIC,NEAR>
cBegin nogen

    CheckKernelDS
    ReSetKernelDS

GPPI    macro   sect, key, defval, file, storeit
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    defval

    push    ds
    push    dataoffset file

    call    GetPrivateProfileInt
ifb <storeit>
    mov defval, ax
endif
endm


GPPS    macro   sect, key, defval, here, hereLen, file
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    ds
    push    dataoffset defval

    push    ds
    push    dataoffset here

    push    hereLen

    push    ds
    push    dataoffset file

    call    GetPrivateProfileString
endm

GPPS1   macro   sect, key, defval, here, hereLen, file
    push    ds
    push    dataoffset sect

    push    ds
    push    key

    push    ds
    push    defval

    push    ds
    push    dataoffset here

    push    hereLen

    push    ds
    push    dataoffset file

    call    GetPrivateProfileString
endm

GPI macro   sect, key, defval, storeit
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    defval

    call    GetProfileInt
ifb <storeit>
    mov defval, ax
endif
endm

ife PMODE32
        xor     ax,ax
        mov     al,fPadCode
        GPPI    Standard, PadCodeStr, ax, BootFile, nostore
        or      al,ah
        mov     fPadCode,al
endif

if SHERLOCK
    GPI szKernel, szGPC, gpEnable
endif

if KDEBUG
ifdef DISABLE
    GPPI    szDebugSect, szKRInfo, _krInfoLevel, BootFile

    GPPI    szDebugSect, szKRBreak, _krBreakLevel, BootFile

    GPPI    szDebugSect, szWin3Info, _Win3InfoLevel, Bootfile

    GPPI    szDebugSect, szWin3Break, _Win3BreakLevel, Bootfile
endif
endif   ;KDEBUG

    GPPS    szDebugSect, szOutputTo, szAux, BootBuf, BootBufLen, BootFile
    or  ax, ax
    jz  @F
    cmp ax, BootBufLen-2
    jz  @F

    mov ah, 3ch     ; creat file (zero length)
    xor cx, cx
    mov dx, dataOffset BootBuf
    DOSCALL
    jc  @F

    mov bx, ax
    mov ah, 3eh     ; now close it
    DOSCALL
    jc  @F

    mov ax, 3d42h   ; open inherit, deny none, read/write
    DOSCALL
    jc  @F

    mov bx, ax      ; dup handle
    mov cx, 3       ; force AUX to be this file
    mov ah, 46h
    DOSCALL

    mov ah, 3eh     ; close temp file
    DOSCALL
    mov wDefRIP, 'i'    ; since AUX is redirected, assume Ignore RIP
@@:

    GPPI    BootSect, FilesCached, MAXFHCACHELEN, BootFile, nostore
    cmp ax, MINFHCACHELEN       ; Validate length
    jae @F
    mov ax, MINFHCACHELEN
@@: cmp ax, MAXFHCACHELEN
    jbe @F
    mov ax, MAXFHCACHELEN
@@: mov fhCacheLen, ax      ; Adjust # of cached file handles
    shl ax, 1
    shl ax, 1
    add ax, dataoffset fhCache
    mov fhCacheEnd, ax

    GPPI    BootSect, IdleSegLoad, 1, BootFile, nostore
    mov fPokeAtSegments, al

ifdef WOW
    GPPI    BootSect, ExitLastApp, 0, BootFile, nostore
    mov fExitOnLastApp, al
endif

    mov bootExecBlock.lpfcb1.off,dataOffset win_show
    mov bootExecBlock.lpfcb1.sel,ds
    mov es,topPDB

    mov bootExecBlock.lpcmdline.off,80h
    mov bootExecBlock.lpcmdline.sel,es

    mov lpBootApp.off,dataOffset app_name
    mov lpBootApp.sel,ds
    cmp graphics,1
    jnz sb1

    mov lpBootApp.off,dataOffset defapp
    mov lpBootApp.sel,ds

sb1:    mov di,dataOffset bootMods

sbloop1:
    cCall   LoadNewExe,<di>
    SetKernelDS es
    mov cx,-1
    xor ax,ax
    cld
    repnz   scasb
    cmp di,dataOffset winmods
    jb  sbloop1

    cmp graphics,1
    jz  sbloop2
;    cCall   InitFwdRef
    jmps    sb4
    UnSetKernelDS   es

sbloop2:                ; load USER.EXE, GDI.EXE
ifdef   FE_SB
        ;** If we just load the fae east modules, we want to
        ;**     checks the system locale vale which is far east
        ;**     locale.
        ;**     If system locale is not far east, then we skip
        ;**     to load far east module.
        cmp     di,dataOffset szBeforeWifeMan
        je      SB_DoFarEastModule
        cmp     di,dataOffset szBeforeWinNls
        jne     SB_DoLoadModule

SB_DoFarEastModule:
                cCall   GetSystemDefaultLangID
                ; return: ax is system locale value
                cmp     ax,411h
                je      SB_DoLoadModule
                cmp     ax,412h
                je      SB_DoLoadModule
                cmp     ax,404h
                je      SB_DoLoadModule
                cmp     ax,804h
                je      SB_DoLoadModule
                cmp     ax,0c04h
                je      SB_DoLoadModule

                        ; skip to next module
                        mov cx,-1
                        xor ax,ax
                        cld
                        repnz   scasb
                        jmp     SB_NotKeyboardDriver
SB_DoLoadModule:
endif
    cCall   LoadNewExe,<di>
        push    ax                      ; Save hInst return value
    SetKernelDS es
    mov cx,-1
    xor ax,ax
    cld
    repnz   scasb
        pop     si                      ; Get hInst of latest module in SI

        ;** If we just loaded the keyboard driver, we want to
        ;**     point our explicit link variables to the AnsiToOem and
        ;**     OemToAnsi functions so OpenFile can use them for the
        ;**     remaining boot modules
        cmp     di,dataOffset szAfterKeyboardDriver
        jne     SB_NotKeyboardDriver

        push    ds                      ; Save regs we care about
        push    di
    regptr  pStr,ds,bx

    mov bx,dataOffset keyprocstr
    cCall   GetProcAddress,<si,pStr>
    mov pKeyProc.off,ax
    mov pKeyProc.sel,dx

    mov bx,dataOffset keyprocstr1
    cCall   GetProcAddress,<si,pStr>
    mov pKeyProc1.off,ax
    mov pKeyProc1.sel,dx

    pop     di
    pop     ds

SB_NotKeyboardDriver:
    cmp di,dataOffset defapp
    jb  sbloop2

; OPTIMIZE BEGIN

; OPTIMIZE END

sb4:
    cCall   InitFwdRef              ; Gets stuff we can't dynalink to
    cCall   InternalEnableDOS   ; Enable int21 hooks
;sb4:
    call    check_TEMP

; Get the shell name from SYSTEM.INI

    mov     ax,dataoffset Shell
    GPPS1   BootSect, ax, lpBootApp.off, BootBuf, BootBufLen, BootFile

    ;** Here we need to convert the command line to ANSI
    cmp     WORD PTR pKeyProc1[2],0 ; Paranoia...
    jz      @F

    ;** Zero terminate the string before passing to OemToAnsi
    mov     es,bootExecBlock.lpcmdline.sel
    mov     bl,es:[80h]             ; Get length byte
    xor     bh,bh
    xchg    BYTE PTR es:[bx+81h],bh ; Replace terminator char with zero

    ;** Call the keyboard driver
    push    es                      ; Save the seg reg
    push    bx                      ; Save offset and char saved
    push    es
    push    81h                     ; Always starts here (fixed offset)
    push    es
    push    81h
    cCall   [pKeyProc1]             ; Call OemToAnsi in keyboard driver
    pop     bx                      ; Get saved info
    pop     es
    mov     al,bh                   ; Saved char from string
    xor     bh,bh
    mov     BYTE PTR es:[bx+81h],al ; Replace the character
@@:

    mov ax,dataOffset bootExecBlock
    regptr  dsax,ds,ax
    cmp graphics,1
    jz  @F

    cCall   LoadModule,<lpBootApp,dsax>
    jmps    asdf

@@: cCall   FlushCachedFileHandle,<hUser>   ; in case 100 fonts are loaded
    farptr  lpBootBuf,ds,di
    mov di, dataoffset BootBuf
    cCall   LoadModule,<lpBootBuf,dsax>

asdf:
    cmp ax,32
    jbe sb6

    cCall   GetExePtr,<ax>
    mov hShell, ax
    jmp bootdone

sb6:
    ReSetKernelDS
    les bx, lpBootApp
    krDebugOut DEB_ERROR, "BOOT: unable to load @ES:BX"
    cCall   LoadFail,<lpBootApp>

;   cmp pDisableProc.sel,0  ; Is there a USER around yet?
;   jz  @F
;   cCall   pDisableProc
;@@:
    jmp bootfail
    UnSetKernelDS
cEnd nogen


;------------------------------------------------------------------------

    assumes ds,nothing
    assumes es,nothing

cProc   LoadNewExe,<PUBLIC,NEAR>,<si,di>
    parmW   pname
cBegin
    farptr  lpparm,ax,ax
    farptr  lpBootBuf,ds,di
    mov di, dataoffset BootBuf

    CheckKernelDS
    ReSetKernelDS
ifdef WOW
;   ATM Alters system.ini registry boot section to load its own SYSTEM.DRV
;   However on WOW this causes us to fail to load correctly.   Also we
;   would be hard pushed to support the current 16 bit ATM since it relies
;   on internals of 16 bit GDI which are not present in WOW.
;   For this Beta I'm going to ignore the bootsection of the registry
;   when loading drivers and thus ATM will not get installed.
;   At least the user will be protected from not being able to boot WOW
;   BUGBUG - Consider
;   MattFe Oct9 92

    mov     di,pname
else
    GPPS1   BootSect, pname, pname, BootBuf, BootBufLen, BootFile
endif
    xor ax,ax
    cCall   LoadModule,<lpBootBuf,lpparm>
    cmp ax,2
    jne lne1
    krDebugOut DEB_ERROR, "Can't find @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Unable to find file - >,ds,di
    jmps    lne4
lne1:
    cmp ax,11
    jne lne2
    krDebugOut DEB_ERROR, "Invalid EXE file @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Invalid .EXE file - >,ds,di
    jmps    lne4
lne2:
    cmp ax,15
    jnz lne3
    krDebugOut DEB_ERROR, "Invalid protect mode EXE file @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Invalid protect mode .EXE file - >,ds,di
    jmps    lne4

lne3:
    cmp ax, 4
    jne lne3a
    krDebugOut DEB_ERROR, "Out of files (set FILES=30 in CONFIG.SYS) @DS:DI"
;   kerror  ERR_LDFILES,<BOOT: Out of files, (set FILES=30 in CONFIG.SYS) loading - >,ds,di
    jmps    lne4

lne3a:
    cmp ax, 32
    jae lnex

NoLoadIt:
;   kerror  ERR_LDBOOT,<BOOT: Unable to load - >,ds,pname
    krDebugOut DEB_ERROR, "Unable to load @DS:DI (#ax)"
lne4:
    cCall   LoadFail,dsdi
    mov ax,1
    cCall   ExitKernel,<ax>
lnex:
    UnSetKernelDS
cEnd

sEnd    INITCODE

;-----------------------------------------------------------------------;
; BootDone                              ;
;                                   ;
; Boot is done when all of modules are loaded.  Here we do a bit of ;
; clean up, such as validating code segments, initing free memory to    ;
; CCCC, freeing up the fake TDB, and finally reallocating the init  ;
; code away.                                ;
;                                   ;
; Arguments:                                ;
;   none                                ;
;                                   ;
; Returns:                              ;
;   nothing                             ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;   all                             ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed Apr 15, 1987 08:53:23p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;


DataBegin INIT

externB beg_initdata

szKernel    DB  'KERNEL',0
szWindows       DB  'WINDOWS',0

if KDEBUG
szDebugOptions  DB  'DebugOptions',0
szDebugFilter   DB  'DebugFilter',0

szChecksum  DB  'EnableSegmentChecksum',0
szSweepFreak    DB  'LRUSweepFrequency',0
sz80x87     DB  'NoUse80x87',0
szFastFP    DB  'FastFP', 0

externW DebugOptions
externW DebugFilter

ifdef DISABLE
externB fLoadTrace
endif

endif   ; KDEBUG

ifdef SDEBUG
szEMSDebug  DB  'EnableEMSDebug',0
endif
szgrab_386  DB  '386GRABBER',0

if SWAPPRO
szSwapPro   DB  'SwapProfile',0
szSwapFile  DB  'SWAPPRO.DAT',0
endif

DataEnd INIT


sBegin  INITCODE
assumes cs,CODE
assumes ds,nothing
assumes es,nothing

externB beg_initcode


cProc   BootDone,<PUBLIC,NEAR>
cBegin  nogen

    SetKernelDS

if KDEBUG

; Get win.ini [Windows] DebugOptions
        GPI     szWindows, szDebugOptions, DebugOptions
; Get win.ini [Windows] DebugFilter
        GPI     szWindows, szDebugFilter, DebugFilter

; Now set various internal flags based on DebugOptions

        xor     ax,ax
        test    DebugOptions,DBO_CHECKHEAP
        jz      @F
        inc     ax
@@:
    mov es,pGlobalHeap
    mov es:[hi_check],ax

        test    DebugOptions,DBO_CHECKFREE
        jz      @F
    or  Kernel_flags,kf_check_free
@@:
ifdef DISABLE
        xor     ax,ax
        test    DebugOptions,DBO_LOADTRACE
        jz      @F
    mov fLoadTrace, al
@@:
endif ; DISABLE
        test    DebugOptions,DBO_DISABLEGPTRAPPING
        jz      wants_trapping

    mov ax,0203h        ; Reset GP fault.
    mov bl,0Dh
    mov cx,prevInt0Dproc.sel
    mov dx,prevInt0Dproc.off
    int 31h

    mov ax,0203h        ; Reset invalid op-code exception.
    mov bl,06h
    mov cx,prevIntx6proc.sel
    mov dx,prevIntx6proc.off
    int 31h

    mov ax,0203h        ; Reset page fault.
    mov bl,0Eh
    mov cx,prevInt0Eproc.sel
    mov dx,prevInt0Eproc.off
    int 31h
wants_trapping:

if SWAPPRO
    GPI szKernel, szSwapPro, 1, nostore
    mov fSwapPro, al

    mov bx,TopPDB
    mov ah,50h
    pushf
    FCLI
    call    prevInt21Proc

    lea dx,szSwapFile
    xor cx,cx
    mov ah,3Ch
    pushf
    FCLI
    call    prevInt21Proc
    mov hSwapPro,ax

    mov bx,cur_dos_pdb
    mov ah,50h
    pushf
    FCLI
    call    prevInt21Proc
endif
    GPI szKernel, szChecksum, 1, nostore
    mov fChkSum,al

    GPI szKernel, sz80x87, 0, nostore
    or  ax,ax
    jz  wants_8087
    mov f8087,0
    and     WinFlags,NOT WF1_80x87  ;Turn off corresponding WinFlags bit
wants_8087:
    GPI szKernel, szFastFP, 1, nostore
    mov fastFP, al

    GPI szKernel, szSweepFreak, 500, nostore
else
    mov ax, 500
endif   ; KDEBUG

ifdef WOW
    xor ax,ax
endif

    or  ax,ax
    jz  nolrusweep

    test    WinFlags[1], WF1_PAGING
    jnz short nolrusweep

    mov bx,codeOffset lrusweep
    regptr  csbx,cs,bx
    xor dx,dx
    cCall   pTimerProc,<dx,ax,csbx>
nolrusweep:

if SDEBUG
    GPI szKernel, szEMSDebug, 0, nostore
    or  ax,ax
    jz  no_EMS_debug_wanted
    or  Kernel_flags,kf_EMS_debug
no_EMS_debug_wanted:
endif

if LDCHKSUM
    cCall   ValidateCodeSegments
endif

if KDEBUG
    mov fCheckFree,0

ife PMODE32
    call    init_free_to_CCCC
endif

endif

; Get the shell name from SYSTEM.INI

    GPPS    BootSect, szgrab_386, szgrab_386, grab_name, 128, BootFile

    mov es,curTDB       ; ES = TDB of fake task
    push    es
    cCall   DeleteTask,<es>     ; Flush bogus task
    pop es
    xor dx,dx
    mov es:[TDB_sig],dx     ; Clear signature word.
    mov curTDB,dx       ; Let someone else be current task

; switch to the temp stack since we're about to Realloc the present one away

    mov ax, ss

    FCLI
    SetKernelDS ss
    mov sp,dataOffset gmove_stack
    FSTI

    cCall   free_sel,<ax>


; Shrink DGROUP down to its post initialization size

    mov     cx,dataOFFSET beg_initdata   ; don't need init data

    ; dx doubles as high word and specifies fixed
    ; reallocation
    xor     dx,dx
    cCall   IGlobalReAlloc,<ds,dx,cx,dx>     ; Realloc DGROUP

    xor     dx,dx


; Now shrink the resident CODE segment

ife ROM
    mov cx,codeOFFSET beg_initcode   ; dont need init code

;   cCall   IGlobalReAlloc,<cs,dxcx,dx>
;   jmps    BootSchedule          ; Jump to schedule first app

    push    cs      ; Arguments to GlobalReAlloc
    push    dx
    push    cx
    push    dx
    push    cs      ; Where GlobalReAlloc will eventually return
    mov ax,codeOFFSET BootSchedule
    push    ax
    jmp near ptr IGlobalReAlloc  ; Jump to GlobalReAlloc

else ;ROM

    jmp BootSchedule
endif
    UnSetKernelDS   ss
    UnSetKernelDS
cEnd    nogen


;-----------------------------------------------------------------------;
; check_TEMP
;
; If the environment variable TEMP points to garbage then GetTempFile
; screws up.  We fix it by wiping out the TEMP string if it points
; to garbage.
;
; Entry:
;   none
;
; Returns:
;
; Registers Preserved:
;   all
;
; History:
;  Thu 11-May-1989 16:39:34  -by-  David N. Weise  [davidw]
; Wrote it.
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   check_TEMP,<PUBLIC,NEAR>,<ds,es>
ifdef   FE_SB
    localW  pMyBuf
endif
cBegin
    pusha
    SetKernelDS
    sub sp,130
    mov di,sp
    CheckKernelDS
    mov ds,TopPDB
    UnSetKernelDS
    mov ds,ds:[PDB_environ]
    xor si, si          ; assume DS:SI points to environment
    cCall   GetTempDrive,<si>
    smov    es,ss
    cld
    stosw
ifdef   FE_SB
    mov pMyBuf,di       ; save string offset(exclude D:)
endif
stmp2:
    lodsw
    or  al,al           ; no more enviroment
ifdef   FE_SB
    jnz @F          ; I hate this
    jmp stmpNo1
@@:
else
    jz  stmpNo1
endif
    cmp ax,'ET'         ; Look for TEMP=
    jne stmp3
    lodsw
    cmp ax,'PM'
    jne stmp3
    lodsb
    cmp al,'='
    je  stmpYes
stmp3:  lodsb
    or  al,al
    jnz stmp3
    jmp stmp2
stmpYes:
    push    si          ; save pointer to TEMP
    push    ds

    push    si          ; spaces are legal, but they
lookForSpace:               ; confuse too many apps, so
    lodsb               ; we treat them as illegal
    cmp al, ' '
    jz  stmpFoundSpace
    or  al, al
    jnz lookForSpace
    pop si
    cmp byte ptr [si+1],':'
    jne stmpnodrive
    and byte ptr [si],NOT 20h   ; springboard needs this!
    dec di
    dec di
stmpnodrive:
    lodsb
    or  al,al
    jz  stmpNo
    stosb
    jmp stmpnodrive

stmpNo:
    mov ax,'~\'
    cmp es:[di-1],al        ; does it already end in \
    jnz stmpNoF         ; no, just store it
    dec di          ; override it
ifdef   FE_SB
    push    si
    mov si,pMyBuf
    call    FarMyIsDBCSTrailByte    ;is that '\' a DBCS trailing byte?
    cmc
    adc di,0            ;skip it if yes.
    pop si
endif
stmpNoF:
    stosw
    xor ax,ax
    stosb               ; zero terminate it
    pop es          ; recover pointer to TEMP
    pop di
    smov    ds,ss
    mov dx,sp
    mov ax,5B00h
    xor cx,cx
    DOSCALL
    jnc stmpClose
    cmp al,80           ; Did we fail because the file
    jz  stmpNo1         ;  already exists?
stmpNukeIt:
    sub di,5            ; Get the TEMP= part.
@@: mov al,'x'
    xchg    al,es:[di]
    inc di
    or  al,al
    jnz @B
    mov byte ptr es:[di-1],0
    jmps    stmpNo1

stmpClose:
    mov bx,ax
    mov ah,3Eh
    DOSCALL
    mov ah,41h
    DOSCALL

stmpNo1:
    add sp,130
    popa
cEnd
stmpFoundSpace:
    pop si
    pop     es
    pop di
    jmps    stmpNukeIt


;-----------------------------------------------------------------------;
; get_windir
;
; Get a pointer to the 'windows' directory.
;
; Entry:
;   DS => environment string
;
; Returns:
;   CX = length of string
;   DI => WFP of 'windows' directory
;
; Registers Preserved:
;   all
;
; History:
;  Mon 16-Oct-1989 23:17:23  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

ifdef WOW
;-----------------------------------------------------------------------;
; original get_windir looks for the environment variable 'windir' (all
; lowercase) to set the 'windows' directory.
;
; On NT the equivalent environment variable is 'SystemRoot' (all
; uppercase). Hence the code is different.
;
;                                             - nanduri
;
; There are some customers that used the undocumented trick on win31
; of moving windir to some network location by putting win.com there.
; The result would be that the "Windows Directory" would point
; to the network location, and the system directory would be local.
; Currently, the way WINDIR is supported involves hacks in a couple
; of different places. What would be best is if you could do a
; "set windir=xxxx" in your autoexec.nt and we would look for windir
; here and we would code it to emulate win31 behavior. However, that's
; broken right now, and windir is only regenerated after krnlx86.exe
; has finished booting. So the approach taken here is to look for
; a new environment variable called win16dir, and if it exists, make
; the windows directory point to it. Systemroot is still used to 
; generate the system directory.
;
; We want to allow NT to be installed into a directory with a long
; name, so we use GetShortPathName on the directory we get from
; either SystemRoot or Win16Dir variables.
; -- DaveHart 9-Feb-96
;-----------------------------------------------------------------------;

szSystemRoot  DB  'SYSTEMROOT=',0
szWin16Dir    DB  'WIN16DIR=',0

cProc   get_windir,<PUBLIC,NEAR>
cBegin nogen

    push  es
    mov   ax, cs        ; the string is in 'cs', see above
    mov   es, ax
    mov   di, codeoffset szSystemRoot
    call  get_env_var_ptr

    push  dx
    mov   dx, ds
    mov   es, dx
    SetKernelDS
    mov   si, dataoffset achRealWindowsDir
    regptr esdi,es,di
    regptr dssi,ds,si
    mov   cx, WINDIR_BUFSIZE
    push  dx
    cCall GetShortPathName, <esdi, dssi, cx>
    pop   dx
    mov   cbRealWindowsDir,ax
    mov   ds, dx                         ;restore ds
    pop   dx
    assumes ds,nothing

    push  cx
    push  di

    mov   ax, cs        ; the string is in 'cs', see above
    mov   es, ax
    mov   di, codeoffset szWin16Dir
    call  get_env_var_ptr
    or    di, di                         ;does win16dir exist?
    jz    gw_not
    add   sp, 4                          ;throw away systemroot
    jmp   short gw_cont

gw_not:
    pop   di
    pop   cx

gw_cont:
    ; Now ds:di points to the Windows directory string in
    ; the environment block.  It may be a long pathname,
    ; so fix it up.
    smov  es, ds
    SetKernelDS
    mov   si, dataoffset achWindowsDir
    regptr esdi,es,di
    regptr dssi,ds,si
    mov   cx, WINDIR_BUFSIZE
    cCall GetShortPathName, <esdi, dssi, cx>
    mov   cx, ax
    smov  ds, es
    assumes ds,nothing

    pop es
    ret

cEnd nogen

cProc   get_env_var_ptr,<PUBLIC,NEAR>
cBegin nogen
    cld
    push si
    xor si,si

    push di
    mov  cx,-1
    xor  ax,ax
    repnz scasb
    not  cx
    dec  cx            ; length of szSystemRoot
    pop  di

gw_cmp:
    mov  al, [si]
    or   al, al
    jz   gw_exit

    push di
    push cx
    repz cmpsb         ; compare the inputstring with szSystemRoot
    pop  cx
    pop  di

    jnz  gw_next       ; not szSystemRoot
    xor  cx,cx         ; yes szSystemRoot, cx=0 indicates so
    mov  di,si

gw_next:
    lodsb
    or al,al
    jnz gw_next        ; skip to the terminating NULL.
    or  cx,cx          ; cx==0 implies... found szSystemRoot
    jnz gw_cmp         ; compare with the next environment string
    mov cx,si          ; here if found szSystemRoot.
    sub cx,di
    mov ax,di
    dec cx


gw_exit:
    mov di,ax
    pop si
    ret
cEnd nogen


;-----------------------------------------------------------------------;
; original get_windir is within the 'else' 'endif' block
;
;-----------------------------------------------------------------------;

else

cProc   get_windir,<PUBLIC,NEAR>
cBegin nogen
    cld
    push    si
    xor di,di
    xor si,si
gw: lodsw
    or  al,al           ; no more enviroment
    jz  gw_exit
if ROM
    if1
    %out    Take this out!
    endif
    ;;;!!!only until loader builds proper environment block
    or  ax,2020h        ; ignore case of ENV string
endif
    cmp ax,'iw'         ; Look for windir=
    jne @F
    lodsw
if ROM
    ;;;!!!only until loader builds proper environment block
    or  ax,2020h        ; ignore case of ENV string
endif
    cmp ax,'dn'
    jne @F
    lodsw
if ROM
    ;;;!!!only until loader builds proper environment block
    or  ax,2020h        ; ignore case of ENV string
endif
    cmp ax,'ri'
    jne @F
    lodsb
    cmp al,'='
    je  gw_got_it
@@: lodsb
    or  al,al
    jnz @B
    jmp gw
gw_got_it:
    mov di,si
@@: lodsb
    or  al,al
    jnz @B
    mov cx,si
    sub cx,di
    dec cx
gw_exit:
    pop si
    ret
cEnd nogen

endif


sEnd    INITCODE

;------------------------------------------------------------------------

sBegin  STACK

; Boot TDB

boottdb     equ this byte
    DB  SIZE TDB dup (0)

if 0
                      ;0123456789012345
; Boot EEMS context save area

NUMBER_OF_BANKS = 4 * (0FFFFh - (LOWEST_SWAP_AREA * 64) + 1)/400h

boottdb_EEMSsave    equ this byte
    DB  NUMBER_OF_BANKS + 100h DUP (0)
endif

; do a clumsy paragraph alignment

    rept    16
if  ($ - boottdb) and 0Fh
    db  0
endif
    endm

; Dummy arena entry so boot SS looks like a valid object

    DB  'M'
    DW  -1
    DW  (BOOTSTACKSIZE + 31)/16
    DB  0
    DW  5 DUP (0)

; Another in case we have to tweek the low order bit of SS

    DB  'M'
    DW  -1
    DW  (BOOTSTACKSIZE + 15)/16
    DB  0
    DW  5 DUP (0)

; Boot stack

stackbottom equ this word
    DB  BOOTSTACKSIZE DUP (0)
stacktop    equ this word

    DW  -1

sEnd    STACK

end BootStrap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldfastb.asm ===
TITLE	LDFASTB - FastBoot  procedure

.xlist
include kernel.inc
include newexe.inc
include pdb.inc
include tdb.inc
include eems.inc
.list

if PMODE32
	.386
endif

externA	 __ahincr

externFP GlobalReAlloc

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

sEnd	NRESCODE

DataBegin

externB Kernel_flags
externW pGlobalHeap
externW win_show
externW hLoadBlock
externW segLoadBlock
externD lpBootApp

ife ROM
externW cpShrink
externW cpShrunk
endif

DataEnd

sBegin	INITCODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyLock

if PMODE32
externNP get_arena_pointer32
else
externNP get_arena_pointer
endif
externNP get_physical_address
externNP set_physical_address
externNP get_rover_2

;-----------------------------------------------------------------------;
; Shrink								;
;									;
; This shrinks what's left of win.bin.	The part at the front of win.bin;
; that has been loaded already is expendable.  The part of win.bin	;
; that has not been loaded yet is moved down over the expended part.	;
; This does not change the segment that win.bin starts at.  The		;
; partition is then realloced down in size.				;
;									;
; Arguments:								;
;	none								;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
;									;
; Registers Destroyed:							;
;	AX,BX,CX,DX							;
;									;
; Calls:								;
;	BigMove								;
;	GlobalReAlloc							;
;	MyLock								;
;									;
; History:								;
;									;
;  Fri Feb 27, 1987 01:20:57p  -by-  David N. Weise   [davidw]		;
; Documented it and added this nifty comment block.			;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Shrink,<PUBLIC,NEAR>
cBegin	nogen

ife ROM
	CheckKernelDS
	ReSetKernelDS
	push	es
	push	si
	push	di
	mov	ax,[segLoadBlock]		; Get current address
	mov	bx, ax
if PMODE32
	mov	ds, pGlobalHeap
	UnSetKernelDS
	cCall	get_arena_pointer32,<ax>
	mov	edx, ds:[eax].pga_size
	shr	edx, 4
	SetKernelDS
else
	cCall	get_arena_pointer,<ax>
	mov	es,ax
	mov	dx,es:[ga_size]		; get size of whole block
endif
	mov	ax,bx
	mov	es,ax			; es is destination
	xor	bx,bx
	xchg	[cpShrink],bx		; Get amount to shrink by
	add	[cpShrunk],bx		; Keep track of how much we have shrunk

	sub	dx,bx			; get new size
	push	dx			; save new size
	push	ds			; save kernel ds

if PMODE32
	mov	ds, ax
	movzx	esi, bx
	shl	esi, 4			; Start of new block
	xor	edi, edi		; Where it will go
	movzx	ecx, dx
	shl	ecx, 2			; Dwords
	cld				; Move it down.
	rep movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67h			; 386 BUG, DO NOT REMOVE
	nop				; 386 BUG, DO NOT REMOVE
else

	push	dx
	xor	cx,cx
	REPT	4
	shl	bx,1
	rcl	cx,1
	ENDM
	cCall	get_physical_address,<es>
	add	ax,bx
	adc	dx,cx
	push	es
	call	get_rover_2
	smov	ds,es
	assumes	ds, nothing
	pop	es
	cCall	set_physical_address,<ds>
	pop	dx
	call	BigMove			; move it on down

endif	; PMODE32

	pop	ds
	CheckKernelDS
	ReSetKernelDS
	pop	ax			; get back size in paragraphs
	mov	cx,4
	xor	dx,dx			; convert to bytes
il3e:
	shl	ax,1
	rcl	dx,1
	loop	il3e
	cCall	GlobalReAlloc,<hLoadBlock,dxax,cx>
	cCall	MyLock,<hLoadBlock>
	mov	[segLoadBlock],ax
	pop	di
	pop	si
	pop	es

endif ;ROM

	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; BigMove								;
;									;
; Moves a large partition down in memory.				;
;									;
; Arguments:								;
;	DX = paragraph count to move					;
;	ES = destination segment					;
;	DS = source segment						;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	None								;
;									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,DI,SI,DS,ES						;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Fri Feb 27, 1987 01:08:43p  -by-  David N. Weise   [davidw]		;
; Documented it and added this nifty comment block.			;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing
ife ROM
ife PMODE32

cProc	BigMove,<PUBLIC,NEAR>
cBegin nogen
if PMODE32
	movzx	ecx, dx
	shl	ecx, 2
	xor	esi, esi
	xor	edi, edi
	cld
	rep	movsd
	ret
else
	mov	bx,dx
	mov	cl,12
	add	bx,0FFFh
	shr	bx,cl			; count +1 of 10000h byte moves
	xor	si,si			; ds:0 is source
	xor	di,di			; es:0 is dest
	cld
	jmps	BM2
BM1:
	int 3				; IF WE HIT THIS, KRNL286.EXE IS
	int 3				; TOO BIG, FIX THE FOLLOWING!!!
	sub	dx,1000h
;;;ife PMODE32
	mov	cx,8000h
	rep	movsw			; si,di are 0
;;;else
;;;	mov	cx, 4000h
;;;	rep	movsd
;;;endif
	mov	ax,ds
	add	ax,__ahincr
	mov	ds,ax
	mov	ax,es
	add	ax,__ahincr
	mov	es,ax
BM2:	dec	bx
	jnz	BM1
;;;ife PMODE32
	mov	cl,3			; convert to words
	shl	dx,cl
	mov	cx,dx
	rep	movsw			; si,di are 0
;;;else
;;;	shl	dx, 2			; dwords
;;;	mov	cx, dx
;;;	rep	movsd
;;;endif
endif
	ret
cEnd nogen

endif	; PMODE32
endif	; ROM

sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldaux.asm ===
TITLE   LDAUX - Assembler side of LD.C

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

DataBegin

externB  fChksum
externW  hExeHead
externW  curTDB
externW  PHTcount
externW  kr1dsc
szFake32BitModuleName DB 128 DUP(0)
cFake32BitModuleName DW SIZE szFake32BitModuleName

ifdef WOW
szWinGDllModule       DB 'WING', 0
szWinGDllFile         DB '\SYSTEM\WING.DLL',0
externD lpWindowsDir
externW cBytesWinDir
endif ; WOW

ifdef DBCS_KEEP
ifdef WOW
public hModNotepad
hModNotepad DW 0
NotepadName DB 'notepad.exe', 0
endif ; WOW
endif ; DBCS_KEEP
DataEnd

externFP GlobalAlloc
externFP GlobalFree
externFP GlobalHandle
externFP GetExePtr
externFP FarMyUpper
externFP FarFindOrdinal
externFP FarEntProcAddress
externFP FarMyLock

externFP FarGetOwner
externFP AllocSelector
externFP IPrestoChangoSelector
externFP FreeSelector
externFP lstrcpyn
ifdef WOW
ifdef DBCS_KEEP
externFP WowGetModuleUsage
externFP MyGetAppWOWCompatFlags
endif ; DBCS_KEEP
externFP WowGetModuleFileName
externFP HandleAbortProc
externFP WowGetModuleHandle
endif

ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

sBegin  CODE
assumes CS,CODE

externNP LoadSegment
externNP MyLock

externNP GetOwner

if LDCHKSUM
externNP GetChksumAddr
endif

;-----------------------------------------------------------------------;
; GetSegPtr                                                             ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:SI = FARPROC or DS = hModule and SI = segment#               ;
;                                                                       ;
; Returns:                                                              ;
;       BX = 0                                                          ;
;       CX = segment# or zero if input invalid                          ;
;       DS:SI -> segment table entry                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 24-Dec-1989 22:49:50  -by-  David N. Weise  [davidw]             ;
; Added check for MPI thunk.                                            ;
;                                                                       ;
;  Wed Oct 07, 1987 12:59:54p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   GetSegPtr,<PUBLIC,NEAR>
cBegin nogen

        xor     bx,bx                   ; For cheap indexed addressing
        cmp     ds:[bx].ne_magic,NEMAGIC; Is this a thunk address?
        jne     gspFixed                ; No, must be fixed procedure
        dec     si                      ; No, see if valid segment #
        cmp     si,ds:[bx].ne_cseg
        jb      @F
        jmps    gspfail                 ; No, fail
@@:     mov     cx,si                   ; Yes, load that segment
        inc     cx
        jmps    gspSegNo

; CX = segment number.  Convert to segment info pointer.

gspSegNo:
        push    cx
        dec     cx
        shl     cx,1
        mov     si,cx
        shl     cx,1
        shl     cx,1
        add     si,cx
        .errnz  10 - SIZE NEW_SEG1
        add     si,ds:[bx].ne_segtab
        pop     cx
        jmps    gspExit                 ; DS:SI -> segment info block

gspFixed:                               ; DS = code segment address

; check for MakeProcInstance thunk first because GetOwner in 386pmode
;  ain't robust enough

        cmp     byte ptr ds:[si].0,0B8h ; Maybe, is this a mov ax,XXXX inst?
        jnz     gsp_not_mpit
        cmp     byte ptr ds:[si].3,0EAh ; Followed by far jump inst?
        jnz     gsp_not_mpit
        cmp     ds:[2],MPIT_SIGNATURE   ; Is it in a mpi table?
        jz      gsp_yes_mpit
        cmp     ds:[TDB_MPI_THUNKS].2,MPIT_SIGNATURE
        jnz     gsp_not_mpit
gsp_yes_mpit:
        lds     si,ds:[si].4            ; get real procedure address
        jmp     GetSegPtr
gsp_not_mpit:

        push    ax
        mov     dx, ds                  ; Handle in dx
        StoH    dl                      ; Assume not fixed
        cCall   GetOwner,<ds>
        or      ax,ax
        mov     ds, ax
        pop     ax
        jz      gspfail

gspf1:
        cmp     ds:[bx].ne_magic,NEMAGIC; Is it a module DB?
        jnz     gspfail                 ;  Nope, fail.

getting_closer:
        mov     si,ds:[bx].ne_segtab    ; Yes, point to segment table
        mov     cx,ds:[bx].ne_cseg
gspLoop:
        cmp     dx,ds:[si].ns_handle    ; Scan stmen
        jz      gspFound
        HtoS    dx                      ; May be fixed seg???
        cmp     dx,ds:[si].ns_handle    ; Scan stmen
        jz      gspFound
        StoH    dx
        add     si,SIZE NEW_SEG1
        loop    gspLoop
gspfail:
        xor     cx,cx
        jmps    gspExit
gspFound:
        sub     cx,ds:[bx].ne_cseg      ; Compute segment# from remainder
        neg     cx                      ; of loop count
        inc     cx                      ; 1-based segment#
gspExit:
        ret

cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   IGetCodeInfo,<PUBLIC,FAR>,<si,di>
        parmD   lpProc
        parmD   lpSegInfo
cBegin
        lds     si,lpProc
        call    getsegptr
        mov     ax,cx
        jcxz    gciExit
        les     di,lpSegInfo
        mov     cx,SIZE NEW_SEG1
        cld
        rep     movsb
        mov     ax,ds:[bx].ne_align     ; Return segment aligment
        stosw
        sub     si,SIZE NEW_SEG1
        sub     di,SIZE NEW_SEG1+2
        cmp     si,ds:[bx].ne_pautodata
        jne     gciExit
        mov     ax,ds:[bx].ne_stack
        add     ax,ds:[bx].ne_heap
        add     es:[di].ns_minalloc,ax
gciExit:
        smov    es,ds ; put module handle (returned from getsegptr) into es
                      ; user depends on this
        mov     cx,ax   ; WHY IS THIS HERE?
;
; NOTE: USER assumes that AX == BOOL fSuccess and ES == hModule upon return
;
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   GetCodeHandle,<PUBLIC,FAR>,<si,di>
        parmD   lpProc
cBegin
        lds     si,lpProc
        call    getsegptr
        mov     dx,cx
        jcxz    gchExit
        mov     ax,ds:[si].ns_handle
;        test    ds:[si].ns_flags,NSLOADED
;        jnz     gchExit
        mov     dx,-1
        cCall   LoadSegment,<ds,cx,dx,dx>
        cCall   MyLock,<ax>
        xchg    ax,dx
        cmp     ax,dx
        je      gchExit
; %OUT Need pmode lru stuff here
gchExit:
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   CallProcInstance,<PUBLIC,FAR>
cBegin  nogen
        mov     ax,ds                   ; AX = caller's DS
        mov     cx,es:[bx]              ; CX = hInstance
        jcxz    cpx                     ; If zero, then use caller's DS
        xchg    ax,cx                   ; AX = hInstance,  CX = caller's DS
        test    al,GA_FIXED             ; Fixed?
        jnz     cpx                     ; Yes, all set
        xchg    bx,ax                   ; No, BX = hInstance, ES:AX ->
labelFP <PUBLIC,CallMoveableInstanceProc>   ; procedure address.
        HtoS    bx                      ; Get selector
        xchg    bx,ax                   ; AX = segment address
        mov     ds,cx                   ; Restore DS
cpx:    jmp     dword ptr es:[bx][2]    ; Jump to far procedure
cEnd    nogen


sEnd    CODE


sBegin  NRESCODE
assumes CS,NRESCODE

externNP MapDStoDATA
externNP FindExeInfo
externNP FindExeFile
externNP NResGetPureName

        assumes ds,nothing
        assumes es,nothing

cProc   CopyName,<PUBLIC,NEAR>,<si>
        parmD   pname
        parmW   pdst
        parmW   fUpper
cBegin
        les     si,pname
        mov     bx,pdst
        mov     cx,127
        mov     dx,fUpper
cn0:
        lods    byte ptr es:[si]
        or      al,al
        jz      cn1
        or      dx,dx
        jz      cn0a
ifdef FE_SB
        call    FarMyIsDBCSLeadByte     ; test if a char is lead byte of DBC
        jc      @F                      ; jump if not a DBC
        inc     bx
        mov     ss:[bx],al              ; store first byte of DBC
        dec     cx
        jcxz    cn1                     ; pay attention for counter exhaust...
        lods    byte ptr es:[si]        ; fetch a 2nd byte of DBC
        jmps    cn0a
@@:
endif
        call    FarMyUpper
cn0a:
        inc     bx
        mov     ss:[bx],al
        loop    cn0
cn1:
        mov     byte ptr ss:[bx+1],0
        mov     ax,bx
        mov     bx,pdst
        sub     ax,bx
        mov     ss:[bx],al
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetProcAddress,<PUBLIC,FAR>,<ds,si>
        parmW   hinstance
        parmD   pname
        localV  namebuf,130
cBegin
        mov     cx,hinstance
        jcxz    use_current_module
        cCall   GetExePtr,<cx>
        xor     dx,dx
        jcxz    gpdone1
        mov     si,ax
        mov     es,ax
        test    es:[ne_flags],NENOTP
        jnz     have_module_address
        xor     bx,bx
if KDEBUG
        fkerror 00FFh,<Can not GetProcAddress a task.>,es,bx
endif
        xor     ax,ax
        xor     dx,dx
gpdone1:
        jmps    gpdone
use_current_module:
        cCall   MapDStoDATA
        ReSetKernelDS
        mov     es,curTDB
        UnSetKernelDS
        mov     si,es:[TDB_pModule]
have_module_address:
        cmp     seg_pname,0
        jne     gp0
        mov     ax,off_pname
        jmps    gpaddr
gp0:
        lea     bx,namebuf
        xor     dx,dx
        cCall   CopyName,<pname,bx,dx>
        lea     bx,namebuf
        mov     dx,-1
        cCall   FarFindOrdinal,<si,ssbx,dx>

        cwd                             ; set DX to 0 if no ordinal
        or      ax,ax
        jz      gpdone                  ; if no ordinal, leave with 0:0

gpaddr:
        cCall   FarEntProcAddress,<si,ax>
gpdone:
        mov     cx,ax
        or      cx,dx
cEnd


;-----------------------------------------------------------------------;
; GetModuleHandle
;
; Returns the module handle, AKA segment address, of the named
; module.  The pname should be a pointer to a name, however
; because we want FreeFontResource to take a file name we check
; for that one special case for file names.
;
; Entry:
;       parmW   pname
;            or 0:instance handle
; Returns:
;       AX = handle if loaded
;          = 0 if not loaded
;
; Registers Destroyed:
;       BX,CX,DX,ES
;
; History:
;  Sat 18-Nov-1989 21:57:24  -by-  David N. Weise  [davidw]
; Adding the handling of exeheaders above the line by calling
; off to EMS_GetModuleHandle.  A little while ago is when
; the checking for filenames was added.
;
;  Tue 04-Apr-1989 01:42:12  -by-  David N. Weise  [davidw]
; This used to return DX = ExeHead, this is now returned in CX.
;
;  Tue 28-Mar-1989 17:28:34  -by-  David N. Weise  [davidw]
; Put in the Excel hack and added this nifty comment block.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleHandle,<PUBLIC,FAR>,<di,si>
        parmD   pname
        localV  nameBuf,130
cBegin
        cCall   MapDStoDATA
        ReSetKernelDS
        cmp     pname.sel,0
ifndef DBCS_KEEP
        jz      gm1
else ; DBCS_KEEP
ifdef WOW
        jnz      gm_chk
        jmp     gm1

 for Lotus Freelance Instration program
gm_chk:
        call    MyGetAppWOWCompatFlags
        test    ax, 4                       ; WOWCF_AUDITNOTEPAD
        jz      gm_ne

        lea     si,NotepadName
        les     di,pname
        mov     cx,11
        cmpsb
        jnz     gm_ne

        mov     ax,hModNotepad
        or      ax,ax
        jz      gm_ne

        cmp     ax,1
        jnz     gm_pe

        mov     bx,10
        xor     cx,cx
        cCall   GlobalAlloc,<cx,cx,bx>
        or      ax,ax
        jz      gm_hdl
        mov     hModNotepad,ax
gm_pe:
        jmp     short gmexit
gm_ne:
endif ; WOW
endif ; DBCS_KEEP

        lea     di,namebuf
        xor     dx,dx                   ; Try as is first
        cCall   CopyName,<pname,di,dx>
        inc     di                      ; point past count
        push    ax
        cCall   FindExeInfo,<ss,di,ax>
        pop     bx
        or      ax,ax
        jnz     gmexit

        lea     di,namebuf
        mov     dx,-1                   ; Now force upper case
        cCall   CopyName,<pname,di,dx>
        inc     di                      ; point past count
        push    ax
        cCall   FindExeInfo,<ss,di,ax>
        pop     bx
        or      ax,ax
        jnz     gmexit

        smov    es,ss
        call    NResGetPureName
        cCall   FindExeFile,<ss,di>
        jmps    gmexit

gm1:    cCall   GetExePtr,<OFF_pname>
gmexit:

ifdef WOW
;
; If we didn't find a matching module, call WOW32 to see if
; the module name matches the module name of a child app
; spawned via WinOldAp.  If it does, WOW32 will return
; that WinOldAp's hmodule.  If not, WOW32 will return zero.
;
        or      ax,ax
        jnz     @F
        lea     di,namebuf[1]
        cCall   WowGetModuleHandle, <ss,di>
@@:
endif

        mov     dx,hExeHead             ; return this as a freebie
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleName,<PUBLIC,FAR>,<si,di>
	parmW	hinstance
	parmD	lpname
	parmW	nbytes
cBegin
	mov	ax, nbytes
	or	ax, ax
        jnz     @f
        jmp     gfx
@@:     cCall   GetExePtr,<hinstance>
	or	ax,ax
	jz	gmn
	mov	ds,ax
	mov	si,ds:[ne_restab]	; Module name is first entry in Res Name Table
        xor     cx,cx
        mov     cl,ds:[si]		; Get Len of module name
        inc     cl                      ; Space for NULL
        inc     si			; Goto start of module name
        cmp     cx,nbytes
        jl      gmn1
        mov     cx,nbytes

gmn1:
        push    lpname
        push    ds
        push    si
        push    cx
        call    lstrcpyn

        mov     ax,0DDh			; Return a true value
gmn:
cEnd

;-----------------------------------------------------------------------
; IsWingModule                                                          
;    Checks if GetModuleFileHandle is called by Wing.dll                
;    on itself.
;    and fills lpname if it is so
;
; Arguments:
;     hinstance - GetModuleFileName's hinstance arg        
;     lpname    - GetModuleFileName's lpname arg
;     nbytes    - GetModuleFileName's lpname arg
;     exehdr    - ExeHdr of hinstance
;     rcsel     - Return Code Selector that called GMFH
; Returns:
;     AX = number of bytes copied if wing is calling GetModuleFileName on itself      
;     AX = 0 otherwise
;     
;------------------------------------------------------------------------

cProc   IsWingModule,<PUBLIC,FAR>,<si,di,ds,es>
        parmW hinstance
        parmD lpname
        parmW nbytes
        parmW exehdr
        parmW rcsel
cBegin  
        mov     es,exehdr
        mov     di,es:[ne_restab]
        inc     di                     ;got modulename 
cCall   MapDStoDATA
assumes DS, DATA
        lea     si, szWinGDllModule
        mov     cx,5
        repe    cmpsb
        jnz     short IWM_NoMatch
        cCall getexeptr,<rcsel>
        cmp     ax,exehdr
        jnz     short IWM_NoMatch
        mov     cx, cBytesWinDir
        add     cx, 17                 ;17=strlen("\system\wing.dll")+1;
        cmp     cx,nbytes
        ja      short IWM_NoMatch      ;return righ away if doesn't fit
        mov     ax,cx                  
        sub     cx,17
        les     di,lpname
        lds     si,lpWindowsDir
        cld
        rep     movsb
        mov     cx,17
        lea     si,szWinGDllFile
        rep     movsb
        jmp     short IWM_End
IWM_NoMatch:      
        mov     ax,0
IWM_End:  
cEnd


;
;NOTE: BX preserved because Actor 4.0 depends on this (bug 9078 - neilk)
;
cProc   IGetModuleFileName,<PUBLIC,FAR>,<si,di,bx>
        parmW   hinstance
        parmD   lpname
        parmW   nbytes
cBegin
ifdef WOW
        ; take care of 32bit hInstance. 32bit hInstance has GDT/LDT bit clear
        ; the validation layer will pass such handles as valid so that we can
        ; thunk to 32bit GetModuleFileName if needed.
        ;
        ; in win32 hInstances are not global. therefore fake success by
        ; returning a valid module name for compatibility sake. Naturally,
        ; we will use our module name.

        mov     ax, hInstance
        test    al, 0100b       ; Check for task aliases (see WOLE2.C) or BOGUSGDT
        jnz     GMFName_Normal
        or      ax, ax
        jz      GMFName_Normal
        cCall   MapDStoDATA
assumes DS, DATA
        mov     cx, cFake32BitModuleName
        lea     si, szFake32BitModuleName
        cCall   WowGetModuleFileName, <ax, ds, si, cx>
        mov     cx,ax
        jmps    GMF_CopyName32

GMFName_Normal:
endif
        mov     ax, nbytes
        or      ax, ax
        jz      gfx
        cCall   GetExePtr,<hinstance>
        or      ax,ax
        jz      gfx
        mov     ds,ax
        cCall   IsWinGModule,<hinstance,lpname,nbytes,ax,[bp+4]>
        or     ax, ax
        jnz     gfx
        mov     si,ds:[ne_pfileinfo]
        xor     cx,cx
        mov     cl,ds:[si].opLen
        sub     cx,opFile
        lea     si,[si].opFile
ifdef WOW
GMF_CopyName32:
endif
        les     di,lpname
        cmp     cx,nbytes
        jl      gf1
        mov     cx,nbytes
        dec     cx
gf1:
        cld
        mov     ax,cx
        rep     movsb
        mov     es:[di],cl
gfx:
        mov     cx,ax

        ;** Nasty hack to support QuickWin libs (Fortran, QCWin)
        ;**     The startup code assumes DX will be the segment of the
        ;**     lpname parameter
        mov     dx,WORD PTR lpname[2]
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleUsage,<PUBLIC,FAR>
        parmW   hinstance
cBegin
ifdef DBCS_KEEP
ifdef WOW
        cCall   MapDStoDATA
        ReSetKernelDS

        call    MyGetAppWOWCompatFlags
        test    ax, 4                       ; WOWCF_AUDITNOTEPAD
        jz      gu_ne

        mov     ax,hModNotepad
        or      ax,ax
        jz      gu_ne

        cmp     ax,hinstance
        jnz     gu_ne

        push    ax
        cCall   WowGetModuleUsage, <0>
        or      ax,ax
        pop     bx
        jnz     gux

        cCall   GlobalFree,<bx>
        jmp     short gux
gu_ne:
endif ; WOW
endif ; DBCS_KEEP
        cCall   GetExePtr,<hinstance>
        or      ax,ax
        jz      gux
got_one:
        mov     es,ax
        mov     ax,es:[ne_usage]
gux:    mov     cx,ax
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetInstanceData,<PUBLIC,FAR>,<si,di>
        parmW   hinstance
        parmW   psrcdst
        parmW   nbytes
cBegin
        push    ds
        cCall   GlobalHandle,<hinstance>
        pop     es              ; Get caller's DS as destination
        or      dx,dx
        jz      gidone
        mov     ds,dx           ; Source is passed instance
        mov     si,psrcdst      ; Offsets are the same
        mov     di,si
        mov     ax,nbytes
        mov     cx,ax
        jcxz    gidone
        cld
        rep     movsb
        push    es
        pop     ds
gidone: mov     cx,ax
cEnd

sEnd    NRESCODE


sBegin MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
; MakeProcInstance                                                      ;
;                                                                       ;
; Cons together a far procedure address with a data segment address,    ;
; in the form                                                           ;
;                                                                       ;
;       mov     ax,DGROUP                                               ;
;       jmp     far pproc                                               ;
;                                                                       ;
; This procedure allocates a fixed segment for a set of thunks and      ;
; threads the thunks together on a free list within the segment.        ;
; When a thunk segment is full, a new one is allocated and pushed       ;
; onto the head of the list of thunk segments pointed to by             ;
; TDB_MPI_Thunks.                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pproc                                                   ;
;       parmW   hinstance                                               ;
;                                                                       ;
; Returns:                                                              ;
;       DX:AX = ProcInstance                                            ;
;       CX   != 0                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       DX:AX = NULL                                                    ;
;       CX    = 0                                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,ES                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       MapDStoDATA                                                     ;
;       GlobalAlloc                                                     ;
;       FarMyLock                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 26, 1987 12:53:58p  -by-  David N. Weise   [davidw]          ;
; ReWrote it a while ago to work with EMS.                              ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IMakeProcInstance,<PUBLIC,FAR>,<si,di>
        parmD   pproc
        parmW   hinstance
cBegin
        SetKernelDSMisc

; We try to prohibit tasks from calling into each other.
;  One way to do this is to not allow one app to MPI for
;  another.

        mov     bx,[bp-2]               ; Warning - assume DS pushed here!
        mov     ax,hinstance            ; if hInstance == NULL,
        or      ax,ax                   ; use caller's DS
        jz      mpi1
        push    bx
        cCall   GlobalHandle,<ax>
        pop     bx
        cmp     dx,bx
        jz      mpi1
        xor     cx,cx
        krDebugOut      DEB_ERROR, "%dx2 MakeProcInstance only for current instance. "
mpi1:   mov     hinstance,bx

; If this is a library DS then it makes absolutely no sense to make a
;  ProcInstance because library prologs setup DS already!  In addition
;  it is assumed in TestDSAX that only task DS's are in ProcInstances.

        cCall   FarGetOwner,<bx>
        mov     es, ax
        NE_check_ES
        mov     dx,pproc.sel
        mov     ax,pproc.off
        test    es:[ne_flags],NENOTP
        jz      @F
        jmp     mpexit                  ; It's a library - return its address
@@:

; now try to get a thunklet

        mov     ax,curTDB
        mov     si,TDB_MPI_Thunks
        mov     es,ax
        mov     ax,es:[TDB_MPI_Sel]
mp2:    mov     es,ax
        mov     bx,es:[si].THUNKSIZE-2
        or      bx,bx
        jz      @F
        jmp     got_a_thunk
@@:     mov     ax,es:[si]              ; Is there another block linked in?
        xor     si,si
        or      ax,ax
        jnz     mp2                     ; Yes, look at it.

; No thunks available, make a block.

        mov     bx,THUNKSIZE * THUNKELEM
        mov     cx,GA_ZEROINIT
        cCall   GlobalAlloc,<cx,ax,bx>
        or      ax,ax
;       jnz     mpx
;       cwd
        jz      mpfail
;mpx:
        mov     bx,ax
        mov     es,curTDB
        xchg    es:[TDB_MPI_Thunks],bx  ; Link the new block in.
        mov     es,ax

; Initialize the new block.

        mov     es:[0],bx
        mov     es:[2],MPIT_SIGNATURE
        mov     bx,THUNKSIZE-2
        mov     cx,THUNKELEM-1
mp1:    lea     dx,[bx+THUNKSIZE]
        .errnz  THUNKELEM and 0FF00h
        mov     es:[bx],dx
        mov     bx,dx
        loop    mp1
        mov     es:[bx],cx
        push    es                      ; make the block into a code segment
        cCall   AllocSelector,<es>
        pop     es
        or      ax, ax
        jnz     @F
                                        ; AllocSelector Failed! Back out.
        mov     bx, es:[0]              ; this is the old thunk val
        mov     ax, es                  ; this is the segment just allocated
        mov     es, curTDB
        mov     es:[TDB_MPI_Thunks], bx ; restore old value
        cCall   GlobalFree,<ax>
mpfail:
        krDebugOut DEB_IERROR, "MakeProcInstance failed.  Did you check return values?"
        xor     ax, ax
        cwd
        jmps    mpexit

@@:     mov     di,ax
        push    es
        cCall   IPrestoChangoSelector,<di,es>
        cCall   FreeSelector,<di>
        pop     ax
        xor     bx,bx
        jmp     mp2

got_a_thunk:

        push    es

; we need a data alias so we can write into this thing

        push    bx
        mov     bx, kr1dsc
        or      bl, SEG_RING
        cCall   IPrestoChangoSelector,<es,bx>
        mov     es,ax
        pop     bx
        mov     ax,es:[bx]
        mov     es:[si].THUNKSIZE-2,ax
        lea     di,[bx-THUNKSIZE+2]

        cld
        mov     dx,di                   ; save offset of thunk
        mov     al,0B8h                 ; mov ax,#
        stosb
        mov     ax,hInstance
        stosw
        mov     al,0EAh                 ; jmp far seg:off
        stosb
        mov     ax,pproc.off
        stosw
        mov     ax,pproc.sel
        stosw
        mov     ax,dx                   ; recover offset of thunk
        pop     dx                      ; recover sel of thunk
mpexit:
        mov     cx,ax
        or      cx,dx
cEnd


;-----------------------------------------------------------------------;
; FreeProcInstance                                                      ;
;                                                                       ;
; Frees the given ProcInstance.                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pproc                                                   ;
;                                                                       ;
; Returns:                                                              ;
;       AX != 0 Success                                                 ;
;       CX != 0 Success                                                 ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX == 0 ProcInstance not found.                                 ;
;       CX == 0 ProcInstance not found.                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DX,DI,SI,DS                                                     ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 26, 1987 12:25:42p  -by-  David N. Weise   [davidw]          ;
; ReWrote it a while ago to work with EMS.                              ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IFreeProcInstance,<PUBLIC,FAR>,<di>
        parmD   pproc
cBegin

        cCall   MISCMapDStoDATA
        ReSetKernelDS
        mov     ax,curTDB
        mov     es,ax
        mov     ax,es:[TDB_MPI_Sel]
        mov     bx,TDB_MPI_Thunks       ; Point to start of first table.

fp0:    or      ax,ax                   ; Loop through linked tables.
        jz      fpdone
        mov     es,ax                   ; Point to table.
        cmp     ax,pproc.sel            ; This the right ProcInstance table?
        jz      fp1
        mov     ax,es:[bx]              ; No, get next table.
        xor     bx,bx
        jmp     fp0
fp1:

        push    bx
        mov     ax, kr1dsc
        or      al, SEG_RING
        cCall   IPrestoChangoSelector,<es,ax>
        mov     es,ax
        pop     bx
        mov     di,pproc.off            ; Pick off the specific Proc.
        xor     ax,ax
        cld
        stosw                           ; Clear it out!
        stosw
        stosw
        mov     ax,di
        xchg    es:[bx].THUNKSIZE-2,ax  ; Update free list.
        stosw
        mov     ax,-1                   ; Return success.

        cCall   HandleAbortProc, <pproc>
fpdone:
        mov     cx,ax
        UnSetKernelDS

cEnd


        assumes ds, nothing
        assumes es, nothing

cProc   DefineHandleTable,<PUBLIC,FAR>,<di>
        parmW   tblOffset
cBegin
        cCall   FarMyLock,<ds>
        or      ax,ax
        jz      dhtx
        mov     di,tblOffset
        call    MISCMapDStoDATA
        ReSetKernelDS
        push    ds
        mov     ds,curTDB
        UnSetKernelDS
        or      di,di                   ; resetting PHT?
        jnz     @F
        mov     dx,di
@@:     mov     word ptr ds:[TDB_PHT][2],dx
        mov     word ptr ds:[TDB_PHT][0],di
        pop     ds
        ReSetKernelDS
        or      di,di                   ; Is the app removing the PHT?
        jnz     @F                      ;  setting new
        dec     PHTcount                ;  resetting
        jmps    dhtx

@@:     inc     PHTcount                ; bump the count of tasks with PHT's
        assumes ds, nothing
        mov     es,ax
        mov     cx,es:[di]              ; Get word count
        add     di,2                    ; Point to first word

        xor     ax,ax
        inc     cx                      ; new handle table format (skip cwClear)
        cld
        rep     stosw                   ; Zero words in private handle table
        inc     ax
dhtx:
cEnd

sEnd MISCCODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lddebug.asm ===
TITLE	LDDEBUG - Debugger interface procedures

include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
include wow.inc
include dbgsvc.inc
include bop.inc
ifdef WOW
include vint.inc
endif

;.386p

HEAPDUMP	=	0

DEBUGOFFSET	equ	000FBH
INTOFFSET	equ	4*3+2

DEBUGCALL MACRO
	call	MyDebugCall
	ENDM

DataBegin

externW	 winVer
externW  wDefRip
externB  Kernel_Flags
externB  Kernel_InDOS
externB  fDW_Int21h
externW	 pGlobalHeap
externW  hGlobalHeap
externD  ptrace_dll_entry
externD  lpfnToolHelpProc
externD  pKeyboardSysReq
externW  curTDB
externW  wExitingTDB
externW	<Win_PDB, topPDB>

ifdef WOW
externD  FastBop
externW  DebugWOW
externW  hExeHead
if PMODE32
externW  gdtdsc
endif; PMODE32
endif; WOW

debugseg	dw	0

IF KDEBUG
externB fKTraceOut
ENDIF

DataEnd

ifdef WOW
externFP GetModuleFileName
externFP GetModuleHandle
externFP WOWOutputDebugString
externFP WOWNotifyTHHOOK
endif
ifdef FE_SB
; _TEXT code segment is over flow with debug 386 version
; GetOwnerName moves to _MISCTEXT from _TEXT segment with DBCS flag
externFP FarGetOwner
endif ; FE_SB

sBegin	CODE
assumes CS,CODE

if pmode32
externNP get_arena_pointer32
else
externNP get_arena_pointer
endif


externNP GetOwner
externNP genter
externNP get_physical_address
externNP ValidatePointer

sEnd 	CODE


sBegin	INITCODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
			

;-----------------------------------------------------------------------;
; debuginit								;
;									;
; Returns a non zero value in AX if debugger is resident.		;
; If the debugger is present a distinquished string of "SEGDEBUG",0	;
; will be found at 100H off of the interrupt vector segment (int 3).	;
;									;
; Arguments:								;
;	None.								;
;									;
; Returns:								;
;	AX =! 0 if debugger resident.					;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:03:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugInit,<PUBLIC,NEAR>,<es,si,di>
cBegin

	CheckKernelDS
	ReSetKernelDS

	DebInt	4fh

	cmp	ax, 0F386h
	jne	short no_debugger
	inc	debugseg
	or	Kernel_flags[2],KF2_SYMDEB
no_debugger:

cEnd


;-----------------------------------------------------------------------;
; DebugDebug
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 21-Jun-1988 13:10:41  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugDebug,<PUBLIC,NEAR>

cBegin nogen

	push	ds
	SetKernelDS

ifdef WOW
        call    WOWNotifyTHHOOK

; Tell the debugger where it can poke around for kernel data structure info

        mov     cx, hGlobalHeap
        mov     dx, hExeHead
        push    DBG_WOWINIT
        FBOP    BOP_DEBUGGER,,FastBop
        add     sp,+2
else

	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	jz	short dd_done

; Tell the debugger where it can poke around for kernel data structure info

	push	ax
	push	bx
	push	cx
	push	dx
	mov	bx,winVer
	mov	cx,dataOffset hGlobalHeap
	mov	dx,ds
	DebInt	5ah
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	UnSetKernelDS
dd_done:
endif
	pop	ds
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; DebugSysReq
;
; tell the keyboard driver to pass sys req through
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 19-Sep-1989 21:42:02  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugSysReq,<PUBLIC,NEAR>
cBegin nogen

	CheckKernelDS
	ReSetKernelDS
	mov	ax,debugseg
	or	ax,ax
	jz	short dwr_ret
	cmp	pKeyboardSysReq.sel,0	; is there a keyboard driver?
	jz	short dwr_ret
	mov	ax,1			; use int 2
	cCall	pKeyboardSysReq,<ax>
dwr_ret:
	ret

cEnd nogen


sEnd	INITCODE


ifdef FE_SB
sBegin	MISCCODE
assumes CS,MISCCODE
else ; !FE_SB
sBegin	CODE
assumes CS,CODE
endif ; !FE_SB
assumes DS,NOTHING
assumes ES,NOTHING


; Copyright (c) Microsoft Coropration 1989-1990. All Rights Reserved.

;
; Stolen from DOSX\DXBUG.ASM
;


; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

Debug_Serv_Int	equ	41h		;WDEB386 service codes
DS_Out_Char	equ	0
DS_Out_Symbol	equ	0fh


; Find owner of 'sel', copy name to buffer, zero terminate name
; return count of chars copied, or 0.

cProc	GetOwnerName,<PUBLIC,FAR>,<ds, si, di>
	parmW	obj
	parmD	buf
	parmW	buflen
cBegin
	push	[obj]
ifdef FE_SB
	call	FarGetOwner
else ; !FE_SB
	call	GetOwner
endif ; !FE_SB
	or	ax, ax
	jz	gon_exit

	mov	ds, ax			; DS:SI points to name
	xor	ax, ax
	cmp	word ptr ds:[0], NEMAGIC
	jnz	gon_exit
	mov	si, ds:[ne_restab]
	lodsb				; get length
	cmp	ax, [buflen]		; name must be smaller than buf
	jb	@F
	mov	ax, [buflen]
	dec	ax
@@:	mov	cx, ax
	cld
	les	di, [buf]
	rep	movsb
	mov	byte ptr es:[di], 0
gon_exit:
cEnd

ifdef FE_SB
sEnd MISCCODE

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
endif ; FE_SB

;******************************************************************************
;
;   KOutputDebugStr
;
;   Basically stolen from Windows/386 code by Ralph Lipe -- hacked up for
;   286 instead of 386.  Here in RalphL's own words is the description:
;
;   DESCRIPTION:
;	The following code is not pretty but it does what it needs to.	It will
;	only be included in DEBUG versions of Kernel.  It accepts an ASCIIZ
;	string which it will output to the COM1 serial port.  If the string
;	contains #(Register) (for example #AX) then the value of that register
;	will be output.  It will not work for segment registers.
;
;	If the string contains ?(Register)[:(Register)] (for example ?AX or
;	?AX:BX) then the value of the register(s) is passed to the debugger
;	to display the label nearest to the given address.  (It, also, will
;	not work with segment registers.  If ?AX is given, then the segment is
;	assumed to be the DS data segment.
;
;	Lower case register forces skip leading zeros.
;
;   ENTRY:
;	DS:SI -> ASCIIZ string
;
;   EXIT:
;	All registers and flags trashed
;
;   ASSUMES:
;	This procedure was called by the Trace_Out macro.  It assumes that
;	the stack is a pusha followed by a FAR call to this procedure.
;
;------------------------------------------------------------------------------


Reg_Offset_Table LABEL WORD			; Order of PUSHA
	dw	"DI"
	dw	"SI"
	dw	"BP"
	dw	"SP"
	dw	"BX"
	dw	"DX"
	dw	"CX"
	dw	"AX"
	dw	"SS"
	dw	"ES"
	dw	"DS"
	dw	"CS"

OSC1_ModName:
	pop	ax
OSC1_ModName1:
	push	es
	mov	es, ax
	cmp	word ptr es:[0], NEMAGIC
	jz	@F
	pop	es
	jmps	is_pdb
@@:	mov	cx, es:[ne_restab]
	inc	cx			; skip length byte
	pop	es
	jmp	Show_String		; AX:CX -> string to print

OSC1_FileName:
	pop	ax
	push	es
	mov	es, ax
	mov	cx, word ptr es:[ne_crc+2]
	add	cx, 8
	pop	es
	jmp	Show_String

szUnk	db	'Unknown',0

OSC1_OwnerName:
	pop	ax
	push	ds
	push	ax
	cCall	GetOwner		; seg value already on stack
	pop	ds
	or	ax, ax
	jnz	OSC1_ModName1
is_pdb:	mov	ax, cs
	mov	cx, CodeOffset szUnk
	jmp	Show_String

OSC1_Custom:
	call	Get_Register
	jnc	short OSC1_not_special
	or	ax, ax
	jz	short OSC1_not_special
	push	ax
	lodsb
	cmp	al, '0'
	jz	short OSC1_ModName
	cmp	al, '1'
	jz	short OSC1_FileName
	cmp	al, '2'
	jz	short OSC1_OwnerName
	pop	ax
	jmps	OSC1_not_special



	public	KOutDebugStr

KOutDebugStr	proc	far
	push	bp
	mov	bp, sp			    ; Assumes BP+6 = Pusha
	sub	sp, 84			; local 80 char line + count
odslen	equ	word ptr [bp-2]
odsbuf	equ	byte ptr [bp-82]
odszero	equ	word ptr [bp-84]	; flag - true if skip leading zero
odsflag	equ	word ptr [bp-86]	; last local var - from pushf
	mov	odslen, 0
	pushf
	push	es

	push	cs			    ; Address our own data seg
	pop	es
	assumes	ds,NOTHING
	assumes	es,code

	cld
        FCLI

OSC1_Loop:
	lodsb				    ; Get the next character
	test	al, al			    ; Q: End of string?
	jz	short OSC1_Done 	    ;	 Y: Return
	push	codeoffset OSC1_Loop
	cmp	al, "#" 		    ;	 N: Q: Special register out?
	je	SHORT OSC1_Hex		    ;	       Y: Find out which one
	cmp	al, "?" 		    ;	    Q: special label out?
	je	short OSC1_Label	    ;	       Y: find out which one
	cmp	al, "@" 		    ;	    Q: special string out?
	je	short OSC1_Str
	cmp	al, "%"			; Custom value?
	je	short OSC1_Custom
OSC1_out:
	xor	ah, ah			    ;	       N: Send char to COM
	jmp	Out_Debug_Chr

OSC1_Hex:
	call	Get_Register
	jnc	short OSC1_not_special

	or	bh, bh 			    ; Q: Word output?
	jz	SHORT OSC1_Out_Byte	    ;	 N: display byte
OSC1_Out_Word:
	jmp	Out_Hex_4_test		; Display AX in hex

OSC1_Out_Byte:
	xchg	al, ah			    ; swap bytes to print just
        jmp     Out_Hex_2_test              ; the low one!

OSC1_Label:
	call	Get_Register
	jc	short show_label
OSC1_not_special:
	lodsb				    ; Get special char again
	jmp	OSC1_out		    ; display it, and continue

show_label:
	mov	cx, ax			    ; save first value
	cmp	byte ptr [si], ':'	    ;Q: selector separator?
	jne	short flat_offset	    ;  N:
	lodsb				    ;  Y: eat the ':'
	call	Get_Register		    ;	and attempt to get the selector
	jc	short sel_offset
flat_offset:
	mov	ax, cs			    ; default selector value
sel_offset:
	jmp	Show_Near_Label

OSC1_Str:
	call	Get_Register
	jnc	short OSC1_not_special
	mov	cx,ax
	cmp	byte ptr [si],':'
	jne	short no_selector
	lodsb
	push	cx
	call	Get_Register
	pop	cx
	xchg	ax,cx
	jc	short got_sel_off
	mov	cx,ax
no_selector:
	mov	ax,ds			    ; default selector for strings
got_sel_off:
	jmp	Show_String

OSC1_Done:				    ; The end
	xor	ax, ax			; flush buffer
	call	Out_Debug_Chr
	pop	es
if pmode32
	test	odsflag, 200h
	jz	short @F
        FSTI
@@:
endif
	popf
	leave
	ret

KOutDebugStr	endp


;******************************************************************************
;
;   Get_Register
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:	    Carry set if register value found
;			AX = register value
;			BL = value size   (1, 2, 4) (no longer true - donc)
;
;   USES:
;
;==============================================================================


Get_Register	proc	near
	lodsw				; get next pair of letters
	mov	bx, ax
	and	bx, 2020h
	mov	[odszero], bx
	and	ax, 0dfdfh		; to upper case
	xchg	ah, al			; normal order (or change table?)
	or	bx, -1			; BH = -1
	cmp	al, 'L' 		; Q: "L" (ie AL, BL, etc)?
	jne short @F			;	 N: word reg
	mov	al, 'X' 		;	 Y: change to X for pos match
	inc	bh			; BH now 0 - will clear AH below
@@:
	xor	di, di			    ; DI = 0
	mov	cx, 12			    ; Size of a pusha + 4 seg regs

OSC1_Special_Loop:
	cmp	ax, Reg_Offset_Table[di]    ; Q: Is this the register?
	je	SHORT OSC1_Out_Reg	    ;	 Y: Output it
	add	di, 2			    ;	 N: Try the next one
	loop	OSC1_Special_Loop	    ;	    until CX = 0
	sub	si, 3			; restore pointer, clear carry
	ret

OSC1_Out_Reg:
	mov	ax, SS:[bp.6][di]	    ; AX = Value to output
	and	ah, bh			; if xL, zero out high byte
	stc
	ret

Get_Register	endp


;******************************************************************************
;
;   Out_Hex_Word
;
;   Outputs the value in AX to the COM port in hexadecimal.
;
;------------------------------------------------------------------------------

Out_Hex_2_test:				; Write two chars
	xor	ah, ah
	cmp	[odszero], 0		; skip leading 0's?
	je	Out_Hex_2		; no, show 2 chars
					; yes, fall through
Out_Hex_4_test:
	cmp	[odszero], 0
	je	Out_Hex_4
	test	ax, 0fff0h
	jz	Out_Hex_1
	test	ah, 0f0h
	jnz	Out_Hex_4
	test	ah, 0fh
	jz	Out_Hex_2
Out_Hex_3:
	xchg	al, ah
	call	Out_Hex_1
	xchg	al, ah
	jmps	Out_Hex_2

Out_Hex_4:
	xchg	al, ah
	call	Out_Hex_2
	xchg	al, ah
Out_Hex_2:
	push	ax
	shr	ax, 4
	call	Out_Hex_1
	pop	ax
Out_Hex_1:
	push	ax
	and	al, 0fh
	cmp	al, 10
	jb	@F
	add	al, '@'-'9'
@@:	add	al, '0'
	call	Out_Debug_Chr
	pop	ax
	ret

;******************************************************************************
;
;   Out_Debug_Chr
;
;   DESCRIPTION:
;
;   ENTRY:
;	AL contains character to output
;
;   EXIT:
;
;   USES:
;	Nothing
;
;==============================================================================

Out_Debug_Chr	proc	near

	push	di
	mov	di, odslen
	mov	odsbuf[di], al		; store in buffer (in stack)
	or	al, al
	jz short odc_flushit		; if null, flush buffer
	inc	odslen
	cmp	di, 79			; if full, flush buffer
	jnz short odc_ret

odc_flushit:
	mov	odsbuf[di], 0		; null terminate string
	lea	di, odsbuf
ifdef WOW
	cCall	<far ptr DebugWrite>,<ssdi,odslen>
else
	cCall	DebugWrite,<ssdi,odslen>
endif
	mov	odslen, 0
odc_ret:
	pop	di
	ret

Out_Debug_Chr	endp


;******************************************************************************
;
;   Show_Near_Label
;
;   DESCRIPTION:    call the debugger to display a label less than or equal
;		    to the given address
;
;   ENTRY:	    AX is selector, CX is offset of address to try to find
;		    a symbol for
;		    ES selector to DOSX data segment
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_Near_Label proc	near

	push	ax				;on a 286, use 16 bit regs
	push	bx
	push	cx
	mov	bx,cx
	mov	cx,ax
	mov	ax,DS_Out_Symbol
	int	Debug_Serv_Int
	pop	cx
	pop	bx
	pop	ax
	ret

Show_Near_Label endp


;******************************************************************************
;
;   Show_String
;
;   DESCRIPTION:    Display an asciiz string
;
;   ENTRY:	    AX is selector, CX is offset of address to find string
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_String	proc	near

	push	ax
	push	ds
	push	si

	mov	ds,ax
	mov	si,cx
	xor	ax,ax
	cmp	byte ptr ds:[si], ' '
	jbe	pascal_show_string
@@:
	lodsb
	or	al,al
	jz	short @f
	call	Out_Debug_Chr
	jmp	short @b
@@:
	pop	si
	pop	ds
	pop	ax

	ret

pascal_show_string:
	push	cx
	lodsb
	mov	cl, al
	xor	ch, ch
pss_1:	lodsb
	call	Out_Debug_Chr
	loop	pss_1
	pop	cx
	jmps	@B

Show_String endp

; END OF DXBUG STUFF



;-----------------------------------------------------------------------;
; CVWBreak
;
; This is part of the tortuous path from a Ctrl-Alt-SysReq to
; CVW.	In RegisterPtrace we tell the keyboard driver to jump
; here if Ctrl-Alt_SysReq is done.
;
; Entry:
;	none
;
; Returns:
;
; Registers Destroyed:
;	none
;
; History:
;  Mon 17-Jul-1989 14:34:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CVWBreak,<PUBLIC,FAR>
cBegin nogen

	push	ax
	push	di
	push	ds
	SetKernelDS
	test	Kernel_flags[2],KF2_PTRACE
	jz	short call_WDEB
	cmp	Kernel_InDOS,0		; not in DOS we don't
	jnz	short TVC15_exit
if pmode32
	.386p
	push	fs			; save current FS for debuggers
	.286p
endif
	call	genter			; sets FS to kernel data seg
	UnSetKernelDS
if pmode32
	.386p
	pop	fs
	.286p
endif
	dec	[di].gi_lrulock
	jz	short call_PTrace
	or	[di].gi_flags,GIF_INT2
	jmps	TVC15_exit

call_PTrace:
	SetKernelDS
	cmp	ptrace_DLL_entry.sel,0
	jnz	short yes_CVW

        ;** This is the only case where WINDEBUG gets first dibs something.
        ;*      Since we have no way of knowing if TOOLHELP wants the
        ;**     CtlAltSysRq, we always give it to CVW if it's there.
        test    Kernel_Flags[2],KF2_TOOLHELP
        jz      SHORT call_WDEB
        mov     ax,SDM_INT2             ;Notification number
        call    lpfnToolHelpProc        ;Give it to TOOLHELP
        jmp     SHORT TVC15_exit

        ;** Give it to the kernel debugger
call_WDEB:
	pop	ds
	UnSetKernelDS
	pop	di
	pop	ax

	int	1
	iret

        ;** Give it to CVW
yes_CVW:
	ReSetKernelDS
	mov	ax,SDM_INT2
	call	ptrace_DLL_entry
TVC15_exit:
	pop	ds
	UnSetKernelDS
	pop	di
	pop	ax
	iret

cEnd nogen



;-----------------------------------------------------------------------;
; DebugDefineSegment							;
;									;
; Informs debugger of physical address and type of a segment for the	;
; named module, that is informed of segment index and corresponding	;
; name and physical segment.						;
;									;
; Arguments:								;
;	ModName	    - Long pointer to module name.			;
;	SegNumber   - zero based segment index				;
;	LoadedSeg   - Physical seg address assigned by user to index.	;
;	InstanceNumber	- Windows instance number bound to physical seg.;
;	DataOrCodeFlag	- Whether segment is code or data.		;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:20:52p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

default_buf_size    equ 130

cProc  DebugDefineSegment,<PUBLIC,NEAR>,<es>
	Parmd	ModName
	Parmw	SegNumber
	Parmw	LoadedSeg
	Parmw	InstanceNumber
        Parmw   DataOrCodeFlag
        localV  modBuf,default_buf_size
        localV  nameBuf,default_buf_size
cBegin
        SetKernelDS es
	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	jz	short setdone
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	les	di, ModName
	UnSetKernelDS es
	mov	bx, SegNumber
	mov	cx, LoadedSeg
	mov	dx, InstanceNumber
	mov	si, DataOrCodeFlag
	mov	ax,SDM_LOADSEG
	DEBUGCALL
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
setdone:

ifdef WOW

	SetKernelDS es
        test    es:DebugWOW,DW_DEBUG
        jnz     @f
        jmp     dd_no_wdebug
	UnSetKernelDS es
@@:

        push    ds
	push	bx
	push	cx
	push	dx
	push	si
        push    di

        lds     si, ModName
        mov     cx,ds:[ne_magic]
        cmp     cx,NEMAGIC
        jz      @f
        jmp     not_yet

@@:     mov     cx,ss
        mov     es,cx
        lea     di,modBuf
        xor     cx,cx
        mov     cl,byte ptr [si-1]          ; Get length byte
        cmp     cx,default_buf_size
        jl      @f
        mov     cx,default_buf_size-1
@@:
        rep movsb                           ; Copy the string

        xor     ax,ax

        stosb

        mov     si,ds:[ne_pfileinfo]
        mov     cl,ds:[si].opLen
        sub     cx,opFile
        lea     si,[si].opFile
        lea     di,nameBuf
        cmp     cx,default_buf_size
        jl      @f
        mov     cx,default_buf_size-1
@@:
        rep movsb                           ; Copy the string

        stosb

	SetKernelDS es

        push    DataOrCodeFlag
        lea     si,nameBuf
        push    ss
        push    si
        lea     si,modBuf
        push    ss
        push    si
        push    SegNumber
        push    LoadedSeg
        push    DBG_SEGLOAD
	IFE PMODE
	BOP	BOP_DEBUGGER
	ELSE
	FBOP BOP_DEBUGGER,,FastBop
	ENDIF
        add     sp,+16

not_yet:
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ds
	UnSetKernelDS

dd_no_wdebug:

endif

cEnd

;-----------------------------------------------------------------------;
; DebugMovedSegment							;
;									;
; Informs debugger of the old and new values for a physical segment.	;
;									;
; Arguments:								;
;	SourceSeg - Original segment value.				;
;	DestSeg	  - New segment value.					;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:29:15p  -by-  David N. Weise   [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	DebugMovedSegment,<PUBLIC,NEAR>
	ParmW	SourceSeg
	ParmW	DestSeg
cBegin
cEnd


;-----------------------------------------------------------------------;
; DebugFreeSegment							;
;									;
; Informs debugger that a segment is being returned to the global	;
; memory pool and is no longer code or data.				;
;									;
; Arguments:								;
;	SegAddr - segment being freed					;
;	fRelBP	- flag indicating if breakpoints should be released,	;
;		  -1 means yes						;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:34:13p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DebugFreeSegment,<PUBLIC,NEAR>,<es>
	Parmw	SegAddr
	parmW	fRelBP
cBegin
	push	ds
	SetKernelDS
ifdef WOW
        test    DebugWOW,DW_DEBUG
        jz      df_no_wdebug

        push    SegAddr             ; Notify the Win32 debugger that
        push    fRelBP
        mov     ax,DBG_SEGFREE      ; the selector number needs to be freed
        push    ax
	IFE PMODE
	BOP	BOP_DEBUGGER
	ELSE
	FBOP BOP_DEBUGGER,,FastBop
	ENDIF
        add     sp,+6

df_no_wdebug:
endif
	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short killdone
	mov	bx, SegAddr
	mov	ax, SDM_FREESEG
	inc	fRelBP
	jnz	short @f
	mov	ax, SDM_RELEASESEG	;free but pulls out breakpoints 1st
@@:
	DEBUGCALL
killdone:
cEnd


;-----------------------------------------------------------------------;
; DebugWrite								;
;									;
; Prints the given string of the given length.	If a debugger is	;
; present tells the debugger to print the message.  Otherwise uses	;
; DOS Function 40h to the con device.					;
;									;
; Arguments:								;
;	lpBuf	long pointer to string to write				;
;	nBytes	# of bytes in string					;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:53:08p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

ifdef WOW
cProc	DebugWrite,<PUBLIC,FAR>,<ds,si>
else
cProc	DebugWrite,<PUBLIC,NEAR>,<ds,si>
endif
	parmD   lpBuf
	parmW   nBytes
	localW  wHandled
	localW	SavePDB

cBegin
	;** Validate the pointer and number of bytes

	mov	ax,WORD PTR lpBuf[0]
	add	ax,nBytes
	jnc     SHORT @F
	jmp	DW_End		;Overflow: error
@@:
if pmode32
	.386
	push	eax		; 32 bit ValidatePointer destroys top half
	push	ecx		;   of eax, ecx which isn't nice in debug outs
	.286
endif
	push	WORD PTR lpBuf[2]
	push	ax
	call	ValidatePointer ;Make sure pointer is OK
	or	ax,ax
if pmode32
	.386
	pop	ecx
	pop	eax
	.286
endif
	jnz     SHORT @F
	jmp     DW_End          ;Bogus pointer: just return.
@@:     mov	cx,nBytes
	lds	dx,lpBuf        ;DS:DX points to string
	or      cx,cx           ;Zero length requires computing
	jnz     SHORT DW_GoodLen

	;** Compute string length if a valid length not passed in
	mov	si,dx
	cld
DW_LenLoop:
	lodsb
	or	al,al
	jnz	short DW_LenLoop
	mov	cx,si
	sub	cx,dx
	dec	cx
DW_GoodLen:

	;** Set up for the Int 41h, PTrace, and TOOLHELP interfaces
	mov     wHandled,0      ;Flag that we haven't handled yet
	mov     si,dx           ;Point to string with DS:SI
	push    ds              ;  and ES:SI
	pop     es

	;** Decide which debugger (if any) to send string to

	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_SYMDEB ;WDEB386 loaded?
	pop	ds
	UnSetKernelDS
	jz	SHORT DW_TryToolHelp  ;No, now try TOOLHELP

	;** Send to WDEB386
        push    si
	DebInt	SDM_CONWRITE
        pop     si
	mov     wHandled,1      ;Assume that WDEB386 handled it

        ;** Send it to TOOLHELP if it is there
DW_TryToolHelp:
        push    ds
        SetKernelDS
        test    Kernel_Flags[2],KF2_TOOLHELP ;ToolHelp around?
	pop     ds
	UnSetKernelDS
        jz      SHORT DW_TryPTrace      ;Nope, now try PTrace

        push    ds
        SetKernelDS

        push    Win_PDB                 ;Save current PDB
        cmp     curTDB,0
        jz      @F
        push    es                      ; and set to current task's PDB
        mov     es,curTDB               ; for toolhelp call.
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:
	mov	ax,SDM_CONWRITE 	;Notification ID
	call    lpfnToolHelpProc        ;String in ES:SI for TOOLHELP

        pop     Win_PDB                 ;Restore current PDB

	or      ax,ax                   ;TOOLHELP client say to pass it on?

	pop     ds
	UnSetKernelDS
	jnz     SHORT DW_End            ;No, we're done

	;** Handle PTrace
DW_TryPTrace:
	SetKernelDS es
	cmp	WORD PTR es:ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking around?
	jz      SHORT DW_WriteToCOM     ;No, try COM port

        ;** If we're exiting a task, don't send the debug write to PTrace.
        ;**     This is a gross hack for QCWin who chokes on these.  These
        ;**     were being sent because of parameter validation errors.
        push    ax                      ;Temp reg
        mov     ax,es:curTDB
        cmp     ax,es:wExitingTDB
        pop     ax
        je      DW_WriteToCOM           ;Write out directly

IF KDEBUG
        ;** If we're sending a KERNEL trace out, we don't want to send this
        ;**     to PTrace, either
        cmp     fKTraceOut, 0           ;Are we doing a KERNEL trace out?
        jne     DW_WriteToCOM           ;Yes, don't call PTrace
ENDIF

        ;** Now send to PTrace
	mov     wHandled,1              ;Assume WINDEBUG handles if present
	push    ax                      ;Save regs PTrace might trash
	push    si
	push    dx
	push    ds
	push    es
	mov	ax,SDM_CONWRITE ;Notification ID
	call    es:ptrace_DLL_entry        ;Do the PTrace thing
	pop     es
	pop     ds
	pop     dx
	pop     si
	pop     ax

	;** Write string to debug terminal
DW_WriteToCOM:
	cmp     wHandled,0              ;Handled?
	jnz	SHORT DW_End		;Yes

        inc     es:fDW_Int21h              ; Skip it if user has canceled
	jnz	SHORT DW_Skip_Write	;   a crit error on this before

        mov     ax, es:topPDB
        xchg    es:Win_PDB, ax          ; Switch to Kernel's PDB,
	mov	SavePDB, ax		; saving current PDB

ifdef WOW
	cCall	WOWOutputDebugString,<lpBuf>
else
	mov	bx,3                    ;Send to DOS AUX port
	mov	ah,40h
	int	21h
endif; WOW

	mov	ax, SavePDB
        mov     es:Win_PDB, ax          ; restore app pdb

DW_Skip_Write:
        dec     es:fDW_Int21h
DW_End:
        UnSetKernelDS
        UnSetKernelDS   es
cEnd

;-----------------------------------------------------------------------;
; OutputDebugString							;
;									;
; A routine callable from anywhere since it is exported.  It calls	;
; DebugWrite to do its dirty work.					;
;									;
; Arguments:								;
;	lpStr	long pointer to null terminated string			;
;									;
; Returns:								;
;	none								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Tue June 28, 1988	       -by-  Ken Shirriff     [t-kens]		;
; Made it save all the registers.					;
;									;
;  Thu Nov 13, 1986 02:54:36p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	OutputDebugString,<PUBLIC,FAR,NODATA>,<es>
	parmD   lpStr
cBegin
	pusha
ifdef WOW
	cCall	<far ptr DebugWrite>,<lpStr, 0>
else
	cCall	DebugWrite,<lpStr, 0>
endif
	popa
cEnd


;-----------------------------------------------------------------------;
; DebugRead								;
;									;
; Gets a character from either the debugger (if one is present) or	;
; from the AUX.								;
;									;
; Arguments:								;
;	none								;
;									;
; Returns:								;
;	AL = character							;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:55:09p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DebugRead,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	;** Send it to the debugger(s) FIRST
	mov	ax,SDM_CONREAD  ;Get the notification ID


	; This sure is weird!  Goal is to ask if WDEB386 has a char
	; available.  If so, return.
	; We do the check here because MyDebugCall assumes INT41
	; doesn't modify registers, but the CONREAD call does.
	; This was hosing TOOLHELP, since we were passing a different
	; function to TOOLHELP based on what char a user was pressing.

	test	Kernel_Flags[2],KF2_SYMDEB	; WDEB386 loaded?
	jz	short dr_symdeb		; no - MyDebugCall
	DebInt				; Yes - read CON
	cmp	ax, SDM_CONREAD
	jnz	@F			; got a response - continue.

dr_symdeb:
	DEBUGCALL
@@:
	;** See if we should still hand it to the AUX port
	cmp     al,SDM_CONREAD  ;If not changed, we didn't get a character
	jne     SHORT DR_End

	mov	ax, wDefRIP	;Do we have a default value to use?
	or	ax, ax
	jnz	DR_End

        xor     cx,cx           ;Allocate WORD to read into
        push    cx
        mov     dx,sp           ;Point with DS:DX
	push    ss
        pop     ds
        inc     cx              ;Get one byte
DR_ConLoop:
ifdef WOW
	int 3			; BUGBUG mattfe 29-mar-92, should be thunked to 32 bit side.
endif
        mov     bx,3            ;Use AUX
	mov     ah,3fh          ;Read device
        int     21h             ;Call DOS
        cmp     ax,cx           ;Did we get a byte?
	jne     SHORT DR_ConLoop ;No, try again
        pop     ax              ;Get the byte read

DR_End:
	pop	ds
	ret

cEnd	nogen

;-----------------------------------------------------------------------;
; DebugDefineLine							;
;									;
; Notifies debugger of the location of The Line.			;
;									;
; Arguments:								;
;	None								;
;									;
; Returns:								;
;	None								;
;									;
; Registers Destroyed:							;
;									;
; History:								;
;  Mon 20-Jun-1988 13:17:41  -by-  David N. Weise  [davidw]		;
; Moved it here.							;
;-----------------------------------------------------------------------;
;
;	assumes ds,nothing
;	assumes es,nothing
;
;cProc	DebugDefineLine,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen
;
;cProc FarDebugNewTask,<PUBLIC,FAR>
;
;cBegin nogen
;	call	DebugNewTask
;	ret
;cEnd nogen
;
;
;-----------------------------------------------------------------------;
; DebugNewTask								;
;									;
;									;
; Arguments:								;
;	AX = EMS PID							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;
;
;cProc	DebugNewTask,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen
;
;cProc FarDebugFlushTask,<PUBLIC,FAR>
;
;cBegin nogen
;	call DebugFlushTask
;	ret
;cEnd nogen
;
;-----------------------------------------------------------------------;
; DebugFlushTask							;
;									;
;									;
; Arguments:								;
;	AX = EMS PID							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;
;
;cProc	DebugFlushTask,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen


;-----------------------------------------------------------------------;
; DebugSwitchOut							;
;									;
;									;
; Arguments:								;
;	DS = TDB							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

cProc	DebugSwitchOut,<PUBLIC,NEAR>

cBegin nogen
	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short dso_done

	push	ax
	mov	ax,SDM_SWITCHOUT
	DEBUGCALL
	pop	ax
dso_done:
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; DebugSwitchIn								;
;									;
;									;
; Arguments:								;
;	DS = TDB							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

cProc	DebugSwitchIn,<PUBLIC,NEAR>

cBegin nogen
	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short dsi_done

	push	ax
	mov	ax,SDM_SWITCHIN
	DEBUGCALL
	pop	ax
dsi_done:
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; DebugExitCall
;
; Notifies the debugger than an app is quitting.  This gets
; called at the top of ExitCall.
;
; Entry:
;
; Returns:
;
; Registers Preserved:
;	all
;
; History:
;  Thu 11-May-1989 08:58:40  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugExitCall,<PUBLIC,NEAR>
cBegin nogen
;
; Windebug knows where this is.  See MyDebugCall() comment.
;
ifdef WOW
	push	ds
	SetKernelDS
        test    DebugWOW,DW_DEBUG
        jz      de_no_wdebug

        push    ax
        push    es
        mov     es,bx               ; Get the current TDB
        push    es                      ; hTask
        mov     ax,es:[TDB_pModule] ; Get the module handle
        mov     es,ax

        push    es                      ; hModule

        push    es                      ; Pointer to module name
        push    es:ne_restab
        push    es                      ; Pointer to module path
        push    word ptr es:ne_crc+2

        mov     ax,DBG_TASKSTOP     ; the selector number needs to be freed
        push    ax
	FBOP BOP_DEBUGGER,,FastBop
        add     sp,+14

        pop     es                  ; Restore original ES
        pop     ax

de_no_wdebug:
        pop     ds
        UnSetKernelDS
endif

	push	ax
        mov     bl,al           ;Exit code in BL
	mov	ax,SDM_EXITCALL
	DEBUGCALL
        pop     ax


	ret
cEnd nogen


;-----------------------------------------------------------------------;
; FarDebugDelModule
;
; Notifies the debugger than a module is being deleted.  This gets
; called at the top of ExitCall.
;
; Entry:
;     ES = module handle
;
; Returns:
;
; Registers Reserved:
;     all
;
; History:
;  Mon 11-Sep-1989 18:34:06  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	FarDebugDelModule,<PUBLIC,FAR>
ifdef WOW
	localV	nameBuf,130
        localV  ModName,64
endif
cBegin nogen
	push	es
ifdef WOW
        push    ds
        push    es

        SetKernelDS

        test    DebugWOW,DW_DEBUG
        jnz     @f
        jmp     fdd_no_wdebug

@@:     push    di
        push    si
        push    cx
        xor     cx,cx
        mov     ax,es
        mov     ds,ax
        mov     si,es:[ne_restab]
        mov     cl,[si]
        inc     si
        cmp     cl,64
        jb      @f
        mov     cl,63
@@:
        mov     ax,ss
        mov     es,ax
        lea     di,ModName
        rep movsb                           ; Copy module name from resource
        mov     byte ptr es:[di],0          ; table and null terminate it
        mov     ax,ds
        mov     es,ax

        lea     di,nameBuf
        push    ax
        push    ss
        push    di
        mov     ax, 130
        push    ax
        call    GetModuleFileName

        SetKernelDS
        lea     di,nameBuf
        push    ss
        push    di
        lea     di,ModName
        push    ss
        push    di
        push    DBG_MODFREE
	IFE PMODE
	BOP	BOP_DEBUGGER
	ELSE
	FBOP BOP_DEBUGGER,,FastBop
	ENDIF
        add     sp,+10
        pop     cx
        pop     si
        pop     di
fdd_no_wdebug:
        pop     es
        pop     ds
        UnSetKernelDS
endif; WOW
	mov	ax,SDM_DELMODULE
	DEBUGCALL
	add	sp,2
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; void DebugLogError(WORD err, VOID FAR* lpInfo);
;
; Notifies debugger of a LogError() call.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugLogError,<PUBLIC,NEAR>
;ParmW	err
cBegin	nogen
	pop	ax

	pop	bx	    ; dx:bx = lpInfo
	pop	dx

	pop	cx	    ; cx = error code

	push	ax
	mov	ax,SDM_LOGERROR
	jmp	short MyDebugCall
cEnd	nogen

;-----------------------------------------------------------------------;
; void DebugLogParamError(VOID FAR* param, FARPROC lpfn, WORD err);
;
; Notifies debugger of a LogParamError() call.
;
; NOTE: the parameters are passed in the REVERSE order than expected,
; so that the stack layout is natural when we do the DebugCall.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugLogParamError,<PUBLIC,NEAR>
;ParmD	param
;ParmD	lpfn
;ParmW	err
cBegin	nogen
;
; es:bx = pointer to struct containing args
;
	mov	bx,sp
	add	bx,2	    ; point past return addr.
	push	ss
	pop	es
	mov	ax,SDM_LOGPARAMERROR
	call	MyDebugCall
	ret	2+4+4
cEnd	nogen

;------------------------------------------------------------------------
;
;  MyDebugCall
;
;  Call the debugger interface.  Created to reduce references to kernel
;  data segment.
;
;------------------------------------------------------------------------

	assumes ds,nothing
	assumes es,nothing

cProc   MyFarDebugCall, <FAR,PUBLIC>
cBegin  nogen
	cCall   MyDebugCall
	retf
cEnd    nogen

cProc	MyDebugCall,<NEAR,PUBLIC>
cBegin	nogen

	push	ds
	SetKernelDS

	test	Kernel_Flags[2],KF2_SYMDEB
	jz	short no_symdeb

	cmp	ax,SDM_SWITCHOUT	; Don't give these to WDEB.
	je	no_symdeb
	cmp	ax,SDM_SWITCHIN
	je	no_symdeb

	pop	ds			; Too bad some Int 41h services
	UnSetKernelDS			;   require segment reg params

	DebInt

	push	ds
	SetKernelDS

no_symdeb:

        ;** Check for TOOLHELP's hook.  We always send it here first
        ;**     This callback does NOT depend on what's on the stack.
        test    Kernel_Flags[2],KF2_TOOLHELP ;TOOLHELP hook?
        jz      SHORT MDC_NoToolHelp    ;No

        push    ax

        push    Win_PDB                 ; Preserve Win_TDB across ToolHelp call
        cmp     curTDB,0
        jz      @F
        push    es
        mov     es,curTDB
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:

        ;** Just call the TOOLHELP callback.  It preserves all registers
        ;**     except AX where it returns nonzero if the notification
        ;**     was handled.
        call    lpfnToolHelpProc        ;Do it

        pop     Win_PDB                 ; Restore Win_TDB

        or      ax,ax                   ;Did the TOOLHELP client say to
                                        ;  pass it on?
        jz      SHORT @F                ;Yes
        add     sp,2                    ;No, so return TOOLHELP's return value
        jmp     SHORT no_ptrace
@@:     pop     ax                      ;Restore notification ID

MDC_NoToolHelp:

	;** Make sure we don't have a new notification.  If it's newer than
        ;*      CVW, CVW chokes on it so we can't send new notifications
        ;**     through PTrace.
        cmp     ax,SDM_DELMODULE        ;Last old notification
        ja      short no_ptrace         ;Don't send new notification
MDC_PTraceOk:
	cmp	WORD PTR ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking around?
        jz      SHORT no_ptrace

; !!!!!!!!!!!!!! HACK ALERT !!!!!!!!!!!!!!
;
; Windebug.DLL for Windows 3.0 knows exactly what is on the stack
; when Kernel makes a PTrace callout.  For this reason, we cannot
; change what is on the stack when we make one of these calls.
; This stuff below fakes a FAR return to our NEAR caller, and jumps
; to the PTrace DLL entry with all registers intact.
;
	; SP -> DS RET

	sub	sp,8
	push	bp
	mov	bp,sp

	; BP -> BP xx xx xx xx DS KERNEL_RET

	mov	[bp+2],ax			; save AX

	mov	ax,[bp+10]			; move saved DS
	mov	[bp+4],ax

	mov	ax,[bp+12]			; convert near RET to far
	mov	[bp+10],ax
	mov	[bp+12],cs

	mov	ax,word ptr ptrace_dll_entry[2]	; CS of Routine to invoke
	mov	[bp+8],ax
	mov	ax,word ptr ptrace_dll_entry	; IP of Routine to invoke
	mov	[bp+6],ax

	; SP -> BP AX DS PTRACE_IP PTRACE_CS KERNEL_RET KERNEL_CS

	pop	bp
	pop	ax
	pop	ds
	UnSetKernelDS
	retf

no_ptrace:
	pop	ds
	UnSetKernelDS

	ret
cEnd	nogen


if KDEBUG

dout	macro	var
	mov	byte ptr ss:[si],var
	inc	si
	endm


;-----------------------------------------------------------------------;
; hex									;
;									;
; Outputs byte in AL as two hex digits.					;
;									;
; Arguments:								;
;	AL    = 8-bit value to be output				;
;	SS:SI = where it's to be put					;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Fri Nov 14, 1986 02:32:15p  -by-  David N. Weise   [davidw]		;
; Modified it from symdeb\debug.asm.					;
;-----------------------------------------------------------------------;

ifndef WOW
cProc	hex,<NEAR>
cBegin nogen

	mov	ah,al		; save for second digit

; shift high digit into low 4 bits

	mov	cl,4
	shr	al,cl

	and	al,0Fh		; mask to 4 bits
	add	al,90h
	daa
	adc	al,40h
	daa
	dout	al

	mov	al,ah		; now do digit saved in ah
	and	al,0Fh		; mask to 4 bits
	add	al,90h
	daa
	adc	al,40h
	daa
	dout	al
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; pdref_norip								;
;									;
; Dereferences the given global handle, i.e. gives back abs. address.	;
;									;
; Arguments:								;
;	DX    = selector						;
;	DS:DI = BURGERMASTER						;
;									;
; Returns:								;
;	FS:ESI = address of arena header				;
;	AX = address of client data					;
;	CH = lock count or 0 for fixed objects				;
;	CL = flags							;
;	DX = handle, 0 for fixed objects				;
;									;
; Error Returns:							;
;	ZF = 1 if invalid or discarded					;
;	AX = 0								;
;	BX = owner of discarded object					;
;	SI = handle of discarded object					;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	ghdref								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

if pmode32
	.386p
	assumes ds,nothing
	assumes es,nothing

cProc	pdref_norip,<PUBLIC,NEAR>

cBegin nogen
					; DPMI - no LDT access
	mov	si, dx
	sel_check si
	or	si, si			; Null handle?
	jnz	short OK1
	mov	ax, si			; yes, return 0
	jmps	pd_exit
OK1:
	lar	eax, edx
	jnz	short pd_totally_bogus
	shr	eax, 8

; We should beef up the check for a valid discarded sel.

	xor	cx,cx
	test	ah, DSC_DISCARDABLE
	jz	short pd_not_discardable
	or	cl, GA_DISCARDABLE
						; Discardable, is it code?
	test	al, DSC_CODE_BIT
	jz	short pd_not_code
	or	cl,GA_DISCCODE
pd_not_code:

pd_not_discardable:
	test	al, DSC_PRESENT
	jnz	short pd_not_discarded

; object discarded

	or	cl,HE_DISCARDED
if PMODE32
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	ax,es				; save es
	mov	bx,dx
	mov	es,cs:gdtdsc
	and	bl, not 7
	mov	bx,es:[bx].dsc_owner
	mov	es,ax				; restore
else
	lsl	bx, dx				; get the owner
endif
	or	si, SEG_RING-1			; Handles are RING 2
	xor	ax,ax
	jmps	pd_exit

pd_not_discarded:
	cCall	get_arena_pointer32,<dx>
	mov	esi, eax
	mov	ax, dx
	or	esi, esi			; Unknown selector
	jz	short pd_maybe_alias
	mov	dx, ds:[esi].pga_handle
	cmp	dx, ax				; Quick check - handle in header
	je	short pd_match			; matches what we were given?

	test	al, 1				; NOW, we MUST have been given
	jz	short pd_totally_bogus		; a selector address.
	push	ax
	StoH	ax				; Turn into handle
	cmp	dx, ax
	pop	ax
	jne	short pd_nomatch
pd_match:
	or	cl, ds:[esi].pga_flags
	and	cl, NOT HE_DISCARDED		; same as GA_NOTIFY!!
	mov	ax, dx				; Get address in AX
	test	dl, GA_FIXED			; DX contains handle
	jnz	short pd_fixed			; Does handle need derefencing?
	mov	ch, ds:[esi].pga_count
	HtoS	ax				; Dereference moveable handle
	jmps	pd_exit
pd_totally_bogus:
	xor	ax,ax
pd_maybe_alias:
pd_nomatch:					; Handle did not match...
	xor	dx, dx
pd_fixed:
pd_exit:
	or	ax,ax
	ret
cEnd nogen
	.286p
endif

;-----------------------------------------------------------------------;
; xhandle_norip								;
; 									;
; Returns the handle for a global segment.				;
; 									;
; Arguments:								;
;	Stack = sp   -> near return return address			;
;		sp+2 -> far return return address of caller		;
;		sp+6 -> segment address parameter			;
; 									;
; Returns:								;
;	Old DS,DI have been pushed on the stack				;
;									;
;	ZF= 1 if fixed segment.						;
;	 AX = handle							;
;									;
;	ZF = 0								;
;	 AX = handle							;
;	 BX = pointer to handle table entry				;
;	 CX = flags and count word from handle table			;
;	 DX = segment address						;
;	 ES:DI = arena header of object					;
;	 DS:DI = master object segment address				;
; 									;
; Error Returns:							;
;	AX = 0 if invalid segment address				;
;	ZF = 1								;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Oct 16, 1986 02:40:08p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;
if pmode32
	.386p
cProc	xhandle_norip,<PUBLIC,NEAR>
cBegin nogen
	pop	dx			; Get near return address
	mov	bx,sp			; Get seg parameter from stack
	mov	ax,ss:[bx+4]
	cmp	ax,-1			; Is it -1?
	jnz	short xh1
	mov	ax,ds			; Yes, use callers DS
xh1:	inc	bp
	push	bp
	mov	bp,sp
	push	ds			; Save DS:DI
	push	edi
	push	esi
	SetKernelDS
	mov	ds, pGlobalHeap 	; Point to master object
	UnSetKernelDS
	xor	edi,edi
	inc	[di].gi_lrulock
	push	dx
	mov	dx,ax
	call	pdref_norip

	xchg	dx,ax			; get seg address in DX
	jz	short xhandle_ret		; invalid or discarded handle
	test	al, GA_FIXED
	jnz	short xhandle_fixed
	or	ax, ax
	jmps	xhandle_ret
xhandle_fixed:
	xor	bx, bx			; Set ZF
xhandle_ret:
	ret
cEnd nogen
	.286p

else    ; !pmode32

cProc	xhandle_norip,<PUBLIC,NEAR>
cBegin nogen
	pop	dx			; Get near return address
	mov	bx,sp			; Get seg parameter from stack
	mov	ax,ss:[bx+4]
	cmp	ax,-1			; Is it -1?
	jnz	xh1
	mov	ax,ds			; Yes, use callers DS
xh1:	inc	bp
	push	bp
	mov	bp,sp
	push	ds			; Save DS:DI
	push	di
	call	genter
	push	dx
	mov	dx,ax
	push	si
externNP pdref
	call	pdref
	xchg	dx,ax			; get seg address in DX
	jz	xhandle_ret		; invalid or discarded handle
	mov	bx,si
	or	si,si
	jz	xhandle_ret
	mov	ax,si
xhandle_ret:
	pop	si
	ret
cEnd nogen



endif    ; !pmode32
endif    ;ifndef WOW

endif	;KDEBUG

cProc	ReplaceInst,<PUBLIC,FAR>

;;	parmD bpaddress
;;	parmW instruct

cBegin nogen
	ret	6
cEnd nogen


sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldheader.asm ===
TITLE   LDHEADER - Load Exe Header procedure

.xlist
include gpfix.inc
include kernel.inc
include newexe.inc
.list

externA  __AHINCR

externFP IGlobalAlloc
externFP IGlobalFree
externFP FarSetOwner
externFP Int21Handler
externFP FarMyUpper
externFP IsBadStringPtr
externFP _hread

DataBegin

externB fBooting
externB szBozo
externW winVer
externD pSErrProc

DataEnd
          
externFP IGlobalLock
externFP IGlobalUnLock

sBegin  NRESCODE
assumes CS,NRESCODE

externNP NResGetPureName


;-----------------------------------------------------------------------;
; LoadExeHeader                                                         ;
;                                                                       ;
; Routine to read an EXE header and check for a new format EXE file.    ;
; Returns NULL if not a new format EXE.  Otherwise reads the resident   ;
; portion of the new EXE header into allocated storage and returns      ;
; the segment address of the new EXE header.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   fh                                                      ;
;       parmW   isfh                                                    ;
;       parmD   pfilename                                               ;
;                                                                       ;
; Returns:                                                              ;
;       AX = segment of exe header                                      ;
;       DL = ne_exetyp                                                  ;
;       DH = ne_flagsothers                                             ;
;                                                                       ;
; Error Returns:                                                        ;
;LME_MEM        = 0     ; Out of memory                                 ;
;LME_VERS       = 10    ; Wrong windows version                         ;
;LME_INVEXE     = 11    ; Invalid exe                                   ;
;LME_OS2        = 12    ; OS/2 app                                      ;
;LME_DOS4       = 13    ; DOS 4 app                                     ;
;LME_EXETYPE    = 14    ; unknown exe type                              ;
;LME_COMP       = 19    ; Compressed EXE file                           ;
;LME_PE         = 21    ; Portable EXE                                  ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI                                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,BX,CX,DS,ES                                                  ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Mar 19, 1987 08:35:32p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   LoadExeHeader,<PUBLIC,FAR>,<si,di>
        parmW   fh
        parmW   isfh
        parmD   pfilename
        localW  pnewexe
        localW  exetype
        localW  nchars
        localW  pseg
        localW  psegsrc
        localW  hBlock
        localW  pBlock
        localW  NEFileOffset
        localD  PreloadLen
        localW  NEBase
        localW  exeflags
        localW  expver
        localW  saveSP
        localB  fast_fail               ; 1 if we can't use fastload block
        localV  hdrbuf,<SIZE EXE_HDR>

.errnz  SIZE EXE_HDR - SIZE NEW_EXE

cBegin
        xor     ax,ax
        mov     pseg,ax
        mov     hBlock, ax
        mov     fast_fail, al
        cmp     SEG_pfilename,ax
        je      re0

IF      KDEBUG                          ; LoadExeHeader is internal
        cCall   IsBadStringPtr, <pfilename, 128> ; so we assume file pointer is OK
        or      ax, ax
        jnz     refailj
ENDIF
        lds     si,pfilename
        mov     al,ds:[si].opLen
        inc     ax                      ; include null byte
re0:
        mov     nchars,ax
        mov     bx,fh                   ; No, seek backwards over what
        cmp     isfh,bx
        je      refile
        mov     ds,bx
        xor     si,si
        jmp     remem

refile:                                 ; Here to load from a file
        push    ss                      ; DS:SI points to I/O buffer
        pop     ds
        lea     si,hdrbuf               ; Read beginning of file
        mov     dx,si
        mov     cx,SIZE EXE_HDR
        mov     bx,fh
        mov     ah,3Fh
        DOSFCALL
        jnc     @F
refailj:
        jmps    refail
@@:
        cmp     ax,cx                   ; Old EXE file, look for offset
        jb      refailj                 ; to new exe header
        cmp     ds:[si].e_magic,EMAGIC  ; Check for old exe file
        je      @F
        cmp     ds:[si], 'ZS'           ; Is it compressed?
        jne     refail
        cmp     ds:[si][2],'DD'
        jne     refail
        cmp     ds:[si][4],0F088h
        jne     refail
        cmp     ds:[si][6],03327h
        jne     refail
        mov     ax, LME_COMP            ; Compressed EXE
        jmp     reexit
@@:
        mov     ax,ds:[si].e_lfanew.hi
        mov     dx,ds:[si].e_lfanew.lo
        mov     pnewexe,dx              ; To check for bound OS/2 apps.
        or      ax,dx
        jz      refail                  ; Fail if not there.

        mov     cx,ds:[si].e_lfanew.hi
        mov     dx,ds:[si].e_lfanew.lo
        mov     bx, fh
        mov     ax,4200h
        DOSFCALL
        jc      refail
        mov     cx,SIZE NEW_EXE
        mov     dx,si
        mov     ah,3Fh
        DOSFCALL
        jc      refail
        cmp     ax,cx
        jne     refail
        cmp     ds:[si].ne_magic,NEMAGIC ; Did we get a valid new EXE header?
        je      remem
        cmp     ds:[si].ne_magic,PEMAGIC ; Did we find a Portable EXE (WIN32)
        jne     refail
        mov     ax, LME_PE
        jmps    rej
refail:
        mov     ax, LME_INVEXE          ; invalid NEW EXE file format
rej:    jmp     reexit

remem:
        mov     psegsrc,bx              ; bx has either fh or seg address
        mov     di,ds:[si].ne_enttab    ; Compute size of resident new header
        add     di,ds:[si].ne_cbenttab
        add     di, 6                   ; null entry space (bug #8414)

        mov     cx, ds:[si].ne_cbenttab
        mov     bx, ds:[si].ne_cmovent
        shl     bx, 1
        sub     cx, bx
        shl     bx, 1
        sub     cx, bx                  ; Number of bytes not moveable entries
        shl     cx, 1                   ; Allow triple these bytes
        add     di, cx

        mov     cx,ds:[si].ne_cseg      ; + 3 * #segments

; Reserve space for ns_handle field in segment table

        shl     cx,1
        add     di,cx

        .errnz  10 - SIZE NEW_SEG1

; Reserve space for file info block at end

        add     di,nchars               ; + size of file info block

        xor     ax,ax                   ; Allocate a fixed block for header
        mov     bx,GA_ZEROINIT or GA_MOVEABLE
        cCall   IGlobalAlloc,<bx,ax,di>  ;  that isn't code or data.
        or      ax,ax
        jnz     @F
        jmps    badformat
@@:
        push    ax
        cCall   IGlobalLock,<ax>
        pop     ax
        push    dx
        cCall   IGlobalUnlock,<ax>
        pop     ax
        sub     di,nchars
        mov     pseg,ax
        mov     es,ax                   ; ES:0 -> new header location
        cld                             ; DS:SI -> old header
        mov     bx,psegsrc
        cmp     isfh,bx                 ; Is header in memory?
        jne     remem1                  ; Yes, continue
        mov     ax,ds:[si].ne_enttab    ; No, read into high end
        add     ax,ds:[si].ne_cbenttab  ; of allocated block
        sub     di,ax
        mov     cx,SIZE NEW_EXE         ; Copy part read so far
        sub     ax,cx
        rep     movsb
        mov     cx,ax
        smov    ds,es                   ; Read rest of header from file
        mov     dx,di
        mov     ah,3fh
        DOSFCALL
        mov     bx,ax
        jc      refail1
        lea     si,[di-SIZE NEW_EXE]    ; DS:SI -> old header
        cmp     bx,cx
        je      remem1
badformat:
        mov     ax, LME_INVEXE          ; don't change flags
refail1:                                ; Here if error reading header
        push    ax
        SetKernelDSNRes                 ; DS may be = pseg, prevent
        cCall   IGlobalFree,<pseg>       ;  GP faults in pmode.
        pop     ax
        jmp     reexit

remem1:
        UnsetKernelDS
        test    ds:[si].ne_flags,NEIERR ; Errors in EXE image?
        jnz     badformat               ; Yes, fail

        cmp     ds:[si].ne_ver,4        ; No, built by LINK4 or above?
        jl      badformat               ; No, error
        mov     bx,ds:[si].ne_flags     ; Make local copies of ne_flags &
        and     bl,NOT NEPROT           ;   ne_expver which can be modified
        mov     exeflags,bx             ;   (can't change ROM exe headers).
        mov     bx,ds:[si].ne_expver
        mov     expver,bx
        mov     bx,word ptr ds:[si].ne_exetyp   ; get exetyp and flagsothers
        mov     exetype,bx

        cmp     bl,NE_UNKNOWN
        jz      windows_exe
        cmp     bl,NE_WINDOWS           ; is it a Windows exe?
        jz      windows_exe
        mov     ax,LME_OS2
        cmp     bl,NE_OS2               ; is it an OS|2 exe?
        jnz     not_os2
        test    bh,NEINPROT             ; can it be run under Windows?
        jz      @F
        and     exeflags,NOT NEAPPLOADER
        or      exeflags,NEPROT
        mov     expver,0300h
        jmps    windows_exe
@@:
        cmp     pnewexe,0800h           ; is it a bound
        jb      refail1
        jmp     badformat
not_os2:
        inc     ax                      ; AX = 13 - LME_DOS4
        cmp     bl,NE_DOS4              ; is it a DOS 4 exe?
        jz      refail1
        inc     ax                      ; AX = 14 - LME_EXETYPE
        jmp     refail1

mgxlib DB 'MGXLIB'

windows_exe:

        mov     NEBase, si              ; Offset of Source header
        xor     di,di                   ; ES:DI -> new header location
        mov     cx,SIZE NEW_EXE         ; Copy fixed portion of header
        cld
        rep     movsb
        mov     ax,exeflags
if ROM
        and     al,NOT NEMODINROM       ; Assume module not in ROM
endif
        mov     es:[ne_flags],ax
        mov     ax,expver
        mov     es:[ne_expver],ax
        mov     si, NEBase
        add     si, es:[ne_segtab]      ; Real location of segment table
        mov     cx,es:[ne_cseg]         ; Copy segment table, adding
        mov     es:[ne_segtab],di
        jcxz    recopysegx
recopyseg:

if ROM

; If this is a module from ROM, the ROM ns_sector field contains the selector
; pointing to the ROM segment--this will become the RAM ns_handle value.

        .errnz  ns_sector
        mov     dx,ds:[si].ns_flags     ; do while si->start of seg info
        lodsw                           ; ns_sector
        xor     bx,bx                   ; ns_handle if not in ROM
        test    dh,(NSINROM SHR 8)
        jz      store_sector
        mov     bx,ax                   ; will be ns_handle
store_sector:
        stosw                           ; ns_sector
else
        movsw                           ; ns_sector
endif
        movsw                           ; ns_cbseg
        lodsw                           ; ns_flags

        .errnz  4 - ns_flags

if ROM
        mov     dl,al
        and     dl,NSLOADED
        and     ax,not (NS286DOS XOR (NSGETHIGH OR NSINROM))
else
        and     ax,not (NS286DOS XOR NSGETHIGH) ; Clear 286DOS bits
endif
; record in the segment flags if this module is a process, this is for EMS

        test    ax,NSTYPE               ; NSCODE
        jnz     not_code
        or      ax,NSWINCODE
not_code:
        or      ax,NSNOTP
        test    es:[ne_flags],NSNOTP
        jnz     not_a_process
        xor     ax,NSNOTP
        or      ax,NSMOVE
not_a_process:
if ROM
        test    ah,(NSINROM SHR 8)      ; if sector is in ROM, preserve
        jz      @f                      ;   NSLOADED flag from ROM builder
        or      al,dl
@@:
endif
        stosw                           ; ns_flags
        movsw                           ; ns_minalloc
        .errnz  8 - SIZE NEW_SEG
if ROM
        mov     ax,bx                   ; bx set to selector or 0 above
else
        xor     ax,ax
endif
        stosw                           ; one word for ns_handle field
        .errnz  10 - SIZE NEW_SEG1
        loop    recopyseg

recopysegx:
        test    es:[ne_flagsothers], NEGANGLOAD
        jz      no_gang_loadj
        mov     bx, fh
        cmp     bx, isfh
        jne     no_gang_loadj

        mov     ax, es:[ne_gang_start]
        or      ax, ax
        jz      no_gang_loadj
        mov     NEFileOffset, ax        ; file offset of gang load area
        mov     ax, es:[ne_gang_length]
        or      ax, ax
        jz      no_gang_loadj
        mov     cx, es:[ne_align]
        xor     dx, dx
gl_len:                                 ; find length of Gang Load area
        shl     ax, 1
        adc     dx, dx
        loop    gl_len

        cmp     dx, 10h                 ; Greater than 1Mb, forget it!!
        jb      alloc_it                ; PS: NEVER go bigger than 1Mb
no_gang_loadj:
        jmp     no_gang_load            ; since LongPtrAdd is limited...

alloc_it:
        mov     word ptr PreloadLen[0], ax
        mov     word ptr PreloadLen[2], dx
        mov     ch, GA_DISCARDABLE
        mov     cl, GA_MOVEABLE+GA_NODISCARD+GA_NOCOMPACT
        push    es
        cCall   IGlobalAlloc,<cx,dx,ax>  ; Allocate this much memory
        pop     es
        or      ax, ax
        jz      no_gang_loadj
        mov     hBlock, ax              ; Have memory to read file into
        push    es
        cCall   IGlobalLock,<ax>
        pop     es
        mov     pBlock, dx
        mov     dx, NEFileOffset
        mov     cx, es:[ne_align]
        xor     bx, bx
gl_pos:                                 ; find pos of Gang Load start
        shl     dx, 1
        adc     bx, bx
        loop    gl_pos

        mov     cx, bx

        mov     bx, fh
        mov     ax,4200h
        DOSFCALL                        ; Seek to new exe header
        jc      refailgang

        mov     ax, pBlock
        xor     bx, bx
        farptr  memadr,ax,bx
        cCall   _hread, <fh, memadr, PreloadLen>
        cmp     dx, word ptr PreloadLen[2]
        jnz     refailgang
        cmp     ax, word ptr PreloadLen[0]
        jz      no_gang_load            ; We're OK now
;       push    ds
;       xor     dx, dx
;       mov     ax, pBlock

;       push    si
;       push    di
;       mov     si, word ptr PreloadLen[2]
;       mov     di, word ptr PreloadLen[0]
;read_file:
;       mov     cx, 08000h              ; Must be factor 64k DON'T CHANGE THIS
;       or      si, si
;       jnz     big_read
;       cmp     cx, di
;       jbe     big_read
;       mov     cx, di                  ; all that's left
;       jcxz    done_read               ; Nothing left, quit.
;big_read:
;       mov     ds, ax
;       mov     ah, 3Fh
;       DOSFCALL                        ; Read chunk from file
;       jc      refailgang
;       cmp     ax, cx                  ; All we asked for?
;       jne     refailgang              ;  no, file corrupted
;       sub     di, cx
;       sbb     si, 0
;       mov     ax, ds
;       add     dx, cx                  ; On to next block
;       jnc     read_file
;       add     ax, __AHINCR
;       jmps    read_file
;
refailgang:
;       pop     di
;       pop     si
;       pop     ds
        cCall   IGlobalUnlock,<hBlock>
        cCall   IGlobalFree,<hBlock>
        mov     hBlock, 0
        jmps    no_gang_load

BadExeHeader:                           ; GP fault handler!!!
        mov     sp, saveSP
;       fix_fault_stack
        jmp     refail1                 ; corrupt exe header (or our bug)


;done_read:
;       pop     di
;       pop     si
;       pop     ds

no_gang_load:
        mov     saveSP, sp
beg_fault_trap  BadExeHeader
        mov     cx,es:[ne_restab]       ; Copy resource table
        sub     cx,es:[ne_rsrctab]
        mov     si, NEBase              ; Get correct source address
        add     si, es:[ne_rsrctab]
        mov     es:[ne_rsrctab],di
        rep     movsb

rerestab:
        mov     cx,es:[ne_modtab]       ; Copy resident name table
        sub     cx,es:[ne_restab]
        mov     es:[ne_restab],di
        rep     movsb

        push    di
        mov     di, es:[ne_restab]      ; Make the module name Upper Case
        xor     ch, ch
        mov     cl, es:[di]
        inc     di
uppercaseit:
        mov     al, es:[di]
        call    farMyUpper
        stosb
        loop    uppercaseit
        pop     di

        mov     cx,es:[ne_imptab]       ; Copy module xref table
        sub     cx,es:[ne_modtab]
        mov     es:[ne_modtab],di
        rep     movsb

        mov     es:[ne_psegrefbytes],di ; Insert segment reference byte table
        mov     es:[ne_pretthunks],di   ; Setup return thunks
        mov     cx,es:[ne_enttab]       ; Copy imported name table
        sub     cx,es:[ne_imptab]
        mov     es:[ne_imptab],di
        jcxz    reenttab
        rep     movsb

reenttab:
        mov     es:[ne_enttab],di
                                        ; Scan current entry table
        xor     ax, ax                  ; First entry in block
        mov     bx, di                  ; Pointer to info for this block
        stosw                           ; Starts at 0
        stosw                           ; Ends at 0
        stosw                           ; And is not even here!

copy_next_block:
        lodsw                           ; Get # entries and type
        xor     cx, cx
        mov     cl, al
        jcxz    copy_ent_done

        mov     al, ah
        cmp     al, ENT_UNUSED
        jne     copy_used_block

        mov     ax, es:[bx+2]           ; Last entry in current block
        cmp     ax, es:[bx]             ; No current block?
        jne     end_used_block

        add     es:[bx], cx
        add     es:[bx+2], cx
        jmps    copy_next_block

end_used_block:
        mov     es:[bx+4], di           ; Pointer to next block
        mov     bx, di
        add     ax, cx                  ; Skip unused entries
        stosw                           ; First in new block
        stosw                           ; Last in new block
        xor     ax, ax
        stosw                           ; End of list
        jmps    copy_next_block

copy_used_block:
        add     es:[bx+2], cx           ; Add entries in this block
        cmp     al, ENT_MOVEABLE
        je      copy_moveable_block

; absolutes end up here as well

copy_fixed_block:
        stosb                           ; Segno
        movsb                           ; Flag byte
        stosb                           ; segno again to match structure
        movsw                           ; Offset
        loop    copy_fixed_block
        jmps    copy_next_block

copy_moveable_block:
        stosb                           ; ENT_MOVEABLE
        movsb                           ; Flag byte
        add     si, 2                   ; Toss int 3Fh
        movsb                           ; Copy segment #
        movsw                           ; and offset
        loop    copy_moveable_block
        jmps    copy_next_block

copy_ent_done:
        xor     bx,bx
        cmp     es:[bx].ne_ver,5        ; Produced by version 5.0 LINK4
        jae     remem2a                 ; or above?
        mov     es:[bx].ne_expver,bx    ; No, clear uninitialized fields
        mov     es:[bx].ne_swaparea,bx

; TEMPORARY BEGIN

        push    ax
        push    cx
        push    di
        push    si
        mov     si,es:[bx].ne_rsrctab
        cmp     si,es:[bx].ne_restab
        jz      prdone
        mov     di,es:[si].rs_align
        add     si,SIZE new_rsrc
prtype:
        cmp     es:[si].rt_id,0
        je      prdone
        mov     cx,es:[si].rt_nres
        add     si,SIZE rsrc_typeinfo
prname:
        push    cx
        mov     ax,es:[si].rn_flags
        test    ah,0F0h                 ; Is old discard field set?
        jz      @F
        or      ax,RNDISCARD            ; Yes, convert to bit
@@:
        and     ax,not RNUNUSED         ; Clear unused bits in 4.0 LINK files
        mov     es:[si].rn_flags,ax
        pop     cx
        add     si,SIZE rsrc_nameinfo
        loop    prname

        jmp     prtype

prdone: pop     si
        pop     di
        pop     cx
        pop     ax

; TEMPORARY END

FixFlags:                               ; label for debugging
public FixFlags, leh_slow
public leh_code, leh_patchnext, leh_code_fixed, leh_patchdone, leh_data
remem2a:                                ; (bx == 0)
        mov     es:[bx].ne_usage,bx
        mov     es:[bx].ne_pnextexe,bx
        mov     es:[bx].ne_pfileinfo,bx
        cmp     es:[bx].ne_align,bx
        jne     @F
        mov     es:[bx].ne_align,NSALIGN
@@:
        mov     cx,nchars
        jcxz    @F
        mov     es:[bx].ne_pfileinfo,di
        lds     si,pfilename
        rep     movsb
@@:                                     ; Save pointer to seginfo record
        mov     bx,es:[bx].ne_autodata  ; of automatic data segment
        or      bx,bx
        jz      @F
        dec     bx
        shl     bx,1
        mov     cx,bx
        shl     bx,1
        shl     bx,1
        add     bx,cx
        .errnz  10 - SIZE NEW_SEG1
        add     bx,es:[ne_segtab]
@@:
        mov     es:[ne_pautodata],bx

        SetKernelDSNRes

; Scan seg table, marking nonautomatic DATA segments fixed, preload

        mov     ax,es:[ne_expver]       ; Default expected version to
        or      ax,ax
        jnz     @F
        mov     ax,201h
        mov     es:[ne_expver],ax       ; 2.01
@@:
        cmp     ax,winVer
        jbe     @F
        cCall   IGlobalFree,<pseg>
        mov     ax, LME_VERS
        jmp     reexit
@@:
        mov     bx,es:[ne_segtab]
        xor     cx,cx
        sub     bx,SIZE NEW_SEG1
        jmps    leh_patchnext

leh_test_preload:
        test    byte ptr es:[bx].ns_flags, NSPRELOAD
        jnz     leh_patchnext

        or      byte ptr es:[bx].ns_flags, NSPRELOAD

        cmp     es:[bx].ns_sector, 0    ; don't whine about empty segments
        je      leh_patchnext

        krDebugOut      DEB_WARN, "Segment #CX of %ES0 must be preload"
        mov     fast_fail, 1

leh_patchnext:
        add     bx,SIZE NEW_SEG1
        inc     cx
        cmp     cx,es:[ne_cseg]
        ja      leh_patchdone
        test    byte ptr es:[bx].ns_flags,NSDATA ; Is it a code segment?
        jz      leh_code                        ; Yes, next segment
        .errnz  NSCODE
leh_data:       ; Data must be non-discardable, preload
if KDEBUG
        test    es:[bx].ns_flags, NSDISCARD
        jz      @F
        krDebugOut DEB_WARN, "Data Segment #CX of %ES0 can't be discardable"
@@:
endif
        and     es:[bx].ns_flags,not NSDISCARD  ; Data segments not discardable
        jmps    leh_test_preload

leh_code:
        test    byte ptr es:[bx].ns_flags,NSMOVE; Moveable code?
        jz      leh_code_fixed

                ; moveable code must be discardable, or must be preload
if      KDEBUG
        test    es:[ne_flags],NENOTP            ; for 3.0 libraries can't have
        jz      @F                              ;  moveable only code
        cmp     fBooting,0                      ; If not booting
        jne     @F
        test    es:[bx].ns_flags,NSDISCARD
        jnz     @F
        krDebugOut DEB_WARN, "Segment #CX of %ES0 was discardable under Win 3.0"
@@:
endif
        test    es:[bx].ns_flags,NSDISCARD      ; Is it discardable?
        jnz     leh_patchnext
        jmp     leh_test_preload

leh_code_fixed: ; fixed code must be preload
        cmp     fBooting,0                      ; If not booting
        jne     leh_patchnext
        jmp     leh_test_preload

leh_patchdone:
        mov     bx,word ptr es:[ne_csip+2]      ; Is there a start segment?
        or      bx,bx
        jz      @F                              ; No, continue
        dec     bx
        shl     bx,1
        mov     si,bx
        shl     si,1
        shl     si,1
        add     si,bx
        .errnz  10 - SIZE NEW_SEG1
        add     si,es:[ne_segtab]       ; Mark start segment as preload
if kdebug
        test    byte ptr es:[si].ns_flags,NSPRELOAD
        jnz     scs_pre
        krDebugOut DEB_WARN, "Starting Code Segment of %ES0 must be preload"
        mov     fast_fail, 1
scs_pre:
endif
        or      byte ptr es:[si].ns_flags,NSPRELOAD

        cmp     es:[ne_autodata],0      ; Is there a data segment?
        je      @F
        or      es:[si].ns_flags,NSUSESDATA ; Yes, then it needs it
        mov     si,es:[ne_pautodata]
if kdebug
        test    byte ptr es:[si].ns_flags,NSPRELOAD
        jnz     sds_pre
        cmp     es:[bx].ns_sector, 0    ; don't whine about empty segments
        je      sds_pre
        krDebugOut DEB_WARN, "Default Data Segment of %ES0 must be preload"
        mov     fast_fail, 1
sds_pre:
endif
        or      byte ptr es:[si].ns_flags,NSPRELOAD ; Mark DS as preload
@@:
        test    es:[ne_flags],NENOTP    ; No stack if not a process
        jnz     @F
        cmp     es:[ne_stack],4096+1024
        jae     @F
        mov     es:[ne_stack],4096+1024 ; 4k stack is not enough (raor)
@@:        
        mov     cx, es:[ne_heap]        ; If the module wants a heap
        jcxz    leh_heapadjdone         ;   make sure it's big enough                                                                                                                       
        mov     ax, 800h                ; ; Environment variables have                                                                    
        cmp     cx, ax                  ; grown, so we need more heap 
        jae     leh_heapadjdone         ; space for apps so we use 800h              
        mov     dx, ax
        test    es:[ne_flags],NENOTP
        jnz     @F
        add     dx, es:[ne_stack]
        jc      leh_heapadjmin     
@@:
        mov     bx,es:[ne_autodata]  ; set if no autodata segment
        or      bx,bx                ; we have to do this here
        jz      leh_heapadjset       ; because for certain dlls
        dec     bx                   ; pautodata is not initialized
        shl     bx,1
        mov     cx,bx
        shl     bx,1
        shl     bx,1
        add     bx,cx
        add     bx,es:[ne_segtab]
        add     dx, es:[bx].ns_minalloc        
        jnc     leh_heapadjset
                
leh_heapadjmin:
                                        ; if 800h is too big fallback to
if KDEBUG                               ; what win9x code used as minimum
        mov     ax, 100h + SIZE LocalStats ; heap size 100h
else                                       
        mov     ax, 100h               
endif           
        mov     cx, es:[ne_heap]                       
        cmp     cx, ax
        jae     leh_heapadjdone
leh_heapadjset:
        mov     es:[ne_heap], ax
leh_heapadjdone:

        mov     ax,es                   ; Set owner to be itself
        cCall   FarSetOwner,<ax,ax>

        mov     dx,exetype
        test    dh,NEINFONT             ; save the font bit in exehdr
        jz      reexit                  ;  somewhere
        or      es:[ne_flags],NEWINPROT
end_fault_trap

reexit:
;       cmp     ax, 20h                 ; translate error messages for ret
;       jae     @F
;       mov     bx, ax
;       xor     ax, ax
;       cmp     bl, 1                   ; bx is 0, 1, 2, 19, other
;       jz      @F                      ; 1 -> 0 (out of memory)
;       mov     al, 11
;       jb      @F                      ; 0 -> 11 (invalid format)
;       cmp     bl, 3                   ;
;       mov     al, 10
;       jb      @F                      ; 2 -> 10 (windows version)
;       mov     al, 19                  ; 3 -> 19 (compressed EXE)
;       jz      @F                      ; others left alone
;       mov     al, bl
;@@:
        push    dx
        mov     bx, hBlock
        or      bx, bx
        je      noUnlock                ; No block to unlock
        push    ax
        cCall   IGlobalUnlock,<bx>
        push    ss
        pop     ds                      ; might be freeing DS
        cmp     fast_fail, 1            ; is fastload area invalid?
        jne     @F
leh_slow:
        krDebugOut      DEB_WARN, "FastLoad area ignored due to incorrect segment flags"
        cCall   IGlobalFree,<hBlock>    ; yes - free it, force slow-load
        mov     hBlock, 0
@@:
        pop     ax
        cmp     ax, LME_MAXERR
        jae     noFree                  ; Success, return memory block in bx
        push    ax
        cCall   IGlobalFree,<hBlock>
        pop     ax
noFree:
        mov     cx, NEFileOffset        ; Return offset of header in CX
        mov     bx, hBlock
noUnlock:
        pop     dx
        UnSetKernelDS
cEnd

sEnd    NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldfile.asm ===
TITLE	LDFILE - Loader file I/O procedures

.xlist
include kernel.inc
include newexe.inc
.list

externFP GlobalAlloc
externFP GlobalFree
externFP MyOpenFile
externFP Int21Handler

sBegin	CODE
assumes CS,CODE

externNP MyLock

;-----------------------------------------------------------------------;
; LoadNRTable								;
; 									;
; Returns the segment address of the non-resident name table.		;
; 									;
; Arguments:								;
;	parmW	hexe		exeheader to load NRTable from		;
;	parmW	fh		file handle, -1 if none 		;
;	parmD	oNRTable	if batching, this is where we left off	;
;	parmD	lpNRbuffer	if batching, this is buffer to use	;
;	parmW	cbNRbuffer	if batching, this is size of buffer	;
; 									;
; Returns:								;
;	DX:AX = pointer to non-resident table				;
;	CX:BX = if batching this is where to pick up from		;
;									;
; Error Returns:							;
;	DX:AX = NULL							;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	MyOpenFile							;
;	GlobalAlloc							;
;	MyLock								;
; 									;
; History:								;
; 									;
;  Tue 09-May-1989 18:38:04  -by-  David N. Weise  [davidw]		;
; Added the batching if out of memory.					;
;									;
;  Thu Oct 08, 1987 10:11:42p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block and fixed it for fastboot.		;
;-----------------------------------------------------------------------;

cProc	LoadNRTable,<PUBLIC,NEAR>,<si,di>
	parmW	hexe
	parmW	fh
	parmD	oNRTable
	parmD	lpNRbuffer
	parmW	cbNRbuffer

	localD	lt_ExeoNRTable		; the real offset in the Exe
	localD	lt_oNRTable
	localB	fBatching
	localB	fFirstTime
	localW	cbnrestab
	localW	pfileinfo		; used for debugging only
cBegin
	mov	cx,oNRTable.hi		; Are we batching?
	or	cx,oNRTable.lo
	or	cl,ch
	mov	fBatching,cl
	xor	di,di
	mov	fFirstTime,0

if KDEBUG
	mov	pfileinfo,di
endif
	mov	es,hexe
	mov	si,ne_nrestab
	mov	bx,fh
	mov	dx,es:[si][2]		; Get potential segment address
	mov	ax,es:[si][0]
	inc	bx			; Were we passed a file handle
	jnz	ltopen			; Yes, go read then
	mov	dx,es:[di].ne_pfileinfo ; No, then open the file
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY or OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY or OF_NO_INHERIT
endif
if KDEBUG
	mov	pfileinfo,dx
	krDebugOut <DEB_TRACE or DEB_krLoadSeg>, "Non-Res name table of @ES:DX"
endif
	regptr	esdx,es,dx
	push	dx
	push	es
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	es
	pop	dx
;;;	cmp	ax, -1
;;;	jne	@F
;;;
;;;	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
;;;	cCall	MyOpenFile,<esdx,esdx,bx>		   
;;;
;;;@@:
	mov	es,hexe
	inc	bx
	jnz	ltopen
	jmp	ltfail
ltopen:
	krDebugOut <DEB_TRACE or DEB_krLoadSeg>, "Loading %es2 Nonresident name table"
	dec	bx
	mov	dx,es:[si][0]		; AX:DX = file address of table
	mov	ax,es:[si][2]
	cmp	es:[di].ne_pfileinfo,di ; Is the NRTable in WIN200.OVL?
	jnz	lt_seek
	mov	cx,4			; Shift left AX:DX by 4.
lt_winovl:
	shl	dx,1
	rcl	ax,1
	loop	lt_winovl
lt_seek:
	mov	lt_ExeoNRTable.hi,ax
	mov	lt_ExeoNRTable.lo,dx
	cmp	fBatching,0		; Are we batching?
	jz	lt_not_batching
	mov	ax,oNRTable.hi
	mov	dx,oNRTable.lo
lt_not_batching:
	mov	lt_oNRTable.hi,ax
	mov	lt_oNRTable.lo,dx
	mov	cx,ax			; CX:DX = file address of table
	mov	ax,4200h		; Seek to beginning of the table
	DOSCALL
	jnc	@F
	jmp	ltfail
@@:	push	es
	push	bx
	cmp	fBatching,0
	jz	lt_first_time
lt_got_no_space:
	mov	es,hexe
	mov	dx,oNRTable.hi
	mov	ax,oNRTable.lo
	sub	ax,lt_ExeoNRTable.lo	; compute the bytes read so far
	sbb	dx,lt_ExeoNRTable.hi
	sub	ax,es:[di].ne_cbnrestab
	neg	ax
	cmp	ax,cbNRbuffer
	jbe	@F
	mov	ax,cbNRbuffer
@@:	mov	cbnrestab,ax

	les	di,lpNRbuffer
	mov	ax,es
	mov	dx,ax
	jmps	lt_share_your_space

lt_first_time:
	mov	fFirstTime,1		; make non-zero
	mov	ax,es:[ne_cbnrestab]	; first time through
	mov	cbnrestab,ax
	add	ax,4
	mov	bx,GA_MOVEABLE or GA_NODISCARD
	xor	cx,cx

	cCall	 GlobalAlloc,<bx,cx,ax>
	xor	dx,dx
	or	ax,ax
	jnz	lt_got_space

	mov	ax,lt_oNRTable.hi
	mov	oNRTable.hi,ax
	mov	ax,lt_oNRTable.lo
	mov	oNRTable.lo,ax
	mov	fBatching,1
	jmp	lt_got_no_space

lt_got_space:
	cCall	MyLock,<ax>
	xor	di,di
lt_share_your_space:
	pop	bx
	mov	cx,ds			; Save DS
	pop	ds
	push	cx			; after alloc
	mov	es,ax
	cmp	fBatching,0
	jnz	@F
	xor	ax,ax			; Set table loaded indicator
	xchg	ds:[si],ax
	cld
	stosw				; Save file offset
	mov	ax,dx
	xchg	ds:[si+2],ax		; Set segment handle
	stosw				; Save file offset
@@:	mov	cx,cbnrestab
	smov	ds,es
	push	dx
	mov	dx,di
	mov	ah,3Fh			; Read in the table
	DOSCALL
	pop	dx
	pop	ds
	jc	ltfail			; did the DOS call fail?
	cmp	ax,cx			; did we get all the bytes?
	jne	ltfail

	cmp	fBatching,0		; are we batching?
	jz	ltdone
	std				; truncate to whole strings
	push	bx
	xor	ax,ax
	xor	bx,bx
	mov	dx,cbNRbuffer
	dec	dx
@@:	cmp	byte ptr es:[di][bx],0	; are we at end of NRTable?
	jnz	lt_not_buffer_end
	xor	ax,ax
	mov	oNRTable.hi,ax
	mov	oNRTable.lo,ax
	jmps	lt_return_buffer
lt_not_buffer_end:
	mov	cx,bx
	mov	al,byte ptr es:[di][bx]
	add	bx,ax
	add	bx,3
	cmp	bx,dx
	jb	@B
	mov	bx,cx
	mov	byte ptr es:[di][bx],0
	add	oNRTable.lo,bx
	adc	oNRTable.hi,0
lt_return_buffer:
	pop	bx
	les	ax,lpNRbuffer
	mov	dx,es
	cmp	fFirstTime,0
	jnz	ltdone_0
	jmps	ltexit

ltdone:
	push	bx
	cCall	MyLock,<dx>
	pop	bx
	mov	dx,ax
	mov	ax,4
ltdone_0:
	mov	es,dx
	mov	si,ax
	xor	ax,ax
	mov	al,es:[si]
	add	ax,si
	add	ax,3
	jmps	ltexit
ltfail:
if KDEBUG
        push    bx
ifdef WOW
        mov     bx, hexe
        krDebugOut      DEB_ERROR, "Unable to load non-resident name table from mod #BX. "
else
        kerror  ERR_LDNRTABLE,<Unable to load non-resident name table from >,hexe,pfileinfo
;;;     kerror  ERR_LDNRTABLE,<(TRY FILES=30 to fix this) Unable to load non-resident name table from >,hexe,pfileinfo
endif
	pop	bx
endif
	xor	ax,ax
	xor	dx,dx

ltexit: cmp	bx,fh
	je	ltx1
	push	ax
	mov	ah,3Eh
	DOSCALL
	pop	ax
ltx1:
	mov	cx,oNRTable.hi
	mov	bx,oNRTable.lo
	cld				; we'll be polite
cEnd


;
; GetStringPtr( hExe, offset ) - Procedure to return the far address of a
; string in the passed new EXE file's string table
;
cProc	GetStringPtr,<PUBLIC,NEAR>,<si,di>
	parmW	hExe
	parmW	fh
	parmW	soffset
cBegin
	mov	es,hExe
	mov	dx,es
	mov	ax,es:[ne_imptab]
	add	ax,soffset
cEnd


; FreeNRTable( lptable ) - Procedure to free table allocated by LoadNRTable
; and restore the new EXE header information.

cProc	FreeNRTable,<PUBLIC,FAR>,<si,di>
	parmW	hexe
	parmW	tblid
cBegin
	mov	es,hexe
	mov	di,tblid
	xor	ax,ax
	mov	cx,es:[di+2]
	cmp	word ptr es:[di],0
	jne	lfexit
	jcxz	lfexit
	push	cx
	cCall	MyLock,<cx>
	pop	cx
	mov	es,hexe
	push	ds
	mov	ds,ax
	xor	si,si
	cld
	movsw
	movsw
	pop	ds
	cCall	GlobalFree,<cx>
lfexit:
cEnd

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldint.asm ===
TITLE   LDINT - Loader interrupt procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include	protect.inc
include dbgsvc.inc
include bop.inc
include	kdos.inc
include gpcont.inc	; SHERLOCK
ifdef WOW
include vint.inc
include softpc.inc
endif

NOTEXT		= 1
NOGDICAPMASKS	= 1
NOMB		= 1
NOVK		= 1
NOWH		= 1
NOMST		= 1
NORASTOPS	= 1
NOMETAFILE	= 1
NOMDI		= 1
NOWINMESSAGES	= 1
NOSYSMETRICS	= 1
NOCOLOR		= 1
NOCOMM		= 1
NOKERNEL	= 1

include	windows.inc		; YIKES!!!

.list

FAULTSTACKFRAME struc

fsf_BP		dw	?	; Saved BP
fsf_msg		dw	?	; Near pointer to message describing fault
fsf_prev_IP	dw	?	; IP of previous fault handler
fsf_prev_CS	dw	?	; CS of previous fault handler
fsf_ret_IP	dw	?	; DPMI fault handler frame follows
fsf_ret_CS	dw	?
fsf_err_code	dw	?
fsf_faulting_IP dw	?
fsf_faulting_CS dw	?
fsf_flags	dw	?
fsf_SP		dw	?
fsf_SS		dw	?

FAULTSTACKFRAME ends

fsf_OFFSET = fsf_ret_IP - fsf_msg

UAE_STRING_LEN	equ	192d
MIN_SP		equ	256d

externFP ExitKernel


DataBegin

;externB syserr
externB	szAbort
externB szAbortCaption
externB szNukeApp
externB szWillClose
externB szBlame
externB szSnoozer
externB szInModule
externB szAt
externB szII
externB szGP
externB szSF
externB szNP
externB	szLoad
;externB szDiscard
externB szPF
externB Kernel_Flags
externB fBooting
externW curTDB
;externW pGlobalHeap
externW DemandLoadSel
externD	pSErrProc
externD pUserGetFocus
externD pUserGetWinTask
externD pUserIsWindow
externD	lpGPChain

if kdebug
globalw	wFaultSegNo,0
endif

if ROM
externD  prevIntx6proc
externD  prevInt0Cproc
externD  prevInt0Dproc
externD  prevInt0Eproc
externD  prevInt3Fproc
endif

if KDEBUG
staticW INT3Fcs,0
endif

globalW	FaultHandler,<codeOffset HandleFault>

externD  pPostMessage

ifdef WOW
externD FastBop
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
externW DebugWOW
externW gdtdsc

endif

DataEnd

sBegin	DATA
externW gmove_stack
externW TraceOff
sEnd    DATA

sBegin	CODE
assumes CS,CODE

if SHERLOCK
externNP GPContinue
endif

ife ROM
externD  prevIntx6proc
externD  prevInt0Cproc
externD  prevInt0Dproc
externD  prevInt0Eproc
externD  prevInt3Fproc
endif

externNP LoadSegment
;externNP MyLock

ifndef WOW
externNP htoa
endif

externNP GetOwner
externNP GetPureName
externNP TextMode
externNP Int21Handler
	    
;externNP DebugPostLoadMessage
externFP GlobalLRUNewest
externFP GlobalHandleNorip
externFP HasGPHandler
externFP AllocSelector
externFP IFreeSelector

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
Entry   macro name
    public name
    align 2
    name&:
    endm
endif

;-----------------------------------------------------------------------;
; Display_Box_of_Doom -- Display the Unrecoverable Application Error
;			 box that everyone seems to dislike so much.
;
; Entry:
;	Action		Reserved, must be zero
;	lpText		String to display, NULL for default
;
; Returns:
;	AX = 1		Cancel
;	AX = 2		OK
;
; Registers Destroyed:
;	AX, BX, CX, DX, SI, DI
;
; History:
;  Thu 16-May-1991 -by- Earle R. Horton
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Display_Box_of_Doom,<PUBLIC,NEAR>

	parmW	action
	parmD	lpText
cBegin
	SetKernelDS
if KDEBUG
	xor	bx,bx
	or	action,bx
	jz	@F
	kerror	00FFh,<Action not 0 in FatalAppExit>,bx,bx
@@:
endif
	push	es			; added 10 feb 1990
	mov	es,curTDB		; did app disable exception
	test	es:[TDB_ErrMode],02h	;  message box?
	pop	es
	jnz	nf_dont_ask

	cmp	pSErrProc.sel, 0	; Can we put up message box?
	jnz	short nf_ask		;   yes, do it
					;   no, have debugger?
nf_dont_ask:
	mov	ax,1
	test	Kernel_Flags[2],KF2_SYMDEB
	jnz	nf_ret			;     yes, call debugger
	inc	ax
	jmps	nf_ret			;     no, have to nuke the app

nf_ask:	 	
	push	es
	mov	ax,lpText.sel
	or	ax,ax
	jz	nf_default_string
	push	ax
	push	lpText.off
	jmps	nf_pushed_string

nf_default_string:
	push	ds
	mov	ax,dataOffset szAbort	; lpText
	push	ax

nf_pushed_string:
	push	ds			; lpCaption
	mov	ax, dataOffset szAbortCaption
	push	ax

	xor	ax,ax		; Assume no debugger, blank first button
	mov	cx,ax
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F				; No
	mov	cx,SEB_CANCEL			; Yes, use Cancel button
@@:
	push	cx
;	push	SEB_OK+SEB_DEFBUTTON
	push	SEB_CLOSE + SEB_DEFBUTTON
	push	ax

	call	ds:[pSErrProc]		; Put up the system error message
	pop	es

nf_ret:

cEnd

;-----------------------------------------------------------------------;
; FatalAppExit -- Called by apps. to request an application error
;		  message box.
;
; Entry:
;	Action		Reserved, must be zero
;	lpText		String to display, NULL for default
;
; Returns:
;	Returns to caller if Cancel button pressed
;
; Registers Destroyed:
;
; History:
;  Sun 22-Oct-1989 15:18:57  -by-  David N. Weise  [davidw]
; Tonyg wrote it!
;  Fri 24-May-1991 EarleH totally rewrote it, so there!
;  
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	IFatalAppExit,<PUBLIC,FAR>

	parmW	action
	parmD	lpText
cBegin

	cmp	seg_lpText,0
	jne	fae_string
	mov	off_lpText,offset szAbort
	mov	seg_lpText,seg szAbort
fae_string:
	cCall	Display_Box_of_Doom,<action,lpText>
	cmp	ax,1			; Cancel pressed?
	je	fae_ret
	jmp	KillApp
fae_ret:
cEnd

; ------------------------------------------------------------------
;
; FormatFaultString -- Special purpose "sprintf()"
;	Only used for the Box of Doom
;
; ------------------------------------------------------------------

cProc	FormatFaultString,<PUBLIC,NEAR>,<si,di,ds,es>
	parmD	lpstr
	parmW	pStr			; Assumed in Kernel's DS
	parmD	csip
cBegin
	SetKernelDS
	cld
	les	di, lpstr		; Form string in ES:DI
	call	CurApName
	lea	si, szSnoozer		; " has caused an error in Windows"
	call	strcpy
	mov	si, pStr		; Copy the fault string
	call	strcpy
	lea	si, szInModule		; "in Module: <unknown>"
	call	strcpy

	push	es
	push	di

	cCall	GetOwner,<seg_csip>	; Can we find a module to blame?
	or	ax, ax
	jz	NoOwner
	mov	es, ax
	cmp	es:[ne_magic], NEMAGIC
	jne	NoOwner
	
	mov	bx, seg_csip		; Have the module, can we get the
	and	bl, not SEG_RING	; segment number?
	mov	di,es:[ne_segtab]
	mov	ax,1   
	mov	cx, es:[ne_cseg]
getsegno:	    
	mov	dx, es:[di].ns_handle
	and	dl, not SEG_RING
	cmp	dx, bx
	jz	gotsegno
	add	di,SIZE NEW_SEG1
	inc	ax
	loop	getsegno
	jmps	nosegno			; No, report the selector instead
gotsegno:
	mov	seg_csip, ax		; Print Segment #
nosegno:						       	
      
	mov	di, es:[ne_pfileinfo]	; Now blame the module
	add	di, opFile
	call	GetPureName
	mov	si, di
	smov	ds, es
	UnSetKernelDS
	pop	di
	pop	es
ifdef FE_SB
find_space:
	cmp	byte ptr es:[di-1],' '		; prepare space before mod name
	jz	copy_name
	dec	di
	jmps	find_space
copy_name:
else ; !FE_SB
	sub	di, 9			; Get rid of <unknown>
endif ; !FE_SB

	call	strcpy
	SetKernelDS
	jmps	GotOwner
	
NoOwner:
	pop	di
	pop	es
GotOwner:
	lea	si, szAt
	call	strcpy
ifdef WOW
	cCall	<far ptr Far_htoa>,<es,di,seg_csip>
else
	cCall	htoa,<es,di,seg_csip>
endif
	mov	di, ax
	mov	es, dx
	mov	byte ptr es:[di], ':'
	inc	di
ifdef WOW
	cCall	<far ptr Far_htoa>,<es,di,off_csip>
else
	cCall	htoa,<es,di,off_csip>
endif
	mov	es, dx
	mov	di, ax
	lea	si, szNukeApp
	call	strcpy
	call	CurApName
	lea	si, szWillClose
	call	strcpy
cEnd

CurApName proc	near
	SetKernelDS
	lea	si, szBlame		; Default task to blame
	cmp	curTDB, 0		; Have a task to blame?
	je	DefaultCaption		; nope, use default
	mov	ds, curTDB
	UnSetKernelDS
	mov	si, TDB_ModName
DefaultCaption:
	mov	cx, 8
copy_appname:
	lodsb
	stosb
	or	al, al			; Null padded in TDB
	loopne	copy_appname
	jne	no_null
	dec	di 			; Toss extra space
no_null:

	SetKernelDS
	ret
CurApName endp

	public	strcpy
strcpy	proc	near
	lodsb
	stosb
	or	al, al
	jnz	strcpy
	dec	di			; Ignore Null
	ret
strcpy	endp

;-----------------------------------------------------------------------;
;
; KillApp -- Calls USER to tell it that the application is going away,
; 	     then tells DOS to kill it.
;
; ENTRY: None
; EXIT: None, doesn't
;
; Registers modified: Huh?
;
;-----------------------------------------------------------------------;

KillApp proc near

	SetKernelDS

                test    fBooting, 1
                jz      @F

	mov	ax, 1
	cCall	ExitKernel,<ax>

@@:	mov	ax,4CFFH		; They said OK to Nuke app.
	DOSCALL

	UnSetKernelDS
KillApp endp

;-----------------------------------------------------------------------;
; FaultFilter -- Called by HandleFault, NestedFault, and routines that
; use the same stack frame.  Look at the faulting CS:IP on the exception
; handler frame, and make sure that CS is Ring 3, LDT.  If it is not
; pop the near return address from the stack and chain the exception
; to the next handler.  This will be the DPMI server, which will crash
; Windows back to DOS.  We ought to try to close up a few things first.
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	FaultFilter
FaultFilter	proc	near


    mov al,byte ptr [bp].fsf_faulting_CS
	and	al, SEG_RING_MASK		; Check it was Ring 3, LDT
	cmp	al, SEG_RING

	je	@F
;
; The faulting CS's ring bits do not match up.  We will not handle
; this fault, because we assume it happened in the DPMI provider,
; and is a Real Bad one.  Since the default handler is going to
; abort here, it would be nice to let the user down real easy.
; Restoring the display to text mode would be nice, at the very
; minimum.
;
	cCall	TextMode
	ret					; Hypocrite!
@@:
;
; Check for faults on POP FS and POP GS. If found, fix them up. We need to
; fix up faults in the register restoration of both KRNL386 (WOW16Return) and
; MMSYSTEM (MULTI_MEDIA_ISR386). Monty Pythons Complete Waste of Time is an app
; which frees selectors in FS across message boundries.
;
ifdef WOW
        push    ds
        mov     ax, word ptr [bp].fsf_faulting_CS
        mov     ds, ax
        mov     si, word ptr [bp].fsf_faulting_IP
        cmp     word ptr [si], 0A10Fh  ; pop  fs
        je      HandFSGSflt
        cmp     word ptr [si], 0A90Fh  ; pop  gs
        je      HandFSGSflt
        jmp short NoFSGSflt
HandFSGSflt:
if KDEBUG
    Trace_Out "POP GS/FS fault fixed up!"
endif
        mov     ds, [bp].fsf_SS
        mov     si, [bp].fsf_SP
        mov     word ptr [si], 0
        pop     ds                      ; restore kernel DS
        pop     ax                      ; don't do EH_Chain
        push    codeOffset EH_ret       ; use "handled it" return instead
        ret
NoFSGSflt:
        pop     ds
endif

    pop ax              ; toss chain return
	push	codeOffset EH_ret		; use "handled it" return

	mov	si,word ptr FaultHandler	; SI = Handler
	push	si
	mov	word ptr FaultHandler,codeOffset NestedFault

if KDEBUG
	test	byte ptr [bp].fsf_flags+1,2	; IF set in faulting frame?
	jnz	@F
	Trace_Out "Fault with interrupts disabled!"
@@:
endif
	cmp	[bp].fsf_SP,128d
	jb	ff_stack

	cCall	HasGPHandler, <[bp].fsf_faulting_CS, [bp].fsf_faulting_IP>
	or	ax, ax
	jz	ff_real_fault
	mov	ds, [bp].fsf_SS
	mov	bx, [bp].fsf_SP
	sub	[bp].fsf_SP, 4
	mov	cx, [bp].fsf_err_code		; put error code on stack
	mov	[bx-2],cx
	mov	dx, [bp].fsf_faulting_IP
	mov	[bx-4],dx			; and faulting IP
	mov	[bp].fsf_faulting_IP, ax	; continue at gp fault handler
	jmps	ff_ret

ff_real_fault:

ifdef WOW
        test    DebugWOW,DW_DEBUG
        jz      ff_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_GPFAULT2

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     ff_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

        ; Otherwise, they chose to continue the exception

ff_no_wdebug:

endif

if	SHERLOCK
	cCall	GPContinue			; We know BP points to
	or	ax, ax				; the fault frame!
	jnz	ff_ret
endif

ff_stack:
	call	si				; call our fault handler

ff_ret:
	SetKernelDS
	pop	FaultHandler
	ret
FaultFilter     endp

ifdef WOW
;-----------------------------------------------------------------------;
;
; single_step
;
;-----------------------------------------------------------------------;
Entry single_step
        push    ds
        SetKernelDS ds

        push    ax

; QCWIN traces through code which it has no source code for.  This means
; its ends up tracing through the 16-bit to 32-bit transition code and
; when it traces on the call fword instruction, it cause  32-bit trace
; interrupt which breaks into the kd>  On a retail build with no
; debugger attached, it might work.
; To work around the problem we turn off the TraceFlag here if wow16cal
; has requested it.

        test    TraceOff,1h
        jnz     ss_turn_off_trace_flag

        test    DebugWOW,DW_DEBUG
        jz      ss_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_SINGLESTEP

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     ss_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

ss_no_wdebug:

        ; Otherwise, they chose to continue the exception
        pop     ax
        pop     ds
        jmp     cs:[prevInt01proc]


; Tell api code (wow16cal) to turn on trace flag at end of next api

ss_turn_off_trace_flag:
        sub     sp,2                    ; Make it look like "normalized" fault frame
	push	bp
	mov	bp,sp
        or      TraceOff,2h
        and     [bp].fsf_flags,NOT FLG_TRAP     ; turn off the trap flag
        pop     bp
        add     sp,2
ss_ret:
        pop     ax
        pop     ds
        UnSetKernelDS ds
        retf







;-----------------------------------------------------------------------;
;
; breakpoint
;
;-----------------------------------------------------------------------;
Entry breakpoint
        push    ds
        SetKernelDS ds
        push    ax

        test    DebugWOW,DW_DEBUG
        jz      br_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_BREAK

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     bp_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

br_no_wdebug:

        ; Otherwise, they chose to continue the exception
        pop     ax
        pop     ds
        jmp     cs:[prevInt03proc]

bp_ret:
        pop     ax
        pop     ds
        UnSetKernelDS ds
        retf

;-----------------------------------------------------------------------;
;
; divide_overflow
;
;-----------------------------------------------------------------------;
Entry divide_overflow
        push    ds
        SetKernelDS ds
        push    ax

        test    DebugWOW,DW_DEBUG
        jz      di_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_DIVOVERFLOW


	FBOP BOP_DEBUGGER,,FastBop
.286p
        add     sp,+2
        or      ax, ax

        jnz     do_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

di_no_wdebug:

        ; Otherwise, they chose to continue the exception
        pop     ax
        pop     ds
        jmp     cs:[oldInt00proc]

do_ret:
        pop     ax
        pop     ds
        UnSetKernelDS ds
        retf


endif

;-----------------------------------------------------------------------;
;
; Set_GO_BP
;
;-----------------------------------------------------------------------;
	public	Set_GO_BP
Set_GO_BP proc near
	mov	cx, [bp].fsf_faulting_CS	; Faulting CS
	mov	bx, [bp].fsf_faulting_IP	; Faulting IP
	DebInt	40h
;	mov	ax, 40h				; 16 bit forced go command
;	int	41h				; Call debugger
;ifdef	JAPAN
;	INT41SIGNATURE
;endif
	ret
Set_GO_BP endp

;-----------------------------------------------------------------------;
;
; ExitFault -- Fault at Exit Time!!!
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	ExitFault
ExitFault	proc	near
if KDEBUG
	Trace_Out "Fault at Exit Time!!!"
endif
;
; If a kernel debugger is loaded, pop out at the nested fault, and
; take no prisoners.
;
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	jmp	Set_GO_BP
@@:
	jmps	HandleFault
ExitFault	endp

	public	BUNNY_351
BUNNY_351	proc	far
	push	ds
	SetKernelDS
	mov	FaultHandler,codeOffset ExitFault
	pop	ds
	ret
BUNNY_351	endp

;-----------------------------------------------------------------------;
;
; MY_RETF -- Executes a far return.
;
;-----------------------------------------------------------------------;

MY_RETF proc near
	retf
MY_RETF	endp

;-----------------------------------------------------------------------;
;
; NestedFault -- Called when a fault handler Faults!!!
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	NestedFault
NestedFault	proc	near
if KDEBUG
	Trace_Out "Nested Fault!!!"
endif
;
; If a kernel debugger is loaded, pop out at the nested fault, and
; take no prisoners.
;
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	jmp	Set_GO_BP
@@:
	jmps	HandleFault
NestedFault	endp

;-----------------------------------------------------------------------;
;
; HandleFault -- Puts up the System Error box for a Fault.  Terminates
;		 the application or enters the debugger.
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.  If Cancel is pressed, we tell
;		WDEB to set a GO breakpoint at the faulting instruction
;		first.  If OK is pressed, then the CS:IP on the DPMI
;		fault frame is modified to point to KillApp, and the
;		SS:SP points to a temp. stack owned by Kernel.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	HandleFault
HandleFault	proc	near

	mov	ax, lpGPChain.sel	; Do we have a private GP handler?
	mov	lpGPChain.sel, 0	; Prevent re-entrancy
	cmp	ax, [bp].fsf_SS
	jnz	We_Can_Handle_It

	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	mov	lpGPChain.sel,ax

	jmp	Set_GO_BP
@@:
					; If we want to chain back for any
	mov	bx, lpGPChain.off	; faults, then set up the stack of
	mov	[bp].fsf_SP, bx		; the handler, and continue execution
	mov	[bp].fsf_faulting_CS, cs ; at a RETF in Kernel
	mov	[bp].fsf_faulting_IP, offset MY_RETF

	cmp	[pPostMessage.sel],0	; is there a USER around yet?
	je	@F
	pusha
	push	es
	cCall	[pPostMessage],<-1,WM_SYSTEMERROR,1,0,0>
	pop	es
	popa
@@:

if kdebug
	mov	es, ax
	mov	ax, es:[bx+2]
	mov	bx, es:[bx]
	krDebugOut DEB_ERROR, "Fault detected - handled by %AX2 #AX:#BX"
endif

	jmp	HandleFault_Exit

We_Can_Handle_It:
	sub	sp, UAE_STRING_LEN	; Room for string
	mov	si, sp

	cCall	FormatFaultString,<ss,si,[bp].fsf_msg,[bp].fsf_faulting_CS,[bp].fsf_faulting_IP>

	push	bp
	xor	bp,bp			; Some people are picky...
	cCall	Display_Box_of_Doom,<0,ss,si>
	pop	bp

	add	sp, UAE_STRING_LEN

	or	ax, ax
	jne	@F
	INT3_DEBUG			; Failed call - no USER
@@:
	cmp	ax, 1			; Button 1 (Cancel) pressed?
	jne	@F
	jmp	Set_GO_BP
@@:

                test    fBooting, 1             ; No, they said to Nuke app.
                jnz     no_signal_proc

	mov	ds, curTDB

	UnSetKernelDS

	cmp	ds:[TDB_USignalProc].sel,0
	jz	no_signal_proc
	mov	bx,0666h
	mov	di, -1

	cCall	ds:[TDB_USignalProc],<ds,bx,di,ds:[TDB_Module],ds:[TDB_Queue]>

;
; Since we are on a nice big fat juicy fault handler stack now, we can call
; Windows to clean up after the task.
;
	mov	bx,SG_EXIT
	cCall	ds:[TDB_USignalProc],<ds,bx,di,ds:[TDB_Module],ds:[TDB_Queue]>
	mov	ds:[TDB_USignalProc].sel,0

no_signal_proc:

	mov	[bp].fsf_SP,dataOffset gmove_stack
	mov	[bp].fsf_SS,seg gmove_stack
	mov	[bp].fsf_faulting_CS,cs

	lea	ax,KillApp
	mov	[bp].fsf_faulting_IP,ax
HandleFault_Exit:
	ret

HandleFault endp

; ------------------------------------------------------------------
;
; ExceptionHandlerProc -- Common entry point for exception handlers
;
; ------------------------------------------------------------------
	public	ExceptionHandlerProc
ExceptionHandlerProc proc far

	push	bp
	mov	bp,sp
	pusha
	push	ds
	SetKernelDS
	push	es
EH_Popup:
	call	FaultFilter
EH_Chain:
	pop	es
	pop	ds
	UnsetKernelDS
	popa
	pop	bp
	add	sp,2			; remove message from stack
	retf				; chain to prev handler
EH_ret:
	pop	es
	pop	ds
	popa
	pop	bp
	add	sp,fsf_OFFSET
	retf

ExceptionHandlerProc endp


; ------------------------------------------------------------------
;
; This macro sets up the stack frame for entry to the generic
; exception handler.
;
; ------------------------------------------------------------------
ExceptionHandlerPrologue	macro name,msg,chain
	public	name
name:
if ROM
	sub	sp,6
	push	bp
	push	ds
	push	ax
	mov	bp,sp
	SetKernelDS
	mov	word ptr [bp+6],offset msg
	mov	ax, word ptr [chain][0]
	mov	[bp+8],ax
	mov	ax, word ptr [chain][2]
	mov	[bp+10],ax
	UnsetKernelDS
	pop	ax
	pop	ds
	pop	bp
else
	push	word ptr chain + 2
	push	word ptr chain
	push	offset msg
endif
endm

; ------------------------------------------------------------------
;
; This macro sets up the stack frame, then jumps to the generic
; exception handler.
;
; ------------------------------------------------------------------
ExceptionHandler	macro name,msg,chain
	ExceptionHandlerPrologue	name,msg,chain
	jmp	ExceptionHandlerProc
	assumes	ds, nothing
	assumes	es, nothing
endm

; ------------------------------------------------------------------
;
; Four fatal ones.
;
; ------------------------------------------------------------------
	ExceptionHandler	StackFault,szSF,prevInt0Cproc
	ExceptionHandler	GPFault,szGP,prevInt0Dproc
	ExceptionHandler	invalid_op_code_exception,szII,prevIntx6proc
	ExceptionHandler	page_fault,szPF,prevInt0Eproc
        ExceptionHandler        LoadSegFailed,szLoad,prevInt3Fproc

; ------------------------------------------------------------------
;
; The not present fault is used to demand-load segments from newexe
; files.  If we find out that something bogus has happened, then
; we just jump into the fault handler.
;
; ------------------------------------------------------------------
	ExceptionHandlerPrologue SegmentNotPresentFault,szNP,prevInt3Fproc
	
	push	bp
	mov	bp,sp
	pusha
	push	ds
	SetKernelDS
	push	es

	mov	al,byte ptr [bp].fsf_faulting_CS
	and	al, SEG_RING_MASK		; Check it was Ring 1, LDT
	cmp	al, SEG_RING
	
	je	@F
	jmp	EH_Chain
@@:
	mov	al,byte ptr [bp].fsf_err_code
	test	al, SEL_LDT			; Check it was LDT
	
	jne	@F
	jmp	EH_Chain
@@:

if KDEBUG
	test	byte ptr [bp].fsf_flags+1,2	; IF set in faulting frame?
	jnz	@F
	Trace_Out "Segment not present fault with interrupts disabled!"
@@:
endif
        FSTI
;
; Don't discard the segment that we have to return to!!!
;
	cCall	GlobalHandleNorip,<[bp].fsf_faulting_CS>
	test	cl,GA_DISCARDABLE
	jz	@F	
	cCall	GlobalLRUNewest,<ax>
@@:

	mov	bx,[bp].fsf_err_code
seg_reload:
	and	bx, NOT 7h		; get the not present selector
	or	bl, SEG_RING		; Correct RING bits
if KDEBUG
	mov	INT3Fcs, bx		; Save in case of error
endif

if PMODE32
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	es,cs:gdtdsc
	mov	cx,bx			; save bx
	and	bl, not 7
	mov	es,es:[bx].dsc_owner
	mov	bx,cx			; restore
else
	lsl	cx, bx	 		; mov es,[bx].he_owner
	mov	es, cx
endif
	StoH	bl			; Need handle

	cmp	es:[ne_magic],NEMAGIC	; If owner is not a module
	jnz	bad_seg_load		; (i.e., an instance or garbage)
					; get out of here.
	mov	di,es:[ne_segtab]
	mov	ax,1
	mov	cx, es:[ne_cseg]
	jcxz	bad_seg_load
dorten:
	cmp	es:[di].ns_handle,bx
	jz	got_seg_no
	add	di,SIZE NEW_SEG1
	inc	ax
	loop	dorten

; program has referenced garbage...

bad_seg_load:
	jmp	EH_Popup

got_seg_no:

;
; If we already are on the exception handler stack, then we want to make
; sure that we don't overwrite the original stack frame.  Copy our
; stack frame variables down by the difference between SP and SP before
; we got called.
;
	push	ax
	mov	ax,ss
	cmp	ax,word ptr [bp].fsf_SS
	pop	ax
	jne	stack_OK
	push	ax
	push	bx
	push	bp
	lea	bp,word ptr [bp].fsf_SS
	mov	ax,sp
	dec	ax
	dec	ax
@@:
	push	word ptr [bp]
	dec	bp
	dec	bp
	cmp	bp,ax
	jne	@B
	pop	bp
	pop	bx
	pop	ax
;
; Figured out what this was supposed to be by tracing up to here
; in the debugger.
;
	sub	bp,32h

stack_OK:
	push	es
	mov	bx,ax
	UnsetKernelDS
	mov	ax,ss
	mov	ds,ax
	les	di,dword ptr [bp].fsf_SP
	dec	di
	dec	di
	std
;
; Push an IRET frame on the faulting stack.
;
	lea	si,[bp].fsf_flags
	mov	cx,3
	rep	movsw
;
; Push our saved registers on the faulting stack.
;
	lea	si,[bp]
	mov	cx,11		; BP + PUSHA + ES + DS
	rep	movsw

	pop	ax
;
; Push arguments to LoadSegment on the faulting stack.
;
	stosw			; hExe
	mov	ax,bx
	stosw			; segno
	mov	ax,-1
	stosw
	stosw
	inc	di
	inc	di
;
; Point the faulting stack at the new location.
;
	mov	[bp].fsf_SP,di
;
; Tell DPMI to return to us instead of the faulting code.
;
	mov	[bp].fsf_faulting_CS,cs
	mov	[bp].fsf_faulting_IP,offset let_them_do_it
	lea	sp,[bp].fsf_ret_IP

if kdebug
	SetKernelDS
	mov	wFaultSegNo, bx
	UnSetKernelDS
endif
	retf
let_them_do_it:
	SetKernelDS

	xor	cx, cx			; we try to keep a selector reserved
	xchg	cx, DemandLoadSel	;   for scratch use while demand
	jcxz	@f			;   loading segments--free it to make
	cCall	IFreeSelector,<cx>	;   it available now
@@:
	cCall	LoadSegment

	push	ax			; reserve a selector for the next
        cCall   AllocSelector,<0>      ;   time we demand load a segment
	mov	DemandLoadSel, ax
	pop	cx			; LoadSegment result
	jcxz	SegLoaderFailure

if kdebug
	push	bx
	mov	bx, wFaultSegNo
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "Demand load %CX2(#bx) on %SS2"
	pop	bx
endif
	pop	es
	pop	ds
	UnsetKernelDS
	popa
	pop	bp

        ;** Check to see if we're about to restart an instruction in
        ;**     a not present segment.  This would only occur if the
        ;**     segment was discarded because of the segment load we
        ;**     just did.
IF KDEBUG
        push    bp              ;Make a stack frame
        mov     bp,sp
        push    ax
        mov     bp,[bp + 4]     ;Get the CS
        lar     ax,bp           ;See if the CS is valid
        test    ax,8000h        ;Is it present?
        jnz     @F              ;Yes, don't complain
	mov	ax,bp
        Trace_Out <'LDINT: Trying to restart discarded caller (#AX)'>
@@:
        pop     ax
        pop     bp
ENDIF
	iret

	public	SegLoaderFailure
SegLoaderFailure	proc near
;
; segment loader was unable to load the segment!!!
; Restore all the registers, create a fake DPMI frame, then
; complain about the problem.  Lets the user break into the
; debugger, if installed, on Cancel.  Creating and destroying
; the fake DPMI frame is inconvenient and messy, but it lets
; us handle the problem in common fault code.
;
	pop	es
	pop	ds
	UnsetKernelDS
	popa

	sub	sp,4
	mov	bp,sp			; BP -> xx xx BP IP CS FL
	push	word ptr [bp+4]		; push app's BP
	push	ax			; get a temporary register
	mov	ax,[bp+6]		; IP
	mov	[bp+2],ax
	mov	ax,[bp+8]		; CS
	mov	[bp+4],ax
	mov	ax,[bp+10]		; Flags
	mov	[bp+6],ax
	mov	[bp+10],ss
	lea	ax,[bp+12]
	mov	[bp+8],ax
	pop	ax
	pop	bp	
	
	call	far ptr LoadSegFailed	; BP -> RETIP RETCS EC IP CS FL SP SS

	push	bp
	mov	bp,sp			; BP -> BP EC IP CS FL SP SS
	mov	[bp+2],ax
	mov	ax,[bp+8]		; Flags
	mov	[bp+12],ax
	mov	ax,[bp+6]		; CS
	mov	[bp+10],ax
	mov	ax,[bp+4]		; IP
	mov	[bp+8],ax
	pop	bp
	pop	ax
	add	sp,4
	iret

SegLoaderFailure	endp

;ENDIF

;-----------------------------------------------------------------------;
; default_sig_handler
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:32:34  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	default_sig_handler,<PUBLIC,FAR>

cBegin nogen

	ret

cEnd nogen

;-----------------------------------------------------------------------;
;
; Panic -- Called by ToolHelp when it gets a bad stack fault or any
;	   other fault with SP suspiciously low.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Panic,<PUBLIC,NEAR>
cBegin
if KDEBUG
	Trace_Out "KERNEL: Panic called!!!"
endif
	int	1
	jmp	KillApp
cEnd

;-----------------------------------------------------------------------;
; DoSignal
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:52:52  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DoSignal,<PUBLIC,FAR>,<ax,bx,cx,dx,di,si,es>
cBegin
	SetKernelDS
	cmp	pUserGetFocus.sel,0	; is there a USER yet?
	jz	ds_exit
	call	pUserGetFocus
	or	ax,ax
	jz	ds_exit
	mov	si,ax
	cCall	pUserIsWindow,<ax>
	or	ax,ax
	jz	ds_exit
	cCall	pUserGetWinTask,<si>
	mov	ds,ax
	TDB_check_DS
	cmp	ds:[TDB_SigAction],2	; send it on?
	jnz	ds_exit
	mov	ax,1
	xor	bx,bx
	cCall	ds:[bx].TDB_ASignalProc,<bx,ax>
ds_exit:

cEnd



sEnd	CODE

sBegin MISCCODE
assumes	cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

ifdef WOW
externFP htoa

	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
; allows htoa to be called from _TEXT code segment
cProc	Far_htoa,<PUBLIC,FAR>
    parmD   lpstr
    parmW   val
cBegin
    push    [bp+10]
    push    [bp+8]
    push    [bp+6]
    call    far ptr htoa
cEnd

endif  ;; WOW


;-----------------------------------------------------------------------;
; SetSigHandler
;
; SetSigHandler notifies Windows of a handler for a signal.
; It may also be used to ignore a signal or install a default
; action for a signal.
;
; Entry:
;	parmD	lpprocRoutine	Signal handler
;	parmD	lpDPrevAddress	Previous handler (returned)
;	parmD	lpWPrevAction	Previous action (returned)
;	parmW	Action		Indicate request type
;	parmW	SigNumber	Signal number of interest
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 25-Dec-1989 00:36:01  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	SetSigHandler,<PUBLIC,FAR>,<di,si,ds>

	parmD	lpprocRoutine
	parmD	lpDPrevAddress
	parmD	lpWPrevAction
	parmW	Action
	parmW	SigNumber
cBegin
	call	MISCMapDStoDATA
	ReSetKernelDS
	cmp	SigNumber,1		; is it SIGINTR?
	jnz	dssh_return_success	;  ignore if not

	cmp	Action,4		; is it reset Signal?
	jz	@F

	push	ds
	mov	ds,curTDB
	assumes ds,nothing
	mov	ax,Action
	xchg	ax,ds:[TDB_SigAction]
	les	bx,lpWPrevAction
	mov	cx,es
	or	cx,bx
	jz	@F
	mov	es:[bx],ax
@@:
	mov	dx,lpprocRoutine.sel
	mov	ax,lpprocRoutine.off
	cmp	Action,0		; put in default handler?
	jnz	ssg_stick_it_in
	mov	dx,SEG default_sig_handler
	mov	ax,codeOffset default_sig_handler
ssg_stick_it_in:
	xchg	dx,ds:[TDB_ASignalProc].sel
	xchg	ax,ds:[TDB_ASignalProc].off
	cmp	Action,4		; is it reset Signal?
	jz	@F
	les	bx,lpDPrevAddress
	mov	cx,es
	or	cx,bx
	jz	@F
	mov	es:[bx].sel,dx
	mov	es:[bx].off,ax
	pop	ds
@@:

dssh_return_success:
	xor	ax,ax			; return success

dssh_exit:

cEnd

;----------------------------------------------------------------------------
;
;  SwapRecording(Flag)
;
;	Flag = 0  => Stop recording
;	     = 1  => Start recording only Swaps, Discards and Returns
;	     = 2  => Start recording Calls in addition to Swaps, Discards and 
;				returns.
;  Destroys AL register
;----------------------------------------------------------------------------

; Retail Version

cProc  ISwapRecording,<PUBLIC, FAR>
;	parmW  Flag
cBegin nogen
	retf  2
cEnd nogen

sEnd MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldseg.asm ===
TITLE   LDSEG - SegAlloc procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc             ; Handle_To_Sel
.list

NSHUGESEG       = NSKCACHED             ; not first seg of huge segment
; A huge segment (data object larger than 64K) requires more than one
; selector, but is part of a single memory allocation block.  The first
; selector is a handle, like any other segment.  Subsequent selectors of
; the huge memory block are _not_ handles, so we can't call MyLock() on
; them, as the consistency check will fail.  We mark these selectors with
; the NSHUGESEG bit in the flags word.  TonyG suggested this.
; Note that data segments are already loaded, locked, etc, so the call to
; MyLock is redundant anyway.
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;



externFP IGlobalFree
externFP IGlobalAlloc
externFP IGlobalReAlloc
externFP IGlobalLock
externFP MyOpenFile
externFP FlushCachedFileHandle
externFP Int21Handler
externFP set_discarded_sel_owner
externFP GetPatchAppRegKey
externFP PatchAppSeg

if KDEBUG
externFP OutputDebugString
endif

if ROM
;externNP SetROMOwner
externFP FarSetROMOwner
externFP ChangeROMHandle
externFP AllocSelector
externFP IFreeSelector
externNP CloneROMSelector
externFP LZDecode
endif

DataBegin

externB  Kernel_flags
;externB  fBooting
externB  fPadCode
;externW  pGlobalHeap
;externW  MyCSDS
externW  Win_PDB

if KDEBUG
externB  fLoadTrace
externB  fPreloadSeg
endif

if PMODE32
externD FreeArenaCount
extrn   CountFreeSel:WORD
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;externNP MyFree
externNP SegReloc
externNP MyAlloc
externNP MyAllocLinear                  ; MyAlloc with useful parameters
externNP MyLock
externNP GetCachedFileHandle
externNP CloseCachedFileHandle
externNP GetOwner
externNP SetOwner
externNP get_selector_length16

externNP get_rover_2
externNP DiscardTheWorld

IFNDEF NO_APPLOADER
externNP LoadApplSegment
endif ;!NO_APPLOADER

if LDCHKSUM
;externNP GetChksumAddr
externNP CheckSegChksum
externNP ZeroSegmentChksum
endif

if SDEBUG
externNP DebugDefineSegment
endif

ifdef WOW_x86
externNP get_physical_address
endif

;-----------------------------------------------------------------------;
; AllocSeg                                                              ;
;                                                                       ;
; Allocates memory for a segment.  Does not load the segment.  Puts     ;
; the handle of the segment into the segment descriptor structure       ;
; in the module database, and updates the flags there to mark the       ;
; segment as allocated but not loaded.  Put the segment number into     ;
; the BurgerMaster handle entry.  It also changes the .ga_owner to be   ;
; the module database.                                                  ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pSegInfo                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle for segment                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       SI,DS,ES                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       MyAlloc                                                         ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
; Handle 64K (big/huge) data segments                                   ;
;                                                                       ;                                                                       ;
;  Mon Feb 09, 1987 10:29:16p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   AllocSeg,<PUBLIC,NEAR>,<si,es>
        parmD   pSegInfo
cBegin
        SetKernelDS
        les     si,pSegInfo

; Get size into AX (max of file size and minimum allocation).

        mov     bx,es:[si].ns_flags

        test    bl,NSALLOCED            ; Already allocated?
        jz      as0                     ;  No, allocate it
        jmp     SHORT as3
as0:    mov     ax,es:[si].ns_minalloc
        xor     dx, dx                  ; if AX == 0
        cmp     ax, 1                   ; then it is really 64K
        adc     dx, dx
        add     ax, 2           ; We may have a 1 byte entry point at the
        adc     dx, 0           ;  very end of a segment.  PatchCodeHandle
                                ;  will GP trying to decipher the prolog.
                                ; Also allow space for reading relocation word

        cmp     si,es:[ne_pautodata]
        jne     as1
        add     ax,es:[ne_stack]        ; Include stack and heap for data.
        jc      asfail                  ; Don't need to handle big auto segs
        add     ax,es:[ne_heap]
        jnc     as1
asfail:
        krDebugOut      DEB_ERROR, "%es2 Automatic Data Segment larger than 64K."
        xor     ax,ax
asxj:   jmp     SHORT asx
as1:

; Allocate space for segment
        push    bx
        push    es
        cCall   MyAllocLinear,<bx,dxax>
        pop     es
        pop     bx
        or      ax,ax
        jz      asxj


as2:
if ROM

; If this segment gets loaded from ROM, change the segment handle
; to be the one that was used to fix-up the ROM code segments.  This
; is the value of ns_sector in the segment table.

        test    byte ptr es:[si].ns_flags+1,(NSINROM SHR 8)
        jz      as_not_a_rom_seg
        mov     bx,es:[si].ns_sector
        test    dl,GA_FIXED
        jnz     as_fixed
        StoH    bx
as_fixed:
        cCall   ChangeROMHandle,<dx,bx>
        mov     dx,bx
as_not_a_rom_seg:
endif
        mov     es:[si].ns_handle,dx    ; Handle into seg table
        and     byte ptr es:[si].ns_flags,not NSLOADED
        or      byte ptr es:[si].ns_flags,NSALLOCED

        mov     bx,dx
        cCall   SetOwner,<ax,es>

as3:    mov     ax,es:[si].ns_handle
asx:
        or      ax,ax

cEnd

;-----------------------------------------------------------------------;
; LoadSegment                                                           ;
;                                                                       ;
; Loads a segment and performs any necessary relocations.               ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hExe                                                    ;
;       parmW   segno                                                   ;
;       parmW   fh                                                      ;
;       parmW   isfh                                                    ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle of segment                                          ;
;       CX = handle of segment                                          ;
;       DX = handle of segment                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;       CX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,ES                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       LoadSegment                                                     ;
;       AllocSeg                                                        ;
;       LoadApplSegment                                                 ;
;       MyOpenFile                                                      ;
;       SegLoad                                                         ;
;       GlobalAlloc                                                     ;
;       MyLock                                                          ;
;       SegReloc                                                        ;
;       GlobalFree                                                      ;
;       ZeroSegmentChksum                                               ;
;       CheckSegChksum                                                  ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
;                                                                       ;
;  Tue Oct 27, 1987 06:10:31p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   LoadSegment,<PUBLIC,NEAR>,<si,di>
        parmW   hExe
        parmW   segno
        parmW   fh
        parmW   isfh
        localW  myfh
        localW  hrleseg
        localD  pseginfo
        localW  creloc
        localW  hseg
        localW  fdataseg
        localW  retries
        localW  SavePDB
        localB  fReload
if ROM
        localW  selROMrle
endif
        localW  pleaseNoLock            ; 1 if shouldn't lock seg
cBegin
        mov     retries, 2
        xor     ax,ax
        mov     hrleseg,ax
        mov     hseg,ax
        mov     SavePDB, ax
        mov     pleaseNoLock, ax
        mov     fReload, al
if ROM
        mov     selROMrle,ax
endif
        not     ax
        mov     myfh,ax
        mov     es,hexe
        mov     si,segno
        dec     si
        cmp     es:[ne_cseg],si
        jg      ls_not_done             ; wish we had auto jump sizing...
        jmp     lsdone
ls_not_done:
        shl     si,1
        mov     bx,si
        shl     si,1
        shl     si,1
        add     si,bx
        .errnz  10 - SIZE NEW_SEG1
        add     si,es:[ne_segtab]
        mov     SEG_pseginfo, es        ; Save segment info pointer
        mov     OFF_pseginfo, si

IFNDEF NO_APPLOADER
        test    es:[ne_flags],NEAPPLOADER
        jnz     ls_special_load
ls_not_special_load:
ENDIF ;!NO_APPLOADER

        mov     bx,es:[si].ns_flags
        mov     ax, bx
        and     ax, NSHUGESEG
        mov     pleaseNoLock, ax

if ROM
        test    bh,(NSINROM SHR 8)      ; Segment in ROM?
        jz      ls0b                    ;   no, go load it normally

        test    bl,NSLOADED             ; Alread 'loaded' in ROM?
        jnz     chk_rom_seg
        push    es
        cCall   AllocSelector,<0>
        pop     es
        cCall   CloneROMSelector,<es:[si].ns_sector,ax>
        mov     selROMrle,ax
        mov     fh,ax                   ; Fake parmas to indicate loading
        mov     isfh,-1                 ;   from memory and go load it
        jmps    ls1b

chk_rom_seg:
        test    bl,NSALLOCED            ; ROM seg allocated & loaded into RAM?
        jnz     ls0b                    ;   yes, treat normally

        mov     ax,es:[si].ns_handle    ; later code expects this
        jmp     DefineSeg               ; define seg to debugger (maybe)
ls0b:
endif ;ROM

        test    bl,NSALLOCED
        jnz     ls1
        push    bx
        cCall   AllocSeg,<essi>         ; No, so try allocating the segment
        pop     bx
        or      ax,ax
        jnz     ls1b
ls1:    mov     ax,es:[si].ns_handle
        mov     hseg,ax
        test    bl,NSLOADED
        jz      ls1b
        mov     fReload,1
        jmp     lsexit                  ; so MyLock at lsexit can swap them in

IFNDEF NO_APPLOADER
ls_special_load:
        mov     ax,segno
        cmp     ax,1
        je      ls_not_special_load     ;* first segment normal load
        test    es:[si].ns_flags,NSLOADED
        jnz     ls_already_loaded
        cCall   LoadApplSegment, <hExe, fh, ax>
        jmp     lsx

ls_already_loaded:
        mov     ax,es:[si].ns_handle
        mov     hseg,ax
        mov     fReload,1
        jmp     lsexit
endif ;!NO_APPLOADER

ls1b:
        mov     ax,fh
        inc     ax                      ; Already have file handle?
        jz      ls2                     ; No, then get one and load segment
        dec     ax
        cmp     isfh,ax                 ; Yes, loading from memory?
        jne     lsdoit                  ; Yes, load it now
        jmps    ls2b                    ; No, load it now
ls2:
        SetKernelDS
        mov     ax, Win_PDB             ; Save what PDB is supposed to be
        mov     SavePDB, ax             ; since we will set it to kernel's PDB
        mov     ax,-1
        cCall   GetCachedFileHandle,<hExe,ax,ax> ; Get file handle from cache
ls2b:
        mov     myfh,ax
        mov     isfh,ax
        inc     ax
        jnz     lsdoit0
        cmp     SavePDB, ax             ; If we saved the PDB, (ax=0)
        je      @F
        push    SavePDB                 ; better restore it!
        pop     Win_PDB
@@:
        jmp     lsdone
lsdoit0:
        dec     ax
lsdoit:
        push    es
        cCall   SegLoad,<essi,segno,ax,isfh>
        pop     es
        mov     hseg,0
        or      ax,ax
        jz      lsexit1

        inc     ax                              ; Did we get a file error?
        jnz     lsloaded
        mov     bx, myfh
        inc     bx                              ; Reading from memory?
        jz      lsexit1                         ;  no, fail
        dec     bx
        cmp     bx, fh                          ; We opened the file?
        je      lsexit1                         ;  no, fail
;;;     cCall   CloseCachedFileHandle,<bx>
        mov     bx, SavePDB
        mov     Win_PDB, bx
        cCall   FlushCachedFileHandle,<hExe>    ; Close it
        dec     retries
        jz      lsbadfile
        jmps    ls2                             ; and try to re-open it.
        UnSetKernelDS
lsbadfile:
        krDebugOut      DEB_ERROR, "%ES2 I/O error reading segment"
lsexit1:
        jmp     lsexit

lsloaded:
        mov     hseg,bx
        mov     bx,es:[si].ns_flags
        test    bx,NSRELOC
        jnz     lm1x
        jmp     lschksum
lm1x:
        and     bx,NSDATA
        mov     fdataseg,bx
        mov     bx,myfh                 ; Loading from memory?
        inc     bx
        jnz     lm1                     ; No, continue
        mov     es,dx                   ; Yes, point to relocation info
        mov     si,cx
        cld
        lods    word ptr es:[si]
        mov     creloc,ax
        jmps    lm2
lm1:
        dec     bx
        mov     creloc,cx
        shl     cx,1
        shl     cx,1
        shl     cx,1
        .errnz  8 - SIZE new_rlc
        push    bx
        push    cx
        mov     ax,GA_MOVEABLE+GA_NODISCARD     ; DO NOT WANT FIXED!!
        xor     bx,bx
        regptr  xsize,bx,cx
if PMODE32
.386
; We don't really want to cause an attempt to grow the global arena
; table or the LDT here!
        push    ds
        SetKernelDS
        cmp     FreeArenaCount,0        ; free arena?
        jz      NoFreeArenas            ; No
        cmp     CountFreeSel,0          ; free selector?
NoFreeArenas:
        pop     ds
        UnsetKernelDS
        jz      lm1a                    ; No, then read one at a time
.286
endif
        cCall   IGlobalAlloc,<ax,xsize>
        mov     hrleseg,ax      ; Save handle
        or      ax,ax           ; Did we get the memory
        jz      lm1a            ; No, then read one at a time

        cCall   IGlobalLock,<ax> ; Get the address of the relocation info
        mov     si, ax
        mov     es, dx
        pop     cx              ; Restore byte count
        pop     bx              ; Restore file handle
        push    ds
        mov     ds,dx
        assumes ds,nothing
        xor     dx,dx
        mov     ah,3Fh          ; Read in relocation information
        DOSCALL
        pop     ds
        assumes ds,nothing
        jc      lserr2
        cmp     ax,cx
        jne     lserr2
        jmps    lm2

lm1a:
        pop     cx              ; Restore byte count
        pop     bx              ; Restore file handle
        xor     si,si
        mov     es,si           ; Signal no records read
lm2:
                                ; Pass pseginfo, not hseg
        cCall   SegReloc,<hexe,essi,creloc,pseginfo,fdataseg,myfh>
lm2a:
        mov     cx,hrleseg
        jcxz    no_hrleseg
        push    ax
        cCall   IGlobalFree,<hrleseg>
        pop     ax
no_hrleseg:
        les     si,pseginfo
        or      ax,ax
        jnz     lschksum
lsdone2:
        jmps    lsdone

lserr2:
        krDebugOut DEB_ERROR, "Error reading relocation records from %es2"
        xor     ax,ax
        jmp     lm2a

lschksum:
        mov     ax, hseg                ; in case we aren't locking
        Handle_To_Sel   al
        cmp     pleaseNoLock, 0
        jnz     lschksum1
        cCall   MyLock,<hseg>
lschksum1:

if LDCHKSUM
        push    ax
        push    si
        mov     si,ax
        cCall   ZeroSegmentChksum
        pop     si
        cCall   CheckSegChksum          ; destroys ax, bx, cx, dx, es
        pop     ax
endif

        les     si, pseginfo

if ROM

DefineSeg:
if SDEBUG
        push    ax                      ; save segment selector
endif
endif

if SDEBUG                               ; Tell debugger about new segment
        cmp     pleaseNoLock, 0
        jnz     keep_secrets
        mov     bx,es:[ne_restab]
        inc     bx
        mov     dx,es:[si].ns_flags
        mov     si, ax  
        xor     ax, ax
        test    dx,NSDATA               ; test to pass NSKCACHED too
        jz      sa8
        test    byte ptr es:[ne_flags],NEINST
        jz      sa8
        mov     ax,es:[ne_usage]
        dec     ax
sa8:
        mov     cx,segno
        dec     cx

        cCall   DebugDefineSegment,<esbx,cx,si,ax,dx>
keep_secrets:
endif

if ROM
if SDEBUG
        pop     ax                      ; recover segment selector
endif
        mov     dx,ax                   ; in case this is a ROM code seg,
                                        ;   MyLock doesn't get called, but we
                                        ;   want to return AX & DX = selector
endif

lsexit:
        mov     cx,hseg
        jcxz    lsdone
        mov     ax, cx                  ; in case we don't lock
        mov     dx, ax
        Handle_To_Sel    al
        cmp     pleaseNoLock, 0
        jnz     lsdone
        cCall   MyLock,<cx>
lsdone:
if ROM
        mov     cx,selROMrle            ; If a segment was loaded from ROM,
        jcxz    @f                      ;   an extra selector was allocated
        push    ax                      ;   to point to reloc info--free that
        cCall   IFreeSelector,<cx>       ;   now.
        pop     ax
@@:
endif
        mov     cx,myfh
        inc     cx
        jz      lsx
        dec     cx
        cmp     fh,cx
        je      lsx
        push    ax
        SetKernelDS
;;;     cCall   CloseCachedFileHandle,<cx>
        mov     ax, SavePDB
if KDEBUG
        or      ax, ax
        jnz     @F
        int 3
@@:
endif
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ax
public lsx
lsx:
        mov     es, hExe
        test    es:[ne_flagsothers], NEHASPATCH
        jz      ls_exeunt
        cmp     fReload, 0
        jne     ls_exeunt

        push    dx
        push    ax

        cCall   GetPatchAppRegKey,<hExe>
        mov     cx, dx
        or      cx, ax
        jnz     @F

        ; MCF_MODPATCH is set, but there are no patches
        ; in the registry for this module. Turn off the patch flag.
        and     es:[ne_flagsothers], not NEHASPATCH
        jmp short ls_after_patch
@@:
        ; reg key in dx:ax
        cCall   PatchAppSeg,<dx,ax,segno,hseg>
        test    ax, ax
        jz      ls_after_patch

        ; One or more patches applied, so mark the segment not discardable.
        ; PatchAppSeg already cleared GA_DISCARDABLE or GA_DISCCODE in the
        ; global arena record.
        mov     si, pseginfo.off
        and     es:[si].ns_flags, not NSDISCARD     ; mark not discardable
ls_after_patch:
        pop     ax
        pop     dx
ls_exeunt:
        mov     cx,ax
cEnd


GETSEGLEN macro segval
        local   not_huge_386
if      PMODE32
.386p
        xor     eax, eax                ; since we now have huge segments,
        mov     ax, segval              ; we need to be able to handle limit
        lsl     eax, eax                ; values > 64K.  On a 386 we just
        inc     eax                     ; execute the lsl instruction.
        test    eax, 0ffff0000h
.286
        jz      not_huge_386
        mov     ax, 0                   ; 0 == 64K
not_huge_386:
else
        cCall   get_selector_length16,<segval>  ; Get size of segment
endif
endm

;-----------------------------------------------------------------------;
; SegLoad                                                               ;
;                                                                       ;
; Reads in the data portion of a code or data segment.                  ;
;                                                                       ;
; It can be confusing decoding how various values of ns_cbseg,          ;
; ns_minalloc, and ns_sector define the size of disk files.  I hope     ;
; this table is accurate for all combinations....                       ;
;                                                                       ;
;       sector  cbseg   minalloc- Sector in memory is ...               ;
;       0       0       0       - 64K segment, all 0's                  ;
;       0       0       m       - 'm' bytes, all 0's                    ;
;       0       c       0       - illegal (sector = 0 when cbseg != 0)  ;
;       0       c       m       - illegal (sector = 0 when cbseg != 0)  ;
;       s       0       0       - 64K segment on disk at given sector   ;
;       s       0       m       - illegal (cbseg > minalloc)            ;
;       s       c       0       - 64K, 'c' from file, 64K-'c' 0's       ;
;       s       c       m       - 'm' bytes, 'c' from file, 'm-c' 0's   ;
;                                                                       ;
;  In other words, cbseg == 0 means 64K when a sector value is given,   ;
;  else it means 0 bytes from the file                                  ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pseginfo                                                ;
;       parmW   segno                                                   ;
;       parmW   psegsrc                                                 ;
;       parmW   isfh                                                    ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
; Add support for big/huge segments                                     ;
;                                                                       ;
;  Tue Oct 27, 1987 06:17:07p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SegLoad,<NEAR,PUBLIC>,<si,di>
        parmD   pseginfo
        parmW   segno
        parmW   psegsrc
        parmW   isfh
        localW  hseg
        localW  pseg
        localW  psegdest
        localD  prleinfo
        localW  retry
        localW  segoffset
        localW  pleaseNoLock            ;1 if segment is 64K
        localW  allocTwice              ;if first alloc fails, FreeTheWorld
ifdef WOW_x86
        localD  rover_2
endif
cBegin
        mov     retry,1
        mov     segoffset, 0
        mov     allocTwice, 1
        les     si,pseginfo
        mov     ax,es:[si].ns_handle
        mov     hseg,ax
        Handle_To_Sel   al                      ; in case we don't lock
        mov     pleaseNoLock, 1
        test    es:[si].ns_flags, NSHUGESEG
        jnz     dont_touch              ;big segs are always locked and present
        mov     pleaseNoLock, 0
        push    es
        cCall   MyLock,<ax>
        pop     es
        or      ax,ax
        jz      try_alloc       ; wish I could "jnz saalloced"
dont_touch:
        jmps    saalloced

try_alloc:
        push    es
        xor     ax,ax
        mov     bx, es:[si].ns_minalloc
        xor     dx, dx
        cmp     bx, 1
        adc     dx, dx
        add     bx, 2           ; We may have a 1 byte entry point at the
        adc     dx, 0           ;  very end of a segment.  PatchCodeHandle
                                ;  will GP trying to decipher the prolog.
                                ; Allow room to read relocation word
ife PMODE32
        push    ds
        SetKernelDS

        cmp     fPadCode, 0
        je      @F
        add     bx, 14
        adc     dx, 0
@@:
        pop     ds
        UnSetKernelDS
endif
        cCall   IGlobalReAlloc,<hseg,dx,bx,ax>
        pop     es
        cmp     hseg,ax
        jz      sarealloced
saerr2:
        test    es:[si].ns_flags,NSDISCARD
        jz      dont_scream
        push    es
        cCall   DiscardTheWorld         ; Maybe if we try again
        pop     es
        dec     allocTwice
        jz      try_alloc
        krDebugOut DEB_ERROR, "Out of mem loading seg %es2"
dont_scream:
        jmp     saerr1

sarealloced:                            ; ax == handle
        Handle_To_Sel   al
        cmp     pleaseNoLock, 0
        jnz     saalloced
        push    es
        cCall   MyLock,<hseg>
        pop     es
        or      ax,ax
        jz      saerr2

saalloced:
        mov     pseg,ax
        mov     psegdest,ax

sareread:
        push    es
        push    si
        push    ds                              ; We are going to trash this

        cld
        cmp     es:[si].ns_sector,0     ; if sector == 0, then just init
        jnz     sa_read_from_disk       ; segment to all 0's
;       mov     cx, es:[si].ns_minalloc ; convert minalloc == 0 to 64K
        GETSEGLEN pseg
        mov     cx, ax
ifdef WOW_x86 ;
.386
;; WOW we can use the magic flat selector 23h to write to any segment
;; This saves us calling get_rover_2 which makes an NT system call to set
;; a temp selector
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     ax,FLAT_SEL
        mov     es,ax

    xor eax, eax
        mov     edi,edx                 ; es:edi -> pseg:0

        cmp     cx, 1                   ; Need to handle case where CX == 0
        mov     dx, cx
        rcr     cx, 1
        shr     cx, 1
        movzx   ecx,cx
        rep     stos dword ptr [edi]
        mov     cx, dx
        and     cx, 3
        rep     stos byte ptr [edi]
        jmp     sa_after_read

else ; 286
        cmp     cx, 1                   ; set CF if 0000
        rcr     cx, 1                   ; this sets CF for odd byte of size
        xor     ax, ax
        xor     di, di
        mov     es, pseg                ; start at pseg:0000
        call    get_rover_2
        rep     stosw
        adc     cx, cx
        rep     stosb                   ; this case now handled
        jmp     sa_after_read
endif;

sa_read_from_disk:
        mov     di,es:[si].ns_cbseg     ; #bytes in segment to read

; If source segment address given then copy segment contents

        mov     bx,psegsrc              ; Get source handle
        cmp     isfh,bx                 ; Is source a file handle?
        je      sa_read_file            ; Yes, go read segment from file

; We are reading from preload buffer, bx == src seg address, di == len
        push    di                      ; No, set up for fast copy
        mov     OFF_prleinfo,di
        mov     SEG_prleinfo,bx
        pop     cx

if ROM
        mov     al,byte ptr es:[si].ns_flags+1  ; Compressed seg in ROM?
        and     al,(NSINROM OR NSCOMPR) SHR 8
        cmp     al,(NSINROM OR NSCOMPR) SHR 8   ; Both NSINROM & NSCOMPR must
        jnz     @f                              ;   be set
        jmp     sa_exp_seg
@@:
endif
        mov     ds,bx
ifdef WOW_x86 ;
.386
;; For WOW on NT we don't want to set the selector unesssarily
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     es,ax

        mov     edi,edx                 ; es:edi -> pseg:0
        xor     esi,esi

        cmp     cx, 1                   ; set carry if 0 for big/huge segs
        mov     ax, cx
        rcr     cx, 1
        shr     cx, 1
        movzx   ecx,cx
        rep     movs dword ptr [edi], dword ptr [esi]
        mov     cx, ax
        and     cx, 3
        rep     movs byte ptr [edi], dword ptr [esi]

        sub     edi,edx                 ; make di correct for rest of code
else
        mov     es,pseg                 ; Writing to pseg
        call    get_rover_2
        xor     si,si
        xor     di,di

IF ROM
        clc                             ; HACK: 64K segs not allowed in ROM
                                        ; because ns_sector always != 0
ELSE
        ; need to handle case where seg size is 64K (cx == 0)
        cmp     cx, 1                   ; set carry if 0 for big/huge segs
ENDIF
ife PMODE32
        rcr     cx, 1                   ; set bit 15 if carry was set
        rep     movsw
        adc     cx, cx
        rep     movsb
else
.386
        mov     ax, cx
        rcr     cx, 1
        shr     cx, 1
        rep     movsd
        mov     cx, ax
        and     cx, 3
        rep     movsb
.286
endif
endif; WOW_x86


        ; we have now read 'cbseg' bytes from preload buffer, di == cbseg
        jmp     sa_zero_fill_rest
           
saerr1:
        xor     ax,ax
        jmp     sax

sa_read_file:
        ; read segment contents from disk file, bx == file handle
        ; ax = disk file sector

if 0    ;KDEBUG
        push    ax
        push    ds
        SetKernelDS

        cmp     fPreloadSeg, 0
        jne     SHORT SkipDebugTrace

        mov     ax, segno
        krDebugOut      <DEB_TRACE or DEB_krLoadSeg>, "%ES0: reading segment #ax"
SkipDebugTrace:
        pop     ds
        UnSetKernelDS
        pop     ax
endif

; Get offset to data portion of segment in DX:AX
        mov     ax, es:[si].ns_sector
        xor     dx,dx
        mov     cx,es:[ne_align]
sa4a:
        shl     ax,1
        adc     dx, dx
        loop    sa4a                    ; DX:AX = file offset to segment

        mov     cx,dx                   ; Seek to beginning of segment data
        mov     dx,ax
        mov     ax,4200h                ; lseek(bx, sector << align, SEEK_SET)
        DOSCALL
        jc      saerr
        mov     cx,di                   ; Get #bytes to read
        test    es:[si].ns_flags,NSRELOC
        jz      no_read_extra_word
        add     cx, 2                   ; Relocation word
no_read_extra_word:
        mov     ds,pseg                 ; Read segment from file
        xor     dx,dx
        mov     ah,3Fh
        test    es:[si].ns_flags,NSITER
        jz      @F
        call    iterated_data_seg
        jmps    sa_iter_done
@@:
        or      cx, cx                  ; if cx == 0 at this point, it is 64K
        jnz     not_huge_read

        cmp     es:[si].ns_minalloc,0   ; If minalloc isn't zero too, then the
        jnz     not_huge_read           ; segment is too small.  Case should't
                                        ; happen but does for dbwindow, mimic Win 3.0.

        mov     cx, 8000h
        DOSCALL                         ; read first 32K from disk
        jc      saerr
        add     dx, cx                  ; update destination address
        mov     ah, 3fh                 ; restore AX (doscall trashes it)
        DOSCALL                         ; read second 32K
        jc      saerr
        cmp     ax, cx
        jnz     saerr
        jmp     short sa_zero_fill_rest

not_huge_read:
        DOSCALL
sa_iter_done:
        jc      saerr                   ; Continue if no errors
        cmp     ax,cx                   ; Read ok, did we get what we asked for?
        jne     saerr                   ; No, fail
        test    es:[si].ns_flags,NSRELOC        ; Relocation records?
        jz      sa_zero_fill_rest       ; No, continue
        mov     ax, ds:[di]             ; Extra word was read here
        mov     OFF_prleinfo, ax
        jmps    sa_zero_fill_rest
saerr:
        pop     ds
        pop     si
        pop     es
        mov     ax, -1                  ; File error
        jmp     sax

if ROM
sa_exp_seg:
        xor     si,si
        mov     es,pseg

;; NOT Compiled for WOW
        call    get_rover_2

        cCall   LZDecode,<es,bx,si,si>
        mov     di,ax
        or      ax,ax
        jnz     sa_zero_fill_rest

if KDEBUG
        Debug_Out "LZDecode of segment failed!"
endif
        pop     ds
        pop     si
        pop     es
        jmp     sax
endif

sa_zero_fill_rest:                      ; di == bytes written so far
        GETSEGLEN       pseg            ; seg len to ax, 0 == 64K

        sub     ax,di                   ; Any uninitialized portion?
        jz      sa_after_read           ; No, continue
ifdef WOW_x86;
.386
;; WOW we don't want to call NT to set the selector
        push    ax
        cCall   get_physical_address,<psegdest>
        shl     edx,16
        mov     dx,ax
        mov     ax,FLAT_SEL
        mov     es,ax

        and     edi,0000ffffh
        add     edi,edx                 ; es:edi -> pseg:0
        pop     cx

        push    edx

    xor eax,eax
        cld
        mov     dx,cx
        shr     cx, 2
        movzx   ecx,cx
        rep     stos dword ptr [edi]
        mov     cx, dx
        and     cx, 3
        rep     stos byte ptr [edi]

        pop     edx
        sub     edi,edx

else
        mov     es,psegdest             ; Yes, set it to zero
        call    get_rover_2
        mov     cx,ax
        xor     ax,ax
        cld
        shr     cx, 1
        rep     stosw
        adc     cx, cx
        rep     stosb
endif

sa_after_read:
        les     si, pseginfo

if LDCHKSUM
        mov     ds,psegdest
        xor     si,si
        mov     cx,di
        shr     cx,1
        xor     dx,dx
        cld
sa5b:
        lodsw
        xor     dx,ax
        loop    sa5b
endif
        cmp     pleaseNoLock, 0
        jnz     dont_patch
        push    dx
        cCall   <far ptr PatchCodeHandle>,<hseg>
        pop     dx
dont_patch:
        pop     ds                      ; Restore DS
        pop     si                      ; segment info pointer
        pop     es
        mov     ax,es:[si].ns_flags     ; Are we loading a code segment?
        and     ax,NSDATA
        .errnz  NSCODE
        jnz     sa9

; Here when loading a code segment

if LDCHKSUM
        mov     cx,segno
        dec     cx
        shl     cx,1
        shl     cx,1
        mov     di,es:[ne_psegcsum]
        add     di,cx
        mov     cx,dx
        xchg    es:[di],cx
        jcxz    sa6a0
        cmp     cx,dx
        je      sa6a0
        dec     retry
        jl      sa6a1
        public  badsegread
badsegread:
        mov     ah,0Dh                  ; Disk Reset
        DOSCALL
        jmp     sareread
sa6a1:
        krDebugOut DEB_ERROR, "Segment contents invalid %es2"
        xor     ax,ax
        jmps    sax
sa6a0:
        mov     word ptr es:[di+2],0
endif

sa9:
        mov     dx,SEG_prleinfo
        mov     cx,OFF_prleinfo
        mov     bx,hseg
        mov     ax,pseg
sax:    or      ax,ax
cEnd



.286

;-----------------------------------------------------------------------;
; iterated_data_seg
;
; This expands out iterated data segments (specifically for the
; OS/2 m.exe).  Due to the late date this is being sleazed in
; instead of being done right.  To be done right, the read would
; go into the last part of the present block, and expanded in place,
; the stack used for the next record count because the last record
; never fits.
;
; Entry:
;       CX    = number of bytes to read
;       DS:DX = place to put them
;       DS:DI = place where #relocs will magically appear
;       ES:SI = module exe header:seg info
;
; Returns:
;       CF = 1
;       DS:DI = updated magic place where #relocs will magically appear
;
; Error Return:
;       CX = 0
;
; Registers Destroyed:
;
; History:
;  Sun 28-Jan-1990 12:25:02  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   iterated_data_seg,<PUBLIC,NEAR>,<bx,dx,si,ds,es>

        localW  temp_buf
        localW  freloc
cBegin

; deal with that extra relocation word!

        xor     ax,ax
        test    es:[si].ns_flags,NSRELOC ; Relocation records?
        jz      @F
        inc     ax
@@:     mov     freloc,ax

; first get a temp buffer

        push    bx
        push    cx
        cCall   IGlobalAlloc,<0,0,cx>
        mov     temp_buf,ax
        pop     cx
        pop     bx
        or      ax,ax
        stc                             ; assume failure
        jz      ids_exit
        push    dx
        push    ds

; read into the temp buffer

        mov     ds,ax
        xor     dx,dx
        mov     ah,3Fh
        DOSCALL
        pop     ds
        pop     dx
        jc      ids_exit1
        cmp     ax,cx
        jnz     ids_exit1

; expand the buffer, yes we should special case strings of length 1

        cmp     freloc,0                ; was an extra word read?
        jz      @F
        sub     cx,2
@@:     mov     dx,cx
        smov    es,ds
        xor     di,di
        mov     ds,temp_buf
        xor     si,si
        cld
ids_next_group:
        lodsw                           ; get the # interations
        mov     cx,ax
        lodsw                           ; get the # bytes
@@:     push    cx
        push    si
        mov     cx,ax
        rep     movsb
        pop     si
        pop     cx
        loop    @B
        add     si,ax                   ; get past group
        cmp     si,dx
        jb      ids_next_group

; data segment now processed, deal with reloc word

        cmp     freloc,0                ; was an extra word read?
        jz      @F
        movsw
        sub     di,2
        add     dx,2
@@:     mov     ax,dx
        mov     cx,dx
        clc

ids_exit1:
        pushf                           ; preserve the carry flag
        push    ax
        push    cx
        smov    ds,0
        cCall   IGlobalFree,<temp_buf>
        pop     cx
        pop     ax
        popf

ids_exit:

cEnd


;-----------------------------------------------------------------------;
; PatchCodeHandle                                                       ;
;                                                                       ;
; Patches the prologs of the procedures in the given code segment.      ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hseg                                                    ;
;                                                                       ;
; Returns:                                                              ;
;       AX = hseg                                                       ;
;       DX = pseg                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       MyLock                                                          ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 17-Sep-1989 10:45:24  -by-  David N. Weise  [davidw]             ;
; Added support for symdeb to understand segments in himem.             ;
;                                                                       ;
;  Tue Oct 27, 1987 06:19:12p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing
cProc   PatchCodeHandle,<PUBLIC,FAR>,<si,di>
        parmW   hseg
        localW  pseg
        localW  hexe
        localW  segno
        localW  segoffset
ifdef WOW_x86
.386
        localD  rover_2
endif
cBegin
        SetKernelDS
        cCall   MyLock,<hseg>
        mov     pseg,ax                 ; Save physical addresss
        or      ax,ax                   ; All done if discarded
        jz      pcsDone1

        xor     si,si
        mov     segoffset, si

        push    ax
        cCall   GetOwner,<pseg>
        mov     es, ax
        pop     ax


        cmp     es:[si].ne_magic,NEMAGIC
if KDEBUG
        jz      good_boy
bad_boy:
        krDebugOut DEB_ERROR "PatchCodeHandle, owner not NewExe %es2"
        jmps    pcsDone1
good_boy:
endif
        jne     pcsDone1
        mov     hexe,es
        mov     cx,es:[si].ne_cseg      ; We need si to point to entry
        mov     si,es:[si].ne_segtab    ;  anyway so do it the slow way
pcsLoop:
        cmp     es:[si].ns_handle,dx    ; Scan table for handle
        je      pcsFound
        add     si,SIZE NEW_SEG1
        loop    pcsLoop
pcsDone1:
        jmp     pcsDone
pcsExit1:
        jmp     pcsExit
pcsFound:
        sub     cx,es:[ne_cseg]         ; Compute segment# from remainder
        neg     cx                      ; of loop count
        inc     cx                      ; 1-based segment#
        mov     segno,cx

        test    es:[si].ns_flags,NSDATA
        jnz     pcsExit1
        .errnz  NSCODE

        push    si
        mov     di,es:[ne_pautodata]
        or      di,di
        jz      sa6a
        cCall   MyLock,<es:[di].ns_handle>
        mov     di,ax
sa6a:                                   ; DI:0 points to data segment (or 0)
ifdef WOW_x86
;; For WOW we use the NT Magic data selector, since all 16 bit code is DATA
        cCall   get_physical_address,<pseg>
        assumes es,nothing
        shl     edx,16
        mov     dx,ax                   ; ES:EDX -> pseg:0
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     es,ax
else
        mov     es,pseg                 ; ES:0 points to code segment
        call    get_rover_2
endif
        mov     ds,hexe                 ; DS:SI points to entry table
        assumes ds,nothing
        mov     si,ds:[ne_enttab]
        cld

        or      di, di                  ; Anything to do?
        jz      sa6x
sa6b:
        lods    word ptr ds:[si]
        mov     dx, ax
        lods    word ptr ds:[si]
        sub     ax, dx                  ; Get # entries in this block
        or      ax,ax
        jz      sa6x                    ; Done if zero
        push    word ptr ds:[si]        ; Next block
        add     si, 2                   ; Skip Next
        mov     cx,ax

sa6c:
        mov     al,ds:[si].pentsegno    ; Get segment# from int instruction
        cmp     byte ptr segno,al       ; Does this moveable segment match ES?
        jne     sa6e                    ; No, advance to next entry

ifdef WOW_x86

        movzx   ebx, word ptr ds:[si].pentoffset ; Get entry point offset
        add     ebx,rover_2
        mov     al, ds:[si].pentflags   ; Get entry point flags

        cmp     byte ptr es:[ebx+2],90h  ; Yes, followed by nop?
        jne     sa6e                    ; No, can;t patch prolog then
        cmp     word ptr es:[ebx],0581Eh ; Is it a push ds, pop ax?
        jne     @F                      ; Yes, take care of prolog

        mov     word ptr es:[ebx],0D88Ch
        jmps    sa6d1
@@:
        cmp     word ptr es:[ebx],0D88Ch ; Is it a mov ax,ds?
        jne     sa6e                    ; No, can't patch prolog then
sa6d1:
        test    al,ENT_DATA             ; Valid prolog.  shared data?
        jnz     sa6d2                   ; Yes, patch mov ax,DGROUP into prolog
        test    byte ptr ds:[ne_flags],NEINST    ; No, multiple instances?
        jz      sa6e                    ; No, do nothing
        test    al,ENT_PUBLIC           ; Public entry point?
        jz      sa6e                    ; No, do nothing
        mov     word ptr es:[ebx],09090h ; Yes, set nop, nop in prolog
        jmps    sa6e
sa6d2:
        mov     byte ptr es:[ebx],0B8h   ; Set mov ax,
        mov     es:[ebx+1],di            ;            DGROUP

else ; NOT WOW_x86

        mov     bx, ds:[si].pentoffset  ; Get entry point offset
        mov     al, ds:[si].pentflags   ; Get entry point flags

        cmp     byte ptr es:[bx+2],90h  ; Yes, followed by nop?
        jne     sa6e                    ; No, can;t patch prolog then
        cmp     word ptr es:[bx],0581Eh ; Is it a push ds, pop ax?
        jne     @F                      ; Yes, take care of prolog

        mov     word ptr es:[bx],0D88Ch
        jmps    sa6d1
@@:
        cmp     word ptr es:[bx],0D88Ch ; Is it a mov ax,ds?
        jne     sa6e                    ; No, can't patch prolog then
sa6d1:
        test    al,ENT_DATA             ; Valid prolog.  shared data?
        jnz     sa6d2                   ; Yes, patch mov ax,DGROUP into prolog
        test    byte ptr ds:[ne_flags],NEINST    ; No, multiple instances?
        jz      sa6e                    ; No, do nothing
        test    al,ENT_PUBLIC           ; Public entry point?
        jz      sa6e                    ; No, do nothing
        mov     word ptr es:[bx],09090h ; Yes, set nop, nop in prolog
        jmps    sa6e
sa6d2:
        mov     byte ptr es:[bx],0B8h   ; Set mov ax,
        mov     es:[bx+1],di            ;            DGROUP
endif; WOW_x86
sa6e:
        add     si,SIZE PENT            ; Advance to next entry in
        loop    sa6c                    ; this block
        pop     si
        or      si, si
        jnz     sa6b
sa6x:
        mov     es,hexe
        pop     si
pcsExit:
        or      byte ptr es:[si].ns_flags,NSLOADED  ; Mark segment as loaded


;;;if SDEBUG                            ; Tell debugger about new segment
;;;     mov     bx,es:[ne_restab]
;;;     inc     bx
;;;     mov     dx,es:[si].ns_flags
;;;     mov     ax,segoffset            ; tell symdeb how to fixup symbols
;;;     test    dx,NSDATA               ; test to pass NSKCACHED too
;;;     jz      sa8
;;;     test    byte ptr es:[ne_flags],NEINST
;;;     jz      sa8
;;;     mov     ax,es:[ne_usage]
;;;     dec     ax
;;;sa8:
;;;     mov     cx,segno
;;;     dec     cx
;;;     cCall   DebugDefineSegment,<esbx,cx,pseg,ax,dx>
;;;endif
pcsDone:
        mov     ax,hseg
        mov     dx,pseg
cEnd

sEnd    CODE

externFP FarAllocSeg
externFP FarMyAlloc
externFP FarMyAllocLinear
externFP FarMyFree
externFP FarSetOwner

sBegin  NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA

externA __AHINCR

;-----------------------------------------------------------------------;
; AllocAllSegs                                                          ;
;                                                                       ;
; "Allocates" for all segments of the module being loaded and stores    ;
; the addresses in the segment table.  By allocate we mean:             ;
;                                                                       ;
; AUTOMATIC DATA gets space, but not yet loaded,                        ;
; PRELOAD FIXED  get global mem allocated , but not yet loaded,         ;
; MOVEABLE  get a handle for later use,                                 ;
; FIXED  get nothing.                                                   ;
;                                                                       ;
; If this is not the first instance, then just allocate space for       ;
; the new instance of the automatic data segment.                       ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hexe                                                    ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX =-1 not enough memory                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       FarAllocSeg                                                     ;
;       FarMyAlloc                                                      ;
;       FarMyFree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Feb 24, 1987 01:04:12p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   AllocAllSegs,<NEAR,PUBLIC>,<si,di,ds>
        parmW   hexe
        localW  cSegs
        localD  hugeLen                 ; cum length of huge segment
        localW  hugeIndex               ; index of first segment of huge
        localW  hugeOffs                ; offset of first segment desc of huge
        localW  hugeCnt                 ; segments making up huge seg
        localW  hugeFlags               ; flags of huge segment (needed?)

cBegin
        call    MapDStoDATA
        ReSetKernelDS
        mov     es,hexe
        mov     si,es:[ne_segtab]
        xor     di,di
        mov     cSegs,di
        inc     di
        cmp     es:[ne_usage],di
        je      paloop
        mov     si,es:[ne_pautodata]
        and     byte ptr es:[si].ns_flags,not NSALLOCED+NSLOADED
        mov     di,es:[si].ns_handle
        cCall   FarAllocSeg,<essi>
        or      ax,ax
        jz      aa_nomem
        inc     cSegs
outahere:
        jmp     pagood

aa_nomem:
        mov     es,hexe
        or      byte ptr es:[si].ns_flags,NSALLOCED+NSLOADED
        mov     es:[si].ns_handle,di
        jmp     pafail3

paloop:
        cmp     di,es:[ne_cseg]
        jbe     more_to_go
        jmp     pagood

more_to_go:

        mov     bx,es:[si].ns_flags
        test    bl,NSPRELOAD            ; Are we preloading?
        jz      not_preload
        test    bl,NSDATA               ; Preload data although moveable
        jnz     paalloc
if ROM
        test    bh,(NSINROM SHR 8)      ; Segment in ROM?
        jz      @f
        test    bl,NSLOADED             ;   Yes, is it already 'loaded'?
        jnz     set_rom_owner           ;   Yes, just need to set owner
@@:
endif
        test    bl,NSMOVE               ; Fixed segment?
        jz      paalloc                 ; Yes, allocate segment
not_preload:

if ROM
        test    bh,(NSINROM SHR 8)      ; Segment in ROM?
        jz      @f
if KDEBUG
        test    bl,NSDATA               ; (non-preload data segments in ROM
        jz      not_rom_data            ;   haven't been tested)
int 3
not_rom_data:
endif
        test    bl,NSLOADED             ;   Yes, already 'loaded'?
        jnz     set_rom_owner           ;   Yes, just need to set owner
@@:
endif
        test    bl,NSALLOCED            ; Already allocated?
        jnz     panext                  ; Yes, then nothing to do
        test    bl,NSMOVE               ; Fixed segment?
        jz      panext                  ; Yes, then nothing to do

        xor     cx,cx                   ; No, allocate zero length
        push    es                      ; object so that we guarantee
        cCall   FarMyAlloc,<bx,cx,cx>   ; we will have a handle.
        pop     es
        or      dx,dx                   ; Fail if we cant get a handle
        jz      pafail
if ROM

; If this segment gets loaded from ROM, change the segment handle
; to be the one that was used to fix-up the ROM code segments.  This
; is the value of ns_sector in the segment table.

        test    byte ptr es:[si].ns_flags+1,(NSINROM SHR 8)
        jz      not_a_rom_seg
        mov     bx,es:[si].ns_sector
        test    dl,GA_FIXED
        jnz     sa_fixed
        StoH    bx
sa_fixed:
        cCall   ChangeROMHandle,<dx,bx>
        mov     dx,bx
not_a_rom_seg:
endif
        mov     es:[si].ns_handle,dx    ; Handle into seg table
        and     byte ptr es:[si].ns_flags,not NSLOADED
        or      byte ptr es:[si].ns_flags,NSALLOCED

        mov     bx,dx                   ; put handle into base register
        call    set_discarded_sel_owner
        jmps    panext

if ROM
set_rom_owner:
        cCall   FarSetROMOwner,<es:[si].ns_handle,es>
        jmps    panext
endif

paalloc:

        cmp     es:[si].ns_minalloc, 0
        jnz     paalloc_fer_shure
        jmps    PAHugeAlloc

paalloc_fer_shure:
        cCall   FarAllocSeg,<essi>
        or      ax,ax
        jz      pafail
        inc     cSegs
panext:
        add     si,size NEW_SEG1
        inc     di
        jmp     paloop

; only gets here if not enough memory, free up all previous segments

pafail:
        mov     si,es:[ne_segtab]
        mov     cx,es:[ne_cseg]
pafail1:
        push    cx
        mov     cx,es:[si].ns_handle
        jcxz    pafail2
        push    es
                                ;Need to handle freeing huge segments!!!
        cCall   FarMyFree,<cx>
        pop     es
        mov     es:[si].ns_handle, 0    ; Necessary for EntProcAddress
pafail2:
        and     byte ptr es:[si].ns_flags,not (NSALLOCED+NSLOADED)
        add     si,size NEW_SEG1
        pop     cx
        loop    pafail1
pafail3:
        mov     cSegs,-1
        jmp     pagood

PAHugeAlloc:
        ; at this point, es:si -> current seg record
        ; di is segment index (range from 1 to es:[ne_cseg])
        mov     off_hugeLen, 0
        mov     seg_hugeLen, 0          ; init length to 0K

        mov     hugeOffs, si
        mov     hugeCnt, 1
        mov     ax, es:[si].ns_flags
        or      ax, NSHUGESEG
        mov     hugeFlags, ax
PAHugeLoop:
        mov     ax, es:[si].ns_minalloc ; add current segment to group
        cmp     ax, 1
        sbb     dx, dx
        neg     dx
        add     off_hugeLen, ax
        adc     seg_hugeLen, dx
        or      es:[si].ns_flags, NSHUGESEG

        cmp     es:[si].ns_minalloc, 0  ;
        jnz     PAHugeEndLoop

        cmp     di, es:[ne_cseg]
        jae     PAHugeEndLoop

        mov     ax, si
        add     ax, size NEW_SEG1
        cmp     ax, es:[ne_pautodata]
        jz      PAHugeEndLoop

        mov     ax, hugeFlags           ; do flags have to be identical?
        cmp     ax, es:[si].ns_flags
        jnz     PAHugeEndLoop

        inc     hugeCnt
        inc     di
        add     si, size NEW_SEG1
        jmp     PAHugeLoop

PAHugeEndLoop:
        inc     di
        push    es
        or      hugeFlags, NSMOVE
        cCall   FarMyAllocLinear, <hugeFlags, hugeLen>
        pop     es
        or      ax, ax                  ; check for error
        jnz     Not_pafail
        jmp     pafail
Not_pafail:

        mov     si, hugeOffs            ; fix up segment(s)
        and     es:[si].ns_flags, NOT NSHUGESEG
PAHugeSegLoop:
        mov     es:[si].ns_handle, dx
        and     byte ptr es:[si].ns_flags, not NSLOADED
        or      byte ptr es:[si].ns_flags, NSALLOCED
        cCall   FarSetOwner, <ax, es>
        add     si, size NEW_SEG1
        add     dx, __AHINCR
        dec     hugeCnt
        jnz     PAHugeSegLoop

        ; continue with rest of allocations

        jmp     paloop

pagood:
        mov     ax,cSegs
cEnd

sEnd    NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldstack.asm ===
TITLE	LDSTACK - stack walking procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include eems.inc
.list

;externFP GlobalHandle
;externFP FarLoadSegment

;externW pStackTop
;externW pStackBot

DataBegin

;externB Kernel_flags
;externW segSwapArea
;externW oOldSP
;externW hOldSS
;externW fEEMS
;externW pGlobalHeap
;externW curTDB
;externW headTDB

DataEnd

sBegin	CODE
assumes CS,CODE

;externNP MyLock
;externNP LoadSegment

sEnd	CODE

sBegin MISCCODE
assumes cs, MISCCODE
assumes ds, nothing
assumes es, nothing

jmpbuf	struc
jb_ret	DD  ?
jb_sp	DW  ?
jb_bp	DW  ?
jb_si	DW  ?
jb_di	DW  ?
jb_hds	DW  ?
jb_ip	DW  ?
jb_hss	DW  ?
jmpbuf	ends

savedSI = -4
savedDI = -6

cProcVDO Catch,<PUBLIC,FAR>,<ds,si,di>
	parmD   lpJmpBuf
cBegin
	push	[bp].savedCS
	push	[bp].savedIP
	push	[bp].savedBP
	les	bx,lpJmpBuf
	mov	es:[bx].jb_hss,ss
	mov	es:[bx].jb_hds,ds
	mov	es:[bx].jb_di,di
	mov	es:[bx].jb_si,si
	pop	es:[bx].jb_bp
	pop	word ptr es:[bx].jb_ret[0]
	pop	word ptr es:[bx].jb_ret[2]
	mov	es:[bx].jb_sp,sp
	xor	ax,ax
CatchRet:
cEnd

cProcVDO Throw,<PUBLIC,FAR>
;	parmD   lpJmpBuf
;	parmW   AXvalue
cBegin	nogen
	mov	bx,sp
	mov	di,ss:[bx+4]
	lds	si,ss:[bx+6]

	mov	ss,ds:[si].jb_hss
	mov	sp,ds:[si].jb_sp
	mov	bp,sp
	add	bp,-savedDI
	push	ds:[si].jb_bp
	pop	ss:[bp].savedBP
	push	ds:[si].jb_si
	pop	ss:[bp].savedSI
	push	ds:[si].jb_di
	pop	ss:[bp].savedDI
	push	ds:[si].jb_hds
	pop	ss:[bp].savedDS
	mov	ax,word ptr ds:[si].jb_ret[2]
	mov	ss:[bp].savedCS,ax
	mov	ax,word ptr ds:[si].jb_ret[0]
	mov	ss:[bp].savedIP,ax
	mov	ax,di
	jmp	CatchRet
cEnd	nogen

sEnd MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldself.asm ===
TITLE	LDSELF - BootStrap procedure for KERNEL.EXE

.xlist
?NODATA=1
?TF=1
include kernel.inc
include newexe.inc
include tdb.inc
.list

externFP IGlobalAlloc
externFP IGlobalLock
externFP IGlobalUnlock
	       
DataBegin

externW winVer
;externW pGlobalHeap

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;externW MyCSDS

externNP SetOwner

externFP set_discarded_sel_owner

; extra debugging parameter for EntProcAddress to avoid RIPing if all 
; we are doing is a GetProcAddress to something that isn't there.
externNP EntProcAddress
cProc	FarEntProcAddress,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   entno
cBegin
if KDEBUG
	mov	cx,1
	cCall	EntProcAddress,<hExe,entno,cx>
else
	cCall	EntProcAddress,<hExe,entno>
endif
cEnd

if KDEBUG

;  AppLoaderEntProcAddress
;       This call added for the app loader.  The above call (FarEntProcAddress)
;       forces no RIPs.  When we're using the app loader, we really want
;       RIPs, so in debug we add this entry point.
;       This call ONLY exists in debug.

cProc	AppLoaderEntProcAddress,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   entno
cBegin
        xor     cx,cx           ;Force RIPs on this one
	cCall	EntProcAddress,<hExe,entno,cx>
cEnd

endif ; KDEBUG


externNP FindOrdinal
cProc	FarFindOrdinal,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmD   lpname
    parmW   fh
cBegin
	cCall	FindOrdinal,<hExe,lpName,fh>
cEnd


externNP LoadSegment
cProc	FarLoadSegment,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   segno
    parmW   fh
    parmW   isfh
cBegin
	cCall	LoadSegment,<hExe,segno,fh,isfh>
cEnd


externNP AllocSeg
cProc	FarAllocSeg,<PUBLIC,FAR,NODATA>
    parmD   pSegInfo
cBegin
	cCall	AllocSeg,<pSegInfo>
cEnd


externNP DeleteTask
cProc	FarDeleteTask,<PUBLIC,FAR,NODATA,ATOMIC>
    parmW taskID
cBegin
	cCall	DeleteTask,<taskID>
cEnd


externNP UnlinkObject
cProc	FarUnlinkObject,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	UnlinkObject
cEnd


externNP MyLower
cProc	FarMyLower,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	MyLower
cEnd


externNP MyUpper
cProc	FarMyUpper,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	 MyUpper
cEnd


externNP MyAlloc
cProc	FarMyAlloc,<PUBLIC,FAR,NODATA>
    parmW   aflags
    parmW   nsize
    parmW   nelem
cBegin
	cCall	MyAlloc,<aflags,nsize,nelem>
cEnd


externNP MyAllocLinear
cProc	FarMyAllocLinear,<PUBLIC,FAR,NODATA>
    parmW   aflags
    parmD   dwBytes
cBegin
	cCall	MyAllocLinear,<aflags,dwBytes>
cEnd


externNP MyLock
cProc	FarMyLock,<PUBLIC,FAR,NODATA>
    parmW   h1
cBegin
	cCall	MyLock,<h1>
cEnd


externNP MyFree
cProc	FarMyFree,<PUBLIC,FAR,NODATA>
    parmW   h2
cBegin
	cCall	MyFree,<h2>
cEnd

externNP genter
cProc	Far_genter,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	genter
cEnd

externNP gleave
cProc   Far_gleave,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
    cCall   gleave
cEnd

externNP lalign
cProc	Far_lalign,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	lalign
cEnd


externNP lrepsetup
cProc	Far_lrepsetup,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	lrepsetup
cEnd


if KDEBUG

externNP lfillCC
cProc	Far_lfillCC,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	 lfillCC
cEnd
endif

sEnd	CODE




sBegin	INITCODE

;-----------------------------------------------------------------------;
; LKExeHeader								;
; 									;
; Copy of LoadExeHeader (from LDHEADER.ASM) that has been stripped	;
; down to the minimum needed to load the new format .EXE header for	;
; KERNEL.EXE.								;
; 									;
; Arguments:								;
;	parmW	pMem							;
;	parmD	pfilename						;
; 									;
; Returns:								;
;	AX = segment of exe header					;
; 									;
; Error Returns:							;
;	AX = 0								;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES							;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Mar 19, 1987 08:35:32p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	LKExeHeader,<PUBLIC,NEAR>,<si,di,ds>
	parmW	pMem
	parmD   pfilename
	localW	nchars
cBegin
	lds	si,pfilename
	xor	ax,ax
	mov	al,ds:[si].opLen
	inc	ax			; include null byte
	mov	nchars,ax

	mov	ds,pMem
	xor	si,si
	mov	di,ds:[si].ne_enttab	; Compute size of resident new header
	add	di, 6			; Room for one block of entries
	push	si
	mov	si, ds:[si].ne_enttab	; Scan current entry table

calc_next_block:
	lodsw
	xor	cx, cx
	mov	cl, al
	jcxz	calc_ent_sized

	cmp	ah, ENT_UNUSED		; 6 bytes per unused block
	jne	calc_used_block
	add	di, 6
	jmps	calc_next_block

calc_used_block:
	errnz	<5-SIZE PENT>
	mov	bx, cx
	shl	bx, 1
	add	di, bx
	add	di, bx			; 5 bytes per entry
	add	di, cx

	add	si, bx
	add	si, cx			; Skip the block
	cmp	ah, ENT_MOVEABLE
	jne	calc_next_block

calc_moveable_block:
	add	si, bx
	add	si, cx			; Skip the block
	jmps	calc_next_block

calc_ent_sized:
	pop	si
	mov	cx,ds:[si].ne_cseg	; + 3 * #segments

; Reserve space for segment reference bytes

	add	di,cx
	shl	cx,1

; Reserve space for ns_handle field in segment table

	add	di,cx
	errnz	<10-SIZE NEW_SEG1>

if LDCHKSUM

; Reserve space for segment chksum table (2 words per segment)

	add	di,cx
	add	di,cx
endif


; Reserve space for file info block at end

	add	di,16			; 16 bytes of slop
	add	di,nchars		; + size of file info block

	xor	ax,ax			; Allocate a block for header
	cCall	IGlobalAlloc,<GA_MOVEABLE,ax,di>
	push	ax
	cCall	IGlobalLock,<ax>
	pop	ax
	push	dx
	cCall	IGlobalUnlock,<ax>
	pop	ax
	mov	es,ax			; ES:DI -> new header location
	xor	di,di
	cld				; DS:SI -> old header
	mov	cx,SIZE NEW_EXE		; Copy fixed portion of header
	cld
	rep	movsb
	mov	cx,es:[ne_cseg] 	; Copy segment table
	mov	es:[ne_segtab],di
recopyseg:

if ROM

; This code assumes kernel segments will not need to be reloaded from ROM
; and so doesn't set the ns_sector field like LoadExeHeader().

	lodsw				; ns_sector has segment selector in ROM
	mov	bx,ax
	stosw
else
	movsw				; ns_sector
endif
	movsw				; ns_cbseg
	lodsw				; ns_flags
	errnz	<4-ns_flags>
	and	ax,not NS286DOS 	; Clear 286DOS bits
if ROM
	or	ax,NENOTP+4000h+NSINROM+NSLOADED  ; library code in ROM
else
	or	ax,NENOTP+4000h 	; Mark library code segments
endif
	stosw
	movsw				; ns_minalloc
	errnz	<8-SIZE NEW_SEG>
if ROM
	mov	ax,bx
else
	xor	ax,ax
endif
	stosw				; one word for ns_handle field
	errnz	<10-SIZE NEW_SEG1>
	loop	recopyseg

recopysegx:
	mov	cx,es:[ne_restab]	; Copy resource table
	sub	cx,es:[ne_rsrctab]
	mov	es:[ne_rsrctab],di
	rep	movsb
rerestab:
	mov	cx,es:[ne_modtab]	; Copy resident name table
	sub	cx,es:[ne_restab]
	mov	es:[ne_restab],di
	rep	movsb

	mov	cx,es:[ne_imptab]	; Copy module xref table
	sub	cx,es:[ne_modtab]
	mov	es:[ne_modtab],di
	rep	movsb

	mov	es:[ne_psegrefbytes],di ; Insert segment reference byte table
	mov	cx,es:[ne_cseg]
	mov	al,0FFh
	rep	stosb			; initialize to not-loaded condition

	mov	es:[ne_pretthunks],di	; Setup return thunks

if LDCHKSUM
	mov	es:[ne_psegcsum],di	; Setup segment chksum table
	mov	cx,es:[ne_cseg]
	jcxz	resetsegcsumexit
	xor	ax,ax
	shl	cx,1			; Two words per segment
	rep	stosw
resetsegcsumexit:
endif
	mov	cx,es:[ne_enttab]	; Copy imported name table
	sub	cx,es:[ne_imptab]
	mov	es:[ne_imptab],di
	jcxz	reenttab
	rep	movsb

reenttab:
	mov	es:[ne_enttab],di
					; Scan current entry table
	xor	ax, ax			; First entry in block
	mov	bx, di			; Pointer to info for this block
	stosw				; Starts at 0
	stosw				; Ends at 0
	stosw				; And is not even here!

copy_next_block:
	lodsw				; Get # entries and type
	xor	cx, cx
	mov	cl, al
	jcxz	copy_ent_done

	mov	al, ah
	cmp	al, ENT_UNUSED
	jne	copy_used_block

	mov	ax, es:[bx].PM_EntEnd	; Last entry in current block
	cmp	ax, es:[bx].PM_EntStart	; No current block?
	jne	end_used_block

int 3
	add	es:[bx].PM_EntStart, cx
	add	es:[bx].PM_EntEnd, cx
	jmps	copy_next_block

end_used_block:
	mov	es:[bx].PM_EntNext, di	; Pointer to next block
	mov	bx, di
	add	ax, cx			; Skip unused entries
	stosw				; First in new block
	stosw				; Last in new block
	xor	ax, ax
	stosw				; End of list
	jmps	copy_next_block

copy_used_block:
	add	es:[bx].PM_EntEnd, cx	; Add entries in this block
	cmp	al, ENT_MOVEABLE
	je	copy_moveable_block

copy_fixed_block:
	stosb				; Segno
	movsb				; Flag byte
	stosb				; segno again to match structure
	movsw				; Offset
	loop	copy_fixed_block
	jmps	copy_next_block

copy_moveable_block:
	stosb				; ENT_MOVEABLE
	movsb				; Flag byte
	add	si, 2			; Toss int 3Fh
	movsb				; Copy segment #
	movsw				; and offset
	loop	copy_moveable_block
	jmps	copy_next_block

copy_ent_done:


	xor	bx,bx
	mov	es:[bx].ne_usage,1
	mov	es:[bx].ne_pnextexe,bx
	mov	es:[bx].ne_pautodata,bx

	mov	cx,nchars
	mov	es:[bx].ne_pfileinfo,di
	lds	si,pfilename
	rep	movsb

	SetKernelDS
	mov	ax,winVer
	mov	es:[bx].ne_expver,ax
if ROM
	or	es:[bx].ne_flags,NENONRES OR NEMODINROM ;have disc code & in ROM
else
	or	es:[bx].ne_flags,NENONRES ; Remember that we have
						; discardable code
endif
	UnSetKernelDS
	cCall	SetOwner,<es,es>
	mov	ax,es
reexit:
cEnd

ife ROM ;----------------------------------------------------------------

cProc	LKAllocSegs,<PUBLIC,NEAR>,<si,di,ds>
	parmW	hExe

	localW	fixed_seg
	localW	SegCount
cBegin
	mov	ds,hExe
	mov	si,ds:[ne_segtab]
	mov	di,ds:[si].ns_minalloc
	xor	ax,ax
	mov	bx,(GA_ALLOC_LOW or GA_CODE_DATA) shl 8
	cCall	IGlobalAlloc,<bx,ax,di>
	or	ax,ax
	jz	lkallocfail
	mov	fixed_seg,ax
	mov	ds:[si].ns_handle,ax
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED

	cCall	SetOwner,<ax,ds>

	add	si,SIZE NEW_SEG1	; NRES segment
	mov	di,ds:[si].ns_sector
	mov	SegCount, 0		; NRES and MISC segments

;;	  SetKernelDS	  es
;;	  cmp	  fWinX,0
;;	  UnSetKernelDS   es
;;	  je	  lk1
;;	  mov	  di,ds:[si].ns_cbseg
;;	  xchg	  ds:[si].ns_minalloc,di
;;	  xchg	  ds:[si].ns_sector,di
;;lk1:

SegLoop:
	inc	SegCount
	xor	ax,ax
	mov	bh,GA_DISCARDABLE + GA_SHAREABLE + GA_CODE_DATA
	mov	bl,GA_MOVEABLE + GA_DISCCODE
	cCall	IGlobalAlloc,<bx,ax,ax>
	or	ax,ax
	jz	lkallocfail
	mov	ds:[si].ns_handle,ax	; Handle into seg table
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED
	mov	bx,ax			; put handle into base register
	smov	es,ds
	call	set_discarded_sel_owner
	smov	es,0
	mov	bx,ds:[si].ns_sector	; Save MiscCode sector
	add	si,SIZE NEW_SEG1	; Next segment
	cmp	SegCount, 2
	jnz	SegLoop


; Allocate fixed block for kernel's data segment

	push	bx			; Save MisCode sector
	mov	bx,ds:[si].ns_minalloc
	xor	ax,ax
	cCall	IGlobalAlloc,<ax,ax,bx>
	pop	bx
	or	ax,ax
	jz	lkallocfail
	mov	ds:[ne_pautodata], si
	mov	ds:[si].ns_handle,ax
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED

	cCall	SetOwner,<ax,ds>

	mov	ax,di			; Return offset to NR segment
lkallocfail:
cEnd

endif ;ROM	---------------------------------------------------------

	nop				; Stop linker from padding segment

sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldopen.asm ===
TITLE   LDOPEN - Open and Delete Pathname primitives

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
.list

externFP AnsiUpper
externFP Int21Handler
externFP <lstrcpy>
ifdef FE_SB
externFP FarMyIsDBCSLeadByte
externFP FarMyIsDBCSTrailByte
endif
ifdef WOW
externFP GetDriveType
endif

;** Equates for the Directory Table code
DT_CURDIR       EQU     1
DT_WINDIR       EQU     2
ifndef WOW
DT_SYSDIR       EQU     3
DT_APPDIR       EQU     4
MAX_SEARCH      EQU     4
else
DT_SYS16DIR     EQU     3
DT_SYSDIR       EQU     4
DT_SYSWX86DIR   EQU     5
DT_APPDIR       EQU     6
MAX_SEARCH      EQU     6
endif


DataBegin

externB fInt21
externB OutBuf
externB szCannotFind1
externB szCannotFind2
externB szDiskCap
externB LastDriveSwapped
externB fNovell
externB fBooting
externW bufpos
externW cBytesWinDir
externW cBytesSysDir
externW TopPDB
externW curTDB
externD lpWindowsDir
externD lpSystemDir
externD pSysProc
externD pKeyProc
externD pKeyProc1
externD pSErrProc
externW wMyOpenFileReent

;** These variables needed to implement the app dir searching
externW loadTDB
externW fLMDepth

staticW myofint24,0

ifdef WOW
externD lpSystem16Dir
externW cBytesSys16Dir
externD lpSystemWx86Dir
externW cBytesSysWx86Dir
endif

;** Directory table for different search orders.  Pgm Management-aware!!

; DIRTABLE struc holds pointers to previously searched paths so we don't
;       repeat the path searches
DIRTABLE STRUC
dt_lpstr        DD      ?
dt_wLen         DW      ?
DIRTABLE ENDS

dtDirTable LABEL DWORD
        public dtDirTable

        DB      (SIZE DIRTABLE) * MAX_SEARCH DUP (0)

; These tables drive the search order loops, determining which paths
;       to search in which order.  The DOS/Novell path is always searched
;       last.

BootOrder LABEL BYTE
        DB      DT_SYSDIR
        DB      DT_WINDIR
        DB      0
DefaultOrder LABEL BYTE
        DB      DT_CURDIR
        DB      DT_WINDIR
ifdef WOW                          ; Search 16-bit system dir (\windir\system)
        DB      DT_SYS16DIR
endif
        DB      DT_SYSDIR
ifdef WOW                          ; Search Wx86 system dir (\windir\system32\Wx86)
        DB      DT_SYSWX86DIR
endif
        DB      DT_APPDIR
        DB      0
        public BootOrder, DefaultOrder

        ;** Static variables
szCurDir        DB      128 DUP (0)     ;Points to fully qualified current dir
pCurDirName     DW      0               ;Points to 8.3 filename
wCurDirLen      DW      0               ;Length of path minus 8.3 filename
        public pCurDirName, wCurDirLen, szCurDir

ifdef WOW
LastOFSearchEntry DW    0               ;Addr of last search table entry used
                                        ;for continuing the search.
OFContinueSearch DW     0               ;1 means continue last search
        public LastOFSearchEntry, OFContinueSearch
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyUpper
externNP PathDrvDSDX
externNP real_DOS

ifdef FE_SB
externNP MyIsDBCSLeadByte
externNP MyIsDBCSTrailByte
endif

;  These constants are the same as the OF_* values, but are a single byte
;       for efficiency
fReOpen equ     10000000b
fExist  equ     01000000b
fPrompt equ     00100000b
fCreate equ     00010000b
fCancel equ     00001000b
fVerify equ     00000100b
fSearch equ     00000100b
fDelete equ     00000010b
fParse  equ     00000001b

;** Flags to InternalOpenFile
IOF_SYSTEM      EQU     1

;!!!!!! Everything from here to the next !!!!! rewritten Aug 2-5 1991 [jont]

;-----------------------------------------------------------------------;
; OpenFile
;                                                                       ;
; OpenFile:  Opens the given file (with LOTS of options)                ;
;       The search order is defined above in the data section and is    ;
;       table-driven.                                                   ;
;                                                                       ;
; Arguments:                                                            ;
;       ParmD   lpstrSourceName                                         ;
;       ParmD   lpOFStruct                                              ;
;       ParmW   Command                                                 ;
;                                                                       ;
; Returns:                                                              ;
;       AX = file handle                                                ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = error code                                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 12, 1987 09:06:05p  -by-  David N. Weise   [davidw]          ;
; Added this nifty coment block.                                        ;
;                                                                       ;
;  August 5, 1991 -by- Jon Thomason [jont]                              ;
;       Rewrote large sections.  Made it table-driven to allow          ;
;       changing search paths.  Made it return extended error codes     ;
;       for all file not found errors.  Generally made it into a        ;
;       humanly-readable module.                                        ;
;                                                                       ;
;-----------------------------------------------------------------------;


cProc   IOpenFile, <PUBLIC,FAR>, <si,di,ds>
        parmD   lpSrcFile               ;String pointing to filename
        parmD   lpOFStruct              ;Points to OFSTRUCT
        parmW   wFlags                  ;LowB is DOS flags, High is OF flags
        localD  lpDestDir               ;Points to dest dir in OFSTRUCT
cBegin
        SetKernelDS

        ;** If the file is to be reopened, do it
        test    BYTE PTR wFlags[1],fReopen ;Reopen file?
        jz      IOF_NoReopen            ;No
        les     di,lpOFStruct           ;Point to structure
        cCall   ReOpenFile, <es,di,wFlags> ;Reopen the file
        jmp     IOF_End                 ;Done
IOF_NoReopen:

ifdef WOW
        ; Reset LastOFSearchEntry if we're not continuing an earlier search
        cmp     OFContinueSearch,0
        jne     @F
        mov     LastOFSearchEntry,0
@@:
endif

        ;** Get a pointer into the OFSTRUCT
        mov     di,WORD PTR lpOFStruct[0] ;Point to structure
        lea     di,[di].opFile          ;Point to string
        mov     WORD PTR lpDestDir[0],di ;Save in temp variable
        mov     di,WORD PTR lpOFStruct[2] ;Get the selector
        mov     WORD PTR lpDestDir[2],di


        ;** Parse the filename and prepare for searching
        mov     bx,dataOFFSET szCurDir  ;Point to dest string
        les     si,lpSrcFile            ;Point to source string
if 0
        krDebugOut DEB_WARN,"WOW16 IOpenFile:Filename @ES:SI"
endif
        cCall   ParseFileName, <es,si,ds,bx,wFlags>

        ;** Check for error
        or      ax,ax                   ;Error?
        jnz     @F                      ;No

        mov     ax,0                    ;Flag that this is a parse error
        mov     bx,dataOFFSET szCurDir  ;pass lpSrcFile as error string
        cCall   ErrorReturn, <lpOFStruct,ds,bx,lpSrcFile,wFlags,ax>
        jmp     IOF_End                 ;Get out
@@:
        ;** If they just wanted to parse, fill in the structure and return
        test    BYTE PTR wFlags[1],fParse ;Parse only?
        jz      @F                      ;No, skip this
        mov     bx,dataOFFSET szCurDir  ;Point to full pathname with DX:BX
        mov     dx,ds
        xor     ax,ax                   ;No file handle
        jmp     IOF_DoCopy              ;Mimic successful file open
@@:
        ;** Save return values for future use
        mov     pCurDirName,bx          ;Points to 8.3 name
        mov     wCurDirLen,cx           ;Length of path portion

        ;** See if we should path search (flag returned in DX)
        or      dx,dx
        jz      IOF_InitSearch          ;Do the search

        ;** Try to open the file without searching any other dirs
        les     bx,lpDestDir            ;Point to dest dir
        mov     di,dataOFFSET dtDirTable ;Point to the start of the DirTable
        cCall   GetPath, <DT_CURDIR,di,es,bx> ;Dest dir returned in ES:BX
        cCall   OpenCall, <es,bx,wFlags> ;Try to open it
        jc      @F
        jmp     IOF_Success
@@:     jmp     IOF_Error         ;File found but problem opening

        ;** Point to the proper search order
IOF_InitSearch:
        SetKernelDS
ifdef WOW
        cmp     OFContinueSearch,0
        je      @F
        mov     OFContinueSearch,0      ;consumed the flag, reset it
        mov     si,LastOFSearchEntry
        or      si,si                   ;Were we searching at all?
        jnz     IOF_WereSearching       ;Yes
        jmp     short IOF_FileNotFound  ;No searching, so give up now.
IOF_WereSearching:
        cmp     si,-1                   ;Already tried SearchPath?
        jne     IOF_RestartSearch       ;No, pick up where we left off in order
IOF_FileNotFound:
        mov     ax,2                    ;SearchPath found it last time, so
        jmp     IOF_Error               ;it won't find a different one this
                                        ;time, se we return File not found
IOF_RestartSearch:
        inc     si
        mov     LastOFSearchEntry,si
        mov     al,[si]
        cbw
        or      al,al
        mov     di,dataOFFSET dtDirTable;Point to the start of the DirTable
        jnz     IOF_SearchLoop          ;Pick up with next in search order
        jmp     short IOF_SearchPath    ;Restarting after last in search
                                        ;order, so try DOS/Novell path.
@@:
endif
        mov     si,dataOFFSET DefaultOrder
        cmp     fBooting,0              ;Booting?
        jz      IOF_DoSearch            ;No
        mov     si,dataOFFSET BootOrder
IOF_DoSearch:
ifdef WOW
        mov     LastOFSearchEntry,si
endif
        mov     al,[si]                 ;Get the first search code
        cbw
        mov     di,dataOFFSET dtDirTable ;Point to the start of the DirTable

        ;** Loop through until we have no more directories to search or
        ;**     until the file is found
IOF_SearchLoop:
        
        ;** Get the path and filename for this index entry
        les     bx,lpDestDir            ;Point to dest dir
        cCall   GetPath, <ax,di,es,bx>  ;Returns pointer to dest dir in ES:BX
        or      bx,bx                   ;Duplicate dir?
        jz      IOF_Continue            ;Yes, skip this

        ;** Try to open the file
        cCall   OpenCall, <es,bx,wFlags> ;Try to open it
        jnc     IOF_Success             ;File was found
        cmp     ax,3                    ;Errors 3 or less mean file not found
        ja      IOF_Error               ;File found but problem opening

        ;** File not found, so try next path if any
IOF_Continue:
        add     di,SIZE DIRTABLE        ;Bump to next DirTable entry
        inc     si                      ;Bump to next code in list
ifdef WOW
        mov     LastOFSearchEntry,si
endif
        mov     al,[si]                 ;Get this code
        cbw                             ;Make it a WORD
        or      al,al                   ;Done?
        jnz     IOF_SearchLoop          ;No

        ;** Try the DOS/Novell path next
ifdef WOW
IOF_SearchPath:
        xor     si,si
        dec     si
        mov     LastOFSearchEntry,si
endif
        les     di,lpDestDir            ;Point to the dest dir
        mov     si,pCurDirName          ;Point to the 8.3 name
        cCall   SearchFullPath, <ds,si,es,di,wFlags>
        jc      IOF_Error               ;Not found here either

        ;** On SUCCESS, we come here.  Delete the file and close if
        ;**     necessary
IOF_Success:
        mov     bx,WORD PTR lpDestDir[0] ;Point to filename with DX:BX
        mov     dx,WORD PTR lpDestDir[2]
IOF_DoCopy:
        les     si,lpOFStruct           ;Point to OFSTRUCT
        cCall   SuccessCleanup, <dx,bx,es,si,wFlags,ax> ;Finish up
        jmp     SHORT IOF_End

        ;** On ERROR, complete the structure and return the error code
IOF_Error:
        les     si,lpOFStruct
        mov     bx,dataOFFSET szCurDir  ;Point to current dir
        cCall   ErrorReturn, <es,si,ds,bx,ds,pCurDirName,wFlags,ax>
IOF_End:

cEnd


;---------------------------------------------------------------------------
;  ReOpenFile
;
;       Does a fast reopen of a file that has already been opened.
;       Returns proper value in AX for return from OpenFile
;
;       Trashes everything but si,di,ds
;
;---------------------------------------------------------------------------

cProc   ReOpenFile, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpStruct                ;LPOFSTRUCT parameter
        parmW   wFlags                  ;OpenFile flags
        localW  hFile
cBegin
        ;** Set up for the reopen
        lds     si,lpStruct             ;Point to the OFSTRUCT
        lea     dx,[si].opFile          ;DS:DX -> path
        call    PathDrvDSDX             ;Make sure DRV letter is valid
        jc      ROF_SetDrvErr

        ;** Set up for either an OPEN or a CREATE
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open
        jnz     ROF_CreateIt            ;In create case, we just do it
        mov     ah,3dh                  ;Open file call
        jmp     SHORT @F
ROF_CreateIt:
        mov     ah,3ch                  ;Create file call
@@:     xor     cx,cx                   ;Default file attributes
        call    real_DOS                ;Skip overhead of Int21Handler
        jnc     ROF_10                  ;Continue on no error
        jmp     SHORT ROF_GetError      ;Get out on error

ROF_SetDrvErr:
        lds     si,lpStruct             ;Point to the OFSTRUCT
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     ROF_End                 ;Error

ROF_10: mov     bx,ax                   ;Get handle
        mov     hFile,ax                ;Save handle for later
ifdef WOW
        xor     cx,cx
        xor     dx,dx
        push    ds
        SetKernelDS ds
        cmp     fLMdepth,cx             ; Called From Loader ?
        pop     ds
        UnSetKernelDS ds
        jnz      @f                     ; Yes -> Ignore Date/Time
endif
        mov     ax,5700h                ;Get time and date of file
        DOSCALL
@@:
        mov     ax,bx                   ;Put file handle back in ax
        test    BYTE PTR wFlags[1],fVerify ;Should we test time/date?
        jz      ROF_VerifyOK
        cmp     [si].opDate,dx          ;Same date as original?
        jnz     ROF_ErrorClose          ;No
        cmp     [si].opTime,cx          ;Same time as original?
        jnz     ROF_ErrorClose          ;No
ROF_VerifyOK:
        mov     es:[si].opTime,cx       ;Save the date and time
        mov     es:[si].opDate,dx

        ;** See if we were supposed to just get the name, or find file
        test    BYTE PTR wFlags[1],fDelete or fExist
        jz      ROF_Done                ;Nope, we're done

        ;** If the user specified OF_DELETE, we don't want
        ;**     the file open, so close it here.
        ;**     NOTE: THIS CODE IS DUPLICATED IN FillOFStruct()!!!!
        mov     bx,hFile                ;Get handle
        mov     ah,3Eh                  ;Close the file
        DOSCALL

        ;** See if we should delete the file
        test    BYTE PTR wFlags[1],fDelete
        jz      ROF_Done                ;Nope, we're done
        smov    ds,es                   ;DS:DX points to full pathname
        UnSetKernelDS
        lea     dx,[si].opFile
        mov     ah,41h                  ;Delete the file
        DOSCALL
        jnc     ROF_Done                ;Return the file handle for compat.

        ;** Get extended error always
ROF_GetError:
        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes regs
        push    si
        push    es
        DOSCALL
        pop     es
        pop     si
        pop     bp
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     SHORT ROF_End

ROF_ErrorClose:
        mov     bx,hFile                ;Get the file handle
        mov     ah,3Eh                  ;Close the bogus file
        DOSCALL
        mov     ax,-1                   ;Error return value
        lds     si,lpStruct             ;Point to the OFSTRUCT
        mov     [si].opXtra,0           ;Non-DOS error
        jmp     SHORT ROF_End           ;Get out

ROF_Done:
        mov     ax,hFile                ;Proper return value for OpenFile
ROF_End:
cEnd


;----------------------------------------------------------------------------
;  ParseFileName
;
;       Prepares to do the various file searches by returning a pointer
;       to the fully qualified path  and to the "pure" filename
;       (just the 8.3 name).
;
;       Returns:
;               AX = TRUE/FALSE function successful (if F, nothing else valid)
;               BX points to start of 8.3 filename
;               CX = Length of path portion of filename
;               DX = TRUE/FALSE: Indicates whether path should be searched
;
;----------------------------------------------------------------------------

cProc   ParseFileName, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpSrcName               ;Passed in pathname
        parmD   lpDestName              ;String to receive pathname
        parmW   wFlags                  ;Command WORD to OpenFile
        localW  wPathLen                ;Length of path portion of filename
cBegin
        ;** Get the fully qualified pathname in lpDestName
        lds     si,lpSrcName            ;DS:SI points to source file
        les     di,lpDestName           ;ES:DI points to file buffer
        call    ParseFile               ;Form a complete name in buffer
                                        ;  Returns dir len in CX when failing
        or      ax,ax                   ;Successful?
        jz      PFN_End                 ;No, get out
        mov     wPathLen,dx             ;Save length of path (no 8.3)

        ;** This section handles the fSearch flag.  This flag is used to
        ;**     do a path search even when we have a path in front of
        ;**     the filename.
        test    BYTE PTR wFlags[1],fSearch ;Do search even with path?
        jz      PF_NoSearch             ;No.
        xor     di,di                   ;Indicate no slashes
PF_NoSearch:         

        ;** Convert the filename to OEM
        lds     si,lpDestName           ;Point to full path
        cCall   MyAnsiToOem,<ds,si,ds,si>

        ;** Return arguments
        mov     ax,1                    ;Success
        mov     bx,WORD PTR lpDestName[0] ;Get the offset of the string
        mov     cx,wPathLen             ;Length of path portion of name
        add     bx,cx                   ;Point to start of string
        inc     bx                      ;Skip slash
        mov     dx,di                   ;Slashes/path search flag

PFN_End:
cEnd


;----------------------------------------------------------------------------
;  GetPointer
;
;       Given an index number, returns a pointer to the path associated
;       with this index and its length
;
;       Returns the lpstr in ES:BX, length in CX
;
;       Depends on the order of the DT_* indices
;       Depends on Kernel's DS being set, does not trash it
;
;----------------------------------------------------------------------------

cProc   GetPointer, <PUBLIC,NEAR>, <si,di>
        parmW   wIndex                  ;Index is from search order table
cBegin
        CheckKernelDS
        ReSetKernelDS

        ;** Decode the index numbers
        mov     ax,wIndex               ;Get the index
        dec     ax                      ;DT_CURDIR?
        jz      GT_CURDIR
        dec     ax                      ;DT_WINDIR?
        jz      GT_WINDIR
ifndef WOW
        dec     ax                      ;DT_SYSDIR?
        jz      GT_SYSDIR
else
        dec     ax                      ;DT_SYS16DIR?
        jz      GT_SYS16DIR
        dec     ax                      ;DT_SYSDIR?
        jz      GT_SYSDIR
        dec     ax                      ;DT_SYSWX86DIR?
        jz      GT_SYSWX86DIR
endif
        ; Must be DT_APPDIR

        ;** Find the app's dir
IF KDEBUG
        cmp     fBooting,0              ;Booting?
        jz      @F                      ;No, whew!
        int     1                       ;No app dir during boot process
        int     1
@@:
ENDIF
        ;** Figure out if we should use curTDB or loadTDB.  This is
        ;**     determined by the number of times LoadModule has recursed.
        ;**     We only use the loadTDB pointer if we're in LoadModule the
        ;**     second time and the pointer is not zero.  Otherwise, we
        ;**     use the curTDB pointer.  If we don't do this check, we
        ;**     end up getting the path of the app calling LoadModule
        cmp     fLMDepth,2              ;In LoadModule 2 times?
        jb      GT_UseCurTDB            ;Yes, use curTDB
        mov     ax,LoadTDB              ;Get loadTDB
        or      ax,ax                   ;NULL?
        jnz     GT_UseLoadTDB           ;No, assume it's OK

        ;** Get a pointer to the path stored in the module database
GT_UseCurTDB:
        mov     ax,curTDB               ;Get the TDB pointer
GT_UseLoadTDB:
        mov     es,ax                   ;Point with DS
        mov     es,es:[TDB_pModule]     ;Point to the module database
IFDEF ROM
        ; if this is in ROM, then return  0 in CX
        ; makes no sense to get the app's dir, if app is in ROM
        test    es:[ne_flags], NEMODINROM
        jz      @f
        xor     cx, cx
        jmp     SHORT GT_Done
@@:
ENDIF
        mov     di,es:[0ah]             ;Points to EXE path string (sort of)
                                        ;  (High word of CRC in exe hdr)
        ;** Copy the entire string into the buffer
        add     di,8                    ;Move past data garbage
        push    di                      ;Save start of string
        cCall   GetPureName             ;ES:DI points just after the '\'
        dec     di                      ;ES:DI points to '\'
        pop     bx                      ;ES:BX points to start of string
        mov     cx,di                   ;Compute length of path, not filename
        sub     cx,bx                   ;  (not including \)
        jmp     SHORT GT_Done

        ;** Get the current directory pointer and length
GT_CURDIR:
        smov    es,ds                   ;ES:BX points to szCurDir
        mov     bx,dataOFFSET szCurDir
        mov     cx,wCurDirLen           ;Get path length
        jmp     SHORT GT_Done

GT_WINDIR:
        les     bx,lpWindowsDir         ;Point to windir
        mov     cx,cBytesWinDir
        jmp     SHORT GT_Done

GT_SYSDIR:
        les     bx,lpSystemDir          ;Point to sysdir
        mov     cx,cBytesSysDir
ifdef WOW
        jmp     SHORT GT_Done

GT_SYS16DIR:
        les     bx,lpSystem16Dir        ;Point to sys16dir
        mov     cx,cBytesSys16Dir
        jmp     SHORT GT_Done

GT_SYSWX86DIR:
        les     bx,lpSystemWx86Dir
        mov     cx,cBytesSysWx86Dir
        ;jmp     SHORT GT_Done
endif ;WOW

GT_Done:
        
cEnd


;----------------------------------------------------------------------------
;  GetPath
;
;       Gets the path associated with the given index.  The 8.3 filename
;       is appended to the end of the path and this is copied into the
;       destination directory.  A pointer to this directory is returned
;       in ES:BX or BX is NULL if the directory to be searched would be
;       a duplicate.
;
;       Assumes (and does not trash) kernel's DS
;
;       Calls: GetPointer
;
;----------------------------------------------------------------------------

cProc   GetPath, <PUBLIC,NEAR>, <si,di>
        parmW   wIndex                  ;Index from search order table
        parmW   pDirTable               ;Points to current DIRTABLE entry
        parmD   lpDest                  ;Place to copy filename
cBegin
        CheckKernelDS

        ;** Gets the pointer and length of the requested string
        cCall   GetPointer, <wIndex>    ;lpstr in ES:BX, len in CX
IFDEF ROM
        or      cx, cx                  ; if in ROM && APPDIR
        jnz     @f
        xor     bx, bx
        jmp     SHORT GP_End
@@:
ENDIF
        ;** Save it in the table
        mov     di,pDirTable            ;Point to the table entry
        mov     WORD PTR [di].dt_lpstr[0],bx
        mov     WORD PTR [di].dt_lpstr[2],es
        mov     [di].dt_wLen,cx

        ;** Check for duplicates
        mov     si,bx                   ;Point to string with SI
        mov     bx,dataOFFSET dtDirTable ;Point to the start of the table
GP_Loop:
        cmp     bx,di                   ;Checked everything before us yet?
        je      GP_Done                 ;Yes
        
        ;** Compare the strings
        cmp     cx,[bx].dt_wLen         ;Compare lengths
        jne     GP_Continue             ;No dup here
        mov     dx,cx                   ;Save len in DX
        push    si
        push    di
        push    ds
        les     di,ds:[di].dt_lpstr     ;Point to the strings to be compared
        lds     si,ds:[bx].dt_lpstr
        repe    cmpsb                   ;Compare the strings
        pop     ds
        pop     di
        pop     si
        or      cx,cx                   ;At end of string?
        jz      GP_FoundMatch           ;Yes, we matched so ignore this string
        mov     cx,dx                   ;Get len back in CX
GP_Continue:
        add     bx,SIZE DIRTABLE        ;Bump to next table entry
        jmp     GP_Loop

GP_FoundMatch:
        mov     WORD PTR [di].dt_lpstr[0],0 ;Null out this entry
        mov     WORD PTR [di].dt_lpstr[2],0
        mov     [di].dt_wLen,0
        xor     bx,bx                   ;Return NULL
        jmp     SHORT GP_End

GP_Done:
        ;** Copy the string in
        push    ds                      ;Save DS around this
        lds     si,[di].dt_lpstr        ;Return ES:BX pointing to string
        les     di,lpDest               ;Point to buffer to copy string to
        mov     bx,di                   ;Point with BX to struct
        rep     movsb                   ;Copy the strings
        pop     ds                      ;Restore KERNEL's DS

        ;** Put a '\' only if needed
IFDEF FE_SB
        push    si
        push    di
        mov     si,word ptr lpDest[0]       ;es:si -> string address
        dec     di                          ;di points to the last valid byte
        call    MyIsDBCSTrailByte           ;the last byts a DBCS trailing byte?
        pop     di
        pop     si
        jnc     GP_DoSlash                  ;yes, go ahead to append a '\'
                                            ;no, fall through
ENDIF
        cmp     BYTE PTR es:[di - 1],'\';Terminating slash?
        je      GP_SkipSlash            ;Yes
        cmp     BYTE PTR es:[di - 1],'/';Terminating slash?
        je      GP_SkipSlash            ;Yes
GP_DoSlash:
        mov     al,'\'                  ;Get the slash
        stosb                           ;  and write it
GP_SkipSlash:

        ;** Copy the filename
        mov     si,pCurDirName          ;Point to the 8.3 filename
        call    strcpyreg
;GP_83Loop:
;       lodsb                           ;Get the char
;        stosb                           ;  and write it
;        or      al,al                   ;Done?
;        jnz     GP_83Loop               ;Nope
                                        ;Returns ES:BX points to filename
GP_End:
cEnd


;----------------------------------------------------------------------------
;  OpenCall
;
;       Does the open/create file call.  The file is either opened
;       or created.  The handle or the error code is returned.
;       The extended error code is returned only if the error was not
;       that the file or path was not found (errors 2 & 3).
;       Carry is set on error.
;
;----------------------------------------------------------------------------

cProc   OpenCall, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpString                ;String to open
        parmW   wFlags                  ;OpenFile flags
        localW  wInt21AX                ;Int 21 AX value
cBegin
        ;** HACK to allow SearchPath to use this call.
        ;**     If wFlags is -1, look for flags preset in AX
        cmp     wFlags,-1               ;wFlags?
        jnz     OC_Normal               ;Yes, proceed normally
        mov     wInt21AX,ax             ;Save these flags
        jmp     SHORT OC_10             ;  and go on

        ;** Set up for either an OPEN or a CREATE
OC_Normal:
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open
        jnz     OC_CreateIt             ;In create case, we just do it
        mov     ah,3dh                  ;Open file call
        mov     wInt21AX,ax             ;Save in temp var
        jmp     SHORT OC_10
OC_CreateIt:
        mov     ah,3ch                  ;Create file call
        and     al,3                    ;Strip incompatbile share bits, etc.
        mov     wInt21AX,ax             ;Save it
        jmp     SHORT OC_DoDOSCall      ;Just do it in create case

OC_10:  SetKernelDS
        cmp     fNovell,0               ;On Novell?
        je      OC_DoDOSCall            ;No, just do normal stuff

        ;** We do a Get Attribute call instead of trying to open the file
        ;**     because doing a normal file open on Novell causes them
        ;**     to search their entire path.
        lds     dx,lpString             ;Get the pathname
        mov     ax,4300h                ;Get file attributes
        DOSCALL                         ;Does the file exist?
        jc      OC_NotThere             ;No

        ;** Try to open the file here.  In case of Novell, we already know
        ;**     it's here, so now open it
OC_DoDOSCall:
        xor     cx,cx                   ;Normal files ONLY!!
        mov     ax,wInt21AX             ;Get function code + access flags
        lds     dx,lpString             ;Get the pathname
        DOSCALL                         ;Try to open the file
        jc      OC_NotThere             ;File can't be opened
        jmp     SHORT OC_FileOpened     ;Success

OC_NotThere:
        cmp     ax,3                    ;Errors 2 & 3 are file not found
        jbe     OC_NoExtError           ;No extended error for file not found
        SetKernelDS
        cmp     wMyOpenFileReent, 0     ;No ext err for MyOpenFile
        jnz     OC_NoExtError
        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes bp
        DOSCALL
        pop     bp
OC_NoExtError:
        stc                             ;Return error

OC_FileOpened:                          ;CY must be clear here on success

cEnd


;----------------------------------------------------------------------------
;  SearchFullPath
;
;       Searches the full DOS/Novell path for the file
;
;       Returns the file handle on success or the error code on failure
;       Carry set on error
;
;----------------------------------------------------------------------------

cProc   SearchFullPath, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpSource                ;8.3 filename
        parmD   lpDest                  ;Place to copy pathname
        parmW   wFlags                  ;OpenFile flags
        localW  wInt21AX
cBegin
        ;** Get the AX WORD for the DOS call
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open?
        mov     ah,3dh                  ;Default to open
        jz      @F
        mov     ah,3ch                  ;Create call
@@:     mov     wInt21AX,ax             ;Save it for later

        ;** Use SearchPath() to find the file for us
        push    ds                      ;Save DS across this
        les     di,lpDest               ;Point to usable dest buffer
        lds     si,lpSource             ;Point to source string
        UnsetKernelDS
        cCall   <FAR PTR SearchPath>,<ds,si,es,di,ax>
        pop     ds
        ResetKernelDS
        cmp     ax,-1
        jne     SFP_FoundIt             ;Found the file
        mov     ax,bx                   ;Get error code from SearchPath
        cmp     ax,3                    ;Not found?
        ja      SFP_Error               ;Found but error

        ;** Now try the Novell path if it's there
        cmp     fNovell,0               ;On Novell?
        je      SFP_Error               ;Nope.  Nothing more to try so error
        lds     dx,lpSource             ;Point to 8.3 filename
        UnsetKernelDS
        xor     cx,cx                   ;Normal file type
        mov     ax,wInt21AX             ;Get open or create call plus attrs
        DOSCALL                         ;Do it
        jc     SFP_Error                ;Didn't find it

SFP_FoundIt:
        clc
        jmp     SHORT SFP_End

SFP_Error:
        stc

SFP_End:                                ;Carry should be set/clear correctly
cEnd


;----------------------------------------------------------------------------
;  SuccessCleanup
;
;       Builds the OFSTRUCT structure on a successful open.
;       Closes and deletes file if requested.
;
;----------------------------------------------------------------------------

cProc   SuccessCleanup, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpGoodPathName          ;Successful path name        
        parmD   lpOFStruct              ;OFSTRUCT param to OpenFile
        parmW   wFlags                  ;OpenFile flags
        parmW   hFile                   ;File handle
cBegin
        ;** Compute the length of the string and OFSTRUCT
        les     di,lpGoodPathName       ;Point to the new pathname
        xor     al,al                   ;Get a zero byte
        xor     cx,cx                   ;Up to 64K
        dec     cx
        repne   scasb                   ;Search for the zero byte
        neg     cx
        mov     ax,cx                   ;Get a copy in AX
        add     ax,(SIZE OPENSTRUC) - 3 ;Length of structure including string

        ;** Copy the successful pathname into the OFSTRUCT if necessary
        dec     cx                      ;This now is string + zero byte len
        les     di,lpOFStruct           ;Point to dest buffer
        lea     di,[di].opFile
        cmp     di,WORD PTR lpGoodPathName[0] ;Offsets the same?
        jne     FOF_DoCopy              ;No, do it
        mov     dx,es                   ;Compare sels
        cmp     dx,WORD PTR lpGoodPathName[2] ;Same?
        je      FOF_NoCopy              ;Yes, no copy needed
FOF_DoCopy:
        lds     si,lpGoodPathName       ;Point to successful path again
        UnSetKernelDS
        rep     movsb                   ;Copy it
FOF_NoCopy:

        ;** Fill out remainder of OFSTRUCT
        les     si,lpOFStruct           ;Point to OFSTRUCT with ES:SI
        lea     di,[si].opFile          ;  and to the pathname with ES:DI
        mov     es:[si].opXtra,0        ;Zero the error
        mov     es:[si].opLen,al        ;Save structure length
        call    AreBooting              ;AreBooting checks Int21 hooks inst
        mov     ah,1                    ;Always booting from hard drive
        jz      FO_NoCheckDrive         ;Int 21 hooks NOT installed yet
        mov     al,es:[di]              ;ES:DI points to string
        or      al,20H                  ;Force it lowercase
        sub     al,'a'                  ;Drive number, zero based
        cbw
        mov     di,ax                   ;Drive number in DI
        call    IsFloppy                ;Returns floppy status in ZF
        mov     ah,0                    ;Zero in case it's a floppy
        jz      FO_NoCheckDrive         ;Must be a floppy disk
        inc     ah                      ;Non-removable media
FO_NoCheckDrive:
        mov     es:[si].opDisk,ah       ;Tell 'em the type of disk
        ;** Get the current file date and time
        mov     bx,hFile                ;Get file handle
        mov     ax,5700h                ;Get date and time
ifdef WOW
        xor     cx,cx
        xor     dx,dx
        push    ds
        SetKernelDS ds
        cmp     fLMdepth,cx             ; Called From Loader ?
        pop     ds
        UnSetKernelDS ds
        jnz      @f                     ; Yes -> Ignore Date/Time
endif
        DOSCALL
@@:
        mov     es:[si].opTime,cx       ;Save the date and time
        mov     es:[si].opDate,dx

        ;** See if we were supposed to just get the name, or find file
        test    BYTE PTR wFlags[1],fExist OR fDelete
        jz      FO_Done                 ;Nope, we're done

        ;** If the user specified OF_EXIST or OF_DELETE, we don't want
        ;**     the file open, so close it here
        ;**     NOTE: THIS CODE IS DUPLICATED IN ReopenFile()!!!!
        mov     bx,hFile                ;Get the handle
        mov     ah,3Eh                  ;Close the file
        DOSCALL
                                        ;We leave the bogus value in hFile
                                        ;  for 3.0 compatibility

        ;** If OF_DELETE is set, we simply delete the file
        test    BYTE PTR wFlags[1],fDelete
        jz      FO_Done
        smov    ds,es                   ;DS:DX points to full pathname
        UnSetKernelDS
        lea     dx,[si].opFile
        mov     ah,41h                  ;Delete the file
        DOSCALL
        mov     ax,1                    ;TRUE return value
        jnc     FO_Done                 ;For 3.0 compatiblity

        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes regs
        push    si
        DOSCALL
        pop     si
        pop     bp
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     SHORT FO_END

FO_Done:
        mov     ax,hFile                ;Proper return value for OpenFile

FO_End:
cEnd
        

;----------------------------------------------------------------------------
;  ErrorReturn
;
;       Fills in the return information for error conditions.
;       Returns the proper return value for OpenFile
;
;----------------------------------------------------------------------------

cProc   ErrorReturn, <NEAR,PUBLIC>,<si,di,ds>
        parmD   lpOFStruct              ;OFSTRUCT given to OpenFile
        parmD   lpPath                  ;Path returned, even when invalid
        parmD   lpError                 ;Text for error box
        parmW   wFlags                  ;OpenFile flags
        parmW   wErrCode                ;Error code already computed
cBegin
        UnSetKernelDS
        cmp     wErrCode,0              ;Parse error?
        jnz     @F                      ;No
        mov     wErrCode,2              ;Mimic "File not found" error
        jmp     SHORT ER_ReturnError    ;Never prompt on parse error
@@:     test    BYTE PTR wFlags[1],fPrompt ;Should we do the dialog?
        jz      ER_ReturnError          ;No, return error code
        call    AreBooting              ;if we're still booting, don't prompt
        jz      ER_ReturnError
        lds     di,lpError
        cmp     BYTE PTR ds:[di],0      ;Don't prompt with NULL string.
        je      ER_ReturnError

        cCall   Prompt, <ds,di>         ;Prompt with error string.

ER_ReturnError:
        SetKernelDS
        les     si,lpOFStruct           ;Point to structure again
        mov     ax,wErrCode             ;Get the error code
        mov     es:[si].opXtra,ax       ;In OFSTRUCT, this is the error code
        lea     di,[si].opFile          ;Point to dest string
        lds     si,lpPath               ;Point to the path
        call    strcpyreg
;ER_Copy:
;       lodsb                           ;Copy the sz string for PowerPoint
;        stosb
;        or      al,al                   ;Done?
;        jnz     ER_Copy                 ;No
        UnSetKernelDS
        mov     ax,-1
cEnd


;!!!!!!!!!!!!!! Everything after this is old


;---------------------------------------------------------------------------
;  AreBooting
;
;       Check to see if DOS hook available
;
;---------------------------------------------------------------------------
AreBooting  PROC        NEAR
        push    ds
        SetKernelDS
        cmp     fInt21,0
        pop     ds
        UnSetKernelDS
        ret
AreBooting  ENDP

;---------------------------------------------------------------------------
;  FarGetEnv
;
;       Gets the correct environment, boot time or no
;
;---------------------------------------------------------------------------

FarGetEnv       PROC    FAR
        SetKernelDS
        mov     si,curTDB
        or      si,si
        jz      boot_time
        mov     ds,si
        UnSetKernelDS
        mov     ds,ds:[TDB_PDB]
not_boot_time:
        mov     ds,ds:[PDB_environ]
        xor     si,si
        ret
boot_time:
        ReSetKernelDS
        mov     ds,TopPDB
        UnSetKernelDS
        jmps    not_boot_time
FarGetEnv       ENDP


;-----------------------------------------------------------------------;
; SearchPath                                                            ;
;                                                                       ;
; Searches the PATH as defined in the environment for the given file.   ;
;                                                                       ;                                                                       ;
; Arguments:                                                            ;
;       ParmD   pName    Pointer to name                                ;
;       ParmD   pBuffer  Pointer to temporary buffer                    ;
;       ParmW   Attr     AX paramter for DOS (Open, etc.)               ;
;                                                                       ;
; Returns:                                                              ;
;       AX != 0                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1, BX is error code                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DS                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,DI,SI,ES                                               ;
;                                                                       ;
; Calls:                                                                ;
;       GetPureName                                                     ;
;       GetFarEnv                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 12, 1987 08:57:48p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   SearchPath,<PUBLIC,FAR>
        ParmD   pName                   ; Pointer to name
        ParmD   pBuffer                 ; Pointer to temporary buffer
        ParmW   Attr                    ; AX paramter for DOS (Open, etc.)

        LocalD  pPureName               ; pointer to stripped name
cBegin
        les     di,pName
        call    GetPureName
        mov     pPureName.off,di
        mov     pPureName.sel,es

        push    cs
        call    near ptr FarGetEnv
        mov     bx, 3                   ; preset error to "path not found"
spth2:  cmp     byte ptr [si],0         ; no more enviroment
        jz      spthNo

        lodsw
        cmp     ax,'AP'                 ; Look for PATH=
        jnz     spth3
        lodsw
        cmp     ax,'HT'
        jnz     spth3
        lodsb
        cmp     al,'='
        jz      spth4
spth3:  lodsb
        or      al,al
        jnz     spth3
        jmp     spth2

spth4:  les     di,pBuffer
spth5:  lodsb
        stosb
        cmp     al,";"
        jz      spth6
        or      al,al
        jnz     spth5
        dec     si

spth6:  mov     al,'\'
ifdef   FE_SB
        push    si
        push    di
        mov     si,word ptr pBuffer     ; buffer address
        dec     di                      ; point di to the byte before ';'
        call    MyIsDBCSTrailByte       ; is it a DBCS trailing byte?
        pop     di
        pop     si
        jnc     spth6a                  ;yes, overwrite ';' with '\'
endif
        cmp     es:[di-2],al            ; path terminated with '\'
        jnz     spth6a
        dec     di
spth6a: mov     es:[di-1],al
        push    ds
        push    si
        cCall   MyAnsiToOem,<pPureName,es,di>

        ;** Call the OpenCall function to search for the file.  It calls
        ;**     the extended error function on failure
        les     si,pBuffer              ;Point to buffer
        mov     ax,Attr                 ;Get the AX word here and flag
        cCall   OpenCall, <es,si,-1>    ;  OpenCall with -1
        mov     bx,ax                   ;Save the error code if any
        pop     si
        pop     ds
        jnc     spthYes
        cmp     byte ptr [si],0         ;At end of path?
        jnz     spth4

spthNo: mov     ax,-1
        ;** Bug 14960:  If the last error code was path not found, the user
        ;**     has a bogus directory in their path.  Since we were unable
        ;**     to find the file, return file not found instead of path not
        ;**     found.   2 November 1991      Clark R. Cyr
        cmp     bx, 3                   ;Path Not Found?
        jne     spthYes
        mov     bx, 2                   ;Make it File Not Found
spthYes:
cEnd


;  MyAnsiToOem
;       Used to do ANSI to OEM conversions.  This function allows routines
;       here to call freely without worrying if the keyboard driver can
;       be called with this yet.  At boot time, we can't call the
;       keyboard driver where these functions reside, so no translation
;       is done.

cProc   MyAnsiToOem, <PUBLIC,NEAR>, <si,di,ds>
        parmD pSrc
        parmD pDst
cBegin
        SetKernelDS
        cmp     pKeyProc.sel,0          ; is there a keyboard yet?
        jnz     mao1                    ; Yes, so do translation
        lds     si, pSrc                ; No, so just copy the strings
        UnSetKernelDS
        les     di, pDst
        call    strcpyreg
;mao0:
;       lodsb
;       stosb
;       or      al, al
;       jnz     mao0
        jmps    mao2
                                        ; Not booting, we can call the
mao1:                                   ; translation routine
        ReSetKernelDS
        cCall   [pKeyProc],<pSrc,pDst>  ; convert string from AnsiToOem
mao2:
cEnd


;  MyOemToAnsi
;       Matching function for MyAnsiToOem.  See comments above

cProc   MyOemToAnsi,<PUBLIC,NEAR>,<si,di,ds>
        parmD pSrc
        parmD pDst
cBegin
        SetKernelDS
        cmp     pKeyProc.sel,0          ; is there a keyboard yet?
        jnz     moa1                    ; Yes, do normal conversion
        lds     si, pSrc                ; No, so just copy the string
        UnSetKernelDS
        les     di, pDst
        call    strcpyreg
;moa0:
;       lodsb
;       stosb
;       or      al, al
;       jnz     moa0
        jmps    moa2

moa1:                                   ; Call the translation routine
        ReSetKernelDS
        cCall   [pKeyProc1],<pSrc,pDst> ; convert string from AnsiToOem
moa2:
cEnd


;---------------------------------------------------------------------
;
;  Is Drive number in DI a floppy? A=0, etc.  ZF = yes, it is a floppy
;
        public  IsFloppy
IsFloppy:
ifdef WOW
        push    dx
        cCall   GetDriveType,<di>
        pop     dx
else
        mov     bx,1            ; 1 = Get Drive Info from InquireSystem
        push    es
        push    ds
        SetKernelDS
        cCall   [pSysProc],<bx,di>
        pop     ds
        UnSetKernelDS
        pop     es
endif
        cmp     al,2            ; 2 = removable media
        ret

FarIsFloppy PROC        FAR
        call    IsFloppy
        ret
FarIsFloppy ENDP


;----------------------------------------------------------------------------
;  Prompt
;
;       Puts up the system error box telling the user the file can't be found
;
;----------------------------------------------------------------------------

cProc   Prompt, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpstr
cBegin
        SetKernelDS
        mov     ax,3                    ;Assume CANCEL
        cmp     pSErrProc.sel,0         ;Is there a USER yet?
        jz      P_End                   ;No

        ;** Format the string <szCannotFind1><lpstr><szCannotFind2>
        push    ds
        pop     es
        mov     di, dataOffset OutBuf   ; ES:DI points to dest
        mov     si, dataOffset szCannotFind1
        call    strcpyreg

        lds     si, [lpstr]
        mov     al, byte ptr ds:[si]
        UnSetKernelDS
        mov     es:[LastDriveSwapped], al
        call    strcpyreg

        push    es
        pop     ds
        ReSetKernelDS
        mov     si, dataOffset szCannotFind2
        call    strcpyreg

        ;** Prepare the dialog box
        push    ds                      ;In our DS
        push    dataOFFSET OutBuf       ;Point to "Cannot find" string

        push    ds
        push    dataOffset szDiskCap    ;Caption

        push    0                       ;No left button

        push    SEB_CLOSE + SEB_DEFBUTTON ;Button 1 style

        push    0                       ;No right button

        call    [pSErrProc]             ;Put up the system error message

P_End:
        xor     ax,ax
cEnd


;----------------------------------------------------------------------------
;  StartString
;
;       Prepares the start of the string for the sys error box
;
;       ES:BX is the pointer to the full pathname
;       DS:DX is the string "Can't find file X:"
;
;----------------------------------------------------------------------------

cProc   strcpyreg, <NEAR,PUBLIC>
cBegin  nogen
        cld
@@:     lodsb                           ; copy from DS:SI
        stosb                           ; to ES:DI
        or      al, al
        jnz     @B                      ; including 0
        dec     di                      ; point to trailing 0
        ret
cEnd    nogen


;cProc   StartString, <NEAR,PUBLIC>
;cBegin  NOGEN
;       CheckKernelDS
;       ReSetKernelDS
;
;       ;** Copy the first part of the string
;       cld
;       push    es                      ;Save the parameter
;       push    bx
;       mov     dx,dataOffset szCannotFind1 ;Point to Can't Find string
;       call    AppendFirst             ;Put in OutBuf
;       pop     bx
;       pop     es
;
;       ;** Save the drive letter for compatibility with ancient disk swaps
;       mov     al,es:[bx]              ;Get drive letter
;       mov     [LastDriveSwapped],al   ;Save it for GetLastDiskChange
;
;       ;** Append the filename portion
;       smov    ds,es
;       mov     dx,bx
;       jmps    Append
;
;cEnd    NOGEN


;  AppendFirst & Append
;       Append ASCIIZ string to the static string OutBuf
;
;       ENTRY:  DS:DX points to a string to append to the static buffer
;
;       AppendFirst clears the static string and appends the new string
;       as the first part of the string.
;       Append just appends the new string on the end of the current string.

cProc   AppendFirst, <PUBLIC,NEAR>
cBegin  NOGEN
        CheckKernelDS
        ReSetKernelDS
        mov     [BufPos],dataOffset OutBuf
        UnSetKernelDS

;Append:
        push    si                      ;Save some registers
        push    di
        SetKernelDS     es
        mov     di,[BufPos]
        mov     si,dx
        call    strcpyreg
;ap1:   lodsb
;       stosb
;       or      al,al
;       jnz     ap1
        dec     di
        mov     [BufPos],di
        pop     di
        pop     si
        ret
cEnd    NOGEN
        UnSetKernelDS   es


;  GetPureName
;       Strips the drive and directory portions of a pathname off.
;       ENTRY:  ES:DI points to pathname
;       EXIT:   ES:DI points to "pure" name in same string

cProc   GetPureName, <NEAR,PUBLIC>
cBegin

        ;** Do FE_SB version:
        ;*      It is not possible to search filename delimiter by backward
        ;**     search in case of FE_SB version, so we use forward search.
IFDEF FE_SB
        mov     bx,di
iup0:
        mov     al,es:[di]
        test    al,al                   ; end of string?
        jz      iup2                    ; jump if so
        inc     di
        cmp     al,'\'
        jz      iup1
        cmp     al,'/'
        jz      iup1
        cmp     al,':'
        jz      iup1
        call    MyIsDBCSLeadByte        ; see if char is DBC
        jc      iup0                    ; jump if not a DBC
        inc     di                      ; skip to detemine 2nd byte of DBC
        jmp     iup0
iup1:
        mov     bx,di                   ; update purename candidate
        jmp     iup0
iup2:
        mov     di,bx                   ; di points purename pointer

        ;** Do normal version:
        ;**     Here we can just back up until we find the proper char
ELSE
        cld
        xor     al,al
        mov     cx,-1
        mov     bx,di
        repne   scasb
        inc     cx
        inc     cx
        neg     cx
iup0:   cmp     bx,di                   ; back to beginning of string?
        jz      iup1                    ; yes, di points to name
        mov     al,es:[di-1]            ; get next char
        cmp     al,'\'                  ; next char a '\'?
        jz      iup1                    ; yes, di points to name
        cmp     al,'/'                  ; next char a '/'
        jz      iup1
        cmp     al,':'                  ; next char a ':'
        jz      iup1                    ; yes, di points to name
        dec     di                      ; back up one
        jmp     iup0
iup1:
ENDIF

cEnd


;  ParseFile
;       
;       ENTRY:  DS:SI points to unqualified pathname
;               ES:DI points to buffer to be used for qualified name
;       EXIT:   Buffer previously pointed to by ES:DI now has full
;               unambiguous pathname
;               DX is length of path portion of entered pathname
;               AX is total length of pathname
;               DI is number of slashes
;               CX is length of path ON ERROR ONLY!!! (for PowerPoint)

LONG_UNC_NAMES equ 1

cProc   ParseFile, <NEAR,PUBLIC>
        localW  cSlash                  ;Word ptr [bp][-2]
        localW  cchPath                 ;Word ptr [bp][-4]
        localW  fUNC                    ;Flag for UNC name (\\foo\bar)
if LONG_UNC_NAMES
        localW  fCountUNC               ;Indicates we are parsing UNC name
else
        localW  fFirstUNC               ;Indicates we are parsing UNC name
endif

cBegin
        mov     cSlash,0                ;Zero the local variables
        mov     cchPath,0
        mov     fUNC,0                  ;Assume it's not UNC
        cld

        ;** If a drive is on the path, parse it.  Otherwise, get the current
        ;**     drive.
        cmp     byte ptr ds:[si+1],':'
        jne     nodrive
        lodsb
        inc     si
        or      al,20h                  ; convert to lower case
        sub     al,'a'                  ; convert to number
        jb      @F                      ;Not valid, so return error
        cmp     al,'z'-'a'
        jbe     gotdrive
@@:     jmp     gpFail2
nodrive:
        mov     ah,19h
        DOSCALL
gotdrive:
        mov     dl,al
        inc     dl
        add     al,'A'                  ; convert to ascii
        mov     ah,':'

        ;** If this is a UNC name, we don't want to copy the drive letter
        ;**     as it is legal but unnecessary for a full path
        mov     fUNC, 1
if LONG_UNC_NAMES
        mov     fCountUNC, 2
else
        mov     fFirstUNC, 1
endif
        cmp     WORD PTR ds:[si], '\\'  ;Is this a UNC? (\\foo\bar)
        je      PF_DriveOK              ;Yes, don't insert drive
        cmp     WORD PTR ds:[si], '//'  ;Is this a UNC? (//foo/bar)
        je      PF_DriveOK              ;Yes, don't insert drive
        mov     fUNC, 0                 ;Nope, not UNC
if LONG_UNC_NAMES
        mov     fCountUNC, 0
else
        mov     fFirstUNC, 0
endif

        stosw                           ;Write drive letter and colon
        add     cchPath,2               ;Add two chars to path len
PF_DriveOK:
        push    di                      ; Save beginning of path

        ;** If we start with a slash, we have a qualified path here
        ;*      so we don't have to search to find the current path.
        ;**     Otherwise, we have to find where we are and make the path.
        mov     bx,'/' shl 8 + '\'      ;Separator characters
        mov     al,ds:[si]              ;Get first character
        cmp     al,bh                   ;If it's either one, we have a
        je      getpath0                ;  full path, so don't search
        cmp     al,bl
        je      getpath0
        mov     al,bl                   ;Get a '\'
        stosb                           ;  and put in the buffer
        inc     cchPath                 ;Bump path count
        mov     cx,ds                   ;Prepare for DOS call:  Save DS
        xchg    si,di                   ;DS:SI needs to point to buffer
        mov     ax,es
        mov     ds,ax
        mov     ah,47h                  ;DOS #47:  Get Current Directory
        DOSCALL
        jnc     @F
        jmp     gpfail
@@:
        push    cx                      ;DOS returns OEM characters
        push    bx                      ;  so convert to ANSI
        cCall   MyOemToAnsi,<ds,si,ds,si>
        pop     bx
        pop     ds
        xchg    si,di                   ;Get pointer back
        xor     al,al
        mov     cx,-1
        repnz   scasb                   ;Find the end of the string
        neg     cx
        dec     cx                      ;Don't count the terminator
        dec     cx
        add     cchPath,cx              ;Add into path count
        dec     di                      ;Don't leave DI past the zero byte
ifdef   FE_SB                           ;Check for trailing slash, DBCS-style
        push    si
        push    di
        mov     si,di
        sub     si,cx                   ;es:si->string address
        dec     di                      ;es:di->last byte
        call    MyIsDBCSTrailByte       ;is the last byte a DBCS trailing byte?
        pop     di
        pop     si
        jnc     loopGD3                 ;yes, append a '\'
                                        ;no, fall through
endif
        mov     al,es:[di-1]            ;Check for trailing slash.  Non-DBCS
        cmp     al,bh                   ;If there is one, we're done here
        je      getpath0
        cmp     al,bl
        je      getpath0
IFDEF FE_SB
loopGD3:
ENDIF
        mov     al,bl                   ;Put a trailing slash on
        stosb
        inc     cchPath

        ;** Parse the pathname the user gave us
getpath0:
PF_GetPath label NEAR
        public PF_GetPath
        xor     cx,cx                   ;CL=# of chars, CH=# of '.'
        mov     dx,di                   ;DX points to start of user chars
gp0:
        lodsb                           ;Get a character
        cmp     al,bl                   ;Slash?
        je      gp1                     ;Yes
        cmp     al,bh
ifdef FE_SB
        je      gp1                     ;Too far if DBCS enable....
        jmp     gp2
else
        jne     gp2                     ;No, skip this
endif
gp1:                                    ;Character is a slash

        ;** If we have a UNC name, two slashes are OK
        ;**     (just at the start of the filename)
        cmp     cchPath, 0              ;Start of path?
        jne     PF_NotUNC               ;No, even if UNC, not valid here
        cmp     fUNC, 0                 ;UNC pathname?
        je      PF_NotUNC               ;No, handle normally
        stosb                           ;Store the first slash
        lodsb                           ;Get the second slash
        inc     cchPath                 ;Another character in string
        jmp     SHORT gp1f              ;Skip double slash failure
PF_NotUNC:
        
        cmp     ds:[si],bl              ; if double slash, bad file name
        jz      gp1SkipSlash            ; so we skip the extra slashes
        cmp     ds:[si],bh              ; to be compatible with win32
        jnz     gp1DoneSlash            ; MonkeyIsland bug 220764
        
gp1SkipSlash: 
        inc     si
        jmp     SHORT PF_NotUNC         ; check for more slashes
gp1DoneSlash:        
               
if LONG_UNC_NAMES
        dec     fCountUNC               ; Move to next portion of path
        jns     @f
        mov     fCountUNC,0
@@:
else
        ;** When we get here, we will be on the first slash AFTER the
        ;**     UNC slashes:  (\\foo\bar) (or any succeeding slash)
        ;**                         ^
        ;**     So, we want clear the fFirstUNC flag so we don't allow
        ;**     more than 8 characters before a dot.
        mov     fFirstUNC, 0
endif
gp1f:
        inc     cSlash                  ; we found a slash
        cmp     cl,ch                   ; number of chars = number of '.'
        jne     gp1b                    ; nope....

        or      cx,cx
        jnz     gp001
ifdef   FE_SB
        jmp     gp2b                    ; We need 16 bits branch
else
        jmp     SHORT gp2b
endif
gp001:

        cmp     cl,2                    ; if more than 2 '.'
        ja      gpFail                  ; then we are bogus

        dec     di
ifdef   FE_SB
        dec     cchPath                 ; adjust path string length
endif
        dec     cl
        jz      getpath0
ifdef   FE_SB
        dec     di
        dec     di
        mov     dx, di
        sub     di, cchPath
        add     di, 4
        cmp     di, dx
        jnc     gpfail          ; illegal path such as "c:.." or "c:\.."
        mov     cchPath, 3
gp1a:
        xor     cx, cx
gp1bb:
        inc     di
        inc     cx
        mov     al, es:[di]
        cmp     al, bl
        jz      gp1c
        call    MyIsDBCSLeadByte
        jc      gp1bb
        inc     di
        inc     cx
        jmp     gp1bb
gp1c:
        cmp     di, dx
        jz      gp1d
        add     cchPath, cx
        jmp     gp1a
gp1d:
        sub     di, cx
        inc     di                  ; new di points previous '\'+1
        jmp     getpath0
else
        mov     di,dx
gp1a:
        dec     di
        mov     al,es:[di-1]
        cmp     al,bl
        je      getpath0
        cmp     al,':'
        jne     gp1a
endif
gpfail:
        pop     ax
gpFail2:
        xor     ax,ax
        jmp     gpexit
gp1b:
        mov     al,bl
        stosb
        inc     cchPath
        jmp     getpath0
gp2:
        or      al,al
        jnz     gp002
ifdef FE_SB
        jmp     gpx
else ; !FE_SB
        jmp     short gpx
endif ; !FE_SB

gp002:
        cmp     al,' '
        jb      gpFail
        ja      gp20

gp2x:   lodsb                   ; if space encountered continue scanning...
        or      al,al           ; if end of string, all ok
ifdef   FE_SB
        jnz     gp2x_01
        jmp     gpx
gp2x_01:
else
        jz      gpx
endif
        cmp     al,' '          ; if space, keep looking...
        jz      gp2x
        jmps    gpFail          ; otherwise error

gp20:   cmp     al,';'
        jz      gpFail
        cmp     al,':'
        jz      gpFail
        cmp     al,','
        jz      gpFail
        cmp     al,'|'
        jz      gpFail
        cmp     al,'+'
        jz      gpFail
        cmp     al,'<'
        jz      gpFail
        cmp     al,'>'
        jz      gpFail
        cmp     al,'"'
        jz      gpFail
        cmp     al,'['
        jz      gpFail
        cmp     al,']'
        jz      gpFail
        cmp     al,'='
        jz      gpFail

        inc     cl                      ; one more char
ifdef FE_SB
        call    MyIsDBCSLeadByte        ; First byte of 2 byte character?
        jc      gp2a                    ; No, convert to upper case
        stosb                           ; Yes, copy 1st byte
        inc     cchPath
        lodsb                           ; Fetch second byte
        inc     cl
        jmps    gp2a1                   ; with no case conversion
gp2a:
endif
        call    MyUpper
gp2a1:
        cmp     cchPath,127             ; DOS pathmax is 128, room for null.
        ja      gpFail
gp2b:
        stosb
        inc     cchPath
        cmp     al,'.'
        jne     gp2c
        inc     ch
        mov     ah,cl
        dec     ah
gp2c:
if LONG_UNC_NAMES
        ;** If this is a UNC name, don't bother checking lengths
        cmp     fCountUNC,0             ; Past \\foo\bar yet?
        je      PF_NotUNCPart
else
        cmp     fFirstUNC, 0            ;First UNC name?
        je      PF_NotFirstUNC          ;Nope
        or      ch,ch                   ;'.' encountered yet?
        jnz     PF_NotFirstUNC          ;Yes, treat like normal name
        cmp     cl, 11                  ;11 chars allowed with no '.'
        ja      gpFv                    ;Too many
endif
        jmp     gp0                     ;Ok

if LONG_UNC_NAMES
PF_NotUNCPart:
else
PF_NotFirstUNC:
endif

        ;** Check other lengths
        cmp     ch,0                    ; did we find a . yet?
        jz      gpT1   