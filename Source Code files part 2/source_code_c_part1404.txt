
    return hr;
}


/*
-   GetItemFromLV
-
*   utility function for returning the recipient item from the LV
*/
LPRECIPIENT_INFO GetItemFromLV(HWND hWndLV, int iItem)
{
    LPRECIPIENT_INFO lpItem = NULL;

    LV_ITEM LVItem;

    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = iItem;
    LVItem.iSubItem = 0;
    LVItem.lParam = 0;

    // Get item lParam LPRECIPIENT_INFO structure
    if (ListView_GetItem(hWndLV,&LVItem))
        lpItem = ((LPRECIPIENT_INFO) LVItem.lParam);

    return lpItem;
}

/*
-   Helper function
-
*/
void SetSBinary(LPSBinary lpsb, ULONG cb, LPBYTE lpb)
{
    if(!lpsb || !cb || !lpb)
        return;
    if(lpsb->lpb = LocalAlloc(LMEM_ZEROINIT, cb))
    {
        lpsb->cb = cb;
        CopyMemory(lpsb->lpb, lpb, cb);
    }
}


/*
-   GetWABIconImage
-
*
*/
int GetWABIconImage(LPRECIPIENT_INFO lpItem)
{
    if(lpItem->cbEntryID == 0)
        return imageUnknown;

    if(lpItem->ulObjectType == MAPI_DISTLIST)
    {
        return imageDistList;
    }
    else
    {
        BYTE bType;

        if(lpItem->bIsMe)
            return imageMailUserMe;
        else if(lpItem->bHasCert)
            return imageMailUserWithCert;
        
        bType = IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, NULL,NULL,NULL, NULL, NULL);
        if(bType == WAB_LDAP_MAILUSER)
            return imageMailUserLDAP;
        else if(bType == WAB_ONEOFF)
            return imageMailUserOneOff;

    }
    return imageMailUser;
}

enum
{
    IE401_DONTKNOW=0,
    IE401_TRUE,
    IE401_FALSE
};
static int g_nIE401 = IE401_DONTKNOW;
/*
-   bIsIE401
-
*   Checks if this installation has IE4.01 or greater so we can decide what flags to pass to the prop sheets
*
*/
BOOL bIsIE401OrGreater()
{
    BOOL bRet = FALSE;

    if(g_nIE401 == IE401_TRUE)
        return TRUE;
    if(g_nIE401 == IE401_FALSE)
        return FALSE;
    
    g_nIE401 = IE401_FALSE;

    // else we need to check
    InitCommonControlLib();

    //load the DLL
    if(ghCommCtrlDLLInst)   
    {
        LPDLLGETVERSIONPROC lpfnDllGetVersionProc = NULL;
        lpfnDllGetVersionProc = (LPDLLGETVERSIONPROC) GetProcAddress(ghCommCtrlDLLInst, "DllGetVersion");
        if(lpfnDllGetVersionProc)
        {
            // Check the version number
            DLLVERSIONINFO dvi = {0};
            dvi.cbSize = sizeof(dvi);
            lpfnDllGetVersionProc(&dvi);
            // we are looking for IE4 version 4.72 or more
            if( (dvi.dwMajorVersion > 4) ||
                (dvi.dwMajorVersion == 4 && dvi.dwMinorVersion >= 72) )
            {
                g_nIE401 = IE401_TRUE;
                bRet = TRUE;
            }
        }
    }

    DeinitCommCtrlClientLib();

    return bRet;
}

#ifdef COLSEL_MENU
/**
    ColSel_PropTagToString: This function will convert a propertytag to a string
*/
BOOL ColSel_PropTagToString( ULONG ulPropTag, LPTSTR lpszString, ULONG cchString)
{
    UINT i, j;
    UINT iIndex;
    HMENU hMainMenu;
    HMENU hMenu;
    MENUITEMINFO mii;
    BOOL fRet = FALSE;

    hMainMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXTMENU_COLSEL));
    if( !hMainMenu )
    {    
        DebugTrace( TEXT("unable to load main colsel menu\n"));
        goto exit;
    }
    hMenu = GetSubMenu( hMainMenu, 0);
    if( !hMenu )
    {
        DebugTrace( TEXT("unable to load submenu from colsel main menu\n"));
        goto exit;
    }        
    if( !lpszString )
    {
        DebugTrace( TEXT("illegal argument -- lpszString must be valid mem\n"));
        goto exit;
    }
    mii.fMask = MIIM_TYPE;
    mii.cbSize = sizeof( MENUITEMINFO );
    mii.dwTypeData = lpszString;
    mii.cch = cchString;

    for( i = 0; i < MAXNUM_MENUPROPS; i++)
    {
        if( MenuToPropTagMap[i] == ulPropTag )
        {
            if( !GetMenuItemInfo( hMenu, i, TRUE, &mii) )
            {
                DebugTrace( TEXT("unable to get menu item info: %x\n"), GetLastError() );
                goto exit;
            }
            fRet = TRUE;
        }
    }
    
exit:
    DestroyMenu( hMainMenu );
    if( !fRet )
        DebugTrace( TEXT("unable to find property tag\n"));
    return fRet;
}
#endif // COLSEL_MENU

/*
-   IsWindowOnScreen
-   
*   Checks if a window is onscreen so that if it is not entirely onscreen we can push it back
*   into a viewable area .. this way if the user changes screen resolution or switches multi-monitors
*   around, we don't lose the app
*/
BOOL IsWindowOnScreen(LPRECT lprc)
{
    HDC hDC = GetDC(NULL);
    BOOL fRet = RectVisible(hDC, lprc);
    ReleaseDC(NULL, hDC);
    return fRet;
}

/*
-   IsHTTPMailEnabled
-   
*   Checks if HTTP is enabled so that we can hide UI if its not.
*/
static TCHAR c_szRegRootAthenaV2[] = TEXT("Software\\Microsoft\\Outlook Express");
static TCHAR c_szEnableHTTPMail[] = TEXT("HTTP Mail Enabled");

BOOL IsHTTPMailEnabled(LPIAB lpIAB)
{
#ifdef NOHTTPMAIL
    return FALSE;
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // [PaulHi] 1/5/98  Raid #64160
    // Hotmail synchronization is disabled if the WAB is not in "identity aware"
    // mode.  So, we need to check for this too.
    bEnabled = lpIAB->bProfilesIdent;
    
    // @todo [PaulHi] 12/1/98
    // We really shouldn't be doing a registry query every time the user
    // opens up the Tools menu, i.e., in update menu.
    // Check this registry sometime during start up and save per instance.
    // open the OE5.0 key
    if ( bEnabled &&
         (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegRootAthenaV2, 0, KEY_QUERY_VALUE, &hkey)) )
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    //
    // [PaulHi] 12/1/98  Raid #57739
    // HACK WARNING
    // Since the Hotmail server is currently hard coded to the U.S. 1252
    // codepage, any other system codepage will result in corrupted data
    // after a round sync trip to the Hotmail server and back, for any fields
    // with DB characters (i.e., international).  The temporary solution is 
    // to simply disable Hotmail synchronization if a codepage other than 
    // 1252 is detected on the client machine.
    //
    #define USLatin1CodePage    1252
    if (bEnabled)
    {
        DWORD dwCodepage = GetACP();
        if (dwCodepage != USLatin1CodePage)
            bEnabled = FALSE;
    }

    return bEnabled;
#endif
}

/*
-
-   WriteRegistryDeletedHotsyncItem
*
*   Writes the Hotmail Contact/ID/Modtime info to the registry so we can track deletions for
*   Hotmail syncing
*
*/
extern LPTSTR g_lpszSyncKey;
void WriteRegistryDeletedHotsyncItem(LPTSTR lpServerID, LPTSTR lpContactID, LPTSTR lpModTime)
{
    HKEY hKey = NULL,hSubKey = NULL;

    DWORD dwDisposition = 0;

    if( !lpServerID || !lstrlen(lpServerID) ||
        !lpContactID || !lstrlen(lpContactID) ||
        !lpModTime || !lstrlen(lpModTime) )
        return;

    // Open key
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_lpszSyncKey, 0,      //reserved
                                        NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                        &hKey, &dwDisposition))
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(hKey,lpContactID, 0,
                                            NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                            &hSubKey, &dwDisposition))
        {
            // Create a value here .. the value name is the Contact ID and the Value Data is the ModTime
            // Now Write this key
            RegSetValueEx( hSubKey, lpServerID, 0, REG_SZ, (LPBYTE) lpModTime, (lstrlen(lpModTime)+1) * sizeof(TCHAR) );
        }
    }

    if(hSubKey)
        RegCloseKey(hSubKey);
    if(hKey)
        RegCloseKey(hKey);
}

/*
-   HrSaveHotmailSyncInfoOnDeletion
-
*   If the user has ever done any hotmail syncing, we need to track deletions in the WAB
*   so that after you delete an entry in the WAB, the corresponding hotmail entry will
*   be deleted on Sync.
*
*   We store the hotmail sync info in the registry, hopefully there won't be too much of it
*   Whenever the hotmail sync happens, the info gets cleaned out.
*/
HRESULT HrSaveHotmailSyncInfoOnDeletion(LPADRBOOK lpAdrBook, LPSBinary lpEID)
{
    // Basically we will open the object being deleted, look for it's Hotmail
    // properties and if these properties exist, we will put them into the registry
    //
    HRESULT hr = S_OK;
    ULONG ulcValues = 0,i=0;
    LPSPropValue lpProps = NULL;
    SizedSPropTagArray(3, ptaHotProps) =
    {   
        3, 
        {
            PR_WAB_HOTMAIL_CONTACTIDS,
            PR_WAB_HOTMAIL_MODTIMES,
            PR_WAB_HOTMAIL_SERVERIDS,
        }
    };

    hr = HrGetPropArray(lpAdrBook,
                        (LPSPropTagArray) &ptaHotProps,
                        lpEID->cb,(LPENTRYID) lpEID->lpb,
                        MAPI_UNICODE,
                        &ulcValues,&lpProps);
    if(HR_FAILED(hr) || !ulcValues || !lpProps)
        goto out;

    // The three props are supposed to be in sync, so if one exists, the other 2 will also exist
    // and if this is not true, then don't write the data to the registry
    if( lpProps[0].ulPropTag != PR_WAB_HOTMAIL_CONTACTIDS ||
        !lpProps[0].Value.MVSZ.cValues ||
        lpProps[1].ulPropTag != PR_WAB_HOTMAIL_MODTIMES ||
        !lpProps[1].Value.MVSZ.cValues ||
        lpProps[2].ulPropTag != PR_WAB_HOTMAIL_SERVERIDS ||
        !lpProps[2].Value.MVSZ.cValues ||
        lpProps[0].Value.MVSZ.cValues != lpProps[1].Value.MVSZ.cValues ||
        lpProps[0].Value.MVSZ.cValues != lpProps[2].Value.MVSZ.cValues ||
        lpProps[1].Value.MVSZ.cValues != lpProps[2].Value.MVSZ.cValues)
        goto out;

    for(i=0;i<lpProps[0].Value.MVSZ.cValues;i++)
    {
        WriteRegistryDeletedHotsyncItem(    lpProps[2].Value.MVSZ.LPPSZ[i], //server id
                                            lpProps[0].Value.MVSZ.LPPSZ[i], //contact id
                                            lpProps[1].Value.MVSZ.LPPSZ[i]); //mod time
    }

out:

    FreeBufferAndNull(&lpProps);
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_abook.c ===
////////////////////////////////////////////////////////////////////////////////////////
//
//
//  UI_ABOOK.C - contains code for the Browse mode Overlapped Window address book view
//
//  Developers: VikramM     5/96
//
////////////////////////////////////////////////////////////////////////////////////////
#include "_apipch.h"
#include "hotsync.h"
#include "htmlhelp.h"
#include <mirror.h>

extern HINSTANCE ghCommCtrlDLLInst;

extern const LPTSTR  lpszRegPositionKeyValueName;

extern BOOL bIsPasteData();
extern HRESULT HrPasteData(LPBWI lpbwi);
extern void AddFolderListToMenu(HMENU hMenu, LPIAB lpIAB);

const static LPTSTR szWABMigRegPathKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wabmig.exe");
const static LPTSTR szWABExeRegPathKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
const LPTSTR szWABMIG = TEXT("wabmig.exe");
const LPTSTR szWABExe = TEXT("wab.exe");
const TCHAR szEXPORT[] = TEXT("/export");
const TCHAR szIMPORT[] = TEXT("/import");
const TCHAR szEXPORTwProfileParam[]=TEXT("/export+/pid:%s+/file:%s");
const TCHAR szIMPORTwProfileParam[]=TEXT("/import+/pid:%s+/file:%s");

// This struct helps in identifying contact folders and groups and in navigating
// around them
//
void FillTreeView(LPBWI lpbwi, HWND hWndTV, LPSBinary lpsbSelection);
void UpdateTVGroupSelection(HWND hWndTV, LPSBinary lpsbSelectEID);
void GetCurrentSelectionEID(LPBWI lpbwi, HWND hWndTV, LPSBinary * lppsbEID, ULONG * lpulObjectType, BOOL bTopMost);
void ClearTreeViewItems(HWND hWndTV);
void UpdateLV(LPBWI lpbwi);
void UpdateListViewContents(LPBWI lpbwi, LPSBinary lpsbEID, ULONG ulObjectType);
void ViewCurrentGroupProperties(LPBWI lpbwi, LPFILETIME lpftLast);
BOOL bIsFocusOnTV(LPBWI lpbwi);
BOOL bIsSelectedTVContainer(LPBWI lpbwi);
BOOL SplitterHitTest(HWND hWndT, LPARAM lParam);
void DragSplitterBar(LPBWI lpbwi, HWND hwnd, HWND hWndT, LPARAM lParam);
HRESULT FillListFromGroup(LPADRBOOK lpIAB, ULONG cbGroupEntryID,  LPENTRYID lpGroupEntryID, LPTSTR lpszName, LPRECIPIENT_INFO * lppList);

extern LPIMAGELIST_DESTROY          gpfnImageList_Destroy;

// extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;

extern ULONG GetToolbarButtonWidth();

void RemoveCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast);
HRESULT RemoveCurrentFolder(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast);
void RemoveSelectedItemsFromCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast, BOOL bRemoveFromWAB);
void RemoveSelectedItemsFromListView(HWND hWndLV, LPRECIPIENT_INFO *lppList);
LRESULT ProcessTreeViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam, LPFILETIME lpftLast);
#ifdef COLSEL_MENU
BOOL UpdateOptionalColumns( LPBWI lpbwi, ULONG iColumn );
#endif // COLSEL_MENU
// Initial Window Size
#define INIT_WINDOW_W  500
#define INIT_WINDOW_H  375

// Minimum Window Size - presently constrained
#define MIN_WINDOW_W	300
#define MIN_WINDOW_H	200

BOOL fOleInit = FALSE;

//
// Some IDs for the Button Bar
//

// Address Book Window Class Name
LPTSTR g_szClass =  TEXT("WABBrowseView");


// Function ProtoTypes

LRESULT CALLBACK AddressBookWndProc(HWND   hWnd,UINT   uMsg,WPARAM   wParam,LPARAM lParam);
void CreateAddressBookChildren(LPBWI lpbwi, HWND hWnd);
void ResizeAddressBookChildren(LPBWI lpbwi, HWND hWndParent);
HWND CreateListViewAddrBook (HWND hWndParent);
void InitChildren(LPBWI lpbwi, HWND hWnd);
void SetListViewStyle(LPBWI lpbwi, int MenuID);
void CleanUpGlobals(LPBWI lpbwi);
HRESULT HrFolderProperties(HWND hWndParent, LPIAB lpIAB, LPSBinary lpsbEID, LPWABFOLDER lpParentFolder, LPSBinary lpsbNew);

//void TabToNextItem();

LRESULT ProcessListViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam);

LRESULT EnforceMinSize(LPBWI lpbwi, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

LRESULT CALLBACK SubClassedProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

void RefreshListView(LPBWI lpbwi, LPFILETIME lpftLast);

STDAPI_(BOOL) FindABWindowProc( HWND hWndToLookAt, LPARAM lParam);

void UpdateSortMenus(LPBWI lpbwi, HWND hWnd);

void UpdateToolbarAndMenu(LPBWI lpbwi);

void UpdatePrintMenu(HWND hWnd);
void UpdateOutlookMenus(HWND hWnd);
void UpdateCustomColumnMenuText(HWND hWnd);
void UpdateViewFoldersMenu(LPBWI lpbwi, HWND hWnd);
void UpdateSwitchUsersMenu(HWND hWnd, LPIAB lpIAB);

//LPFNABSDI lpfnAccelerateMessages;
BOOL STDMETHODCALLTYPE fnAccelerateMessages(ULONG_PTR ulUIParam, LPVOID lpvmsg);

void SetPreviousSessionPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB);

void SaveCurrentPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB);

void Handle_WM_MENSELECT (LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam );
void Handle_WM_INITMENUPOPUP(HWND hWnd, LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam );

void UpdateTooltipTextBuffer(LPBWI lpbwi, int nItem);
void InitMultiLineToolTip(LPBWI lpbwi, HWND hWndParent);
void FillTooltipInfo(LPBWI lpbwi, LPTOOLINFO lpti);
int HitTestLVSelectedItem(LPBWI lpbwi);
BOOL bCheckIfOnlyGroupsSelected(HWND hWndLV);

void DestroyImageLists(LPBWI lpbwi);

#define WAB_TOOLTIP_TIMER_ID   888
#define WAB_TOOLTIP_TIMER_TIMEOUT   750 // milliseconds


HRESULT HrExportWAB(HWND hWnd, LPBWI lpbwi);
void HrShowOptionsDlg(HWND hWndParent);

//$$ extern void UIOLEUninit();
void UIOLEUninit()
{
    if(fOleInit)
    {
        OleUninitialize();
        fOleInit = FALSE;
    }
}

void UIOLEInit()
{
    if(!fOleInit)
    {
        OleInitialize(NULL);
        fOleInit = TRUE;
    }
}

//$$
//
// LocalFreeSBinary - frees a locally alloced SBinary struct
//
//
void LocalFreeSBinary(LPSBinary lpsb)
{
    if(lpsb)
    {
        if(lpsb->lpb)
            LocalFree(lpsb->lpb);
        LocalFree(lpsb);
    }
}

//$$
/*----------------------------------------------------------------------*/
//
// RunWABApp - runs the import-export tool based on the registered path
//       if regesitered path is not found, shell execs ...
//
/*----------------------------------------------------------------------*/
void RunWABApp(HWND hWnd, LPTSTR szKey, LPTSTR szExeName, LPTSTR szParam)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD  dwType = 0;
    ULONG  cbData = CharSizeOf(szPath);
    HKEY hKey = NULL;
    LONG lRes = 0;

    *szPath = '\0';
    *szPathExpand = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey))
        lRes = RegQueryValueEx( hKey,  TEXT(""), NULL, &dwType, (LPBYTE) szPath, &cbData);

    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szPath, szPathExpand, CharSizeOf(szPathExpand));
        lstrcpy(szPath, szPathExpand);
    }

    if(hKey) RegCloseKey(hKey);

    if(!lstrlen(szPath))
        lstrcpy(szPath, szExeName);

    ShellExecute(hWnd,  TEXT("open"), szPath, szParam, NULL, SW_SHOWNORMAL);
}

//$$
/*----------------------------------------------------------------------*/
//
// StatusBarMessage - puts a message in the status bar
//
/*----------------------------------------------------------------------*/
void StatusBarMessage(LPBWI lpbwi, LPTSTR lpsz)
{
    SetWindowText(bwi_hWndSB, lpsz);
    UpdateWindow(bwi_hWndSB);
    return;
}

//$$
/*----------------------------------------------------------------------*/
//
// ShowLVCountinStatusBar - puts a message in the status bar
//
/*----------------------------------------------------------------------*/
void ShowLVCountinStatusBar(LPBWI lpbwi)
{
    TCHAR sz[MAX_UI_STR];
    TCHAR szString[MAX_UI_STR];
    LoadString(hinstMapiX, idsStatusBarCount, szString, CharSizeOf(szString));
    wsprintf(sz, szString, ListView_GetItemCount(bwi_hWndListAB));
    StatusBarMessage(lpbwi, sz);
    return;
}

//$$*------------------------------------------------------------------------
//| IAddrBook::Advise::OnNotify handler
//|
//*------------------------------------------------------------------------
ULONG AdviseOnNotify(LPVOID lpvContext, ULONG cNotif, LPNOTIFICATION lpNotif)
{
    LPBWI lpbwi = (LPBWI) lpvContext;

    DebugTrace( TEXT("=== AdviseOnNotify ===\n"));
    if(bwi_bDeferNotification)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        if(!pt_bIsWABOpenExSession)
        {
            DebugTrace( TEXT("=== Advise Defered ===\n"));
            bwi_bDeferNotification = FALSE;
            return S_OK;
        }
    }
    if(!bwi_bDontRefreshLV)
    {
        DebugTrace( TEXT("=== Calling RefreshListView ===\n"));
        HrGetWABProfiles(bwi_lpIAB);
        RefreshListView(lpbwi, NULL);
    }

    return S_OK;
}

/*
-
-   GetSelectedUserFolder - returns a pointer to the selected User Folder if any
*       If the selection is on a sub-folder, gets the parent User folder for that folder
*
*/
LPWABFOLDER GetSelectedUserFolder(LPBWI lpbwi)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;
    LPWABFOLDER lpFolder = NULL;
    //if(bIsSelectedTVContainer(lpbwi))
    {
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, TRUE);
        if(bIsWABSessionProfileAware(bwi_lpIAB))
            lpFolder = FindWABFolder(bwi_lpIAB, lpsbEID, NULL, NULL);
    }
    LocalFreeSBinary(lpsbEID);
    return (lpFolder && lpFolder->lpProfileID) ? lpFolder : NULL;
}

/*
-   RemoveUpdateSelection - Updates the selected TV Item when a deletion is done
-
*
*/
void RemoveUpdateSelection(LPBWI lpbwi)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
    if(TreeView_GetParent(bwi_hWndTV, hItem))
        hItem = TreeView_GetParent(bwi_hWndTV, hItem);
    else
        hItem = TreeView_GetNextSibling(bwi_hWndTV, hItem);
    if(!hItem)
        hItem = TreeView_GetRoot(bwi_hWndTV);
    TreeView_SelectItem(bwi_hWndTV, hItem);
    bwi_hti = NULL;
}

/*
-   CreateWindowTitle - if we don't have a passed in caption, create a title 
-       If there is a current user, add the user's name to the title
-       Returns LocalAlloced stuff that needs to be freed
-
*/
LPTSTR CreateWindowTitle(LPIAB lpIAB)
{
    LPTSTR lpTitle = NULL;
    TCHAR szTitle[MAX_PATH];
    LPTSTR lpsz = NULL;

    if(bIsThereACurrentUser(lpIAB))
    {
        LPTSTR lpsz = lpIAB->szProfileName;
        LoadString(hinstMapiX, idsCaptionWithText, szTitle, CharSizeOf(szTitle));
        FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szTitle, 0, 0, (LPTSTR) &lpTitle, 0, (va_list *)&lpsz);
    }

    if(!lpTitle || !lstrlen(lpTitle))
    {
        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szTitle, CharSizeOf(szTitle));
        if(lpTitle = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szTitle)+1)))
            lstrcpy(lpTitle, szTitle);
    }

    return lpTitle;
}

//$$*------------------------------------------------------------------------
//| Main call to create, activate address book overlapped-window
//|
//*------------------------------------------------------------------------
HWND hCreateAddressBookWindow(LPADRBOOK lpAdrBook, HWND hWndParent, LPADRPARM lpAdrParms)
{
    WNDCLASS  wc;
    HWND hWnd = NULL;
    HMENU hMenu = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPBWI lpbwi = NULL;
    LPTSTR lpTitle = NULL;
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    LPTSTR szCaption = (lpAdrParms->ulFlags & MAPI_UNICODE) ? // <note> assumes UNICODE defined
                        (LPWSTR)lpAdrParms->lpszCaption :
                        ConvertAtoW((LPSTR)lpAdrParms->lpszCaption);
    DWORD dwExStyle = WS_EX_NOPARENTNOTIFY | WS_EX_CONTROLPARENT;

    if(IS_BIDI_LOCALIZED_SYSTEM())
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst)
        goto out;

    //
    // We want each thread to only have one address book window - so we do an
    // enum thread windows and look for our address book window
    // If we find it - we set focus to it - if we dont find it
    // we go ahead and create a new one for this thread ...
    //


    // Is this window we found related to my thread?
    EnumThreadWindows(	GetCurrentThreadId(),
    					FindABWindowProc,
    					(LPARAM) &hWnd);

    if (IsWindow(hWnd))
    {
    	//Perhaps the window was hidden .. show it
    	//if (!IsWindowVisible(hWnd))
    	// ShowWindow(hWnd,SW_NORMAL | SW_RESTORE);

        // SetWindowPos(hWnd, HWND_TOP,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        
        if(IsWindowEnabled(hWnd))
        {
            SetActiveWindow(hWnd);
            // [PaulHi] 12/1/98  Raid #58527
            // The window may also be minimized.
            if ( IsIconic(hWnd) )
                ShowWindow(hWnd, SW_RESTORE);
        }
        else
        {
            HWND hWndC = GetLastActivePopup(hWnd);
            SetForegroundWindow(hWndC);
        }

    	{
    		// The previous instance of the Dialog might have had a different caption
    		// so we update the caption
            LPBWI lpbwi = (LPBWI) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    		if(szCaption)
    			SetWindowText(hWnd,szCaption);
            if(lpbwi)
            {
    		    bwi_bDontRefreshLV = TRUE;
                RefreshListView(lpbwi,NULL);
                bwi_bDontRefreshLV = FALSE;
            }
    		goto out;
    	}
    }

    lpbwi = LocalAlloc(LMEM_ZEROINIT, sizeof(BWI));
    if(!lpbwi)
    {
        DebugTrace( TEXT("LocalAlloc failed\n"));
        goto out;
    }

    TrimSpaces(szCaption);
    lpTitle = (szCaption && lstrlen(szCaption)) ? szCaption : CreateWindowTitle(lpIAB);

    //
    // if we're here, we didnt succeed in finding or displaying the window
    //

    wc.style           = 0L;
    wc.lpfnWndProc     = (WNDPROC) AddressBookWndProc;
    wc.cbClsExtra      = 0;
    wc.cbWndExtra      = 0;
    wc.hInstance       = hinstMapiXWAB; //NULL;
    wc.hIcon           = LoadIcon(hinstMapiX,MAKEINTRESOURCE(IDI_ICON_ABOOK));;
    wc.hCursor         = NULL;
    wc.hbrBackground   = (HBRUSH) (COLOR_BTNFACE+1);
    wc.lpszMenuName    = NULL;
    wc.lpszClassName   = g_szClass;

    if(!RegisterClass(&wc))
    {
    	DebugPrintError(( TEXT("Attempt to register class failed: %d!\n"),GetLastError()));
    }

    // In windows95 there is no way of telling wether or not the WindowClass is
    // already registered. Hence we should go ahead and try to create the window
    // anyway making sure to trap the errors.
    // (The above is really needed for Athena - which runs on the system Explorer thread
    // and never really shuts down till the system is shut off - as a result the WndClass
    // registration above would continue to exist and RegisterClass would fail due
    // to  TEXT("incorrect parameters") .. so we let this play on ..

    hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_AB));
    
    if (!hMenu)
    {
    	DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
    	goto out;
    }

    // Clean any garbage from previous sessions
    CleanUpGlobals(lpbwi);
    bwi_lpfnDismiss = NULL;
    bwi_lpvDismissContext = NULL;

#ifndef WIN16 // WIN16FF : disable until ldap16.dll is available.
    if (bwi_lpAdrBook)
    {
        ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    	bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    	bwi_lpAdrBook = NULL;
        bwi_lpIAB = NULL;
        pt_lpIAB = NULL;
    }
#else
    bwi_lpAdrBook = NULL;
    bwi_lpIAB = NULL;
#endif // !WIN16

    // we need this pointer ....
    if (!bwi_lpAdrBook)
    {
    	bwi_lpAdrBook = lpAdrBook;
        bwi_lpIAB = (LPIAB)bwi_lpAdrBook;
    	UlAddRef(bwi_lpAdrBook);
        OpenAddRefPropertyStore(NULL, bwi_lpIAB->lpPropertyStore);
        pt_lpIAB = lpAdrBook;
    }

    HrAllocAdviseSink(&AdviseOnNotify, (LPVOID) lpbwi, &(bwi_lpAdviseSink));

    DebugTrace( TEXT("WAB Window Title is \"%s\"\n"),lpTitle?lpTitle:szEmpty);

    {

        if(IS_BIDI_LOCALIZED_SYSTEM())
        {
            dwExStyle |= RTL_MIRRORED_WINDOW;
        }
        
        hWnd = CreateWindowEx( dwExStyle,
                                 g_szClass,
                                 lpTitle ? lpTitle : szEmpty,
                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                 CW_USEDEFAULT,
                                 CW_USEDEFAULT,
                                 INIT_WINDOW_W,
                                 INIT_WINDOW_H,
                                 NULL,		
                                 hMenu,			
                                 hinstMapiXWAB,	
                                 (LPVOID)lpbwi);

        if (!hWnd)
        {
    	    DebugPrintError(( TEXT("Ok. CreateWindowEx failed. Ugh.\n")));
            if (bwi_lpAdrBook)
    	    {
                ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    		    bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    		    bwi_lpAdrBook = NULL;
                bwi_lpIAB = NULL;
    	    }
    	    goto out;
        }

        // Set up the menu markers on the sort menus ...
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
        SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);
        
        // Update folders before redoing any other menu since removing folders
        // changes the order number of the other items
        UpdateSortMenus(lpbwi, hWnd);


        // **IMPORTANT**
        // These 4 calls are position based removals so order of calling them functions is important
        UpdateSwitchUsersMenu(hWnd, bwi_lpIAB);
        UpdateViewFoldersMenu(lpbwi, hWnd);
        UpdatePrintMenu(hWnd);
        UpdateOutlookMenus(hWnd);
        //////////////////////////////////////////////////////////////////////////////////

        UpdateCustomColumnMenuText(hWnd);


        IF_WIN32(ShowWindow(hWnd,SW_SHOWDEFAULT);)
        IF_WIN16(ShowWindow(hWnd,SW_SHOW);)

        if(lpAdrParms->ulFlags & DIALOG_SDI)
        {
            lpAdrParms->lpfnABSDI = &fnAccelerateMessages;
            bwi_lpfnDismiss = lpAdrParms->lpfnDismiss;
            bwi_lpvDismissContext = lpAdrParms->lpvDismissContext;
        }

        // load the accelrator table ...
        pt_hAccTable = LoadAccelerators(hinstMapiX,	 TEXT("WabUIAccel"));

        // repainting everything ...
        RedrawWindow(   hWnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
        //populate the window
        bwi_bDontRefreshLV = TRUE;
        RefreshListView(lpbwi,NULL);
        bwi_bDontRefreshLV = FALSE;

    }
out:

    if(lpTitle != szCaption)
        LocalFree(lpTitle);
    if(szCaption != lpAdrParms->lpszCaption)
        LocalFreeAndNull(&szCaption);

    return (hWnd);
}

#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#endif // WS_EX_LAYOUTRTL

//$$
//
//
void ShowToolbarItemMenu(LPBWI lpbwi, HWND hWndTools, int tbitem, int lvtb)
{
    // We're going to pop up the Action sub-menu - need to align it
    // neatly with the bottom of the toolbar
    RECT rc = {0}, rcButton = {0};
    LPARAM lp;
    SendMessage(hWndTools, TB_GETITEMRECT, (WPARAM)tbitem, (LPARAM)&rcButton);
    GetWindowRect(bwi_hWndBB, &rc);
    lp = MAKELPARAM((GetWindowLong(bwi_hWndBB, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)? rc.right - rcButton.left : rc.left + rcButton.left, rc.top + rcButton.bottom);
    ShowLVContextMenu(  lvtb, bwi_hWndListAB, NULL, lp, NULL, bwi_lpAdrBook, bwi_hWndTV);
}

//$$
//*------------------------------------------------------------------------
//| AddressBookWndProx:
//|
//*------------------------------------------------------------------------
LRESULT CALLBACK AddressBookWndProc(HWND   hWnd,
                                    UINT   uMsg,
                                    WPARAM   wParam,
                                    LPARAM lParam)
{
    static UINT uTimer = 0;
    static FILETIME ftLast = {0};
// HBRUSH to draw STATIC control's background
    IF_WIN16(static HBRUSH hBrushBack;)
    static BOOL bMouseDrag = FALSE;
    LPBWI lpbwi = (LPBWI) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    switch(uMsg)
    {
        // OE5 HACK. Do not use these WM_USER values in the WAB wndproc
        // OE subclasses the WAB to do some modal voodoo in common\ipab.cpp
        // if needs to send these private messages.
        // case WM_USER + 10666:
        // case WM_USER + 10667:
            //break;

#ifdef HM_GROUP_SYNCING
        case WM_USER_SYNCGROUPS:
            // We don't want the user to have to select the HM account for both passes, so use 
            // the TLS stored account ID if it is available.
            HrSynchronize(hWnd, bwi_lpAdrBook, lpPTGData->lptszHMAccountId, TRUE);    // Sync group contacts
            break;
#endif

        case WM_INITMENUPOPUP:
            Handle_WM_INITMENUPOPUP(hWnd, lpbwi, uMsg, wParam, lParam);
            break;

        case WM_MENUSELECT:
            Handle_WM_MENSELECT(lpbwi, uMsg, wParam, lParam);
            break;

		case WM_MOUSEMOVE:
			if(SplitterHitTest(bwi_hWndSplitter, lParam))
				SetCursor(LoadCursor(NULL, IDC_SIZEWE));
			break;

		case WM_LBUTTONDOWN:
			if(SplitterHitTest(bwi_hWndSplitter, lParam))
			{
				DragSplitterBar(lpbwi, hWnd, bwi_hWndSplitter, lParam);
			}
			break;

        case WM_COMMAND:
            {
                switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                default:
                    if(GET_WM_COMMAND_ID(wParam, lParam) >= IDM_VIEW_FOLDERS1 &&
                        GET_WM_COMMAND_ID(wParam, lParam) <= IDM_VIEW_FOLDERS1 + MAX_VIEW_FOLDERS)
                    {
                        LPWABFOLDER lpFolder = bwi_lpIAB->lpWABFolders;
                        if(lpFolder)
                        {
                            int nCmdID = GET_WM_COMMAND_ID(wParam, lParam);
                            LPSBinary lpsb = NULL;
                            while(lpFolder)
                            {
                                if(nCmdID == lpFolder->nMenuCmdID)
                                    break;
                                lpFolder = lpFolder->lpNext;
                            }

                            if(lpFolder)
                            {
                                if(!HR_FAILED(HrUpdateFolderInfo((bwi_lpIAB), &lpFolder->sbEID, 
                                                    FOLDER_UPDATE_SHARE, !lpFolder->bShared, NULL)))
                                {
                                    HrGetWABProfiles((bwi_lpIAB));
                                }
                                if(!IsWindowVisible(bwi_hWndTV))
                                    PostMessage(hWnd, WM_COMMAND, (WPARAM) IDM_VIEW_GROUPSLIST, 0);
                            }
                            if(bwi_lpUserFolder)
                                bwi_lpUserFolder = NULL;

                            //UpdateViewFoldersMenu(lpbwi, hWnd);
                            // Refresh the UI
                            GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsb, NULL, FALSE);
                            bwi_bDontRefreshLV = TRUE;
                            RefreshListView(lpbwi,&ftLast);
                            UpdateLV(lpbwi);
                            UpdateTVGroupSelection(bwi_hWndTV, lpsb);
                            bwi_bDontRefreshLV = FALSE;
                            LocalFreeSBinary(lpsb);
                        }
                    }                    
#ifdef COLSEL_MENU 
                    else if ((GET_WM_COMMAND_ID(wParam, lParam) > IDR_MENU_LVCONTEXTMENU_COLSEL) && 
                        (GET_WM_COMMAND_ID(wParam, lParam) <= (IDR_MENU_LVCONTEXTMENU_COLSEL + MAX_VIEW_COLSEL)))
                    {
                        BOOL rVal = FALSE;
                        TCHAR szBuf[MAX_PATH];
                        ULONG iCol = lpbwi->iSelColumn;
                        ULONG ulCmdId = GET_WM_COMMAND_ID(wParam, lParam);
                        ULONG iTagSel = (ulCmdId - IDR_MENU_LVCONTEXTMENU_COLSEL - 1);
                        LONG lr = 0;
                        HMENU hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXTMENU_COLSEL));
                        HMENU hSubMenu = GetSubMenu(hMenu, 0);
                        MENUITEMINFO mii;
                        if( hMenu && hSubMenu )
                        {
                            mii.fMask = MIIM_TYPE;
                            mii.dwTypeData = szBuf;
                            mii.cch = CharSizeOf( szBuf );
                            mii.cbSize = sizeof (MENUITEMINFO);
                            if ( !GetMenuItemInfo( hSubMenu, iTagSel, TRUE, &mii) )
                            {                       
                                DebugTrace( TEXT("cannot get info : %d\n"), GetLastError() );
                                rVal = TRUE;
                            }
                            else
                            {
                                if( iCol == colHomePhone || iCol == colOfficePhone)
                                {
                                    if( iCol == colHomePhone )
                                    {
                                        PR_WAB_CUSTOMPROP1 = MenuToPropTagMap[iTagSel];
                                        lstrcpy(szCustomProp1, szBuf);
                                        UpdateOptionalColumns( lpbwi, colHomePhone );
                                    }                            
                                    else
                                    {
                                        PR_WAB_CUSTOMPROP2 = MenuToPropTagMap[iTagSel];
                                        lstrcpy(szCustomProp2, szBuf);
                                        UpdateOptionalColumns( lpbwi, colOfficePhone );
                                    }
                                    UpdateLV( lpbwi );
                                    UpdateSortMenus(lpbwi, hWnd);
                                    UpdateCustomColumnMenuText(hWnd);
                                }
                            }
                        }
                        else
                        {                            
                            DebugTrace( TEXT("LoadMenu failed: %d\n"), GetLastError());
                            rVal = TRUE;
                        }
                        DestroyMenu(hMenu);
                        return rVal;
                    }
#endif //COLSEL_MENU 
                    else
                    {
                        LRESULT fRet = FALSE;
                        bwi_hti = NULL; 
                        bwi_bDontRefreshLV = TRUE;
                        fRet = ProcessActionCommands(bwi_lpIAB, bwi_hWndListAB, 
                                                      hWnd, uMsg, wParam, lParam);
                        bwi_bDontRefreshLV = FALSE;
                        return fRet;
                    }
                    break;

                case IDM_EDIT_SETME:
                    {
                        SBinary sb = {0};
                        HrSetMeObject(bwi_lpAdrBook, MAPI_DIALOG, sb, (ULONG_PTR)hWnd);
                    }
                    break;

                case IDM_FILE_EXIT:
                    SendMessage(hWnd,WM_CLOSE,0,0L);
    			    return 0;
                    break;

                case IDC_ABOOK_STATIC_QUICK_FIND:
                    SetFocus(bwi_hWndEditQF);
                    break;

    		    case IDC_BB_NEW:
                    ShowToolbarItemMenu(lpbwi, bwi_hWndTools, tbNew, lvToolBarNewEntry);
                    break;

                case IDC_BB_ACTION:
                    // OE 63674
                    // When the Print button is hidden (thanks to idsLangPrintingOn==0)
                    // The enumeration item tbAction is off by 1
                    ShowToolbarItemMenu(lpbwi, bwi_hWndTools, bPrintingOn ? tbAction : tbAction - 1, lvToolBarAction);
                    break;

                case IDM_FILE_SENDMAIL:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_SENDMAIL:
                    bwi_bDontRefreshLV = TRUE;
                    /*
                    if(bIsFocusOnTV(lpbwi) && !bIsSelectedTVContainer(lpbwi))
                    {
                        LPSBinary lpsbEID = NULL;
                        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);
                        if(lpsbEID && lpsbEID->lpb)
                        {
                            HrSendMailToSingleContact(hWnd, bwi_lpIAB, lpsbEID->cb, (LPENTRYID)lpsbEID->lpb);
                            LocalFreeSBinary(lpsbEID);
                        }
                    }
                    else
                    */
                   HrSendMailToSelectedContacts(bwi_hWndListAB, bwi_lpAdrBook, 0);
                    bwi_hti = NULL;
                    bwi_bDontRefreshLV = FALSE;
                    break;

    		    case IDC_BB_DELETE:
    		    case IDM_FILE_DELETE:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_DELETE:
                    bwi_bDontRefreshLV = TRUE;
                    // if focus is on the treeview, remove the group from the treeview
                    if(bIsFocusOnTV(lpbwi))
                    {
                        if(!bIsSelectedTVContainer(lpbwi))
                        {
                            RemoveCurrentGroup(lpbwi, hWnd, &ftLast);
                            bwi_bDeferNotification = TRUE;
                            SetFocus(bwi_hWndTV);
                        }
                        else
                        {
                            if(!HR_FAILED(RemoveCurrentFolder(lpbwi, hWnd, &ftLast)))
                            {
                                UpdateLV(lpbwi);
                                //UpdateViewFoldersMenu(lpbwi, hWnd);
                                SetFocus(bwi_hWndTV);
                                bwi_bDeferNotification = TRUE;
                            }
                        }
                        bwi_hti = NULL;
                    }
                    else
                    {
                        // Focus is on the ListView
                        // If we're looking at the root AB - remove from addressbook
                        // If we're looking at some group, remove entries from group
                        bwi_hti = NULL; // if this wasnt a context-initiated action on the tree view, dont trust the hti setting
                        if(!bIsSelectedTVContainer(lpbwi))
                        {
                            // a group is selected .. remove from the group .. unless
                            // the shift key is pressed which means remove from the 
                            // address book
                            if(GetKeyState(VK_SHIFT) & 0x80)
                                RemoveSelectedItemsFromCurrentGroup(lpbwi, hWnd, &ftLast, TRUE);
                            else
                                RemoveSelectedItemsFromCurrentGroup(lpbwi, hWnd, &ftLast, FALSE);
                            bwi_hti = NULL;
                            bwi_bDontRefreshLV = TRUE;
	                        RefreshListView(lpbwi,&ftLast);
                            bwi_bDontRefreshLV = FALSE;
                            bwi_bDeferNotification = TRUE;
                        }
                        else // Container selected - remove selected items from the container
                        {
                            DeleteSelectedItems(bwi_hWndListAB, (LPADRBOOK)bwi_lpAdrBook, bwi_lpIAB->lpPropertyStore->hPropertyStore, &ftLast);
                            bwi_hti = NULL;
                            bwi_bDontRefreshLV = TRUE;
	                        RefreshListView(lpbwi,&ftLast);
                            bwi_bDontRefreshLV = FALSE;
                            bwi_bDeferNotification = TRUE;
                        }
                        SetFocus(bwi_hWndListAB);
                    }
                    bwi_hti = NULL;
				    UpdateToolbarAndMenu(lpbwi);
                    bwi_bDontRefreshLV = FALSE;
    			    return 0;
    			    break;

                case IDM_FILE_NEWFOLDER:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_NEWFOLDER:
                    bwi_bDontRefreshLV = TRUE;
                    {
                        LPWABFOLDER lpParent = GetSelectedUserFolder(lpbwi);
                        LPSBinary lpNew = NULL;
                        SBinary sbNewFolder = {0}, sbParent = {0};
                        if(lpParent)
                            SetSBinary(&sbParent, lpParent->sbEID.cb, lpParent->sbEID.lpb);
                        HrFolderProperties(hWnd, bwi_lpIAB, NULL, lpParent, &sbNewFolder);
                        if(sbNewFolder.lpb)
                            lpNew = &sbNewFolder;
                        else if(lpParent)
                            lpNew = &sbParent;
                        //UpdateViewFoldersMenu(lpbwi, hWnd);
                        if(!IsWindowVisible(bwi_hWndTV))
                            PostMessage(hWnd, WM_COMMAND, (WPARAM) IDM_VIEW_GROUPSLIST, 0);
                        HrGetWABProfiles(bwi_lpIAB);
                        RefreshListView(lpbwi, NULL);
                        if(lpNew && lpNew->cb)
                            UpdateTVGroupSelection(bwi_hWndTV, lpNew);
                        LocalFreeAndNull((LPVOID *) (&(sbParent.lpb)));
                        LocalFreeAndNull((LPVOID *) (&(sbNewFolder.lpb)));
                    }
                    bwi_bDontRefreshLV = FALSE;
                    bwi_bDeferNotification = TRUE;
                    bwi_hti = NULL;
                    break;

    		    case IDM_FILE_NEWGROUP:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_NEWGROUP:
    		    //case IDC_BB_NEW_GROUP:
                    {
                        ULONG cbEID = 0;
                        LPENTRYID lpEID = NULL;
                        HRESULT hr = S_OK;
                        bwi_bDontRefreshLV = TRUE;
    			        hr = AddNewObjectToListViewEx(bwi_lpAdrBook, bwi_hWndListAB, bwi_hWndTV, bwi_hti,
                                                    NULL, MAPI_DISTLIST,
                                                    &bwi_SortInfo, &bwi_lpContentsList, &ftLast,
                                                    &cbEID, &lpEID);
                        if(hr != MAPI_E_USER_CANCEL)
                        {
                            bwi_hti = NULL;
                            RefreshListView(lpbwi,&ftLast);
                            if(cbEID && lpEID && IsWindowVisible(bwi_hWndTV))
                            {
                                SBinary sbEID = {cbEID, (LPBYTE)lpEID };
                                UpdateTVGroupSelection(bwi_hWndTV,&sbEID);
                                FreeBufferAndNull(&lpEID);
                            }
                        }
                        bwi_bDontRefreshLV = FALSE;
                        //bwi_bDeferNotification = TRUE;
                        UpdateToolbarAndMenu(lpbwi);
                    }
    			    break;

    		    case IDM_FILE_NEWCONTACT:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_NEWCONTACT:
                    bwi_bDontRefreshLV = TRUE;
    			    AddNewObjectToListViewEx( bwi_lpAdrBook, bwi_hWndListAB, bwi_hWndTV, bwi_hti,
                                                NULL, MAPI_MAILUSER,
                                                &bwi_SortInfo, &bwi_lpContentsList, &ftLast,NULL,NULL);
                    //RefreshListView(lpbwi,&ftLast);
                    bwi_hti = NULL;
                    //bwi_bDeferNotification = TRUE;
                    bwi_bDontRefreshLV = FALSE;
                    UpdateToolbarAndMenu(lpbwi);
    			    break;

                case IDM_TOOLS_OPTIONS:
                    HrShowOptionsDlg(hWnd);
                    break;
                
                case IDM_TOOLS_SYNCHRONIZE_NOW:
#ifdef HM_GROUP_SYNCING
                    HrSynchronize(hWnd, bwi_lpAdrBook, NULL, FALSE);    // Sync mail contacts
#else
                    HrSynchronize(hWnd, bwi_lpAdrBook, NULL);
#endif
                    break;

                case IDM_FILE_DIRECTORY_SERVICE:
                    HrShowDirectoryServiceModificationDlg(hWnd, bwi_lpIAB);
                    break;


                case IDC_BB_PRINT:
                case IDM_FILE_PRINT:
                    if(bPrintingOn)
                    {
                        TCHAR szBuf[MAX_PATH];
                        bwi_bDontRefreshLV = TRUE;
                        LoadString(hinstMapiX, idsPrintStatusBarMessage, szBuf, CharSizeOf(szBuf));
                        StatusBarMessage(lpbwi, szBuf);
                        HrPrintItems(hWnd, bwi_lpAdrBook, bwi_hWndListAB, bwi_SortInfo.bSortByLastName);
                        ShowLVCountinStatusBar(lpbwi);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

                case IDM_EDIT_COPY:
                        bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_COPY:
                    {
                        LPIWABDATAOBJECT lpIWABDataObject = NULL;
                        bwi_bDontRefreshLV = TRUE;
                        HrCreateIWABDataObject((LPVOID)lpbwi, bwi_lpAdrBook, bwi_hWndListAB, &lpIWABDataObject, 
                                                TRUE,bCheckIfOnlyGroupsSelected(bwi_hWndListAB));
                        if(lpIWABDataObject)
                        {
                            bwi_lpIWABDragDrop->m_bSource = TRUE;
                            OleSetClipboard((LPDATAOBJECT) lpIWABDataObject);
                            bwi_lpIWABDragDrop->m_bSource = FALSE;
                            lpIWABDataObject->lpVtbl->Release(lpIWABDataObject);
                        }
                        //HrCopyItemDataToClipboard(hWnd, bwi_lpAdrBook, bwi_hWndListAB);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

                case IDM_EDIT_PASTE:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_PASTE:
                    {
                        LPDATAOBJECT lpDataObject = NULL;
                        bwi_bDontRefreshLV = TRUE;
                        if(bIsPasteData())
                        {
                            if(S_OK == HrPasteData(lpbwi))
                                UpdateLV(lpbwi);
                        }
                        //HrCopyItemDataToClipboard(hWnd, bwi_lpAdrBook, bwi_hWndListAB);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

    		    case IDC_BB_FIND:
    		    case IDM_EDIT_FIND:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_FIND:
                    bwi_bDontRefreshLV = TRUE;
                    HrShowSearchDialog((LPADRBOOK) bwi_lpAdrBook,
                                        bwi_hWndAB,
                                        (LPADRPARM_FINDINFO) NULL,
                                        (LPLDAPURL) NULL,
                                        &(bwi_SortInfo));
                    bwi_hti = NULL;
                    RefreshListView(lpbwi,&ftLast);
                    bwi_bDeferNotification = TRUE;
                    bwi_bDontRefreshLV = FALSE;
                    UpdateToolbarAndMenu(lpbwi);
                    SetFocus(bwi_hWndListAB);
    			    break;

    		    case IDM_EDIT_SELECTALL:
                    {
                        int index = 0;
                        int iTotal = ListView_GetItemCount(bwi_hWndListAB);
                        if (iTotal > 0)
                        {
                            for(index=0;index<iTotal;index++)
                            {
                                ListView_SetItemState ( bwi_hWndListAB,  // handle to listview
    							                        index,			// index to listview item
    							                        LVIS_SELECTED,  // item state
    							                        LVIS_SELECTED); // mask
                            }
                        }

                    }
    			    break;


                case IDM_HELP_ADDRESSBOOKHELP:
                    WABHtmlHelp(hWnd,  TEXT("%SYSTEMROOT%\\help\\wab.chm>iedefault"), 
                        HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR)  TEXT("wab_welcome.htm"));
    			    break;

    		    case IDM_HELP_ABOUTADDRESSBOOK:
                    DialogBox(  hinstMapiX,
                                MAKEINTRESOURCE(IDD_DIALOG_ABOUT),
                                hWnd,
                                (DLGPROC) HelpAboutDialogProc);
                    break;

                case IDM_FILE_SWITCHUSERS:
                    HrLogonAndGetCurrentUserProfile(hWnd, bwi_lpIAB, TRUE, FALSE);
                    break;

                case IDM_FILE_SHOWALLCONTENTS:
                    RunWABApp(hWnd, szWABExeRegPathKey, szWABExe, TEXT("/all"));
                    break;

                case IDM_NOTIFY_REFRESHUSER:
                    {
                        LPTSTR lpTitle = CreateWindowTitle(bwi_lpIAB);
                        SetWindowText(hWnd, lpTitle);
                        LocalFreeAndNull(&lpTitle);
                        ReadWABCustomColumnProps(bwi_lpIAB);
                        UpdateOptionalColumns( lpbwi, colHomePhone );
                        UpdateOptionalColumns( lpbwi, colOfficePhone );
                        ReadRegistrySortInfo(bwi_lpIAB,&bwi_SortInfo);
                        RefreshListView(lpbwi, NULL);
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
                            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
                        }
                    }
                    break;

    		    case IDM_FILE_PROPERTIES:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 2)
                    {
                        if( (GetKeyState(VK_CONTROL) & 0x80) &&
                            (GetKeyState(VK_MENU)  & 0x80) &&
                            (GetKeyState(VK_SHIFT) & 0x80))
                        {
                            SCS(hWnd);
                            break;
                        }
                    }
                    else
                        bwi_nCount = 0;*/
    		    case IDC_BB_PROPERTIES:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_PROPERTIES:
                    bwi_bDontRefreshLV = TRUE;
                    if(bIsFocusOnTV(lpbwi))
                    {
                        ViewCurrentGroupProperties(lpbwi, &ftLast);
                        bwi_bDeferNotification = TRUE;
                    }
                    else
    			    {
    				    HRESULT hr = HrShowLVEntryProperties(bwi_hWndListAB, WAB_ONEOFF_NOADDBUTTON, bwi_lpAdrBook, &ftLast);
                        bwi_hti = NULL;
                        if(hr == MAPI_E_OBJECT_CHANGED)
                        {
                            bwi_bDeferNotification = TRUE;
                            // resort the display
                            SendMessage(bwi_hWndListAB, WM_SETREDRAW, FALSE, 0);
                            SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
                            SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0);
                        }
                        bwi_bDontRefreshLV = FALSE;
    				    return 0;
    			    }
                    bwi_bDontRefreshLV = FALSE;
    			    break;


    		    case IDM_VIEW_REFRESH:
                    bwi_bDontRefreshLV = TRUE;
                    bwi_hti = NULL;
                    HrGetWABProfiles(bwi_lpIAB);
    			    RefreshListView(lpbwi,&ftLast);
                    bwi_bDontRefreshLV = FALSE;
    			    return 0;
    			    break;


                case IDM_VIEW_STATUSBAR:
                    if (IsWindowVisible(bwi_hWndSB))
                    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndSB, SW_HIDE);
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndSB, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    InvalidateRect(bwi_hWndListAB,NULL,TRUE);
                        ShowLVCountinStatusBar(lpbwi);
                    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
                    break;

    		    case IDM_VIEW_TOOLBAR:
    			    if (IsWindowVisible(bwi_hWndBB))
    			    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndBB, SW_HIDE);
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndBB, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    InvalidateRect(bwi_hWndListAB,NULL,TRUE);
    				    InvalidateRect(bwi_hWndTV,NULL,TRUE);
    			    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
    			    break;

                case IDM_VIEW_GROUPSLIST:
    			    if (IsWindowVisible(bwi_hWndTV))
    			    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndTV, SW_HIDE);
    				    ShowWindow(bwi_hWndSplitter, SW_HIDE);
                        InvalidateRect(bwi_hWndStaticQF, NULL, TRUE);
                        // If this is a user based session, we want the hidden focus to be on the user's
                        // folder not on the Shared Contacts
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
                            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
                        }
                        else
                        {
                            // Set the selection to the root address book so we see the file
                            // contents just as if we dont have a treeview at all
                            HTREEITEM hItem = TreeView_GetSelection(bwi_hWndTV);
                            HTREEITEM hRoot = TreeView_GetRoot(bwi_hWndTV);
                            if(hItem != hRoot)
                                TreeView_SelectItem(bwi_hWndTV, hRoot);
                        }
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndTV, SW_NORMAL);
    				    ShowWindow(bwi_hWndSplitter, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    //InvalidateRect(bwi_hWndListAB,NULL,TRUE);
    				    //InvalidateRect(bwi_hWndTV,NULL,TRUE);
    			    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
                    SaveCurrentPosition(lpbwi, hWnd,bwi_hWndListAB,bwi_hWndBB,bwi_hWndSB);
                    break;

                case IDM_VIEW_SORTBY_DISPLAYNAME:
                case IDM_VIEW_SORTBY_EMAILADDRESS:
                case IDM_VIEW_SORTBY_BUSINESSPHONE:
                case IDM_VIEW_SORTBY_HOMEPHONE:
                    {
                        //Assuming the above ids are in sequential order ...
                        int iCol = LOWORD(wParam) - IDM_VIEW_SORTBY_DISPLAYNAME;
                        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, iCol, &bwi_SortInfo, FALSE);
                        UpdateSortMenus(lpbwi, hWnd);
                    }
                    break;


                case IDM_VIEW_SORTBY_FIRSTNAME:
                    bwi_SortInfo.bSortByLastName = FALSE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_LASTNAME:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 1)
                        bwi_nCount++;
                    else
                        bwi_nCount = 0;*/
                    bwi_SortInfo.bSortByLastName = TRUE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_DESCENDING:
                    bwi_SortInfo.bSortAscending = FALSE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_ASCENDING:
                    bwi_SortInfo.bSortAscending = TRUE;
                    DoSortMenuStuff:
                        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, 0, &bwi_SortInfo, TRUE);
                        UpdateSortMenus(lpbwi, hWnd);
                    break;


    		    // miscellanous styles for the list view control
                case IDM_VIEW_LARGEICON:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 0)
                        bwi_nCount++;*/
                case IDM_VIEW_SMALLICON:
                case IDM_VIEW_LIST:
                case IDM_VIEW_DETAILS:
                    SetListViewStyle(lpbwi, LOWORD(wParam));
    			    CheckMenuRadioItem(	GetMenu(hWnd),
    								    IDM_VIEW_LARGEICON,
    								    IDM_VIEW_DETAILS,
    								    LOWORD(wParam),
    								    MF_BYCOMMAND);
    			    return 0;
                    break;

    		    case IDC_EDIT_QUICK_FIND:
    			    switch(HIWORD(wParam)) //check the notification code
    			    {
    			    case EN_CHANGE: //edit box changed
    					DoLVQuickFind(bwi_hWndEditQF,bwi_hWndListAB);
/*                            if(bwi_bDoQuickFilter)
                            {
                                DoLVQuickFilter(bwi_lpAdrBook,
                                                bwi_hWndEditQF,
                                                bwi_hWndListAB,
                                                &bwi_SortInfo,
                                                AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL,
                                                1,
                                                &bwi_lpContentsList);

                                ShowLVCountinStatusBar(lpbwi);
                            }
*/
    				    break;
    			    }
    			    break;

                case IDM_TOOLS_EXPORT_WAB:
                    HrExportWAB(hWnd, lpbwi);
                    break;

                case IDM_TOOLS_EXPORT_OTHER:
                case IDM_TOOLS_IMPORT_OTHER:
                    {
                        // if there is a current user, then we let wabmig.exe automatically
                        // loginto the current user in the WAB .. else we need to send the filename etc
                        //
                        BOOL bImport = (GET_WM_COMMAND_ID(wParam, lParam) == IDM_TOOLS_IMPORT_OTHER);
                        TCHAR szParam[MAX_PATH * 2];
                        
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            lstrcpy(szParam, bImport ? szIMPORT : szEXPORT);
                        }
                        else
                        {
                            LPTSTR lpWABFile = NULL, lpProfileID = szEmpty;
                            lpWABFile = GetWABFileName( bwi_lpIAB->lpPropertyStore->hPropertyStore, FALSE);
                            if(!lpWABFile || !lstrlen(lpWABFile))
                                lpWABFile = szEmpty;
                            wsprintf(szParam, (bImport ? szIMPORTwProfileParam : szEXPORTwProfileParam), 
                                    szEmpty, lpWABFile);
                        }
                        RunWABApp(hWnd, szWABMigRegPathKey, szWABMIG, szParam);
                    }
                    break;


                case IDM_TOOLS_IMPORT_WAB:
                    bwi_bDontRefreshLV = TRUE;
                    //bwi_bDeferNotification = TRUE;
                    HrImportWABFile(hWnd, bwi_lpAdrBook, MAPI_DIALOG, NULL);
                    bwi_bDontRefreshLV = FALSE;
                    RefreshListView(lpbwi, &ftLast);
                    break;

    #ifdef VCARD
                case IDM_TOOLS_EXPORT_VCARD:
                    bwi_bDontRefreshLV = TRUE;
                    VCardExportSelectedItems(bwi_hWndListAB, bwi_lpAdrBook);
                    bwi_bDontRefreshLV = FALSE;
                    return(0);

                case IDM_TOOLS_IMPORT_VCARD:
                    OpenAndAddVCard(lpbwi, NULL);
                    return(0);
    #endif
                }
            }
    		break;

       case WM_TIMER:
           {
               // Check if we need to refresh
               switch(wParam)
               {
                   /*
               case WAB_REFRESH_TIMER:
                    if (    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, &ftLast))
                    {
                        if(!bwi_bDontRefreshLV)
                            RefreshListView(lpbwi,&ftLast);
                        return(0);
                    }
                    else
                    {
                        return(DefWindowProc(hWnd,uMsg,wParam,lParam));
                    }
                    break;
                    */
               case WAB_TOOLTIP_TIMER_ID:
                   {
                        if(GetActiveWindow() == hWnd)
                        {
                            // We seem to get the message anytime the mouse is sitting idle on the
                            // list view - or when the selection changes between items
                            if(bwi_tt_bActive)
                            {
                                // The tooltip is already active
                                // Get the item index number of the item under the mouse
                                //
                                int nItem = HitTestLVSelectedItem(lpbwi);

                                if(nItem != bwi_tt_iItem)
                                {
                                    bwi_tt_bShowTooltip = FALSE;
                                    bwi_tt_iItem = nItem;
                                }
                                else
                                {
                                    if(!bwi_tt_bShowTooltip)
                                    {
                                        // if this is an item other than the previous item
                                        // we update the tooltip and move it
                                        TOOLINFO ti = {0};

                                        bwi_tt_bShowTooltip = TRUE;

                                        bwi_tt_iItem = nItem;

                                        FillTooltipInfo(lpbwi, &ti);
                                        bwi_tt_szTipText[0]='\0';
                                        ti.lpszText = szEmpty;

                                        // There is a case where nItem transitions from valid to
                                        // invalid (-1) item. Cover that case too.
                                        if(nItem != -1)
                                            UpdateTooltipTextBuffer(lpbwi, nItem);

                                        // Set the tooltip text to  TEXT("") - this will hide the tooltip
                                        ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);

                                        if(nItem != -1)
                                        {
                                            POINT pt;
                                            // Move the tooltip
                                            GetCursorPos(&pt);
                                            SendMessage(bwi_hWndTT,TTM_TRACKPOSITION,0,(LPARAM)MAKELPARAM(pt.x+15,pt.y+15));

                                            // Set the new text to the tooltip
                                            ti.lpszText = bwi_tt_szTipText;
                                            ToolTip_UpdateTipText(bwi_hWndTT,(LPARAM)&ti);
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // reset the tooltip text ...
                            if(bwi_tt_bActive)
                            {
                                //set the tooltip text to empty
                                TOOLINFO ti = {0};
                                FillTooltipInfo(lpbwi, &ti);
                                ti.lpszText = szEmpty; //LPSTR_TEXTCALLBACK;
                                ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);
                                bwi_tt_iItem = -1;
                            }
                        }
                   }
                   break;
               }
           }
           break;

    	case WM_GETMINMAXINFO:
    		//enforce a minimum size for sanity
    		return EnforceMinSize(lpbwi, hWnd, uMsg, wParam, lParam);
    		break;

        case PUI_OFFICE_COMMAND:
            // WAB should not shut down if it is running as part of some other process .. it should only shut down if 
            // it is running in a seperate process ..
            // To find out if we were invoked by wab.exe, check the cached guidPSExt on the LPIAB object
            if(memcmp(&bwi_lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)))
            {
                DebugTrace( TEXT("Ignoring the Plug_UI command...\n"));
                return 0;
            }

            // We get this message when user switches his locale and IE tells us it wants us to shut down
            if(wParam == PLUGUI_CMD_QUERY)
            {
                PLUGUI_QUERY pq;

                pq.uQueryVal = 0; // initialize
                pq.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9; // Value filled in by Apps
                pq.PlugUIInfo.uOleServer = FALSE;              // Value filled in by Apps

                return (pq.uQueryVal); // The state of the App
            }
            // for any others parameters, including PLUGUI_CMD_SHUTDOWN
            // fall to close application

    	case WM_CLOSE:
            {
                BOOL bDragDrop = FALSE;

                if(bwi_lpIWABDragDrop)
			    {
                    bDragDrop = TRUE;
				    RevokeDragDrop(bwi_hWndListAB);
				    RevokeDragDrop(bwi_hWndTV);
				    CoLockObjectExternal((LPUNKNOWN) bwi_lpIWABDragDrop, FALSE, TRUE);
				    bwi_lpIWABDragDrop->lpVtbl->Release(bwi_lpIWABDragDrop);
				    bwi_lpIWABDragDrop = NULL;
			    }

                bwi_bDontRefreshLV = TRUE;

                ClearTreeViewItems(bwi_hWndTV);
                ListView_DeleteAllItems(bwi_hWndListAB);

                //
                // Save the sort info to the registry
                //
                WriteRegistrySortInfo(bwi_lpIAB, bwi_SortInfo);
                SaveCurrentPosition(lpbwi, hWnd,bwi_hWndListAB,bwi_hWndBB,bwi_hWndSB);
                if(bwi_lpfnDismiss)
                {
                    (*bwi_lpfnDismiss)((ULONG_PTR) hWnd, (LPVOID) bwi_lpvDismissContext);
                    bwi_lpfnDismiss = NULL;
                }
                bwi_lpvDismissContext = NULL;
    		    DestroyWindow(hWnd);
                // In case the search window was every shown and the LDAP Client DLL was
                // initialized, we deinitialize it just once to save time, when this
                // window shuts down ...
                {
                    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    DeinitLDAPClientLib();
                    SetCursor(hOldCur);
                }
                OleFlushClipboard();

    		    return 0;
            }
    		break;


        case WM_DESTROY:
            {
                int i = 0;
                LPPTGDATA lpPTGData=GetThreadStoragePointer();

                bwi_lpIAB->hWndBrowse = NULL;

                if(bwi_lpAdviseSink)
                {
                    bwi_lpAdrBook->lpVtbl->Unadvise(bwi_lpAdrBook, bwi_ulAdviseConnection);
                    bwi_lpAdviseSink->lpVtbl->Release(bwi_lpAdviseSink);
                    bwi_lpAdviseSink = NULL;
                    bwi_ulAdviseConnection = 0;
                }

                if (bwi_lpAdrBook)
    		    {
                    ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    			    bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    			    bwi_lpAdrBook = NULL;
                    bwi_lpIAB = NULL;
                    pt_lpIAB = NULL;
    		    }

                if (bwi_tt_TooltipTimer)
                    KillTimer(hWnd, bwi_tt_TooltipTimer);

                if (uTimer)
                    KillTimer(hWnd, uTimer);

                if(bwi_hWndAB)
                    DestroyMenu(GetMenu(bwi_hWndAB));


                // reset subclassed procs
                for(i=0;i<s_Max;i++)
                {
    	            SetWindowLongPtr (bwi_s_hWnd[i], GWLP_WNDPROC, (LONG_PTR) bwi_fnOldProc[i]);
                }

                DestroyImageLists(lpbwi);
                CleanUpGlobals(lpbwi);

                LocalFree(lpbwi);
                lpbwi = NULL;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM) NULL);

                // Delete background brush, WIN16 specific.
                IF_WIN16(DeleteObject(hBrushBack);)
            }
            break;



        case WM_CREATE:
            {
                lpbwi = (LPBWI) ((LPCREATESTRUCT) lParam)->lpCreateParams;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM) lpbwi);
                bwi_hWndAB = hWnd;
                bwi_lpIAB->hWndBrowse = hWnd;
                CreateAddressBookChildren(lpbwi, hWnd);
    		    InitChildren(lpbwi, hWnd);
                ReadRegistrySortInfo(bwi_lpIAB,&bwi_SortInfo);
                SetPreviousSessionPosition(lpbwi, hWnd, bwi_hWndListAB, bwi_hWndBB,bwi_hWndSB);
                SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);

                // Tooltip Timer
                bwi_tt_TooltipTimer = SetTimer(hWnd,
                                        WAB_TOOLTIP_TIMER_ID,
                                        WAB_TOOLTIP_TIMER_TIMEOUT,
                                        NULL);

                if(bwi_lpAdviseSink)
                {
                    // Register for notifications
                    bwi_lpAdrBook->lpVtbl->Advise(  bwi_lpAdrBook, 0, NULL, fnevObjectModified, 
                                                bwi_lpAdviseSink, &bwi_ulAdviseConnection); 
                }

/*
                // UI Refresh timer
                uTimer = SetTimer(hWnd,     // handle of window for timer messages
                  WAB_REFRESH_TIMER,          // timer identifier
                  WAB_REFRESH_TIMEOUT,        // time-out value
                  NULL);                      // address of timer procedure
*/
                // Create default background brush, WIN16 only
                IF_WIN16(hBrushBack = CreateSolidBrush (GetSysColor (COLOR_BTNFACE)) ;)

				HrCreateIWABDragDrop(&bwi_lpIWABDragDrop);
				if(bwi_lpIWABDragDrop)
				{
                    bwi_lpIWABDragDrop->m_lpv = (LPVOID) lpbwi;
                    UIOLEInit();
					CoLockObjectExternal((LPUNKNOWN) bwi_lpIWABDragDrop, TRUE, FALSE);
					RegisterDragDrop(bwi_hWndListAB, (LPDROPTARGET) bwi_lpIWABDragDrop->lpIWABDropTarget);
					RegisterDragDrop(bwi_hWndTV, (LPDROPTARGET) bwi_lpIWABDragDrop->lpIWABDropTarget);
				}
                {
                    LPPTGDATA lpPTGData=GetThreadStoragePointer();
                    if(pt_bFirstRun)
                        pt_bFirstRun = FALSE;
                }
            }
            if(bIsThereACurrentUser(bwi_lpIAB))
                UpdateTVGroupSelection(bwi_hWndTV, &(bwi_lpIAB->lpWABCurrentUserFolder->sbEID));
            break;


        case WM_SIZE:
            ResizeAddressBookChildren(lpbwi, hWnd);
            break;


    	case WM_KEYDOWN:
            {
    		    switch(wParam)
    		    {
    		    case VK_TAB:
    			    SetFocus(bwi_s_hWnd[bwi_iFocus]);
    			    return 0;
    			    break;

    		    case VK_ESCAPE:
                    SendMessage(hWnd,WM_CLOSE,0,0L);
    			    return 0;
                    break;
    		    }
            }
    		break;


        case WM_NOTIFY:
    		switch((int) wParam)
    		{
    		case IDC_LISTVIEW:
    			return ProcessListViewMessages(lpbwi, hWnd,uMsg,wParam,lParam);
    			break;
            case IDC_TREEVIEW:
    			return ProcessTreeViewMessages(lpbwi, hWnd,uMsg,wParam,lParam, &ftLast);
                break;
    		}
            switch(((LPNMHDR) lParam)->code)
            {
            case TTN_POP:
                {
                    // Need to turn off the hot item
                    // Find the first selected item in the list view
                    //int nItem = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);
                    ListView_SetHotItem(bwi_hWndListAB, -1); //nItem);
                }
                break;

            case TTN_SHOW:
                {
                    // Set the hot item
                    ListView_SetHotItem(bwi_hWndListAB, bwi_tt_iItem);
                }
                break;

            case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpttt;
                    int nItem = HitTestLVSelectedItem(lpbwi);
                    DebugPrintTrace(( TEXT("Tooltip NeedText\n")));
                    lpttt = (LPTOOLTIPTEXT) lParam;
                    if (nItem != -1)
                    {
                        UpdateTooltipTextBuffer(lpbwi, nItem);
                        lpttt->lpszText = bwi_tt_szTipText;
                    }
                    else
                        lpttt->lpszText = szEmpty;
                }
                break;
            }
    		break;


    	case WM_SETTINGCHANGE:
            // [PaulHi] 3/17/99  Raid 68541  Redraw window with new system settings
            // [PaulHi] 4/19/99 Recompute the font sizes, in case they changed.
            // Fonts used for bolding list items
            DeleteFonts();
            InitFonts();
            // Fonts used for all children windows
            if(pt_hDefFont)
            {
                DeleteObject(pt_hDefFont);
                pt_hDefFont = NULL;
            }
            if(pt_hDlgFont)
            {
                DeleteObject(pt_hDlgFont);
                pt_hDlgFont = NULL;
            }
            EnumChildWindows(hWnd,
                SetChildDefaultGUIFont,
                (LPARAM) PARENT_IS_WINDOW);
            InvalidateRect(hWnd, NULL, TRUE);
            ResizeAddressBookChildren(lpbwi, hWnd);
            // Drop through...
        case WM_SYSCOLORCHANGE:
            {
    		    //Forward any system changes to the list view
		        SendMessage(bwi_hWndListAB, uMsg, wParam, lParam);
		        SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);
    		    SendMessage(bwi_hWndBB, uMsg, wParam, lParam);
            }
    		break;

#ifndef WIN16 // Disable CONTEXTMENU here.
              // All context menu will be handled notify handler.
    	case WM_CONTEXTMENU:
            {
                if ((HWND)wParam == bwi_hWndListAB)
                {                    
#ifdef COLSEL_MENU 
                    HWND hHeader = ListView_GetHeader(bwi_hWndListAB);
                    POINT pointScreen, pointHeader;
                    DWORD dwPos;
                    char szClass[50];
                    dwPos = GetMessagePos();
                    pointScreen.x = LOWORD(dwPos);
                    pointScreen.y = HIWORD(dwPos);
                    if ( hHeader )
                    {                      
                        HD_HITTESTINFO hdhti;
                        pointHeader = pointScreen;
                        ScreenToClient( hHeader, &pointHeader) ;
                        hdhti.pt = pointHeader;
                        SendMessage( hHeader, HDM_HITTEST, (WPARAM)(0), 
                            (LPARAM)(HD_HITTESTINFO FAR *)&hdhti);                        
                        if( hdhti.flags == HHT_ONHEADER && 
                            (hdhti.iItem == colHomePhone || hdhti.iItem == colOfficePhone) )
                        {
                            lpbwi->iSelColumn = hdhti.iItem;
                            ShowLVContextMenu( lvMainABHeader, bwi_hWndListAB,
                                               NULL, lParam, (LPVOID)IntToPtr(hdhti.iItem), bwi_lpAdrBook, bwi_hWndTV); 
                        }
                        else
                        {
#endif // COLSEL_MENU 
                            ShowLVContextMenu(  lvMainABView,
                                bwi_hWndListAB,
                                NULL, lParam,
                                NULL, bwi_lpAdrBook, bwi_hWndTV);
#ifdef COLSEL_MENU 
                        }
                    }
#endif // COLSEL_MENU 
                }
                else if((HWND)wParam==bwi_hWndTV)
                {
                    HTREEITEM hti = NULL;
                    if(lParam == -1)
                        hti = TreeView_GetSelection(bwi_hWndTV);
                    else
                    {
                        TV_HITTESTINFO tvhti;
                        POINT pt = {LOWORD(lParam), HIWORD(lParam)};
                        ScreenToClient(bwi_hWndTV, &pt);
                        tvhti.pt = pt;
                        hti = TreeView_HitTest(bwi_hWndTV, &tvhti);
                    }
                    
                    if (hti == NULL)
                        return 0;
                    
                    TreeView_SelectDropTarget(bwi_hWndTV, hti);
                    
                    // cache the selected item for later processing 
                    bwi_hti = hti;
                    bwi_lpUserFolder = GetSelectedUserFolder(lpbwi);
                    
                    if(!ShowLVContextMenu(  lvMainABTV,
                        bwi_hWndListAB,
                        NULL, lParam,
                        (LPVOID) bwi_lpUserFolder, bwi_lpAdrBook, bwi_hWndTV))
                    {
                        bwi_hti = NULL;
                    }
                    
                    TreeView_SelectDropTarget(bwi_hWndTV, NULL);
                }
                else
                    return DefWindowProc(hWnd,uMsg,wParam,lParam);
            }
            break;
#endif // !WIN16
            
#ifdef WIN16 // Change Static controls background color
		case WM_CTLCOLOR:
			switch(HIWORD(lParam)) {
            	case CTLCOLOR_STATIC:

                /* Set background to btnface color */
                SetBkColor((HDC) wParam,GetSysColor (COLOR_BTNFACE) );
				return (DWORD)hBrushBack;
        	}
        	return NULL;
#endif
        default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
            if((g_msgMSWheel && uMsg == g_msgMSWheel) 
//                || uMsg == WM_MOUSEWHEEL
                )
            {
                if(bIsFocusOnTV(lpbwi))
                    SendMessage(bwi_hWndTV, uMsg, wParam, lParam);
                else
                    SendMessage(bwi_hWndListAB, uMsg, wParam, lParam);
                break;
            }
#endif // !WIN16
            return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }

    return 0;
}



//$$
//*------------------------------------------------------------------------
//| CreateAddressBookChildren:
//|
//*------------------------------------------------------------------------
void CreateAddressBookChildren(LPBWI lpbwi, HWND hWndParent)
{
	HINSTANCE hinst = hinstMapiXWAB;
    TCHAR szBuf[MAX_PATH];
    HDC hdc = GetDC(hWndParent);
    int i;
    HFONT hFnt = GetStockObject(DEFAULT_GUI_FONT);
    SIZE size;
#ifdef WIN16
    // Remove bold.
    LOGFONT lf;

    GetObject(hFnt, sizeof(LOGFONT), &lf);
    lf.lfWeight = FW_NORMAL;
    DeleteObject(hFnt);
    LoadString(hinstMapiX, idsDefaultDialogFace, lf.lfFaceName, CharSizeOf(lf.lfFaceName));
    hFnt = CreateFontIndirect(&lf);
#endif


    bwi_hWndBB = CreateCoolBar(lpbwi, hWndParent);


    bwi_hWndSB = CreateWindowEx( 0,
                                STATUSCLASSNAME,
                                szEmpty,
                                WS_CHILD /*| WS_BORDER */| WS_VISIBLE | SBS_SIZEGRIP,
                                0,0,0,0,
                                hWndParent,
                                (HMENU) IDC_STATUSBAR,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndSB, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    bwi_hWndTV = CreateWindowEx( WS_EX_CLIENTEDGE,
                                WC_TREEVIEW,
                                (LPTSTR) NULL,
                                WS_VISIBLE | WS_CHILD | TVS_HASLINES | TVS_LINESATROOT |
                                TVS_HASBUTTONS | TVS_SHOWSELALWAYS | WS_BORDER,
                                0,0,
                                150, //default width
                                CW_USEDEFAULT,
                                hWndParent,
                                (HMENU) IDC_TREEVIEW,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndTV, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);


	{
#ifndef WIN16
		WNDCLASSEX wc = {0};
#else
		WNDCLASS   wc = {0};
#endif



		bwi_hWndSplitter = CreateWindowEx(0,
										 TEXT("STATIC"),
										szEmpty,
										WS_CHILD | WS_VISIBLE,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										hWndParent,
										(HMENU) IDC_SPLITTER,
										hinst,
										NULL);
		SendMessage(bwi_hWndSplitter, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

	}

    bwi_hWndTT = CreateWindowEx( 0,
                                TOOLTIPS_CLASS,
                                (LPTSTR) NULL,
                                TTS_ALWAYSTIP,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hWndParent,
                                (HMENU) NULL, //IDC_TOOLTIP,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndTT, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    // Create main list view
    bwi_hWndListAB = CreateWindowEx (
                               WS_EX_CLIENTEDGE,
                               WC_LISTVIEW,                            // list view class
                               szEmpty,                                 // no default text
                               WS_TABSTOP | WS_HSCROLL | WS_VSCROLL |
    						   WS_VISIBLE | WS_CHILD | //WS_BORDER |
    						   LVS_REPORT | LVS_SHOWSELALWAYS |
    						   //LVS_AUTOARRANGE |
    						   WS_EX_CLIENTEDGE,   // styles
                               0, 0, 0, 0,
                               hWndParent,
                               (HMENU) IDC_LISTVIEW,
                               hinst,
                               NULL);

    //ListView_SetExtendedListViewStyle(bwi_hWndListAB, LVS_EX_HEADERDRAGDROP);

    // create caption for quick find edit box
    LoadString(hinstMapiX, idsQuickFindCaption, szBuf, CharSizeOf(szBuf));
    GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), &size);

    bwi_hWndStaticQF = CreateWindow(   TEXT("STATIC"),
                                    szBuf,
                                    WS_TABSTOP | WS_CHILD | WS_VISIBLE,
                                    0,0,size.cx,size.cy,
                                    hWndParent,
                                    (HMENU) IDC_STATIC_QUICK_FIND,
                                    hinst,
                                    NULL);
#if 0 // Disable temporarily untile comctlie.dll export this.
#ifdef WIN16
    Ctl3dSubclassCtl(bwi_hWndStaticQF);
#endif
#endif
    SendMessage(bwi_hWndStaticQF, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);
    UpdateWindow(bwi_hWndStaticQF);

    // create quick find edit box
    bwi_hWndEditQF = CreateWindowEx(  WS_EX_CLIENTEDGE,
                                     TEXT("EDIT"),
                                    NULL,
                                    WS_TABSTOP | WS_CHILD | WS_VISIBLE |
                                    ES_AUTOHSCROLL | ES_LEFT | ES_AUTOVSCROLL ,
                                    0,0,
                                    size.cx,size.cy+4,
                                    hWndParent,
                                    (HMENU) IDC_EDIT_QUICK_FIND,
                                    hinst,
                                    NULL);
#if 0 // Disable temporarily untile comctlie.dll export this.
#ifdef WIN16
    Ctl3dSubclassCtl(bwi_hWndEditQF);
#endif
#endif
    SendMessage(bwi_hWndEditQF, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);
    SendMessage(bwi_hWndEditQF, EM_SETLIMITTEXT,(WPARAM) MAX_DISPLAY_NAME_LENGTH-1,0);



    if (hdc) ReleaseDC(hWndParent,hdc);

    // Sub class some of the controls
    bwi_s_hWnd[s_EditQF] = bwi_hWndEditQF;
    bwi_s_hWnd[s_ListAB] = bwi_hWndListAB;
    bwi_s_hWnd[s_TV]		= bwi_hWndTV;

    for(i=0;i<s_Max;i++)
    {
    	bwi_fnOldProc[i] = (WNDPROC) SetWindowLongPtr (bwi_s_hWnd[i], GWLP_WNDPROC, (LONG_PTR) SubClassedProc);
    }

    SetFocus(bwi_hWndEditQF);

    return;
}





//$$/////////////////////////////////////////////////////////////
//
// ResizeAddressBookChildren(HWND hWndParent)
//
//	Resizing and moving around
//
///////////////////////////////////////////////////////////////
void ResizeAddressBookChildren(LPBWI lpbwi, HWND hWndParent)
{
    RECT rc, rc1;
    int BBx,BBy,BBw,BBh;
    int SBx,SBy,SBw,SBh;
    int QFx,QFy,QFw,QFh;
    int EDx,EDy,EDw,EDh;
    int LVx,LVy,LVw,LVh;
    TCHAR szBuf[MAX_PATH];
    HDC hdc;
    SIZE  size;
	RECT rcTV;
    int TVx=0, TVy=0, TVw=0, TVh=0;
	int TCKx = 0, TCKy=0, TCKw=0, TCKh=0;

    // calculate button, static, and edit sizes from the font.
    hdc = GetDC(hWndParent);

    GetClientRect(hWndParent,&rc);

    GetChildClientRect(bwi_hWndBB,&rc1);

    // Button Bars coordinates
    BBx = BBy = 0; BBw = rc.right; BBh = rc1.bottom - rc1.top;

    if (IsWindowVisible(bwi_hWndBB))
    	MoveWindow(bwi_hWndBB, BBx, BBy,BBw, BBh,TRUE);
    else
    	BBw = BBh = 0;
    if (IsWindowVisible(bwi_hWndTV))
    {
	    GetChildClientRect(bwi_hWndTV, &rcTV);
        TVx = 0;
        TVw = rcTV.right - rcTV.left;
	    TCKx = TVw;
	    TCKw = BORDER;
    }

    // Quick Find labels coordinates
    GetTextExtentPoint32(hdc, szBuf, GetWindowText(bwi_hWndStaticQF, szBuf, CharSizeOf(szBuf)), &size);
    QFx = TVx + TVw + BORDER;
    QFy = BBy+BBh+BORDER;
    QFw = size.cx;
    QFh = size.cy;

    //Edit Box coordinates
    EDx = QFx+QFw+CONTROL_SPACING;
    EDy = QFy;
    QFy += 2;
    GetChildClientRect(bwi_hWndEditQF,&rc1);
    EDh = rc1.bottom - rc1.top;
    EDw = QFw;

    //List View Dimensions
    LVx = TVx + TVw + BORDER;
    LVy = EDy+EDh+BORDER;
    LVw = rc.right - rc.left;// - 2*BORDER;
    LVh = rc.bottom - LVy;// - BORDER;

    // [PaulHi] 3/17/99  Raid 68541
    // We can't just set the status bar height to 14 because in large mode Windows will 
    // draw outside the status bar window (very ugly).  We want the status bar to be
    // smaller than system default so we (safely) subtract six pixels from the height.
    SBx = 0;
    SBh = GetSystemMetrics(SM_CYCAPTION) - 4;
    SBh = (SBh > 0) ? SBh : 14;
    SBy = rc.bottom - SBh;
    SBw = rc.right - rc.left;

    if(IsWindowVisible(bwi_hWndSB))
        LVh = LVh - SBh - 2*BORDER;
    TVy = QFy;
    TVh = rc.bottom - TVy; 
    if(IsWindowVisible(bwi_hWndSB))
        TVh = TVh - SBh - 2*BORDER;
    LVw = LVw - BORDER - TVw;
    if (IsWindowVisible(bwi_hWndTV))
    {
	    TCKy = TVy;
	    TCKh = TVh;
    }

    {
    	HDWP hdwp = BeginDeferWindowPos(6);

    	MoveWindow(bwi_hWndEditQF, EDx, EDy, EDw, EDh, TRUE);

		MoveWindow(bwi_hWndStaticQF, QFx, QFy, QFw, QFh, TRUE);

    	MoveWindow(bwi_hWndListAB, LVx, LVy, LVw, LVh, TRUE);

    	MoveWindow(bwi_hWndSB, SBx, SBy, SBw, SBh, TRUE);

    	if (IsWindowVisible(bwi_hWndTV))
        {
    	    MoveWindow(bwi_hWndTV, TVx, TVy, TVw, TVh, TRUE);
    	    MoveWindow(bwi_hWndSplitter, TCKx, TCKy, TCKw, TCKh, TRUE);
        }

    	EndDeferWindowPos(hdwp);

    }

    ReleaseDC(hWndParent, hdc);

	return;
}




//$$/////////////////////////////////////////////////////////////
//
// Initialize the kid windows
//
///////////////////////////////////////////////////////////////
void InitChildren(LPBWI lpbwi, HWND hWndParent)
{

    HrInitListView(bwi_hWndListAB, LVS_REPORT, TRUE);

    InitMultiLineToolTip(lpbwi, hWndParent);

    {
        HIMAGELIST hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_SMALL))),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

        // Associate the image lists with the list view control.
    	TreeView_SetImageList (bwi_hWndTV, hSmall, TVSIL_NORMAL);

        //FillTreeView(bwi_hWndTV, NULL);
    }
    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hWndParent,
                        SetChildDefaultGUIFont,
                        (LPARAM) PARENT_IS_WINDOW);


    SendMessage(hWndParent,WM_COMMAND,IDM_VIEW_DETAILS,0);

    bwi_bDoQuickFilter = TRUE;

    SetFocus(bwi_hWndEditQF);

}





//$$/////////////////////////////////////////////////////////////
//
// Change list views styles and possibly menus also
//
///////////////////////////////////////////////////////////////
void SetListViewStyle(LPBWI lpbwi, int MenuID)
{
    DWORD dwStyle = GetWindowLong(bwi_hWndListAB,GWL_STYLE);
    BOOL bUseCurrentSortSettings = FALSE;

    // Right now we just change the style here
    // later on we can update the menu etc. to reflect the style and

    switch(MenuID)
    {
            case IDM_VIEW_DETAILS:
                if((dwStyle & LVS_TYPEMASK) != LVS_REPORT)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_REPORT);
                break;
            case IDM_VIEW_SMALLICON:
                if((dwStyle & LVS_TYPEMASK) != LVS_SMALLICON)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_SMALLICON);
                break;
            case IDM_VIEW_LARGEICON:
                if((dwStyle & LVS_TYPEMASK) != LVS_ICON)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_ICON);
                break;
            case IDM_VIEW_LIST:
                if((dwStyle & LVS_TYPEMASK) != LVS_LIST)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_LIST);
                break;
    }

    {
        //
        // If we are not in details view, we dont really want to be able to sort
        // by phone number and email address .. hence we disable those menu
        // options under certain conditions ...
        //
        HMENU hMenuMain = GetMenu(bwi_hWndAB);
        HMENU hMenuView = GetSubMenu(hMenuMain,idmView);
        int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
        HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);

        if (MenuID == IDM_VIEW_DETAILS)
        {
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_EMAILADDRESS,MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_BUSINESSPHONE,MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_HOMEPHONE,MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_EMAILADDRESS,MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_BUSINESSPHONE,MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_HOMEPHONE,MF_BYCOMMAND | MF_GRAYED);
        }
    }

    if (MenuID != IDM_VIEW_DETAILS)
    {
        SORT_INFO SortTmp = bwi_SortInfo;
        //hack
        SendMessage(bwi_hWndListAB, WM_SETREDRAW, (WPARAM) FALSE, 0);
        bUseCurrentSortSettings = FALSE;
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, bUseCurrentSortSettings);
        bwi_SortInfo = SortTmp;
        bwi_SortInfo.iOldSortCol = colDisplayName;
        bUseCurrentSortSettings = TRUE;
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, bUseCurrentSortSettings);
        SendMessage(bwi_hWndListAB, WM_SETREDRAW, (WPARAM) TRUE, 0);
    }

    UpdateSortMenus(lpbwi, bwi_hWndAB);


    return;
}


//$$/////////////////////////////////////////////////////////////
//
// Resets the globals in case someone drops by again
//
///////////////////////////////////////////////////////////////
void CleanUpGlobals(LPBWI lpbwi)
{
    if (bwi_lpContentsList)
        FreeRecipList(&bwi_lpContentsList);

    bwi_hWndListAB = NULL;
    bwi_hWndBB = NULL;
    bwi_hWndSB = NULL;
    bwi_hWndEditQF =NULL;
    bwi_hWndStaticQF = NULL;
    bwi_hWndAB = NULL;
    bwi_hWndTT = NULL;
    bwi_tt_bActive = FALSE;
    bwi_tt_iItem = -1;
    bwi_tt_szTipText[0]='\0';
    bwi_tt_TooltipTimer = 0;

	bwi_hWndTV = NULL;
	bwi_hWndSplitter = NULL;
    bwi_bDontRefreshLV = FALSE;
    ReadRegistrySortInfo(bwi_lpIAB, &bwi_SortInfo);

    return;

}

/*
-   bCheckIfOnlyGroupsSelected
-
-   Returns TRUE if all the selected items in the ListView are only Groups (no Contacts)
*
*/
BOOL bCheckIfOnlyGroupsSelected(HWND hWndLV)
{
    int nSelected = ListView_GetSelectedCount(hWndLV);
    int iItemIndex = -1;

    if(nSelected <= 0)
        return FALSE;
    
    while((iItemIndex = ListView_GetNextItem(hWndLV, iItemIndex, LVNI_SELECTED))!= -1)
    {
        // Get the entryid of the selected item
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem && lpItem->ulObjectType == MAPI_MAILUSER)
            return FALSE;
    }

    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Processes messages for the list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessListViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
    HWND hWndAddr = pNm->hdr.hwndFrom;

    switch(pNm->hdr.code)
    {        
    case LVN_COLUMNCLICK:
        SortListViewColumn(bwi_lpIAB, hWndAddr, pNm->iSubItem, &bwi_SortInfo, FALSE);
        UpdateSortMenus(lpbwi, bwi_hWndAB);
        break;

    case LVN_KEYDOWN:
        UpdateToolbarAndMenu(lpbwi);
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_DELETE, 0);
            return 0;
            break;
    	case VK_RETURN:
    		SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return 0;
        }
        break;

    //case LVN_ITEMCHANGED:
    case NM_CLICK:
    case NM_RCLICK:
        {
            UpdateToolbarAndMenu(lpbwi);
#ifdef WIN16 // Context menu handler for WIN16           
            if( pNm->hdr.code == NM_RCLICK && pNm->hdr.hwndFrom == bwi_hWndListAB)
            {                
                    POINT pt;                   
                    GetCursorPos(&pt);
                    ShowLVContextMenu( lvMainABView,
                        bwi_hWndListAB,
                        NULL, //bwi_hWndCombo,
                        MAKELPARAM(pt.x, pt.y),
                        NULL,
                        bwi_lpAdrBook, bwi_hWndTV);
            }
#endif // WIN16
        }
    break;

    case NM_SETFOCUS:
        UpdateToolbarAndMenu(lpbwi);
    	break;

    case NM_DBLCLK:
        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
        return 0;
        break;

    case NM_CUSTOMDRAW:
        return ProcessLVCustomDraw(NULL, lParam, FALSE);
        break;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        {
            DWORD dwEffect = 0;
            LPIWABDATAOBJECT lpIWABDataObject = NULL;
            bwi_bDontRefreshLV = TRUE; // prevent refreshes as this action is based on the selection
            HrCreateIWABDataObject((LPVOID) lpbwi, bwi_lpAdrBook, bwi_hWndListAB, &lpIWABDataObject, 
                                    FALSE,bCheckIfOnlyGroupsSelected(bwi_hWndListAB));
            if(lpIWABDataObject)
            {
                bwi_lpIWABDragDrop->m_bSource = TRUE;
                DoDragDrop( (LPDATAOBJECT) lpIWABDataObject,
                            (LPDROPSOURCE) bwi_lpIWABDragDrop->lpIWABDropSource,
                            DROPEFFECT_COPY | DROPEFFECT_MOVE,
                            &dwEffect);
                bwi_lpIWABDragDrop->m_bSource = FALSE;
                lpIWABDataObject->lpVtbl->Release(lpIWABDataObject);
            }
            RefreshListView(lpbwi, NULL);
            bwi_bDontRefreshLV = FALSE; // prevent refreshes as this action is based on the selection
        }
        return 0;
        break;
    }


    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


//$$/////////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////////
LRESULT EnforceMinSize(LPBWI lpbwi, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPPOINT lppt = (LPPOINT)lParam;			// lParam points to array of POINTs
    RECT rc1, rc2;

    if(lpbwi)
    {
        if(bwi_hWndEditQF)
        {
    	    GetWindowRect(bwi_hWndEditQF,&rc1);
    	    GetWindowRect(bwi_hWndStaticQF,&rc2);
    	    lppt[3].x  = rc1.right-rc1.left + rc2.right-rc2.left + 2*BORDER;		// Set minimum width
    	    lppt[3].y  = MIN_WINDOW_H;		// Set minimum height
        }
    }
    return DefWindowProc(hWnd, uMsg, wParam, lParam);

}

//$$
//*------------------------------------------------------------------------
//| RefreshListView
//|
//| lpftLast - WAB file time at last update
//*------------------------------------------------------------------------
void RefreshListView(LPBWI lpbwi, LPFILETIME lpftLast)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;

    bwi_hti = NULL;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    //if(lpsbEID) //root item can have a null entryid - so we default to that item if NULL or err
    {
        // Refresh the groups list
        FillTreeView(lpbwi, bwi_hWndTV, lpsbEID);
        LocalFreeSBinary(lpsbEID);
    }


    // Update the wab file write time so the timer doesn't
    // catch this change and refresh.
    //if (lpftLast) {
    //    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
    //}

    UpdateSortMenus(lpbwi, bwi_hWndAB);

    UpdateToolbarAndMenu(lpbwi);

    //DoLVQuickFind(bwi_hWndEditQF,bwi_hWndListAB);

    bwi_bDoQuickFilter = FALSE;
    SetWindowText(bwi_hWndEditQF,szEmpty);
    bwi_bDoQuickFilter = TRUE;

    SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0L);

    return;
}


//$$
//*------------------------------------------------------------------------
//| SubClassedProc - to subclass child controls
//|
//*------------------------------------------------------------------------
LRESULT CALLBACK SubClassedProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{

    LPBWI lpbwi = (LPBWI) GetWindowLongPtr(GetParent(hWnd), GWLP_USERDATA);

    IF_WIN32(int i = GetWindowLong(hWnd, GWL_ID);)
    IF_WIN16(int i = GetWindowWord(hWnd, GWW_ID);)

    switch(i)
    {
    case IDC_EDIT_QUICK_FIND:
    	i = s_EditQF;
    	break;
    case IDC_LISTVIEW:
    	i = s_ListAB;
        break;
    case IDC_TREEVIEW:
    	i = s_TV;
        break;
    }

    switch (iMsg)
    {
    case WM_KEYDOWN:
    	switch(wParam)
    	{
    	case VK_TAB:
            {
                int max = s_Max;
                if(!IsWindowVisible(bwi_hWndTV)) max--;
        		SetFocus(bwi_s_hWnd[(i + ((GetKeyState(VK_SHIFT) < 0) ? (max-1) : 1)) % (max)]);
            }
    		break;
    	case VK_ESCAPE:
    		SendMessage(bwi_hWndAB,WM_CLOSE,0,0L);
            return 0;
    		break;
    	case VK_RETURN:
    		if (i==s_EditQF)
    			SetFocus(bwi_s_hWnd[(i + ((GetKeyState(VK_SHIFT) < 0) ? (s_Max-1) : 1)) % (s_Max)]);
    		break;
    	}
    	break;

    case WM_CHAR:
    	if (i==s_EditQF  || i==s_TV)
    	{
    		if ((wParam==VK_RETURN) || (wParam==VK_TAB))
    			return 0; //prevents irritating beeps
    	}
    	break;

    case WM_SETFOCUS:
    	bwi_iFocus = i;
    	break;

    case WM_LBUTTONDBLCLK:
        if(i==s_TV)
        {
            SendMessage(bwi_hWndAB, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return FALSE;
        }
        break;
    }

    return CallWindowProc(bwi_fnOldProc[i],hWnd,iMsg,wParam,lParam);

}



//$$
//*------------------------------------------------------------------------
//| FindABWindowProc:
//|
//*------------------------------------------------------------------------
STDAPI_(BOOL) FindABWindowProc( HWND hWndToLookAt, LPARAM lParam)
{
    HWND * lphWndTmp = (HWND *) lParam;
    
    TCHAR szBuf[MAX_PATH];

    
    // yuk - need a better way to do this - TBD
    if (*lphWndTmp == NULL)
    {
    	GetClassName(hWndToLookAt, szBuf, CharSizeOf(szBuf));
    	if(!lstrcmpi(g_szClass,szBuf))
    	{
    		// Found our man
    		*lphWndTmp = hWndToLookAt;
    		return FALSE;
    	}
    }
    return TRUE;
}


//$$
//*------------------------------------------------------------------------
//| CallBack used by client to send accelerators to us
//|
//*------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE fnAccelerateMessages(ULONG_PTR ulUIParam, LPVOID lpvmsg)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bRet = FALSE;
    if(lpvmsg && pt_hAccTable /*&& IsDialogMessage((HWND) ulUIParam,lpvmsg)*/)
    {
        bRet =  TranslateAcceleratorW((HWND) ulUIParam,	// handle of destination window
                                     pt_hAccTable,	        // handle of accelerator table
                                    (LPMSG) lpvmsg 	    // address of structure with message
                                );
    }
    return bRet;
}



//$$
//*------------------------------------------------------------------------
//| Updates the menu item markings whenever we sort ...
//|
//*------------------------------------------------------------------------
void UpdateSortMenus(LPBWI lpbwi, HWND hWnd)
{
    int id;

    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuView = GetSubMenu(hMenuMain,idmView);
    int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
    HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);

    BOOL bRet;
    //
    // There are several menus to update here ...
    // Sort by  TEXT("Column")
    // Sort by FirstName or LastName
    // Sort Ascending or descending

    switch(bwi_SortInfo.iOldSortCol)
    {
    case colDisplayName:
        id = IDM_VIEW_SORTBY_DISPLAYNAME;
        break;
    case colEmailAddress:
        id = IDM_VIEW_SORTBY_EMAILADDRESS;
        break;
    case colOfficePhone:
        id = IDM_VIEW_SORTBY_BUSINESSPHONE;
        break;
    case colHomePhone:
        id = IDM_VIEW_SORTBY_HOMEPHONE;
        break;
    }
    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_DISPLAYNAME,
    				IDM_VIEW_SORTBY_HOMEPHONE,
    				id,
    				MF_BYCOMMAND);


    if (id!=IDM_VIEW_SORTBY_DISPLAYNAME)
    {
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_LASTNAME,MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_FIRSTNAME,MF_BYCOMMAND | MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_LASTNAME,MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_FIRSTNAME,MF_BYCOMMAND | MF_ENABLED);
    }

    id = (bwi_SortInfo.bSortByLastName) ? IDM_VIEW_SORTBY_LASTNAME : IDM_VIEW_SORTBY_FIRSTNAME;

    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_FIRSTNAME,
    				IDM_VIEW_SORTBY_LASTNAME,
    				id,
    				MF_BYCOMMAND);

    id = (bwi_SortInfo.bSortAscending) ? IDM_VIEW_SORTBY_ASCENDING : IDM_VIEW_SORTBY_DESCENDING;

    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_ASCENDING,
    				IDM_VIEW_SORTBY_DESCENDING,
    				id,
    				MF_BYCOMMAND);


    return;
}

///////////////////////////////////////////////////////////////////////////
//
// Updates the toolbar based on the contents of the list box
//
//
///////////////////////////////////////////////////////////////////////////
void UpdateToolbarAndMenu(LPBWI lpbwi)
{

    //
    // Toolbar Button States
    //
    // Y: Enabled
    // N: Disabled
    //
    //                  non-Empty-WAB   Empty-WAB   non-EmptyLDAP   EmptyLDAP
    // New                  Y               Y           N               N
    // Properties           Y               N           Y               N
    // Delete               Y               N           N               N
    // Search               Y               Y           Y               Y
    // Add to WAB           N               N           Y               N
    // Print                Y               N           Y               N
    // SendMail             Y               N           Y               N

    BOOL bState[tbMAX];
    int i;

	// if the current focus is on a group, all the above can be selected
	// else depends on the list view

    if(bIsFocusOnTV(lpbwi))
	{
		for(i=0;i<tbMAX;i++)
			bState[i] = TRUE;
		// if there are no items in this group, tag it so
		if(ListView_GetItemCount(bwi_hWndListAB) <= 0)
			bState[tbPrint] = /*bState[tbAction] =*/ FALSE;

		// [PaulHi] 11/23/98  Raid #12453
		// Allow pasting into the Tree View
        // bState[tbCopy] = bState[tbPaste] = FALSE;
		bState[tbCopy] = FALSE;
		bState[tbPaste] = bIsPasteData();
	}
	else
    {
        GetCurrentOptionsState( NULL, bwi_hWndListAB, bState);
    }
    
//    if( (bDoesThisWABHaveAnyUsers(bwi_lpIAB)) &&
//        TreeView_GetSelection(bwi_hWndTV) == TreeView_GetRoot(bwi_hWndTV))
//        bState[tbNewFolder] = FALSE;

    // Set the toolbar button states
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_NEW,(LPARAM) MAKELONG(bState[tbNew], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_PROPERTIES,(LPARAM) MAKELONG(bState[tbProperties], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_DELETE,(LPARAM) MAKELONG(bState[tbDelete], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_FIND,(LPARAM) MAKELONG(bState[tbFind], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_PRINT,(LPARAM) MAKELONG(bState[tbPrint], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_ACTION,(LPARAM) MAKELONG(bState[tbAction], 0));

#ifdef WIN16 // WIN16FF:Disable find button of coolbar. Find is not beta1 feature
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_FIND,(LPARAM)MAKELONG(0, 0));
#endif

    //
    // We also need to synchronize the menus with the toolbar ...
    //

    {
        HMENU hMenuMain = GetMenu(bwi_hWndAB);
        HMENU hMenuSub = GetSubMenu(hMenuMain,idmFile);
        UINT  uiFlag[tbMAX];

        for(i=0;i<tbMAX;i++)
            uiFlag[i] = (bState[i] ? MF_ENABLED : MF_GRAYED);

        EnableMenuItem(hMenuSub,IDM_FILE_NEWCONTACT,MF_BYCOMMAND | uiFlag[tbNewEntry]);
        EnableMenuItem(hMenuSub,IDM_FILE_NEWGROUP,  MF_BYCOMMAND | uiFlag[tbNewGroup]);
        EnableMenuItem(hMenuSub,IDM_FILE_NEWFOLDER, MF_BYCOMMAND | uiFlag[tbNewFolder]);
        EnableMenuItem(hMenuSub,IDM_FILE_DELETE,    MF_BYCOMMAND | uiFlag[tbDelete]);
        EnableMenuItem(hMenuSub,IDM_FILE_PROPERTIES,MF_BYCOMMAND | uiFlag[tbProperties]);
        //EnableMenuItem(hMenuSub,IDM_FILE_ADDTOWAB,  MF_BYCOMMAND | uiFlag[tbAddToWAB]);
        //EnableMenuItem(hMenuSub,IDM_FILE_SENDMAIL,  MF_BYCOMMAND | uiFlag[tbAction]);
    
        if(bPrintingOn)
            EnableMenuItem(hMenuSub,IDM_FILE_PRINT,  MF_BYCOMMAND | uiFlag[tbPrint]);

        hMenuSub = GetSubMenu(hMenuMain,idmEdit);
        EnableMenuItem(hMenuSub,IDM_EDIT_COPY,  MF_BYCOMMAND | uiFlag[tbCopy]);
        EnableMenuItem(hMenuSub,IDM_EDIT_PASTE,  MF_BYCOMMAND | uiFlag[tbPaste]);
#ifdef WIN16 // WIN16FF:FIND is not beta1 feature
        EnableMenuItem(hMenuSub,IDM_EDIT_FIND,  MF_BYCOMMAND | MF_GRAYED);
#else
        EnableMenuItem(hMenuSub,IDM_EDIT_FIND,  MF_BYCOMMAND | uiFlag[tbFind]);
#endif

        //hMenuSub = GetSubMenu(hMenuMain,idmTools);
    }

    ShowLVCountinStatusBar(lpbwi);

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// SaveCurrentPosition
//
// Saves the modeless dialog window position and the list view column sizes ...
//
//////////////////////////////////////////////////////////////////////////////////
void SaveCurrentPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i;
    RECT rect;

    //
    // First read the previous settings from the registry so we dont
    // overwrite something if we dont need to ...
    //
    ReadRegistryPositionInfo(bwi_lpIAB, &ABPosColSize, lpszRegPositionKeyValueName);

    {
        WINDOWPLACEMENT wpl = {0};
        wpl.length = sizeof(WINDOWPLACEMENT);

        // This call tells us the window state and normal size and position
        GetWindowPlacement(hWnd, &wpl);

        // There seems to be a bug in GetWindowPlacement that
        // doesnt account for various taskbars on the screen when
        // returning the Window's Normal Position .. as a result
        // the stored coordinates won't be accurate. Instead, we'll
        // use those coordinates only if the window is maximized or
        // minimized - otherwise we will use the GetWindowRect
        // coordinates.

        // Get the screen position of this window
        GetWindowRect(hWnd, &(ABPosColSize.rcPos));

        if(wpl.showCmd != SW_SHOWNORMAL)
        {
            ABPosColSize.rcPos = wpl.rcNormalPosition;
        }
    }

    // Check the current List View Style
    ABPosColSize.dwListViewStyle = GetWindowLong(hWndLV, GWL_STYLE);

    if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_REPORT )
    {
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_DETAILS;
        // get column widths only if this is the details style otherwise
        // not ...
        for(i=0; i<NUM_COLUMNS; i++)
        {
            int nCol = ListView_GetColumnWidth(hWndLV, i);
            if(nCol!=0)
                ABPosColSize.nColWidth[i] = nCol;
        }
    }
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_SMALLICON )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_SMALLICON;
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_ICON )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_LARGEICON;
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_LIST )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_LIST;

    if (IsWindowVisible(hWndTB))
    	ABPosColSize.bViewToolbar = TRUE;
    else
    	ABPosColSize.bViewToolbar = FALSE;

    if (IsWindowVisible(hWndSB))
    	ABPosColSize.bViewStatusBar = TRUE;
    else
    	ABPosColSize.bViewStatusBar = FALSE;

    {
        if (IsWindowVisible(bwi_hWndTV))
    	    ABPosColSize.bViewGroupList = TRUE;
        else
    	    ABPosColSize.bViewGroupList = FALSE;
    }
    ListView_GetColumnOrderArray(hWndLV, NUM_COLUMNS, ABPosColSize.colOrderArray);        
    GetWindowRect( bwi_hWndTV, &rect );
    ABPosColSize.nTViewWidth = rect.right - rect.left;
    WriteRegistryPositionInfo(bwi_lpIAB, &ABPosColSize,lpszRegPositionKeyValueName);

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// SetPreviousSessionPosition
//
// Sets the modeless dialog window position and the list view column sizes based on
//  the previous sessions parameters ...
//
//////////////////////////////////////////////////////////////////////////////////
void SetPreviousSessionPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i;
    RECT rect;

    ABPosColSize.bViewGroupList =TRUE; // Off by default

    if(ReadRegistryPositionInfo(bwi_lpIAB, &ABPosColSize, lpszRegPositionKeyValueName))
    {
        rect.left = ABPosColSize.rcPos.left;
        rect.top =  ABPosColSize.rcPos.top;
        rect.right = ABPosColSize.rcPos.right;
        rect.bottom = ABPosColSize.rcPos.bottom;
        if( IsWindowOnScreen( &rect ) )                      
        {
            MoveWindow(hWnd,
                   ABPosColSize.rcPos.left,
                   ABPosColSize.rcPos.top,
                   ABPosColSize.rcPos.right-ABPosColSize.rcPos.left,
                   ABPosColSize.rcPos.bottom-ABPosColSize.rcPos.top,
                   FALSE);
        }

        for(i=0; i<NUM_COLUMNS; i++)
        {
            if(ABPosColSize.nColWidth[i]!=0)
                ListView_SetColumnWidth(hWndLV, i, ABPosColSize.nColWidth[i]);
        }

    	if(ABPosColSize.bViewToolbar == FALSE)
        {
    		//hide it
    		CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_UNCHECKED);
    		ShowWindow(hWndTB, SW_HIDE);
        }

    	if(ABPosColSize.bViewStatusBar == FALSE)
        {
    		//hide it
    		CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_UNCHECKED);
    		ShowWindow(hWndSB, SW_HIDE);
        }
        GetWindowRect( bwi_hWndTV, &rect );
        if( ABPosColSize.nTViewWidth != 0 )
            MoveWindow( bwi_hWndTV, rect.left, rect.top, ABPosColSize.nTViewWidth, rect.bottom - rect.top, FALSE );
    	ResizeAddressBookChildren(lpbwi, hWnd);//,SIZE_RESTORED);

        if (ABPosColSize.nListViewStyleMenuID != 0)
        {
            SetListViewStyle(lpbwi, ABPosColSize.nListViewStyleMenuID);
    		CheckMenuRadioItem(	GetMenu(hWnd),
    							IDM_VIEW_LARGEICON,
    							IDM_VIEW_DETAILS,
    							ABPosColSize.nListViewStyleMenuID,
    							MF_BYCOMMAND);

        }

        {
            int nTotal=0,nColSum=0;
            // the previous version did not have the column order setting, so if the
            // values are incorrect reset them
            for(i=0;i<NUM_COLUMNS;i++)
            {
                nTotal += ABPosColSize.colOrderArray[i];
                nColSum += i;
            }
            if(nColSum != nTotal)
            {
                for(i=0;i<NUM_COLUMNS;i++)
                    ABPosColSize.colOrderArray[i] = i;
            }

        }
        ListView_SetColumnOrderArray(hWndLV, NUM_COLUMNS, ABPosColSize.colOrderArray);

    }

    if(ABPosColSize.bViewGroupList == FALSE)
    {
    	//hide it
    	CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_UNCHECKED);
    	ShowWindow(bwi_hWndTV, SW_HIDE);
    	ShowWindow(bwi_hWndSplitter, SW_HIDE);
        InvalidateRect(bwi_hWndStaticQF, NULL, TRUE);
        // folder not on the Shared Contacts
        if(bIsThereACurrentUser(bwi_lpIAB))
        {
            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
        }
        else
        {
            // Set the selection to the root address book so we see the file
            // contents just as if we dont have a treeview at all
            TreeView_SelectItem(bwi_hWndTV, TreeView_GetRoot(bwi_hWndTV));
        }
    }

    return;
}

#define MAX_TOOLTIP_LENGTH  300
#define TOOLTIP_INITTIME    5000 //milliseconds
#define TOOLTIP_TIME        8000 //milliseconds

//$$/////////////////////////////////////////////////////////////////////////////
//
// void UpdateTooltipTextBuffer - Updates the text in the buffer for the tooltip
//
////////////////////////////////////////////////////////////////////////////////
void UpdateTooltipTextBuffer(LPBWI lpbwi, int nItem)
{

    LPTSTR lpszData = NULL;

    bwi_tt_iItem = nItem;
    bwi_tt_szTipText[0]='\0';

    HrGetLVItemDataString(bwi_lpAdrBook, bwi_hWndListAB, nItem, &lpszData);

    if(lpszData)
    {
        if (CharSizeOf(bwi_tt_szTipText) < (lstrlen(lpszData)+1))
        {
            LPTSTR lpsz = TEXT(" ...");
            ULONG nLen = TruncatePos(lpszData, CharSizeOf(bwi_tt_szTipText) - lstrlen(lpsz) - 1);
            CopyMemory(bwi_tt_szTipText, lpszData, sizeof(TCHAR)*nLen);
            bwi_tt_szTipText[nLen]='\0';
    		lstrcat(bwi_tt_szTipText,lpsz);
        }
        else
            lstrcpy(bwi_tt_szTipText, lpszData);
    }

    LocalFreeAndNull(&lpszData);

    return;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// void InitMultiLineTooltip - initializes the multiline tooltip for the list view
// control
//
////////////////////////////////////////////////////////////////////////////////
void InitMultiLineToolTip(LPBWI lpbwi, HWND hWndParent)
{
    TOOLINFO ti = {0};
    bwi_tt_bActive = FALSE;
    bwi_tt_iItem = -1;
    bwi_tt_szTipText[0]='\0';
    FillTooltipInfo(lpbwi, &ti);
    SendMessage(bwi_hWndTT, TTM_SETMAXTIPWIDTH, 0, (LPARAM) MAX_TOOLTIP_LENGTH);
    ToolTip_AddTool(bwi_hWndTT, (LPARAM) (LPTOOLINFO) &ti);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_INITIAL, (LPARAM) TOOLTIP_INITTIME);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_RESHOW, (LPARAM) TOOLTIP_INITTIME);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_AUTOPOP, (LPARAM) TOOLTIP_TIME);
    SendMessage(bwi_hWndTT, TTM_ACTIVATE, (WPARAM) TRUE, 0);
    if(!bwi_tt_bActive)
    {
        // if the tooltip is not active, activate it
        TOOLINFO ti = {0};
        FillTooltipInfo(lpbwi, &ti);
        ti.lpszText = szEmpty; //LPSTR_TEXTCALLBACK;
        ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);
        SendMessage(bwi_hWndTT, TTM_TRACKACTIVATE,(WPARAM)TRUE,(LPARAM)&ti);
        bwi_tt_bActive = TRUE;
    }

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// void FillTooltipInfo - initializes the tooltip structure for making updates or
//  modifications to the tooltips
//
////////////////////////////////////////////////////////////////////////////////
void FillTooltipInfo(LPBWI lpbwi, LPTOOLINFO lpti)
{
    lpti->cbSize = sizeof(TOOLINFO);
    lpti->hwnd = bwi_hWndAB;
    lpti->uId = (UINT_PTR) bwi_hWndListAB;
    lpti->hinst = hinstMapiX;
    lpti->uFlags = TTF_IDISHWND | TTF_SUBCLASS;// | TTF_ABSOLUTE | TTF_TRACK;
    lpti->lpszText = szEmpty;//LPSTR_TEXTCALLBACK;
    lpti->lParam = 0;
    return;
}



//$$/////////////////////////////////////////////////////////////////////////////
//
// int HitTestLVSelectedItem() - Gets the item index number of the item exactly under
// the mouse - further selects the item if it isnt selected
//
////////////////////////////////////////////////////////////////////////////////
int HitTestLVSelectedItem(LPBWI lpbwi)
{
    POINT pt;
    RECT rc;
    int nItemIndex = -1;
    LV_HITTESTINFO lht = {0};

    GetCursorPos(&pt);
    GetWindowRect(bwi_hWndListAB, &rc);

    lht.pt.x = pt.x - rc.left;
    lht.pt.y = pt.y - rc.top;

    ListView_HitTest(bwi_hWndListAB, &lht);

    if(lht.iItem != -1)
        nItemIndex = lht.iItem;

    return nItemIndex;
}


/***********************************************************
    Handle_WM_INITMENUPOPUP
    
      Handles any popup menu's we need to modify ..

***********************************************************/
void Handle_WM_INITMENUPOPUP (HWND hWnd, LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam )
{
    HMENU hMenuPopup = (HMENU) uParam;
    UINT  uPos = (UINT) LOWORD(lParam);
    BOOL  fSysMenu = (BOOL) HIWORD(lParam);

    // Look at the first item on the menu to identify it
    UINT uID = GetMenuItemID(hMenuPopup, 0);

    if(uID == IDM_FILE_SENDMAIL) // this is the Tools | Action Menu
    {
        AddExtendedMenuItems(bwi_lpAdrBook, bwi_hWndListAB, 
                             hMenuPopup, TRUE, 
                             (!bIsFocusOnTV(lpbwi))); // this is the condition for updating SendMailTo
    }
    else
    if(uID == IDM_EDIT_COPY)
    {
        UpdateToolbarAndMenu(lpbwi);
    }
    else
    if(uID == IDM_FILE_NEWCONTACT)
    {
        if(bDoesThisWABHaveAnyUsers(bwi_lpIAB))
            UpdateViewFoldersMenu(lpbwi, hWnd);
    }

    UpdateSynchronizeMenus(hMenuPopup, bwi_lpIAB);

/*
    else if(uID == IDM_FILE_NEWCONTACT)
    {
        if(!bIsThereACurrentUser(bwi_lpIAB))
            EnableMenuItem(hMenuPopup, IDM_FILE_SWITCHUSERS, MF_GRAYED | MF_BYCOMMAND);
    }
*/
}


/***********************************************************
   The Handle_WM_MENSELECT function below is a pared down
   cheezy sample to figure out the ID of the currently selected
   menu. It returns 0 if a popup menu is selected, -1 of no menu
   is selected (i.e. closed), and a positive nonzero value
   if a menu item is selected.
***********************************************************/
void Handle_WM_MENSELECT (LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam )
{
    UINT   nStringID = 0;
    TCHAR sz[MAX_UI_STR];

    UINT   fuFlags = (UINT)HIWORD(uParam) & 0xffff;
    UINT   uCmd    = (UINT)LOWORD(uParam);
    HMENU  hMenu   = (HMENU)lParam;

    nStringID = 0;

    lstrcpy(sz, szEmpty);

    if (fuFlags == 0xffff && hMenu == NULL)     // Menu has been closed
        nStringID = (UINT)-1;
    else if (fuFlags & MFT_SEPARATOR)           // Ignore separators
        nStringID = 0;
    else if (fuFlags & MF_POPUP)                // Popup menu
    {
        nStringID = 0;
        if (fuFlags & MF_SYSMENU)               // System menu
            nStringID = 0;
    }  // for MF_POPUP
    else                                        // Must be a command item
    {
        switch(uCmd)
        {
        case IDC_BB_PRINT:
        case IDM_FILE_PRINT:
            nStringID = idsPrintMenu;
            break;

        case IDM_VIEW_GROUPSLIST:
            nStringID = idsGroupListMenu;
            break;

        case IDM_HELP_ABOUTADDRESSBOOK:
            nStringID = idsAboutMenu;
            break;

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDM_FILE_NEWCONTACT:
            nStringID = idsMenuNewContact;
            break;

        case IDM_LVCONTEXT_NEWGROUP:
        case IDM_FILE_NEWGROUP:
            nStringID = idsMenuNewGroup;
            break;

        case IDM_LVCONTEXT_NEWFOLDER:
        case IDM_FILE_NEWFOLDER:
            nStringID = idsMenuNewFolder;
            break;

        case IDM_LVCONTEXT_COPY:
        case IDM_EDIT_COPY:
            nStringID = idsMenuCopy;
            break;

        case IDM_LVCONTEXT_PASTE:
        case IDM_EDIT_PASTE:
            nStringID = idsMenuPaste;
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDM_FILE_PROPERTIES:
            nStringID = idsMenuProperties;
            break;

        case IDM_LVCONTEXT_DELETE:
        case IDM_FILE_DELETE:
            nStringID = idsMenuDeleteRemove;
            break;

        //case IDM_FILE_ADDTOWAB:
        //case IDM_LVCONTEXT_ADDTOWAB:
        //    nStringID = idsMenuAddToWAB;
        //    break;

        case IDM_LVCONTEXT_FIND:
        case IDM_EDIT_FIND:
            nStringID = idsMenuFind;
            break;

        case IDM_FILE_DIRECTORY_SERVICE:
            nStringID = idsMenuDirectoryService;
            break;

        case IDM_FILE_SWITCHUSERS:
            nStringID = idsMenuSwitchUser;
            break;

        case IDM_FILE_SHOWALLCONTENTS:
            nStringID = idsMenuShowAllContents;
            break;

        case IDM_FILE_EXIT:
            nStringID = idsMenuExit;
            break;

        case IDM_EDIT_SELECTALL:
            nStringID = idsMenuSelectAll;
            break;

        case IDM_VIEW_TOOLBAR:
            nStringID = idsMenuViewToolbar;
            break;

        case IDM_VIEW_STATUSBAR:
            nStringID = idsMenuViewStatusBar;
            break;

        case IDM_VIEW_LARGEICON:
            nStringID = idsMenuLargeIcon;
            break;


        case IDM_VIEW_SMALLICON:
            nStringID = idsMenuSmallIcon;
            break;

        case IDM_VIEW_LIST:
            nStringID = idsMenuList;
            break;

        case IDM_VIEW_DETAILS:
            nStringID = idsMenuDetails;
            break;

        case IDM_VIEW_SORTBY_DISPLAYNAME:
            nStringID = idsMenuDisplayName;
            break;

        case IDM_VIEW_SORTBY_EMAILADDRESS:
            nStringID = idsMenuEmail;
            break;

        case IDM_VIEW_SORTBY_BUSINESSPHONE:
            nStringID = idsMenuBusinessPhone;
            break;

        case IDM_VIEW_SORTBY_HOMEPHONE:
            nStringID = idsMenuHomePhone;
            break;

        case IDM_VIEW_SORTBY_FIRSTNAME:
            nStringID = idsMenuFirstName;
            break;

        case IDM_VIEW_SORTBY_LASTNAME:
            nStringID = idsMenuLastName;
            break;

        case IDM_VIEW_SORTBY_ASCENDING:
            nStringID = idsMenuAscending;
            break;

        case IDM_VIEW_SORTBY_DESCENDING:
            nStringID = idsMenuDescending;
            break;

        case IDM_VIEW_REFRESH:
            nStringID = idsMenuRefresh;
            break;

        case IDM_TOOLS_IMPORT_WAB:
            nStringID = idsMenuImportWAB;
            break;

        case IDM_TOOLS_IMPORT_VCARD:
            nStringID = idsMenuImportVcard;
            break;

        case IDM_TOOLS_IMPORT_OTHER:
            nStringID = idsMenuImportOther;
            break;

        case IDM_TOOLS_EXPORT_OTHER:
            nStringID = idsMenuExportOther;
            break;

        case IDM_TOOLS_EXPORT_WAB:
            nStringID = idsMenuExportWAB;
            break;

        case IDM_TOOLS_EXPORT_VCARD:
            nStringID = idsMenuExportVcard;
            break;

        case IDM_HELP_ADDRESSBOOKHELP:
            nStringID = idsMenuHelp;
            break;

        case IDM_EDIT_SETME:
            nStringID = idsMenuEditProfile;
            break;

        default:
            nStringID = 0;
            GetContextMenuExtCommandString(bwi_lpIAB, uCmd, sz, CharSizeOf(sz));
            break;
        }
    }

    if (nStringID > 0)
    {
       LoadString(hinstMapiX, nStringID, sz, CharSizeOf(sz));
    }

    StatusBarMessage(lpbwi, sz);

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Fills a lpList from the contents of a given group
// If lpList is NULL, ignores that parameter
// If lpszName is NULL, ignores that parameter
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT FillListFromGroup(
                        LPADRBOOK lpAdrBook,
                        ULONG cbGroupEntryID, 
                        LPENTRYID lpGroupEntryID,
                        LPTSTR lpszName,
                        LPRECIPIENT_INFO * lppList)
{
	ULONG ulcPropCount;
    LPSPropValue lpPropArray = NULL;
    ULONG j;
	HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpInfo = NULL;

    hr = HrGetPropArray( lpAdrBook, NULL,
                    cbGroupEntryID, (LPENTRYID) lpGroupEntryID,
                    MAPI_UNICODE,
                    &ulcPropCount, &lpPropArray);
    if (HR_FAILED(hr))
        goto exit;

    if(lppList && *lppList)
        FreeRecipList(lppList);

    for(j=0;j<ulcPropCount;j++)
    {
        // We are ignoring PR_WAB_DL_ONEOFFS here since we don't want to show OneOffs
        if( lpPropArray[j].ulPropTag==PR_WAB_DL_ENTRIES  && lppList )
        {
            ULONG k;

            // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
            for (k = 0; k < lpPropArray[j].Value.MVbin.cValues; k++)
            {
                ULONG cbEID = lpPropArray[j].Value.MVbin.lpbin[k].cb;
                {
                    LPENTRYID lpEID = (LPENTRYID)lpPropArray[j].Value.MVbin.lpbin[k].lpb;

                    // we don't want one-offs showing up in the UI because all kinds of problems start happening
                    // when these one-offs are dragged and dropped
                    // A doublecheck here not really needed in 99% cases
                    if(WAB_ONEOFF == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL))
                        continue;

                    ReadSingleContentItem( lpAdrBook,cbEID, (LPENTRYID)lpEID, &lpInfo);
                    if(lpInfo)
                    {
						lpInfo->lpNext = *lppList;
                        if(*lppList)
							(*lppList)->lpPrev = lpInfo;
                        *lppList = lpInfo;
                    }
                }
            }
        }
        else if (lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
        {
            if(lpszName)
                lstrcpy(lpszName, lpPropArray[j].Value.LPSZ);
        }
    }

    hr = S_OK;

exit:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return(hr);

}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateListViewContents(lpsbEID)
//
// Updates the displayed list in the list view based on the entry id of the selected
// TreeView item
//
//////////////////////////////////////////////////////////////////////////////////////////
void UpdateListViewContents(LPBWI lpbwi, LPSBinary lpsbEID, ULONG ulObjectType)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if( (ulObjectType == MAPI_ABCONT && (pt_bIsWABOpenExSession || bIsWABSessionProfileAware(bwi_lpIAB)))//a folder and it's outlook or profiles are enabled 
        || !lpsbEID || !lpsbEID->cb || !lpsbEID->lpb )// or no container entryid 
    {
        HrGetWABContents(   bwi_hWndListAB,
                            bwi_lpAdrBook,
                            lpsbEID,
                            bwi_SortInfo,
                            &(bwi_lpContentsList));
    }
    else if(ulObjectType == MAPI_DISTLIST )
    {
		if(!HR_FAILED(  FillListFromGroup(  
                            bwi_lpAdrBook,
                            lpsbEID->cb,
                            (LPENTRYID) lpsbEID->lpb,
							NULL,
							&(bwi_lpContentsList))))
        {
		    int nSelectedItem = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);

			if(nSelectedItem < 0)
				nSelectedItem = 0;

            ListView_DeleteAllItems(bwi_hWndListAB);
            if (!HR_FAILED(HrFillListView(	bwi_hWndListAB,
										    bwi_lpContentsList)))
	        {
                SendMessage(bwi_hWndListAB, WM_SETREDRAW, FALSE, 0);
                SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
                SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0);
            }

			if(nSelectedItem >= ListView_GetItemCount(bwi_hWndListAB))
				nSelectedItem = ListView_GetItemCount(bwi_hWndListAB)-1;
		    LVSelectItem(bwi_hWndListAB, nSelectedItem);

        }
    }

    ShowLVCountinStatusBar(lpbwi);

    return;
}
                    

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateTVGroupSelection(HWND hWndTV, lpsbSelectEID)
//
// Updates the selected item on the TreeView to point to the item having the given
// entryid
//
//////////////////////////////////////////////////////////////////////////////////////////
void UpdateTVGroupSelection(HWND hWndTV, LPSBinary lpsbSelectEID)
{

    // search for the specified group and select it ..
    HTREEITEM hRoot = TreeView_GetRoot(hWndTV);

    if(!lpsbSelectEID || !lpsbSelectEID->cb || !lpsbSelectEID->lpb)
    {
        //if(!bIsSelectedTVContainer(lpbwi))
            TreeView_SelectItem(hWndTV, hRoot); //Select the Address Book
    }
    else
    {
        BOOL bSet = FALSE;
        TV_ITEM tvI = {0};

        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        while(hRoot && !bSet)
        {
            HTREEITEM hItem = TreeView_GetChild(hWndTV, hRoot);

            tvI.hItem = hRoot;
            TreeView_GetItem(hWndTV, &tvI);
            if(tvI.lParam)
            {
                LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                if( lptvStuff && lptvStuff->lpsbEID && lptvStuff->lpsbEID->cb &&
                    !memcmp(lptvStuff->lpsbEID->lpb,lpsbSelectEID->lpb,lpsbSelectEID->cb))
                {
                    TreeView_SelectItem(hWndTV, hRoot); 
                    break;
                }
            }
            while(hItem)
            {
                tvI.hItem = hItem;
                TreeView_GetItem(hWndTV, &tvI);
                if(tvI.lParam)
                {
                    LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                    
                    if( lptvStuff && lptvStuff->lpsbEID && lptvStuff->lpsbEID->cb &&
                        !memcmp(lptvStuff->lpsbEID->lpb,lpsbSelectEID->lpb,lpsbSelectEID->cb))
                    {
                        bSet = TRUE;
                        TreeView_SelectItem(hWndTV, hItem); //Select the Address Book
                        break;
                    }
                }
                hItem = TreeView_GetNextSibling(hWndTV, hItem);
            }
            hRoot = TreeView_GetNextSibling(hWndTV, hRoot);
        }
    }
    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the currently selected tree view item is a container item
// Returns true if it is a container item .. this way we can distinguish between 
// groups and folders/containers
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL bIsSelectedTVContainer(LPBWI lpbwi)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
    TV_ITEM tvI = {0};
    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;
    TreeView_GetItem(bwi_hWndTV, &tvI);
    if(tvI.lParam)
        return (((LPTVITEM_STUFF)tvI.lParam)->ulObjectType==MAPI_ABCONT);
    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the focus is on the TreeView or not
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL bIsFocusOnTV(LPBWI lpbwi)
{
    return( IsWindowVisible(bwi_hWndTV) && (bwi_iFocus == s_TV));
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Gets EntryID of CurrentSelection
// lpcbEID, lppEID should be MAPIFreeBuffered
//
//  bTopMost means that get the EntryID of the topmost parent of a given selection in case the
//      selection is on a sub-item
//
//////////////////////////////////////////////////////////////////////////////////////////
void GetCurrentSelectionEID(LPBWI lpbwi, HWND hWndTV, LPSBinary * lppsbEID, ULONG * lpulObjectType, BOOL bTopMost)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(hWndTV);
    TV_ITEM tvI = {0};
    LPSBinary lpsbEID = NULL;

    if(!lppsbEID)
        return;

    *lppsbEID = NULL;

    if(bTopMost)
    {
        HTREEITEM hParent = NULL;
        while(hParent = TreeView_GetParent(hWndTV, hItem))
            hItem = hParent;
    }

    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;
    if(TreeView_GetItem(hWndTV, &tvI))
    {
        if(tvI.lParam)
        {
            LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
            if(lptvStuff)
            {
                if(lptvStuff->lpsbEID)
                {
                    lpsbEID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
                    if(lpsbEID)
                    {
                        if(lptvStuff->lpsbEID->cb)
                            SetSBinary(lpsbEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
                        *lppsbEID = lpsbEID;
                    }
                    if(lpulObjectType)
                        *lpulObjectType = lptvStuff->ulObjectType;
                }
            }
        }
    }
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Removes specified group from WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrRemoveEntryFromWAB(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID)
{
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType;
    SBinaryArray SBA;
    SBinary SB;


    hr = lpIAB->lpVtbl->GetPAB(lpIAB,&cbWABEID,&lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);
    if(HR_FAILED(hr))
        goto out;

                    
    SB.cb = cbEID;
    SB.lpb = (LPBYTE) lpEID;

    SBA.cValues = 1;
    SBA.lpbin = &SB;

    hr = lpWABCont->lpVtbl->DeleteEntries(
                                        lpWABCont,
                                        (LPENTRYLIST) &SBA,
                                        0);
    if(HR_FAILED(hr))
        goto out;

out:
    if(lpWABCont)
        UlRelease(lpWABCont);
    
    if(lpWABEID)
        FreeBufferAndNull(&lpWABEID);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////////
//
// FreeTVItemLParam
//
//
////////////////////////////////////////////////////////////////////////////////////////
void FreeTVItemLParam(HWND hWndTV, HTREEITEM hItem)
{
    TV_ITEM tvI = {0};
    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;

    TreeView_GetItem(hWndTV, &tvI);
    if(tvI.lParam)
    {
        LPTVITEM_STUFF lptvi = (LPTVITEM_STUFF) tvI.lParam;
        if(lptvi)
        {
            // if(lptvi->ulObjectType==MAPI_DISTLIST) //only free this for groups
            LocalFreeSBinary(lptvi->lpsbEID);
            LocalFree(lptvi);
        }
    }
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ClearTreeViewItems - Clears the treeview of all its items
//
//////////////////////////////////////////////////////////////////////////////////////////
void FreeTreeNode(HWND hWndTV, HTREEITEM hItem)
{
    HTREEITEM hTemp = NULL;

    if(!hItem)
        return;

    FreeTVItemLParam(hWndTV, hItem);

    hTemp = TreeView_GetChild(hWndTV, hItem);
    while(hTemp)
    {
        FreeTreeNode(hWndTV, hTemp);
        hTemp = TreeView_GetNextSibling(hWndTV, hTemp);
    }
}

void ClearTreeViewItems(HWND hWndTV)
{
    // Go through all the items and clear their lParams which we allocated earlier
    HTREEITEM hRoot = TreeView_GetRoot(hWndTV);
    while(hRoot)
    {
        FreeTreeNode(hWndTV, hRoot);
        hRoot = TreeView_GetNextSibling(hWndTV, hRoot);
    }
    TreeView_DeleteAllItems(hWndTV);
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemoveCurrentGroup - removes the currently selected group from the WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast)
{
    HRESULT hr = E_FAIL;

    // Warn the user if they really want to do this ?
    if(IDYES == ShowMessageBox( hWnd, idsRemoveGroupFromAB, MB_ICONEXCLAMATION | MB_YESNO ) )
    {
        LPSBinary lpsbEID = NULL;
        // Get the entryid of this group
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

        if(lpsbEID)
        {
            HTREEITEM hItem = NULL;

            // Delete the group contact from the WAB
            hr = HrRemoveEntryFromWAB(bwi_lpIAB, lpsbEID->cb, (LPENTRYID)lpsbEID->lpb);
        
            if(HR_FAILED(hr))
                ShowMessageBox(hWnd, idsRemoveGroupError, MB_ICONEXCLAMATION | MB_OK);

            // Remove selection from the current group
            RemoveUpdateSelection(lpbwi);

            // Update all
            bwi_bDontRefreshLV = TRUE;
            RefreshListView(lpbwi, lpftLast);
            bwi_bDontRefreshLV = FALSE;

            LocalFreeSBinary(lpsbEID);
        }
    }
}



//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemoveCurrentFolder - removes the currently selected folder and all its contents from the WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT RemoveCurrentFolder(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HRESULT hr = E_FAIL;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    ULONG i, j, cValues= 0;
    SBinary sb = {0};
    LPSBinary lpsbEID = NULL;
    LPIAB lpIAB = bwi_lpIAB;

    // Get the entryid of this folder
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

    if( !lpsbEID || !lpsbEID->cb || !lpsbEID->lpb || // can't delete root item
        (lpIAB->lpWABCurrentUserFolder && (lpsbEID->cb==lpIAB->lpWABCurrentUserFolder->sbEID.cb) && //can't delete the current users folder
            !memcmp(lpsbEID->lpb, lpIAB->lpWABCurrentUserFolder->sbEID.lpb, lpsbEID->cb) ) )
    {
        ShowMessageBox(hWnd, idsCannotDelete, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    // ignore deletions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(bwi_lpIAB) || pt_bIsWABOpenExSession)
        goto out;

    // Warn the user if they really want to do this ?
    if(IDYES == ShowMessageBox( hWnd, idsRemoveFolderFromAB, MB_ICONEXCLAMATION | MB_YESNO ) )
    {
        if(lpsbEID && lpsbEID->cb && lpsbEID->lpb) // can't delete root item
        {
            HTREEITEM hItem = NULL;
            // Open the group and read its contents
            if(!HR_FAILED(hr = ReadRecord( bwi_lpIAB->lpPropertyStore->hPropertyStore, 
                                            lpsbEID, 0, &cValues, &lpPropArray)))
            {
                for(i=0;i<cValues;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
                    {
                        for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
                        {
                            hr = HrRemoveEntryFromWAB(bwi_lpIAB, 
                                            lpPropArray[i].Value.MVbin.lpbin[j].cb,
                                            (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[j].lpb);
                        }
                    }
                }

                // Delete the group contact from the WAB
                hr = DeleteRecord( bwi_lpIAB->lpPropertyStore->hPropertyStore, lpsbEID);
        
                if(HR_FAILED(hr) && hr!=MAPI_E_INVALID_ENTRYID)
                    ShowMessageBox(hWnd, idsRemoveFolderError, MB_ICONEXCLAMATION | MB_OK);

                // Remove selection from the current group
                RemoveUpdateSelection(lpbwi);
                // Update all
                bwi_bDontRefreshLV = TRUE;
                HrGetWABProfiles(bwi_lpIAB);
                RefreshListView(lpbwi, lpftLast);
                bwi_bDontRefreshLV = FALSE;
            }
            ReadRecordFreePropArray(NULL, cValues, &lpPropArray);
        }
    }
out:
    LocalFreeSBinary(lpsbEID);
    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemovesSelectedItems from the listview
//
//	lpList is the ContentsList associated with the ListView which needs
//		to be kept updated
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveSelectedItemsFromListView(HWND hWndLV, LPRECIPIENT_INFO * lppList)
{

    int iItemIndex = 0;
    
    if(ListView_GetSelectedCount(hWndLV) <= 0)
        goto exit;

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    // Start removing from the bottom up
    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    
    while(iItemIndex != -1)
    {
        // Get the entryid of the selected item
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;
            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;
			if(lppList && *lppList == lpItem)
				*lppList = lpItem->lpNext;
            FreeRecipItem(&lpItem);
        }
        ListView_DeleteItem(hWndLV, iItemIndex);
        iItemIndex = ListView_GetNextItem(hWndLV, iItemIndex-1, LVNI_SELECTED);
    }

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
exit:
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Removes selected items from the group and the WAB, if specified
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveSelectedItemsFromCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast, BOOL bRemoveFromWAB)
{
    // We want to remove the selected items from the current group and also
    // remove them from the ListView ...
    LPSBinary lpsbEID = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropArray = NULL;
    HRESULT hr = S_OK;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;
    ULONG i,j;
    ULONG ulDLEntriesIndex = 0;
    int id = (bRemoveFromWAB) ? idsRemoveSelectedFromGroupAndAB : idsRemoveSelectedFromGroup;

    if( ListView_GetSelectedCount(bwi_hWndListAB) <= 0)
        goto exit;

    if(IDNO == ShowMessageBox(hWnd, id, MB_ICONEXCLAMATION | MB_YESNO))
        goto exit;

    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

    if(!lpsbEID)
        goto exit;

    if (HR_FAILED(hr = bwi_lpAdrBook->lpVtbl->OpenEntry(bwi_lpAdrBook,
                                                    lpsbEID->cb,    // cbEntryID
                                                    (LPENTRYID)lpsbEID->lpb,    // entryid
                                                    NULL,         // interface
                                                    MAPI_MODIFY,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
        goto exit;
    }

    Assert(lpMailUser);

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    NULL,   // lpPropTagArray
                                                    MAPI_UNICODE,            // ulFlags
                                                    &ulcValues,     // how many properties were there?
                                                    &lpPropArray)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    // Scan these props for the PR_WAB_DL_ENTRIES
    // We ignore PR_WAB_DL_ONEOFFS here because technically you can't have one-offs in the Browse view therefore
    // should never need to delete OneOffs in this function
    for(i=0;i<ulcValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES)
        {
            ulDLEntriesIndex = i;
            break;
        }
    }

    if(!ulDLEntriesIndex)
        goto exit;


    {
        // cycle through the list view items entryids
        int iItemIndex = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);
        while(iItemIndex != -1)
        {
            // Get the entryid of the selected item
            ULONG cbItemEID = 0;
            LPENTRYID lpItemEID = NULL;
            LPRECIPIENT_INFO lpItem = GetItemFromLV(bwi_hWndListAB, iItemIndex);
            if(lpItem)
            {
                RemovePropFromMVBin(lpPropArray,
                                    ulcValues,
                                    ulDLEntriesIndex,
                                    (LPVOID) lpItem->lpEntryID,
                                    lpItem->cbEntryID);
                if(bRemoveFromWAB)
                {
                    // Delete the group contact from the WAB
                    // Note; This is very inefficient - we should ideally create a 
                    //  SBinaryArray and call deleteentries all at once
                    //  We'll leave that for some later time <TBD> <BUGBUG>
                    hr = HrRemoveEntryFromWAB(bwi_lpIAB, lpItem->cbEntryID, lpItem->lpEntryID);
                }
            }
            iItemIndex = ListView_GetNextItem(bwi_hWndListAB, iItemIndex, LVNI_SELECTED);
        }
    }

    // Knock out the PR_WAB_DL_ENTRIES property so we can overwrite it
    {
        if (HR_FAILED(hr = lpMailUser->lpVtbl->DeleteProps(lpMailUser,
                                                           (LPSPropTagArray) &tagaDLEntriesProp,
                                                            NULL)))
        {
            DebugTraceResult( TEXT("IAB->DeleteProps:"), hr);
            goto exit;
        }

    }
    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                    ulcValues,     
                                                    lpPropArray,
                                                    NULL)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    if(HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READONLY)))
    {
        DebugTraceResult( TEXT("SaveChanges failed: "), hr);
        goto exit;
    }

    // update the file stamp
    //if (lpftLast) {
    //    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
    //}
    bwi_bDeferNotification = TRUE;

    RemoveSelectedItemsFromListView(bwi_hWndListAB, &bwi_lpContentsList);

exit:

    if(lpsbEID)
        LocalFreeSBinary(lpsbEID);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Shows properties on the currently selected group or folder
//
//////////////////////////////////////////////////////////////////////////////////////////
void ViewCurrentGroupProperties(LPBWI lpbwi, LPFILETIME lpftLast)
{
    LPSBinary lpsbEID = NULL;
    HWND hWnd = GetParent(bwi_hWndTV);
    ULONG ulObjectType = 0;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    if(lpsbEID && (ulObjectType==MAPI_DISTLIST))
    { 
        bwi_lpAdrBook->lpVtbl->Details(	bwi_lpAdrBook,
									(PULONG_PTR) &hWnd,
									NULL,
									NULL,
									lpsbEID->cb,
									(LPENTRYID)lpsbEID->lpb,
									NULL,
									NULL,
									NULL,
									0);
        // if the item name changed, update it
        {
            LPRECIPIENT_INFO lpInfo = NULL;
            ReadSingleContentItem( bwi_lpAdrBook,
                                   lpsbEID->cb,
                                   (LPENTRYID) lpsbEID->lpb,
                                   &lpInfo);
            if(lpInfo)
            {
                TV_ITEM tvi = {0};
                tvi.hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
                tvi.mask = TVIF_HANDLE;
                TreeView_GetItem(bwi_hWndTV, &tvi);
                tvi.mask |= TVIF_TEXT;
                tvi.pszText = lpInfo->szDisplayName;
                tvi.cchTextMax = lstrlen(tvi.pszText)+1;
                TreeView_SetItem(bwi_hWndTV, &tvi);
                FreeRecipItem(&lpInfo);
            }
            

        }

		UpdateListViewContents(lpbwi, lpsbEID, ulObjectType);
		// Update the wab file write time so the timer doesn't
		// catch this change and refresh.
		//if (lpftLast) {
		//	CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
		//}
        bwi_bDeferNotification = TRUE;

	}
    else if(lpsbEID //&& lpsbEID->cb && lpsbEID->lpb 
            && (ulObjectType==MAPI_ABCONT) 
            && bIsWABSessionProfileAware(bwi_lpIAB))
    {
        // view properties on the folder entry
        if(!HR_FAILED(HrFolderProperties(GetParent(bwi_hWndTV), bwi_lpIAB, lpsbEID, NULL, NULL)))
        {
            //UpdateViewFoldersMenu(lpbwi, hWnd);
            RefreshListView(lpbwi,lpftLast);
        }
    }

    if(lpsbEID)
        LocalFreeSBinary(lpsbEID);

    return;
}
//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Processes messages for the TREE view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessTreeViewMessages(LPBWI lpbwi, HWND hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam, LPFILETIME lpftLast)
{

    NM_TREEVIEW * pNm = (NM_TREEVIEW *)lParam;

    switch(pNm->hdr.code)
    {
    case NM_SETFOCUS:
        UpdateToolbarAndMenu(lpbwi);
    	break;

    case TVN_KEYDOWN:
        //UpdateToolbarAndMenu(lpbwi);
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_DELETE, 0);
            return 0;
            break;
    	case VK_RETURN:
    		SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return 0;
        }
        break;

	case TVN_SELCHANGEDW:
    case TVN_SELCHANGEDA:
        {
            if(!bwi_bDontRefreshLV)
                UpdateLV(lpbwi);
	        UpdateToolbarAndMenu(lpbwi);
        }
    	break;
    }


    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

BOOL SplitterHitTest(HWND hWndT, LPARAM lParam)
{
	LONG xPos = LOWORD(lParam);
	LONG yPos = HIWORD(lParam);
	RECT rc;
    if(!IsWindowVisible(hWndT))
        return FALSE;
	GetChildClientRect(hWndT, &rc);
	if(	(xPos <= rc.right) && (xPos >= rc.left) && 
		(yPos <= rc.bottom) && (yPos >= rc.top) )
		return TRUE;
	else
		return FALSE;
}



/////////////////////////////////////////
// Stolen (essentially) from COMMCTRL
HBITMAP FAR PASCAL CreateDitherBitmap(COLORREF crFG, COLORREF crBG)
{
    PBITMAPINFO pbmi;
    HBITMAP hbm;
    HDC hdc;
    int i;
    long patGray[8];
    DWORD rgb;

    pbmi = (PBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * 16));
    if (!pbmi)
        return NULL;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 8;
    pbmi->bmiHeader.biHeight = 8;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = BI_RGB;

    rgb = crBG;
    pbmi->bmiColors[0].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[0].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[0].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[0].rgbReserved = 0;

    rgb = crFG;
    pbmi->bmiColors[1].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[1].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[1].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[1].rgbReserved = 0;


    /* initialize the brushes */

    for (i = 0; i < 8; i++)
       if (i & 1)
           patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray
       else
           patGray[i] = 0x5555AAAAL;   //  0x11114444L; // lighter gray

    hdc = GetDC(NULL);

    // REVIEW: We cast am array of long to (BYTE const *). Is it ok for Win32?
    hbm = CreateDIBitmap(hdc, &pbmi->bmiHeader, CBM_INIT,
                         (BYTE const *)patGray, pbmi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);

    LocalFree(pbmi);

    return hbm;
}

// Stolen (essentially) from COMMCTRL
HBRUSH FAR PASCAL CreateDitherBrush(COLORREF crFG, COLORREF crBG)
{
	HBITMAP hbm;
	HBRUSH hbrRet = NULL;

	hbm = CreateDitherBitmap(crFG, crBG);
	if (hbm)
	{
		hbrRet = CreatePatternBrush(hbm);
		DeleteObject(hbm);
	}

	return(hbrRet);
}
//////////////////////////////////////////

// Stolen from Athena
void DragSplitterBar(LPBWI lpbwi, HWND hwnd, HWND hWndT, LPARAM lParam)
{
	MSG msg;
	int x, y, dx, dy;
	RECT rcSplitter;
	RECT rc;
    HDC hdc;
    LONG lStyle;
    HBRUSH hbrDither, hbrOld;
    int nAccel = 2;

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    SetWindowLong(hwnd, GWL_STYLE, (lStyle & ~WS_CLIPCHILDREN));

	GetChildClientRect(hWndT, &rcSplitter);
	//GetWindowRect(hWndT, &rcSplitter);
	x = rcSplitter.left;
	y = rcSplitter.top;
    dx = rcSplitter.right - rcSplitter.left;
    dy = rcSplitter.bottom - rcSplitter.top;

	GetWindowRect(hwnd, &rc);
	
    hdc = GetDC(hwnd);
	hbrDither = CreateDitherBrush(RGB(255, 255, 255), RGB(0, 0, 0));
	if (hbrDither)
        hbrOld = (HBRUSH)SelectObject(hdc, (HGDIOBJ)hbrDither);

    // split bar loop...
    PatBlt(hdc, x, y, dx, dy, PATINVERT);

    SetCapture(hwnd);

    while (GetMessage(&msg, NULL, 0, 0))
    {
	    if (	msg.message == WM_LBUTTONUP || 
				msg.message == WM_LBUTTONDOWN ||
				msg.message == WM_RBUTTONDOWN)
            break;

        if (GetCapture() != hwnd)
        {
            msg.message = WM_RBUTTONDOWN; // treat as cancel
            break;
        }

        if (	msg.message == WM_KEYDOWN || 
				msg.message == WM_SYSKEYDOWN ||
				(msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST) )
        {
            if (msg.message == WM_KEYDOWN)
            {
                nAccel = 4;

                if (msg.wParam == VK_LEFT)
                {
                    msg.message = WM_MOUSEMOVE;
                    msg.pt.x -= nAccel/2;
                }
				else if (msg.wParam == VK_RIGHT)
                {
                    msg.message = WM_MOUSEMOVE;
                    msg.pt.x += nAccel/2;
                }
                else if (	msg.wParam == VK_RETURN ||
		                    msg.wParam == VK_ESCAPE)
                {
                    break;
                }

                if (msg.pt.x > rc.right)
                    msg.pt.x = rc.right;

                if (msg.pt.x <  rc.left)
                    msg.pt.x = rc.left;

                SetCursorPos(msg.pt.x, msg.pt.y);
            }

            if (msg.message == WM_MOUSEMOVE)
            {
                int lo, hi;

                if (msg.pt.x > rc.right)
                    msg.pt.x = rc.right;
                if (msg.pt.x <  rc.left)
                    msg.pt.x = rc.left;

                ScreenToClient(hwnd, &msg.pt);

                // Clip out the parts we don't want so
                // that we do a single PatBlt (less
                // flicker for small movements).
                if (x < msg.pt.x)
                {
                    lo = x;
                    hi = msg.pt.x;
                }
                else
	            {
					lo = msg.pt.x;
					hi = x;
                }

				if (hi < lo+dx)
                {
	                ExcludeClipRect(hdc, hi, y, lo+dx, y+dy);
                }
                else
                {
	                ExcludeClipRect(hdc, lo+dx, y, hi, y+dy);
                }

                // Erase the old and draw the new in one draw.
                PatBlt(hdc, lo, y, hi-lo+dx, dy, PATINVERT);
                SelectClipRgn(hdc, NULL);

                x = msg.pt.x;
            }
        }
        else
        {
            DispatchMessage(&msg);
        }
    }

    ReleaseCapture();

    // erase old
    PatBlt(hdc, x, y, dx, dy, PATINVERT);

    if (hbrDither)
    {
        if (hbrOld)
            SelectObject(hdc, hbrOld);
        DeleteObject(hbrDither);
    }
    ReleaseDC(hwnd, hdc);

    SetWindowLong(hwnd, GWL_STYLE, lStyle);

    if (msg.wParam != VK_ESCAPE && msg.message != WM_RBUTTONDOWN && msg.message != WM_CAPTURECHANGED)
    {
		RECT rcTV;
		GetChildClientRect(bwi_hWndTV, &rcTV);

		MoveWindow(bwi_hWndTV, rcTV.left, rcTV.top, x, rcTV.bottom - rcTV.top, TRUE);

		ResizeAddressBookChildren(lpbwi, hwnd);

    	InvalidateRect( bwi_hWndSplitter,NULL,TRUE);
    	InvalidateRect( bwi_hWndEditQF,NULL,TRUE);
    	InvalidateRect( bwi_hWndStaticQF,NULL,TRUE);
    	InvalidateRect( hwnd,NULL,TRUE);
		RedrawWindow(	hwnd, NULL, NULL,
						RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW );
		RedrawWindow(	bwi_hWndEditQF, NULL, NULL,
						RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW );
    }

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// Opens a VCard and adds it to the WAB and to the Current group
//	szVCardFIle can be a NULL in which case we open the OpenFile dialog
//
//////////////////////////////////////////////////////////////////////////////////
HRESULT OpenAndAddVCard(LPBWI lpbwi, LPTSTR szVCardFile)
{
	HRESULT hr = S_OK;
    LPSPropValue lpProp  = NULL;

	hr = VCardImport(bwi_hWndAB, bwi_lpAdrBook, szVCardFile, &lpProp);

    // if the above failed, then the lpProp will have nothing in it
    // in cases where there are multiple nested vcards, the error could
    // be from one vcard, but the rest may have imported .. if they
    // imported successfully then lpProp will have something in it ..
    // so use lpProp instead of hr ..
    if(lpProp)
	{
        if(HR_FAILED(hr))
            hr = MAPI_W_ERRORS_RETURNED;

		bwi_bDontRefreshLV = TRUE;
		if(lpProp && PROP_TYPE(lpProp->ulPropTag) == PT_MV_BINARY)
		{
			if(!bIsSelectedTVContainer(lpbwi))
			{
                LPSBinary lpsbEIDGroup = NULL;
                ULONG ulObjectType = 0;
                bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
				GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEIDGroup, &ulObjectType, FALSE);
                if(lpsbEIDGroup)
                {
                    ULONG i = 0;
                    for(i=0;i<lpProp->Value.MVbin.cValues;i++)
                    {
				        hr = AddEntryToContainer(bwi_lpAdrBook, ulObjectType,
								        lpsbEIDGroup->cb, (LPENTRYID) lpsbEIDGroup->lpb,
								        lpProp->Value.MVbin.lpbin[i].cb,
								        (LPENTRYID) lpProp->Value.MVbin.lpbin[i].lpb);
                    }
                }
			}
		}
		FreeBufferAndNull(&lpProp);
		bwi_bDontRefreshLV = FALSE;
    	// if updated and showing PAB, refresh list
		SendMessage(bwi_hWndAB, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
	}

	return hr;
}



//$$
//  Updates the switch-user's menu if this is not a wab.exe initiated call
//
//
void UpdateSwitchUsersMenu(HWND hWnd, LPIAB lpIAB)
{
    if( memcmp(&lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) ||
        !bIsThereACurrentUser(lpIAB) || !bAreWABAPIProfileAware(lpIAB))
    {
        HMENU hMenuMain = GetMenu(hWnd);
        HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
        // Need to remove the print and the seperator
	RemoveMenu(hMenuFile, idmFSep5, MF_BYPOSITION);
	RemoveMenu(hMenuFile, idmAllContents, MF_BYPOSITION);
	RemoveMenu(hMenuFile, idmSwitchUsers, MF_BYPOSITION);
        DrawMenuBar(hWnd);
    }
}


//$$
//
// Turns of the print menu if requested to do so
//
//
void UpdatePrintMenu(HWND hWnd)
{
    if(!bPrintingOn)
    {
        HMENU hMenuMain = GetMenu(hWnd);
        HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
        
        // Need to remove the print and the seperator
        RemoveMenu(hMenuFile, idmFSep4, MF_BYPOSITION);
        RemoveMenu(hMenuFile, idmPrint, MF_BYPOSITION);

        DrawMenuBar(hWnd);
    }
    return;
}

/*
-
- UpdateViewFoldersMenu
-
*
*
*/
void UpdateViewFoldersMenu(LPBWI lpbwi, HWND hWnd)
{
#ifdef FUTURE
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
    HMENU hMenu = GetSubMenu(hMenuFile, idmFolders);
    LPIAB lpIAB = bwi_lpIAB;
    int i = 0;

    // If profiles are not enabled or there are no subfolders, remove the folder option completely
    if(!bDoesThisWABHaveAnyUsers(lpIAB))
    {
        // remove all folder options:

        // Remove the Folders option from the View Menu
        RemoveMenu(hMenuFile, idmSepFolders, MF_BYPOSITION); 
        RemoveMenu(hMenuFile, idmFolders, MF_BYPOSITION); 
        goto out;
    }
    else 
    {
        // removing screws up numbering and svrewss up access to other folders
        // so just disable
        EnableMenuItem(hMenuFile, idmSepFolders, MF_BYPOSITION | (lpIAB->lpWABFolders ? MF_ENABLED : MF_GRAYED)); 
        EnableMenuItem(hMenuFile, idmFolders, MF_BYPOSITION | (lpIAB->lpWABFolders ? MF_ENABLED : MF_GRAYED)); 
        if(lpIAB->lpWABFolders)
            AddFolderListToMenu(hMenu, lpIAB);
        goto out;
    }

    // if there is only 1 folder in the wab and this is the shared folder
    // then disable the folder item because there is nothing to be done
    //if( !bIsThereACurrentUser(lpIAB) )
    //{
    //    EnableMenuItem(hMenuView, idmFolders, MF_BYPOSITION | MF_GRAYED); 
    //    goto out;
    //}


out:
#endif // FUTURE
    return;
}


//$$
//  UpdateOutlookMenus
//
//  Some menus are not accessible when running from outlook
//
//  Tools | Options Menu should not be accessible from WAB when
//  outlook is in Full MAPI mode because then Outlook doesnt use 
//  WAB and we dont want to give the option to the user of 
//  switching to the WAB
//
void UpdateOutlookMenus(HWND hWnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bNoOptions = TRUE;
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuFile = NULL;
    HMENU hMenu = NULL;

    if( pt_bIsWABOpenExSession && 
        lpfnAllocateBufferExternal &&                           // **ASSUMPTION** that Outlook always
        lpfnAllocateMoreExternal && lpfnFreeBufferExternal)     // passes in memory allocators ..!!! 
    {
/*
        hMenuFile = GetSubMenu(hMenuMain, idmFile);

        {
            // Need to remove the import AddressBook and Export Addressbook options
            hMenu = GetSubMenu(hMenuFile, idmImport);
            RemoveMenu(hMenu, IDM_TOOLS_IMPORT_OTHER, MF_BYCOMMAND); 
            hMenu = GetSubMenu(hMenuFile, idmExport);
            RemoveMenu(hMenu, IDM_TOOLS_EXPORT_OTHER, MF_BYCOMMAND); 
            RemoveMenu(hMenu, IDM_TOOLS_EXPORT_WAB, MF_BYCOMMAND); 
        }
*/
/*
        // [PaulHi] 12/18/98  Raid #62640
        // Disable the Import/Export menu items before anything is removed and
        // order gets messed up.
        EnableMenuItem(hMenuFile, idmImport, MF_GRAYED | MF_BYPOSITION);
        EnableMenuItem(hMenuFile, idmExport, MF_GRAYED | MF_BYPOSITION);

        //Also remove New Folder menu
        RemoveMenu(hMenuFile, IDM_FILE_NEWFOLDER, MF_BYCOMMAND);
*/
    }
    else
    {
        // Not called from Outlook ...
        // check if Outlook is using the WAB .. if it isnt, we dont want
        // to show the Tools Options menu
        //
        HKEY hKey = NULL;
        LPTSTR lpReg =  TEXT("Software\\Microsoft\\Office\\8.0\\Outlook\\Setup");
        LPTSTR lpOMI =  TEXT("MailSupport");
        BOOL bUsingWAB = FALSE;

        if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, lpReg, 0, KEY_READ, &hKey))
        {
            DWORD dwType = 0, dwSize = sizeof(DWORD), dwData = 0;
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpOMI, NULL, &dwType, (LPBYTE)&dwData, &dwSize))
            {
                if(dwType == REG_DWORD && dwData == 0)
                    bUsingWAB = TRUE;
            }
        }

        if(hKey)
            RegCloseKey(hKey);

        bNoOptions = !bUsingWAB;
    }

    // [PaulHi] 1/4/99  The pt_bIsWABOpenExSession variable is mis-named.  This 
    // boolean used to be true only if the WAB was opened from WABOpenEx, i.e, 
    // by Outlook using the Outlook store.  However, this boolean is now true in
    // the case where the WAB is open from WABOpen but still uses the Outlook 
    // store because it is in "shared mode", i.e., the use outlook store registry
    // setting is true.
    if(pt_bIsWABOpenExSession)
    {
        //Also remove New Folder menu
        hMenuFile = GetSubMenu(hMenuMain, idmFile);

        // [PaulHi] 1/4/99  Raid #64016
        // Disable the Import/Export menu items before anything is removed and
        // order gets messed up.
        // This is similar to Raid #62640 except we need to disable import/export
        // WHENEVER the WAB is opened to use the Outlook store since it doesn't
        // know how to import/export Outlook store information.
        EnableMenuItem(hMenuFile, idmImport, MF_GRAYED | MF_BYPOSITION);
        EnableMenuItem(hMenuFile, idmExport, MF_GRAYED | MF_BYPOSITION);

        RemoveMenu(hMenuFile, IDM_FILE_NEWFOLDER, MF_BYCOMMAND);

        // [PaulHi] 3/22/99  Raid 73457  Remove the Profile... Edit menu item
        // since profiles are turned off when in Outlook mode
        hMenu = GetSubMenu(hMenuMain, idmEdit);
        RemoveMenu(hMenu, IDM_EDIT_SETME, MF_BYCOMMAND);    // Profile... menu item
        RemoveMenu(hMenu, 5, MF_BYPOSITION);                // Seperator
    }

    if(bNoOptions)
    {
        // Hide the tools options option
        //
        hMenuFile = GetSubMenu(hMenuMain,idmTools);

        // Need to remove the second-last and third-last items
        RemoveMenu(hMenuFile, 3, MF_BYPOSITION); //Seperator
        RemoveMenu(hMenuFile, 2, MF_BYPOSITION); //Options

        DrawMenuBar(hWnd);
    }

    return;
}


void UpdateCustomColumnMenuText(HWND hWnd)
{
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuView = GetSubMenu(hMenuMain, idmView);
    int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
    HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_STRING;

    if(PR_WAB_CUSTOMPROP1 && lstrlen(szCustomProp1))
    {
        mii.dwTypeData = (LPTSTR) szCustomProp1;
        mii.cch = lstrlen(szCustomProp1) + 1;
        SetMenuItemInfo(hMenu, 3, TRUE, &mii);        
    }
    if(PR_WAB_CUSTOMPROP2 && lstrlen(szCustomProp2))
    {
        mii.dwTypeData = (LPVOID) szCustomProp2;
        mii.cch = lstrlen(szCustomProp2) + 1;
        SetMenuItemInfo(hMenu, 2, TRUE, &mii);
    }
    DrawMenuBar(hWnd);
    return;
}


//$$
// bCheckForOutlook
// Checks if the Outlook Contact Store is available
//
// If this is an outlook session, this is true by default
// Otherwise hunt for presence of outlwab.dll
//
BOOL bCheckForOutlook()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if(pt_bIsWABOpenExSession)
        return TRUE;

    // Not an outlook session ..
    // Look for OutlWAB.Dll 
    return bCheckForOutlookWABDll(NULL);

}

//$$
//
// Dialog proc for the options dialog
//
/*//$$************************************************************************
//
//  fnSearch - Search Dialog Proc
//
**************************************************************************/
INT_PTR CALLBACK fnOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            if(!bCheckForOutlook()) //<TBD> - No Outlook 98 is installed
            {
                // Disable the Outlook option
                EnableWindow(GetDlgItem(hDlg, IDC_OPTIONS_RADIO_OUTLOOK), FALSE);
                SendMessage(hDlg, WM_COMMAND, (WPARAM) MAKEWPARAM(IDC_OPTIONS_RADIO_WAB, BN_CLICKED), (LPARAM) GetDlgItem(hDlg, IDC_OPTIONS_RADIO_WAB));
                if(bUseOutlookStore()) // make sure reg says false .. not true
                    SetRegistryUseOutlook(FALSE);
            }
            else
            {
                // Correct type of Outlook is installed
                int id = bUseOutlookStore() ? IDC_OPTIONS_RADIO_OUTLOOK : IDC_OPTIONS_RADIO_WAB;
                SendMessage(hDlg, WM_COMMAND, 
                        (WPARAM) MAKEWPARAM(id, BN_CLICKED), 
                        (LPARAM) GetDlgItem(hDlg, id));
            }
        }

        // [PaulHi] Be sure to set the child window fonts
        EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM)PARENT_IS_DIALOG);
        return TRUE;
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            // Check which option button is checked
            {
                BOOL bOriginal = bUseOutlookStore();
                BOOL bCurrent = IsDlgButtonChecked(hDlg, IDC_OPTIONS_RADIO_OUTLOOK);
                SetRegistryUseOutlook(bCurrent);
                if(bCurrent != bOriginal)
                    ShowMessageBox(hDlg, idsStoreChangeOnRestart, MB_ICONINFORMATION | MB_OK);
            }
            // fall thru
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        case IDC_OPTIONS_RADIO_WAB:
            CheckRadioButton(hDlg,
                            IDC_OPTIONS_RADIO_OUTLOOK,
                            IDC_OPTIONS_RADIO_WAB,
                            IDC_OPTIONS_RADIO_WAB);	
            break;

        case IDC_OPTIONS_RADIO_OUTLOOK:
            CheckRadioButton(hDlg,
                            IDC_OPTIONS_RADIO_OUTLOOK,
                            IDC_OPTIONS_RADIO_WAB,
                            IDC_OPTIONS_RADIO_OUTLOOK);	
            break;
        }
        break;
    }

    return FALSE;
}

//$$
//
// Shows the options dialog 
//
void HrShowOptionsDlg(HWND hWndParent)
{
    BOOL bChange = FALSE;
    INT_PTR nRetVal = DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_OPTIONS),
		         hWndParent, (DLGPROC) fnOptionsDlgProc, (LPARAM) &bChange);
}

//$$////////////////////////////////////////////////////////////////////////////
//
// AddTVItem
//
// Adds an item to the Tree View - item can be folder/container or group
//
////////////////////////////////////////////////////////////////////////////////
HTREEITEM AddTVItem(HWND hWndTV, LPTSTR lpszName,  HTREEITEM hParentItem, HTREEITEM htiAfter,
               LPSBinary lpsbParentEID, LPSBinary lpEID, ULONG ulObjectType)
{
    TV_ITEM tvI = {0};
    TV_INSERTSTRUCT tvIns = {0};
    LPTVITEM_STUFF lptvStuff = NULL;
    HTREEITEM htiRet = NULL;
    int img = 0;

    if(ulObjectType == MAPI_DISTLIST)
        img = imageDistList;
    else
    {
        if(!lpEID || !lpEID->cb || !lpEID->lpb)
            img = imageAddressBook;
        else
            img = imageFolderClosed;
    }

    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvI.iImage = img;
    tvI.iSelectedImage = (img == imageFolderClosed) ? imageFolderOpen : img;
    tvI.pszText = lpszName;
    tvI.cchTextMax = lstrlen(tvI.pszText);

    lptvStuff = LocalAlloc(LMEM_ZEROINIT, sizeof(TVITEM_STUFF));
    if(!lptvStuff)
        goto out;

    lptvStuff->ulObjectType = ulObjectType;

    if(lpEID)
    {
        LPSBinary lpsbEID = NULL;
        lpsbEID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(lpsbEID)
        {
            if(lpEID->cb)
                SetSBinary(lpsbEID, lpEID->cb, lpEID->lpb);
            lptvStuff->lpsbEID = lpsbEID;
        }
    }

    lptvStuff->lpsbParent = lpsbParentEID;
    lptvStuff->hItemParent = hParentItem;

    tvI.lParam = (LPARAM) lptvStuff;

    tvIns.item = tvI;
    tvIns.hInsertAfter = htiAfter;
    tvIns.hParent = hParentItem;
    
    htiRet = TreeView_InsertItem(hWndTV, &tvIns);

    /* Uncomment this to make the top level folders show up in bold
    if(htiRet && !hParentItem)
    {
        TVITEM tvi = {0};
        tvi.mask = TVIF_STATE;
        tvi.state = tvi.stateMask = TVIS_BOLD;
        tvi.hItem = htiRet;
        TreeView_SetItem(hWndTV, &tvi);
    }*/
out:
    return htiRet;
}

//$$///////////////////////////////////////////////////////////////////////////
//
// AddTVFolderGroup
// 
// Add a group under a contact folder in the TV
//
///////////////////////////////////////////////////////////////////////////////
HTREEITEM AddTVFolderGroup(LPBWI lpbwi, HWND hWndTV, HTREEITEM hParentItem, LPSBinary lpsbParentEID, LPSBinary lpsbEID)
{
	TCHAR szBufName[MAX_UI_STR];

    if(!lpsbEID || !lpsbEID->cb || !lpsbEID->lpb)
        return NULL;

    // Get the name of this group
	if(HR_FAILED(FillListFromGroup( bwi_lpAdrBook,
                            lpsbEID->cb, (LPENTRYID) lpsbEID->lpb,									
                            szBufName, NULL)))
        return NULL;

    return AddTVItem( hWndTV, szBufName, 
               hParentItem, TVI_SORT,
               lpsbParentEID, lpsbEID,
               MAPI_DISTLIST);
}

//$$///////////////////////////////////////////////////////////////////////////////
//
// FillTreeView
//
// Fill the TreeView with Contact Folders and groups as appropriate
//
//      lpsbSelection - entryid of item to select after filling
//
///////////////////////////////////////////////////////////////////////////////////
void FillTreeView(LPBWI lpbwi, HWND hWndTV, LPSBinary lpsbSelection)
{
    // Way to do this
    //
    // If this is the WAB, just add an AddressBook item to the top of the list
    // otherwise if this is Outlook, get a list of all the contact folders and
    // add them to the Root of the TV.
    //
    // Then go through the list of contact folders and for each one, add the groups
    // at the next level
    // We cache the TVITEM_STUFF info on each item, contact folder or group
    //
    HTREEITEM hItem = NULL;    
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = bwi_lpIAB;
    int nDepth = 0;

    bwi_bDontRefreshLV = TRUE;

    SendMessage(hWndTV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    ClearTreeViewItems(hWndTV);

    EnterCriticalSection(&lpIAB->cs);


    // Check if this is an outlook session
    if( pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB) )
    {
	    ULONG iolkci, colkci;
	    OlkContInfo *rgolkci;
        HTREEITEM htiTopLevel = NULL;

        colkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->colkci : lpIAB->cwabci;
	    Assert(colkci);
        rgolkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->rgolkci : lpIAB->rgwabci;
	    Assert(rgolkci);

        // Add the multiple folders here
        // Since each folder is added under the first item, we start last first
        // to preserve the folder order.
        if(pt_bIsWABOpenExSession)
        {
            do
            {
                iolkci = colkci-1;
                htiTopLevel = AddTVItem(  hWndTV, rgolkci[iolkci].lpszName, NULL, TVI_FIRST, NULL, 
                            (iolkci==0/*&& pt_bIsWABOpenExSession*/) ? NULL : rgolkci[iolkci].lpEntryID,
                            MAPI_ABCONT);
                colkci--;
            } while(colkci!=0);
        }
        else
        {
            // WAB Profiles ..
            // We want to add the first item ( TEXT("All Contacts")) at the top and all user folders
            // at the same level and all ordinary folders under the user level folders
            LPWABFOLDER lpFolder = (bIsThereACurrentUser(lpIAB) ? lpIAB->lpWABCurrentUserFolder : lpIAB->lpWABUserFolders);
            
            // With a given user, we only add that users folder
            // Without a given user we add everyones folders

            // if there are no user folders at all then we don't have user's configured and
            // all folders should show up at the top level
            if(!lpFolder)
                lpFolder = lpIAB->lpWABFolders;

            while(lpFolder)
            {
                LPWABFOLDERLIST lpFolderList = lpFolder->lpFolderList;
                htiTopLevel = AddTVItem(hWndTV, lpFolder->lpFolderName, NULL, TVI_SORT, NULL, &lpFolder->sbEID, MAPI_ABCONT);
                while(lpFolderList)
                {
                    // Don't show Shared Folders under the user-folders .. shared folders will be
                    // shown under the PAB folder
                    if(!lpFolderList->lpFolder->bShared)
                        AddTVItem(hWndTV, lpFolderList->lpFolder->lpFolderName, htiTopLevel, TVI_SORT, NULL, &lpFolderList->lpFolder->sbEID, MAPI_ABCONT);
                    lpFolderList = lpFolderList->lpNext;
                }
                TreeView_Expand(hWndTV, htiTopLevel, TVE_EXPAND);

                if(lpIAB->lpWABCurrentUserFolder)
                    break;
                lpFolder=lpFolder->lpNext;
            }
            // Add the Virtual PAB item to the top of the list so we can sort the others
            htiTopLevel = AddTVItem(hWndTV, rgolkci[0].lpszName, NULL, TVI_FIRST, NULL, rgolkci[0].lpEntryID, MAPI_ABCONT);
            // add all the SHARED folders under the root item
            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                if(lpFolder->bShared)
                    AddTVItem(hWndTV, lpFolder->lpFolderName, htiTopLevel, TVI_SORT, NULL, &lpFolder->sbEID, MAPI_ABCONT);
                lpFolder=lpFolder->lpNext;
            }
            //if(!bIsThereACurrentUser(lpIAB) && !bDoesThisWABHaveAnyUsers(lpIAB))
            TreeView_Expand(hWndTV, htiTopLevel, TVE_EXPAND);
        }
    }
    else
    {
        TCHAR sz[MAX_PATH];
        *sz = '\0';
        LoadString(hinstMapiX, idsContacts/*IDS_ADDRBK_CAPTION*/, sz, CharSizeOf(sz));
        AddTVItem( hWndTV, sz, NULL, TVI_FIRST, NULL, NULL, MAPI_ABCONT);
    }

    //TreeView_SortChildren(hWndTV, NULL, 0);

    // Now we have all the contact folders at the root level ..
    // we can now add the groups under each folder
    hItem = TreeView_GetRoot(hWndTV);
    
    //if(bDoesThisWABHaveAnyUsers(lpIAB)) // don't populate any groups under the Root Item if Users exist
    //    hItem = TreeView_GetNextSibling(hWndTV, hItem);
    while(hItem)
    {
        TV_ITEM tvI = {0};
        // Find all the Groups in this folder
        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        tvI.hItem = hItem;
        if(TreeView_GetItem(hWndTV, &tvI))
        {
            if(tvI.lParam && ((LPTVITEM_STUFF)tvI.lParam)->ulObjectType==MAPI_ABCONT)
            {
                LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                SPropertyRestriction PropRes = {0};
		        SPropValue sp = {0};
                HRESULT hr = S_OK;
                ULONG ulCount = 0;
                LPSBinary rgsbEntryIDs = NULL;

                sp.ulPropTag = PR_OBJECT_TYPE;
		        sp.Value.l = MAPI_DISTLIST;

                PropRes.ulPropTag = PR_OBJECT_TYPE;
                PropRes.relop = RELOP_EQ;
                PropRes.lpProp = &sp;

                if(!HR_FAILED(hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
							        lptvStuff->lpsbEID, 0, TRUE, &PropRes,
                                    &ulCount,&rgsbEntryIDs)))
                {
                    ULONG i;
                    for(i=0;i<ulCount;i++)
                        AddTVFolderGroup(lpbwi, hWndTV, hItem, lptvStuff->lpsbEID, &(rgsbEntryIDs[i]));

                    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
                }
            }
        }

        TreeView_SortChildren(hWndTV, hItem, 0);
        
        // Start at the top level, look for children, 
        // if no children, look for next sibling,
        // if no sibling, look for parent's sibling
        {
            HTREEITEM hTemp = NULL;
            if(nDepth < 1) // Assumes we only have 2 levels of folders - this way we don't look at the third level which may only have groups
                hTemp = TreeView_GetChild(hWndTV, hItem);
            if(hTemp)
                nDepth++;
            else
                hTemp = TreeView_GetNextSibling(hWndTV, hItem);
            if(!hTemp)
            {
                if(hTemp = TreeView_GetParent(hWndTV, hItem))
                {
                    nDepth--;
                    hTemp = TreeView_GetNextSibling(hWndTV, hTemp);
                }
            }
            hItem = hTemp;
        }
    }

    if(!lpsbSelection && bIsThereACurrentUser(bwi_lpIAB))
        lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;

    UpdateTVGroupSelection(hWndTV, lpsbSelection);

    //if(!lpsbSelection || !lpsbSelection->cb || !lpsbSelection->lpb)
    {
        LPSBinary lpsb = NULL;
        //UpdateListViewContents(lpbwi, &sb, MAPI_ABCONT);
        ULONG ulObjectType;
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsb, &ulObjectType, FALSE);
        UpdateListViewContents(lpbwi, lpsb, ulObjectType);
        LocalFreeSBinary(lpsb);
    }

    SendMessage(hWndTV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    bwi_bDontRefreshLV = FALSE;
    
    LeaveCriticalSection(&lpIAB->cs);

    {
        // if there is only a single item in the tree view, remove the haslines style
        // as it looks pretty strange..
        //
        DWORD dwStyle = GetWindowLong(hWndTV, GWL_STYLE);
        int nCount = TreeView_GetCount(hWndTV);
        if(nCount > 1)
            dwStyle |= TVS_HASLINES;
        else
            dwStyle &= ~TVS_HASLINES;
        SetWindowLong(hWndTV, GWL_STYLE, dwStyle);
    }

    return;
}



typedef struct _FolderInfo
{
    BOOL bIsReadOnly;       // Sets DLG ctrls to readonly
    BOOL bIsShared;         // Indicates if shared
    BOOL bForceShared;      // Indicates that shared-checkbox should be shared and non-modifiable
    LPTSTR lpsz;            // Folder name (in and out param)
    LPTSTR lpszOldName;     // Old name so we can track name changes
    LPTSTR lpszOwnerName;   // Person who created this folder
    LPIAB lpIAB;
    LPSBinary lpsbEID;      // EID of the folder
    LPWABFOLDER lpParentFolder; // Parent folder this folder will be associated with
    SBinary sbNew;          // returned new EID of new folder
} FINFO, * LPFINFO;

//$$
/* 
-   fnFolderDlgProc
-
*   Dialog proc for the Folder dialog
*
*/
INT_PTR CALLBACK fnFolderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPFINFO lpfi = (LPFINFO) lParam;
            LPTSTR lpsz = lpfi->lpsz;
            HWND hWndCheck = GetDlgItem(hDlg, IDC_FOLDER_CHECK_SHARE);
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) lpfi); //Save this for future reference
            SendMessage(GetDlgItem(hDlg,IDC_FOLDER_EDIT_NAME), EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-1,0);
            if(lpsz && lstrlen(lpsz))
                SetDlgItemText(hDlg, IDC_FOLDER_EDIT_NAME, lpsz);
            CheckDlgButton(hDlg, IDC_FOLDER_CHECK_SHARE, (lpfi->bIsShared ? BST_CHECKED : BST_UNCHECKED));
            if(lpfi->lpszOwnerName)
            {
                TCHAR sz[MAX_PATH];
                TCHAR szTmp[MAX_PATH], *lpszTmp;
                *sz = '\0';
                GetDlgItemText(hDlg, IDC_FOLDER_STATIC_CREATEDBY, sz, CharSizeOf(sz));
                if(sz && lstrlen(sz))
                {
                    LPTSTR lpsz = NULL;
                    CopyTruncate(szTmp, lpfi->lpszOwnerName, MAX_PATH - 1);
                    lpszTmp = szTmp;

                    if(FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    sz, 0, 0, (LPTSTR) &lpsz, 0, (va_list *)&lpszTmp))
                    {
                        SetDlgItemText(hDlg, IDC_FOLDER_STATIC_CREATEDBY, lpsz);
                        LocalFree(lpsz);
                        ShowWindow(GetDlgItem(hDlg, IDC_FOLDER_STATIC_CREATEDBY), SW_SHOWNORMAL);
                    }
                    
                }
            }
            if(lpfi->bIsReadOnly)
            {
                SendDlgItemMessage(hDlg, IDC_FOLDER_EDIT_NAME, EM_SETREADONLY, (WPARAM) TRUE, 0);
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                EnableWindow(hWndCheck, FALSE);
                SendMessage(hDlg, DM_SETDEFID, IDCANCEL, 0);
                SetFocus(GetDlgItem(hDlg,IDCANCEL));
            }
            else
                SetFocus(GetDlgItem(hDlg,IDC_FOLDER_EDIT_NAME));
            if(lpfi->bForceShared)
            {
                CheckDlgButton(hDlg, IDC_FOLDER_CHECK_SHARE, BST_CHECKED);
                EnableWindow(hWndCheck, FALSE);
            }
            if(!bDoesThisWABHaveAnyUsers(lpfi->lpIAB))
            {
                // there are no users configured so hide the sharing option
                EnableWindow(hWndCheck, FALSE);
                ShowWindow(hWndCheck, SW_HIDE);
            }


        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: 
            switch(LOWORD(wParam))
            { //update title as necessary
            case IDC_FOLDER_EDIT_NAME:
                {
                    TCHAR szBuf[MAX_UI_STR];
                    if(GetWindowText((HWND) lParam,szBuf,CharSizeOf(szBuf)))
	                    SetWindowPropertiesTitle(hDlg, szBuf);
                }
                break;
            }
            break;
        }
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            // Check that text is filled in
            {
                TCHAR sz[MAX_UI_STR];
                GetDlgItemText(hDlg, IDC_FOLDER_EDIT_NAME, sz, CharSizeOf(sz));
                if(!lstrlen(sz))
                {
                    ShowMessageBox(hDlg, idsAddFolderName, MB_ICONINFORMATION | MB_OK);
                    return FALSE;
                }
                else
                {
                    LPFINFO lpfi = (LPFINFO) GetWindowLongPtr(hDlg,DWLP_USER); 
                    LPTSTR lpsz = lpfi->lpsz;
                    HRESULT hr = S_OK;
                    BOOL bShared = IsDlgButtonChecked(hDlg, IDC_FOLDER_CHECK_SHARE);

                    if(lpfi->lpsbEID && sz) //existing entry
                    {
                        ULONG ulFlags = 0;
                        // Did the name change or sharing info changed
                        if(lstrcmp(sz, lpfi->lpszOldName)!=0)
                            ulFlags |= FOLDER_UPDATE_NAME;
                        if(lpfi->bIsShared!=bShared)
                            ulFlags |= FOLDER_UPDATE_SHARE;
                        
                        if(ulFlags)
                        {
                            if(!HR_FAILED(hr = HrUpdateFolderInfo(lpfi->lpIAB, lpfi->lpsbEID, ulFlags, bShared, sz)))
                            {
                                //reload the profiles so that this is updated
                                HrGetWABProfiles(lpfi->lpIAB);
                            }
                        }
                    }
                    else
                    {
                        // if we're here we have a valid folder name ..
                        hr = HrCreateNewFolder( lpfi->lpIAB, sz, 
                                                lstrlen(lpfi->lpIAB->szProfileID)?lpfi->lpIAB->szProfileID:NULL, 
                                                FALSE, lpfi->lpParentFolder, bShared, &lpfi->sbNew);
                    }
                    if(HR_FAILED(hr))
                    {
                        if(hr == MAPI_E_COLLISION)
                            ShowMessageBox(hDlg, idsEntryAlreadyInWAB, MB_ICONINFORMATION | MB_OK);
                        else
                            ShowMessageBox(hDlg, idsCouldNotSelectUser, MB_ICONEXCLAMATION | MB_OK);
                        return FALSE;
                    }

                }
            }
            EndDialog(hDlg, IDOK);
            break;
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        }
        break;
    }

    return FALSE;
}

/*
-   HrFolderProperties 
-
*   if FolderEID is NULL,    
*   Creates a newfolder, adds it to the current profile, updates the UI
*   in TreeView and in the View | Folders menu ...
*   else opens properties on the folder so user can change the name
*   if desired
*
*   lpsbEID - NULL if creating a new folder else EID of folder to view
*   lpParentFolder - User folder under which this is being created
*   lpsbnew - return EID of newly created folder
*/
HRESULT HrFolderProperties(HWND hWndParent, LPIAB lpIAB, LPSBinary lpsbEID, 
                           LPWABFOLDER lpParentFolder, LPSBinary lpsbNew)
{

    HRESULT hr = S_OK;
    int nRetVal;
    TCHAR sz[MAX_UI_STR];
    LPTSTR lpsz = NULL;
    FINFO fi = {0};

    fi.lpszOwnerName = NULL;

    *sz = '\0';
    if(lpsbEID)
    {
        LPWABFOLDER lpFolder  = FindWABFolder(lpIAB, lpsbEID, NULL, NULL);
        if( (!lpsbEID->cb && !lpsbEID->lpb) )
            fi.bIsShared = TRUE;
        if( (!lpsbEID->cb && !lpsbEID->lpb) ||
            (lpFolder && lpFolder->lpProfileID && lstrlen(lpFolder->lpProfileID)) )
            fi.bIsReadOnly = TRUE;
        if(lpFolder)
        {
            lstrcpy(sz, lpFolder->lpFolderName);
            fi.lpszOldName = lpFolder->lpFolderName;
            fi.bIsShared = lpFolder->bShared;
            fi.lpszOwnerName = lpFolder->lpFolderOwner;
        }
        else
        {
            LoadString(hinstMapiX, idsSharedContacts/*idsAllContacts*/, sz, CharSizeOf(sz));
        }
    }
    else
    {
        // this is a new folder ..
        // if it doesn't have a parent and userfolders are already configured then it's being created
        // in the shared folders in which case we should force the shared-folder option
        if(bDoesThisWABHaveAnyUsers(lpIAB) && !lpParentFolder)
            fi.bForceShared = TRUE;
    }
    fi.lpsz = sz;
    fi.lpIAB = lpIAB;
    fi.lpsbEID  = lpsbEID;
    fi.lpParentFolder = lpParentFolder;

    nRetVal = (int) DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_FOLDER),
		                     hWndParent, (DLGPROC) fnFolderDlgProc, (LPARAM) &fi);
    if(nRetVal == IDCANCEL)
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    if(lpsbNew)
        SetSBinary(lpsbNew, fi.sbNew.cb, fi.sbNew.lpb);
out:
    LocalFreeAndNull((LPVOID *) (&fi.sbNew.lpb));
    return hr;
}


/*
-   UpdateLV
-
*   Refreshes the list view based on the current selection
*
*/
void UpdateLV(LPBWI lpbwi)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;
    bwi_hti = NULL;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    UpdateListViewContents(lpbwi, lpsbEID, ulObjectType);
    LocalFreeSBinary(lpsbEID);
    bwi_bDeferNotification = TRUE;
}

#ifdef COLSEL_MENU 
/**
This function will update the listview and write the selected custom column selections out
to the registry.
*/
BOOL UpdateOptionalColumns( LPBWI lpbwi, ULONG iColumn )
{
    LVCOLUMN lvCol = {0}; 
    HKEY hKey = NULL;
    LPTSTR lpszColTitle = (iColumn == colHomePhone ) ? szCustomProp1 : szCustomProp2;        
    ULONG ulProp = (iColumn == colHomePhone ) ? PR_WAB_CUSTOMPROP1 : PR_WAB_CUSTOMPROP2;
    DWORD cbProp = 0;
    LPIAB lpIAB = bwi_lpIAB;
    HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD dwDisposition = 0;
    BOOL fRet = FALSE;
    TCHAR szBuf[MAX_PATH];

    if( iColumn != colHomePhone && iColumn != colOfficePhone )
        goto exit;

    LoadString(hinstMapiX, lprgAddrBookColHeaderIDs[iColumn], szBuf, CharSizeOf(szBuf));
    lvCol.mask = LVCF_TEXT;
    lvCol.pszText = (lpszColTitle && lstrlen(lpszColTitle))? lpszColTitle : szBuf;
    if( !ListView_SetColumn( bwi_hWndListAB, iColumn, &lvCol ) )
    {
        DebugTrace( TEXT("could not setcolumntext: %x\n"), GetLastError() );
        goto exit;
    }
    if(ulProp)
    {
        // begin registry stuff
        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot, lpNewWABRegKey, 0,      //reserved
                                            NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                            NULL, &hKey, &dwDisposition))
        {
            goto exit;
        }
        cbProp = sizeof( ULONG );
        if(ERROR_SUCCESS != RegSetValueEx(  hKey, 
                                            (iColumn == colHomePhone ? szPropTag1 : szPropTag2), 
                                            0, REG_DWORD, (LPBYTE)&ulProp, cbProp))
            goto exit;
    }
    fRet = TRUE;
exit:
    if(hKey)
        RegCloseKey(hKey);
    return fRet;
}

#endif // COLSEL_MENU 


/*
-   HrExportWAB
-
*   Supposed to export data out of the .WAB into another .wab file.
*   Ideally, user should be able to specify an existing WAB file and  TEXT("push") data
*   into that file from this file.
*   Instead, we do a cheesy implementation here where we let the user specify a file name to
*   create and we then just copy the current .WAB file to the new file name
*   
*   Obviously this method doesn't work when WAB is sharing the Outlook store and in that
*   case we remove this option from the Menu
*
*/
extern BOOL PromptForWABFile(HWND hWnd, LPTSTR szFile, BOOL bOpen);

HRESULT HrExportWAB(HWND hWnd, LPBWI lpbwi)
{
    HRESULT hr = E_FAIL;
    TCHAR szFile[MAX_PATH];
    HCURSOR hOldC = NULL;

    if(!PromptForWABFile(hWnd, szFile, FALSE))
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    //Check if file already exists ..
    if(0xFFFFFFFF != GetFileAttributes(szFile))
    {
        // Ask user if they want to overwrite
        if(IDNO == ShowMessageBoxParam(hWnd,
                                    IDE_VCARD_EXPORT_FILE_EXISTS,
                                    MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND,
                                    szFile))
        {
            hr = MAPI_E_USER_CANCEL;
            goto out;
        }
    }
    
    hOldC = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Still here, means go ahead and copy the current .wab file to the new place ...
    if(!CopyFile(GetWABFileName(bwi_lpIAB->lpPropertyStore->hPropertyStore,FALSE), szFile, FALSE))
    {
        DebugTrace( TEXT("WAB File export failed: %d\n"), GetLastError());
        goto out;
    }

    if(hOldC)
    {
        SetCursor(hOldC);
        hOldC = NULL;
    }
    ShowMessageBoxParam(hWnd, idsWABExportSuccess, MB_OK | MB_ICONEXCLAMATION, szFile);

    hr = S_OK;
out:
    if(HR_FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
        ShowMessageBox(hWnd, idsExportError, MB_OK | MB_ICONEXCLAMATION);

    if(hOldC)
        SetCursor(hOldC);
    return hr;
}



void DestroyImageLists(LPBWI lpbwi)
{
    HIMAGELIST  hImageList;

    if (NULL == gpfnImageList_Destroy)
        return;

    if (IsWindow(bwi_hWndTools))
    {
        // Destroy Image Lists created in ui_clbar.cpp's InitToolbar()
        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);

        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETHOTIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);

        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETDISABLEDIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);
    }

    if (IsWindow(bwi_hWndTV))
    {
        // Destroy Image Lists created in ui_abook.c's InitChildren()
        hImageList = TreeView_GetImageList (bwi_hWndTV, TVSIL_NORMAL);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\uimisc.h ===
////////////////////////////////////////////////////////////////////////////////
//
//	UIMISC.H - header for common miscellaneous functions used by the UI
//
//
////////////////////////////////////////////////////////////////////////////////
#ifndef __UIMISC_H_
#define __UIMISC_H_

#define IDC_TREEVIEW            9010 //These should really be in resource.h
#define IDC_SPLITTER            9011

#define TOOLTIP

#define MAX_DISPLAY_NAME_LENGTH 32
#define MAX_UI_STR              200
#define MAX_BUF_STR             4*MAX_UI_STR

#ifndef WIN16
static LPTSTR g_szWABHelpFileName = TEXT("WAB.HLP");
#else
static LPTSTR g_szWABHelpFileName = TEXT("WAB16.HLP");
#endif
extern const LPTSTR szInternetCallKey;
extern const LPTSTR szCallto;
extern const LPTSTR szCRLF;
extern const LPTSTR szColon;
extern const LPTSTR szTrailingDots;
extern const LPTSTR szArrow;
extern const LPTSTR szBackSlash;


#define IDC_BB_NEW      		8080
#define IDC_BB_PROPERTIES		8082
#define IDC_BB_DELETE			8083
#define IDC_BB_FIND				8084
#define IDC_BB_PRINT            8085
#define IDC_BB_ACTION           8086
#define IDC_BB_ADD_TO_ADDRBOOK  8087

// This should not be an enumeration as tbPrint can drop out at
// run-time.  Be very careful if you change the order of this
// enumeration - search for all uses of these enumerated values
// first.  There is code in ui_abook.c which relies on tbPrint
// being in front of tbAction.
enum _Toolbar
{
    tbNew=0,
    tbProperties,
    tbDelete,
    tbFind,
    tbPrint,
    tbAction, //upto this many on the toolbar
    tbAddToWAB,
    tbCopy,   //these on the context menu
    tbPaste,
    tbNewEntry,
    tbNewGroup,
    tbNewFolder,
    tbMAX
};

enum _AddressModalDialogState // Used in various forms of modal IAB_ADDRESS dialogs
{
    STATE_SELECT_RECIPIENTS = 0,
    STATE_PICK_USER,
    STATE_BROWSE,
    STATE_BROWSE_MODAL
};

// Returned values from our Search Dialog Proc
enum _SearchDialogReturnValues
{
    SEARCH_CANCEL=0,
    SEARCH_OK,
    SEARCH_ERROR,
	SEARCH_CLOSE,
	SEARCH_USE
};


//#define VCARD

// **** Keep this enum below in sync with the Main menu structure in CoolUI.RC
enum _MainMenuSubMenus
{
    idmFile = 0,
    idmEdit,
    idmView,
    idmTools,
    idmHelp
};

enum _FileMenu
{
    idmNewContact = 0,
    idmNewGroup,
    idmNewFolder,
    idmFSep1,
    idmProperties,
    idmDelete,
    idmFSep2,
    idmImport,
    idmExport,
    idmFSep3,
    idmPrint,
    idmFSep4,
#ifdef FUTURE
    idmFolders,
    idmSepFolders,
#endif
    idmSwitchUsers,
    idmAllContents,
    idmFSep5,
    idmClose,
    idmFileMax,
};

enum _EditMenu
{
    idmCopy=0,
    idmPaste,
    idmESep1,
    idmSelectAll,
    idmESep2,
//    idmProfile,
//    idmESep3,
    idmFindPeople,
};

enum _ViewMenus
{
    idmToolBar=0,
    idmStatusBar,
	idmGroupsList,
    idmSepUI,
    idmLargeIcon,
    idmSmallIcon,
    idmList,
    idmDetails,
    idmSepListStyle,
    idmSortBy,
    idmSepSort,
    idmRefresh,
    idmViewMax,
};

enum _ToolsMenus
{
    idmAccounts=0,
    idmSepAccounts,
    idmOptions,
    idsSepOptions,
    idmAction,
};

#define WAB_ONEOFF_NOADDBUTTON  0x00000080 // Flag used to surpress AddToWABButton in iAddrBook::Details


#ifdef HM_GROUP_SYNCING
// [PaulHi] Private message to begin a second group synchronization pass to main UI thread
#define WM_USER_SYNCGROUPS WM_USER+102
#endif


// Private message we send to our toolbar container so it can forward it to
// the toolbar.
#define WM_PRVATETOOLBARENABLE WM_USER+101
//////////////////////////////////////////////////////////////////////////////
//
// IMPORTANT NOTE: If you change this, you must change lprgAddrBookColHeaderIDs in
//   globals.c!
//
enum _AddrBookColumns
{
        colDisplayName=0,
        colEmailAddress,
		colOfficePhone,
		colHomePhone,
        NUM_COLUMNS
 };

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used for storing the address book position and column sizes
// in the registry for persistence
//
typedef struct _AddressBookPosColSize
{
    RECT rcPos;
    int nColWidth[NUM_COLUMNS];
    BOOL bViewToolbar;
    DWORD dwListViewStyle;
    int nListViewStyleMenuID;
    BOOL bViewStatusBar;
    int colOrderArray[NUM_COLUMNS];
    BOOL bViewGroupList;
    int nTab;
    int nTViewWidth;
} ABOOK_POSCOLSIZE, * LPABOOK_POSCOLSIZE;
//////////////////////////////////////////////////////////////////////////////


extern const TCHAR *g_rgszAdvancedFindAttrs[];


/////////////////////////////////////////////////////////////////////////////
// This represents all the listview boxes in the UI
// Using these tags we can customize the context sensitive menus
// in one sub routine saving code duplication ...
/////////////////////////////////////////////////////////////////////////////
enum _AllTheListViewBoxes
{
	lvMainABView = 0,
	lvDialogABContents,         // Modeless address view LV
	lvDialogModalABContents,    // Modal addres vuew LV
	lvDialogABTo,               // To Well LV
	lvDialogABCC,               // CC Well LV
	lvDialogABBCC,              // BCC Well LV
	lvDialogDistList,           // Disttribution list UI LV
	lvDialogResolve,            // Resolve dialog LV
    lvDialogFind,               // Find dialog results LV
	lvMainABTV,					// TreeView in main AB
    lvToolBarAction,
    lvToolBarNewEntry,
#ifdef COLSEL_MENU 
    lvMainABHeader,             // column selection viewin main AB
#endif // COLSEL_MENU 

};


/////////////////////////////////////////////////////////////////////////////
// These are indexes into the bitmaps to show the little bitmap
// next to each entry - this has to be synchronized with the bmps
/////////////////////////////////////////////////////////////////////////////
enum _ListViewImages
{
	imageMailUser=0, //Common to small and large imagelists
	imageDistList,
	imageSortDescending,
	imageSortAscending,
    imageDirectoryServer,
    imageUnknown,
    imageMailUserLDAP,
    imageAddressBook,
    imageMailUserWithCert,
    imageMailUserMe,
    imageFolderClosed,
    imageFolderOpen,
    imageMailUserOneOff,
	imageMax
};

//
// cellwidth of LV image lists
//
#define S_BITMAP_WIDTH 16
#define S_BITMAP_HEIGHT 16
#define L_BITMAP_WIDTH 32

#define RGB_TRANSPARENT (COLORREF)0x00FF00FF

//
// UI control spacing - TBD confirm these numbers
//
#define BORDER 3 //pixels
#define CONTROL_SPACING 3


// UI Refresh timer defines
#define WAB_REFRESH_TIMER   14     // timer identifier
#define WAB_REFRESH_TIMEOUT 4000   // time-out value - 4 seconds


/////////////////////////////////////////////////////////////////////////////
// LDAP_SEARCH_PARAMS - specifies parameters for LDAP searches
/////////////////////////////////////////////////////////////////////////////
enum _LDAPSearch
{
    ldspDisplayName,
    ldspEmail,
    ldspAddress,
    ldspPhone,
    ldspOther,
    ldspMAX
};

typedef struct _LDAPSearchParams
{
    LPADRBOOK lpIAB;
    TCHAR szContainerName[MAX_UI_STR];
    TCHAR szData[ldspMAX][MAX_UI_STR];
    BOOL bUseOtherBase;
} LDAP_SEARCH_PARAMS, * LPLDAP_SEARCH_PARAMS;




/////////////////////////////////////////////////////////////////////////////
// Stores info about each entry in the list view control
// Each entry in the list view controls has 1 structure corresponding to that
// entry
/////////////////////////////////////////////////////////////////////////////
typedef struct _RecipientInfo
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
    TCHAR       szDisplayName[MAX_DISPLAY_NAME_LENGTH];//The actual text that is displayed
//    LPTSTR      szDisplayName;
    TCHAR       szEmailAddress[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szHomePhone[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szOfficePhone[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szByLastName[MAX_DISPLAY_NAME_LENGTH]; // Stores the text preloaded by last name first
    TCHAR       szByFirstName[MAX_DISPLAY_NAME_LENGTH];// Stores preloaded DisplayName
    ULONG       ulRecipientType;
    ULONG       ulObjectType;
    BOOL        bHasCert;
    BOOL        bIsMe;
    ULONG       ulOldAdrListEntryNumber; //if this was an element passed into the Address lpAdrList
                                        //we store its original AdrList index here so that we dont
                                        //have to do inefficient searches later ...
                                        // ***VERY IMPORTANT*** Legal values range from 1 to AdrList->cValues (not from 0)
    LPTSTR      lpByRubyFirstName;
    LPTSTR      lpByRubyLastName;
    struct _RecipientInfo * lpNext;
    struct _RecipientInfo * lpPrev;
} RECIPIENT_INFO, * LPRECIPIENT_INFO;



//////////////////////////////////////////////////////////////////////////////
// Hack structure used for talking between the Find dialog and the select
// recipients dialog
//////////////////////////////////////////////////////////////////////////////
typedef struct _AdrParmFindInfo
{
    LPADRPARM lpAdrParms;
    LPRECIPIENT_INFO * lppTo;
    LPRECIPIENT_INFO * lppCC;
    LPRECIPIENT_INFO * lppBCC;
	int DialogState;	// identifies where it was called from
	int nRetVal;		// return code identifies what action closed the dialog
	LPENTRYID lpEntryID;
	ULONG cbEntryID;
} ADRPARM_FINDINFO, * LPADRPARM_FINDINFO;
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// A structure that will contain the LDAP URL subparts ...
typedef struct _LDAPURL
{
    LPTSTR   lpszServer;     // Server name
    LPTSTR   lpszBase;       // Base <dn>
    LPTSTR * ppszAttrib;     // Attributes requested
    ULONG   ulAttribCount;  //
    ULONG   ulScope;        // Search scope
    LPTSTR   lpszFilter;     // search filter
    LPTSTR   lpszExtension;  // And extension part of the URL
    LPTSTR   lpszBindName;   // A bindname extension for the URL
    BOOL    bServerOnly;    // Only found a server entry
    DWORD   dwAuthType;     // Authentication Type
    LPRECIPIENT_INFO lpList;// used to cache multple query results
} LDAPURL, * LPLDAPURL;
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// This structure holds information about
// the sort order of a particular list view
/////////////////////////////////////////////////////////////////////////////
typedef struct _SortInfo
{
    int iOldSortCol;
	int iOlderSortCol;
    BOOL bSortAscending;
    BOOL bSortByLastName;
} SORT_INFO, *LPSORT_INFO;


/////////////////////////////////////////////////////////////////////////////
// We will subclass some of the child controls on the main Address Book View to
// enable tabbing between the controls - the following
// are used in this subclassing
/////////////////////////////////////////////////////////////////////////////
enum _SubClassedControlIndexs
{
	s_EditQF=0,
	s_ListAB,
	s_TV,
	s_Max
};

typedef struct _ToolTipInfo
{
    int iItem;
    BOOL bActive;
    TCHAR szTipText[MAX_BUF_STR];
    UINT_PTR uTooltipTimer;
    BOOL bShowTooltip;
} TOOLTIP_INFO, * LPTOOLTIPINFO;

typedef struct _TVItemStuff
{
    ULONG ulObjectType;
    LPSBinary lpsbEID;
    LPSBinary lpsbParent;
    HTREEITEM hItemParent;
} TVITEM_STUFF, * LPTVITEM_STUFF;


// There may be several property sheets in the final version of the details pane
// Each list will have a seperate set of controls corresponding to different properties
// We want to retrieve the control values and map them into a property-array
// Each dialog will create its own proparray on exiting. The original record will also
// have some properties that never got mapped in the first place and some which may have been
// deleted thru the ui. Hence we look at the old array and the new array and create a merged
// list of props ... all mapped props in the new arrays superscede props in the
// old array

enum _PropSheets{   propSummary = 0,
                    propPersonal,   // a list of all the property sheets on this page
                    propHome,
                    propBusiness,
                    propNotes,
                    propConferencing,
                    propCert,
                    propOrg,
                    propTrident,
                    propFamily,
                    TOTAL_PROP_SHEETS
                };

enum _DLPropSheets{ propGroup = 0,
                    propGroupOther,
                    propDLMax
                    };

enum _DetailsDialogReturnValues
{
    DETAILS_RESET = 0, //blank return value
    DETAILS_OK,
    DETAILS_CANCEL,
    DETAILS_ADDTOWAB
};

enum
{
    contactHome=0,
    contactBusiness,
    groupOther,
    contactPersonal,
};



//////////////////////////////////////////////////////////////////////////////
//
// The PropArrayInfo is used by the property sheets displaying details on 
// contacts or groups
//
//////////////////////////////////////////////////////////////////////////////
// Misc flags used here
#define DETAILS_DNisCompanyName     0x00000001
#define DETAILS_DNisNickName        0x00000002
#define DETAILS_DNisFMLName         0x00000004
#define DETAILS_UseRubyPersonal     0x00000008 //  Determines if the displayed prop sheet is a RUBY one for Japan/China/Korea
#define DETAILS_Initializing        0x00000010 //  Prevents WM_COMMAND triggers during initialization
#define DETAILS_ProgChange          0x00000020 //  Diffrentiates between changes in Display Name caused by user and by other parts of the code
#define DETAILS_EditingEmail        0x00000040 //  So we can abort the email editing if user cancels
#define DETAILS_HideAddToWABButton  0x00000080 // Hides the add-to-wab button for some one-offs
#define DETAILS_ShowCerts           0x00000100 //  Decides whether or not to show certs UI
#define DETAILS_ShowTrident         0x00000200 //  Decides whether or not to show Trident in UI
#define DETAILS_ShowNetMeeting      0x00000400 //  Decides whether or not to show Netmeeting stuff
#define DETAILS_ShowOrg             0x00000800 //  Decides whether or not to show Org UI
#define DETAILS_EditingConf         0x00001000 //  Tracks if editing a server/email pair
#define DETAILS_ShowSummary         0x00002000 //  Decides whether or not to present summary information
#define DETAILS_EditingOneOff       0x00004000 //  Tracks if editing a group one-off
#define DETAILS_DefHomeChanged      0x00008000 //  Used to track changes in non-Edit controls on the Home prop sheets
#define DETAILS_DefBusChanged       0x00010000 //  Used to track changes in non-Edit controls on the Business prop sheets
#define DETAILS_GenderChanged       0x00020000 //  Used to track changes in Gender
#define DETAILS_DateChanged         0x00040000 //  Used to track changes in Date-Time fields
#define DETAILS_ChildrenChanged     0x00080000 //  Used to track changes in PR_CHILDRENS_NAMES
#define DETAILS_EditingChild        0x00100000 //  Tracks if we're in the middle of editing a children name

typedef struct _PropArrayInfo
{
    ULONG   cbEntryID;              // Entryid of this item
    LPENTRYID lpEntryID;
    ULONG   ulOperationType;        // SHOW_DETAILS or SHOW_NEW_ENTRY
    ULONG   ulObjectType;           // MAILUSER or DISTLIST
    LPMAPIPROP lpPropObj;           // Actual object we are displaying
    int     nRetVal;
    BOOL    bSomethingChanged;          //  flags changes so we dont waste processing
    BOOL    bPropSheetOpened[TOTAL_PROP_SHEETS];
    ULONG   ulFlags;
    HWND    hWndDisplayNameField;       //  Holds HWND of DN edit field
    int     ulTridentPageIndex;         //  index of the trident sheet in case we need to remove it
    LPADRBOOK lpIAB;
    LPIWABDOCHOST lpIWABDocHost;
    int     nDefaultServerIndex;
    int     nBackupServerIndex;
    LPTSTR  szDefaultServerName;        //  LocalAlloc storage for these and then free them later ..
    LPTSTR  szBackupServerName;
    int     nConfEditIndex;
    SBinary sbDLEditingOneOff;
    HWND    hWndComboConf;
    LPRECIPIENT_INFO lpContentsList;    //  Used by groups only for member lists
    LPCERT_ITEM lpCItem;                //  Keeps a list of all our cert items ...
    int nPropSheetPages;                //  Total number of propsheets for this item
    HPROPSHEETPAGE * lphpages;          //  An array of all the prop sheets created for this item
    LPWABEXTDISPLAY lpWED;              //  Stores info about extended prop sheets
    LPEXTDLLINFO lpExtList;             //  List of shell extension objects
    LPTSTR  lpLDAPURL;                  //  Points to the LDAP URL, if any, being displayed
    BOOL    bIsNTDSURL;                   //  True if the LDAP URL represents an object from an NTDS
    LPTSTR  lpszOldName;                //  used for caching the old name of the prop being displayed
    int nNTDSPropSheetPages;            //  Tracks the number of NTDS PropSheet extensions
    HPROPSHEETPAGE * lphNTDSpages;      //  We cache the NTDS extension prop pages seperately since we may need to replace out own pages with these
    GUID    guidExt;                    // Used while creating prop sheet extensions for identifying the appropriate extension
} PROP_ARRAY_INFO, * LPPROP_ARRAY_INFO;

#define DL_INFO PROP_ARRAY_INFO 
#define LPDL_INFO LPPROP_ARRAY_INFO

//
// The following structure is used to cache various data associated with the
// main browse UI for the WAB
//
typedef struct _tabBrowseWindowInfo
{
    // Following are used in ui_abook.c in the main ui
    HWND        hWndListAB;        //  Handle of main list view
    HWND        hWndBB;            //  Handle of Button Bar
    HWND        hWndEditQF;
    HWND        hWndStaticQF;
    HWND        hWndAB;            //  Handle of the Address Book Window
    HWND        hWndSB;            //  Status bar
    int         iFocus;            //  Tracks who has the focus
    LPRECIPIENT_INFO lpContentsList;
    LPADRBOOK   lpAdrBook;      //  Hangs on to AdrBook object
    LPIAB       lpIAB;          //  Internal version of AdrBook object
    WNDPROC     fnOldProc[s_Max]; // Subclass some of the control procs
    HWND	    s_hWnd[s_Max];  //  HWNDS of subclasses controls
    LPFNDISMISS lpfnDismiss;//  Context for dismissing in the case of modeless IAdrBook window
    LPVOID      lpvDismissContext;  // Dismiss context as above
    HWND        hWndTools;           // handle of the toolbar window
    SORT_INFO   SortInfo;   //  Sort Info
#ifdef TOOLBAR_BACK
    HBITMAP     hbmBack;          // handle of the toolbar background
    HPALETTE    hpalBkgnd;       // handle of the toolbar background palette
#endif
    HWND        hWndTT;        // Tooltip control info in ui_abook.c
    TOOLTIP_INFO tti;
    BOOL        bDoQuickFilter;
    // bobn: brianv says we have to take this out...
    //int         nCount;
    // Used to override automatic notification-fueled refreshes
    BOOL        bDontRefreshLV;
    // Related to Treeview in ui_Abook.c
    HWND        hWndTV;
    HWND        hWndSplitter;
    // Related to drag and drop
    LPIWABDRAGDROP lpIWABDragDrop;
    // Related to Notifications and updates
    LPMAPIADVISESINK lpAdviseSink;
    ULONG       ulAdviseConnection;

    BOOL        bDeferNotification; // Used to defer next notification request

    HTREEITEM   hti; //used for caching rt-click items for treeview

    LPWABFOLDER lpUserFolder;           //  Used only to mark the User-Folder being rt-clicked
#ifdef COLSEL_MENU 
    ULONG       iSelColumn;             //  Used for Column Selection caching
#endif
} BWI, * LPBWI;

#define bwi_lpUserFolder     lpbwi->lpUserFolder
#define bwi_hti              lpbwi->hti
#define bwi_hWndListAB       lpbwi->hWndListAB
#define bwi_hWndBB           lpbwi->hWndBB
#define bwi_hWndSB           lpbwi->hWndSB
#define bwi_bDoQuickFilter   lpbwi->bDoQuickFilter
// bobn: brianv says we have to take this out...
//#define bwi_nCount           lpbwi->nCount
#define bwi_bDeferNotification  lpbwi->bDeferNotification

#define bwi_SortInfo         lpbwi->SortInfo

#define bwi_hWndTT           lpbwi->hWndTT
#define bwi_tt_iItem         ((lpbwi->tti).iItem)
#define bwi_tt_bActive       lpbwi->tti.bActive
#define bwi_tt_szTipText     ((lpbwi->tti).szTipText)
#define bwi_tt_TooltipTimer  ((lpbwi->tti).uTooltipTimer)
#define bwi_tt_bShowTooltip  ((lpbwi->tti).bShowTooltip)

#define bwi_hWndTV           (lpbwi->hWndTV)
#define bwi_hWndSplitter      (lpbwi->hWndSplitter)

#define bwi_hWndEditQF       lpbwi->hWndEditQF
#define bwi_hWndStaticQF     lpbwi->hWndStaticQF
#define bwi_hWndAB           lpbwi->hWndAB
#define bwi_iFocus           lpbwi->iFocus
#define bwi_lpIAB            (lpbwi->lpIAB)
#define bwi_lpAdrBook        (lpbwi->lpAdrBook)
#define bwi_fnOldProc        (lpbwi->fnOldProc)
#define bwi_s_hWnd           (lpbwi->s_hWnd)
#define bwi_lpContentsList   (lpbwi->lpContentsList)
#define bwi_lpfnDismiss      (lpbwi->lpfnDismiss)
#define bwi_lpvDismissContext (lpbwi->lpvDismissContext)

#define bwi_hWndTools         (lpbwi->hWndTools)

#ifdef TOOLBAR_BACK
#define bwi_hbmBack           (lpbwi->hbmBack)
#define bwi_hpalBkgnd         (lpbwi->hpalBkgnd)
#endif

#define bwi_bDontRefreshLV   (lpbwi->bDontRefreshLV)
#define bwi_lpIWABDragDrop   (lpbwi->lpIWABDragDrop)

#define bwi_lpAdviseSink     (lpbwi->lpAdviseSink)
#define bwi_ulAdviseConnection (lpbwi->ulAdviseConnection)

/////////////////////////////////////////////////////////////////////////////
// Each thread can generate a different Address Book window .. need to
// keep the data thread safe ...
/////////////////////////////////////////////////////////////////////////////
typedef struct _tagPerThreadGlobalData
{
    // Persistent search params
    LDAP_SEARCH_PARAMS LDAPsp;// Search parameters for LDAP

    LPADRBOOK lpIAB;
    HACCEL hAccTable;       //  Accelerator TAble

    HWND hWndFind;      // hWnd of Find dialog so LDAP cancel dialog has a parent
    HWND hDlgCancel;    // hWnd of the Cancel dialog
    BOOL bDontShowCancel;   // Dont show the cancel dialog when the find is launched ...

    // Used in print dialog
    BOOL bPrintUserAbort;
    HWND hWndPrintAbortDlg;

    // Tracks if this is an OpenExSession
    BOOL bIsWABOpenExSession;
    BOOL bIsUnicodeOutlook;     // Tracks if this WAB supports Unicode in which case we don't need to do Unicode conversions for it

#ifdef HM_GROUP_SYNCING
    LPTSTR lptszHMAccountId;    // Keeps Hotmail syncing account ID across two synchronization passes.
#endif

    BOOL bDisableParent;
    
    // Tracks first run for Directory Service modification
    BOOL bFirstRun;

    // Default Platform/Dialog Font
    HFONT hDefFont;
    HFONT hDlgFont;

    // Caches a cookie for LDAP paged results
    struct berval *   pCookie;

} PTGDATA, * LPPTGDATA;

#define pt_hDefFont         (lpPTGData->hDefFont)
#define pt_hDlgFont         (lpPTGData->hDlgFont)
#define pt_pCookie          (lpPTGData->pCookie)
#define pt_LDAPsp           (lpPTGData->LDAPsp)

#define pt_hWndFind         lpPTGData->hWndFind
#define pt_hDlgCancel       lpPTGData->hDlgCancel
#define pt_bDontShowCancel  lpPTGData->bDontShowCancel

#define pt_bPrintUserAbort  (lpPTGData->bPrintUserAbort)
#define pt_hWndPrintAbortDlg    (lpPTGData->hWndPrintAbortDlg)

#define pt_bIsWABOpenExSession (lpPTGData->bIsWABOpenExSession)
#define pt_bIsUnicodeOutlook        (lpPTGData->bIsUnicodeOutlook)

#define pt_bDisableParent   (lpPTGData->bDisableParent)

#define pt_bFirstRun        (lpPTGData->bFirstRun)

#define pt_lpIAB            (lpPTGData->lpIAB)
#define pt_hAccTable        (lpPTGData->hAccTable)

// This is a global
DWORD dwTlsIndex;                      // index for private thread storage


// for COLSEL_MENU stuff
#ifdef COLSEL_MENU
extern const ULONG MenuToPropTagMap[];
#endif // COLSEL_MENU

/**** MISC UI FUNCTIONS ****/

// Gets a threads storage pointer or creates a new one if none found
LPPTGDATA __fastcall GetThreadStoragePointer();

//This function frees up RECIPIENT_INFO structures
void FreeRecipItem(LPRECIPIENT_INFO * lppItem);


// This function loads a string and allocates space for it.
LPTSTR LoadAllocString(int StringID);


// This function initializes a list view
HRESULT HrInitListView(	HWND hWndLV,			// List view hWnd
						DWORD dwStyle,			// Style
						BOOL bShowHeaders);		// Hide or show column headers


// This function fills a list view from a contents list
HRESULT HrFillListView(	HWND hWndLV,			
						LPRECIPIENT_INFO lpContentsList);


// Call to create main view to address book
HWND hCreateAddressBookWindow(	LPADRBOOK lpIAB,	
								HWND hWndParent,
								LPADRPARM lpszCaption);


// Creates a ContentsList from the property store
HRESULT HrGetWABContentsList(   LPIAB lpIAB, 
                                SORT_INFO SortInfo,
								LPSPropTagArray  lpPTA,
								LPSPropertyRestriction lpPropRes,
								ULONG ulFlags,
                                LPSBinary lpsbContainer,
                                BOOL bGetProfileContents,
                                LPRECIPIENT_INFO * lppContentsList);


#define LDAP_USE_ADVANCED_FILTER 0x04000000 // completely made up flag
                                            // for passing a advanced filter 
                                            // to the LDAP_FindRow
// Creates ContentsList from an LDAP container
HRESULT HrGetLDAPContentsList(  LPADRBOOK lpIAB,
                                ULONG   cbContainerEID,
                                LPENTRYID   lpContainerEID,
                                SORT_INFO SortInfo,
	                            LPSRestriction lpPropRes,
                                LPTSTR lpAdvFilter,
								LPSPropTagArray  lpPTA,
                                ULONG ulFlags,
                                LPRECIPIENT_INFO * lppContentsList);

// Trims leading and trailing spaces from strings
BOOL TrimSpaces(TCHAR * szBuf);


// Sort Call Back funciton for list views
int CALLBACK ListViewSort(	LPARAM lParam1,
							LPARAM lParam2,
							LPARAM lParamSort);


// Retrieves the HWND for a list view column header
//HWND GetListViewColumnHeader(HWND hWndLV, DWORD dwPos);


// Paints bmps onto list view column headers
void SetColumnHeaderBmp(	HWND hWndLV,
							SORT_INFO SortInfo);

// Returns TRUE if the current viewed container is the PAB
BOOL CurrentContainerIsPAB(HWND hWndCombo);

// Cleans up the list view and releases the contents list
void ClearListView(	HWND hWndLV,
					LPRECIPIENT_INFO * lppContentsList);


// Deletes the selected items from a list view control and the property store
void DeleteSelectedItems(	HWND hWndLV,
                            LPADRBOOK lpIAB,
							HANDLE hPropertyStore,
                           LPFILETIME lpftLast);


// Calls properties on a list view item
HRESULT HrShowLVEntryProperties(	HWND hWndLV,
                                    ULONG ulFlags,
									LPADRBOOK lpIAB,
                                   LPFILETIME lpftLast);


// Exports list view items to vCard files
HRESULT VCardExportSelectedItems(HWND hWndLV,
                                 LPADRBOOK lpIAB);


// Imports vCard file to property store
HRESULT VCardImport(HWND hWnd, LPADRBOOK lpIAB, LPTSTR szVCardFile, LPSPropValue * lppProp);


// Selects the specified list view item
void LVSelectItem(	HWND hWndList,
					int iItemIndex);


//	Given an entryid, reads a single item from the store and creates a list view item
BOOL ReadSingleContentItem( LPADRBOOK lpIAB,
                            ULONG  cbEntryID,
							LPENTRYID lpEntryID,
							LPRECIPIENT_INFO * lppItem);


// Converts an lpPropArray into a LPRECIPIENT_INFO item
void GetRecipItemFromPropArray(	ULONG ulcPropCount,
								LPSPropValue rgPropVals,
								LPRECIPIENT_INFO * lppItem);


// Inserts a single RecipientInfo item into a list view
void AddSingleItemToListView(	HWND hWndLV,
								LPRECIPIENT_INFO lpItem);


// Higher level function that takes a WAB entryid and puts it in the list view
// Calls most of the above functions (this function assumes caller has checked that
// the entryid is a valid wab entryid
BOOL AddWABEntryToListView(	LPADRBOOK lpIAB,
                            HWND hWndLV,
                            ULONG cbEID,
							LPENTRYID lpEID,
                            LPRECIPIENT_INFO * lppContentsList);


// Called by the NewContact menu items or buttons
HRESULT AddNewObjectToListViewEx(	LPADRBOOK lpIAB,
								HWND hWndLV,
                                HWND hWndTV,
                                HTREEITEM hSelItem,
                                LPSBinary lpsbContEID,
                                ULONG ulObjectType,
								SORT_INFO * lpSortInfo,
                                LPRECIPIENT_INFO * lppContentsList,
                                LPFILETIME lpftLast,
                                LPULONG lpcbEID,
                                LPENTRYID * lppEID);

HRESULT AddEntryToContainer(LPADRBOOK lpIAB,
                        ULONG ulObjType, //MAPI_DISTLIST or MAPI_ABCONT
                        ULONG cbGroupEntryID,
                        LPENTRYID lpGroupEntryID,
                        DWORD cbEID,
                        LPENTRYID lpEID);

// Customizes and displays the context menu for various list views in the UI
int ShowLVContextMenu(int LV, // idicates which list view this is
					   HWND hWndLV,
                       HWND hWndCombo,
					   LPARAM lParam,  // contains the mouse pos info when called from WM_CONTEXTMENU
                       LPVOID lpVoid,  //misc stuff we want to pass in
                       LPADRBOOK lpIAB, HWND hWndTV);

// Gets the child's coordinates in client units
void GetChildClientRect(    HWND hWndChild,
                            LPRECT lprc);


// Finds the item in the LV matching the text in the EditBox
void DoLVQuickFind(HWND hWndEdit, HWND hWndLV);


// Does string searching of one within the other
BOOL SubstringSearch(LPTSTR pszTarget, LPTSTR pszSearch);



// Gets the props from a object
HRESULT HrGetPropArray( LPADRBOOK lpIAB,
                        LPSPropTagArray lpPTA,
                        ULONG cbEntryID,
                        LPENTRYID lpEntryID,
                        ULONG ulFlags,
                        ULONG * lpcValues,
                        LPSPropValue * lppPropArray);



// Calls CreateEntry for a new mailuser/distlist ...
HRESULT HrCreateNewEntry(   LPADRBOOK   lpIAB,          //AdrBook Object
                            HWND        hWndParent,     //Hwnd for dialog
                            ULONG       ulCreateObjectType,   //MAILUSER or DISTLIST
                            ULONG       cbEIDContainer,
                            LPENTRYID   lpEIDContainer,
                            ULONG       ulContObjectType,
                            ULONG       ulFlags,
                            BOOL        bShowBeforeAdding,
                            ULONG       cValues,
                            LPSPropValue lpPropArray,
                            ULONG       *lpcbEntryID,
                            LPENTRYID   *lppEntryID );


HRESULT HrGetWABTemplateID( LPADRBOOK lpIAB,
                            ULONG   ulObjectType,
                            ULONG * lpcbEID,
                            LPENTRYID * lppEID);


BOOL CheckForCycle( LPADRBOOK lpAdrBook,
                    LPENTRYID lpEIDChild,
                    ULONG cbEIDChild,
                    LPENTRYID lpEIDParent,
                    ULONG cbEIDParent); //from distlist.c


// Used for sorting columns in various list views ...
void SortListViewColumn(    LPIAB lpIAB,
                            HWND hWndLV,                //ListView Handle
                            int iSortCol,               //Column to sort by
                            LPSORT_INFO lpSortInfo,
                            BOOL bUseCurrentSettings);    // Sort Info structre specific for each dialog



// Used for storing sort info for persistence between sessions.
BOOL ReadRegistrySortInfo(LPIAB lpIAB, LPSORT_INFO lpSortInfo);
BOOL WriteRegistrySortInfo(LPIAB lpIAB, SORT_INFO SortInfo);

// Constructs a localized display name from individual pieces
BOOL SetLocalizedDisplayName(
                    LPTSTR lpszFirstName,
                    LPTSTR lpszMiddleName,
                    LPTSTR lpszLastName,
                    LPTSTR lpszCompanyName,
                    LPTSTR lpszNickName,
                    LPTSTR * lppszBuf,
                    ULONG  ulszBuf,
                    BOOL   bDNbyLN,
                    LPTSTR lpTemplate,
                    LPTSTR * lppszRetBuf);


// Callback for setting all the children windows to default GUI font ..
#define PARENT_IS_DIALOG 0 // We treat dialog children differently from window children
#define PARENT_IS_WINDOW 1 // so need these LPARAM values to differentiate..
STDAPI_(BOOL) SetChildDefaultGUIFont(HWND hWndChild, LPARAM lParam);


// Used for populating the Combo box with LDAP server names ...
HRESULT PopulateContainerList(  LPADRBOOK lpIAB,
                                HWND hWndLV,
                                LPTSTR lpszSelection,
                                LPTSTR lptszPreferredSelection);


// Used for freeing the associated structure in each container List Views
void FreeLVItemParam(HWND hWndLV);


// Gets the EntryID of the current container ...
void GetCurrentContainerEID(HWND hWndLV,
                            LPULONG lpcbContEID,
                            LPENTRYID * lppContEID);


// Shows the LDAP search dialog and creates a restriction
HRESULT HrShowSearchDialog(LPADRBOOK lpIAB,
                           HWND hWndParent,
                           LPADRPARM_FINDINFO lpAPFI,
                           LPLDAPURL lplu,
                           LPSORT_INFO lpSortInfo);


// Gets contents from an LDAP search and container
HRESULT HrSearchAndGetLDAPContents(
                            LDAP_SEARCH_PARAMS LDAPsp,
                            LPTSTR lpAdvFilter,
                            HWND hWndList,
                            LPADRBOOK lpIAB,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList);

// Gets contents from a WAB local store container
HRESULT HrGetWABContents(   HWND  hWndList,
                            LPADRBOOK lpIAB,
                            LPSBinary lpsbContainer,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList);


// Shows UI to modify current list of servers
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent, LPIAB lpIAB);

// Creates a new blank mailuser object
HRESULT HrCreateNewObject(LPADRBOOK lpIAB,
                        LPSBinary lpsbContainer,
                        ULONG ulObjectType,
                        ULONG ulFlags,
                        LPMAPIPROP * lppPropObj);

// Generic message box displayer ...
int ShowMessageBox(HWND hWndParent, int MsgId, int ulFlags);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);


// atoi converter
int my_atoi(LPTSTR lpsz);

// Reads the default registry LDAP country name
BOOL ReadRegistryLDAPDefaultCountry(LPTSTR szCountry, LPTSTR szCountryCode);

#ifdef OLD_STUFF
// Fills a drop down list with the LDAP country names
void FillComboLDAPCountryNames(HWND hWndCombo);
// Writes the defaule country name to the registry
BOOL WriteRegistryLDAPDefaultCountry(LPTSTR szCountry);
#endif //OLD_STUFF

// Looks at Combo and ListView and determines which options to enable or disable
void GetCurrentOptionsState(HWND hWndCombo,
                            HWND hWndLV,
                            LPBOOL lpbState);

// Adds selected LDAP items to the Address Book
HRESULT HrAddToWAB( LPADRBOOK   lpIAB,
                    HWND hWndLV,
                    LPFILETIME lpftLast);


// Coolbar creating function ...
HWND CreateCoolBar(LPBWI lpbwi, HWND hwndParent);


// Directory Services Proeprties property sheet
HRESULT HrShowDSProps(HWND hWndParent,LPTSTR lpszName, BOOL bAddNew);


// Saves the modeless dialog size and position to registry for persistence
BOOL WriteRegistryPositionInfo(LPIAB lpIAB, LPABOOK_POSCOLSIZE  lpABPosColSize, LPTSTR szKey);


// Retrieves the modeless dialog size and position to registry for persistence
BOOL ReadRegistryPositionInfo(LPIAB lpIAB, LPABOOK_POSCOLSIZE  lpABPosColSize, LPTSTR szKey);


// Processes the nmcustomdraw message from the list view
LRESULT ProcessLVCustomDraw(HWND hWnd, LPARAM lParam, BOOL bIsDialog);


// Quick Filter for list view
void DoLVQuickFilter(   LPADRBOOK lpIAB,
                        HWND hWndEdit,
                        HWND hWndLV,
                        LPSORT_INFO lpSortInfo,
                        ULONG ulFlags,
                        int nMinLen,
                        LPRECIPIENT_INFO * lppContentsList);

// Sets the objects name in the properties window title
void SetWindowPropertiesTitle(HWND hDlg, LPTSTR lpszName);

void SCS(HWND hwndParent);


// Copies an items (partial) contents into the clipboard
HRESULT HrCopyItemDataToClipboard(HWND hWnd, LPADRBOOK lpIAB, HWND hWndLV);


// Gets the items data and puts it all into 1 long string
HRESULT HrGetLVItemDataString(LPADRBOOK lpIAB, HWND hWndLV, int iItemIndex, LPTSTR * lppszData);

LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3);


// Shellexecutes a "mailto" to selected entry ...
HRESULT HrSendMailToSelectedContacts(HWND hWndLV, LPADRBOOK lpIAB, int nExtEmail);


// Show certificate properties
//HRESULT HrShowCertProps(HWND   hWndParent,
//                        LPCERT_DISPLAY_PROPS lpCDP);

// Shows the Help About dialog box
INT_PTR CALLBACK HelpAboutDialogProc(  HWND hDlg,
                                       UINT    message,
                                       WPARAM  wParam,
                                       LPARAM  lParam);


// Helps truncate DBCS strings correctly
ULONG TruncatePos(LPTSTR lpsz, ULONG nMaxLen);

// Local WAB search
HRESULT HrDoLocalWABSearch( IN  HANDLE hPropertyStore,
                            IN  LPSBinary lpsbCont,
                            IN  LDAP_SEARCH_PARAMS LDAPsp,
                            OUT LPULONG lpulFoundCount,
                            OUT LPSBinary * lprgsbEntryIDs );


// Adds a non-wab entry to the wab
HRESULT HrEntryAddToWAB(    LPADRBOOK lpIAB,
                            HWND hWndParent,
                            ULONG cbInputEID,
                            LPENTRYID lpInputEID,
                            ULONG * lpcbOutputEID,
                            LPENTRYID * lppOutputEID);


//  Deciphers a vCard File and then shows one off details on it
HRESULT HrShowOneOffDetailsOnVCard(  LPADRBOOK lpIAB,
                                     HWND hWnd,
                                     LPTSTR szvCardFile);

// Checks if the current locale needs Ruby Support
BOOL bIsRubyLocale();

void FreeRecipList(LPRECIPIENT_INFO * lppList);

void SetSBinary(LPSBinary lpsb, ULONG cb, LPBYTE lpb);


HRESULT HrProcessLDAPUrl(LPADRBOOK lpIAB,   HWND hWnd,
                         ULONG ulFlags,     LPTSTR szLDAPUrl,
                         LPMAILUSER * lppMailUser);

HRESULT VCardRetrieve(LPADRBOOK lpIAB,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPSTR lpszBuf,
                      LPMAILUSER * lppMailUser);

HRESULT VCardCreate(  LPADRBOOK lpIAB,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPMAILUSER lpMailUser);

//void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient);
HRESULT HrShellExecInternetCall(LPADRBOOK lpIAB, HWND hWndLV);


// Open a vCard and add it to the wab based on file name
HRESULT OpenAndAddVCard(LPBWI lpbwi, LPTSTR szVCardFile);


// removes illegal chars from potential file names
void TrimIllegalFileChars(LPTSTR sz);

// DistList prop sheets
//
INT_PTR CreateDLPropertySheet( HWND hwndOwner,
                           LPDL_INFO lpPropArrayInfo);


// Copies truncated version of Src to Dest
int CopyTruncate(LPTSTR szDest, LPTSTR szSrc, int nMaxLen);

// Adds an item's parent's eid to the item
HRESULT AddFolderParentEIDToItem(LPIAB lpIAB,
                                 ULONG cbFolderEntryID,
                                 LPENTRYID lpFolderEntryID,
                                 LPMAPIPROP lpMU, ULONG cbEID, LPENTRYID lpEID);

// Adds an item's eid to its parent
HRESULT AddItemEIDToFolderParent(  LPIAB lpIAB,
                                   ULONG cbFolderEntryId,
                                   LPENTRYID lpFolderEntryId,
                                   ULONG cbEID, LPENTRYID lpEID);

// Adds the specified entry to the specified WAB Profile Folder
HRESULT AddEntryToFolder(LPADRBOOK lpIAB,
                         LPMAPIPROP lpMailUser,
                        ULONG cbFolderEntryId,
                        LPENTRYID lpFolderEntryId,
                        DWORD cbEID,
                        LPENTRYID lpEID);

// imports another WAB file
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpIAB, ULONG ulFlags, LPTSTR lpszFileName);

LPRECIPIENT_INFO GetItemFromLV(HWND hWndLV, int iItem);

// determines what the UI icon for the entry should be..
int GetWABIconImage(LPRECIPIENT_INFO lpItem);

// 
// Functions related to using Outlook store
BOOL SetRegistryUseOutlook(BOOL bUseOutlook);
BOOL bUseOutlookStore();
BOOL bCheckForOutlookWABDll(LPTSTR lpszDllPath);


// Functions used in managing rt-click extensions
void FreeActionItemList(LPIAB lpIAB);
HRESULT HrUpdateActionItemList(LPIAB lpIAB);
LRESULT ProcessActionCommands(LPIAB lpIAB, HWND  hWndLV, 
                              HWND  hWnd, UINT  uMsg, WPARAM  wParam, LPARAM lParam);
void AddExtendedMenuItems(LPADRBOOK lpIAB, HWND hWndLV, HMENU hMenuAction, BOOL bUpdateStatus, BOOL bAddSendMailItems);
void AddExtendedSendMailToItems(LPADRBOOK lpIAB, HWND hWndLV, HMENU hMenuAction, BOOL bAddItems);
void GetContextMenuExtCommandString(LPIAB lpIAB, int uCmd, LPTSTR sz, ULONG cbsz);


// Stuff to do with GetMe / SetMe
HRESULT HrGetMeObject(LPADRBOOK lpIAB, ULONG ulFlags, DWORD * lpdwAction, SBinary * lpsbEID, ULONG_PTR ulParam);
HRESULT HrSetMeObject(LPADRBOOK lpIAB, ULONG ulFlags, SBinary sbEID, ULONG_PTR ulParam);

// Stuff to do with the print and abort import dialog
void CreateShowAbortDialog(HWND hWndParent, int idsTitle, int idsIcon, int ProgMax, int ProgCurrent);
void CloseAbortDlg();
BOOL CALLBACK FAbortProc(HDC hdcPrn, INT nCode);
void SetPrintDialogMsg(int idsMsg, int idsFormat, LPTSTR lpszMsg);
INT_PTR CALLBACK FAbortDlgProc(HWND hwnd, UINT msg,WPARAM wp, LPARAM lp);
BOOL bTimeToAbort();

HRESULT HrSaveHotmailSyncInfoOnDeletion(LPADRBOOK lpAdrBook, LPSBinary lpEID);
HRESULT HrAssociateOneOffGroupMembersWithContacts(LPADRBOOK lpAdrBook, 
                                                  LPSBinary lpsbGroupEID,
                                                  LPDISTLIST lpDistList);

// Stuff used in adding extension property pages to the WAB Prop Sheets
//
typedef HRESULT (_ADDPROPPAGES_) (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, int * lpnPage);
typedef _ADDPROPPAGES_  FAR *LPFNADDPAGES;

BOOL CALLBACK AddPropSheetPageProc( HPROPSHEETPAGE hpage, LPARAM lParam );
void FreePropExtList(LPEXTDLLINFO lpList);
HRESULT GetExtDisplayInfo(LPIAB lpIAB, LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL fReadOnly, BOOL bMailUser);
BOOL ChangedExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL bChanged);
void FreeExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo);

#ifdef COLSEL_MENU 
BOOL ColSel_PropTagToString( ULONG ulPropTag, LPTSTR lpszString, ULONG cchSize);
#endif // COLSEL_MENU 

BOOL IsWindowOnScreen(LPRECT lprc); // determines if window is onscreen
BOOL IsHTTPMailEnabled(LPIAB lpIAB);

/*********************************************************************/

#ifdef WIN16 // Need WINAPI for 16 bits
typedef BOOL WINAPI (_INITCOMMONCONTROLSEX_)(LPINITCOMMONCONTROLSEX lpiccex);
typedef _INITCOMMONCONTROLSEX_ FAR *LP_INITCOMMONCONTROLSEX;

typedef HPROPSHEETPAGE WINAPI (_CREATEPROPERTYSHEETPAGE_)(PROPSHEETPAGE * lppsp); 
typedef _CREATEPROPERTYSHEETPAGE_ FAR * LP_CREATEPROPERTYSHEETPAGE;
 
typedef BOOL WINAPI (_IMAGELIST_DRAW_)(HIMAGELIST himl, int i, HDC hdcDst,int x, int y, UINT fStyle);
typedef _IMAGELIST_DRAW_ FAR * LPIMAGELIST_DRAW;

typedef BOOL WINAPI (_IMAGELIST_DESTROY_)(HIMAGELIST himl);
typedef _IMAGELIST_DESTROY_ FAR * LPIMAGELIST_DESTROY;

typedef HIMAGELIST WINAPI (_IMAGELIST_LOADIMAGE_)(HINSTANCE hi, LPTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef _IMAGELIST_LOADIMAGE_ FAR *LPIMAGELIST_LOADIMAGE;

typedef COLORREF WINAPI (_IMAGELIST_SETBKCOLOR_)(HIMAGELIST himl, COLORREF clrBk);
typedef _IMAGELIST_SETBKCOLOR_ FAR *LPIMAGELIST_SETBKCOLOR;

typedef BOOL WINAPI (_TRACKMOUSEEVENT_)(LPTRACKMOUSEEVENT lpEventTrack);
typedef _TRACKMOUSEEVENT_ FAR *LP_TRACKMOUSEEVENT;

typedef int WINAPI (_PROPERTYSHEET_)(LPCPROPSHEETHEADER lppsph);
typedef _PROPERTYSHEET_ FAR *LPPROPERTYSHEET;
#else  // WIN16
typedef BOOL (_INITCOMMONCONTROLSEX_)(LPINITCOMMONCONTROLSEX lpiccex);
typedef _INITCOMMONCONTROLSEX_ FAR *LP_INITCOMMONCONTROLSEX;

/*
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_)(PROPSHEETPAGE * lppsp); 
typedef _CREATEPROPERTYSHEETPAGE_ FAR * LP_CREATEPROPERTYSHEETPAGE;
*/
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_A_)(LPCPROPSHEETPAGEA lppsp);
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_W_)(LPCPROPSHEETPAGEW lppsp);

typedef _CREATEPROPERTYSHEETPAGE_A_ FAR * LP_CREATEPROPERTYSHEETPAGE_A;
typedef _CREATEPROPERTYSHEETPAGE_W_ FAR * LP_CREATEPROPERTYSHEETPAGE_W;
 
typedef BOOL (_IMAGELIST_DRAW_)(HIMAGELIST himl, int i, HDC hdcDst,int x, int y, UINT fStyle);
typedef _IMAGELIST_DRAW_ FAR * LPIMAGELIST_DRAW;

typedef BOOL (_IMAGELIST_DESTROY_)(HIMAGELIST himl);
typedef _IMAGELIST_DESTROY_ FAR * LPIMAGELIST_DESTROY;

/*
typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_)(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef _IMAGELIST_LOADIMAGE_ FAR *LPIMAGELIST_LOADIMAGE;
*/

typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_A_)(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_W_)(HINSTANCE hi, LPCWSTR lpbmp,int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

typedef _IMAGELIST_LOADIMAGE_A_ FAR *LPIMAGELIST_LOADIMAGE_A;
typedef _IMAGELIST_LOADIMAGE_W_ FAR *LPIMAGELIST_LOADIMAGE_W;

typedef COLORREF (_IMAGELIST_SETBKCOLOR_)(HIMAGELIST himl, COLORREF clrBk);
typedef _IMAGELIST_SETBKCOLOR_ FAR *LPIMAGELIST_SETBKCOLOR;

typedef BOOL (_TRACKMOUSEEVENT_)(LPTRACKMOUSEEVENT lpEventTrack);
typedef _TRACKMOUSEEVENT_ FAR *LP_TRACKMOUSEEVENT;

/*
typedef int (_PROPERTYSHEET_)(LPCPROPSHEETHEADER lppsph);
typedef _PROPERTYSHEET_ FAR *LPPROPERTYSHEET;
*/
typedef INT_PTR (_PROPERTYSHEET_A_)(LPCPROPSHEETHEADERA lppsphA); 
typedef INT_PTR (_PROPERTYSHEET_W_)(LPCPROPSHEETHEADERW lppsphW);

typedef _PROPERTYSHEET_A_ FAR *LPPROPERTYSHEET_A;
typedef _PROPERTYSHEET_W_ FAR *LPPROPERTYSHEET_W;
#endif

BOOL InitCommonControlLib(void);
ULONG DeinitCommCtrlClientLib(void);
BOOL __fastcall IsSpace(LPTSTR lpChar);
/*********************************************************************/

// The following messages are used for shutting down the WAB when the user changes to modify the locale
// so that the new set of WAB resources can be brought in ..
// These are used in conjunction with MLLoadLibrary 
#define PUI_OFFICE_COMMAND      (WM_USER + 0x0901)
#define PLUGUI_CMD_SHUTDOWN		0 // wParam value
#define PLUGUI_CMD_QUERY		1 // wParam value
#define OFFICE_VERSION_9		9 // standardized value to return for Office 9 apps

typedef struct _PLUGUI_INFO
{
	unsigned uMajorVersion : 8;	// Used to indicate App;s major version number
	unsigned uOleServer : 1;		// BOOL, TRUE if this is an OLE process
	unsigned uUnused : 23;		// not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
	UINT uQueryVal;
	PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;
// End of Pluggable UI section

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_cflct.h ===
// ui_cflct.h
//
// definitions for WAB synchronization conflict resolution dialog
//
#include "imnxport.h"
#include "imnact.h"

#ifndef __UI_CFLCT_H__
#define __UI_CFLCT_H__

#ifdef __cplusplus
extern "C"{
#endif 

typedef enum {
    CONFLICT_IGNORE = 0,
    CONFLICT_SERVER,
    CONFLICT_CLIENT
}CONFLICT_DECISION;

#define CONFLICT_DECISION_COUNT 28

typedef struct HTTPCONFLICTINFO
{
    BOOL                    fContainsSkip;
    LPHTTPCONTACTINFO       pciServer;
    LPHTTPCONTACTINFO       pciClient;
    CONFLICT_DECISION       rgcd[CONFLICT_DECISION_COUNT];
}HTTPCONFLICTINFO, *LPHTTPCONFLICTINFO;


BOOL    ResolveConflicts(HWND hwnd, LPHTTPCONFLICTINFO prgConflicts, DWORD cConflicts);
BOOL    ChooseHotmailServer(HWND hwnd, IImnEnumAccounts *pEnumAccts, LPSTR pszAccountName);

#ifdef __cplusplus
}
#endif 


#endif //__UI_CFLCT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_addr.h ===
#ifndef _UI_ADDRS_H_
#define _UI_ADDRS_H_

HRESULT HrShowAddressUI(IN  LPADRBOOK   lpIAB,
                        IN  HANDLE      hPropertyStore,
					    IN  ULONG_PTR * lpulUIParam,
					    IN  LPADRPARM   lpAdrParms,
					    IN  LPADRLIST  *lppAdrList);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_addr.c ===
/*--------------------------------------------------------------
*
*
*   ui_addr.c - contains stuff for showing the :Address UI
*
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;

#define SET_UNICODE_STR(lp1,lp2,lpAdrParms)   if(lpAdrParms->ulFlags & MAPI_UNICODE)\
                                                  lp1 = (LPWSTR)lp2;                      \
                                              else                                        \
                                                  lp1 = ConvertAtoW((LPSTR)lp2);          \

#define FREE_UNICODE_STR(lp1,lp2)   if(lp1 != lp2) LocalFreeAndNull(&lp1);

typedef struct _AddressParms
{
    LPADRBOOK   lpIAB;              //Stores a pointer to the ADRBOOK object
    LPADRPARM   lpAdrParms;         //AdrParms structure passed into Address
    LPADRLIST   *lppAdrList;        //AdrList of input names
    HANDLE      hPropertyStore;     //pointer to the property store
    int         DialogState;        //Identifies the ongoing function
    LPRECIPIENT_INFO lpContentsList;//Contains a list of entries in the contents structure
    LPRECIPIENT_INFO lpListTo;      //Entries in the To Well
    LPRECIPIENT_INFO lpListCC;      //Entries in the CC well
    LPRECIPIENT_INFO lpListBCC;     //Entries in the BCC well
    SORT_INFO  SortInfo;            //Contains current sort info
    int        nContextID;      //identifies which list view called the context menu
    BOOL       bDontRefresh;    //Used to ensure that nothing refreshes during modal operations
    BOOL       bLDAPinProgress;
    HCURSOR    hWaitCur;
    int        nRetVal;
    LPMAPIADVISESINK lpAdviseSink;
    ULONG       ulAdviseConnection;
    BOOL        bDeferNotification; // Used to defer next notification request
    HWND        hDlg;
    HWND        hWndAddr;
}   ADDRESS_PARMS, *LPADDRESS_PARMS;


enum _lppAdrListReturnedProps
{
    propPR_DISPLAY_NAME,
    propPR_ENTRYID,
    propPR_RECIPIENT_TYPE,
    TOTAL_ADRLIST_PROPS
};


static DWORD rgAddrHelpIDs[] =
{
    IDC_ADDRBK_EDIT_QUICKFIND,      IDH_WAB_PICK_RECIP_TYPE_NAME,
    IDC_ADDRBK_STATIC_CONTENTS,     IDH_WAB_PICK_RECIP_NAME_LIST,
    IDC_ADDRBK_LIST_ADDRESSES,      IDH_WAB_PICK_RECIP_NAME_LIST,
    IDC_ADDRBK_BUTTON_PROPS,        IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_ADDRBK_BUTTON_NEW,          IDH_WAB_PICK_RECIP_NAME_NEW,
    IDC_ADDRBK_BUTTON_TO,           IDH_WAB_PICK_RECIP_NAME_TO_BUTTON,
    IDC_ADDRBK_BUTTON_CC,           IDH_WAB_PICK_RECIP_NAME_CC_BUTTON,
    IDC_ADDRBK_BUTTON_BCC,          IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON,
    IDC_ADDRBK_LIST_TO,             IDH_WAB_PICK_RECIP_NAME_TO_LIST,
    IDC_ADDRBK_LIST_CC,             IDH_WAB_PICK_RECIP_NAME_CC_LIST,
    IDC_ADDRBK_LIST_BCC,            IDH_WAB_PICK_RECIP_NAME_BCC_LIST,
    IDC_ADDRBK_BUTTON_DELETE,       IDH_WAB_PICK_RECIP_NAME_DELETE,
    IDC_ADDRBK_BUTTON_NEWGROUP,     IDH_WAB_PICK_RECIP_NAME_NEW_GROUP,
    IDC_ADDRBK_STATIC_RECIP_TITLE,  IDH_WAB_COMM_GROUPBOX,
    IDC_ADDRBK_BUTTON_FIND,         IDH_WAB_PICK_RECIP_NAME_FIND,
    IDC_ADDRBK_COMBO_CONT,          IDH_WAB_GROUPS_CONTACTS_FOLDER,
    0,0
};

// forward declarations

INT_PTR CALLBACK fnAddress(HWND    hDlg,
                           UINT    message,
                           WPARAM  wParam,
                           LPARAM  lParam);


BOOL SetAddressBookUI(HWND hDlg,
                      LPADDRESS_PARMS lpAP);

void FillListFromCurrentContainer(HWND hDlg, LPADDRESS_PARMS lpAP);

BOOL FillWells(HWND hDlg, LPADRLIST lpAdrList, LPADRPARM lpAdrParms, LPRECIPIENT_INFO * lppListTo, LPRECIPIENT_INFO * lppListCC, LPRECIPIENT_INFO * lppListBCC);

BOOL ListDeleteItem(HWND hDlg, int CtlID, LPRECIPIENT_INFO * lppList);

BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType);

void UpdateLVItems(HWND hWndLV,LPTSTR lpszName);

void ShowAddrBkLVProps(LPIAB lpIAB, HWND hDlg, HWND hWndAddr, LPADDRESS_PARMS lpAP, LPFILETIME lpftLast);

HRESULT HrUpdateAdrListEntry(	LPADRBOOK	lpIAB,
								LPENTRYID	lpEntryID,
								ULONG cbEntryID,
                                ULONG ulFlags,
								LPADRLIST * lppAdrList);

enum _AddressDialogReturnValues
{
    ADDRESS_RESET = 0,  //Blank initialization value
    ADDRESS_CANCEL,
    ADDRESS_OK,
};


//$$/////////////////////////////////////////////////////////////////////////////////////////
//
// FillContainerCombo - Fills the container combo with container names
//
/////////////////////////////////////////////////////////////////////////////////////////////
void FillContainerCombo(HWND hWndCombo, LPIAB lpIAB)
{
	ULONG iolkci, colkci;
	OlkContInfo *rgolkci;
    int nPos, nDefault=0;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    
    // Clear out the combo
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

	Assert(lpIAB);

    EnterCriticalSection(&lpIAB->cs);
    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB))
    {
        colkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->colkci : lpIAB->cwabci;
	    Assert(colkci);
        rgolkci = lpIAB->lpPropertyStore->colkci ? lpIAB->lpPropertyStore->rgolkci : lpIAB->rgwabci;
	    Assert(rgolkci);

        // Add the multiple folders here
        for(iolkci = 0; iolkci < colkci; iolkci++)
        {
            nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) rgolkci[iolkci].lpszName);
            if(nPos != CB_ERR)
                SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM)nPos, (LPARAM) (DWORD_PTR)(iolkci==0 ? NULL : rgolkci[iolkci].lpEntryID));
            if( bIsThereACurrentUser(lpIAB) && 
                !lstrcmpi(lpIAB->lpWABCurrentUserFolder->lpFolderName, rgolkci[iolkci].lpszName) &&//folder names are unique
                nPos != CB_ERR)
            {
                nDefault = nPos;
            }
        }
    }
    LeaveCriticalSection(&lpIAB->cs);
    SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nDefault, 0);
}



//$$*------------------------------------------------------------------------
//| IAddrBook::Advise::OnNotify handler
//|
//*------------------------------------------------------------------------
ULONG AddrAdviseOnNotify(LPVOID lpvContext, ULONG cNotif, LPNOTIFICATION lpNotif)
{
    LPADDRESS_PARMS lpAP = (LPADDRESS_PARMS) lpvContext;

    DebugTrace( TEXT("+++ AddrAdviseOnNotify ===\n"));

    if(lpAP->bDeferNotification)
    {
        DebugTrace( TEXT("+++ Advise Defered ===\n"));
        lpAP->bDeferNotification = FALSE;
        return S_OK;
    }
    if(!lpAP->bDontRefresh)
    {
        DebugTrace( TEXT("+++ Calling FillListFromCurrentContainer ===\n"));
        FillListFromCurrentContainer(lpAP->hDlg, lpAP);
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////
//
// ShowAddressUI - does some parameter checking and calls the PropertySheets
//
//
//
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowAddressUI(IN  LPADRBOOK   lpIAB,
                        IN  HANDLE      hPropertyStore,
					    IN  ULONG_PTR * lpulUIParam,
					    IN  LPADRPARM   lpAdrParms,
					    IN  LPADRLIST  *lppAdrList)
{
    HRESULT hr = E_FAIL;
    //ADDRESS_PARMS AP = {0};
    LPADDRESS_PARMS lpAP = NULL;
    TCHAR szBuf[MAX_UI_STR];

    HWND hWndParent = NULL;
    int nRetVal = 0;
    int DialogState = 0;

    //Addref the AdrBook object to make sure it stays valid throughout ..
    // Remember to release before leaving ...
    // NOTE: Must be before any jumps to out!
    UlAddRef(lpIAB);

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if (lpulUIParam)
        hWndParent = (HWND) *lpulUIParam;

    if ( // Can't pick-user with wells
        ((lpAdrParms->ulFlags & ADDRESS_ONE) && (lpAdrParms->cDestFields != 0)) ||
         // cDestFields has limited for tier 0.5
        (lpAdrParms->cDestFields > 3) ||
         // Cant pick user without an input lpAdrList
        //((lpAdrParms->ulFlags & ADDRESS_ONE) && (*lppAdrList == NULL)) ||
        ((lpAdrParms->ulFlags & DIALOG_SDI) && (lpAdrParms->cDestFields != 0)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    //
    // The possible states of this dialog box are
    // 1. Select recipients Wells shown, returns an AdrList of picked up entries, Cant delete entries
    // 2. Select a single user, No wells shown, single selection, cannot delete, must have input Adrlist
    // 3. Open for browsing only, multiple selection, can create delete, create, view details

    // Determine what the dialog state is
    if (lpAdrParms->cDestFields > 0)
    {
        //lpAP->DialogState = STATE_SELECT_RECIPIENTS;
        DialogState = STATE_SELECT_RECIPIENTS;
    }
    else if (lpAdrParms->ulFlags & ADDRESS_ONE)
    {
        DialogState = STATE_PICK_USER;
    }
    else if (lpAdrParms->ulFlags & DIALOG_MODAL)
    {
        DialogState = STATE_BROWSE_MODAL;
    }
    else if (lpAdrParms->ulFlags & DIALOG_SDI)
    {
        DialogState = STATE_BROWSE;
    }


	if (DialogState == STATE_BROWSE)
	{
		// Show the browse window and leave
		//
		HWND hWndAB = NULL;
		hWndAB = hCreateAddressBookWindow(	lpIAB,
											hWndParent,
											lpAdrParms);
		if (hWndAB)
        {
            *lpulUIParam = (ULONG_PTR) hWndAB;
			hr = S_OK;
        }
		goto out;

	}

    lpAP = LocalAlloc(LMEM_ZEROINIT, sizeof(ADDRESS_PARMS));

	if (!lpAP)
	{
		hr = MAPI_E_NOT_ENOUGH_MEMORY;
		goto out;
	}

	lpAP->DialogState = DialogState;


    lpAP->lpIAB = lpIAB;
    lpAP->lpAdrParms = lpAdrParms;
    lpAP->lppAdrList = lppAdrList;
    lpAP->hPropertyStore = hPropertyStore;

    ReadRegistrySortInfo((LPIAB)lpIAB, &(lpAP->SortInfo));

    lpAP->lpContentsList = NULL;

    lpAP->bDontRefresh = FALSE;

    lpAP->bLDAPinProgress = FALSE;
    lpAP->hWaitCur = NULL;

    HrAllocAdviseSink(&AddrAdviseOnNotify, (LPVOID) lpAP, &(lpAP->lpAdviseSink));

    nRetVal = (int) DialogBoxParam( hinstMapiX,
                              MAKEINTRESOURCE(IDD_DIALOG_ADDRESSBOOK),
                              hWndParent,
                              (DLGPROC) fnAddress,
                              (LPARAM) lpAP);
    switch(nRetVal)
    {
    case -1: //some error occured
        hr = E_FAIL;
        break;
    case ADDRESS_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case ADDRESS_OK:
    default:
        hr = S_OK;
        break;
    }

    if(lpAP->lpAdviseSink)
    {
        lpAP->lpIAB->lpVtbl->Unadvise(lpAP->lpIAB, lpAP->ulAdviseConnection);
        lpAP->lpAdviseSink->lpVtbl->Release(lpAP->lpAdviseSink);
        lpAP->lpAdviseSink = NULL;
        lpAP->ulAdviseConnection = 0;
    }

out:

    lpIAB->lpVtbl->Release(lpIAB);

    LocalFreeAndNull(&lpAP);
    return hr;
}


#define lpAP_lppContentsList    (&(lpAP->lpContentsList))
#define lpAP_lppListTo          (&(lpAP->lpListTo))
#define lpAP_lppListCC          (&(lpAP->lpListCC))
#define lpAP_lppListBCC         (&(lpAP->lpListBCC))
#define lpAP_bDontRefresh       (lpAP->bDontRefresh)
#define _hWndAddr               lpAP->hWndAddr


extern HRESULT FillListFromGroup(LPADRBOOK lpIAB, ULONG cbGroupEntryID, LPENTRYID lpGroupEntryID,
                                LPTSTR lpszName, LPRECIPIENT_INFO * lppList);

//$$/////////////////////////////////////////////////////////////////////////////
//
// GetCurrentComboSelection - Get the current selection from the combo 
//
/////////////////////////////////////////////////////////////////////////////////
LPSBinary GetCurrentComboSelection(HWND hWndCombo)
{
    int nPos = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    LPSBinary lpsbCont = NULL;

    if(nPos == CB_ERR)
        nPos = 0;
    lpsbCont = (LPSBinary) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) nPos, 0);
    if(CB_ERR == (DWORD_PTR) lpsbCont)
        lpsbCont = NULL;

    return lpsbCont;
}
//$$/////////////////////////////////////////////////////////////////////////////
//
// FillListFromCurrentContainer - Get the selection from the combo and fill it
//
/////////////////////////////////////////////////////////////////////////////////
void FillListFromCurrentContainer(HWND hDlg, LPADDRESS_PARMS lpAP)
{
    HWND hWndAddr = GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES);
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPSBinary lpsbCont = NULL;

    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
    {
        HWND hWndCombo = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
        int nPos = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

        if(nPos != CB_ERR)
        {
            // Refill the combo in case the folder list changed
            FillContainerCombo(hWndCombo, (LPIAB)lpAP->lpIAB);
            nPos = (int) SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nPos, 0);
        }
        lpsbCont = GetCurrentComboSelection(hWndCombo);
    }

    HrGetWABContents(   hWndAddr,
                        lpAP->lpIAB, lpsbCont,
                        lpAP->SortInfo, lpAP_lppContentsList);
}


extern BOOL APIENTRY_16 fnFolderDlgProc(HWND hDlg, UINT message, UINT wParam, LPARAM lParam);


/////////////////////////////////////////////////////////////////////////////////
//
// fnAddress - the PropertySheet Message Handler
//
//
//
/////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK fnAddress(HWND    hDlg,
                           UINT    message,
                           WPARAM  wParam,
                           LPARAM  lParam)
{
    static FILETIME ftLast = {0};

    LPADDRESS_PARMS lpAP = (LPADDRESS_PARMS ) GetWindowLongPtr(hDlg,DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
        lpAP = (LPADDRESS_PARMS) lParam;

        lpAP->hWndAddr = GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES);
        lpAP->hDlg = hDlg;
        lpAP_bDontRefresh = FALSE;

        lpAP->nContextID = IDC_ADDRBK_LIST_ADDRESSES;

        SetAddressBookUI(hDlg,lpAP);

        // if this is a pick-user dialog, need to have the names by
        // first name so we can find the closest match ..
        if(lpAP->DialogState == STATE_PICK_USER)
            (lpAP->SortInfo).bSortByLastName = FALSE;


        FillListFromCurrentContainer(hDlg, lpAP);


        if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
        {
            FillWells(hDlg,*(lpAP->lppAdrList),(lpAP->lpAdrParms),lpAP_lppListTo,lpAP_lppListCC,lpAP_lppListBCC);

            // we want to highlight the first item in the list
            if (ListView_GetItemCount(_hWndAddr) > 0)
                LVSelectItem( _hWndAddr, 0);
        }
        else if (lpAP->DialogState == STATE_PICK_USER &&
                 *(lpAP->lppAdrList) )
        {
            // if this is a pick user dialog, then try to match the supplied name to the
            // closest entry in the List Box
            if (ListView_GetItemCount(_hWndAddr) > 0)
            {
                LPTSTR lpszDisplayName = NULL;
                ULONG i;

                // Scan only the first entry in the lpAdrList for a display name
                for(i=0;i< (*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
                {
                    ULONG ulPropTag = PR_DISPLAY_NAME;
                    if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                        ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
                    if((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
                    {
                        SET_UNICODE_STR(lpszDisplayName, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
                        break;
                    }
                }

                if (lpszDisplayName)
                {
                    // We have Something to search for
                    TCHAR szBuf[MAX_UI_STR];
                    ULONG nLen;
                    LV_FINDINFO lvF = {0};

                    // Typically, we are not going to get a full match ...
                    // Instead we want to make a partial match on disply name.
                    // The ListViewFindItem does an exact partial match if the supplied
                    // string matches the first few entries of an existing item
                    // Hence, to obtain a semi-partial match, we start with the
                    // original Display Name working our way backwards from last
                    // character to first character until we get a match or run
                    // out of characters.

                    int iItemIndex = -1;
                    nLen = lstrlen(lpszDisplayName);

                    if (nLen >= CharSizeOf(szBuf))
                        nLen = CharSizeOf(szBuf)-1;
                    lvF.flags = LVFI_PARTIAL | LVFI_STRING;

                    while((nLen > 0) && (iItemIndex == -1))
                    {
                        nLen = TruncatePos(lpszDisplayName, nLen);
                        if (nLen==0) break;

                        CopyMemory(szBuf, lpszDisplayName, sizeof(TCHAR)*nLen);
                        szBuf[nLen] = '\0';

                        lvF.psz = szBuf;
                        iItemIndex = ListView_FindItem(_hWndAddr,-1, &lvF);

                        nLen--;
                    }

                    // Set focus to the selected item or to the first item in the list

                    if (iItemIndex < 0) iItemIndex = 0;

					LVSelectItem(_hWndAddr, iItemIndex);

                    FREE_UNICODE_STR(lpszDisplayName, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
                }
            }
        }

        if(lpAP->lpAdviseSink)
        {
            // Register for notifications
            lpAP->lpIAB->lpVtbl->Advise(lpAP->lpIAB, 0, NULL, fnevObjectModified, 
                                        lpAP->lpAdviseSink, &lpAP->ulAdviseConnection); 
        }

        if (ListView_GetSelectedCount(_hWndAddr) <= 0)
            LVSelectItem(_hWndAddr, 0);
        
        // if we want the user to pick something actively, we disable OK until they click on something 
        // or do something specific ..
        if( lpAP->DialogState == STATE_PICK_USER )
        {
            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE); 
            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
        }

        SetFocus(GetDlgItem(hDlg,IDC_ADDRBK_EDIT_QUICKFIND));
        return FALSE;
//        return TRUE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(_hWndAddr, message, wParam, lParam);
        SetColumnHeaderBmp(_hWndAddr, lpAP->SortInfo);
		break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgAddrHelpIDs );
        break;

    case WM_SETCURSOR:
        if (lpAP->bLDAPinProgress)
        {
            SetCursor(lpAP->hWaitCur);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, MAKELONG(TRUE, 0));
            return(TRUE);
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_SELCHANGE:
            FillListFromCurrentContainer(hDlg, lpAP);
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        default:
            if (lpAP->nContextID != -1)
            {
                LRESULT fRet = FALSE;
                lpAP_bDontRefresh = TRUE;
                fRet = ProcessActionCommands((LPIAB) lpAP->lpIAB,_hWndAddr, 
                                             hDlg, message, wParam, lParam);
                lpAP_bDontRefresh = FALSE;
                return fRet;
            }
            break;


        case IDC_ADDRBK_BUTTON_DELETE:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                lpAP_bDontRefresh = TRUE;
                DeleteSelectedItems(_hWndAddr, lpAP->lpIAB, lpAP->hPropertyStore, &ftLast);
                lpAP->bDeferNotification = TRUE;
                lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_DELETE:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                switch(lpAP->nContextID)
                {
                case IDC_ADDRBK_LIST_ADDRESSES:
                    lpAP_bDontRefresh = TRUE;
                    DeleteSelectedItems(_hWndAddr, lpAP->lpIAB, lpAP->hPropertyStore, &ftLast);
                    lpAP->bDeferNotification = TRUE;
                    lpAP_bDontRefresh = FALSE;
                    break;
                case IDC_ADDRBK_LIST_TO:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_TO, lpAP_lppListTo);
                    break;
                case IDC_ADDRBK_LIST_CC:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_CC, lpAP_lppListCC);
                    break;
                case IDC_ADDRBK_LIST_BCC:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_BCC, lpAP_lppListBCC);
                    break;
                default:
                    break;
                }
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_COPY:
            lpAP_bDontRefresh = TRUE;
            HrCopyItemDataToClipboard(hDlg, lpAP->lpIAB, GetDlgItem(hDlg,lpAP->nContextID));
            lpAP_bDontRefresh = FALSE;
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_ADDRBK_BUTTON_PROPS:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                if (lpAP->nContextID != -1)
                {
                    lpAP_bDontRefresh = TRUE;
                    ShowAddrBkLVProps((LPIAB)lpAP->lpIAB, hDlg, GetDlgItem(hDlg, lpAP->nContextID), lpAP, &ftLast);
                    lpAP->bDeferNotification = TRUE;
                    lpAP_bDontRefresh = FALSE;
                }
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

/* Uncomment to enable NEW_FOLDER functionality from this dialog

        case IDM_LVCONTEXT_NEWFOLDER:
            {
                TCHAR sz[MAX_UI_STR];
                LPTSTR lpsz = NULL;
                *sz = '\0';
                if( IDCANCEL  != DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_FOLDER),
		                                 hDlg, (DLGPROC) fnFolderDlgProc, (LPARAM) sz)
                    && lstrlen(sz)) 
                {
                    // if we're here we have a valid folder name ..
                    if(!HR_FAILED(HrCreateNewFolder((LPIAB)lpAP->lpIAB, sz, NULL, FALSE, NULL, NULL)))
                    {
                        int i,nTotal;
                        HWND hWndC = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
                        // Fill in the Combo with the container names
                        FillContainerCombo(hWndC, (LPIAB)lpAP->lpIAB);
                        nTotal = SendMessage(hWndC, CB_GETCOUNT, 0, 0);
                        if(nTotal != CB_ERR)
                        {
                            // Find the item we just added in the combo and set the sel on it
                            TCHAR szC[MAX_UI_STR];
                            for(i=0;i<nTotal;i++)
                            {
                                *szC = '\0';
                                SendMessage(hWndC, CB_GETLBTEXT, (WPARAM) i, (LPARAM) szC);
                                if(!lstrcmpi(sz, szC))
                                {
                                    SendMessage(hWndC, CB_SETCURSEL, (WPARAM) i, 0);
                                    break;
                                }
                            }
                        }
                        FillListFromCurrentContainer(hDlg, lpAP);
                    }
                }
            }
            break;
*/

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDC_ADDRBK_BUTTON_NEW:
            // only difference between contact and group is the object being added
        case IDM_LVCONTEXT_NEWGROUP:
        case IDC_ADDRBK_BUTTON_NEWGROUP:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG cbEID = 0;
                LPENTRYID lpEID = NULL;
                int nID = GET_WM_COMMAND_ID(wParam, lParam);
                ULONG ulObjType = (nID == IDM_LVCONTEXT_NEWCONTACT || nID == IDC_ADDRBK_BUTTON_NEW) ? MAPI_MAILUSER : MAPI_DISTLIST;
                LPSBinary lpsbContEID = NULL;

                if(bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
                    lpsbContEID = GetCurrentComboSelection(GetDlgItem(hDlg,IDC_ADDRBK_COMBO_CONT));

                lpAP->bLDAPinProgress = TRUE;
                lpAP_bDontRefresh = TRUE;

                AddNewObjectToListViewEx(   lpAP->lpIAB, _hWndAddr, NULL, NULL, 
                                            lpsbContEID,
                                            ulObjType,
                                            &(lpAP->SortInfo), lpAP_lppContentsList, &ftLast, &cbEID, &lpEID);

                FreeBufferAndNull(&lpEID);
                SetFocus(_hWndAddr);
                lpAP->bDeferNotification = TRUE;
                lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;
            }
			break;


        case IDM_LVCONTEXT_ADDWELL1:
        case IDC_ADDRBK_BUTTON_TO:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiTo = MAPI_TO;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiTo = lpAP->lpAdrParms->lpulDestComps[0];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_TO, lpAP_lppListTo, ulMapiTo))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_ADDWELL2:
        case IDC_ADDRBK_BUTTON_CC:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiCC = MAPI_CC;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiCC = lpAP->lpAdrParms->lpulDestComps[1];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_CC, lpAP_lppListCC, ulMapiCC))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_ADDWELL3:
        case IDC_ADDRBK_BUTTON_BCC:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiBCC = MAPI_BCC;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiBCC = lpAP->lpAdrParms->lpulDestComps[2];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_BCC, lpAP_lppListBCC, ulMapiBCC))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_FIND:
        case IDC_ADDRBK_BUTTON_FIND:
            if(!lpAP->bLDAPinProgress)
            {
                ADRPARM_FINDINFO apfi = {0};
                LPADRPARM_FINDINFO lpapfi = NULL;
                ULONG ulOldFlags = lpAP->lpAdrParms->ulFlags;
                lpAP->bLDAPinProgress = TRUE;

				apfi.DialogState = lpAP->DialogState;

                if (lpAP->DialogState==STATE_SELECT_RECIPIENTS)
                {
                    apfi.lpAdrParms = lpAP->lpAdrParms;
                    apfi.lppTo = lpAP_lppListTo;
                    apfi.lppCC = lpAP_lppListCC;
                    apfi.lppBCC = lpAP_lppListBCC;
                    lpapfi = &apfi;
                }
				else if (lpAP->DialogState == STATE_PICK_USER)
				{
                    TCHAR sz[MAX_UI_STR];
					LPTSTR lpsz = NULL;

                    LoadString(hinstMapiX, idsPickUserSelect, sz, CharSizeOf(sz));
                    lpsz = (LPTSTR) sz;

                    apfi.lpAdrParms = lpAP->lpAdrParms;
					apfi.lpAdrParms->cDestFields = 1;
					apfi.lpAdrParms->lppszDestTitles = &lpsz; // <TBD> use resource
                    apfi.lpAdrParms->ulFlags |= MAPI_UNICODE;
					apfi.cbEntryID = 0;
					apfi.lpEntryID = NULL;
					apfi.nRetVal = 0;
                    lpapfi = &apfi;
					{
						// Setup the Find persistent info to show the name we are trying to resolve
						ULONG i;
					    LPPTGDATA lpPTGData=GetThreadStoragePointer();
						for(i=0;i<ldspMAX;i++)
						{
							lstrcpy(pt_LDAPsp.szData[i], szEmpty);
						}
                        if(*(lpAP->lppAdrList))
                        {
						    for(i=0;i<(*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
						    {
                                ULONG ulPropTag = PR_DISPLAY_NAME;
                                if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
							    if ((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
							    {
                                    LPTSTR lpTitle = NULL;
                                    SET_UNICODE_STR(lpTitle, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
								    lstrcpy(pt_LDAPsp.szData[ldspDisplayName], lpTitle);
                                    FREE_UNICODE_STR(lpTitle, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
								    break;
							    }
						    }
                        }
					}
				}

                //lpAP_bDontRefresh = TRUE;
                HrShowSearchDialog(lpAP->lpIAB,
                                   hDlg,
                                   lpapfi,
                                   (LPLDAPURL) NULL,
                                   &(lpAP->SortInfo));

                //lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;

                // reset
                lpAP->lpAdrParms->ulFlags = ulOldFlags;

                if (lpAP->DialogState == STATE_PICK_USER)
				{
					// Reset these fake values
					lpAP->lpAdrParms->cDestFields = 0;
					lpAP->lpAdrParms->lppszDestTitles = NULL; // <TBD> use resource

					// If the above dialog was CANCELed or CLOSEd, we dont do anything
					// If the above dialog was closed with the Use button, then we basically
					// have the person we were looking for .. we will just return that name
					// and EntryID because that is all we need to return
					if((lpapfi->nRetVal == SEARCH_USE) &&
						lpapfi->lpEntryID &&
						lpapfi->cbEntryID)
					{
                        HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        // Prevent the user from doing anything on this window ..
                        EnableWindow(hDlg, FALSE);

						// Figure out what to do here ...
						// We could add a hidden item to the listview, select it and send
						// an ok message to the dialog which would then do the needful.
						if(HR_FAILED(HrUpdateAdrListEntry(	
											lpAP->lpIAB,
											lpapfi->lpEntryID,
											lpapfi->cbEntryID,
                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE)?MAPI_UNICODE:0,
											lpAP->lppAdrList)))
						{
							lpAP->nRetVal = -1;
						}
						else
						{
							lpAP->nRetVal = ADDRESS_OK;
						}
						LocalFreeAndNull(&(lpapfi->lpEntryID));
                        lpapfi->cbEntryID = 0;
						// Since we've done our processing, we'll fall thru to
						// the cancel dialog
                        SetCursor(hOldCur);
				        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_CANCEL, 0);
					}

				}

            }
            break;


		case IDC_ADDRBK_EDIT_QUICKFIND:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
			    switch(HIWORD(wParam)) //check the notification code
			    {
			    case EN_CHANGE: //edit box changed
    /***/
				    DoLVQuickFind((HWND)lParam,_hWndAddr);
    /***
                    DoLVQuickFilter(lpAP->lpIAB,
                                    (HWND)lParam,
                                    _hWndAddr,
                                    &(lpAP->SortInfo),
                                    AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL,
                                    1,
                                    lpAP_lppContentsList);
    ***/
				    break;
			    }
                lpAP->bLDAPinProgress = FALSE;
            }
			break;

        case IDOK:
        case IDC_ADDRBK_BUTTON_OK:
            if(!lpAP->bLDAPinProgress)
            {
            HCURSOR hOldCur;

            lpAP->nRetVal = ADDRESS_OK;

            lpAP->hWaitCur = LoadCursor(NULL, IDC_WAIT);
            hOldCur = SetCursor(lpAP->hWaitCur);
            lpAP->bLDAPinProgress = TRUE;
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, MAKELONG(TRUE, 0));

            //ShowWindow(hDlg, SW_HIDE);

            //EnableWindow(hDlg, FALSE);
            //SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_FIND), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_CC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_BCC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC), FALSE);
            EnableWindow(_hWndAddr, FALSE);

            //
            //  Do  TEXT("OK") stuff here and then Fall Thru to the cancel stuff
            // in PSN_RESET where we clean up
            //

            // if the ADDRESS_ONE flag was set we're supposed to return the
            // selected entry
            //
            // else if wells were displayed we return the recipients in the AdrList
            //
            // else we dont change the AdrList ..
            //

            if (lpAP->DialogState == STATE_PICK_USER)
            {
                // We have been asked to return an entry in the LpAdrList,
                // we dont care about recipient type - just Display Name and EntryID

                // First check if anything is selected at all
                int iItemIndex = ListView_GetNextItem(_hWndAddr,-1,LVNI_SELECTED);
                if (iItemIndex != -1)
                {
                    LPRECIPIENT_INFO lpItem = GetItemFromLV(_hWndAddr, iItemIndex);
                    if (lpItem)
                    {
						if(HR_FAILED(HrUpdateAdrListEntry(	
											lpAP->lpIAB,
											lpItem->lpEntryID,
											lpItem->cbEntryID,
                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE)?MAPI_UNICODE:0,
											lpAP->lppAdrList)))
						{
							lpAP->nRetVal = -1;
						}
                    }
                }
            }
            else if ((lpAP->DialogState==STATE_SELECT_RECIPIENTS) && ((*lpAP_lppListTo)||(*lpAP_lppListCC)||(*lpAP_lppListBCC)))
            {
                //
                //if user selected something in the TO/CC wells, we want to return
                //a relevant AdrList back ...
                //
                ULONG ulcEntryCount = 0;
                LPRECIPIENT_INFO lpItem = NULL;

                //
                // get a count of how many elements we need to return
                //
                lpItem = (*lpAP_lppListTo);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                lpItem = (*lpAP_lppListCC);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                lpItem = (*lpAP_lppListBCC);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                if (ulcEntryCount != 0)
                {
                    ULONG nIndex = 0;
                    LPADRENTRY lpAdrEntryTemp = NULL;
                    LPADRLIST lpAdrList = NULL;
                    SCODE sc;
                    BOOL bProcessingCC = FALSE;

                    //
                    // if there was something in the passed in AdrList, free it and
                    // create a new list
                    //

                    if(!FAILED(sc = MAPIAllocateBuffer(    sizeof(ADRLIST) + ulcEntryCount * sizeof(ADRENTRY),
                                                &lpAdrList)))
                    {
                        lpAdrList->cEntries = ulcEntryCount;

                        nIndex = 0;

                        // Start getting items from the TO list
                        lpItem = (*lpAP_lppListTo);

                        while(nIndex < ulcEntryCount)
                        {
                            if (lpItem == NULL)
                            {
                                if (bProcessingCC == FALSE)
                                {
                                    lpItem = (*lpAP_lppListCC);
                                    bProcessingCC = TRUE;
                                }
                                else
                                    lpItem = (*lpAP_lppListBCC);
                            }

                            if (lpItem != NULL)
                            {
                                LPSPropValue rgProps = NULL;
                                ULONG cValues = 0;
                                LPSPropValue lpPropArrayNew = NULL;
                                ULONG cValuesNew = 0;
                                LPTSTR lpszTemp = NULL;
                                LPVOID lpbTemp = NULL;
                                ULONG i = 0;
                                SCODE sc;
                                HRESULT hr = hrSuccess;

                                //reset hr
                                hr = hrSuccess;


                                // We are walking through our linked lists representing the TO and CC
                                // selected recipients. We want to return proper set of existing props
                                // for all the resolved users and the passed in set of props for the
                                // unresolved user. Hence we compare to see what we can get for each
                                // individual user. For unresolved users, the only distinctive criteria is
                                // their display name .. we have no other information .. <TBD> this is
                                // problematic because if there are 2 entries in the input adrlist with the
                                // same unresolved display name, even if they have difference rgPropVals
                                // we might end up giving them identical ones back .... what to do .. <TBD>


                                // Items that have entry ids are resolved ... items that dont have entryids
                                // are not resolved ...

                                if (lpItem->cbEntryID != 0) 
                                {
                                    // if this was an item from the original list .. we dont really
                                    // want to mess with it irrespective of whether it is a resolved
                                    // or unresolved entry.
                                    // However, if this is a new entry, then we want to get its
                                    // minimum props from the store ...

                                    if (lpItem->ulOldAdrListEntryNumber == 0)
                                    {

                                        //resolved entry
                                        hr = HrGetPropArray(lpAP->lpIAB,
                                                            (LPSPropTagArray) &ptaResolveDefaults,
                                                            lpItem->cbEntryID,
                                                            lpItem->lpEntryID,
                                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE) ? MAPI_UNICODE : 0,
                                                            &cValues,
                                                            &rgProps);
                                    }
                                    else
                                    {
                                        rgProps = NULL;
                                        cValues = 0;
                                    }

                                    if (!HR_FAILED(hr))
                                    {
                                        if(lpItem->ulOldAdrListEntryNumber != 0)
                                        {
                                            ULONG index = lpItem->ulOldAdrListEntryNumber - 1; //remember the increment-by-one ..

                                            // This is from the original entry list ...
                                            // We want to merge the newly generated properties with the old
                                            // original properties .. the original properties will include a
                                            // PR_RECIPIENT_TYPE (or this entry would have been rejected)

                                            sc = ScMergePropValues( (*(lpAP->lppAdrList))->aEntries[index].cValues,
                                                                    (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                    cValues,
                                                                    rgProps,
                                                                    &cValuesNew,
                                                                    &lpPropArrayNew);

                                            if (sc != S_OK)
                                            {
                                                // If errors then dont merge .. just take the temp set of props
                                                // in rgProps
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = rgProps;
                                                cValuesNew = cValues;
                                                lpAP->nRetVal = -1;
                                            }
                                            else
                                            {
                                                // merged successfully, discard the temp sets of props
                                                if (rgProps)
                                                    MAPIFreeBuffer(rgProps);
                                            }
                                        }
                                        else
                                        {
                                            // totally new item
                                            // we have to give it a valid PR_RECIPIENT_TYPE
                                            // so create a new one and merge it with the above props
                                            SPropValue Prop = {0};
                                            Prop.ulPropTag = PR_RECIPIENT_TYPE;
                                            Prop.Value.l = lpItem->ulRecipientType;

                                            sc = ScMergePropValues( 1,
                                                                    &Prop,
                                                                    cValues,
                                                                    rgProps,
                                                                    &cValuesNew,
                                                                    &lpPropArrayNew);
                                            if (sc != S_OK)
                                            {
                                                // oops this failed
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = NULL;
                                                lpAP->nRetVal = -1;
                                            }

                                            //free rgProps
                                            if (rgProps)
                                                MAPIFreeBuffer(rgProps);

                                        } // end have previous adr list items

                                        // [PaulHi] 2/15/99  Make sure that the new property string
                                        // values are converted to ANSI if our client is non-UNICODE.
                                        if ( !FAILED(sc) && !(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE) && lpPropArrayNew )
                                        {
                                            sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0);
                                            if (FAILED(sc))
                                            {
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = NULL;
                                                lpAP->nRetVal = -1;
                                            }
                                        }

                                    } // end GetProps succeeded
                                }
                                else
                                {
                                    // this is an unresolved entry
                                    // we need to get its original sets of props from the original AdrList
                                    if (lpItem->ulOldAdrListEntryNumber == 0)
                                    {
                                        // ouch - this kind of error shouldnt have happened
                                        DebugPrintError(( TEXT("Address: Unresolved entry has no index number!!!\n")));
                                        lpAP->nRetVal = -1; //error code
                                    }
                                    else
                                    {
                                        ULONG cb = 0;
                                        ULONG index = lpItem->ulOldAdrListEntryNumber - 1; //remember to decrement the +1 increment

                                        cValuesNew = (*(lpAP->lppAdrList))->aEntries[index].cValues;
                                        // copy over the props from our old array into a new one
                                        if (!(FAILED(sc = ScCountProps(   cValuesNew,
                                                                        (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                        &cb))))
                                        {
                                            if (!(FAILED(sc = MAPIAllocateBuffer(cb, &lpPropArrayNew))))
                                            {

                                                if (FAILED(sc = ScCopyProps(    cValuesNew,
                                                                                (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                                lpPropArrayNew,
                                                                                NULL)))
                                                {
                                                    DebugPrintError(( TEXT("Address: ScCopyProps fails!!!\n")));
                                                    lpAP->nRetVal = -1;
                                                }
                                            }
                                            else
                                            {
                                                lpAP->nRetVal = -1;
                                            }
                                        }
                                        else
                                        {
                                            lpAP->nRetVal = -1;
                                        }
                                    }
                                }
                                // At this point, if we've still got no errors,
                                // we should have a valid lpPropArrayNew and cValuesNew which we should
                                // be able to add to our new AdrList
                                if (lpAP->nRetVal != -1)
                                {
                                    lpAdrList->aEntries[nIndex].cValues = cValuesNew;
                                    lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                                }
                                else
                                {
                                    // some error
                                    if (lpPropArrayNew)
                                    {
                                        MAPIFreeBuffer(lpPropArrayNew);
                                        lpPropArrayNew = NULL;
                                    }
                                }

                                lpItem = lpItem->lpNext;
                                nIndex++;
                            }
                        }

                        if (*(lpAP->lppAdrList))
                        {
                            FreePadrlist(*(lpAP->lppAdrList));
                        }

                        *(lpAP->lppAdrList) = lpAdrList;

                    }
                }




            }
            else if ((lpAP->DialogState==STATE_SELECT_RECIPIENTS) && ((*lpAP_lppListTo)==NULL) && ((*lpAP_lppListCC)==NULL) && ((*lpAP_lppListBCC)==NULL))
            {
                // we were asked to select recipients but if these pointers are null
                // then the user deleted the entries in the wells and we thus dont
                // want to return anything. So free the lpaddrlist
                // and make it NULL

                if (*(lpAP->lppAdrList))
                {
                    // Bug 27483 - dont NULL the lpAdrList - just set cEntries to 0
                    ULONG iEntry = 0;
                    for (iEntry = 0; iEntry < (*(lpAP->lppAdrList))->cEntries; iEntry++) 
                    {
                        MAPIFreeBuffer((*(lpAP->lppAdrList))->aEntries[iEntry].rgPropVals);
                    }
                    (*(lpAP->lppAdrList))->cEntries = 0;
                }
            }

            //
            // Save the sort info to the registry
            //
            if(lpAP->DialogState != STATE_PICK_USER)
                WriteRegistrySortInfo((LPIAB)lpAP->lpIAB, lpAP->SortInfo);

            lpAP->bLDAPinProgress = FALSE;
            lpAP->hWaitCur = NULL;
            SetCursor(hOldCur);
            }
            // fall thru to cleanup code

        case IDCANCEL:
        case IDC_ADDRBK_BUTTON_CANCEL:
            if(!lpAP->bLDAPinProgress)
            {
                if ((lpAP->nRetVal != ADDRESS_OK) && // Are we falling thru from above ??
                    (lpAP->nRetVal != -1) ) // or did someone trigger an error above ??
                {
                    // if not ..
                    lpAP->nRetVal = ADDRESS_CANCEL;
                }

                if ((*lpAP_lppContentsList))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_ADDRESSES),
                                    lpAP_lppContentsList);

                if ((*lpAP_lppListTo))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO),
                                    lpAP_lppListTo);

                if ((*lpAP_lppListCC))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC),
                                    lpAP_lppListCC);

                if ((*lpAP_lppListBCC))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC),
                                    lpAP_lppListBCC);

                lpAP->bLDAPinProgress = FALSE;

                EndDialog(hDlg,lpAP->nRetVal);

                return TRUE;
            }
            break;

        }
        break;

    case WM_CLOSE:
        //treat it like a cancel button
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_CANCEL, 0);
        break;

	case WM_CONTEXTMENU:
        {
            int id = GetDlgCtrlID((HWND)wParam);
            //
            //This call to the context menu may generate any one of several
            //command messages - for properties and for delete, we need to
            //know which List View initiated the command ...
            //
            lpAP->nContextID = id;
            switch(id)
            {
            case IDC_ADDRBK_LIST_ADDRESSES:
                if (lpAP->DialogState == STATE_BROWSE_MODAL)
    			    ShowLVContextMenu(  lvDialogModalABContents,
                                        (HWND)wParam,
                                        NULL, //GetDlgItem(hDlg, IDC_ADDRBK_COMBO_SHOWNAMES),
                                        lParam,
                                        (LPVOID) lpAP->lpAdrParms,
                                        lpAP->lpIAB, NULL);
                else
    			    ShowLVContextMenu(  lvDialogABContents,
                                        (HWND)wParam,
                                        NULL, //GetDlgItem(hDlg, IDC_ADDRBK_COMBO_SHOWNAMES),
                                        lParam,
                                        (LPVOID) lpAP->lpAdrParms,
                                        lpAP->lpIAB, NULL);
                break;

            case IDC_ADDRBK_LIST_TO:
    			ShowLVContextMenu(lvDialogABTo,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            case IDC_ADDRBK_LIST_BCC:
    			ShowLVContextMenu(lvDialogABCC,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            case IDC_ADDRBK_LIST_CC:
    			ShowLVContextMenu(lvDialogABBCC,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            default:
                //reset it ..
                lpAP->nContextID = -1;
                WABWinHelp((HWND) wParam,
                        g_szWABHelpFileName,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID) rgAddrHelpIDs );
                break;
            }
        }
        break;


    case WM_NOTIFY:
        {
            LV_DISPINFO * pLvdi = (LV_DISPINFO *)lParam;
            NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;

            switch((int) wParam)
            {
            case IDC_ADDRBK_LIST_TO:
            case IDC_ADDRBK_LIST_CC:
            case IDC_ADDRBK_LIST_BCC:
                switch(((LV_DISPINFO *)lParam)->hdr.code)
                {
                case LVN_KEYDOWN:
                    switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                    {
                    case VK_DELETE:
                        if ((int) wParam == IDC_ADDRBK_LIST_TO)
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListTo);
                        else if ((int) wParam == IDC_ADDRBK_LIST_CC)
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListCC);
                        else
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListBCC);
                        break;
                    }
                    break;

                case NM_SETFOCUS:
                    lpAP->nContextID = GetDlgCtrlID(((NM_LISTVIEW *)lParam)->hdr.hwndFrom);
                    break;

                case NM_DBLCLK:
                    //properties of the item ...
                    lpAP->nContextID = GetDlgCtrlID(((NM_LISTVIEW *)lParam)->hdr.hwndFrom);
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDM_LVCONTEXT_PROPERTIES, 0);
                    break;

	            case NM_CUSTOMDRAW:
                    return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                    break;
                }
                break;


            case IDC_ADDRBK_LIST_ADDRESSES:

                switch(pLvdi->hdr.code)
                {
                case LVN_KEYDOWN:
                    switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                    {
                    case VK_DELETE:
                        if (lpAP->DialogState == STATE_BROWSE_MODAL)
                            SendMessage(hDlg, WM_COMMAND, IDC_ADDRBK_BUTTON_DELETE, 0);
                        break;
                    }
                    break;

                case LVN_COLUMNCLICK:
                    SortListViewColumn((LPIAB)lpAP->lpIAB, pNm->hdr.hwndFrom, pNm->iSubItem, &(lpAP->SortInfo), FALSE);
                    break;

                case NM_CLICK:
                case NM_RCLICK:
                    if(lpAP->DialogState == STATE_PICK_USER)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                        {
                            //Nothing is selected .. dont let them say OK
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),FALSE);
                            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),TRUE);
                            SendMessage (hDlg, DM_SETDEFID, IDOK, 0);
                        }
                    }

                    break;

                case NM_SETFOCUS:
                    lpAP->nContextID = GetDlgCtrlID(pNm->hdr.hwndFrom);
                    if(lpAP->DialogState == STATE_PICK_USER)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                        {
                            //Nothing is selected .. dont let them say OK
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),FALSE);
                            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),TRUE);
                            SendMessage (hDlg, DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;

                case NM_DBLCLK:
                    {
                        //if an entry is selected - do this - otherwise dont do anything
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                            break;
                        {
                            //DWORD dwDefId = SendMessage(hDlg, DM_GETDEFID, 0, 0);
                            //if(dwDefId)
                            //    SendMessage(hDlg, WM_COMMAND, (WPARAM) LOWORD(dwDefId), 0);
                            SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_TO + lpAP->lpAdrParms->nDestFieldFocus, 0);
                        }
                    }
                    break;

	            case NM_CUSTOMDRAW:
                    return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                    break;
                }
                break;

            }
        }
        break;

    default:
        if( (g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), message, wParam, lParam);
            else if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), message, wParam, lParam);
            else if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), message, wParam, lParam);
            else
                SendMessage(_hWndAddr, message, wParam, lParam);
        }
        break;

    }

    return FALSE;

}

/////////////////////////////////////////////////////////////////////////////////
//
// ListAddItem - Adds an item to the wells
//
//  hDlg - HWND of parent
//  hWndAddr - HWND of source ListView from which the item will be added
//  CtlID - control ID of the target list view
//  lppList - Item list corresponding to the target list view to which this item will be appended
//  RecipientType - Specified recipient type to tag the new item with
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType)
{
    BOOL bRet = FALSE;
    int iItemIndex = 0;
    HWND hWndList = GetDlgItem(hDlg,CtlID);


    iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
    if (iItemIndex != -1)
    {
        int iLastIndex = 0;
        do
        {
            // otherwise get the entry id of this thing
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndAddr, iItemIndex);
            if (lpItem)
            {
                LV_ITEM lvI;
                LPRECIPIENT_INFO lpNew = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));

                if(!lpNew)
                {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                }

                lpNew->ulObjectType = lpItem->ulObjectType;
                lstrcpy(lpNew->szDisplayName, lpItem->szDisplayName);
                lstrcpy(lpNew->szByFirstName, lpItem->szByFirstName);
                lstrcpy(lpNew->szByLastName, lpItem->szByLastName);
                lstrcpy(lpNew->szEmailAddress, lpItem->szEmailAddress);
                lstrcpy(lpNew->szHomePhone, lpItem->szHomePhone);
                lstrcpy(lpNew->szOfficePhone, lpItem->szOfficePhone);
                lpNew->bHasCert = lpItem->bHasCert;
                lpNew->ulRecipientType = RecipientType;
                lpNew->ulOldAdrListEntryNumber = 0; //Flag this as not from the original AdrList
                if (lpItem->cbEntryID)
                {
                    lpNew->cbEntryID = lpItem->cbEntryID;
                    lpNew->lpEntryID = LocalAlloc(LMEM_ZEROINIT, lpItem->cbEntryID);
                    if(!lpNew->lpEntryID)
                    {
                        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                        goto out;
                    }
                    CopyMemory(lpNew->lpEntryID,lpItem->lpEntryID,lpItem->cbEntryID);
                }

                lpNew->lpNext = (*lppList);
                if (*lppList)
                    (*lppList)->lpPrev = lpNew;
                lpNew->lpPrev = NULL;
                (*lppList) = lpNew;

                lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                lvI.state = 0;
                lvI.stateMask = 0;
                lvI.iSubItem = 0;
                lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

                lvI.iImage = GetWABIconImage(lpNew);

                // now fill in the List
                lvI.iItem = ListView_GetItemCount(hWndList);
                lvI.pszText = lpNew->szDisplayName;
                lvI.lParam = (LPARAM) lpNew;
                ListView_InsertItem(hWndList, &lvI);
                ListView_EnsureVisible(hWndList,ListView_GetItemCount(hWndList)-1,FALSE);
            }
            iLastIndex = iItemIndex;
            // Get next selected item ...
            iItemIndex = ListView_GetNextItem(hWndAddr,iLastIndex,LVNI_SELECTED);
        } while (iItemIndex != -1);
        //SetFocus(hWndAddr);
    }
    else
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEMS_ADD, MB_ICONEXCLAMATION);
        goto out;
    }

    if((ListView_GetItemCount(hWndList) > 0) &&
        (ListView_GetSelectedCount(hWndList) <= 0))
        LVSelectItem(hWndList, 0);

    bRet = TRUE;

out:
    return bRet;

}

/////////////////////////////////////////////////////////////////////////////////
//
// ListDeleteItem - deletes an item from the Wells - unlike the Address COntents list we
// make sure to delete it here because we want the linked lists to only have valid entries
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ListDeleteItem(HWND hDlg, int CtlID, LPRECIPIENT_INFO * lppList)
{
    BOOL bRet = TRUE;
    LPRECIPIENT_INFO lpItem = NULL;
    HWND hWndAddr =  GetDlgItem(hDlg,CtlID);
    int iItemIndex=0;

    iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
    if (iItemIndex != -1)
    {
        int iLastItem = 0;
        do
        {
            // otherwise get the entry id of this thing
            lpItem = GetItemFromLV(hWndAddr, iItemIndex);
            if (lpItem)
            {
                // remove this item from our linked list of arrays
                // if this is the first item in the list then handle that special case too

                if ((*lppList) == lpItem)
                    (*lppList) = lpItem->lpNext;
                if (lpItem->lpNext)
                    lpItem->lpNext->lpPrev = lpItem->lpPrev;
                if (lpItem->lpPrev)
                    lpItem->lpPrev->lpNext = lpItem->lpNext;

                // we need to update our display
                ListView_DeleteItem(hWndAddr,iItemIndex);
                //UpdateWindow(hWndAddr);

                FreeRecipItem(&lpItem);
            }
            iLastItem = iItemIndex;
            // Get next selected item ...
            iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
        }while (iItemIndex != -1);

        // select the previous or next item ...
        if (iLastItem >= ListView_GetItemCount(hWndAddr))
            iLastItem = ListView_GetItemCount(hWndAddr) - 1;
		LVSelectItem(hWndAddr, iLastItem);
    }
    SetFocus(hWndAddr);

    return bRet;

}


/////////////////////////////////////////////////////////////////////////////////
//
// FillWells - Dismembers the lpAdrList to create the To and CC wells
//
//  Scans the AdrEntry Structures in the LpAdrList, looks at PR_RECIPIENT_TYPE,
//      ignores entries which it cant understand ... creates a temporary linked
//      list of To and CC recipient lists which are used to populate the
//      To and CC List boxes
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillWells(HWND hDlg, LPADRLIST lpAdrList, LPADRPARM lpAdrParms, LPRECIPIENT_INFO * lppListTo, LPRECIPIENT_INFO * lppListCC, LPRECIPIENT_INFO * lppListBCC)
{
    BOOL bRet = FALSE;
    LPRECIPIENT_INFO lpNew = NULL;
    LPADRENTRY lpAdrEntry = NULL;
    ULONG i=0,j=0,nLen=0;
    int index=0;
    LV_ITEM lvI;
    HWND hWndAddr = NULL;
    ULONG ulMapiTo = MAPI_TO;
    ULONG ulMapiCC = MAPI_CC;
    ULONG ulMapiBCC = MAPI_BCC;
    BOOL bUnicode = (lpAdrParms->ulFlags & MAPI_UNICODE);

    *lppListTo = NULL;
    *lppListCC = NULL;
    *lppListBCC = NULL;

    if (lpAdrList == NULL) //nothing to do
    {
        bRet = TRUE;
        goto out;
    }

    //
    // The Input AdrParms structure has a lpulDestComps field that lets the
    // caller specify his own recipient types. If this is missing, we are supposed
    // to use the default recipient types.
    //
            if ((lpAdrParms->cDestFields > 0) && (lpAdrParms->lpulDestComps))
            {
                ULONG i=0;
                for (i=0;i<lpAdrParms->cDestFields;i++)
                {
                    switch(i)
                    {
                    case 0:
                        ulMapiTo = lpAdrParms->lpulDestComps[i];
                        break;
                    case 1:
                        ulMapiCC = lpAdrParms->lpulDestComps[i];
                        break;
                    case 2:
                        ulMapiBCC = lpAdrParms->lpulDestComps[i];
                        break;
                    }
                }
            }



    for(i=0; i < lpAdrList->cEntries; i++)
    {
        lpAdrEntry = &(lpAdrList->aEntries[i]);
        if (lpAdrEntry->cValues != 0)
        {
            TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];
            ULONG ulRecipientType = 0;
            ULONG ulObjectType = 0;
            ULONG cbEntryID = 0;
            BOOL bHasCert = FALSE;
            LPENTRYID lpEntryID = NULL;
            szBuf[0]='\0';

            for(j=0;j<lpAdrEntry->cValues;j++)
            {
                ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
                
                if(!bUnicode && PROP_TYPE(ulPropTag) == PT_STRING8)
                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

                switch(ulPropTag)
                {
                case(PR_DISPLAY_NAME):
                    {
                        LPTSTR lpNameW = NULL;
                        SET_UNICODE_STR(lpNameW, lpAdrEntry->rgPropVals[j].Value.LPSZ,lpAdrParms);
                        nLen = CopyTruncate(szBuf, lpNameW, MAX_DISPLAY_NAME_LENGTH);
                        FREE_UNICODE_STR(lpNameW, lpAdrEntry->rgPropVals[j].Value.LPSZ);
                    }
                    break;
                case(PR_RECIPIENT_TYPE):
                    ulRecipientType = lpAdrEntry->rgPropVals[j].Value.l;
                    break;
                case(PR_OBJECT_TYPE):
                    ulObjectType = lpAdrEntry->rgPropVals[j].Value.l;
                    break;
                case(PR_ENTRYID):
                    cbEntryID = lpAdrEntry->rgPropVals[j].Value.bin.cb;
                    lpEntryID = (LPENTRYID) lpAdrEntry->rgPropVals[j].Value.bin.lpb;
                    break;
                case PR_USER_X509_CERTIFICATE:
                    bHasCert = TRUE;
                    break;
                }
            }


            if (lstrlen(szBuf) && ((ulRecipientType == ulMapiBCC) || (ulRecipientType == ulMapiTo) || (ulRecipientType == ulMapiCC)))
            {
                lpNew = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
                if(!lpNew)
                {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                }

                // ***NOTE***
                // Store this index number, ie 1st item in AdrList is 1, then 2, 3, so on
                // we do a plus 1 here because 0 value means it wasnt passed in and thus the
                // minimum valid value is 1
                lpNew->ulOldAdrListEntryNumber = i+1;

                lpNew->bHasCert = bHasCert;
                lstrcpy(lpNew->szDisplayName,szBuf);
                lpNew->ulRecipientType = ulRecipientType;
                lpNew->ulObjectType = ulObjectType;

                if (cbEntryID != 0)
                {
                    lpNew->cbEntryID = cbEntryID;
                    lpNew->lpEntryID = LocalAlloc(LMEM_ZEROINIT,cbEntryID);
                    if(!lpNew->lpEntryID)
                    {
                        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                        goto out;
                    }
                    CopyMemory(lpNew->lpEntryID,lpEntryID,cbEntryID);
                }

                if (ulRecipientType == ulMapiTo)
                {
                    lpNew->lpNext = *lppListTo;
                    if (*lppListTo)
                        (*lppListTo)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListTo = lpNew;
                }
                else if (ulRecipientType == ulMapiCC)
                {
                    lpNew->lpNext = *lppListCC;
                    if (*lppListCC)
                        (*lppListCC)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListCC = lpNew;
                }
                else if (ulRecipientType == ulMapiBCC)
                {
                    lpNew->lpNext = *lppListBCC;
                    if (*lppListBCC)
                        (*lppListBCC)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListBCC = lpNew;
                }
            }

        }
    }

    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

    for(i=0;i<3;i++)
    {
        switch(i)
        {
        case 0:
            lpNew = *lppListTo;
            break;
        case 1:
            lpNew = *lppListCC;
            break;
        case 2:
            lpNew = *lppListBCC;
            break;
        }

        hWndAddr = GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO+i);
        index = 0;
        while(lpNew)
        {
            lvI.iItem = index;
            lvI.pszText = lpNew->szDisplayName;
            lvI.lParam = (LPARAM) lpNew;

            lvI.iImage = GetWABIconImage(lpNew);

            ListView_InsertItem(hWndAddr, &lvI);

            index++;
            lpNew = lpNew->lpNext;
        }
    }

    // We will highlight the first item in any filled list box
    // because basically that looks good when tabbing through them ...
    for(i=0;i<lpAdrParms->cDestFields;i++)
    {
        HWND hWndLV = GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO+i);

        if (ListView_GetItemCount(hWndLV) > 0)
            LVSelectItem(hWndLV,0);
    }


    bRet = TRUE;

out:

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////////
//
// SetAddressBookUI - juggles the address book UI in response to various parameters
//
//      This function will probably be more complex with each tier
//
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetAddressBookUI(HWND hDlg,
                      LPADDRESS_PARMS lpAP)
{
    BOOL bRet = FALSE;
    //LV_COLUMN lvC;
    RECT rc, rc1, rc2;
    POINT ptLU1,ptRB1;
    int nButtonsVisible = 0;
    int nButtonSpacing = 7;
    int nButtonWidth = 0;
    ULONG nLen = 0;
    TCHAR szBuf[MAX_UI_STR*4];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HWND hWndListAddresses = GetDlgItem(hDlg, IDC_ADDRBK_LIST_ADDRESSES);

    LPTSTR szCaption = NULL;

    SET_UNICODE_STR(szCaption, lpAP->lpAdrParms->lpszCaption,lpAP->lpAdrParms);

    if(!szCaption || !lstrlen(szCaption))
    {
        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szBuf, CharSizeOf(szBuf));
        szCaption = szBuf;
    }
    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
    {
        // Fill in the Combo with the container names
        FillContainerCombo(GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT), (LPIAB)lpAP->lpIAB);
    }
    else
    {
        HWND hWndCombo = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
        EnableWindow(hWndCombo, FALSE);
        ShowWindow(hWndCombo, SW_HIDE);

        // resize the listview to take place of the hidden combo
        GetWindowRect(hWndCombo,&rc2);
        GetWindowRect(hWndListAddresses,&rc);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);       
        ptLU1.x = rc2.left;
        ptLU1.y = rc2.top;
        ptRB1.x = rc.right;
        ptRB1.y = rc.bottom;
        MoveWindow(hWndListAddresses,ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);
    }

    //
    // There are only two states that need configuration -
    //  Pick User - in which we have to hide the wells
    // and
    //  Select Recipients, in which we have to hide the wells
    //  as per the input criteria and resize accordingly and
    //  also set the labels based on the input criteria
    //
    if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
    {
        SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_TO, 0);

        // in case the nDestFieldFocus parameter is supplied, use it ..
        if (
            (lpAP->lpAdrParms->nDestFieldFocus < lpAP->lpAdrParms->cDestFields))
        {
            if (lpAP->lpAdrParms->nDestFieldFocus == 1)
                SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_CC, 0);
            else if (lpAP->lpAdrParms->nDestFieldFocus == 2)
                SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_BCC, 0);
        }
    }
    else if (lpAP->DialogState == STATE_PICK_USER)
        SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
    else if (lpAP->DialogState == STATE_BROWSE_MODAL)
        SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_PROPS, 0);

    // Set the window caption
    if (szCaption)
        SetWindowText(hDlg,szCaption);

    // Set the caption over the destination wells
    if (lpAP->lpAdrParms->lpszDestWellsTitle)
    {
        LPWSTR lpTitle = NULL; // <note> assumes UNICODE defined
        SET_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lpszDestWellsTitle,lpAP->lpAdrParms);
        SetDlgItemText(hDlg,IDC_ADDRBK_STATIC_RECIP_TITLE,lpTitle);
        FREE_UNICODE_STR(lpTitle, lpAP->lpAdrParms->lpszDestWellsTitle);
    }

    if (lpAP->DialogState == STATE_PICK_USER &&
        *(lpAP->lppAdrList) )
    {
        ULONG i=0;
        LPTSTR lpszRecipName = NULL;

        //Get the user whose name we are trying to find
        for(i=0;i<(*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
        {
            ULONG ulPropTag = PR_DISPLAY_NAME;
            if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
            if ((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
            {
                SET_UNICODE_STR(lpszRecipName,(*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
                break;
            }
        }

        if(lpszRecipName)
        {
            LPTSTR lpszBuffer = NULL;
            TCHAR szTmp[MAX_PATH], *lpszTmp;

			LoadString(hinstMapiX, IDS_ADDRBK_RESOLVE_CAPTION, szBuf, CharSizeOf(szBuf));

            CopyTruncate(szTmp, lpszRecipName, MAX_PATH - 1);
            lpszTmp = szTmp;

            if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szBuf,
                                0,0, //ignored
                                (LPTSTR) &lpszBuffer,
                                MAX_UI_STR,
                                (va_list *)&lpszTmp))
            {
                // if the display name is too long, it doesnt show up properly in the UI ..
                // so we will purposely limit the visible portion to 64 characters - arbitarily defined limit..
                szBuf[0]='\0';
                nLen = CopyTruncate(szBuf, lpszBuffer, 2 * MAX_DISPLAY_NAME_LENGTH);

                LocalFreeAndNull(&lpszBuffer);
            }

            //Increase the size of the static control to = what the Contents List width will be
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS),&rc2);
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc);
            //
            //This api working in both mirrored and unmirrored windows.
            //
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);            
            ptLU1.x = rc2.left;
            ptLU1.y = rc2.top;
            ptRB1.x = rc.right;
            ptRB1.y = rc2.bottom;
            MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS),ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);

            SetDlgItemText(hDlg,IDC_ADDRBK_STATIC_CONTENTS,szBuf);

            FREE_UNICODE_STR(lpszRecipName,(*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
        }

    }


    if (lpAP->DialogState == STATE_PICK_USER)
    {
        // If ADDRESS_ONE has been selected, then make the IDC_ADDRBK_LIST_ADDRESSES
        // single selection only
        DWORD dwStyle;
        dwStyle = GetWindowLong(hWndListAddresses, GWL_STYLE);
        SetWindowLong(hWndListAddresses, GWL_STYLE, dwStyle | LVS_SINGLESEL);
    }

    if ((lpAP->DialogState == STATE_PICK_USER)||(lpAP->DialogState == STATE_BROWSE_MODAL))
    {
        int i = 0;
        // Dont show wells which means we have to do some rearranging
        //  * Hide the wells and the To, CC, BCC buttons
        //  * Resize the IDC_ADDRBK_LIST_ADDRESSES to fill the whole dialog
        //  * Move the 3 buttons below it to the left side of the dialog
        //

        // Get the dimensions of the ToListBox
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc2);
        GetWindowRect(hWndListAddresses,&rc);
        //
        //This api works for in both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
        ptLU1.x = rc.left;
        ptLU1.y = rc.top;
        ptRB1.x = rc2.right;
        ptRB1.y = rc.bottom;

        MoveWindow(hWndListAddresses,ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);

        for(i=0;i<3;i++)
        {
            ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_TO + i), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO + i), SW_HIDE);
        }

        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_STATIC_RECIP_TITLE), SW_HIDE); //  TEXT("Message Recipients") label

    }

    // other things to do

    // Load Headers for List box
    GetWindowRect(hWndListAddresses,&rc);
	HrInitListView(hWndListAddresses, LVS_REPORT, TRUE);

    GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS),&rc2);
    nButtonsVisible = 2;

    nButtonWidth = (rc2.right - rc2.left);

    // get the new coordinates of the 1st visible button
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU1.x = rc.left;
    ptLU1.y = rc2.top;
    ptRB1.x = ptLU1.x + nButtonWidth;
    ptRB1.y = rc2.bottom;

    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
    ptLU1.x += nButtonWidth + nButtonSpacing;
    ptRB1.x = ptLU1.x + nButtonWidth;
    if (lpAP->DialogState == STATE_BROWSE_MODAL)
    {
        MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEWGROUP),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
        ptLU1.x += nButtonWidth + nButtonSpacing;
        ptRB1.x = ptLU1.x + nButtonWidth;
    }
    else
    {
        // The NewGroup button is visible only in the DialogModalView
        EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_NEWGROUP), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_NEWGROUP), SW_HIDE);
    }
    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
    ptLU1.x += nButtonWidth + nButtonSpacing;
    ptRB1.x = ptLU1.x + nButtonWidth;
    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_DELETE),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);


    // The delete button is visible only in the DialogModalView
    if (lpAP->DialogState != STATE_BROWSE_MODAL)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_DELETE), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_DELETE), SW_HIDE);
    }

    //
    // We now need to customize this window if we are selecting
    // recipients ...
    //
    if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
    {
        // We need to see which wells are visible and
        // then we need to resize the buttons based on their captions
        //
        int i=0;
        int nLen=0;
        int cDF = lpAP->lpAdrParms->cDestFields;
        int iLeft=0,iTop=0;

        SIZE size={0};
        ULONG MaxWidth=0;
        ULONG maxHeightPerLV = 0;
        HWND hw;
        HDC hdc=GetDC(hDlg);

        if (lpAP->lpAdrParms->lppszDestTitles)
        {
            for(i=0; i < cDF; i++)
            {
                LPTSTR lpTitle = NULL;
                ULONG Len = 0;
                SET_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lppszDestTitles[i],lpAP->lpAdrParms);
                if(!lpTitle)
                    continue;
                Len = lstrlen(lpTitle);
                if (Len > CharSizeOf(szBuf) - 4)
                {
                    ULONG iLen = TruncatePos(lpTitle, CharSizeOf(szBuf) - 4);
                    CopyMemory(szBuf,lpTitle,iLen*sizeof(TCHAR));
                    szBuf[iLen] = '\0';
                }
                else
                {
                    lstrcpy(szBuf,lpTitle);
                }
                lstrcat(szBuf,szArrow);
                if (lstrlen(szBuf) >= nLen)
                {
                    nLen = lstrlen(szBuf);
                    GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                    MaxWidth = size.cx;
                }
                // Set the new text
                SetDlgItemText(hDlg,IDC_ADDRBK_BUTTON_TO+i,szBuf);
                FREE_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lppszDestTitles[i]);
            }

        }

        ReleaseDC(hDlg,hdc);

        if (MaxWidth == 0)
        {
            //get the default width
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO),&rc1);
            MaxWidth = rc1.right - rc1.left;
        }

        //Get the maximum allowable height per well
        GetWindowRect(hWndListAddresses,&rc);
        GetChildClientRect(hWndListAddresses, &rc);
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW),&rc1);
        GetChildClientRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW), &rc1);
        maxHeightPerLV = (rc1.bottom-rc.top - (cDF - 1)*CONTROL_SPACING)/cDF;
        iTop = rc.top;

        for(i=0;i<cDF;i++)
        {
            hw = GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO + i);

            // resize the buttons to fit the text
            GetWindowRect(hw,&rc1);
            GetChildClientRect(hw,&rc1);
            MoveWindow(hw,rc1.left,iTop,MaxWidth,rc1.bottom - rc1.top,FALSE);

            iLeft = rc1.left + MaxWidth + 2*CONTROL_SPACING;

            // Move the list boxes to accomodate the resized buttons
            hw = GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO + i);
            GetWindowRect(hw, &rc1);
            GetChildClientRect(hw, &rc1);
            MoveWindow(hw,iLeft,iTop,rc1.right-iLeft,maxHeightPerLV,FALSE);

            ListView_SetExtendedListViewStyle(hw,LVS_EX_FULLROWSELECT);

            iTop += maxHeightPerLV + CONTROL_SPACING;

        }

        //Move the label over the wells and restrict it's size
        hw = GetDlgItem(hDlg,IDC_ADDRBK_STATIC_RECIP_TITLE);
        GetWindowRect(hw, &rc2);
        GetChildClientRect(hw, &rc2);
        if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB)) // need to move this to the same height as combo
        {
            int ht = rc2.bottom - rc2.top;
            rc2.bottom = rc.top - CONTROL_SPACING;
            rc2.top = rc2.bottom - ht;
        }
        MoveWindow(hw,iLeft,rc2.top,rc1.right-iLeft,rc2.bottom-rc2.top,FALSE);


        // Now we have the position and width of the list boxes .. need to get their height
        if (cDF!=3) //if not the default preset position, reposition
        {
            switch(cDF)
            {
            case 1:
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_CC), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), SW_HIDE);
            case 2:
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_BCC), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC), SW_HIDE);
                break;
            }

        }

        for(i=0;i<cDF;i++)
            HrInitListView(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO + i), LVS_REPORT, FALSE);

/***
        // Add a column to the To,CC,BCC List Boxes
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc);

        lvC.mask = LVCF_FMT | LVCF_WIDTH;// | LVCF_TEXT;
        lvC.fmt = LVCFMT_LEFT;
        lvC.cx = (rc.right - rc.left)-20;
        lvC.iSubItem = 0;
        lvC.pszText = NULL; // TEXT(" 'TO'  Recipients");

        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),lvC.iSubItem, &lvC);
        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_CC),lvC.iSubItem, &lvC);
        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_BCC),lvC.iSubItem, &lvC);
/***/
        for (i=0;i<cDF;i++)
        {
            ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO+i), SW_SHOWNORMAL);
            UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO+i));
            ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO+i), SW_SHOWNORMAL);
            UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO+i));
        }
    }

    // The window is taking too long to display with several 100 entries in the
    // property store ... so we force all the contents to visible so that we
    // can view the fill contents ...
    //ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES), SW_SHOWNORMAL);
    //UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW));
    ShowWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/));
    ShowWindow(GetDlgItem(hDlg,IDCANCEL/*IDC_ADDRBK_BUTTON_CANCEL*/), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDCANCEL/*IDC_ADDRBK_BUTTON_CANCEL*/));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_15), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_15));
    ShowWindow(hDlg,SW_SHOWNORMAL);
    UpdateWindow(hDlg);


    {
//        HICON hIcon = LoadIcon(hinstMapiX,MAKEINTRESOURCE(IDI_ICON_FIND));
        // associate the icon with the button.
//        SendMessage(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_FIND),BM_SETIMAGE,(WPARAM)IMAGE_ICON,(LPARAM)(HANDLE)hIcon);
    }
    bRet = TRUE;

    if( szCaption != lpAP->lpAdrParms->lpszCaption &&
        szCaption != szBuf)
        LocalFreeAndNull(&szCaption);

    return bRet;
}


//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateLVItems ....
//      When we call properties on an object, its props can change ...
//      Since the particular user may appear in any of the 4 list views,
//      we have to make sure that all views are updated for that entry
//
///////////////////////////////////////////////////////////////////////////////////////////////
void UpdateLVItems(HWND hWndLV,LPTSTR lpszName)
{
    // We have the handle to the list view initiating the Properties call
    // We know the old name to look for
    //
    // We know which item is selected - we can get its entryid and lParam
    // We then search all the list views for the old display name
    // if the old display name matches, we compare the entry id
    // if the entryid matches, then we update that item ...

    int iItemIndex = 0, iLastItemIndex = 0;
    LPRECIPIENT_INFO lpOriginalItem;
    ULONG i=0;
    ULONG nCount = 0;
    int id = 0;
    HWND hDlg = GetParent(hWndLV);
    HWND hw = NULL;
    LV_FINDINFO lvf={0};

    if ( (ListView_GetSelectedCount(hWndLV) != 1) ||
         (lpszName == NULL) )
    {
        goto out;
    }

    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    lpOriginalItem = GetItemFromLV(hWndLV, iItemIndex);

    if(!lpOriginalItem)
        goto out;


    // There can be upto 4 list view boxes in the view, each of which can
    // contain a displayed copy of this item ..
    // We want to go through all 4 and update all entries that match this item

    // Our strategy is to search for each and every item that
    // matches the display name - check its entry ID and if
    // the entry ID matches, update it ...

    lvf.flags = LVFI_STRING;
    lvf.psz = lpszName;

    for(i=0;i<4;i++)
    {
        switch(i)
        {
        case 0:
            id = IDC_ADDRBK_LIST_ADDRESSES;
            break;
        case 1:
            id = IDC_ADDRBK_LIST_TO;
            break;
        case 2:
            id = IDC_ADDRBK_LIST_CC;
            break;
        case 3:
            id = IDC_ADDRBK_LIST_BCC;
            break;
        }

        hw = GetDlgItem(hDlg,id);

        // if its hidden, ignore it
        if (!IsWindowVisible(hw))
            continue;

        // if its empty, ignore it
        nCount = ListView_GetItemCount(hw);
        if (nCount <= 0)
            continue;

        // The contents list view wont have duplicates so ignore it if its the original
        if ((id == IDC_ADDRBK_LIST_ADDRESSES) &&
            (hw == hWndLV))
            continue;

        // see if we can find the matching items
        iLastItemIndex = -1;
        iItemIndex = ListView_FindItem(hw,iLastItemIndex,&lvf);
        while (iItemIndex != -1)
        {
            // inspect this item
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if (lpItem && (lpItem->cbEntryID != 0) && (lpOriginalItem->cbEntryID == lpItem->cbEntryID))
            {
                if(!memcmp(lpOriginalItem->lpEntryID,lpItem->lpEntryID,lpItem->cbEntryID))
                {
                    // this is the same item ... update it
                    if (lstrcmpi(lpItem->szDisplayName,lpOriginalItem->szDisplayName))
                    {
                        ListView_SetItemText(hw,iItemIndex,colDisplayName,lpOriginalItem->szDisplayName);
                        lstrcpy(lpItem->szDisplayName,lpOriginalItem->szDisplayName);
                    }

                    if (lstrcmpi(lpItem->szEmailAddress,lpOriginalItem->szEmailAddress))
                    {
                        ListView_SetItemText(hw,iItemIndex,colEmailAddress,lpOriginalItem->szEmailAddress);
                        lstrcpy(lpItem->szEmailAddress,lpOriginalItem->szEmailAddress);
                    }

                    if (lstrcmpi(lpItem->szHomePhone,lpOriginalItem->szHomePhone))
                    {
                        ListView_SetItemText(hw,iItemIndex,colHomePhone,lpOriginalItem->szHomePhone);
                        lstrcpy(lpItem->szHomePhone,lpOriginalItem->szHomePhone);
                    }

                    if (lstrcmpi(lpItem->szOfficePhone,lpOriginalItem->szOfficePhone))
                    {
                        ListView_SetItemText(hw,iItemIndex,colOfficePhone,lpOriginalItem->szOfficePhone);
                        lstrcpy(lpItem->szOfficePhone,lpOriginalItem->szOfficePhone);
                    }

                    if (lstrcmpi(lpItem->szByFirstName,lpOriginalItem->szByFirstName))
                        lstrcpy(lpItem->szByFirstName,lpOriginalItem->szByFirstName);

                    if (lstrcmpi(lpItem->szByLastName,lpOriginalItem->szByLastName))
                        lstrcpy(lpItem->szByLastName,lpOriginalItem->szByLastName);
                }
            }

            iLastItemIndex = iItemIndex;
            iItemIndex = ListView_FindItem(hw,iLastItemIndex,&lvf);
        }
    }
out:
    return;
}


//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// ShowAddrBkLVProps ....
//
///////////////////////////////////////////////////////////////////////////////////////////////
void ShowAddrBkLVProps(LPIAB lpIAB, HWND hDlg, HWND hWndAddr,LPADDRESS_PARMS lpAP, LPFILETIME lpftLast)
{
    // get the display name of this item
    TCHAR szName[MAX_DISPLAY_NAME_LENGTH];
    szName[0]='\0';
    if (ListView_GetSelectedCount(hWndAddr) == 1)
    {
        ListView_GetItemText(   hWndAddr,
                                ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED),
                                0,
                                szName,
                                CharSizeOf(szName));
    }
    if( (MAPI_E_OBJECT_CHANGED == HrShowLVEntryProperties(hWndAddr, 0, lpAP->lpIAB, lpftLast)) &&
        (szName) &&
        (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
      )
    {
        // if the entry has changed and we have multiple list views visible,
        // we need to update all instances of the entry in all the list views
        //
        UpdateLVItems(hWndAddr,szName);
        SortListViewColumn(lpIAB, GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES), colDisplayName, &(lpAP->SortInfo), TRUE);

    }
    SetFocus(hWndAddr);

}



//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// HrUpdateAdrListEntry ....
//
//	When returning from a PickUser operation, updates the 
//	entry in the lpAdrList with the newly found item
//
//  ulFLags 0 or MAPI_UNICODE passed down to GetProps
//
//  Returns: Hr
//
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrUpdateAdrListEntry(	LPADRBOOK	lpIAB,
								LPENTRYID	lpEntryID,
								ULONG cbEntryID,
                                ULONG ulFlags,
								LPADRLIST * lppAdrList)
{

    LPSPropValue rgProps = NULL;
    ULONG cValues = 0;
    LPSPropValue lpPropArrayNew = NULL;
    ULONG cValuesNew = 0;
    LPTSTR lpszTemp = NULL;
    LPVOID lpbTemp = NULL;
    ULONG i = 0;
    SCODE sc;
	HRESULT hr = E_FAIL;

	if (!lppAdrList || !lpEntryID || !lpIAB || !cbEntryID)
		goto out;

    hr = HrGetPropArray(lpIAB,
                        (LPSPropTagArray) &ptaResolveDefaults,
                        cbEntryID,
                        lpEntryID,
                        ulFlags,
                        &cValues,
                        &rgProps);
    if (!HR_FAILED(hr))
    {

        if(!*lppAdrList)
        {
            // Allocate one ..
            LPADRLIST lpAdrList = NULL;

            sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY),
                                    &lpAdrList);

            if(FAILED(sc))
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            *lppAdrList = lpAdrList;
            (*lppAdrList)->cEntries = 1;
            (*lppAdrList)->aEntries[0].ulReserved1 = 0;
            (*lppAdrList)->aEntries[0].cValues = 0;
            (*lppAdrList)->aEntries[0].rgPropVals = NULL;
        }

        //Merge the new list with the old list
        sc = ScMergePropValues( (*lppAdrList)->aEntries[0].cValues,
                                (*lppAdrList)->aEntries[0].rgPropVals,
                                cValues,
                                rgProps,
                                &cValuesNew,
                                &lpPropArrayNew);
        if (sc == S_OK)
        {
            // if OK replace the lpspropvalue array
            // if not we havent changed anything
            (*lppAdrList)->aEntries[0].cValues = cValuesNew;
            if((*lppAdrList)->aEntries[0].rgPropVals)
                MAPIFreeBuffer((*lppAdrList)->aEntries[0].rgPropVals);
            (*lppAdrList)->aEntries[0].rgPropVals = lpPropArrayNew;
        }
        else
        {
            // If errors Free up the allocated memory
            if (lpPropArrayNew)
                MAPIFreeBuffer(lpPropArrayNew);
			hr = E_FAIL;
        }

    }

    // we free this anyway whether the above succeeded or not
    if (rgProps)
        MAPIFreeBuffer(rgProps);

out:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_clbar.h ===
////////////////////////////////////////////////////////////////////////////////
//
// Header for adding stuff related to new rebar control ...
//
////////////////////////////////////////////////////////////////////////////////
#ifndef __UI_CLBAR_H_
#define __UI_CLBAR_H_



//Toolbar stuff
//#define TBSTYLE_FLAT            0x0800
//#define TBSTYLE_TRANSPARENT     0x1000
//#define TB_SETMAXTEXTROWS       (WM_USER + 60)
//#define TB_SETHOTIMAGELIST      (WM_USER + 52)
//#define TB_SETDISABLEDIMAGELIST (WM_USER + 54)
//#define TB_SETBUTTONWIDTH       (WM_USER + 59)

#define NO_COMMCTRL_SHLWAPI

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_clbar.c ===
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;
// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A     gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W     gpfnImageList_LoadImageW;


#define TBARCONTAINERCLASS TEXT("WABTBarContainerClass")

#undef  FCIDM_TOOLBAR
#define FCIDM_CONTAINER    4876
#define FCIDM_TOOLBAR       4876
#define CBIDX_TOOLS         4877

#define TB_BMP_CX       26
#define TB_BMP_CY       20
#define MAX_TB_WIDTH    80

enum _ImageLists
{
    IMLIST_DEFAULT=0,
    IMLIST_HOT,
    IMLIST_DISABLED,
    imlMax
};

HDC m_hdc = NULL;

LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void AddTools(LPBWI lpbwi, HWND hWndToolParent);
BOOL LoadToolNames(TCHAR *szTools);

#ifdef TOOLBAR_BACK
void OnPaint(HWND hwnd,HBITMAP hbm,HDC hdc);
#endif

void InitToolbar(   HWND hwnd,
                    UINT nBtns, TBBUTTON *ptbb,
                    TCHAR *pStrings, int cx,
                    int cy, int cxMax,
                    int idBmp,
                    int nNumColors);



/////******************************************************************************/
/////******************************************************************************/
/////******************************************************************************/
#ifdef TOOLBAR_BACK
HRESULT LoadBackBitmap()
{
    HRESULT hr = E_FAIL;
    HBITMAP     hbmSave;
    UINT        n;
    COLORREF    clrFace;
    UINT        i;
    RGBQUAD     rgbTable[256];
    RGBQUAD     rgbFace;
    HDC         m_hdc = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if (m_hbmBack)
    {
        DeleteObject(m_hbmBack);
        m_hbmBack = NULL;
    }
    if (m_hpalBkgnd)
    {
        DeleteObject(m_hpalBkgnd);
        m_hpalBkgnd = NULL;
    }

    m_hdc = CreateCompatibleDC(NULL);

    if (GetDeviceCaps(m_hdc, RASTERCAPS) & RC_PALETTE)
        m_hpalBkgnd = CreateHalftonePalette(m_hdc);


    m_hbmBack = (HBITMAP) LoadImage(hinstMapiX, MAKEINTRESOURCE(IDB_BITMAP_HBG),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);

    if (!m_hbmBack)
        goto out;

    clrFace = GetSysColor(COLOR_BTNFACE);

    if (clrFace == RGB(192,192,192))
    {
        // no mapping needed
        hr = S_OK;
        goto out;
    }

    hbmSave = (HBITMAP)SelectObject(m_hdc, m_hbmBack);
    n = GetDIBColorTable(m_hdc, 0, 256, rgbTable);

    rgbFace.rgbRed   = GetRValue(clrFace);
    rgbFace.rgbGreen = GetGValue(clrFace);
    rgbFace.rgbBlue  = GetBValue(clrFace);

    for (i = 0; i < n; i++)
    {
        rgbTable[i].rgbRed   = (rgbTable[i].rgbRed   * rgbFace.rgbRed  ) / 192;
        rgbTable[i].rgbGreen = (rgbTable[i].rgbGreen * rgbFace.rgbGreen) / 192;
        rgbTable[i].rgbBlue  = (rgbTable[i].rgbBlue  * rgbFace.rgbBlue ) / 192;
    }

    SetDIBColorTable(m_hdc, 0, n, rgbTable);
    SelectObject(m_hdc, hbmSave);

    hr = S_OK;

out:
    if(m_hdc)
        DeleteDC(m_hdc);
    return(hr);
}
#endif
/////******************************************************************************/
/////******************************************************************************/
/////******************************************************************************/
HWND CreateCoolBar(LPBWI lpbwi, HWND hwndParent)
{
    DWORD                   dwcbData = 0;
    DWORD                   dwType = 0;
    IF_WIN32(WNDCLASSEX              wc;)
    IF_WIN16(WNDCLASS                wc;)

    HWND hWnd = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst)
        goto out;


#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);

    if (!GetClassInfoEx(hinstMapiXWAB, TBARCONTAINERCLASS, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = SizableWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hinstMapiXWAB;
        wc.hCursor          = 0;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = TBARCONTAINERCLASS;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }
#else
    if (!GetClassInfo(hinstMapiXWAB, TBARCONTAINERCLASS, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = SizableWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hinstMapiXWAB;
        wc.hCursor          = 0;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = TBARCONTAINERCLASS;
        wc.hIcon            = NULL;

        RegisterClass(&wc);
    }
#endif


#ifdef TOOLBAR_BACK
    LoadBackBitmap();
#endif


    hWnd = CreateWindowEx(  0,//WS_EX_STATICEDGE,
                            TBARCONTAINERCLASS,
                            NULL,
                            WS_VISIBLE | WS_CHILD |
                            WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            0,
                            0,
                            100,
                            36,
                            hwndParent,
                            (HMENU) FCIDM_CONTAINER,
                            hinstMapiXWAB,
                            (LPVOID)lpbwi);

    if (!hWnd)
    {
        DebugPrintError(( TEXT("CreateCoolBar: Show CreateWindow(TBARCONTAINERCLASS) failed")));
        goto out;
    }


    AddTools(lpbwi, hWnd);

    RedrawWindow(   hWnd,
                    NULL,
                    NULL,
                    RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);

out:

    return hWnd;
}

#define MAX_TB_BUTTONS  6

/////******************************************************************************
/////******************************************************************************
ULONG GetToolbarButtonWidth()
{
    ULONG ulMax = 0;
    TCHAR szBuf[MAX_UI_STR];

    LoadString(hinstMapiX, idsToolbarMaxButtonWidth, szBuf, CharSizeOf(szBuf));
    ulMax = my_atoi(szBuf);

    if( (ulMax<=0)  ||  (ulMax>250) )
        ulMax = MAX_TB_WIDTH;

    return ulMax;
}

/////******************************************************************************
void AddTools(LPBWI lpbwi, HWND hWndToolParent)
{
    TCHAR szToolsText[(MAX_UI_STR + 2) * MAX_TB_BUTTONS];
    int nMaxButtons = MAX_TB_BUTTONS;
    HWND hWndTools = NULL;

#ifndef WIN16
    TBBUTTON tbExplorer[] =
    {
        { 0, IDC_BB_NEW,    TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
        { 1, IDC_BB_PROPERTIES,   TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 1 },
        { 2, IDC_BB_DELETE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 2 },
        { 3, IDC_BB_FIND,         TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 3 },
        { 4, IDC_BB_PRINT,        TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 4 },
        { 5, IDC_BB_ACTION,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 5 },
    };
#else  // !WIN16
    TBBUTTON tbExplorer[] =
    {
        { 0, IDC_BB_NEW,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
        { 1, IDC_BB_PROPERTIES,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 1 },
        { 2, IDC_BB_DELETE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 2 },
        { 3, IDC_BB_FIND,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 3 },
        { 4, IDC_BB_PRINT,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 4 },
        { 5, IDC_BB_ACTION,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 5 },
    };
#endif // !WIN16

    if(!bPrintingOn)
        nMaxButtons--;

    if(!bPrintingOn)
        tbExplorer[4] = tbExplorer[5];

    // create tools window
    hWndTools = CreateWindowEx(    WS_EX_TOOLWINDOW,
                                    TOOLBARCLASSNAME,
                                    NULL,
                                    WS_CHILD | WS_VISIBLE | //WS_EX_TRANSPARENT |
                                    TBSTYLE_FLAT |  /*TBSTYLE_TOOLTIPS | TBSTYLE_TRANSPARENT |*/
                                    WS_CLIPCHILDREN |
                                    WS_CLIPSIBLINGS |
                                    CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                    CCS_NORESIZE,
                                    2,
                                    2,
                                    100,
                                    36,
                                    hWndToolParent,
                                    (HMENU) FCIDM_TOOLBAR,
                                    hinstMapiXWAB,
                                    NULL);

    if (!hWndTools)
    {
        DebugPrintError(( TEXT("AddTools: CITB:Show CreateWindow(TOOLBAR) failed")));
        goto out;
    }

    bwi_hWndTools = hWndTools;

    LoadToolNames(szToolsText);

    {
        // Check the current color resolution - if it is more than 256 colors we want
        // to use the high-color bitmaps
        int nNumColors = 0;
        HDC hDC = GetDC(NULL);

        nNumColors = GetDeviceCaps(hDC, BITSPIXEL);

        InitToolbar(    hWndTools,
                        nMaxButtons,
                        tbExplorer,
                        szToolsText,
                        TB_BMP_CX,
                        TB_BMP_CY,
                        GetToolbarButtonWidth(),
                        (nNumColors > 8) ? IDB_COOLBAR_DEFHI : IDB_COOLBAR_DEFAULT,
                        nNumColors);

        ReleaseDC(NULL, hDC);
    }



out:
    return;
}

/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

BOOL LoadToolNames(TCHAR *szTools)
{
    int i;

    for (i = 0; i < MAX_TB_BUTTONS; i++)
    {
        LoadString(hinstMapiX, idsButton0 + i, szTools, MAX_UI_STR);
        szTools += lstrlen(szTools) + 1;
    }
    *szTools = TEXT('\0');
    return(TRUE);
}

/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

void InitToolbar(   HWND hwnd,
                    UINT nBtns,
                    TBBUTTON *ptbb,
                    TCHAR *pStrings,
                    int cx,
                    int cy,
                    int cxMax,
                    int idBmp,
                    int nNumColors)
{
    HIMAGELIST phiml[imlMax];

    int nRows = 2;

    int i;

    for (i = 0; i < imlMax; i++)
    {
        UINT uFlags = LR_DEFAULTCOLOR;
        if (nNumColors > 8 && i != IMLIST_DISABLED)
            uFlags |= LR_CREATEDIBSECTION|LR_LOADMAP3DCOLORS;
        phiml[i] = gpfnImageList_LoadImage( hinstMapiX,
                                        MAKEINTRESOURCE(idBmp + i),
                                        //(LPCTSTR) ((DWORD) ((WORD) (idBmp + i))),
                                        cx,
                                        0,
                                        RGB(255,0,255),
                                        IMAGE_BITMAP,
                                        uFlags);
    }

    // this tells the toolbar what version we are
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);

    SendMessage(hwnd, TB_SETMAXTEXTROWS,      nRows, 0L);
    SendMessage(hwnd, TB_SETBITMAPSIZE,       0,     MAKELONG(cx, cy));
    SendMessage(hwnd, TB_SETIMAGELIST,        0,     (LPARAM) phiml[IMLIST_DEFAULT]);
    SendMessage(hwnd, TB_SETHOTIMAGELIST,     0,     (LPARAM) phiml[IMLIST_HOT]);
    SendMessage(hwnd, TB_SETDISABLEDIMAGELIST,0,     (LPARAM) phiml[IMLIST_DISABLED]);
    ToolBar_AddString(hwnd, (LPARAM) pStrings);
    ToolBar_AddButtons(hwnd, nBtns, (LPARAM) ptbb);
    SendMessage(hwnd, TB_SETBUTTONWIDTH,      0,     MAKELONG(0, cxMax));

    //Reset the toolbar container height to match the toolbars height
    {
        RECT rcTB, rcParent;
        HWND hwndParent = GetParent(hwnd);
        SendMessage(hwnd,TB_GETITEMRECT,0,(LPARAM) &rcTB);
        GetWindowRect(hwndParent,&rcParent);
        MoveWindow(hwndParent,rcParent.left, rcParent.top, rcParent.right - rcParent.left, rcTB.bottom-rcTB.top + 4,TRUE);
    }
}


/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch(uMsg)
    {
        case WM_CREATE:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) ((LPCREATESTRUCT) lParam)->lpCreateParams);
            break; 

        case WM_SETTINGCHANGE:
        case WM_SYSCOLORCHANGE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                SendMessage(bwi_hWndTools, uMsg, wParam, lParam);
            }
#ifdef TOOLBAR_BACK
            LoadBackBitmap();
#endif
            RedrawWindow(hwnd, NULL, NULL, RDW_ALLCHILDREN);
            break;


        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
            // We must swallow these messages to avoid infinite SendMessage
            break;


        case WM_NOTIFY:
            // We must swallow these messages to avoid infinite SendMessage
            //return(OnNotify((LPNMHDR) lParam));
            break;

//        case WM_PAINT:
//            break;

        case WM_ERASEBKGND:
            //
            // The TBSTYLE_FLAT toolbar cheats a little - to draw the
            // background bitmap, we have to draw the bitmap in the
            // WM_ERASEBKGND message. Then the toolbar draws a frame
            // around the selected button - when the mouse is removed from
            // the selected button, the toolbar sends us a
            // WM_ERASEBKGND again - but this time the corresponding
            // hdc is the hdc of the Toolbar and not of the child window.
            // So we **must** use this given hdc to redraw the background
            // bitmap, this time onto the toolbar, thus cleaning it up.

#ifdef TOOLBAR_BACK
            OnPaint(hwnd, m_hbmBack, (HDC) wParam);
            return TRUE;
#else
            {
                RECT rc;
                GetClientRect(hwnd, &rc);
                if(!DrawEdge((HDC) wParam, &rc, EDGE_ETCHED, BF_RECT))
                    DebugPrintError(( TEXT("Drawedge failed: %u\n"),GetLastError()));
            }
#endif
            break;

        case WM_SIZE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                RECT rc,rc1;
                GetClientRect(hwnd, &rc);
                GetChildClientRect(bwi_hWndTools, &rc1);
                if(bwi_hWndTools)
                    MoveWindow(bwi_hWndTools, rc1.left, rc1.top, rc.right-rc.left-4, rc.bottom-rc.top-4, TRUE);
                {
                    HDC hdc = GetDC(hwnd);
#ifdef TOOLBAR_BACK
                    OnPaint(hwnd, m_hbmBack, hdc);
#else
                    {
                        RECT rc;
                        GetClientRect(hwnd, &rc);
                        if(!DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT))
                            DebugPrintError(( TEXT("Drawedge failed: %u\n"),GetLastError()));
                    }
#endif
                    ReleaseDC(hwnd,hdc);
                }
            }
            break;

        case WM_DESTROY:
#ifdef TOOLBAR_BACK
            if (m_hbmBack)
            {
                DeleteObject(m_hbmBack);
                m_hbmBack = NULL;
            }
            if (m_hpalBkgnd)
            {
                DeleteObject(m_hpalBkgnd);
                m_hpalBkgnd = NULL;
            }
#endif
            break;

        case WM_COMMAND:
            //OnCommand(wParam, lParam);
            SendMessage(GetParent(hwnd),uMsg,wParam,lParam);
            break;

        case WM_PRVATETOOLBARENABLE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                SendMessage(bwi_hWndTools, TB_ENABLEBUTTON, wParam, lParam);
            }
            break;

        case WM_PALETTECHANGED:
            RedrawWindow(   hwnd,
                            NULL,
                            NULL,
                            RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);
            break;


        default:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return 0L;
}




#ifdef TOOLBAR_BACK
void OnPaint(HWND hwnd,HBITMAP hbm, HDC hdc)
{
//    HDC hdc;
    PAINTSTRUCT ps;
    HDC hdcMem;
    HBITMAP hbmMemOld;
    HPALETTE hpalOld = NULL;
    RECT rc;
    BITMAP bm;

    int cxIndent = 3;
    int cyIndent = 3;
    int nTop = 0;
    int nLeft = 0;
    int nButton = 0;
    int i=0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Get the size of the background bitmap
    GetObject(hbm, sizeof(BITMAP), (LPVOID) &bm);
    GetClientRect(hwnd, &rc);

    BeginPaint(hwnd, &ps);

    if(hdc)
    {

        hdcMem = CreateCompatibleDC(hdc);

        if (m_hpalBkgnd)
        {
            hpalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
            RealizePalette(hdc);
        }

        hbmMemOld = (HBITMAP) SelectObject(hdcMem, (HGDIOBJ) hbm);

        nTop = 0;
        nLeft = 0;

        while (nLeft < rc.right)
        {
            BitBlt(hdc, nLeft, nTop, bm.bmWidth, bm.bmHeight, hdcMem, 0,
                   0, SRCCOPY);
            nLeft += bm.bmWidth;
        }

        {
            if(!DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT))
                DebugPrintError(("Drawedge failed: %u\n",GetLastError()));
        }

        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        SelectObject(hdcMem, hbmMemOld);

        DeleteDC(hdcMem);
    } // if hdc...

    EndPaint(hwnd, &ps);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_cflct.c ===
#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "resource.h"
#include "objbase.h"
#include "ui_cflct.h"
#include "commctrl.h"
#include "winuser.h"

typedef struct CONFLICTS_PARAM
{
    LPHTTPCONFLICTINFO  prgConflicts;
    DWORD               cConflicts;
    DWORD               dwCurrentContact;
} CONFLICTS_PARAM, *LPCONFLICTS_PARAM;

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))
#define ListView_GetFirstSel(_hwndlist)          ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED)
extern LPIMAGELIST_DESTROY         gpfnImageList_Destroy;
// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A     gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W     gpfnImageList_LoadImageW;

enum {
    LVINDEX_TITLE = 1,
    LVINDEX_ABVALUE = 2,
    LVINDEX_REPLACE = 0,
    LVINDEX_HMVALUE = 3,
};
static DWORD  g_rgFieldNameIds[] = 
{
    0,
    0,
    0,
    0,
    idsDisplayName,
    idsGivenName,
    idsSurname,
    idsNickname,
    idsEmail,
    idsHomeStreet,
    idsHomeCity,
    idsHomeState,
    idsHomePostalCode,
    idsHomeCountry,
    idsCompany,
    idsWorkStreet,
    idsWorkCity,
    idsWorkState,
    idsWorkPostalCode,
    idsWorkCountry,
    idsHomePhone,
    idsHomeFax,
    idsWorkPhone,
    idsWorkFax,
    idsMobilePhone,
    idsOtherPhone,
    idsBirthday,
    idsPager
};

/*
 *  CenterDialog
 *
 *  Purpose:
 *      This function centers a dialog with respect to its parent
 *      dialog.
 *
 *  Parameters:
 *      hwndDlg     hwnd of the dialog to center
 */
VOID CenterDialog(HWND hwndDlg)
{
    HWND    hwndOwner;
    RECT    rc;
    RECT    rcDlg;
    RECT    rcOwner;
    RECT    rcWork;
    INT     x;
    INT     y;
    INT     nAdjust;

    // Get the working area rectangle
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

    // Get the owner window and dialog box rectangles.
    //  The window rect of the destop window is in trouble on multimonitored
    //  macs. GetWindow only gets the main screen.
    if (hwndOwner = GetParent(hwndDlg))
        GetWindowRect(hwndOwner, &rcOwner);
    else
        rcOwner = rcWork;

    GetWindowRect(hwndDlg, &rcDlg);
    rc = rcOwner;

    // Offset the owner and dialog box rectangles so that
    // right and bottom values represent the width and
    // height, and then offset the owner again to discard
    // space taken up by the dialog box.
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect(&rc, -rc.left, -rc.top);
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

    // The new position is the sum of half the remaining
    // space and the owner's original position.
    // But not less than Zero - jefbai

    x= rcOwner.left + (rc.right / 2);
    y= rcOwner.top + (rc.bottom / 2);

    // Make sure the dialog doesn't go off the right edge of the screen
    nAdjust = rcWork.right - (x + rcDlg.right);
    if (nAdjust < 0)
        x += nAdjust;

    //$ Raid 5128: Make sure the left edge is visible
    if (x < rcWork.left)
        x = rcWork.left;

    // Make sure the dialog doesn't go off the bottom edge of the screen
    nAdjust = rcWork.bottom - (y + rcDlg.bottom);
    if (nAdjust < 0)
        y += nAdjust;

    //$ Raid 5128: Make sure the top edge is visible
    if (y < rcWork.top)
        y = rcWork.top;
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

static BOOL _ValidateEndConflictDialog(HWND hDlg)
{
    return TRUE;
}

void  _AddRow(HWND hwndList, DWORD dwIndex, DWORD dwResId, LPSTR pszServer, LPSTR pszClient, CONFLICT_DECISION cdCurrent)
{
    LVITEM  lvItem;
    TCHAR   szRes[255];

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LoadString(hinstMapiX, (cdCurrent == CONFLICT_IGNORE ? idsSyncSkip : idsSyncKeep), szRes, CharSizeOf(szRes));
    lvItem.iItem = ListView_GetItemCount(hwndList);
    lvItem.lParam = dwIndex;
    lvItem.pszText = szRes;
    lvItem.iImage = cdCurrent;
    ListView_InsertItem(hwndList, &lvItem);

    // [PaulHi] 1/22/99  Raid 67407  Convert single byte to double byte strings
    {
        LPWSTR  lpwszServer = ConvertAtoW(pszServer);
        LPWSTR  lpwszClient = ConvertAtoW(pszClient);

        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_ABVALUE, (lpwszClient ? lpwszClient :  TEXT("")));
        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_HMVALUE, (lpwszServer ? lpwszServer :  TEXT("")));		
        LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));
        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_TITLE, szRes);		

        LocalFreeAndNull(&lpwszServer);
        LocalFreeAndNull(&lpwszClient);
    }
}

void _RowSelected(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    int                 iItem, cItems;
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    iItem = ListView_GetFirstSel(hwndList);
    cItems = ListView_GetSelectedCount(hwndList);

    if (iItem >= 0)
    {
        LVITEM  lvItem;
        TCHAR   szRes[256];

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.pszText = szRes;
        lvItem.cchTextMax = 255;
        lvItem.iItem = iItem;
        lvItem.iSubItem = LVINDEX_TITLE;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            if (cItems > 1)
                LoadString(hinstMapiX, idsMultipleSelected, szRes, CharSizeOf(szRes));

            SetDlgItemText(hDlg, IDC_SYNC_FIELDNAME, szRes);
            CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, FALSE);
            CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, FALSE);
            CheckDlgButton(hDlg, IDC_SYNC_IGNORE, FALSE);

            if (cItems == 1)
            {
                switch(pCurrConflict->rgcd[lvItem.lParam])
                {
                    case CONFLICT_IGNORE:
                        CheckDlgButton(hDlg, IDC_SYNC_IGNORE, TRUE);
                        break;

                    case CONFLICT_SERVER:
                        CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, TRUE);
                        break;

                    case CONFLICT_CLIENT:
                        CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, TRUE);
                        break;
                }
            }
        }
    }
}


BOOL _PageContainsSkip(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    int                 iItem, cItems;
    LVITEM              lvItem;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);
    HWND                hwndList;

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    cItems = ListView_GetItemCount(hwndList);
    pCurrConflict->fContainsSkip = FALSE;
    
    for (iItem = 0; iItem < cItems; iItem++)
    {
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_PARAM;
        lvItem.cchTextMax = 0;
        lvItem.iItem = iItem;
        lvItem.iSubItem = LVINDEX_TITLE;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            switch(pCurrConflict->rgcd[lvItem.lParam])
            {
                case CONFLICT_IGNORE:
                    pCurrConflict->fContainsSkip = TRUE;
                    break;

                case CONFLICT_SERVER:
                    break;

                case CONFLICT_CLIENT:
                    break;
            }
        }

        if (pCurrConflict->fContainsSkip)
            break;
    }

    return pCurrConflict->fContainsSkip;
}


static void _FillInPage(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);
    TCHAR               szName[255] =  TEXT("");
    LPTSTR              psz = szName;
    LPSTR               *ppszServer = (LPSTR *)pCurrConflict->pciServer;
    LPSTR               *ppszClient = (LPSTR *)pCurrConflict->pciClient;
    DWORD               dwCount = ARRAYSIZE(g_rgFieldNameIds), dwIndex;


    if (pCurrConflict->pciClient->pszDisplayName)
        psz = ConvertAtoW(pCurrConflict->pciClient->pszDisplayName);
    else if (pCurrConflict->pciClient->pszGivenName && pCurrConflict->pciClient->pszSurname)
    {
        wsprintf(szName,  TEXT("%s %s"), pCurrConflict->pciClient->pszGivenName, pCurrConflict->pciClient->pszSurname);
        psz = szName;
    }
    else if (pCurrConflict->pciServer->pszGivenName && pCurrConflict->pciServer->pszSurname)
    {
        wsprintf(szName,  TEXT("%s %s"), pCurrConflict->pciServer->pszGivenName, pCurrConflict->pciServer->pszSurname);
        psz = szName;
    }
    else if (pCurrConflict->pciServer->pszNickname)
    {
        psz = ConvertAtoW(pCurrConflict->pciServer->pszNickname);
    }

    SetDlgItemText(hDlg, IDC_SYNC_CONTACTNAME, psz);
    
    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
    ListView_DeleteAllItems(hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);
    
    for (dwIndex = 5; dwIndex < dwCount; dwIndex++)
    {
        if (ppszServer[dwIndex] && ppszClient[dwIndex])
        {
            if (lstrcmpA(ppszServer[dwIndex], ppszClient[dwIndex]))
                _AddRow(hwndList, dwIndex, g_rgFieldNameIds[dwIndex], ppszServer[dwIndex], ppszClient[dwIndex], pCurrConflict->rgcd[dwIndex]);
        }
        else
        {
            if( ppszServer[dwIndex] || ppszClient[dwIndex])
                _AddRow(hwndList, dwIndex, g_rgFieldNameIds[dwIndex], ppszServer[dwIndex], ppszClient[dwIndex], pCurrConflict->rgcd[dwIndex]);
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_SYNC_NEXT), (pConflicts->dwCurrentContact < pConflicts->cConflicts - 1)); 
    EnableWindow(GetDlgItem(hDlg, IDC_SYNC_BACK), pConflicts->dwCurrentContact > 0); 

    CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, FALSE);
    CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, FALSE);
    CheckDlgButton(hDlg, IDC_SYNC_IGNORE, FALSE);
    SetDlgItemText(hDlg, IDC_SYNC_FIELDNAME, TEXT(""));

    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
    _RowSelected(hDlg, pConflicts);

    if(psz != szName)
        LocalFreeAndNull(&psz);
}

void _ChangeDecision(HWND hDlg, LPCONFLICTS_PARAM pConflicts, CONFLICT_DECISION cdNew)
{
    int                 iItem, cItems, i;
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    iItem = -1;
    cItems = ListView_GetSelectedCount(hwndList);

    for (i = 0; i < cItems; i++)
    {
        iItem = ListView_GetNextItem(hwndList, iItem, LVNI_SELECTED);
        if (iItem >= 0)
        {
            LVITEM  lvItem;
            TCHAR   szRes[256];

            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.pszText = szRes;
            lvItem.cchTextMax = 255;
            lvItem.iItem = iItem;
    
            if (ListView_GetItem(hwndList, &lvItem))
            {
                DWORD   dwResId;

                pCurrConflict->rgcd[lvItem.lParam] = cdNew;

                dwResId = (cdNew == CONFLICT_IGNORE ? idsSyncSkip : idsSyncKeep);
                LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));

                lvItem.pszText = szRes;
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
                lvItem.iSubItem = 0;
                lvItem.iImage = cdNew;
                ListView_SetItem(hwndList, &lvItem);
//                ListView_SetItemText(hwndList,lvItem.iItem, 2, (cdNew == CONFLICT_IGNORE ? "X": (cdNew == CONFLICT_SERVER ? "-->": "<--")));		
            }
        }
    }
}

static void _InitConflictList(HWND hwnd)
{
    LVCOLUMN    lvCol;
    int         rgiColOrder[4] = {LVINDEX_TITLE, LVINDEX_ABVALUE, LVINDEX_REPLACE, LVINDEX_HMVALUE};
    RECT        rcWnd;
    int         iColWidth;
    HIMAGELIST  hImageList;
    TCHAR       szRes[255];

    if (hImageList = gpfnImageList_LoadImage(hinstMapiX,
                      MAKEINTRESOURCE(IDB_SYNC_SYNCOP),
                      //(LPCTSTR) ((DWORD) ((WORD) (IDB_SYNC_SYNCOP))),
                      16,
                      0,
                      RGB(255, 0, 255),
                      IMAGE_BITMAP,
                      0)) 
        ListView_SetImageList(hwnd, hImageList, LVSIL_SMALL);

    GetClientRect(hwnd, &rcWnd);
    iColWidth = ((rcWnd.right - rcWnd.left) - 180) / 2;

    LoadString(hinstMapiX, idsSyncReplace, szRes, CharSizeOf(szRes));
    lvCol.mask = LVCF_TEXT | LVCF_FMT;
    lvCol.pszText = szRes;
    lvCol.fmt = LVCFMT_LEFT;
    ListView_InsertColumn(hwnd, LVINDEX_REPLACE, &lvCol);

    LoadString(hinstMapiX, idsSyncField, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_TITLE, &lvCol);

    LoadString(hinstMapiX, idsSyncABInfo, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_ABVALUE, &lvCol);

    LoadString(hinstMapiX, idsSyncHMInfo, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_HMVALUE, &lvCol);

    ListView_SetColumnWidth(hwnd,LVINDEX_TITLE,120);
    ListView_SetColumnWidth(hwnd,LVINDEX_ABVALUE,iColWidth);
    ListView_SetColumnWidth(hwnd,LVINDEX_REPLACE,65);
    ListView_SetColumnWidth(hwnd,LVINDEX_HMVALUE,iColWidth);

    ListView_SetColumnOrderArray(hwnd, 4, &rgiColOrder);
}
/*
    _ConflictDlgProc

    Description: Dialog proc for handling the contact conflict.
*/
INT_PTR CALLBACK _ConflictDlgProc(HWND     hDlg, 
                               UINT     iMsg, 
                               WPARAM   wParam, 
                               LPARAM   lParam)
{
    static char *sOldNewPassword;
    HWND hwndList;
    LPCONFLICTS_PARAM pConflicts = NULL;
    switch (iMsg)
    {
        case WM_INITDIALOG:
            pConflicts = (LPCONFLICTS_PARAM)lParam;

            CenterDialog(hDlg);
            hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
            _InitConflictList(hwndList);
            pConflicts->dwCurrentContact = 0;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pConflicts);
            _FillInPage(hDlg, pConflicts);
            return TRUE;

        case WM_DESTROY:
            // Free image lists
            hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
            if (IsWindow(hwndList) && NULL != gpfnImageList_Destroy)
            {
                HIMAGELIST  hImageList;

                hImageList = ListView_GetImageList(hwndList, LVSIL_SMALL);
                if (NULL != hImageList)
                    gpfnImageList_Destroy(hImageList);
            }
            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
//            return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);
            return TRUE;
        
        case WM_SETFONT:
            return TRUE;

        case WM_COMMAND:
            pConflicts = (LPCONFLICTS_PARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (!pConflicts)
                break;

            switch(LOWORD(wParam))
            {
                case IDC_SYNC_NEXT:
                    _PageContainsSkip(hDlg, pConflicts);
                    pConflicts->dwCurrentContact++;
                    _FillInPage(hDlg, pConflicts);
                    return TRUE;

                case IDC_SYNC_BACK:
                    _PageContainsSkip(hDlg, pConflicts);
                    pConflicts->dwCurrentContact--;
                    _FillInPage(hDlg, pConflicts);
                    return TRUE;

                case IDC_SYNC_ADDRESSBOOK:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_CLIENT);
                    return TRUE;
                
                case IDC_SYNC_HOTMAIL:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_SERVER);
                    return TRUE;

                case IDC_SYNC_IGNORE:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_IGNORE);
                    return TRUE;

                case IDOK:
                    _PageContainsSkip(hDlg, pConflicts);
                    if (_ValidateEndConflictDialog(hDlg))
                        EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;

            }
            break;

	    case WM_NOTIFY: 
 
            // Branch depending on the specific notification message. 
            switch (((LPNMHDR) lParam)->code) { 
 
                // selection changed, update the contols
                case NM_CLICK:
                case NM_CUSTOMDRAW:
                case LVN_BEGINDRAG:
                case LVN_ODSTATECHANGED:
                    pConflicts = (LPCONFLICTS_PARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                    _RowSelected(hDlg, pConflicts);
                    break; 
 
                // Process LVN_ENDLABELEDIT to change item labels after 
                // in-place editing. 
                case LVN_ENDLABELEDITA: 
                case LVN_ENDLABELEDITW: 
                    break; 
                // Process LVN_COLUMNCLICK to sort items by column. 
                case LVN_COLUMNCLICK: 
                    break;
            } 
        break; 


    }
    return FALSE;
}

/*
    ResolveConflicts

*/
BOOL    ResolveConflicts(HWND hwnd, LPHTTPCONFLICTINFO prgConflicts, DWORD cConflicts) 
{
    int bResult;
    DWORD dwErr;
    CONFLICTS_PARAM cParam = {0};

    Assert(hwnd);
    if (cConflicts == 0)
        return S_OK;

    cParam.cConflicts = cConflicts;
    cParam.prgConflicts = prgConflicts;
    bResult = (int) DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(iddConflict), hwnd, (DLGPROC)_ConflictDlgProc, (LPARAM)&cParam);
    dwErr = GetLastError();

    return (bResult == IDOK);   
}

typedef struct tagChooseServer
{
    IImnEnumAccounts *pEnumAccts;
    LPSTR             pszName;
} CHOOSE_SERVER_PARAM;
/*
    _ChooseServerDlgProc

    Description: Dialog proc for handling the choose server.
*/
INT_PTR CALLBACK _ChooseServerDlgProc(HWND     hDlg, 
                               UINT     iMsg, 
                               WPARAM   wParam, 
                               LPARAM   lParam)
{
    CHOOSE_SERVER_PARAM *pParams;
    HWND                hwndList;
    DWORD               i, dwCount;
    HRESULT             hr;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            pParams = (CHOOSE_SERVER_PARAM*)lParam;

            CenterDialog(hDlg);
            hwndList = GetDlgItem(hDlg, IDC_SERVER_LIST);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pParams);

            SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
            
            *pParams->pszName = 0;

            pParams->pEnumAccts->lpVtbl->Reset(pParams->pEnumAccts);
            pParams->pEnumAccts->lpVtbl->SortByAccountName(pParams->pEnumAccts);

            if (SUCCEEDED(hr = pParams->pEnumAccts->lpVtbl->GetCount(pParams->pEnumAccts, &dwCount)))
            {
                IImnAccount *pAccount = NULL;
                char        szAcctName[CCHMAX_ACCOUNT_NAME+1];
                DWORD       ccb;

                for (i = 0; i < dwCount; i++)
                {
                    if (SUCCEEDED(hr = pParams->pEnumAccts->lpVtbl->GetNext(pParams->pEnumAccts, &pAccount)))
                    {
                        ccb = CharSizeOf(szAcctName);
                        if (FAILED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_NAME, szAcctName, &ccb)))
                            continue;

                        // [PaulHi] 1/19/99  Raid 66195
                        // Must use wide character string
                        {
                            LPWSTR lpwszAcctName = ConvertAtoW(szAcctName);
                            SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)lpwszAcctName);
                            LocalFreeAndNull(&lpwszAcctName);
                        }

                        pAccount->lpVtbl->Release(pAccount);
                    }
                }
            }
            else
                return FALSE;

            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
//            return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);
            return TRUE;
        
        case WM_SETFONT:
            return TRUE;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case LBN_DBLCLK:
                    wParam = IDOK;
                    break;
                case LBN_SELCHANGE:
                    break;
            }

            pParams = (CHOOSE_SERVER_PARAM*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (!pParams)
                break;

            switch(LOWORD(wParam))
            {
                DWORD   dwSelItem;

                case IDOK:
                    dwSelItem = (DWORD) SendDlgItemMessage(hDlg, IDC_SERVER_LIST, LB_GETCURSEL, 0, 0);
                    if (LB_ERR != dwSelItem)
                    {
                        // [PaulHi] 1/19/99  Raid 66195
                        // Convert wide char back to MB
                        TCHAR   tszName[CCHMAX_ACCOUNT_NAME+1];
                        LPSTR   lpstr = NULL;
                        int     nLen;

                        nLen = (int) SendDlgItemMessage(hDlg, IDC_SERVER_LIST, LB_GETTEXT, dwSelItem, (LPARAM)tszName);

                        AssertSz((nLen <= CCHMAX_ACCOUNT_NAME), TEXT("ChooseHotmailServer: Returned account name too large for buffer"));

                        lpstr = ConvertWtoA(tszName);
                        lstrcpyA(pParams->pszName, lpstr);
                        LocalFreeAndNull(&lpstr);

                        EndDialog(hDlg, IDOK);
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;

            }
            break;
    }
    return FALSE;
}

/*
    ChooseHotmailServer

*/
BOOL    ChooseHotmailServer(HWND hwnd, IImnEnumAccounts *pEnumAccts, LPSTR pszAccountName)
{
    int bResult;
    DWORD dwErr;
    CHOOSE_SERVER_PARAM cParam = {0};

    Assert(hwnd);

    cParam.pEnumAccts = pEnumAccts;
    cParam.pszName = pszAccountName;
    bResult = (int) DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(iddChooseServer), hwnd, (DLGPROC)_ChooseServerDlgProc, (LPARAM)&cParam);

    return (bResult == IDOK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_detls.h ===
#ifndef _DETAILS_H_
#define _DETAILS_H_


HRESULT HrShowDetails(  LPADRBOOK   lpIAB,
                        HWND        hWndParent,
                        HANDLE      hPropertyStore,
                        ULONG       cbContEID,
                        LPENTRYID   lpContEID,
                        ULONG       *lpcbEntryID,
                        LPENTRYID   *lppEntryID,
                        LPMAPIPROP  lpPropObj,      // [optional] IN:IMAPIProp object
                        ULONG       ulFlags,
                        ULONG       ulObjectType,
                        BOOL        *lpbChangesMade);


HRESULT HrShowOneOffDetails(    LPADRBOOK lpAdrBook,
                                HWND    hWndParent,
                                ULONG   cbEntryID,
                                LPENTRYID   lpEntryID,
                                ULONG ulObjectType,
                                LPMAPIPROP lpPropObj, // [optional] IN:IMAPIProp object
                                LPTSTR szLDAPUrl,
                                ULONG   ulFlags);

// Flags used for showing the NewEntry and Details from the same dialog box
#define SHOW_DETAILS    0x00000001
#define SHOW_NEW_ENTRY  0x00000010
#define SHOW_ONE_OFF    0x00000100
#define SHOW_OBJECT     0x00001000  // HrShowDetails of an object


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_detls.c ===
/**********************************************************************************
*
*
*   Details.C - contains functions for the Details dialog
*
*
*
*
*
*
*
**********************************************************************************/

#include "_apipch.h"

#define _CRYPTDLG_
#define EDIT_LEN        MAX_UI_STR*2
#define MAX_EDIT_LEN    MAX_BUF_STR*2

#define IDC_TRIDENT_WINDOW  9903

extern BOOL bDNisByLN;

extern HINSTANCE ghCommCtrlDLLInst;

// extern LPPROPERTYSHEET gpfnPropertySheet;
// extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;
// extern LP_CREATEPROPERTYSHEETPAGE gpfnCreatePropertySheetPage;
extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;

extern HRESULT HandleSaveChangedInsufficientDiskSpace(HWND hWnd, LPMAILUSER lpMailUser);
extern BOOL GetOpenFileName(LPOPENFILENAME pof);
extern BOOL GetSaveFileName(LPOPENFILENAME pof);
extern BOOL bIsIE401OrGreater();
extern void ChangeLocaleBasedTabOrder(HWND hWnd, int nPropSheet);

const LPTSTR szInternetCallKey = TEXT("Software\\Clients\\Internet Call");
const LPTSTR szCallto = TEXT("callto://");
const LPTSTR szHTTP = TEXT("http://");


/*  Context-Sensitive Help IDs

    The following is a giant list of Control IDs and corresponding Help IDs for
    all the controls on all the property sheets .. when adding new prop sheets
    just append your controls to the bottom of the list
    */
static DWORD rgDetlsHelpIDs[] =
{
    IDC_DETAILS_PERSONAL_FRAME_NAME,        IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_PERSONAL_FRAME_EMAIL,       IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_STATIC_FIRSTNAME,  IDH_WAB_CONTACT_PROPS_FIRST,
    IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME,    IDH_WAB_CONTACT_PROPS_FIRST,
    IDC_DETAILS_PERSONAL_STATIC_LASTNAME,   IDH_WAB_CONTACT_PROPS_LAST,
    IDC_DETAILS_PERSONAL_EDIT_LASTNAME,     IDH_WAB_CONTACT_PROPS_LAST,
    IDC_DETAILS_PERSONAL_STATIC_MIDDLENAME, IDH_WAB_MIDDLE_NAME,
    IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME,   IDH_WAB_MIDDLE_NAME,
    IDC_DETAILS_PERSONAL_STATIC_NICKNAME,   IDH_WAB_NICKNAME,
    IDC_DETAILS_PERSONAL_EDIT_NICKNAME,     IDH_WAB_NICKNAME,
    IDC_DETAILS_PERSONAL_STATIC_DISPLAYNAME,IDH_WAB_PERSONAL_NAME_DISPLAY,
    IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, IDH_WAB_PERSONAL_NAME_DISPLAY,
    IDC_DETAILS_PERSONAL_STATIC_TITLE,      IDH_WAB_CONTACT_PROPS_TITLE,
    IDC_DETAILS_PERSONAL_EDIT_TITLE,        IDH_WAB_CONTACT_PROPS_TITLE,
    IDC_DETAILS_PERSONAL_STATIC_CAPTION3,   IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL,     IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL,   IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_LIST,              IDH_WAB_EMAIL_NAME_LIST,
    IDC_DETAILS_PERSONAL_BUTTON_REMOVE,     IDH_WAB_DELETE_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT, IDH_WAB_DEFAULT_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_EDIT,       IDH_WAB_EDIT_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB,   IDH_WAB_DIRSERV_ADDADDRESS,
    IDC_DETAILS_PERSONAL_CHECK_RICHINFO,    IDH_WAB_PROPERTIES_SEND_USING_PLAIN_TEXT,

    IDC_DETAILS_HOME_STATIC_ADDRESS,        IDH_WAB_HOME_ADDRESS,
    IDC_DETAILS_HOME_EDIT_ADDRESS,          IDH_WAB_HOME_ADDRESS,
    IDC_DETAILS_HOME_STATIC_CITY,           IDH_WAB_HOME_CITY,
    IDC_DETAILS_HOME_EDIT_CITY,             IDH_WAB_HOME_CITY,
    IDC_DETAILS_HOME_STATIC_STATE,          IDH_WAB_HOME_STATE,
    IDC_DETAILS_HOME_EDIT_STATE,            IDH_WAB_HOME_STATE,
    IDC_DETAILS_HOME_STATIC_ZIP,            IDH_WAB_HOME_ZIP,
    IDC_DETAILS_HOME_EDIT_ZIP,              IDH_WAB_HOME_ZIP,
    IDC_DETAILS_HOME_STATIC_COUNTRY,        IDH_WAB_HOME_COUNTRY,
    IDC_DETAILS_HOME_EDIT_COUNTRY,          IDH_WAB_HOME_COUNTRY,
    IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS,  IDH_WAB_BUSINESS_DEFAULTBOX, 
    IDC_DETAILS_HOME_BUTTON_MAP,            IDH_WAB_BUSINESS_VIEWMAP,
    IDC_DETAILS_HOME_STATIC_WEB,            IDH_WAB_HOMEPAGE,
    IDC_DETAILS_HOME_EDIT_URL,              IDH_WAB_HOMEPAGE,
    IDC_DETAILS_HOME_BUTTON_URL,            IDH_WAB_HOMEPAGE_BUTTON,
    IDC_DETAILS_HOME_STATIC_PHONE,          IDH_WAB_BUS_PHONE,
    IDC_DETAILS_HOME_EDIT_PHONE,            IDH_WAB_BUS_PHONE,
    IDC_DETAILS_HOME_STATIC_FAX,            IDH_WAB_BUS_FAX,
    IDC_DETAILS_HOME_EDIT_FAX,              IDH_WAB_BUS_FAX,
    IDC_DETAILS_HOME_STATIC_CELLULAR,       IDH_WAB_BUS_CELLULAR,
    IDC_DETAILS_HOME_EDIT_CELLULAR,         IDH_WAB_BUS_CELLULAR,
    IDC_DETAILS_HOME_COMBO_GENDER,          IDH_WAB_HOME_GENDER,

    IDC_DETAILS_BUSINESS_STATIC_COMPANY,    IDH_WAB_BUS_COMPANY,
    IDC_DETAILS_BUSINESS_EDIT_COMPANY,      IDH_WAB_BUS_COMPANY,
    IDC_DETAILS_BUSINESS_STATIC_ADDRESS,    IDH_WAB_BUS_ADDRESS,
    IDC_DETAILS_BUSINESS_EDIT_ADDRESS,      IDH_WAB_BUS_ADDRESS,
    IDC_DETAILS_BUSINESS_STATIC_CITY,       IDH_WAB_BUS_CITY,
    IDC_DETAILS_BUSINESS_EDIT_CITY,         IDH_WAB_BUS_CITY,
    IDC_DETAILS_BUSINESS_STATIC_STATE,      IDH_WAB_BUS_STATE,
    IDC_DETAILS_BUSINESS_EDIT_STATE,        IDH_WAB_BUS_STATE,
    IDC_DETAILS_BUSINESS_STATIC_ZIP,        IDH_WAB_BUS_ZIP,
    IDC_DETAILS_BUSINESS_EDIT_ZIP,          IDH_WAB_BUS_ZIP,
    IDC_DETAILS_BUSINESS_STATIC_COUNTRY,    IDH_WAB_BUS_COUNTRY,
    IDC_DETAILS_BUSINESS_EDIT_COUNTRY,      IDH_WAB_BUS_COUNTRY,
    IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS,  IDH_WAB_BUSINESS_DEFAULTBOX,
    IDC_DETAILS_BUSINESS_BUTTON_MAP,        IDH_WAB_BUSINESS_VIEWMAP,
    IDC_DETAILS_BUSINESS_STATIC_JOBTITLE,   IDH_WAB_BUS_TITLE,
    IDC_DETAILS_BUSINESS_EDIT_JOBTITLE,     IDH_WAB_BUS_TITLE,
    IDC_DETAILS_BUSINESS_STATIC_DEPARTMENT, IDH_WAB_BUS_DEPT,
    IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT,   IDH_WAB_BUS_DEPT,
    IDC_DETAILS_BUSINESS_STATIC_OFFICE,     IDH_WAB_BUS_OFFICE,
    IDC_DETAILS_BUSINESS_EDIT_OFFICE,       IDH_WAB_BUS_OFFICE,
    IDC_DETAILS_BUSINESS_STATIC_PHONE,      IDH_WAB_BUS_PHONE,
    IDC_DETAILS_BUSINESS_EDIT_PHONE,        IDH_WAB_BUS_PHONE,
    IDC_DETAILS_BUSINESS_STATIC_FAX,        IDH_WAB_BUS_FAX,
    IDC_DETAILS_BUSINESS_EDIT_FAX,          IDH_WAB_BUS_FAX,
    IDC_DETAILS_BUSINESS_STATIC_PAGER,      IDH_WAB_BUS_PAGER,
    IDC_DETAILS_BUSINESS_EDIT_PAGER,        IDH_WAB_BUS_PAGER,
    IDC_DETAILS_BUSINESS_STATIC_IPPHONE,    IDH_WAB_BUSINESS_IPPHONE,
    IDC_DETAILS_BUSINESS_EDIT_IPPHONE,      IDH_WAB_BUSINESS_IPPHONE,

    IDC_DETAILS_BUSINESS_STATIC_WEB,        IDH_WAB_HOMEPAGE,
    IDC_DETAILS_BUSINESS_EDIT_URL,          IDH_WAB_HOMEPAGE,
    IDC_DETAILS_BUSINESS_BUTTON_URL,        IDH_WAB_HOMEPAGE_BUTTON,

    IDC_DETAILS_NOTES_STATIC_NOTES,         IDH_WAB_NOTES,
    IDC_DETAILS_NOTES_EDIT_NOTES,           IDH_WAB_NOTES,
    IDC_DETAILS_NOTES_STATIC_NOTES_GROUP,   IDH_WAB_OTHER_GROUP_MEMBERSHIP,
    IDC_DETAILS_NOTES_EDIT_GROUPS,          IDH_WAB_OTHER_GROUP_MEMBERSHIP,
    IDC_DETAILS_NOTES_FRAME_FOLDER,         IDH_WAB_OTHER_FOLDER,
    IDC_DETAILS_NOTES_STATIC_FOLDER,        IDH_WAB_OTHER_FOLDER,

    IDC_DETAILS_CERT_FRAME,                 IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_CERT_LIST,                  IDH_WAB_PROPERTIES_CERTIFICATES,
    IDC_DETAILS_CERT_BUTTON_PROPERTIES,     IDH_WAB_PROPERTIES_PROPERTIES,
    IDC_DETAILS_CERT_BUTTON_REMOVE,         IDH_WAB_PROPERTIES_REMOVE,
    IDC_DETAILS_CERT_BUTTON_SETDEFAULT,     IDH_WAB_PROPERTIES_SETASDEFAULT,
    IDC_DETAILS_CERT_BUTTON_IMPORT,         IDH_WAB_PROPERTIES_IMPORT,
    IDC_DETAILS_CERT_BUTTON_EXPORT,         IDH_WAB_PROPERTIES_EXPORT,
    IDC_DETAILS_CERT_COMBO,                 IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS,
    IDC_DETAILS_CERT_STATIC2,               IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS,

    IDC_DETAILS_NTMTG_FRAME_SERVERS,        IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_NTMTG_FRAME_SERVERS2,       IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_NTMTG_STATIC_CAPTION2,      IDH_WAB_CONFERENCE_SELECT_ADDRESS,
    IDC_DETAILS_NTMTG_COMBO_EMAIL,          IDH_WAB_CONFERENCE_SELECT_ADDRESS,
    IDC_DETAILS_NTMTG_BUTTON_CALL,          IDH_WAB_CONFERENCE_CALL_NOW,
    IDC_DETAILS_NTMTG_STATIC_CAPTION3,      IDH_WAB_CONFERENCE_SERVER_NAME,
    IDC_DETAILS_NTMTG_EDIT_ADDSERVER,       IDH_WAB_CONFERENCE_SERVER_NAME,
    IDC_DETAILS_NTMTG_BUTTON_ADDSERVER,     IDH_WAB_CONFERENCE_ADD_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_EDIT,          IDH_WAB_CONFERENCE_EDIT_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_REMOVE,        IDH_WAB_CONFERENCE_REMOVE_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT,    IDH_WAB_CONFERENCE_SET_DEFAULT,
    IDC_DETAILS_NTMTG_BUTTON_SETBACKUP,     IDH_WAB_CONFERENCE_SET_BACKUP,
    IDC_DETAILS_NTMTG_LIST_SERVERS,         IDH_WAB_CONFERENCE_SERVER_LIST,

    IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB,    IDH_WAB_DIRSERV_ADDADDRESS,

    IDC_DETAILS_SUMMARY_STATIC_NAME,        IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_EMAIL,       IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE,   IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_PAGER,       IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_CELLULAR,    IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_JOBTITLE,    IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT,  IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_OFFICE,      IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB, IDH_WAB_SUMMARY,

    IDC_DETAILS_ORG_STATIC_MANAGER,         IDH_WAB_ORGANIZATION_MANAGER,
    IDC_DETAILS_ORG_LIST_MANAGER,           IDH_WAB_ORGANIZATION_MANAGER,
    IDC_DETAILS_ORG_STATIC_REPORTS,         IDH_WAB_ORGANIZATION_REPORTS,
    IDC_DETAILS_ORG_LIST_REPORTS,           IDH_WAB_ORGANIZATION_REPORTS,

    IDC_DETAILS_FAMILY_STATIC_SPOUSE,       IDH_WAB_PERSONAL_SPOUSE,
    IDC_DETAILS_FAMILY_EDIT_SPOUSE,         IDH_WAB_PERSONAL_SPOUSE,
    IDC_DETAILS_FAMILY_STATIC_CHILDREN,     IDH_WAB_PERSONAL_CHILDREN,
    IDC_DETAILS_FAMILY_LIST_CHILDREN,       IDH_WAB_PERSONAL_CHILDREN,
    IDC_DETAILS_FAMILY_BUTTON_ADDCHILD,     IDH_WAB_PERSONAL_ADD,
    IDC_DETAILS_FAMILY_BUTTON_EDITCHILD,    IDH_WAB_PERSONAL_EDIT,
    IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD,  IDH_WAB_PERSONAL_REMOVE,
    IDC_DETAILS_FAMILY_STATIC_BIRTHDAY,     IDH_WAB_PERSONAL_BIRTHDAY,
    IDC_DETAILS_FAMILY_STATIC_ANNIVERSARY,  IDH_WAB_PERSONAL_ANNIVERSARY,
    IDC_DETAILS_FAMILY_DATE_BIRTHDAY,       IDH_WAB_PERSONAL_BIRTHDAY,
    IDC_DETAILS_FAMILY_DATE_ANNIVERSARY,    IDH_WAB_PERSONAL_ANNIVERSARY,


    0,0
};



/* 
    
    Structs for Filling in data in the PropSheets

    When filling in IDs into each property sheet, we do a GetProps on the displayed
    object for the specific Props needed for each page .. we then use the returned
    data to fill in the current prop sheet ..
    Named properties need some special handling since we can't pre-allocate them into the structs -
    the named properties need to be added prior to using them
    Non-string properties may also need special handling
  */


  /* -- Summary TAB info --*/
#define MAX_SUMMARY_ID 13

int rgSummaryIDs[] = 
{
    IDC_DETAILS_SUMMARY_STATIC_NAME,
    IDC_DETAILS_SUMMARY_STATIC_EMAIL,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX,
    IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE,
    IDC_DETAILS_SUMMARY_STATIC_PAGER,
    IDC_DETAILS_SUMMARY_STATIC_CELLULAR,
    IDC_DETAILS_SUMMARY_STATIC_JOBTITLE,
    IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT,
    IDC_DETAILS_SUMMARY_STATIC_OFFICE,
    IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB,
    IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB,
};

static const SizedSPropTagArray(MAX_SUMMARY_ID + 2, ptaUIDetlsPropsSummary) = 
{
    MAX_SUMMARY_ID + 2,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_COMPANY_NAME,
        PR_BUSINESS_HOME_PAGE,
        PR_PERSONAL_HOME_PAGE,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
    }
};

/* -- Personal/Name TAB info --*/

/*
 * [PaulHi] 4/8/99  Since the personal property sheet contains global properties
 * (i.e., the Ruby properties ... PR_WAB_YOMI_LASTNAME, PR_WAB_YOMI_FIRSTNAME), 
 * this tag array cannot be static.
static const SizedSPropTagArray(12, ptaUIDetlsPropsPersonal)=
{
    12,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_ADDRTYPES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_MIDDLE_NAME,
        PR_NICKNAME,
        PR_SEND_INTERNET_ENCODING,
        PR_DISPLAY_NAME_PREFIX
    }
};
*/

/* -- Home TAB info --*/
static SizedSPropTagArray(10, ptaUIDetlsPropsHome)=
{
    10,
    {
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_PERSONAL_HOME_PAGE,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_NULL,    /*PR_WAB_POSTALID*/
    }
};

/* -- Business TAB info --*/
static SizedSPropTagArray(15, ptaUIDetlsPropsBusiness)=
{
    15,
    {
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_HOME_PAGE,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_COMPANY_NAME,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_NULL,    /*PR_WAB_IPPHONE*/
        PR_NULL,    /*PR_WAB_POSTALID*/

    }
};

/* -- Notes TAB info --*/
static const SizedSPropTagArray(1, ptaUIDetlsPropsNotes)=
{
    1,
    {
        PR_COMMENT,
    }
};

/* -- Digital ID TAB info --*/
static const SizedSPropTagArray(1, ptaUIDetlsPropsCert)=
{
    1,
    {
        PR_USER_X509_CERTIFICATE,
    }
};

/* -- Family TAB info --*/
static const SizedSPropTagArray(5, ptaUIDetlsPropsFamily)=
{
    5,
    {
        PR_SPOUSE_NAME,
        PR_CHILDRENS_NAMES,
        PR_GENDER,
        PR_BIRTHDAY,
        PR_WEDDING_ANNIVERSARY,
    }
};



enum _ImgEmail
{
    imgNotDefaultEmail=0,
    imgDefaultEmail,
    imgChild
};

typedef struct _EmailItem
{
    TCHAR szDisplayText[EDIT_LEN*2];
    TCHAR szEmailAddress[EDIT_LEN];
    TCHAR szAddrType[EDIT_LEN];
    BOOL  bIsDefault;

} EMAIL_ITEM, * LPEMAIL_ITEM;


typedef struct _ServerItem
{
    LPTSTR lpServer;
    LPTSTR lpEmail;
} SERVER_ITEM, * LPSERVER_ITEM;


enum _CertValidity
{
    imgCertValid=0,
    imgCertInvalid
};


enum _ListViewType
{
    LV_EMAIL=0,
    LV_CERT,
    LV_SERVER,
    LV_KIDS
};


// forward declarations
LRESULT CALLBACK RubySubClassedProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int CreateDetailsPropertySheet(HWND hwndOwner,LPPROP_ARRAY_INFO lpPropArrayInfo);

INT_PTR CALLBACK fnSummaryProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnPersonalProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnHomeProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnBusinessProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnNotesProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnCertProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnTridentProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnConferencingProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnOrgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnFamilyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);

void FillComboWithEmailAddresses(LPPROP_ARRAY_INFO lpPai, HWND hWndCombo, int * lpnDefault);
void SetBackupServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce);
void SetDefaultServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce);
BOOL FillPersonalDetails(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillHomeBusinessNotesDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillCertTridentConfDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillFamilyDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL GetDetailsFromUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai , BOOL bSomethingChanged, int nPropSheet, LPSPropValue * lppPropArray, LPULONG lpulcPropCount);
BOOL SetDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, ULONG ulOperationType,int nPropSheet);

void CreateDateTimeControl(HWND hDlg, int idFrame, int idControl);
void AddLVNewChild(HWND hDlg, LPTSTR lpName);

void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome);
// [PaulHi] 4/5/99  Raid 57504  Enable the View Map button(s) for all locales.
// [PaulHi] 6/17/99 Raid 80805  Disable the View Map button again for various locales.
void ShowHideMapButton(HWND hWndButton);

HRESULT HrInitDetlsListView(HWND hWndLV, DWORD dwStyle, int nLVType);
void FreeLVParams(HWND hWndLV, int LVType);
void SetLVDefaultEmail( HWND hWndLV, int iItemIndex);
void AddLVEmailItem(HWND    hWndLV, LPTSTR  lpszEmailAddress, LPTSTR  lpszAddrType);
BOOL DeleteLVEmailItem(HWND hWndLV, int iItemIndex);
void ShowURL(HWND hWnd, int id, LPTSTR lpURL);
void SetHTTPPrefix(HWND hDlg, int id);
int AddNewEmailEntry(HWND hDlg, BOOL bShowCancelButton);
void SetDetailsWindowTitle(HWND hDlg, BOOL bModifyDisplayNameField);
void ShowRubyNameEntryDlg(HWND hDlg, LPPROP_ARRAY_INFO lpPai);

void SetComboDNText(HWND hDlg, LPPROP_ARRAY_INFO lpPAI, BOOL bAddAll, LPTSTR szTxt);
void FreeCertList(LPCERT_ITEM * lppCItem);

HRESULT HrSetCertInfoInUI(HWND hDlg, LPSPropValue lpPropMVCert, LPPROP_ARRAY_INFO lpPai);
BOOL AddLVCertItem(HWND hWndLV, LPCERT_ITEM lpCItem, BOOL bCheckForDups);
void SetLVDefaultCert( HWND hWndLV,int iItemIndex);
BOOL DeleteLVCertItem(HWND hWndLV, int iItemIndex, LPPROP_ARRAY_INFO lpPAI);
void ShowCertProps(HWND hDlg, HWND hWndLV, BOOL * lpBool);
BOOL ImportCert(HWND hDlg, LPPROP_ARRAY_INFO lpPai);
BOOL ExportCert(HWND hDlg);
void UpdateCertListView(HWND hDlg, LPPROP_ARRAY_INFO lpPai);

//HRESULT KillTrustInSleazyFashion(HWND hWndLV, int iItem);
void LocalFreeServerItem(LPSERVER_ITEM lpSI);
HRESULT HrAddEmailToObj(LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail, LPTSTR szAddrType);


//$$/////////////////////////////////////////////////////////////////
//
// Ensure lower case character
//
/////////////////////////////////////////////////////////////////////
TCHAR lowercase(TCHAR ch) {
    if (ch >= 'A' && ch <= 'Z') {
        ch = ch + ('a' - 'A');
    }
    return(ch);
}

//$$///////////////////////////////////////////////////////////////////
//
// bIsHttpPrefix(LPTSTR szBuf) - verify that the URL is http: not file://fdisk.exe
//
//$$///////////////////////////////////////////////////////////////////
BOOL bIsHttpPrefix(LPTSTR szBuf)
{
    // SECURITY: make sure it's http:
    if (lstrlen(szBuf) > 5)
    {
        if (lowercase(szBuf[0]) == 'h' &&
            lowercase(szBuf[1]) == 't' &&
            lowercase(szBuf[2]) == 't' &&
            lowercase(szBuf[3]) == 'p' &&
            lowercase(szBuf[4]) == ':')
        {
            return TRUE;
        }
        else
        {
            // BUGBUG: Susan Higgs wants a dialog here, but BruceK thinks
            // it's superfluous.  If people are nice to each other, we should
            // not ever get here.  I regard this as a last ditch line of
            // security to keep ruthless people from exploiting our use
            // of ShellExecute.
            DebugTrace( TEXT("Whoa!  Somebody's put something other than a web page in the web page slot!  %sf\n"), szBuf);
        }
    }
    return FALSE;
}


// TBD - merge these two functions HrShowDetails and HrShowOneOffDetails

//$$///////////////////////////////////////////////////////////////////
//
// HrShowOneOffDetails - shows read-onlydetails for one-off addresses
//
//
//  We either pass in a cbEntryID-lpEntryID combination or
//      we pass in a ulcValues-lpPropArray combination or
//      we pass in a lpPropObj to display
//
//  If we are displaying one-off props on a LDAP URL result, the LDAP
//  URL is also added so that it can be piped into extension prop sheets
//  that need the LDAP URL information
//
//////////////////////////////////////////////////////////////////////
HRESULT HrShowOneOffDetails(    LPADRBOOK lpAdrBook,
                                HWND    hWndParent,
                                ULONG   cbEntryID,
                                LPENTRYID   lpEntryID,
                                ULONG ulObjectType,
                                LPMAPIPROP lpPropObj,
                                LPTSTR szLDAPURL,
                                ULONG   ulFlags)
{
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i=0;
    PROP_ARRAY_INFO PropArrayInfo = {0};

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(ulFlags & WAB_ONEOFF_NOADDBUTTON)
    {
        ulFlags &= ~WAB_ONEOFF_NOADDBUTTON;
        PropArrayInfo.ulFlags |= DETAILS_HideAddToWABButton;
    }

    if ( ((!lpEntryID) && (!lpPropObj)) ||
         (ulFlags != SHOW_ONE_OFF))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(cbEntryID && lpEntryID)
    {
        // if this is a one-off address, do an open entry and then a get props to
        // get an lpPropArray from this guy ...

        if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                        cbEntryID,    // cbEntryID
                                                        lpEntryID,    // entryid
                                                        NULL,         // interface
                                                        0,                // ulFlags
                                                        &(PropArrayInfo.ulObjectType),
                                                        (LPUNKNOWN *)&(PropArrayInfo.lpPropObj) )))
        {
            // Failed!  Hmmm.
            if((HR_FAILED(hr)) && (MAPI_E_USER_CANCEL != hr))
            {
                int ids;
                UINT flags = MB_OK | MB_ICONEXCLAMATION;

                switch(hr)
                {
                case MAPI_E_UNABLE_TO_COMPLETE:
                case MAPI_E_AMBIGUOUS_RECIP:
                    ids = idsLDAPAmbiguousRecip;
                    break;
                case MAPI_E_NOT_FOUND:
                    ids = idsLDAPSearchNoResults;
                    break;
                case MAPI_E_NO_ACCESS:
                    ids = idsLDAPAccessDenied;
                    break;
                case MAPI_E_TIMEOUT:
                    ids = idsLDAPSearchTimedOut;
                    break;
                case MAPI_E_NETWORK_ERROR:
                    ids = idsLDAPCouldNotFindServer;
                    break;
                default:
                    ids = idsEntryNotFound;
                    break;
                }

                ShowMessageBox(  hWndParent, ids, flags);
            }
            goto out;
        }
    }
    else
    {
        PropArrayInfo.ulObjectType = ulObjectType;
        PropArrayInfo.lpPropObj = lpPropObj;
    }


    if (HR_FAILED(hr = PropArrayInfo.lpPropObj->lpVtbl->GetProps(PropArrayInfo.lpPropObj,
                                        NULL, MAPI_UNICODE,
                                        &cValues,     // how many properties were there?
                                        &lpPropArray)))
    {
        goto out;
    }

    if (cValues == 0)
    {
        // nothing to show
        hr = E_FAIL;
        goto out;
    }
    else
        PropArrayInfo.ulFlags |= DETAILS_ShowSummary;

    PropArrayInfo.lpIAB = lpAdrBook;

    //Now we can call the property sheets ...
    PropArrayInfo.cbEntryID = 0;    //this will be ignored for one-offs
    PropArrayInfo.lpEntryID = NULL;
    PropArrayInfo.bSomethingChanged = FALSE;

    for(i=0;i<TOTAL_PROP_SHEETS;i++)
        PropArrayInfo.bPropSheetOpened[i] = FALSE;

    PropArrayInfo.ulOperationType = SHOW_ONE_OFF;
    PropArrayInfo.nRetVal = DETAILS_RESET;

    if(InitCryptoLib())
        PropArrayInfo.ulFlags |= DETAILS_ShowCerts;

    // Do we show the org tab ?
    for(i=0;i<cValues;i++)
    {
        if( lpPropArray[i].ulPropTag == PR_WAB_MANAGER ||
            lpPropArray[i].ulPropTag == PR_WAB_REPORTS )
        {
            PropArrayInfo.ulFlags |= DETAILS_ShowOrg;
            break;
        }
    }

    // Check if we need to show the Trident Pane
#ifndef WIN16 // WIN16FF
    for(i=0;i<cValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_LDAP_LABELEDURI)
        {
            if(lstrlen(lpPropArray[i].Value.LPSZ) &&
               bIsHttpPrefix((LPTSTR)lpPropArray[i].Value.LPSZ) )
            {
                // We have the correct property, now check - do we have Trident installed
                // on this machine ???
                hr = HrNewWABDocHostObject(&(PropArrayInfo.lpIWABDocHost));
                if(!HR_FAILED(hr) && PropArrayInfo.lpIWABDocHost)
                {
                    // Check to see if we can load IE4 and whether its the right
                    // version of IE4 .. <TBD> this should actually be a global so we
                    // dont do this for each entry ...
                    // <TBD> dont hardcode these strings ..
                    LPDLLGETVERSIONPROC lpfnDllGetVersionProc = NULL;
                    HINSTANCE hTrident = LoadLibrary( TEXT("shdocvw.dll"));
                    if(hTrident)
                    {
                        lpfnDllGetVersionProc = (LPDLLGETVERSIONPROC) GetProcAddress(hTrident, "DllGetVersion");
                        if(lpfnDllGetVersionProc)
                        {
                            // Check the version number
                            DLLVERSIONINFO dvi = {0};
                            dvi.cbSize = sizeof(dvi);
                            lpfnDllGetVersionProc(&dvi);
                            // we are looking for IE4 version 4.71.0544.1 or more
                            if( dvi.dwMajorVersion > 4 ||
                                (dvi.dwMajorVersion == 4 && dvi.dwMinorVersion >= 71 && dvi.dwBuildNumber >= 544))
                            {
                                PropArrayInfo.ulFlags |= DETAILS_ShowTrident;
                            }
                        }
                        FreeLibrary(hTrident);
                    }
                }
            }
            break;
        }
    }
#endif

    // if this is an ldap entry, turn the ldap entryid into an ldapurl and pass that
    // to the extension prop sheets .. this enables the NTDS prop sheets to appropriately 
    // display themselves ..
    if( cbEntryID && lpEntryID )
    {
        LPTSTR lpURL = NULL;
        CreateLDAPURLFromEntryID(cbEntryID, lpEntryID, &lpURL, &PropArrayInfo.bIsNTDSURL);
        PropArrayInfo.lpLDAPURL = lpURL;
    }
    else
        PropArrayInfo.lpLDAPURL = szLDAPURL;

    GetExtDisplayInfo((LPIAB)lpAdrBook, &PropArrayInfo, TRUE, TRUE);

    if (CreateDetailsPropertySheet(hWndParent,&PropArrayInfo) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }

    //  This was a read only operation so we dont care for the results ...
    //  so nothing more to do ....
    if(PropArrayInfo.nRetVal == DETAILS_ADDTOWAB)
    {
        ULONG cbEID = 0, cbPABEID = 0;
        LPENTRYID lpEID = NULL, lpPABEID = NULL;

        // We need to strip out the PR_WAB_LDAP_LABELEDURI prop and the
        // old entryid if it exists
        for(i=0;i<cValues;i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_WAB_LDAP_LABELEDURI:
                // remove the ldap url from this object
            case PR_ENTRYID:
                lpPropArray[i].ulPropTag = PR_NULL;
                break;
            }
            if(lpPropArray[i].ulPropTag == PR_WAB_MANAGER ||
               lpPropArray[i].ulPropTag == PR_WAB_REPORTS )
                 lpPropArray[i].ulPropTag = PR_NULL;
        }

        if(!HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbPABEID, &lpPABEID)))
        {
            hr = HrCreateNewEntry(  lpAdrBook,
                                    hWndParent,
                                    MAPI_MAILUSER,   //MAILUSER or DISTLIST
                                    cbPABEID, lpPABEID, 
                                    MAPI_ABCONT,//container entryid
                                    CREATE_CHECK_DUP_STRICT,
                                    TRUE,
                                    cValues,
                                    lpPropArray,
                                    &cbEID,
                                    &lpEID);
        }

        if(lpPABEID)
            MAPIFreeBuffer(lpPABEID);
        if(lpEID)
            MAPIFreeBuffer(lpEID);
    }

out:

    if(PropArrayInfo.lpLDAPURL && PropArrayInfo.lpLDAPURL!=szLDAPURL)
        LocalFree(PropArrayInfo.lpLDAPURL);

    LocalFreeAndNull(&PropArrayInfo.lpszOldName);

    FreeExtDisplayInfo(&PropArrayInfo);

    if(PropArrayInfo.szDefaultServerName)
        LocalFree(PropArrayInfo.szDefaultServerName);

    if(PropArrayInfo.szBackupServerName)
        LocalFree(PropArrayInfo.szBackupServerName);

    if(PropArrayInfo.lpIWABDocHost)
        (PropArrayInfo.lpIWABDocHost)->lpVtbl->Release(PropArrayInfo.lpIWABDocHost);

    if(PropArrayInfo.lpPropObj && !lpPropObj)
        PropArrayInfo.lpPropObj->lpVtbl->Release(PropArrayInfo.lpPropObj);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}



//$$/////////////////////////////////////////////////////////////////
//
//  HrShowDetails - shows details/new entry UI
//
//  lpIAB           -   lpAdrBook object
//  hWndParent      -   hWnd of parent
//  hPropertyStore  - Handle to property store (can be retrieved from lpIAB)
//  cbEIDContainer  - EntryID of container in which to create the entry
//  lpEIDContainer  - EntryID of container in which to create the entry
//  lppEntryID      - entry id of object to display .. if a new object,
//                      contains the lpentryid of the created object
//  lpPropObj       - sometimes used in lieu of the entryid .. useful for
//                      adding objects like vCards and LDAP entries which have
//                      an object but dont currently exist in the WAB
//  ulFlags         - unused
//  lpbChangesMade  - Indicates if object was modified or not
//
///////////////////////////////////////////////////////////////////
HRESULT HrShowDetails(  LPADRBOOK   lpIAB,
                        HWND        hWndParent,
                        HANDLE      hPropertyStore,
                        ULONG       cbEIDContainer,
                        LPENTRYID   lpEIDContainer,
                        ULONG       *lpcbEntryID,
                        LPENTRYID   *lppEntryID,
                        LPMAPIPROP  lpPropObj,      // [optional] IN:IMAPIProp object
                        ULONG       ulFlags,
                        ULONG       ulObjectType,
                        BOOL    *   lpbChangesMade)
{
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;

    ULONG cbpta = 0;
    ULONG ulNumOldProps = 0;

    ULONG cbEntryID = 0;
    LPENTRYID lpEntryID = NULL;

    int     nRet = 0, nRetVal = 0;
    ULONG i = 0, j = 0, k = 0;
    PROP_ARRAY_INFO PropArrayInfo = {0};
    BOOL bChanges = FALSE;

    ULONG nMaxSheets = 0;

    DebugPrintTrace(( TEXT("----------\nHrShowDetails Entry\n")));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(lppEntryID)
        lpEntryID = *lppEntryID;

    if (lpcbEntryID)
        cbEntryID = *lpcbEntryID;


    if (    (!(ulFlags & SHOW_OBJECT) && hPropertyStore == NULL) ||
            ( (ulFlags & SHOW_DETAILS) && (lpEntryID == NULL)) ||
            ( (ulFlags & SHOW_OBJECT) && (lpPropObj == NULL)))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(cbEntryID && lpEntryID)
    {
        PropArrayInfo.cbEntryID = cbEntryID;
        PropArrayInfo.lpEntryID = LocalAlloc(LMEM_ZEROINIT, cbEntryID);

        CopyMemory(PropArrayInfo.lpEntryID, lpEntryID, cbEntryID);
        PropArrayInfo.ulFlags |= DETAILS_ShowSummary;
    }
    else if (ulFlags & SHOW_DETAILS)
    {
        // cant show details without a valid entryid
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpbChangesMade = FALSE;

    if (ulFlags & SHOW_DETAILS)
    {
        if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    MAPI_BEST_ACCESS,                // ulFlags
                                                    &(PropArrayInfo.ulObjectType),
                                                    (LPUNKNOWN *)&(PropArrayInfo.lpPropObj) )))
        {
            // Failed!  Hmmm.
            goto out;
        }
    }
    else if (ulFlags & SHOW_OBJECT)
    {
        Assert(lpPropObj);
        PropArrayInfo.lpPropObj = lpPropObj;
        PropArrayInfo.ulObjectType = ulObjectType;
    }
    else
    {
        SBinary sb = {0};
        sb.cb = cbEIDContainer;
        sb.lpb = (LPBYTE) lpEIDContainer;
        if(HR_FAILED(hr = HrCreateNewObject(    lpIAB,
                                                &sb,
                                                ulObjectType,
                                                0,
                                                &(PropArrayInfo.lpPropObj))))
        {
            goto out;
        }
        PropArrayInfo.ulObjectType = ulObjectType;
        PropArrayInfo.cbEntryID = 0;
        PropArrayInfo.lpEntryID = NULL;
        PropArrayInfo.ulFlags |= DETAILS_DNisFMLName;
    }

    PropArrayInfo.lpIAB = lpIAB;

    nMaxSheets = (ulObjectType == MAPI_DISTLIST) ? propDLMax : TOTAL_PROP_SHEETS;

    for(i=0;i<nMaxSheets;i++)
        PropArrayInfo.bPropSheetOpened[i] = FALSE;

    PropArrayInfo.ulOperationType = ulFlags;
    PropArrayInfo.nRetVal = DETAILS_RESET;
    PropArrayInfo.bSomethingChanged = FALSE;

    if(InitCryptoLib())
        PropArrayInfo.ulFlags |= DETAILS_ShowCerts;

    // Never show trident for regular people - only for LDAP contacts
    // PropArrayInfo.bShowTrident = FALSE;

    GetExtDisplayInfo((LPIAB) lpIAB, &PropArrayInfo, FALSE, (ulObjectType == MAPI_MAILUSER));

    if(ulObjectType == MAPI_MAILUSER)
    {
        if (CreateDetailsPropertySheet(hWndParent,&PropArrayInfo) == -1)
        {
            // Something failed ...
            hr = E_FAIL;
            goto out;
        }
    }
    else
    {
        if (CreateDLPropertySheet(hWndParent,&PropArrayInfo) == -1)
        {
            // Something failed ...
            hr = E_FAIL;
            goto out;
        }
    }

    if (PropArrayInfo.nRetVal == DETAILS_CANCEL)
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    bChanges = PropArrayInfo.bSomethingChanged;

    /*
    if(!bChanges)
    {
        for(i=0;i<nMaxSheets;i++)
        {
            if(PropArrayInfo.bPropSheetOpened[i])
            {
                // The returned prop array is not null
                // or the sheet was opened (which should return something) but
                // the returned array is null (which means every thing on that
                // particular sheet has been deleted).

                bChanges = TRUE;
                break;
            }
        }
    }
    */

    if(!bChanges && PropArrayInfo.lpWED)
    {
        if(PropArrayInfo.lpWED->fDataChanged)
        {
            bChanges = TRUE;
        }
    }

    if (!bChanges) goto out;

    // if its an object, dont save changes yet
    if(!(ulFlags & SHOW_OBJECT))
    {
        // Bug: 56220 - a retail-only bug in which for some reason the ObjAccess flag on
        // Groups gets reset to IPROP_READONLY which causes a write failure. I can't figure out
        // the cause for the problem but as a temporary solution, I'm forcing the access flag to
        // say READWRITE and everythng works fine then. Note that if we're at this code point, then
        // the object flag will ALWAYS be READWRITE anyway
        ((LPMailUser)PropArrayInfo.lpPropObj)->ulObjAccess = IPROP_READWRITE;

        hr = (PropArrayInfo.lpPropObj)->lpVtbl->SaveChanges( (PropArrayInfo.lpPropObj),               // this
                                            KEEP_OPEN_READWRITE);
        if(hr == MAPI_E_NOT_ENOUGH_DISK)
                hr = HandleSaveChangedInsufficientDiskSpace( hWndParent,
                                                            (LPMAILUSER) PropArrayInfo.lpPropObj);
        *lpbChangesMade = TRUE;
    }

    // if we want entryids back, make sure we get them
    {
        if(lppEntryID && lpcbEntryID && !*lppEntryID && !*lpcbEntryID)
        {
            LPSPropValue lpSPV = NULL;
            ULONG ulSPV = 0;
            if(!HR_FAILED(hr = (PropArrayInfo.lpPropObj)->lpVtbl->GetProps(PropArrayInfo.lpPropObj,
                                                                          (LPSPropTagArray)&ptaEid, MAPI_UNICODE,
                                                                          &ulSPV, &lpSPV)))
            {
                if(lpSPV[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID)
                {
                    sc = MAPIAllocateBuffer(lpSPV[ieidPR_ENTRYID].Value.bin.cb, lppEntryID);
                    if(!sc)
                    {
                        *lpcbEntryID = lpSPV[ieidPR_ENTRYID].Value.bin.cb;
                        CopyMemory(*lppEntryID, lpSPV[ieidPR_ENTRYID].Value.bin.lpb, *lpcbEntryID);
                    }
                }
                MAPIFreeBuffer(lpSPV);
            }
        }
    }

    hr = S_OK;

out:
    FreeExtDisplayInfo(&PropArrayInfo);

    LocalFreeAndNull(&PropArrayInfo.lpszOldName);

    if(PropArrayInfo.szDefaultServerName)
        LocalFree(PropArrayInfo.szDefaultServerName);

    if(PropArrayInfo.szBackupServerName)
        LocalFree(PropArrayInfo.szBackupServerName);

    if(PropArrayInfo.lpEntryID)
        LocalFree(PropArrayInfo.lpEntryID);

    if(PropArrayInfo.lpPropObj && !lpPropObj)
        PropArrayInfo.lpPropObj->lpVtbl->Release(PropArrayInfo.lpPropObj);

    return hr;
}




/*//$$***************************************************************************
*    FUNCTION: CreateDetailsPropertySheet(HWND)
*
*    PURPOSE:  Creates the Details property sheet
*
****************************************************************************/
int CreateDetailsPropertySheet(HWND hwndOwner,
                               LPPROP_ARRAY_INFO lpPropArrayInfo)
{
    PROPSHEETPAGE psp[TOTAL_PROP_SHEETS];
    PROPSHEETHEADER psh;
    //TCHAR szBuf[TOTAL_PROP_SHEETS][MAX_UI_STR];
    LPTSTR * szBuf = NULL;
    TCHAR szBuf2[MAX_UI_STR];
    ULONG ulProp = 0;
    ULONG ulTotal = 0;
    HPROPSHEETPAGE * lph = NULL;
    ULONG ulCount = 0;
    int i = 0;
    int nRet = 0;
    BOOL bRet = FALSE;
    // If it's an NTDS entry and we have the requisite prop sheets, then we are going to hide the 
    // WAB's version of the prop sheets and show the NTDS ones upfront instead
    //
    //  NTDS folks want us to hide the following: personal, home, business and other
    //      
    BOOL bShowNTDSProps = ( lpPropArrayInfo->nNTDSPropSheetPages && 
                            lpPropArrayInfo->lphNTDSpages &&
                            lpPropArrayInfo->bIsNTDSURL);

    ulTotal = TOTAL_PROP_SHEETS // Predefined ones +
            + lpPropArrayInfo->nPropSheetPages 
            + lpPropArrayInfo->nNTDSPropSheetPages;

    if(!(szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*TOTAL_PROP_SHEETS)))
        goto out;
    for(i=0;i<TOTAL_PROP_SHEETS;i++)
    {
        if(!(szBuf[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_UI_STR)))
            goto out;
    }
    
    lph = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * ulTotal);
    if(!lph)
        goto out;

    psh.nStartPage = 0;

    //
    // Initialize info for the various property sheets
    //
    if( (lpPropArrayInfo->ulFlags & DETAILS_ShowSummary) && !bShowNTDSProps )
    {
        // Personal
        psp[propSummary].dwSize = sizeof(PROPSHEETPAGE);
        psp[propSummary].dwFlags = PSP_USETITLE;
        psp[propSummary].hInstance = hinstMapiX;
        psp[propSummary].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_SUMMARY);
        psp[propSummary].pszIcon = NULL;
        psp[propSummary].pfnDlgProc = (DLGPROC) fnSummaryProc;
        LoadString(hinstMapiX, idsDetailsSummaryTitle, szBuf[propSummary], MAX_UI_STR);
        psp[propSummary].pszTitle = szBuf[propSummary];
        psp[propSummary].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propSummary]));
        if(lph[ulCount])
            ulCount++;

        // Start page is personal page
        psh.nStartPage = propSummary;
    }

    if(!bShowNTDSProps)
    {
        // Personal
        // Check if this is Japan/China/Korea and use the RUBY personal prop sheet instead
        if(bIsRubyLocale())
            lpPropArrayInfo->ulFlags |= DETAILS_UseRubyPersonal;

        psp[propPersonal].dwSize = sizeof(PROPSHEETPAGE);
        psp[propPersonal].dwFlags = PSP_USETITLE;
        psp[propPersonal].hInstance = hinstMapiX;
        psp[propPersonal].pszTemplate = MAKEINTRESOURCE((lpPropArrayInfo->ulFlags & DETAILS_UseRubyPersonal) ? IDD_DETAILS_PERSONAL_RUBY : IDD_DETAILS_PERSONAL);
        psp[propPersonal].pszIcon = NULL;
        psp[propPersonal].pfnDlgProc = (DLGPROC) fnPersonalProc;
        LoadString(hinstMapiX, idsName, szBuf[propPersonal], MAX_UI_STR);
        psp[propPersonal].pszTitle = szBuf[propPersonal];
        psp[propPersonal].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propPersonal]));

        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Home
        psp[propHome].dwSize = sizeof(PROPSHEETPAGE);
        psp[propHome].dwFlags = PSP_USETITLE;
        psp[propHome].hInstance = hinstMapiX;
        psp[propHome].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_HOME);
        psp[propHome].pszIcon = NULL;
        psp[propHome].pfnDlgProc = (DLGPROC) fnHomeProc;
        LoadString(hinstMapiX, idsDetailsHomeTitle, szBuf[propHome], MAX_UI_STR);
        psp[propHome].pszTitle = szBuf[propHome];
        psp[propHome].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propHome]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Business
        psp[propBusiness].dwSize = sizeof(PROPSHEETPAGE);
        psp[propBusiness].dwFlags = PSP_USETITLE;
        psp[propBusiness].hInstance = hinstMapiX;
        psp[propBusiness].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_BUSINESS);
        psp[propBusiness].pszIcon = NULL;
        psp[propBusiness].pfnDlgProc = (DLGPROC) fnBusinessProc;
        LoadString(hinstMapiX, idsDetailsBusinessTitle, szBuf[propBusiness], MAX_UI_STR);
        psp[propBusiness].pszTitle = szBuf[propBusiness];
        psp[propBusiness].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propBusiness]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        psp[propFamily].dwSize = sizeof(PROPSHEETPAGE);
        psp[propFamily].dwFlags = PSP_USETITLE;
        psp[propFamily].hInstance = hinstMapiX;
        psp[propFamily].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_FAMILY);
        psp[propFamily].pszIcon = NULL;
        psp[propFamily].pfnDlgProc = (DLGPROC) fnFamilyProc;
        LoadString(hinstMapiX, idsDetailsPersonalTitle, szBuf[propFamily], MAX_UI_STR);
        psp[propFamily].pszTitle = szBuf[propFamily];
        psp[propFamily].lParam = (LPARAM) lpPropArrayInfo;
        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propFamily]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Notes
        psp[propNotes].dwSize = sizeof(PROPSHEETPAGE);
        psp[propNotes].dwFlags = PSP_USETITLE;
        psp[propNotes].hInstance = hinstMapiX;
        psp[propNotes].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_NOTES);
        psp[propNotes].pszIcon = NULL;
        psp[propNotes].pfnDlgProc = (DLGPROC) fnNotesProc;
        LoadString(hinstMapiX, idsDetailsNotesTitle, szBuf[propNotes], MAX_UI_STR);
        psp[propNotes].pszTitle = szBuf[propNotes];
        psp[propNotes].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propNotes]));
        if(lph[ulCount])
            ulCount++;
    }

    if(bShowNTDSProps) //now insert the NTDS props at this point instead of the above lot..
    {
        // Now do the extended props if any
        for(i=0;i<lpPropArrayInfo->nNTDSPropSheetPages;i++)
        {
            if(lpPropArrayInfo->lphNTDSpages)
            {
                lph[ulCount] = lpPropArrayInfo->lphNTDSpages[i];
                ulCount++;
            }
        }
    }

    // Conferencing
    psp[propConferencing].dwSize = sizeof(PROPSHEETPAGE);
    psp[propConferencing].dwFlags = PSP_USETITLE;
    psp[propConferencing].hInstance = hinstMapiX;
    psp[propConferencing].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_NTMTG);
    psp[propConferencing].pszIcon = NULL;
    psp[propConferencing].pfnDlgProc = (DLGPROC) fnConferencingProc;
    {
        TCHAR sz[MAX_PATH];
        LONG cbSize = CharSizeOf(sz);
        *sz='\0';
        if(RegQueryValue(HKEY_LOCAL_MACHINE, szInternetCallKey, sz, &cbSize) == ERROR_SUCCESS
           && lstrlen(sz)
           && !lstrcmpi(sz,TEXT("Microsoft NetMeeting")))
        {
            lstrcpy(szBuf[propConferencing], TEXT("NetMeeting"));
        }
        else
            LoadString(hinstMapiX, idsDetailsConferencingTitle, szBuf[propConferencing], MAX_UI_STR);
    }
    psp[propConferencing].pszTitle = szBuf[propConferencing];
    psp[propConferencing].lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propConferencing]));
    if(lph[ulCount])
        ulCount++;


    ulProp = propConferencing + 1;


    if(lpPropArrayInfo->ulFlags & DETAILS_ShowCerts)
    {
        // Certificates
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_CERT);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = (DLGPROC) fnCertProc;
        LoadString(hinstMapiX, idsDetailsCertTitle, szBuf[propCert], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propCert];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
            ulCount++;

        ulProp++;
    }


    if( !bShowNTDSProps &&
        (lpPropArrayInfo->ulFlags & DETAILS_ShowOrg) )
    {
        // Organization
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_ORG);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = (DLGPROC) fnOrgProc;
        LoadString(hinstMapiX, idsDetailsOrgTitle, szBuf[propOrg], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propOrg];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
            ulCount++;

        ulProp++;
    }


    if(lpPropArrayInfo->ulFlags & DETAILS_ShowTrident)
    {
        // Trident sheet
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_TRIDENT);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = (DLGPROC) fnTridentProc;
        LoadString(hinstMapiX, idsDetailsTridentTitle, szBuf[propTrident], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propTrident];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;
        
        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
        {
            // Start page is trident page
            psh.nStartPage = ulCount;
            ulCount++;
        }

        lpPropArrayInfo->ulTridentPageIndex = ulProp;
        ulProp++;
    }


    // Now do the extended props if any
    for(i=0;i<lpPropArrayInfo->nPropSheetPages;i++)
    {
        if(lpPropArrayInfo->lphpages)
        {
            lph[ulCount] = lpPropArrayInfo->lphpages[i];
            ulCount++;
        }
    }

/*** US dialogs get truncated on FE OSes .. we want the comctl to fix the truncation
     but this is only implemented in IE4.01 and beyond .. the problem with this being 
     that wab is specifically compiled with the IE = 0x0300 so we're not pulling in the
     correct flag from the commctrl header .. so we will define the flag here and pray
     that commctrl never changes it ***/
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
/***                                ***/

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW;
    if(bIsIE401OrGreater())
        psh.dwFlags |= PSH_USEPAGELANG;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, CharSizeOf(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = ulCount; // ulProp //sizeof(psp) / sizeof(PROPSHEETPAGE);

    psh.phpage = lph;

    nRet = (int) gpfnPropertySheet(&psh);

    bRet = TRUE;
out:
    LocalFreeAndNull((LPVOID*)&lph);

    if(szBuf)
    {
        for(i=0;i<TOTAL_PROP_SHEETS;i++)
            LocalFreeAndNull(&(szBuf[i]));
        LocalFreeAndNull((LPVOID*)&szBuf);
    }
    return nRet;
}

/*  Filling in the Data in a Prop Sheet

        Since most props handled in the UI are string props, and it's just a 
        matter of doing SetText/GetText with the data on the appropriate edit
        control, we create control-property pairs of edit-controls and string props 
        and use them to fill in props in a simple loop

        Non string props and named props end up needing special handling
  */

typedef struct _tagIDProp
{
    ULONG ulPropTag;
    int   idCtl;

} ID_PROP;


// Control IDs corresponding to the Personal property sheet

ID_PROP idPropPersonal[]=
{
    {PR_DISPLAY_NAME,   IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME},
    {PR_GIVEN_NAME,     IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME},
    {PR_SURNAME,        IDC_DETAILS_PERSONAL_EDIT_LASTNAME},
    {PR_MIDDLE_NAME,    IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME},
    {PR_NICKNAME,       IDC_DETAILS_PERSONAL_EDIT_NICKNAME},
    {PR_DISPLAY_NAME_PREFIX, IDC_DETAILS_PERSONAL_EDIT_TITLE},
    {0,                 IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL},
    {PR_NULL/*YOMI_LAST*/,IDC_DETAILS_PERSONAL_STATIC_RUBYLAST},
    {PR_NULL/*YOMI_FIRST*/,IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST}
};
const ULONG idPropPersonalCount = 9;



// Control IDs corresponding to the Home property sheet

ID_PROP idPropHome[]=
{
    {PR_HOME_ADDRESS_STREET,             IDC_DETAILS_HOME_EDIT_ADDRESS},
    {PR_HOME_ADDRESS_CITY,               IDC_DETAILS_HOME_EDIT_CITY},
    {PR_HOME_ADDRESS_POSTAL_CODE,        IDC_DETAILS_HOME_EDIT_ZIP},
    {PR_HOME_ADDRESS_STATE_OR_PROVINCE,  IDC_DETAILS_HOME_EDIT_STATE},
    {PR_HOME_ADDRESS_COUNTRY,            IDC_DETAILS_HOME_EDIT_COUNTRY},
    {PR_PERSONAL_HOME_PAGE,              IDC_DETAILS_HOME_EDIT_URL},
    {PR_HOME_TELEPHONE_NUMBER,           IDC_DETAILS_HOME_EDIT_PHONE},
    {PR_HOME_FAX_NUMBER,                 IDC_DETAILS_HOME_EDIT_FAX},
    {PR_CELLULAR_TELEPHONE_NUMBER,       IDC_DETAILS_HOME_EDIT_CELLULAR},
    {PR_NULL/*PR_WAB_POSTALID*/,         IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS},
};
#define idPropHomePostalID     9 // since POSTALID is dynamically generated prop, it needs to be reset anytime the array is used
const ULONG idPropHomeCount = 10;


// Control IDs corresponding to the Business property sheet

ID_PROP idPropBusiness[]=
{
    {PR_BUSINESS_ADDRESS_STREET,         IDC_DETAILS_BUSINESS_EDIT_ADDRESS},
    {PR_BUSINESS_ADDRESS_CITY,           IDC_DETAILS_BUSINESS_EDIT_CITY},
    {PR_BUSINESS_ADDRESS_POSTAL_CODE,    IDC_DETAILS_BUSINESS_EDIT_ZIP},
    {PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,  IDC_DETAILS_BUSINESS_EDIT_STATE},
    {PR_BUSINESS_ADDRESS_COUNTRY,        IDC_DETAILS_BUSINESS_EDIT_COUNTRY},
    {PR_BUSINESS_HOME_PAGE,              IDC_DETAILS_BUSINESS_EDIT_URL},
    {PR_BUSINESS_TELEPHONE_NUMBER,       IDC_DETAILS_BUSINESS_EDIT_PHONE},
    {PR_BUSINESS_FAX_NUMBER,             IDC_DETAILS_BUSINESS_EDIT_FAX},
    {PR_PAGER_TELEPHONE_NUMBER,          IDC_DETAILS_BUSINESS_EDIT_PAGER},
    {PR_COMPANY_NAME,                    IDC_DETAILS_BUSINESS_EDIT_COMPANY},
    {PR_TITLE,                           IDC_DETAILS_BUSINESS_EDIT_JOBTITLE},
    {PR_DEPARTMENT_NAME,                 IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT},
    {PR_OFFICE_LOCATION,                 IDC_DETAILS_BUSINESS_EDIT_OFFICE},
    {PR_NULL/*PR_WAB_IPPHONE*/,          IDC_DETAILS_BUSINESS_EDIT_IPPHONE},
    {PR_NULL/*PR_WAB_POSTALID*/,         IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS},
};
#define idPropBusIPPhone    13 // since PR_WAB_IPPHONE is dynamically generated prop, it needs to be reset anytime the array is used
#define idPropBusPostalID   14 // since POSTALID is dynamically generated prop, it needs to be reset anytime the array is used
const ULONG idPropBusinessCount = 15;


// Control IDs corresponding to the Notes property sheet
ID_PROP idPropNotes[] =
{
    {PR_COMMENT,    IDC_DETAILS_NOTES_EDIT_NOTES} //PR_COMMENT
};
const ULONG idPropNotesCount = 1;

// Control IDs corresponding to the Family property sheet
ID_PROP idPropFamily[] = 
{
    {PR_SPOUSE_NAME, IDC_DETAILS_FAMILY_EDIT_SPOUSE},
    {PR_GENDER, IDC_DETAILS_HOME_COMBO_GENDER},
    {PR_BIRTHDAY, IDC_DETAILS_FAMILY_DATE_BIRTHDAY},
    {PR_WEDDING_ANNIVERSARY, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY},
    {PR_CHILDRENS_NAMES, IDC_DETAILS_FAMILY_LIST_CHILDREN}
};
const ULONG idPropFamilyCount = 5;


/*  
    A list of all the buttons on all the propsheets .. this is mostly used to render the buttons
    disabled when reading read-only data (such as vCards and LDAP)
    */
ULONG idSetReadOnlyControls[] = {
    IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL,
    IDC_DETAILS_PERSONAL_BUTTON_REMOVE,
    IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT,
    IDC_DETAILS_PERSONAL_BUTTON_EDIT,
    IDC_DETAILS_HOME_BUTTON_URL,
    IDC_DETAILS_BUSINESS_BUTTON_URL,
    IDC_DETAILS_CERT_BUTTON_PROPERTIES,
    IDC_DETAILS_CERT_BUTTON_REMOVE,
    IDC_DETAILS_CERT_BUTTON_SETDEFAULT,
    IDC_DETAILS_CERT_BUTTON_IMPORT,
    IDC_DETAILS_CERT_BUTTON_EXPORT,
    IDC_DETAILS_NTMTG_BUTTON_ADDSERVER,
    IDC_DETAILS_NTMTG_BUTTON_EDIT,
    IDC_DETAILS_NTMTG_BUTTON_REMOVE,
    IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT,
    IDC_DETAILS_NTMTG_BUTTON_SETBACKUP,
    IDC_DETAILS_NTMTG_COMBO_EMAIL,
    IDC_DETAILS_NTMTG_LIST_SERVERS,
    IDC_DETAILS_NTMTG_EDIT_ADDSERVER,
    IDC_DETAILS_FAMILY_EDIT_SPOUSE,
    IDC_DETAILS_FAMILY_LIST_CHILDREN,
    IDC_DETAILS_FAMILY_BUTTON_ADDCHILD,
    IDC_DETAILS_FAMILY_BUTTON_EDITCHILD,
    IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD,
    IDC_DETAILS_FAMILY_DATE_BIRTHDAY,
    IDC_DETAILS_FAMILY_DATE_ANNIVERSARY,
    IDC_DETAILS_HOME_COMBO_GENDER,
    IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS,
    IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS,
    IDC_DETAILS_PERSONAL_LIST,
    IDC_DETAILS_PERSONAL_CHECK_RICHINFO,
    IDC_DETAILS_CERT_LIST,
    IDC_DETAILS_CERT_COMBO,

};
const ULONG idSetReadOnlyCount = 33;



/*//$$***************************************************************************
*    FUNCTION: SetDetailsUI
*
*    PURPOSE:  Generic function that is used for doing the legwork for preparing
*           the prop sheet to receive the data. This will include setting the text limits
*           rendering controls read-only etc. Most of the propsheets call this same
*           function since there is a lot of common work for each property sheet.
*           To add future prop sheets, you can extend this function or you can just
*           write your own...
*
****************************************************************************/
BOOL SetDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, ULONG ulOperationType, int nPropSheet)
{
    ULONG i =0;
    ID_PROP * lpidProp = NULL;
    ULONG idCount = 0;

    switch(nPropSheet)
    {
    case propPersonal:
        //Check the send-plain text check box on the UI off by default
        CheckDlgButton(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO, BST_UNCHECKED);
        // Initialize the list view
        lpPai->hWndDisplayNameField = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), LVS_REPORT, LV_EMAIL);
        if (ulOperationType == SHOW_ONE_OFF)
        {
            EnableWindow(lpPai->hWndDisplayNameField , FALSE);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
        }
        lpidProp = idPropPersonal;
        idCount = idPropPersonalCount;
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),FALSE);
        SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME),
                    CB_LIMITTEXT, (WPARAM) EDIT_LEN, 0);
        if(lpPai->ulFlags & DETAILS_UseRubyPersonal)
        {
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, szEmpty);
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, szEmpty);

            // [PaulHi] 3/29/99 Subclass the first and last name edit boxes.  The
            // static Ruby fields will be updated automatically.
            // Only do this for Japanese locales.
            if (GetUserDefaultLCID() == 0x0411)
            {
                HWND    hWndEdit;
                WNDPROC OldWndProc = NULL;

                hWndEdit = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME);
                Assert(hWndEdit);
                OldWndProc = (WNDPROC)SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)RubySubClassedProc);
                Assert(GetWindowLongPtr(hWndEdit, GWLP_USERDATA) == 0);
                SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)OldWndProc);

                hWndEdit = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME);
                Assert(hWndEdit);
                OldWndProc = (WNDPROC)SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)RubySubClassedProc);
                Assert(GetWindowLongPtr(hWndEdit, GWLP_USERDATA) == 0);
                SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)OldWndProc);
            }
        }
        break;

    case propHome:
        lpidProp = idPropHome;
        idCount = idPropHomeCount;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        ShowHideMapButton(GetDlgItem(hDlg, IDC_DETAILS_HOME_BUTTON_MAP));
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_PHONE), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_FAX), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_CELLULAR), (HIMC) NULL);
        break;

    case propBusiness:
        lpidProp = idPropBusiness;
        idCount = idPropBusinessCount;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;

        ShowHideMapButton(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_BUTTON_MAP));
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_PHONE), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_FAX), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_PAGER), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_IPPHONE), (HIMC) NULL);
        break;

    case propNotes:
        lpidProp = idPropNotes;
        idCount = idPropNotesCount;
        break;

    case propFamily:
        lpidProp = idPropFamily;
        idCount = idPropFamilyCount;
        {   // Gender Combo stuff
            TCHAR szBuf[MAX_PATH];
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_HOME_COMBO_GENDER);
            SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
            for(i=0;i<3;i++)
            {
                LoadString(hinstMapiX, idsGender+i, szBuf, CharSizeOf(szBuf));
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
            }
            SendMessage(hWndCombo, CB_SETCURSEL, 0, 0); //default is unspecified gender
        }
        //Need to create the month date controls for this dialog
        CreateDateTimeControl(hDlg, IDC_STATIC_BIRTHDAY, IDC_DETAILS_FAMILY_DATE_BIRTHDAY);
        CreateDateTimeControl(hDlg, IDC_STATIC_ANNIVERSARY, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY);
        //Setup the ListView for the children's names
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN), LVS_REPORT, LV_KIDS);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_FAMILY_BUTTON_EDITCHILD),FALSE);
        break;

    case propCert:
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST), LVS_REPORT, LV_CERT);
        lpidProp = NULL;
        idCount = 0;
        break;

    case propTrident:
        if (ulOperationType != SHOW_ONE_OFF)
        {
            HWND hwnd = GetDlgItem(hDlg, IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB);
            EnableWindow(hwnd, FALSE);
            ShowWindow(hwnd, SW_HIDE);
        }
        lpidProp = NULL;
        idCount = 0;
        break;

    case propConferencing:
        // If there is a Internet Call client installed, enable CallNow
        // else disable it
        {
            LONG cbSize = 0;
            if(RegQueryValue(HKEY_LOCAL_MACHINE, szInternetCallKey, NULL, &cbSize) == ERROR_SUCCESS && cbSize >= 1)
                EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CALL), TRUE);
            else
                EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CALL), FALSE);

            HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), LVS_REPORT, LV_SERVER);
            lpPai->hWndComboConf = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL);

            lpPai->nDefaultServerIndex = -1;
            lpPai->nBackupServerIndex = -1;
            lpPai->szDefaultServerName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_UI_STR);
            lpPai->szBackupServerName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_UI_STR);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_EDIT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETBACKUP), FALSE);
        }
        break;
    }

    if(lpidProp && idCount)
    {

        //Set max input limits on the edit fields
        for(i=0;i<idCount;i++)
        {
            ULONG ulLen = EDIT_LEN; //512
            HWND hWndC= GetDlgItem(hDlg,lpidProp[i].idCtl);
            if(!hWndC)
                continue;
            // Some fields need to be longer than others ...
            switch(lpidProp[i].idCtl)
            {
            case IDC_DETAILS_HOME_EDIT_URL:
            case IDC_DETAILS_BUSINESS_EDIT_URL:
            case IDC_DETAILS_NOTES_EDIT_NOTES:
                ulLen = MAX_EDIT_LEN-MAX_DISPLAY_NAME_LENGTH; // ~2K
                break;
            case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS: //make exceptions for non-string props
            case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            case IDC_DETAILS_HOME_COMBO_GENDER:
                continue;
                break;
            }
            SendMessage(hWndC,EM_SETLIMITTEXT,(WPARAM) ulLen,0);
            if (ulOperationType == SHOW_ONE_OFF) // Make all the controls readonly
                SendMessage(hWndC,EM_SETREADONLY,(WPARAM) TRUE,0);
        }

    }

    if(nPropSheet == propHome)
        SetHTTPPrefix(hDlg, IDC_DETAILS_HOME_EDIT_URL);
    else if(nPropSheet == propBusiness)
        SetHTTPPrefix(hDlg, IDC_DETAILS_BUSINESS_EDIT_URL);

    if (ulOperationType == SHOW_ONE_OFF)
    {
        // Make all the readonlyable controls readonly
        for(i=0;i<idSetReadOnlyCount;i++)
        {
            switch(idSetReadOnlyControls[i])
            {
            case IDC_DETAILS_HOME_BUTTON_URL:
            case IDC_DETAILS_BUSINESS_BUTTON_URL:
                break;
            default:
                {
                    HWND hWnd = GetDlgItem(hDlg,idSetReadOnlyControls[i]);
                    if(hWnd)
                        EnableWindow(hWnd,FALSE);
                }
                break;
            }
        }
    }

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);


    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//  RubySubClassedProc
//
//  Subclassed window proc for the Ruby static edit fields.  Used to provide
//  IME support.
///////////////////////////////////////////////////////////////////////////////
#define CCHMAX_RUBYSIZE 1024

LRESULT CALLBACK RubySubClassedProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WNDPROC OldWndProc = (WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    HIMC    hIMC;
    WCHAR   wszTemp[CCHMAX_RUBYSIZE];
    WCHAR   wszRuby[CCHMAX_RUBYSIZE];
    HWND    hWndParent;
    LONG    lId;
    HWND    hWndRuby = NULL;

    Assert(OldWndProc);

    switch (uMsg)
    {
    case WM_IME_COMPOSITION:
        if ( (hIMC = ImmGetContext(hWnd)) )
        {
            // IME does not include zero terminating character
            ZeroMemory(wszTemp, (CCHMAX_RUBYSIZE * sizeof(WCHAR)));
            ZeroMemory(wszRuby, (CCHMAX_RUBYSIZE * sizeof(WCHAR)));

            ImmGetCompositionStringW(hIMC, GCS_RESULTREADSTR, wszTemp, (sizeof(WCHAR) * (CCHMAX_RUBYSIZE-1)));
            // This subclassing only takes place for Japanese systems (lcid = 0x0411).
            LCMapString(0x0411, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, wszTemp, lstrlen(wszTemp), wszRuby, CCHMAX_RUBYSIZE-1);
            ImmReleaseContext(hWnd, hIMC);

            // Set either the first or last name ruby field, depending on which edit control
            // this is.
            hWndParent = GetParent(hWnd);
            Assert(hWndParent);
            lId = (LONG)GetWindowLongPtr(hWnd, GWL_ID);

            switch (lId)
            {
            case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
                hWndRuby = GetDlgItem(hWndParent, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST);
                break;

            case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
                hWndRuby = GetDlgItem(hWndParent, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST);
                break;

            default:
                Assert(0);  // What the heck did we subclass if not the two Ruby fields above?
                break;
            }

            if (hWndRuby)
            {
                BOOL    bDoConcat = TRUE;
                DWORD   dwStartSel = 0;
                DWORD   dwEndSel = 0;

                // If we have selected text in the edit field or it is empty then 
                // start over in Ruby field
                SendMessage(hWnd, EM_GETSEL, (WPARAM)&dwStartSel, (LPARAM)&dwEndSel);
                GetWindowText(hWnd, wszTemp, (CCHMAX_RUBYSIZE-1));
                if ( (dwEndSel > dwStartSel) || ((*wszTemp) == '\0') )
                    bDoConcat = FALSE;
                
                // Concatenate the text to what already exists in the Ruby field
                if (bDoConcat)
                {
                    GetWindowText(hWndRuby, wszTemp, (CCHMAX_RUBYSIZE-1));

                    if ( (lstrlen(wszTemp) + lstrlen(wszRuby) + 1) < CCHMAX_RUBYSIZE )
                    {
                        lstrcat(wszTemp, wszRuby);
                        SetWindowText(hWndRuby, wszTemp);
                        break;
                    }
                }

                // Default
                SetWindowText(hWndRuby, wszRuby);
            }
        }
        break;

    }   // end switch(uMsg)

    return CallWindowProc(OldWndProc, hWnd, uMsg, wParam, lParam);
}

/*//$$***************************************************************************
*    FUNCTION: FillCertComboWithEmailAddresses(hDlg, lpPai);
*
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
*   szEmail - if an email address is specified that exists in the
*       combo, that email address is selected
*
****************************************************************************/
void FillCertComboWithEmailAddresses(HWND hDlg, LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail)
{
    HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_CERT_COMBO);
    TCHAR sz[MAX_UI_STR];
    int nDefault = 0;

    FillComboWithEmailAddresses(lpPai, hWndCombo, &nDefault);

    if( lpPai->ulOperationType != SHOW_ONE_OFF &&
        SendMessage(hWndCombo, CB_GETCOUNT, 0, 0) > 0 &&
        SendMessage(hWndCombo, CB_GETCOUNT, 0, 0) != CB_ERR ) 
        EnableWindow(hWndCombo, TRUE);

    // Append the item [None - certificates without e-mail addresses]
    // to this list
    *sz = '\0';

    LoadString(hinstMapiX, idsCertsWithoutEmails, sz, CharSizeOf(sz));

    // *** NOTE ***
    // This item should always be the last item in the combo - several
    // places in this file work on that assumption
    //
    if(lstrlen(sz))
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) sz);

    if(szEmail)
    {
        // Set focus to a specific email address
        int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
        if(lstrlen(szEmail))
        {
            int i;
            for(i=0;i<nCount-1;i++)
            {
                *sz = '\0';
                SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) sz);
                if( lstrlen(sz) &&
                    !lstrcmpi(sz, szEmail))
                {
                    SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) i, 0);
                    break;
                }
            }
        }
        else
        {
            // passed in an empty email string which means we have just imported
            // a cert without an email address which means set the focus to the
            // last item in the combo
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nCount-1, 0);
        }
    }
    else
        SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nDefault, 0);
}



//$$//////////////////////////////////////////////////////////////////////////////
//
// bVerifyRequiredData
//
// Checks that all the required data for a given prop sheet is filled in,
// If not, returns FALSE and ID of control to set focus on
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bVerifyRequiredData(HWND hDlg,
                         LPPROP_ARRAY_INFO lpPai,
                         int nPropSheet,
                         int * lpCtlID)
{
    TCHAR szBuf[2 * MAX_UI_STR];
    ULONG ulSzBuf = CharSizeOf(szBuf);

    //
    // First check the required property (which is the GroupName)
    //
    *lpCtlID = 0;
    szBuf[0]='\0';

    switch (nPropSheet)
    {
    case propPersonal:
        // We need to check that all the required properties are filled in ...
        // For now all we really want a display Name

        szBuf[0] = '\0';
        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if (lstrlen(szBuf) == 0)
        {
            // Nothing in the display name field ..
            // Try to populate the field with the various info.
            // If we are successful in populating the field, we'll pick the first
            // entry as the default display name
            // If we are unsuccessful in picking something, we will stop and warn the
            // user
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
            int nItemCount = 0;
            SetComboDNText(hDlg, lpPai, TRUE, NULL);
            nItemCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
            if(nItemCount == 0)
            {
                //still nothing , warn and abort
                ShowMessageBox(GetParent(hDlg), IDS_DETAILS_MESSAGE_FIRST_LAST_REQUIRED, MB_ICONEXCLAMATION | MB_OK);
                *lpCtlID = IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME;
                return FALSE;
            }
            else
            {
                //Get the combo current selection which will be item 0
                SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) 0, (LPARAM) szBuf);
            }
        }

        break;
    }
    return TRUE;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// bUpdateOldPropTagArray
//
// For each prop sheet that is accessed, we will update the list of old prop tags
// for that sheet so that the old props can be knocked out of existing mailuser objects
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bUpdateOldPropTagArray(LPPROP_ARRAY_INFO lpPai, int nIndex)
{
    LPSPropTagArray lpta = NULL;

    SizedSPropTagArray(14, ptaUIDetlsPropsPersonal)=
    {
        14,
        {
            PR_DISPLAY_NAME,
            PR_EMAIL_ADDRESS,
            PR_ADDRTYPE,
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_ADDRTYPES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_GIVEN_NAME,
            PR_SURNAME,
            PR_MIDDLE_NAME,
            PR_NICKNAME,
            PR_SEND_INTERNET_ENCODING,
            PR_DISPLAY_NAME_PREFIX,
            PR_WAB_YOMI_FIRSTNAME,
            PR_WAB_YOMI_LASTNAME
        }
    };

    switch(nIndex)
    {
        case propPersonal:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsPersonal;
            break;
        case propHome:
            ptaUIDetlsPropsHome.aulPropTag[idPropHomePostalID]  = PR_WAB_POSTALID;
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsHome;
            break;
        case propBusiness:
            ptaUIDetlsPropsBusiness.aulPropTag[idPropBusIPPhone]   = PR_WAB_IPPHONE;
            ptaUIDetlsPropsBusiness.aulPropTag[idPropBusPostalID]  = PR_WAB_POSTALID;
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsBusiness;
            break;
        case propNotes:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsNotes;
            break;
        case propCert:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsCert;
            break;
        case propConferencing:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsConferencing;
            break;
        case propFamily:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsFamily;
            break;
    }

    if(!lpta)
        return TRUE;

    if(lpPai->lpPropObj && lpPai->bSomethingChanged)
    {
        // Knock out these old props from the PropObject
        if( (lpPai->lpPropObj)->lpVtbl->DeleteProps( (lpPai->lpPropObj),lpta,NULL))
            return FALSE;
    }

    return TRUE;
}


/*
-
-   bGetHomeBusNotesInfo - Gets data from the Home/Business/Notes fields
-
*/
BOOL bGetHomeBusNotesInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai,
                          int nPropSheet, ID_PROP * lpidProp, ULONG idPropCount,
                          LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    // The idea is to first count all the properties that have non-zero values
    // Then create a lpPropArray of that size and fill in the text from the props ..
    //
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
            if(lpPai->ulFlags & DETAILS_DefHomeChanged)
                ulNotEmptyCount++;
            continue;
            break;
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            if(lpPai->ulFlags & DETAILS_DefBusChanged)
                ulNotEmptyCount++;
            continue;
            break;
        }
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
        // if its just the default prefix, ignore
        if( ((lpidProp[i].idCtl == IDC_DETAILS_HOME_EDIT_URL) ||
             (lpidProp[i].idCtl == IDC_DETAILS_BUSINESS_EDIT_URL)) &&
             (lstrcmpi(szHTTP, szBuf)==0))
             ulNotEmptyCount--;

    }

    if (ulNotEmptyCount == 0)
    {
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugTrace(( TEXT("Error allocating memory\n")));
        goto out;
    }

   ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            continue;
            break;
        }

        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);

        if( ((lpidProp[i].idCtl == IDC_DETAILS_HOME_EDIT_URL) ||
             (lpidProp[i].idCtl == IDC_DETAILS_BUSINESS_EDIT_URL)) &&
             (lstrcmpi(szHTTP, szBuf)==0))
             continue;

        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));

            if (sc!=S_OK)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                goto out;
            }
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szBuf);
            ulIndex++;
        }
    }
    if(nPropSheet == propHome)
    {
        if(lpPai->ulFlags & DETAILS_DefHomeChanged)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_POSTALID;
            lpPropArray[ulIndex].Value.l = (IsDlgButtonChecked(hDlg, IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS)) ?
                                            ADDRESS_HOME : ADDRESS_NONE;
            ulIndex++;
        }
    }
    else if(nPropSheet == propBusiness)
    {
        if(lpPai->ulFlags & DETAILS_DefBusChanged)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_POSTALID;
            lpPropArray[ulIndex].Value.l = (IsDlgButtonChecked(hDlg, IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS)) ?
                                            ADDRESS_WORK : ADDRESS_NONE;
            ulIndex++;
        }
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    return bRet;
}


/*
-   bGetPersonalInfo
-   Get Data from Personal Prop sheet
*
*/
BOOL bGetPersonalInfo(  HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                        ID_PROP * lpidProp, ULONG idPropCount,
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    ULONG ulcProps = 0;
    LPSPropValue rgProps = NULL;

    HWND hWndLV = NULL;
    TCHAR szConf[MAX_UI_STR];

    SizedSPropTagArray(1, ptaIC) = {1, PR_SEND_INTERNET_ENCODING};

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, (LPSPropTagArray)&ptaIC, 
                                                    MAPI_UNICODE, &ulcProps, &rgProps)))
        goto out;

    szBuf[0] = '\0';
    hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
    
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, (LPTSTR)szBuf, ulSzBuf);
    TrimSpaces(szBuf);
    if (lstrlen(szBuf) == 0)
    {
        // Nothing in the display name field ..
        // Try to populate the field with the various info.
        // If we are successful in populating the field, we'll pick the first
        // entry as the default display name
        // If we are unsuccessful in picking something, we will stop and warn the
        // user
        HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
        int nItemCount = 0;

        SetComboDNText(hDlg, lpPai, TRUE, NULL);
        nItemCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
        if(nItemCount && nItemCount != CB_ERR)
        {
            //Get the combo current selection which will be item 0
            SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) 0, (LPARAM) szBuf);
        }
    }

    ulNotEmptyCount = 0;
    for(i=0;i<idPropCount;i++)
    {
        HWND hWndC = GetDlgItem(hDlg, lpidProp[i].idCtl);
        if(!hWndC)
            continue;
        szBuf[0]='\0'; //reset
        if(GetWindowText(hWndC, szBuf, ulSzBuf))
		{
			TrimSpaces(szBuf);
			if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
				ulNotEmptyCount++;
		}
    }


    if ((ulNotEmptyCount == 0) &&
        (ListView_GetItemCount(hWndLV) <= 0)) // Bug 14274 - werent looking for an email address before bailing out ..
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    ulcPropCount++;      //  We create an entryid

    if(ListView_GetItemCount(hWndLV) > 0)
        ulcPropCount += 5;  // +1 for email1_address,
                            // +1 for addrtype,
                            // +1 for contact_email_addresses,
                            // +1 for contact_addrtypes
                            // +1 for contact_default_index,

    ulcPropCount++; //Add one for the PR_SEND_INTERNET_ENCODING property

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugPrintError(( TEXT("Error allocating memory\n")));
        goto out;
    }

    ulIndex = 0;

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        HWND hWndC = GetDlgItem(hDlg, lpidProp[i].idCtl);
        if(!hWndC)
            continue;
        szBuf[0]='\0'; //reset
        GetWindowText(hWndC, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf))
        {
            if(lpidProp[i].idCtl == IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST)
                lpidProp[i].ulPropTag = PR_WAB_YOMI_FIRSTNAME;
            else if(lpidProp[i].idCtl == IDC_DETAILS_PERSONAL_STATIC_RUBYLAST)
                lpidProp[i].ulPropTag = PR_WAB_YOMI_LASTNAME;

            if(lpidProp[i].ulPropTag) //some text
            {
                ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
                lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;

                sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));
                if (sc!=S_OK)
                {
                    DebugPrintError(( TEXT("Error allocating memory\n")));
                    goto out;
                }
                lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szBuf);
                ulIndex++;
            }
        }
    }

    // TBD - write code for getting all the other props

    // if this is a new entry, we want to give it a blank PR_ENTRYID property
    // else we want to set its PR_ENTRYID property
    lpPropArray[ulIndex].ulPropTag = PR_ENTRYID;

    if (lpPai->cbEntryID == 0)
    {
        lpPropArray[ulIndex].Value.bin.cb = 0;
        lpPropArray[ulIndex].Value.bin.lpb = NULL;
    }
    else
    {
        lpPropArray[ulIndex].Value.bin.cb = lpPai->cbEntryID;
        sc = MAPIAllocateMore(lpPai->cbEntryID, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.bin.lpb)));
        if (sc!=S_OK)
        {
            DebugPrintError(( TEXT("Error allocating memory\n")));
            goto out;
       }

        CopyMemory(lpPropArray[ulIndex].Value.bin.lpb,lpPai->lpEntryID,lpPai->cbEntryID);
    }

    ulIndex++;

    lstrcpy(szConf, szEmpty);

    // Check if we need to change the COnf_server_email_index prop
    if(lpPai->hWndComboConf)
    {
        GetWindowText(lpPai->hWndComboConf, szConf, CharSizeOf(szConf));
        TrimSpaces(szConf);
    }

    if(ListView_GetItemCount(hWndLV) > 0)
    {
        // Find out how many elements we need to add
        ULONG nEmailCount = ListView_GetItemCount(hWndLV);

        // we'll use the following as indexes for lpPropArray
        ULONG nMVEmailAddress = ulIndex++;//ulIndex+0;
        ULONG nMVAddrTypes =    ulIndex++;//ulIndex+1;
        ULONG nEmailAddress =   ulIndex++;//ulIndex+2;
        ULONG nAddrType =       ulIndex++;//ulIndex+3;
        ULONG nDefaultIndex =   ulIndex++;//ulIndex+4;

        lpPropArray[nEmailAddress].ulPropTag = PR_EMAIL_ADDRESS;
        lpPropArray[nAddrType].ulPropTag = PR_ADDRTYPE;
        lpPropArray[nDefaultIndex].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        lpPropArray[nMVEmailAddress].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        lpPropArray[nMVAddrTypes].ulPropTag = PR_CONTACT_ADDRTYPES;

        // initialize before using ...
        lpPropArray[nMVEmailAddress].Value.MVSZ.cValues = 0;
        lpPropArray[nMVEmailAddress].Value.MVSZ.LPPSZ = NULL;
        lpPropArray[nMVAddrTypes].Value.MVSZ.cValues = 0;
        lpPropArray[nMVAddrTypes].Value.MVSZ.LPPSZ = NULL;

        // For thetime being just null them all
        for(i=0;i<nEmailCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPEMAIL_ITEM lpEItem = (LPEMAIL_ITEM) lvi.lParam;

                if(HR_FAILED(hr = AddPropToMVPString(
                                            lpPropArray,
                                            ulcPropCount,
                                            nMVEmailAddress,
                                            lpEItem->szEmailAddress)))
                {
                    DebugPrintError(( TEXT("AddPropToMVString Email failed: %x"),hr));
                    goto out;
                }

                if(HR_FAILED(hr = AddPropToMVPString(
                                            lpPropArray,
                                            ulcPropCount,
                                            nMVAddrTypes,
                                            lpEItem->szAddrType)))
                {
                    DebugPrintError(( TEXT("AddPropToMVString AddrType failed: %x"),hr));
                    goto out;
                }

                if(lpEItem->bIsDefault)
                {
                    // For the default e-mail ... set all the other props
                    lpPropArray[nDefaultIndex].Value.l = i;

                    sc = MAPIAllocateMore(  sizeof(TCHAR)*(lstrlen(lpEItem->szEmailAddress)+1),
                                            lpPropArray,
                                            (LPVOID *) (&(lpPropArray[nEmailAddress].Value.LPSZ)));
                    if(FAILED(sc))
                    {
                        DebugPrintError(( TEXT("MApiAllocateMore failed\n")));
                        hr = ResultFromScode(sc);
                        goto out;
                    }
                    lstrcpy(lpPropArray[nEmailAddress].Value.LPSZ,lpEItem->szEmailAddress);

                    sc = MAPIAllocateMore(  sizeof(TCHAR)*(lstrlen(lpEItem->szAddrType)+1),
                                            lpPropArray,
                                            (LPVOID *) (&(lpPropArray[nAddrType].Value.LPSZ)));
                    if(FAILED(sc))
                    {
                        DebugPrintError(( TEXT("MApiAllocateMore failed\n")));
                        hr = ResultFromScode(sc);
                        goto out;
                    }
                    lstrcpy(lpPropArray[nAddrType].Value.LPSZ,lpEItem->szAddrType);

                } // if bIsDefault...
            } // if LV_GetItem ...
        } // for i = ...

    } // if LV_GetItemCount ...

    // Add the PR_SEND_INTERNET_ENCODING property
    lpPropArray[ulIndex].ulPropTag = PR_SEND_INTERNET_ENCODING;
    lpPropArray[ulIndex].Value.l = 0;

    // The PR_SEND_INTERNET_ECODING is a bit mask of several flags and we dont want
    // to loose any information that was in the original set of bits so we get it again
    if(rgProps[0].ulPropTag == PR_SEND_INTERNET_ENCODING)
    {
        //Check the check box on the UI
        lpPropArray[ulIndex].Value.l = rgProps[0].Value.l;
    }

    lpPropArray[ulIndex].Value.l &= ~BODY_ENCODING_MASK; //BODY_ENCODING_HTML;
    if(IsDlgButtonChecked(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO) != BST_CHECKED)
        lpPropArray[ulIndex].Value.l |= BODY_ENCODING_TEXT_AND_HTML; //BODY_ENCODING_HTML;

    ulIndex++;

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    FreeBufferAndNull(&rgProps);
    return bRet;
}


/*
-   bGetConferencingInfo
-   Get Data from Conferencing Prop sheet
*
*/
BOOL bGetConferencingInfo(  HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nItemCount = ListView_GetItemCount(hWndLV);
    TCHAR szEmail[MAX_UI_STR];
    ULONG ulcProps = 0;
    LPSPropValue rgProps = NULL;

    SizedSPropTagArray(1, ptaCf) = {1, PR_WAB_CONF_SERVERS};

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, (LPSPropTagArray)&ptaCf, 
                                                    MAPI_UNICODE, &ulcProps, &rgProps)))
        goto out;

    // For the conferencing tab, we need to save 4 properties
    //  Conferencing Server Names
    //  Default Index
    //  Backup Index
    //  Email Address Index
    //
    ulNotEmptyCount = 0;

    if(nItemCount > 0)
    {
        ulNotEmptyCount += 2; // CONF_SERVERS and DEFAULT_INDEX

       if(lpPai->nBackupServerIndex != -1)
            ulNotEmptyCount++;
    }

    if (ulNotEmptyCount == 0)
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
        goto out;

    ulIndex = 0; //now we reuse this variable as an index

    if(nItemCount > 0)
    {
        TCHAR * szCalltoStr = NULL; //szCalltoStr[MAX_UI_STR * 3];
        ULONG i,j;

        if(szCalltoStr = LocalAlloc(LMEM_ZEROINIT, MAX_UI_STR*3*sizeof(TCHAR)))
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_SERVERS;
            lpPropArray[ulIndex].Value.MVSZ.cValues = 0;
            lpPropArray[ulIndex].Value.MVSZ.LPPSZ = NULL;

            // first scan the original prop array for any PR_SERVERS props that
            // we didnt touch - retain those props witout losing them

            {
                j = 0; //index of PR_WAB_CONF_SERVERS prop
                if(rgProps[j].ulPropTag == PR_WAB_CONF_SERVERS)
                {
                    LPSPropValue lpProp = &(rgProps[j]);
                    for(i=0;i<lpProp->Value.MVSZ.cValues; i++)
                    {
                        LPTSTR lp = lpProp->Value.MVSZ.LPPSZ[i];
                        TCHAR sz[32];
                        int iLenCallto = lstrlen(szCallto);
                        if(!SubstringSearch(lp, TEXT("://")))
                            continue;
                        if(lstrlen(lp) < iLenCallto)
                            continue;

                        CopyMemory(sz, lp, sizeof(TCHAR)*iLenCallto);
                        sz[iLenCallto] = '\0';
                        if(lstrcmpi(sz, szCallto))
                        {
                            // Not a callto string .. retain it
                            if(HR_FAILED(hr = AddPropToMVPString( lpPropArray, ulcPropCount, ulIndex, lp)))
                            {
                                DebugPrintError(( TEXT("AddPropToMVString Conf server %s failed: %x"),lp, hr));
                                goto out;
                            }
                        }
                    }
                }
            }
            for(i=0;i< (ULONG) nItemCount; i++)
            {
                szBuf[0]='\0';
                szEmail[0] = '\0';
                {
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = i; lvi.iSubItem = 0;
                    ListView_GetItem(hWndLV, &lvi);
                    if(lvi.lParam)
                    {
                        LPSERVER_ITEM lpSI = (LPSERVER_ITEM) lvi.lParam;

                        if(lpSI->lpServer)
                            lstrcpy(szBuf, lpSI->lpServer);
                        if(lpSI->lpEmail)
                            lstrcpy(szEmail, lpSI->lpEmail);
                    }
                }

                if(lstrlen(szBuf) && lstrlen(szEmail))
                {
                    lstrcpy(szCalltoStr, szCallto);
                    lstrcat(szCalltoStr, szBuf);
                    lstrcat(szCalltoStr, TEXT("/"));
                    lstrcat(szCalltoStr, szEmail);
                    if(HR_FAILED(hr = AddPropToMVPString( lpPropArray, ulcPropCount, ulIndex, szCalltoStr)))
                    {
                        DebugPrintError(( TEXT("AddPropToMVString Conf server %s failed: %x"),szCalltoStr, hr));
                        goto out;
                    }
                }
            }
            LocalFreeAndNull(&szCalltoStr);
        }

        ulIndex++;
        lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_DEFAULT_INDEX;
        lpPropArray[ulIndex].Value.l = (ULONG) lpPai->nDefaultServerIndex;

        ulIndex++;

        if(lpPai->nBackupServerIndex != -1)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_BACKUP_INDEX;
            lpPropArray[ulIndex].Value.l = (ULONG) lpPai->nBackupServerIndex;
            ulIndex++;
        }
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    FreeBufferAndNull(&rgProps);
    return bRet;
}

/*
- bGetFamilyInfo - get's info back from the Family Prop
-
*/
BOOL bGetFamilyInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                    ID_PROP * lpidProp, ULONG idPropCount,
                    LPSPropValue * lppPropArray, ULONG * lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
    SYSTEMTIME st = {0};
    short int nSel = 0;
	int nCount = 0;

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_FAMILY_LIST_CHILDREN:
            if( lpPai->ulFlags & DETAILS_ChildrenChanged ||
                ListView_GetItemCount(hWndLV) > 0)
                ulNotEmptyCount++;
            continue;
            break;
        case IDC_DETAILS_FAMILY_DATE_BIRTHDAY:
        case IDC_DETAILS_FAMILY_DATE_ANNIVERSARY:
            {
                SYSTEMTIME st = {0};
                if( lpPai->ulFlags & DETAILS_DateChanged ||
                    GDT_VALID == SendDlgItemMessage(hDlg, lpidProp[i].idCtl, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
                    ulNotEmptyCount++;
            }
            continue;
        case IDC_DETAILS_HOME_COMBO_GENDER:
            if( lpPai->ulFlags & DETAILS_GenderChanged ||
                SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_GETCURSEL, 0, 0)>0 )
                ulNotEmptyCount++;
            continue;
            break;
        }
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
    }

    if (ulNotEmptyCount == 0)
    {
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugTrace(( TEXT("Error allocating memory\n")));
        goto out;
    }

   ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_FAMILY_DATE_BIRTHDAY:
        case IDC_DETAILS_FAMILY_DATE_ANNIVERSARY:
        case IDC_DETAILS_HOME_COMBO_GENDER:
        case IDC_DETAILS_FAMILY_LIST_CHILDREN:
            continue;
            break;
        }

        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);

        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));
            if (sc!=S_OK)
            {
                DebugTrace( TEXT("Error allocating memory\n"));
                goto out;
            }
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szBuf);
            ulIndex++;
        }
    }

    // Get the Gender data
    //
    nCount = ListView_GetItemCount(hWndLV);
    if(lpPai->ulFlags & DETAILS_ChildrenChanged || nCount>0)
    {
        ULONG ulCount = 0;
        if(nCount > 0)
        {
            lpPropArray[ulIndex].ulPropTag = PR_CHILDRENS_NAMES;
            sc = MAPIAllocateMore(nCount * sizeof(LPTSTR), lpPropArray, (LPVOID *)&(lpPropArray[ulIndex].Value.MVSZ.LPPSZ));
            if (sc!=S_OK)
            {
                DebugTrace( TEXT("Error allocating memory\n"));
                goto out;
            }
            for(i=0;i<(ULONG)nCount;i++)
            {
                *szBuf = '\0';
                ListView_GetItemText(hWndLV, i, 0, szBuf, ulSzBuf);
                if(szBuf && lstrlen(szBuf))
                {
                    sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(szBuf)+1), lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.MVSZ.LPPSZ[ulCount])));
                    if (sc!=S_OK)
                    {
                        DebugTrace( TEXT("Error allocating memory\n"));
                        goto out;
                    }
                    lstrcpy(lpPropArray[ulIndex].Value.MVSZ.LPPSZ[ulCount], szBuf);
                    ulCount++;
                }
            }
            lpPropArray[ulIndex].Value.MVSZ.cValues = ulCount;
            ulIndex++;
        }

    }
    nSel = (short int) SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_GETCURSEL, 0, 0);
    if(nSel == CB_ERR)
        nSel = 0;
    if(lpPai->ulFlags & DETAILS_GenderChanged || nSel>0)
    {
        lpPropArray[ulIndex].ulPropTag = PR_GENDER;
        lpPropArray[ulIndex].Value.i = nSel;
        ulIndex++;
    }

    if(GDT_VALID == SendDlgItemMessage(hDlg, IDC_DETAILS_FAMILY_DATE_BIRTHDAY, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
    {
        lpPropArray[ulIndex].ulPropTag = PR_BIRTHDAY;
        SystemTimeToFileTime(&st, (FILETIME *) (&lpPropArray[ulIndex].Value.ft));
        ulIndex++;
    }

    if(GDT_VALID == SendDlgItemMessage(hDlg, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
    {
        lpPropArray[ulIndex].ulPropTag = PR_WEDDING_ANNIVERSARY;
        SystemTimeToFileTime(&st, (FILETIME *) (&lpPropArray[ulIndex].Value.ft));
        ulIndex++;
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    return bRet;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  GetDetails from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
//////////////////////////////////////////////////////////////////////////////////
BOOL GetDetailsFromUI(  HWND hDlg, LPPROP_ARRAY_INFO lpPai ,
                        BOOL bSomethingChanged, int nPropSheet,
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    BOOL bRet = TRUE;
    ULONG i = 0;

    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;

    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = hrSuccess;

    if (!bSomethingChanged)
    {
        bRet = TRUE;
        goto out;
    }

    *lppPropArray = NULL;
    *lpulcPropCount = 0;

    DebugTrace( TEXT("GetDetailsFromUI: %d\n"),nPropSheet);

    switch(nPropSheet)
    {
    case propHome:
        idPropCount = idPropHomeCount;
        lpidProp = idPropHome;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        goto GetProp;
    case propBusiness:
        idPropCount = idPropBusinessCount;
        lpidProp = idPropBusiness;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;
        goto GetProp;
    case propNotes:
        idPropCount = idPropNotesCount;
        lpidProp = idPropNotes;
GetProp:
        bRet = bGetHomeBusNotesInfo(hDlg, lpPai, nPropSheet, 
                        lpidProp, idPropCount,lppPropArray, lpulcPropCount);
        break;
/***********/
    case propPersonal:
        bRet = bGetPersonalInfo(hDlg, lpPai, idPropPersonal, idPropPersonalCount, lppPropArray, lpulcPropCount);
        break; // case propPersonal
/***********/
    case propCert:
        // There is only 1 property, PR_USER_X509_CERTIFICATE
        if(lpPai->lpCItem)
        {
            if(HR_FAILED(HrSetCertsFromDisplayInfo( lpPai->lpCItem, lpulcPropCount, lppPropArray)))
                bRet = FALSE;
        }
        break;
/***********/
    case propConferencing:
        bRet = bGetConferencingInfo(hDlg, lpPai,lppPropArray, lpulcPropCount);
        break;
/***********/
    case propFamily:
        bRet = bGetFamilyInfo(hDlg, lpPai, idPropFamily, idPropFamilyCount, lppPropArray, lpulcPropCount);
        break;
    }

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }

    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////////
//
// bUpdatePropArray
//
// Updates the prop array info for each sheet that is stored in the globaly accessible
// pointer
//
//////////////////////////////////////////////////////////////////////////////
BOOL bUpdatePropArray(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet)
{
    BOOL bRet = TRUE;
    ULONG cValues = 0;
    LPSPropValue rgPropVals = NULL;
    if (lpPai->ulOperationType != SHOW_ONE_OFF)
    {
        bUpdateOldPropTagArray(lpPai, nPropSheet);

        lpPai->bSomethingChanged = ChangedExtDisplayInfo(lpPai, lpPai->bSomethingChanged);

        if(lpPai->bSomethingChanged)
        {
            bRet = GetDetailsFromUI(   hDlg, lpPai, lpPai->bSomethingChanged, nPropSheet, &rgPropVals, &cValues);
            if(cValues && rgPropVals)
            {
#ifdef DEBUG
                _DebugProperties(rgPropVals, cValues, TEXT("GetDetails from UI\n"));
#endif
                lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, cValues, rgPropVals, NULL);
            }
        }
    }
    FreeBufferAndNull(&rgPropVals);
    return bRet;
}




#define lpPAI ((LPPROP_ARRAY_INFO) pps->lParam)
#define lpbSomethingChanged (&(lpPAI->bSomethingChanged))

/*//$$***********************************************************************
*    FUNCTION: fnPersonalProc
*
*    PURPOSE:  Callback function for handling the PERSONAL property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnPersonalProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        ChangeLocaleBasedTabOrder(hDlg, contactPersonal);
        SetDetailsUI(hDlg,lpPAI, lpPAI->ulOperationType,propPersonal);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), message, wParam, lParam);
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
               g_szWABHelpFileName,
               HELP_WM_HELP,
               (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
               g_szWABHelpFileName,
               HELP_CONTEXTMENU,
               (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_DROPDOWN:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                SetComboDNText(hDlg, lpPAI, TRUE, NULL);
                break;
            }
            break;

        case CBN_SELCHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                {
                    int nSel = (int) SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETCURSEL, 0, 0);
                    if(nSel != CB_ERR)
                    {
                        int nLen = (int) SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETLBTEXTLEN, (WPARAM)nSel, 0);
                        if(nLen != CB_ERR)
                        {
                            LPTSTR lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen + 1));
                            if(lpsz)
                            {   
                                SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETLBTEXT, (WPARAM)nSel, (LPARAM)lpsz);
                                SetWindowPropertiesTitle(GetParent(hDlg), lpsz);
                                if (lpbSomethingChanged) //some edit box changed - dont care which
                                   (*lpbSomethingChanged) = TRUE;
                                LocalFreeAndNull(&lpsz);
                            }
                        }
                    }
                }
                break;
            }
            break;

        case CBN_EDITCHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                if(!(lpPAI->ulFlags & DETAILS_ProgChange) )
                {
                    lpPAI->ulFlags &= ~DETAILS_DNisFMLName;
                    lpPAI->ulFlags &= ~DETAILS_DNisNickName;
                    lpPAI->ulFlags &= ~DETAILS_DNisCompanyName;
                }
                {
                    TCHAR szBuf[MAX_UI_STR];
                    szBuf[0]='\0';
                    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf, CharSizeOf(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                    if (lpbSomethingChanged) //some edit box changed - dont care which
                        (*lpbSomethingChanged) = TRUE;
                }
                break;
            }
            break;

        case EN_CHANGE:
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged) //some edit box changed - dont care which
                (*lpbSomethingChanged) = TRUE;
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL:
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),TRUE);
                SendMessage(hDlg, DM_SETDEFID, IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL, 0);
                return 0;
                break;

            case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
            case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
            case IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME:
                // if there is nothing in the display name field (new contact)
                // and we are typing here, update the display name
                //TCHAR szBuf[2];
                //int nText = GetWindowText(lpPAI->hWndDisplayNameField, szBuf, CharSizeOf(szBuf));
                if(lpPAI->ulFlags & DETAILS_DNisFMLName)// || !nText)
                {
                    lpPAI->ulFlags |= DETAILS_ProgChange;
                    SetDetailsWindowTitle(hDlg, TRUE);
                    lpPAI->ulFlags &= ~DETAILS_ProgChange;
                }

                // [PaulHi] 4/8/99
                // If the text in the edit box was deleted then also delete the corresponding
                // Ruby field text
                if(lpPAI->ulFlags & DETAILS_UseRubyPersonal)
                {
                    HWND    hWndEdit = GetDlgItem(hDlg, LOWORD(wParam));
                    HWND    hWndRuby = NULL;
                    WCHAR   wszTemp[EDIT_LEN];

                    Assert(hWndEdit);

                    GetWindowText(hWndEdit, wszTemp, EDIT_LEN);
                    if (*wszTemp == '\0')
                    {
                        // Clear either the first or last name ruby field, depending on which 
                        // edit control this is.
                        switch (LOWORD(wParam))
                        {
                        case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
                            hWndRuby = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST);
                            break;

                        case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
                            hWndRuby = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST);
                            break;

                        default:
                            break;
                        }

                        if (hWndRuby)
                            SetWindowText(hWndRuby, szEmpty);
                    }
                }

                break;

            case IDC_DETAILS_PERSONAL_EDIT_NICKNAME:
                {
                    if(lpPAI->ulFlags & DETAILS_DNisNickName)
                    {
                        TCHAR szBuf[MAX_UI_STR];
                        szBuf[0]='\0';
                        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_NICKNAME, szBuf, CharSizeOf(szBuf));
                        lpPAI->ulFlags |= DETAILS_ProgChange;
                        SetComboDNText(hDlg, lpPAI, FALSE, szBuf);
                        lpPAI->ulFlags &= ~DETAILS_ProgChange;
                    }
                    else
                        SetComboDNText(hDlg, lpPAI, TRUE, NULL);

                }
                break;


            default:
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_PERSONAL_BUTTON_RUBY:
            ShowRubyNameEntryDlg(hDlg, lpPAI);
            break;

        case IDC_DETAILS_PERSONAL_CHECK_RICHINFO:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    SetLVDefaultEmail( hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_EDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    HWND hWndEditLabel;
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    SetFocus(hWndLV);
                    hWndEditLabel = ListView_EditLabel(hWndLV, index);
                    // Set Text Limit on this Edit Box
                    SendMessage(hWndEditLabel, EM_LIMITTEXT, EDIT_LEN, 0);
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)>=1)
                {
                    BOOL bSetNewDefault = FALSE;
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    while(iItemIndex != -1)
                    {
                        BOOL bRet = FALSE;
                        bRet = DeleteLVEmailItem(hWndLV,iItemIndex);
                        if (!bSetNewDefault)
                            bSetNewDefault = bRet;
                        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    }

                    if (bSetNewDefault && (ListView_GetItemCount(hWndLV) > 0))
                        SetLVDefaultEmail(hWndLV, 0);

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if (ListView_GetItemCount(hWndLV) <= 0)
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),FALSE);
                        SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                        return FALSE;
                    }
                    else
                    {
                        //make sure something is selected
                        if(ListView_GetSelectedCount(hWndLV) <= 0)
                            LVSelectItem(hWndLV,0);
                    }
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL:
            AddNewEmailEntry(hDlg,FALSE);
            return FALSE;
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillPersonalDetails(hDlg, lpPAI, propPersonal, lpbSomethingChanged);
            if(lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                // Since items to this list view can be added from certs and conf panes,
                // update this everytime the focus somes back to us
                if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST)) > 0)
                {
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
                }
            }
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                // check if there is some pending email entry
                if(IDCANCEL == AddNewEmailEntry(hDlg,TRUE))
                {
                    //abort this ok
                    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            bUpdatePropArray(hDlg, lpPAI, propPersonal);
            FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                int CtlID = 0; //used to determine which required field in the UI has not been set
                ULONG ulcPropCount = 0;
                if(!bVerifyRequiredData(hDlg, lpPAI, propPersonal, &CtlID))
                {
                    SetFocus(GetDlgItem(hDlg,CtlID));
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            //bUpdatePropArray(hDlg, lpPAI, propPersonal);
            //FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingEmail) //cancel any email editing else it faults #30235
            {
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), -1);
                lpPAI->ulFlags &= ~DETAILS_EditingEmail;
            }
            FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;

        case LVN_BEGINLABELEDITA:
        case LVN_BEGINLABELEDITW:
            {
                // We are editing a email address in teh list box
                // We need to get:
                //      item index number
                //      item lParam
                //      edit box hWnd
                // and replace the text with the actual email address
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                if (lvi.iItem >= 0)
                {
                    HWND hWndLVEdit = NULL;
                    LPEMAIL_ITEM lpEItem = NULL;
                    if (lvi.mask & LVIF_PARAM)
                    {
                        lpEItem = (LPEMAIL_ITEM) lvi.lParam;
                    }
                    else
                    {
                        lvi.mask |= LVIF_PARAM;
                        if (ListView_GetItem(hWndLV, &lvi))
                            lpEItem = (LPEMAIL_ITEM) lvi.lParam;
                    }
                    if (!lpEItem)
                        return TRUE; //prevents editing

                    hWndLVEdit = ListView_GetEditControl(hWndLV);

                    if (!hWndLVEdit)
                        return TRUE;

                    lpPAI->ulFlags |= DETAILS_EditingEmail;

                    SendMessage(hWndLVEdit, WM_SETTEXT, 0, (LPARAM) lpEItem->szEmailAddress);//lpText);

                    return FALSE;
                }

            }
            return TRUE;
            break;

        case LVN_ENDLABELEDITA:
        case LVN_ENDLABELEDITW:
            {
                // We get the text from the edit box and put it in the item data
                BOOL bRet = FALSE;
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                LPWSTR lpW = NULL;
                LPSTR lpA = NULL;
                if(!g_bRunningOnNT) //on Win9x we will get an LV_ITEMA, not a LV_ITEMW
                {
                    lpA = (LPSTR)lvi.pszText;
                    lpW = ConvertAtoW(lpA);
                    lvi.pszText = lpW;
                }
                if ((lvi.iItem >= 0) && lvi.pszText && (lstrlen(lvi.pszText)))
                {
                    LV_ITEM lviActual = {0};
                    LPEMAIL_ITEM lpEItem = NULL;
                    BOOL bSetDefault = FALSE;
                    LPTSTR lpText = lvi.pszText;
                    LPTSTR lpszEmailAddress = NULL; 
                    if(!IsInternetAddress(lpText, &lpszEmailAddress))
                    {
                        if(IDNO == ShowMessageBox(GetParent(hDlg), idsInvalidInternetAddress, MB_ICONEXCLAMATION | MB_YESNO))
                        {
                            bRet = TRUE;
                            goto endN;
                        }
                    }

                    // bobn, Raid 87496, IsInternetAddress can correctly leave lpszEmailAddress NULL
                    // if it returns false.  If the user said to use it, we need to set it accordingly.
                    if(!lpszEmailAddress)
                        lpszEmailAddress = lpText;

                    lviActual.mask = LVIF_PARAM | LVIF_TEXT;
                    lviActual.iItem = lvi.iItem;

                    if (ListView_GetItem(hWndLV, &lviActual))
                        lpEItem = (LPEMAIL_ITEM) lviActual.lParam;

                    if (!lpEItem)
                    {
                        bRet = TRUE;
                        goto endN;
                    }

                    lstrcpy(lpEItem->szEmailAddress, lpszEmailAddress);
                    lstrcpy(lpEItem->szDisplayText, lpszEmailAddress);
                    lviActual.pszText = lpszEmailAddress;

                    // Throw away any display name that may have been entered here.

                    bSetDefault = lpEItem->bIsDefault;
                    lpEItem->bIsDefault = FALSE; //this will be set again in SetLVDefaultEmail function

                    ListView_SetItem(hWndLV, &lviActual);
                    if (bSetDefault)
                        SetLVDefaultEmail(hWndLV, lvi.iItem);

                    lpPAI->ulFlags &= ~DETAILS_EditingEmail;

                    bRet = FALSE;
                }
endN:
                LocalFreeAndNull(&lpW);
                if(!g_bRunningOnNT)
                    ((LV_DISPINFO FAR *) lParam)->item.pszText = (LPWSTR)lpA; // reset it as we found it
                return bRet;
            }
            return TRUE;
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_PERSONAL_LIST:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        SetLVDefaultEmail(pNm->hdr.hwndFrom, iItemIndex);
                        if (lpbSomethingChanged)
                            (*lpbSomethingChanged) = TRUE;
                    }
                }
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_PERSONAL_LIST:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        LPEMAIL_ITEM lpEItem = (LPEMAIL_ITEM) pnmcd->lItemlParam;

                        if (lpEItem)
                        {
			                if(lpEItem->bIsDefault)
			                {
				                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				                return TRUE;
			                }
#ifdef WIN16 // Set font
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIcon));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                return TRUE;
                            }
#endif
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        }
        break; //WM_NOTIFY

    default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), message, wParam, lParam);
        }
#endif
        break;

    } //switch


    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnHomeProc
*
*    PURPOSE:  Callback function for handling the HOME property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnHomeProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propHome);
        ChangeLocaleBasedTabOrder(hDlg, contactHome);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
               g_szWABHelpFileName,
               HELP_WM_HELP,
               (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND)wParam,
               g_szWABHelpFileName,
               HELP_CONTEXTMENU,
               (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        {
            int nCmd = GET_WM_COMMAND_ID(wParam, lParam);
            switch(nCmd)
            {
            case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
                lpPAI->ulFlags |= DETAILS_DefHomeChanged;
                break;
            case IDCANCEL:
                // This is a windows bug that prevents ESC canceling prop sheets
                // which have MultiLine Edit boxes KB: Q130765
                SendMessage(GetParent(hDlg),message,wParam,lParam);
                break;
            case IDC_DETAILS_HOME_BUTTON_MAP:
                bUpdatePropArray(hDlg, lpPAI, propHome); // update the props from the fields onto the prop-object
                ShowExpediaMAP(hDlg, lpPAI->lpPropObj, TRUE);
                break;

            case IDC_DETAILS_HOME_BUTTON_URL:
                ShowURL(hDlg, IDC_DETAILS_HOME_EDIT_URL,NULL);
                break;
            }
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propHome, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propHome);
            lpPAI->ulFlags &= ~DETAILS_DefHomeChanged; //reset flag
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propHome);
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}




/*//$$***********************************************************************
*    FUNCTION: fnBusinessProc
*
*    PURPOSE:  Callback function for handling the BUSINESS property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnBusinessProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        ChangeLocaleBasedTabOrder(hDlg, contactBusiness);
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propBusiness);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
//        (*lpbSomethingChanged) = FALSE;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            lpPAI->ulFlags |= DETAILS_DefBusChanged;
            break;
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_BUSINESS_BUTTON_MAP:
            bUpdatePropArray(hDlg, lpPAI, propBusiness); // update the props from the fields onto the prop-object
            ShowExpediaMAP(hDlg, lpPAI->lpPropObj, FALSE);
            break;

        case IDC_DETAILS_BUSINESS_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_BUSINESS_EDIT_URL,NULL);
            break;
        
        case IDC_DETAILS_BUSINESS_EDIT_COMPANY:
            if(lpPAI->ulFlags & DETAILS_DNisCompanyName)
            {
                TCHAR szBuf[MAX_UI_STR];
                szBuf[0]='\0';
                GetDlgItemText(hDlg, IDC_DETAILS_BUSINESS_EDIT_COMPANY, szBuf, CharSizeOf(szBuf));
                SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                lpPAI->ulFlags |= DETAILS_ProgChange;
                SetWindowText(lpPAI->hWndDisplayNameField, szBuf);
                lpPAI->ulFlags &= ~DETAILS_ProgChange;
            }
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propBusiness, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propBusiness);
            lpPAI->ulFlags &= ~DETAILS_DefBusChanged;
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propBusiness);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnNotesProc
*
*    PURPOSE:  Callback function for handling the NOTES property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnNotesProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propNotes);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
//        (*lpbSomethingChanged) = FALSE;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propNotes, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propNotes);
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propNotes);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}

/*//$$***********************************************************************
*    FUNCTION: fnCertProc
*
*    PURPOSE:  Callback function for handling the Certificates property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnCertProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propCert);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam, lParam))
        {
        case CBN_SELCHANGE:
            UpdateCertListView(hDlg, lpPAI);
            break;

        }
        switch(LOWORD(wParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_CERT_BUTTON_PROPERTIES:
            {
            ShowCertProps(hDlg, GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST), NULL);
            }
            break;

        case IDC_DETAILS_CERT_BUTTON_SETDEFAULT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    SetLVDefaultCert( hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }
                else if(ListView_GetSelectedCount(hWndLV) <= 0)
                {
                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
                }

            }
            break;

        case IDC_DETAILS_CERT_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
                if(ListView_GetSelectedCount(hWndLV)>=1)
                {
                    BOOL bSetNewDefault = FALSE;
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    while(iItemIndex != -1)
                    {
                        BOOL bRet = FALSE;
//                        KillTrustInSleazyFashion(hWndLV, iItemIndex);
                        bRet = DeleteLVCertItem(hWndLV,iItemIndex, lpPAI);
                        if (!bSetNewDefault)
                            bSetNewDefault = bRet;

                        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    }

                    if (bSetNewDefault && (ListView_GetItemCount(hWndLV) > 0))
                        SetLVDefaultCert(hWndLV, 0);

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if (ListView_GetItemCount(hWndLV) <= 0)
                    {
                        SetFocus(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_IMPORT));
                        EnableWindow(hWndLV,FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),FALSE);
                        return FALSE;
                    }
                    else
                    {
                        //make sure something is selected
                        if(ListView_GetSelectedCount(hWndLV) <= 0)
                            LVSelectItem(hWndLV,0);
                    }
                }
                else
                {
                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
                }

            }
            break;

        case IDC_DETAILS_CERT_BUTTON_IMPORT:
            if(ImportCert(hDlg, lpPAI))
            {
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
            }
            break;

        case IDC_DETAILS_CERT_BUTTON_EXPORT:
            ExportCert(hDlg);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propCert, lpbSomethingChanged);
            //FillCertComboWithEmailAddresses(hDlg, lpPAI, NULL);
            //UpdateCertListView(hDlg, lpPAI);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propCert);
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST));
            //lpPAI->lpCItem = NULL;
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propCert);
            //FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST),LV_CERT);
            FreeCertList(&(lpPAI->lpCItem));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            FreeCertList(&(lpPAI->lpCItem));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;


        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_CERT_LIST:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        SetLVDefaultCert(pNm->hdr.hwndFrom, iItemIndex);
                        if (lpbSomethingChanged)
                            (*lpbSomethingChanged) = TRUE;
                    }
                }
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_CERT_LIST:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        LPCERT_ITEM lpItem = (LPCERT_ITEM) pnmcd->lItemlParam;

                        if (lpItem)
                        {
			                if(lpItem->lpCDI->bIsDefault)
			                {
				                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				                return TRUE;
			                }
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        } //WM_NOTIFY

        return TRUE;
    }

    return bRet;

}



/*//$$***********************************************************************
*
*    FUNCTION: HrInitDetlsListView
*
*    PURPOSE:  Initializes the Email Address List View
*
****************************************************************************/
HRESULT HrInitDetlsListView(HWND hWndLV, DWORD dwStyle, int nLVType)
{
    HRESULT hr=hrSuccess;
    LV_COLUMN lvC;               // list view column structure
    DWORD dwLVStyle;
	RECT rc;
	HIMAGELIST hSmall = NULL;
	ULONG nCols=0;
	ULONG index=0;
    int nBmp=0;
    TCHAR sz[MAX_PATH];

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    if(nLVType == LV_EMAIL)
        nBmp = IDB_DEFAULT_EMAIL;
    else if(nLVType == LV_CERT)
        nBmp = IDB_CERT_VALID_INVALID;
    else if(nLVType == LV_KIDS)
        nBmp = IDB_DEFAULT_EMAIL;
    else
        nBmp = 0;

	ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_TYPEMASK) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_TYPEMASK) | dwStyle);


    if(nBmp)
    {
	    hSmall = gpfnImageList_LoadImage( hinstMapiX,
                                        MAKEINTRESOURCE(nBmp),
                                        //(LPCTSTR) ((DWORD) ((WORD) (nBmp))),
                                        S_BITMAP_WIDTH,
                                        0,
                                        RGB_TRANSPARENT,
                                        IMAGE_BITMAP,
                                        0);
	
	    // Associate the image lists with the list view control.
	    ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);
    }

	GetWindowRect(hWndLV,&rc);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column
	lvC.cx = rc.right - rc.left - 20; //TBD
	lvC.pszText = NULL;

    if(nLVType == LV_SERVER)
    {
        lvC.mask |= LVCF_TEXT;
        lvC.cx /= 2;
        LoadString(hinstMapiX, idsConfServer, sz, CharSizeOf(sz));
        lvC.pszText = sz;
    }

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		hr = E_FAIL;
		goto out;
	}

    // if this is the conferencing server item, add another prop
    if(nLVType == LV_SERVER)
    {
        LoadString(hinstMapiX, idsConfEmail, sz, CharSizeOf(sz));
        lvC.pszText = sz;
        if (ListView_InsertColumn (hWndLV, 1, &lvC) == -1)
	    {
		    DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		    hr = E_FAIL;
		    goto out;
	    }

    }

out:
    return hr;
}

/*//$$***********************************************************************
*
*    FUNCTION: FreeLVParams
*
*    PURPOSE:  Frees the memory allocated to the ListView item lParams
*
****************************************************************************/
void FreeLVParams(HWND hWndLV, int LVType)
{
    int iItemIndex = ListView_GetItemCount(hWndLV);

    while(iItemIndex > 0)
    {
        if(LVType == LV_EMAIL)
            DeleteLVEmailItem(hWndLV, iItemIndex-1);
        else if(LVType == LV_CERT)
            DeleteLVCertItem(hWndLV, iItemIndex-1, NULL);

        iItemIndex = ListView_GetItemCount(hWndLV);
    }


    return;
}


//$$
BOOL DeleteLVEmailItem(HWND hWndLV, int iItemIndex)
{
    LV_ITEM lvi;
    LPEMAIL_ITEM lpEItem;
    BOOL bDeletedDefault = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItemIndex;

    ListView_GetItem(hWndLV, &lvi);
    lpEItem = (LPEMAIL_ITEM) lvi.lParam;

    if (lpEItem->bIsDefault)
        bDeletedDefault = TRUE;

    LocalFreeAndNull(&lpEItem);

    ListView_DeleteItem(hWndLV, lvi.iItem);

    return bDeletedDefault;

}


///$$/////////////////////////////////////////////////////////////////////////
//
// AddLVEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddLVEmailItem(HWND    hWndLV,
                    LPTSTR  lpszEmailAddress,
                    LPTSTR  lpszAddrType)
{
    LV_ITEM lvi = {0};
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];
    ULONG nLen;
    LPEMAIL_ITEM lpEItem = NULL;

    if (!lpszEmailAddress)
        goto out;

    lpEItem = LocalAlloc(LMEM_ZEROINIT, sizeof(EMAIL_ITEM));
    if (!lpEItem)
    {
        DebugPrintError(( TEXT("AddLVEmailItem: Out of Memory\n")));
        goto out;
    }

    lpEItem->bIsDefault = FALSE;

    nLen = lstrlen(lpszEmailAddress) + 1;
    if (nLen > EDIT_LEN)
    {
        ULONG iLen = TruncatePos(lpszEmailAddress, EDIT_LEN - 1);
        CopyMemory(lpEItem->szEmailAddress,lpszEmailAddress,sizeof(TCHAR)*iLen);
        lpEItem->szEmailAddress[iLen] = '\0';
    }
    else
    {
        lstrcpy(lpEItem->szEmailAddress,lpszEmailAddress);
    }

    lstrcpy(lpEItem->szDisplayText,lpEItem->szEmailAddress);

    if(!lpszAddrType)
    {
        lstrcpy(szBuf, szSMTP);
        lpszAddrType = szBuf;
    }

    nLen = lstrlen(lpszAddrType) + 1;
    if (nLen > EDIT_LEN)
    {
        ULONG iLen = TruncatePos(lpszAddrType, EDIT_LEN - 1);
        CopyMemory(lpEItem->szAddrType,lpszAddrType,sizeof(TCHAR)*iLen);
        lpEItem->szAddrType[iLen] = '\0';
    }
    else
    {
        lstrcpy(lpEItem->szAddrType,lpszAddrType);
    }

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.pszText = lpEItem->szDisplayText;
    lvi.cchTextMax = MAX_UI_STR;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;
    lvi.iImage = imgNotDefaultEmail;
    lvi.lParam = (LPARAM) lpEItem;

    ListView_InsertItem(hWndLV, &lvi);

    if (ListView_GetItemCount(hWndLV) == 1)
    {
        // only one item in here .. we will take the liberty of making it the
        // default one ...
        SetLVDefaultEmail(hWndLV, 0);
    }

out:
    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// SetLVDefaultEmail - Makes an email entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
void SetLVDefaultEmail( HWND hWndLV,
                        int iItemIndex)
{
    int nCount = ListView_GetItemCount(hWndLV);
    int i;
    LPEMAIL_ITEM lpEItem = NULL;
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];

    if (iItemIndex >= nCount)
        goto out;

    for(i=0; i<nCount; i++)
    {
        // At amy given point of time one and only one entry in the
        // list view is the default one ...
        // So we want to reset the previous default and set the new one
        //
        LV_ITEM lvi = {0};
        lvi.iItem = i;
        lvi.mask = LVIF_PARAM;
        if(!ListView_GetItem(hWndLV, &lvi))
            goto out;
        lpEItem = (LPEMAIL_ITEM) lvi.lParam;
        if (lpEItem->bIsDefault)
        {
            // This was the default entry - if its the same one we are setting
            // do nothing ...
            if (i == iItemIndex)
                goto out;

            // else reset this entry ...
            lpEItem->bIsDefault = FALSE;
            lvi.iImage = imgNotDefaultEmail;
            lvi.pszText = lpEItem->szEmailAddress;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
        if (iItemIndex == i)
        {
            //This is the item we want to modify ..
            lpEItem->bIsDefault = TRUE;
            lvi.iImage = imgDefaultEmail;

            lstrcpy(lpEItem->szDisplayText,lpEItem->szEmailAddress);
            LoadString(hinstMapiX, idsDefaultEmail, szBuf, CharSizeOf(szBuf));
            lstrcat(lpEItem->szDisplayText, TEXT("  "));
            lstrcat(lpEItem->szDisplayText, szBuf);

            lvi.pszText = lpEItem->szDisplayText;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
    }

    LVSelectItem(hWndLV, iItemIndex);

out:
    return;
}

#ifdef WIN16 // Enable DDE to communicate IE.
#include <ddeml.h>

static char cszIEAppName[] = "IEXPLORE";
static char cszIEDDEOpenURL[] = "WWW_OpenURL";
static char cszIEDDEActivate[] = "WWW_Activate";

static char cszIEIniFile[] = "iexplore.ini";
static char cszIEIniSectMain[] = "Main";
static char cszIEIniKeyStart[] = "Home Page";
static char cszIEIniKeySearch[] = "Search Page";
static char cszIEReadNews[] = "news:*";

static char cszIEBinName[] = "iexplore.exe";
static char cszIERegHtm[] = ".htm";
static char cszRegShellOpen[] = "shell\\open\\command";

static HDDEDATA CALLBACK  DdeCallback( UINT uType, UINT uFmt, HCONV hConv,
          HSZ hSz1, HSZ hSz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2 )
{
   return( (HDDEDATA)NULL );
}

#define TIME_WAIT_DDE   10000   // waiting for 10 sec, and if doesn't return,
                                // assumes News is configured correctly.

void RunBrowser(LPCSTR cszURL, BOOL bCheckRet )
{
   if ( GetModuleHandle( cszIEBinName ) == NULL )
   {
//
// FIND & RUN IEXPLORE
//
// Try to find the browser in the Mail's directory
      char  szPath[_MAX_PATH*2+1];
      char  *pPtr, *pSlash = NULL;;
      HKEY  hKey;
      LONG  cbPath;
      char  szRegPath[_MAX_PATH];

      GetModuleFileName( hinstMapiXWAB, szPath, _MAX_PATH );
      for ( pPtr = szPath;  *pPtr;  pPtr = AnsiNext( pPtr ) )
         if ( *pPtr == '\\' )
         {
            pSlash = pPtr;
         }
      if ( pSlash != NULL )
      {
         _fstrcpy( pSlash+1, cszIEBinName );
         _fstrcat( szPath, " " );
         _fstrcat( szPath, cszURL );

         if ( WinExec( szPath, SW_SHOWNORMAL ) >= 32 )
         {
            return;
         }
      }

// Try to find system default browser from the registry
      _fstrcpy( szRegPath, cszIERegHtm );
      while ( RegOpenKey( HKEY_CLASSES_ROOT, szRegPath, &hKey ) == ERROR_SUCCESS )
      {
         LONG lReg;
         cbPath = CharSizeOf( szPath );
         lReg = RegQueryValue( hKey, cszRegShellOpen, szPath, &cbPath );
         RegCloseKey( hKey );
         if ( lReg == ERROR_SUCCESS )
         {
            char  *pFmt = _fstrstr( szPath, "%1" );
            if ( pFmt != NULL )
            {
               _fstrcpy( pFmt, cszURL );
               *pFmt = '\0';
            }
            else
            {
               // Can this case happen???
               _fstrcat( szPath, " " );
               _fstrcat( szPath, cszURL );
            }

            if ( WinExec( szPath, SW_SHOWNORMAL ) >= 32 )
            {
               return;
            }
            else
               break;
         }
         else
         {
            cbPath = CharSizeOf( szRegPath );
            if ( RegQueryValue( HKEY_CLASSES_ROOT, szRegPath,
                                szRegPath, &cbPath ) != ERROR_SUCCESS )
               break;
         }
      }
// Insert proper messagebox here
//      MessageBox( IDS_NOT_FOUND_IEXPLORE );
      return;
   }
   else
   {
//
// CALL IEXPLORE DDE
//
      if ((GetWinFlags() & WF_PMODE) != 0 )     // None-Protected Mode
      {
         DWORD  idInst = 0L;
         FARPROC  lpDdeProc = MakeProcInstance( (FARPROC)DdeCallback, hinstMapiXWAB );

         if ( DdeInitialize( &idInst, (PFNCALLBACK)lpDdeProc,
                             APPCMD_CLIENTONLY,
                             0L ) == DMLERR_NO_ERROR )
         {
            HSZ   hszAppName = DdeCreateStringHandle( idInst, cszIEAppName, CP_WINANSI );
            char  szParam[256];
            HSZ   hszParam;
// Activate IE
            HSZ  hszTopic = DdeCreateStringHandle( idInst, cszIEDDEActivate, CP_WINANSI );
            HCONV  hConv = DdeConnect( idInst, hszAppName, hszTopic, (PCONVCONTEXT)NULL );

            DdeFreeStringHandle( idInst, hszTopic );
            if ( hConv != NULL )
            {
               wsprintf( szParam, "0x%lX,0x%lX", 0xFFFFFFFF, 0L );
               hszParam = DdeCreateStringHandle( idInst, szParam, CP_WINANSI );
               DdeClientTransaction( NULL, 0L, hConv, hszParam, CF_TEXT,
                                     XTYP_REQUEST, TIMEOUT_ASYNC, NULL );
               DdeFreeStringHandle( idInst, hszParam );
               DdeDisconnect( hConv );
            }

// Request to open URL
            hszTopic   = DdeCreateStringHandle( idInst, cszIEDDEOpenURL, CP_WINANSI );
            hConv = DdeConnect( idInst, hszAppName, hszTopic, (PCONVCONTEXT)NULL );
            DdeFreeStringHandle( idInst, hszTopic );
            if ( hConv != NULL )
            {
               HSZ hszParam;
               HDDEDATA hDDE;

               wsprintf( szParam, "\"%s\",,0x%lX,0x%lX,,,", cszURL, 0xFFFFFFFF, 0L );
               hszParam = DdeCreateStringHandle( idInst, szParam, CP_WINANSI );
               hDDE = DdeClientTransaction( NULL, 0L, hConv, hszParam,
                                   CF_TEXT, XTYP_REQUEST, TIME_WAIT_DDE, NULL );
               if ( bCheckRet && ( hDDE != NULL ) )
               {
                  long  lRet;
                  DdeGetData( hDDE, &lRet, sizeof( lRet ), 0 );
                  DdeFreeDataHandle( hDDE );
                  if ( lRet == -5L )
                  {
/*
// Insert Error message.
                     CString  strErr, strTmp;
                     strErr.LoadString( IDS_DDE_NEWS_NOT_READY1 );
                     strTmp.LoadString( IDS_DDE_NEWS_NOT_READY2 );
                     strErr += strTmp;
                     MessageBox( strErr, NULL, MB_ICONINFORMATION | MB_OK );
*/
                     ;
                  }
               }
               DdeFreeStringHandle( idInst, hszParam );
               DdeDisconnect( hConv );
            }

            DdeFreeStringHandle( idInst, hszAppName );
            DdeUninitialize( idInst );
         }

         FreeProcInstance( lpDdeProc );
      }
   }
}
#endif // WIN16



//$$/////////////////////////////////////////////////////////////////
//
// Launches explorer with the URL to show it ...
//
/////////////////////////////////////////////////////////////////////
void ShowURL(HWND hWnd, int id, LPTSTR lpURL)
{
    TCHAR szBuf[MAX_EDIT_LEN];
    LPTSTR lp = NULL;

    if(!lpURL)
    {
        //get the text in the dialog
        GetDlgItemText(hWnd, id, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        //if its blank, exit
        if(!lstrlen(szBuf))
            return;
        lpURL = szBuf;
    }

    // if its just the default prefix, ignore
    if(lstrcmpi(szHTTP, lpURL)!=0)
    {
        if(!bIsHttpPrefix(lpURL))
        {
            //append the http:// prefix before shellexecing
            lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpURL)+lstrlen(szHTTP)+1));
            lstrcpy(lp, szHTTP);
            lstrcat(lp, szBuf);
        }

        IF_WIN32(ShellExecute(hWnd,  TEXT("open"), (lp ? lp : lpURL), NULL, NULL, SW_SHOWNORMAL);)
        IF_WIN16(RunBrowser((lp ? lp : lpURL), FALSE);) // Need DDE routine to invoke IEXPLORE.

        if(lp)
            LocalFree(lp);

    }
    return;
}



//$$/////////////////////////////////////////////////////////////////
//
// Sets the  TEXT("http://") prefix in the URL edit fields if user doesnt
// anything in there ....
//
///////////////////////////////////////////////////////////////////
void SetHTTPPrefix(HWND hDlg, int id)
{
    TCHAR szBuf[MAX_EDIT_LEN];

    // Check to see if anything is filled in ...
    GetDlgItemText(hDlg, id, szBuf, CharSizeOf(szBuf));

    TrimSpaces(szBuf);

    if (lstrlen(szBuf))
        return;

    lstrcpy(szBuf,szHTTP);
    SetDlgItemText(hDlg, id, szBuf);

    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// AddNewEmailEntry - Adds text from Email edit box to the list box
//
// bShowCancelButton - lets us specify whether to show a dialog with a cancel
//                  button
//
// returns IDYES, IDNO or IDCANCEL
//
//////////////////////////////////////////////////////////////////////////////
int AddNewEmailEntry(HWND hDlg, BOOL bShowCancelButton)
{
    int nRet = IDYES;
    TCHAR szBuf[EDIT_LEN];
    LPTSTR lpszEmailAddress = szBuf;
    GetDlgItemText( hDlg,
                    IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL,
                    szBuf,
                    CharSizeOf(szBuf));

    TrimSpaces(szBuf);

    if(!lstrlen(szBuf))
        goto out;

    if(!IsInternetAddress(szBuf, &lpszEmailAddress))
    {
        // Check if this is invalid because of high bytes or something else
        // (Need to warn user about entering DBCS email addresses)
        LPTSTR lpsz = szBuf;
        BOOL bHighBits = FALSE;
        while (*lpsz)
        {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpsz >= 0x0080)
            {
                bHighBits = TRUE;
                break;
            }
            lpsz++;
        }

        if(bHighBits)
        {
            ShowMessageBox(GetParent(hDlg), idsInvalidDBCSInternetAddress, MB_ICONEXCLAMATION | MB_OK);
            SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
            goto out;
        }
        else
        {
            // some other casue for error
            int nFlag = (bShowCancelButton ? MB_YESNOCANCEL : MB_YESNO);
            nRet = ShowMessageBox(GetParent(hDlg), idsInvalidInternetAddress, MB_ICONEXCLAMATION | nFlag);
            if(IDYES != nRet)
            {
                SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                goto out;
            }
        }
    }

    // Add the text to the list box
    AddLVEmailItem( GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),
                    lpszEmailAddress,
                    NULL);

    // If there is no display name and there was one specified in the entered address,
    // add a display name.
    if (szBuf != lpszEmailAddress) {    // then there was a DisplayName specified in the entered email address
        TCHAR szBuf2[16];   // big enough to rule out likely leading spaces.  Doesn't have to fit entire DN.

        szBuf2[0] = '\0';
        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf2, CharSizeOf(szBuf2));
        TrimSpaces(szBuf2);
        if (lstrlen(szBuf2) == 0) {
            // No display name, set one
            SetComboDNText(hDlg, NULL, FALSE, szBuf);   // Set the DN
        }
    }


    //Cleanout the edit control
    SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL, szEmpty);

    //Disable the add new button
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),FALSE);

    // enable/disable other buttons
    if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST)) > 0)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
    }

    // Set the focus to the email edit field
    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));

    // Set the default id to the OK button
    SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);

    nRet = IDYES;

out:
    return nRet;
}


//$$///////////////////////////////////////////////////////////////
//
//  SetDetailsWindowTitle - creates a display name and sets it in
//  the title
//
///////////////////////////////////////////////////////////////////
void SetDetailsWindowTitle(HWND hDlg, BOOL bModifyDisplayNameField)
{
    TCHAR szFirst[MAX_UI_STR];
    TCHAR szLast[MAX_UI_STR];
    TCHAR szMiddle[MAX_UI_STR];
    TCHAR * szBuf = NULL;//szBuf[MAX_BUF_STR];

    if(!(szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_BUF_STR)))
        return;

    szFirst[0] = szMiddle[0] = szLast[0] = '\0';

    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, szFirst, CharSizeOf(szFirst));
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, szLast, CharSizeOf(szLast));
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME, szMiddle, CharSizeOf(szMiddle));

    szBuf[0]='\0';
    {
        LPTSTR lpszTmp = szBuf;
        SetLocalizedDisplayName(szFirst,
                                szMiddle,
                                szLast,
                                NULL,
                                NULL,
                                (LPTSTR *) &lpszTmp, //&szBuf,
                                MAX_BUF_STR,
                                bDNisByLN,
                                NULL,
                                NULL);
    }

    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);

    if (bModifyDisplayNameField)
    {
        SetComboDNText(hDlg, NULL, FALSE, szBuf);
        //SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_DISPLAYNAME, szBuf);
    }
    LocalFreeAndNull(&szBuf);
}

//$$///////////////////////////////////////////////////////////////
//
//  UpdateCertListView - fills the cert lv with certinfo, based on current
//      listview selection
//
///////////////////////////////////////////////////////////////////
void UpdateCertListView(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    HWND hWndLV = GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST);
    HWND hWndCombo = GetDlgItem(hDlg,IDC_DETAILS_CERT_COMBO);
    TCHAR szEmail[MAX_UI_STR];
    LPCERT_ITEM lpCItem = lpPai->lpCItem;
    int nSel = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    int nCountCerts = 0;
    BOOL * lpbAddCert = NULL;
    BOOL bShowOrphanCerts = FALSE;

    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),FALSE);

    *szEmail = '\0';
    if(!GetWindowText(hWndCombo, szEmail, CharSizeOf(szEmail)))
		goto out;

    if(!nCount || !lpCItem || !lstrlen(szEmail))
        goto out;


    nCountCerts = 0;
    while(lpCItem)
    {
        nCountCerts++;
        lpCItem = lpCItem->lpNext;
    }

    if(!nCountCerts)
        goto out;

    // Clear the list view ....
    ListView_DeleteAllItems(hWndLV);

    // we will have this bool array that we can use to mark which cert to
    // add and which not to add
    lpbAddCert = LocalAlloc(LMEM_ZEROINIT, nCountCerts*sizeof(BOOL));

    if(!lpbAddCert)
        goto out;

    // if the selection is in the last item in the list, then we only
    // show orphan certs ..
    // Orphan certs are certs without email addresses or with email addresses
    // that dont match anything in the current contacts properties ...
    //
    if(nSel == nCount - 1)
        bShowOrphanCerts = TRUE;

    lpCItem = lpPai->lpCItem;
    nCountCerts = 0;

    if(!bShowOrphanCerts)
    {
        // we only need to look at the e-mail address of each cert and match it to
        // the currently selected email address
        while(lpCItem)
        {
            if( lpCItem->lpCDI && lpCItem->lpCDI->lpszEmailAddress &&
                lstrlen(lpCItem->lpCDI->lpszEmailAddress ) &&
                !lstrcmpi(szEmail, lpCItem->lpCDI->lpszEmailAddress) )
            {
                lpbAddCert[nCountCerts] = TRUE; // Add this cert
            }

            nCountCerts++;
            lpCItem = lpCItem->lpNext;
        }
    }
    else
    {
        // Scan all the certs and find the ones that dont match anything
        while(lpCItem)
        {
            int i;

            lpbAddCert[nCountCerts] = TRUE; // Add this cert

            for(i=0;i<nCount-1;i++) // nCount = # e-mail addresses + 1
            {
                SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) szEmail);

                if( lpCItem->lpCDI && lpCItem->lpCDI->lpszEmailAddress &&
                    lstrlen(lpCItem->lpCDI->lpszEmailAddress ) &&
                    !lstrcmpi(szEmail, lpCItem->lpCDI->lpszEmailAddress) )
                {
                    // There is a match
                    lpbAddCert[nCountCerts] = FALSE; // Dont add this cert
                }
            }
            nCountCerts++;
            lpCItem = lpCItem->lpNext;
        }
    }


    lpCItem = lpPai->lpCItem;
    nCountCerts = 0;


    while(lpCItem)
    {
        if(lpbAddCert[nCountCerts])
            AddLVCertItem(  hWndLV, lpCItem, TRUE);

        nCountCerts++;
        lpCItem = lpCItem->lpNext;
    }

out:
    if(ListView_GetItemCount(hWndLV)>0)
    {
        if(lpPai->ulOperationType != SHOW_ONE_OFF)
        {
            EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),TRUE);
        }
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),TRUE);
    }

    if(lpbAddCert)
        LocalFree(lpbAddCert);

    return;

}

//$$
//
// Init the CertItem struct from an existing lpCDI struct
//
//  bImporting - if we are importing a new cert - tests it to see if it can be matched to
//              the current contact and if it can't, prompts user
//
BOOL AddNewCertItem(HWND hDlg, LPCERT_DISPLAY_INFO lpCDI, LPPROP_ARRAY_INFO lpPai, BOOL bImporting)
{
    int nLen = 0;
    BOOL bRet= FALSE;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
    LPCERT_ITEM lpCItem = NULL;
    BOOL bMatchFound = FALSE;

    // 96/12/20 markdu  BUG 13029  Check for duplicates before adding.
    if(bImporting)
    {
        int i, nCount;

        // Go through all the lpCDI structs in the listview elements and
        // see if any is a match with the new item
        nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
                if (CertCompareCertificate(X509_ASN_ENCODING, lpItem->lpCDI->pccert->pCertInfo,
                                           lpCDI->pccert->pCertInfo))
                {
                    // This cert is already in the list.  Select it.
                    ShowMessageBox(hDlg, idsCertAlreadyExists,
                                MB_ICONINFORMATION | MB_OK);
                    SetFocus(hWndLV);
                    LVSelectItem(hWndLV, i);
                    bRet = TRUE;
                    // Free lpCDI here or we will leak it ...
                    FreeCertdisplayinfo(lpCDI);
                    goto out;
                }
            }
        }
    }

    if(bImporting && lpCDI->lpszEmailAddress && lstrlen(lpCDI->lpszEmailAddress))
    {
        // Check the e-mail address of this certificate with the ones we already have
        // Warn if we cant find it
        HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_CERT_COMBO);
        TCHAR szEmail[MAX_PATH];
        int i, nCount;
        nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);

        if(nCount > 1)
        {
            // Go thru all the email addresses in the combo box
            for(i= 0;i<nCount -1; i++)
            {
                *szEmail = '\0';
                SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) szEmail);
                if( lpCDI->lpszEmailAddress && lstrlen(szEmail) &&
                    !lstrcmpi(szEmail, lpCDI->lpszEmailAddress))
                {
                    bMatchFound = TRUE;
                    break;
                }
            }
        }

        if(!bMatchFound)
        {
            switch(ShowMessageBoxParam(hDlg, idsImportCertNoEmail, MB_ICONEXCLAMATION | MB_YESNOCANCEL,
                    lpCDI->lpszDisplayString, lpCDI->lpszEmailAddress))
            {
            case IDCANCEL: // cancel this import
                bRet = TRUE;
                // Free lpCDI here or we will leak it ...
                FreeCertdisplayinfo(lpCDI);
                goto out;
                break;
            case IDYES: // Add the email address of this contact to the list of email addresses
                HrAddEmailToObj(lpPai, lpCDI->lpszEmailAddress, (LPTSTR)szSMTP);
                FillCertComboWithEmailAddresses(hDlg, lpPai, lpCDI->lpszEmailAddress);
                break;
            case IDNO: // do nothing just add this certificate
                break;
            }
        }
    }

    if( bImporting &&
        (!lpCDI->lpszEmailAddress || !lstrlen(lpCDI->lpszEmailAddress)) )
    {
        FillCertComboWithEmailAddresses(hDlg, lpPai, szEmpty); //szEmpty forces combo to switch to the  TEXT("none") option
    }

    lpCItem = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_ITEM));

    if (!lpCItem)
        goto out;

    lpCItem->lpCDI = lpCDI;
    lpCItem->pcCert = CertDuplicateCertificateContext(lpCDI->pccert);
    lpCItem->lpPrev = NULL;

    nLen = lstrlen(lpCDI->lpszDisplayString) + 1;
    if (nLen > MAX_PATH)
    {
        ULONG iLen = TruncatePos(lpCDI->lpszDisplayString, MAX_PATH - 1);
        lpCDI->lpszDisplayString[iLen] = '\0';
    }

    lstrcpy(lpCItem->szDisplayText, lpCDI->lpszDisplayString);

    lpCItem->lpNext = lpPai->lpCItem;
    if(lpPai->lpCItem)
        lpPai->lpCItem->lpPrev = lpCItem;
    lpPai->lpCItem = lpCItem;

    bRet = TRUE;
out:
    return bRet;

}
//$$///////////////////////////////////////////////////////////////
//
//  SetCertInfoInUI - fills the cert lv with certinfo, if any exists
//
///////////////////////////////////////////////////////////////////
HRESULT HrSetCertInfoInUI(HWND   hDlg,
                     LPSPropValue   lpPropMVCert,
                     LPPROP_ARRAY_INFO lpPai)
{
    HRESULT hr = E_FAIL; 
    LPCERT_DISPLAY_INFO lpCDI = NULL, lpTemp = NULL;

    if(!lpPropMVCert)
        goto out;

    if(!lpPai->lpCItem)
    {
        if(HR_FAILED(HrGetCertsDisplayInfo(hDlg, lpPropMVCert, &lpCDI)))
            goto out;

        if(!lpCDI)
        {
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        lpTemp = lpCDI;
        while(lpTemp)
        {

            AddNewCertItem(hDlg, lpTemp, lpPai, FALSE);

            lpTemp = lpTemp->lpNext;
        }
    }


    UpdateCertListView(hDlg, lpPai);

    hr = S_OK; 

out:
    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// AddLVcertItem - adds an item to the certificates list view
//
//
////////////////////////////////////////////////////////////////////////////////////
BOOL AddLVCertItem(HWND hWndLV, LPCERT_ITEM lpCItem, BOOL bCheckForDups)
{
    LV_ITEM lvi = {0};
    ULONG nLen;
    BOOL bRet = FALSE;

    if(!lpCItem)
        goto out;

    // 96/12/20 markdu  BUG 13029  Check for duplicates before adding.
    if (TRUE == bCheckForDups)
    {
        int i, nCount;

        // Go through all the lpCDI structs in the listview elements and
        // see if any is a match with the new item
        nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
                if (CertCompareCertificate(X509_ASN_ENCODING, lpItem->lpCDI->pccert->pCertInfo,
                                           lpCItem->lpCDI->pccert->pCertInfo))
                {
                    // This cert is already in the list.  Select it.
                    SetFocus(hWndLV);
                    LVSelectItem(hWndLV, i);
                    goto out;
                }
            }
        }
    }


    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.pszText = lpCItem->lpCDI->bIsDefault ? lpCItem->szDisplayText : lpCItem->lpCDI->lpszDisplayString;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;

    if(!lpCItem->lpCDI->bIsExpired && !lpCItem->lpCDI->bIsRevoked && lpCItem->lpCDI->bIsTrusted)
        lvi.iImage = imgCertValid;
    else
        lvi.iImage = imgCertInvalid;

    lvi.lParam = (LPARAM) lpCItem;

    {
        int nIndex = ListView_InsertItem(hWndLV, &lvi);
        if (ListView_GetItemCount(hWndLV) == 1)
        {
            // only one item in here .. we will take the liberty of making it the
            // default one ...
            SetLVDefaultCert(hWndLV, 0);
        }
        else if(lpCItem->lpCDI->bIsDefault)
        {
            SetLVDefaultCert(hWndLV, nIndex);
        }

        // Select the cert we just added.
        SetFocus(hWndLV);
        LVSelectItem(hWndLV, nIndex);
    }
    bRet = TRUE;

out:
    return TRUE;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// SetLVDefaultCert - Makes an cert entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
void SetLVDefaultCert( HWND hWndLV,
                        int iItemIndex)
{
    int nCount = ListView_GetItemCount(hWndLV);
    int i;
    LPCERT_ITEM lpItem = NULL;
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];

    if (iItemIndex >= nCount)
        goto out;

    for(i=0; i<nCount; i++)
    {
        // At amy given point of time one and only one entry in the
        // list view is the default one ...
        // So we want to reset the previous default and set the new one
        //
        LV_ITEM lvi = {0};
        lvi.iItem = i;
        lvi.mask = LVIF_PARAM;
        if(!ListView_GetItem(hWndLV, &lvi))
            goto out;
        lpItem = (LPCERT_ITEM) lvi.lParam;
        if (lpItem->lpCDI->bIsDefault)
        {
            // This was the default entry - if its
            // not the same one as the one we are setting,
            // reset the default
            if (i != iItemIndex)
            {
                // else reset this entry ...
                lpItem->lpCDI->bIsDefault = FALSE;
                lvi.pszText = lpItem->lpCDI->lpszDisplayString;
                lvi.mask = LVIF_PARAM | LVIF_TEXT;
                lvi.iItem = i;
                lvi.iSubItem = 0;
                ListView_SetItem(hWndLV, &lvi);
            }
        }
        if (iItemIndex == i)
        {
            //This is the item we want to modify ..
            lpItem->lpCDI->bIsDefault = TRUE;
            lstrcpy(lpItem->szDisplayText,lpItem->lpCDI->lpszDisplayString);
            LoadString(hinstMapiX, idsDefaultCert, szBuf, CharSizeOf(szBuf));
            lstrcat(lpItem->szDisplayText, szBuf);

            lvi.pszText = lpItem->szDisplayText;
            lvi.mask = LVIF_PARAM | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
    }

    LVSelectItem(hWndLV, iItemIndex);

out:
    return;
}

extern HRESULT HrGetTrustState(HWND hwndParent, PCCERT_CONTEXT pcCert, DWORD *pdwTrust);

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowCertProps - Shows props for a cert
//
//////////////////////////////////////////////////////////////////////////////
void ShowCertProps(HWND hDlg, HWND hWndLV, BOOL * lpBool)
{
    DWORD dwTrust = 0;
    int nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    LV_ITEM lvi;
    LPCERT_ITEM lpItem;
    BOOL bDeletedDefault = FALSE;
    BOOL bOldTrusted;
    LPSTR   oidPurpose = szOID_PKIX_KP_EMAIL_PROTECTION;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = nIndex;

    if(ListView_GetItem(hWndLV, &lvi))
    {
        lpItem = (LPCERT_ITEM) lvi.lParam;
        if(lpItem)
        {
            if(lpItem->pcCert == NULL)
            {
                Assert(lpItem->pcCert);
                return;
            }

            // Only one thing is user changable in the cert UI - the trust info
            // So we will track that piece of info
            // User can change dwTrust and consequently, bIsTrusted can also change
            // which needs to be uppdated in the UI check mark

            bOldTrusted = lpItem->lpCDI->bIsTrusted;

            {
                CERT_VIEWPROPERTIES_STRUCT_A cvps = {0};

                cvps.dwSize = sizeof(CERT_VIEWPROPERTIES_STRUCT);
                cvps.hwndParent = hDlg;
                cvps.hInstance = hinstMapiX;
                cvps.pCertContext = lpItem->pcCert;
                cvps.arrayPurposes = &oidPurpose;
                cvps.cArrayPurposes = 1;
                cvps.nStartPage = 1; // go directly to details page
                cvps.dwFlags = CM_NO_NAMECHANGE;

                CertViewPropertiesA(&cvps);
            }

            // Determine if the trust changed or not
            if (FAILED(HrGetTrustState(hDlg, lpItem->pcCert, &(lpItem->lpCDI->dwTrust))))
            {
                lpItem->lpCDI->dwTrust = CERT_VALIDITY_NO_TRUST_DATA;
            }

            if (0 == lpItem->lpCDI->dwTrust)
                lpItem->lpCDI->bIsTrusted = TRUE;
            else
                lpItem->lpCDI->bIsTrusted = FALSE;

            //N2 if the trust changes, we need to check trust again...
            if (bOldTrusted != lpItem->lpCDI->bIsTrusted)
            {
                LV_ITEM lvi = {0};

                // Update the displayed graphic next to the cert.
                lvi.mask = LVIF_IMAGE;
                lvi.iItem = nIndex;
                lvi.iSubItem = 0;
                if(!lpItem->lpCDI->bIsExpired && !lpItem->lpCDI->bIsRevoked && lpItem->lpCDI->bIsTrusted)
                    lvi.iImage = imgCertValid;
                else
                    lvi.iImage = imgCertInvalid;
                ListView_SetItem(hWndLV, &lvi);
            }
            if(lpBool)
                *lpBool = TRUE;
        }
    }
    else if(ListView_GetSelectedCount(hWndLV) <= 0)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
    }

    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// DeleteLVCertItem - Makes an cert entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
BOOL DeleteLVCertItem(HWND hWndLV, int iItemIndex, LPPROP_ARRAY_INFO lpPai)
{
    LV_ITEM lvi;
    LPCERT_ITEM lpItem;
    BOOL bDeletedDefault = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItemIndex;

    if(ListView_GetItem(hWndLV, &lvi))
    {
        lpItem = (LPCERT_ITEM) lvi.lParam;

        if(lpItem)
        {
            if (lpItem->lpCDI->bIsDefault)
                bDeletedDefault = TRUE;

            if(lpItem->lpCDI->lpNext)
                lpItem->lpCDI->lpNext->lpPrev = lpItem->lpCDI->lpPrev;

            if(lpItem->lpCDI->lpPrev)
                lpItem->lpCDI->lpPrev->lpNext = lpItem->lpCDI->lpNext;

            FreeCertdisplayinfo(lpItem->lpCDI);

            if (lpItem->pcCert)
                CertFreeCertificateContext(lpItem->pcCert);

            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if(lpPai && lpPai->lpCItem == lpItem)
                lpPai->lpCItem = lpItem->lpNext;

            LocalFree(lpItem);

            ListView_DeleteItem(hWndLV, lvi.iItem);
        }
    }
    return bDeletedDefault;
}


const TCHAR szCertFilter[] =  TEXT("*.p7c;*.p7b;*.cer");
const TCHAR szAllFilter[] =  TEXT("*.*");
const TCHAR szCERFilter[] =  TEXT("*.cer");
const TCHAR szCERExt[] =  TEXT("ext");


//$$////////////////////////////////////////////////////////////////////////
////
//// ImportCert - imports a cert from file and then adds it into the list view
////
////
////////////////////////////////////////////////////////////////////////////
BOOL ImportCert(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];

    // we need to get a file name after poping the file open dialog
    // Then we need to decode it
    // Then we need to add it to the list view

    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_CERT_FILE_SPEC,
                                        szCertFilter,
                                        IDS_ALL_FILE_SPEC,
                                        szAllFilter,
                                        0,
                                        NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    LoadString(hinstMapiX, idsCertImportTitle, szBuf, CharSizeOf(szBuf));
    ofn.lpstrTitle = szBuf;
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL; 
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetOpenFileName(&ofn))
    {
        LPCERT_DISPLAY_INFO lpCDI = NULL;
        LPCERT_ITEM lpCItem = NULL;
        if(!HR_FAILED(HrImportCertFromFile( szFileName,
				                            &lpCDI)))
        {
            if(!AddNewCertItem(hDlg, lpCDI, lpPai, TRUE))
                goto out;

            UpdateCertListView(hDlg, lpPai);
        }
        else
        {
            ShowMessageBoxParam(hDlg, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto out;
        }
    }
    else
        goto out;


    bRet = TRUE;

out:
    LocalFreeAndNull(&lpFilter);
    return bRet;
}


//$$////////////////////////////////////////////////////////////////////////
////
//// ExportCert - exports a cert to a file
////
////
////////////////////////////////////////////////////////////////////////////
BOOL ExportCert(HWND hDlg)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);

    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_CER_FILE_SPEC,
                                        szCERFilter,
                                        IDS_ALL_FILE_SPEC,
                                        szAllFilter,
                                        0,
                                        NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");


    // we need to get a file name after poping the file open dialog
    // Then we need to save the cert to the file name

    // First make sure only one entry is selected for exporting
    if(ListView_GetSelectedCount(hWndLV) > 1)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_ACTION, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }
    else if (ListView_GetSelectedCount(hWndLV) <= 0)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    LoadString(hinstMapiX, idsCertExportTitle, szBuf, CharSizeOf(szBuf));
    ofn.lpstrTitle = szBuf;
    ofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = szCERExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetSaveFileName(&ofn))
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        lvi.iSubItem = 0;
        if (ListView_GetItem(hWndLV, &lvi))
        {
            LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
            HrExportCertToFile( szFileName, lpItem->lpCDI->pccert, NULL, NULL, FALSE);
        }
        else
            goto out;
    }
    else
        goto out;


    bRet = TRUE;

out:
    return bRet;
}

//$$////////////////////////////////////////////////////////////////////////////////
//
//  Sets the display name in the Combo box
//
//  hDlg - handle of Personal Pane
//  lppai - proparrayinfo struct
//  bAddAll - determines whether to fill the combo with all the values or not
//  szTxt - txt to put in the edit field part of the combo. if bAddAll=TRUE,
//      dont need szTxt.
//
////////////////////////////////////////////////////////////////////////////////////
void SetComboDNText(HWND hDlg, LPPROP_ARRAY_INFO lppai, BOOL bAddAll, LPTSTR szTxt)
{
    HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);

    if(!bAddAll)
    {
        if(szTxt == NULL)
            szTxt = szEmpty;
        // just add the current string to the combo
        SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szTxt);
        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
        SetWindowText(hWndCombo, szTxt);
    }
    else
    {
        // Populates the drop down list with all other names ...
        TCHAR * szFirst = NULL;//szFirst[MAX_UI_STR*2];
        TCHAR * szMiddle = NULL;//[MAX_UI_STR*2];
        TCHAR * szLast = NULL;//[MAX_UI_STR*2];
        TCHAR * szDisplay = NULL;//[MAX_UI_STR*2];
        ULONG nLen = MAX_UI_STR*2;
        szFirst = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szLast = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szMiddle = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szDisplay = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));

        if(szFirst && szLast && szMiddle && szDisplay)
        {
            szFirst[0] = szLast[0] = szMiddle[0] = szDisplay[0] = '\0';

            // First get the current text and save it ...
            GetWindowText(hWndCombo, szDisplay, nLen);

            // Clear out combo and add the display name again
            SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

            if(lstrlen(szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szDisplay);

            // Get the localized F/M/L name from F/M/L fields
            // If the localized name does not match the display name, add it
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, szFirst, nLen);
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, szLast, nLen);
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME, szMiddle, nLen);

            {
                ULONG ulSzBuf = MAX_BUF_STR;
                LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*ulSzBuf);
                LPTSTR lpszTmp = szBuf;

                if(szBuf) // Get the localized Display Name and reverse localized display name
                {
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, bDNisByLN, 
                                                bDNisByLN ? szResourceDNByCommaLN : szResourceDNByLN,
                                                NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    lstrcpy(szBuf, szEmpty);
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, !bDNisByLN, NULL, NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    lstrcpy(szBuf, szEmpty);
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, bDNisByLN, NULL, NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    LocalFreeAndNull(&szBuf);
                }
            }

            // Get the NickName and if its different add it to this list
            szFirst[0]='\0';
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_NICKNAME, szFirst, nLen);
            if(lstrlen(szFirst) && lstrcmp(szFirst, szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szFirst);

            // Get the Company name and if its different add it to the list
            szFirst[0]='\0';
            {
                ULONG i;
                ULONG ulcPropCount = 0;
                LPSPropValue lpPropArray = NULL;
                SizedSPropTagArray(1, ptaDN) = {1, PR_COMPANY_NAME};
                if(!HR_FAILED(lppai->lpPropObj->lpVtbl->GetProps(lppai->lpPropObj,
                                                        (LPSPropTagArray)&ptaDN, 
                                                        MAPI_UNICODE,
                                                        &ulcPropCount,
                                                        &lpPropArray)))
                {
                    if(lpPropArray[0].ulPropTag == PR_COMPANY_NAME)
                        lstrcpy(szFirst, lpPropArray[0].Value.LPSZ);
                }
                if(lpPropArray)
                    MAPIFreeBuffer(lpPropArray);
            }

            if(lstrlen(szFirst) && lstrcmp(szFirst, szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szFirst);

            SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
            SetWindowText(hWndCombo, szDisplay);
        }
        LocalFreeAndNull(&szFirst);
        LocalFreeAndNull(&szLast);
        LocalFreeAndNull(&szMiddle);
        LocalFreeAndNull(&szDisplay);
    }

    //SendMessage(hWndCombo, WM_SETREDRAW, (WPARAM) TRUE, 0);
    UpdateWindow(hWndCombo);

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrShowOneOffDetailsOnVCard
//
//  Deciphers a vCard File and then shows one off details on it
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowOneOffDetailsOnVCard(  LPADRBOOK lpAdrBook,
                                     HWND hWnd,
                                     LPTSTR szvCardFile)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;
    LPMAILUSER lpMailUser = NULL;
    LPSTR lpBuf = NULL, lpVCardStart = NULL;
    LPSTR lpVCard = NULL, lpNext = NULL;

    if(!VCardGetBuffer(szvCardFile, NULL, &lpBuf) && hWnd) //no message if no hwnd
    {
        // couldn't open file.
        ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR,
                            MB_ICONEXCLAMATION, szvCardFile);
        goto out;
    }

    lpVCardStart = lpBuf;

    // Loop through showing all the nested vCards one by one ..
    while(VCardGetNextBuffer(lpVCardStart, &lpVCard, &lpNext) && lpVCard)
    {
        // Step 1 - see if we can get a mailuser object out of this file
        if(!HR_FAILED(hr = VCardRetrieve( lpAdrBook, hWnd, MAPI_DIALOG, szvCardFile,
                                        lpVCard, &lpMailUser)))
        {
            // Step 2 - Show one-off details on this entry
            if(!HR_FAILED(hr = HrShowOneOffDetails(   lpAdrBook, hWnd, 0, NULL,
                                MAPI_MAILUSER, (LPMAPIPROP) lpMailUser, NULL, SHOW_ONE_OFF)))
            {
                if(lpMailUser)
                    lpMailUser->lpVtbl->Release(lpMailUser);
                if(hr == MAPI_E_USER_CANCEL)
                    break;
            }
        }

        lpVCard = NULL;
        lpVCardStart = lpNext;
    }


out:
    LocalFreeAndNull(&lpBuf);
    return hr;
}
/*
HRESULT KillTrustInSleazyFashion(HWND hWndLV, int iItem)
{
    LV_ITEM         lvi = {0};
    HRESULT         hr = E_FAIL;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;

    if (ListView_GetItem(hWndLV, &lvi))
    {
    }

    return hr;
}
*/


/*//$$***********************************************************************
*    FUNCTION: fnTridentProc
*
*    PURPOSE:  Callback function for handling the Trident property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnTridentProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
            SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType, propTrident);
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propTrident, lpbSomethingChanged);
            return TRUE;
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB:
            lpPAI->nRetVal = DETAILS_ADDTOWAB;
            SendMessage(GetParent(hDlg), WM_COMMAND, (WPARAM) IDCANCEL, 0);
            break;

        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if(lpbSomethingChanged)
                (*lpbSomethingChanged) = ChangedExtDisplayInfo(lpPAI, (*lpbSomethingChanged));

            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}



//$$//////////////////////////////////////////////////////////////////////////
//
// SetDefaultServer(hDlg, lpPai)
//
//  iSelectedItem - the item index to which we should set the Default or Backup
//  bForce - forcibly set the Index to the one specified by iSelectedItem
//      if FALSE, chooses any unused index value
//
/////////////////////////////////////////////////////////////////////////////
void SetDefaultServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nCount = ListView_GetItemCount(hWndLV);
    TCHAR sz[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    int oldIndex = lpPai->nDefaultServerIndex;



    if(iSelectedItem == -1)
    {
        iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iSelectedItem < 0)
            return; // nothing selected ..
    }


    if(iSelectedItem == lpPai->nBackupServerIndex)
    {
        if(!bForce)
        {
            if(nCount >= 2)
            {
                int nTmp = 0;
                while(nTmp == iSelectedItem && nTmp < nCount)
                    nTmp++;
                iSelectedItem = nTmp;
            }
        }
    }

    // replace the old value of the def index item if applicable
    if(lpPai->nDefaultServerIndex >= 0 && lpPai->szDefaultServerName && lstrlen(lpPai->szDefaultServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, lpPai->szDefaultServerName);
        lstrcpy(lpPai->szDefaultServerName, szEmpty);
    }

    // replace the old backup item text if we are reseting the backup item
    if((lpPai->nBackupServerIndex == iSelectedItem) &&
       lpPai->nBackupServerIndex >= 0 && lpPai->szBackupServerName && lstrlen(lpPai->szBackupServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, lpPai->szBackupServerName);
        lstrcpy(lpPai->szBackupServerName, szEmpty);
    }

    lpPai->nDefaultServerIndex = iSelectedItem;

    // Now that we have unique indexes for Default and Server Indexes
    //  append  TEXT("Default") and  TEXT("Backup") to these names

    {
        lstrcpy(sz, szEmpty);
        lstrcpy(szTmp, szEmpty);
        ListView_GetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, sz, CharSizeOf(sz));
        lstrcpy(lpPai->szDefaultServerName, sz);
        LoadString(hinstMapiX, idsDefaultServer, szTmp, CharSizeOf(szTmp));
        lstrcat(sz,  TEXT(" "));
        lstrcat(sz, szTmp);
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, sz);
    }

    if(lpPai->nBackupServerIndex == iSelectedItem)
    {
        // Update this backup item
        SetBackupServer(hDlg, lpPai, oldIndex, FALSE);
    }
}


//$$//////////////////////////////////////////////////////////////////////////
//
// SetBackupServer(hDlg, lpPai) - set backup server if possible to do so
//
//  iSelectedItem - the item index to which we should set the Default or Backup
//  bForce - forcibly set the Index to the one specified by iSelectedItem
//      if FALSE, chooses any unused index value
//
/////////////////////////////////////////////////////////////////////////////
void SetBackupServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nCount = ListView_GetItemCount(hWndLV);
    TCHAR sz[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    int oldIndex = lpPai->nBackupServerIndex;

    if(iSelectedItem != -1)
    {
        if(nCount <= 1) // cant overwrite the default to skip
            return;
    }
    else
    {
        iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iSelectedItem < 0)
            return; // nothing selected ..
    }


    if(iSelectedItem == lpPai->nDefaultServerIndex)
    {
        if(nCount <= 1)
            return;
        else
        {
            if(!bForce)
            {
                int nTmp = 0;
                while(nTmp == iSelectedItem && nTmp < nCount)
                    nTmp++;
                iSelectedItem = nTmp;
            }
        }
    }

    // replace the old value of the def index item if its being overwritten
    if((lpPai->nDefaultServerIndex == iSelectedItem) &&
       lpPai->nDefaultServerIndex >= 0 && lpPai->szDefaultServerName && lstrlen(lpPai->szDefaultServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, lpPai->szDefaultServerName);
        lstrcpy(lpPai->szDefaultServerName, szEmpty);
    }

    // replace the old backup item text if we are reseting the backup item
    if(lpPai->nBackupServerIndex >= 0 && lpPai->szBackupServerName && lstrlen(lpPai->szBackupServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, lpPai->szBackupServerName);
        lstrcpy(lpPai->szBackupServerName, szEmpty);
    }

    lpPai->nBackupServerIndex = iSelectedItem;

    {
        lstrcpy(sz, szEmpty);
        lstrcpy(szTmp, szEmpty);
        ListView_GetItemText(hWndLV, lpPai->nBackupServerIndex, 0, sz, CharSizeOf(sz));
        lstrcpy(lpPai->szBackupServerName, sz);
        LoadString(hinstMapiX, idsBackupServer, szTmp, CharSizeOf(szTmp));
        lstrcat(sz,  TEXT(" "));
        lstrcat(sz, szTmp);
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, sz);
    }

    if(lpPai->nDefaultServerIndex == iSelectedItem)
    {
        // Update this backup item
        SetDefaultServer(hDlg, lpPai, oldIndex, FALSE);
    }
}



//$$//////////////////////////////////////////////////////////////////////////
//
// UpdateServerLVButtons(hDlg);
//
/////////////////////////////////////////////////////////////////////////////
void UpdateServerLVButtons(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    int nCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS));

    if(lpPai->ulOperationType == SHOW_ONE_OFF)
        nCount = 0;

    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_EDIT), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_REMOVE), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETBACKUP), (nCount > 1) ? TRUE : FALSE);

}

//$$//////////////////////////////////////////////////////////////////////////
//
// FillComboWithEmailAddresses(HWND hWndLV, HWND hWndCombo);
//
/////////////////////////////////////////////////////////////////////////////
void FillComboWithEmailAddresses(LPPROP_ARRAY_INFO lpPai, HWND hWndCombo, int * lpnDefault)
{
    ULONG i,j;
    ULONG ulcProps = 0;
    LPSPropValue lpProps = NULL;
    int nSel = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    TCHAR szBuf[MAX_UI_STR];
    BOOL bMatch = FALSE;
    BOOL bFound = FALSE;
    ULONG nEmail = 0xFFFFFFFF;

    enum _EmailProps
    {
        eCEmailAddr=0,
        eCEmailIndex,
        eCEmail,
        eMax
    };

    SizedSPropTagArray(eMax, ptaE) =
    {
        eMax,
        {
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_EMAIL_ADDRESS
        }
    };
    *szBuf = '\0';
    GetWindowText(hWndCombo, szBuf, CharSizeOf(szBuf));


    // Delete all the combo contents
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                                    (LPSPropTagArray)&ptaE, 
                                                    MAPI_UNICODE,
                                                    &ulcProps, &lpProps)))
        return;

    // Check if the PR_CONTACT_EMAIL_ADDRESSES already exists ..
    // if it does, tag the email onto it
    // if it doesnt and there is no pr_email_address, we create both
    // else if there is PR_EMAIL address then we cretae contact_email_addresses

    if(lpProps[eCEmailAddr].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
    {
        bFound = TRUE;
        for(j=0;j<lpProps[eCEmailAddr].Value.MVSZ.cValues;j++)
        {
            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpProps[eCEmailAddr].Value.MVSZ.LPPSZ[j]);
            if(!lstrcmp(szBuf, lpProps[eCEmailAddr].Value.MVSZ.LPPSZ[j]))
            {   
                bMatch = TRUE;
                nSel = j;
            }
        }
    }
    if( lpProps[eCEmailIndex].ulPropTag == PR_CONTACT_DEFAULT_ADDRESS_INDEX)
    {
        if(lpnDefault)
            *lpnDefault = lpProps[eCEmailIndex].Value.l;
    }
    if(lpProps[eCEmail].ulPropTag == PR_EMAIL_ADDRESS)
        nEmail = eCEmail;

    // if there is no Contact_Email_Addresses but there is an email_address
    if(!bFound && nEmail != 0xFFFFFFFF)
    {
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpProps[nEmail].Value.LPSZ);
        if(!lstrcmp(szBuf, lpProps[nEmail].Value.LPSZ))
        {
            bMatch = TRUE;
            nSel = 0;
        }
    }

    if(bMatch)
        SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nSel, 0);
    else if(lstrlen(szBuf))
    {
        // make sure this is not the     [None .. ] string
        TCHAR sz[MAX_PATH];
        LoadString(hinstMapiX, idsCertsWithoutEmails, sz, CharSizeOf(sz));
        if(lstrcmpi(sz, szBuf))
        {
            int nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nPos, 0);
        }
    }

    SetWindowText(hWndCombo, szBuf);

    MAPIFreeBuffer(lpProps);

}

/*
-   ClearConfLV
-
*   Clears out the info alloced into the conferencing list view
*/
void ClearConfLV(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nItemCount = ListView_GetItemCount(hWndLV), i = 0;
    for(i=0;i< nItemCount; i++)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i; lvi.iSubItem = 0;
        ListView_GetItem(hWndLV, &lvi);
        if(lvi.lParam)
            LocalFreeServerItem((LPSERVER_ITEM) lvi.lParam);
    }
    ListView_DeleteAllItems(hWndLV);
}


/*//$$***********************************************************************
*    FUNCTION: fnConferencingProc
*
*    PURPOSE:  Callback function for handling the Conferencing property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnConferencingProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        // [PaulHi] EnumChildWindows needs to be called BEFORE SetDetails in this case
        // because it sets list view column strings.  SetDetails calls EnumChildWindows
        // at the end but this is too late.
        // @todo - Instead of callinge EnumChildWindows twice just call it at the 
        // begninning of SetDetails.  Don't want to change the code that much now right
        // before RTM.
        EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM)0);
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType, propConferencing);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;
        break;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE:
            if(LOWORD(wParam) == IDC_DETAILS_NTMTG_EDIT_ADDSERVER)
            {
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_ADDSERVER),TRUE);
                SendMessage(hDlg, DM_SETDEFID, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, 0);
                return 0;
                break;
            }
        case CBN_EDITCHANGE:
        case CBN_SELCHANGE:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_NTMTG_BUTTON_CALL:
            // basically shell-exec a  TEXT("callto") command here
            // The format of the  TEXT("Callto") protocol is
            //      callto://servername/emailalias
            //
            {
                TCHAR * szCalltoURL = NULL;//szCalltoURL[MAX_UI_STR*2];
                TCHAR szEmail[MAX_UI_STR];
                TCHAR szServer[MAX_UI_STR];
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                if(szCalltoURL = LocalAlloc(LMEM_ZEROINIT, MAX_UI_STR*2*sizeof(TCHAR)))
                {
                    int nItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    {
                        LV_ITEM lvi = {0};
                        lvi.iItem = nItem;
                        lvi.iSubItem = 0;
                        lvi.mask = LVIF_PARAM;
                        ListView_GetItem(hWndLV, &lvi);

                        if(lvi.lParam)
                        {
                            lstrcpy(szServer, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpServer);
                            lstrcpy(szEmail, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpEmail);
                        }
                        else
                        {
                            lstrcpy(szServer, szEmpty);
                            lstrcpy(szEmail, szEmpty);
                        }
                    }
                    if(lstrlen(szServer) && lstrlen(szEmail))
                    {
                        lstrcpy(szCalltoURL, szCallto);
                        lstrcat(szCalltoURL, szServer);
                        lstrcat(szCalltoURL, TEXT("/"));
                        lstrcat(szCalltoURL, szEmail);
                        ShellExecute(hDlg,  TEXT("open"), szCalltoURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                    else
                        ShowMessageBox(hDlg, idsIncompleteConfInfo, MB_OK | MB_ICONINFORMATION);
                    LocalFreeAndNull(&szCalltoURL);
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                LVSelectItem(hWndLV, lpPAI->nConfEditIndex);
                lpPAI->ulFlags &= ~DETAILS_EditingConf;
                ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT), SW_HIDE);
                lpPAI->nConfEditIndex = -1;
                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szEmpty);
                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmpty);
                {
                    TCHAR sz[MAX_PATH];
                    LoadString(hinstMapiX, idsConfAdd, sz, CharSizeOf(sz));
                    SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, sz);
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_ADDSERVER:
            {
                TCHAR szBuf[MAX_UI_STR], szEmail[MAX_UI_STR];
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szBuf, CharSizeOf(szBuf));
                TrimSpaces(szBuf);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmail, CharSizeOf(szEmail));
                TrimSpaces(szEmail);
                if(!lstrlen(szBuf) || !lstrlen(szEmail))
                    ShowMessageBox(hDlg, idsIncompleteConfInfo, MB_OK | MB_ICONEXCLAMATION);
                else
                {
                    LV_ITEM lvi = {0};
                    LPSERVER_ITEM lpSI = (LPSERVER_ITEM) LocalAlloc(LMEM_ZEROINIT, sizeof(SERVER_ITEM));
                    LPTSTR lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                    LPTSTR lpE = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szEmail)+1));
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    if(lp && lpE && lpSI)
                    {
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
                        lstrcpy(lp, szBuf);
                        lstrcpy(lpE, szEmail);
                        lpSI->lpServer = lp;
                        lpSI->lpEmail = lpE;
                        lvi.lParam = (LPARAM) lpSI;
                        if(lpPAI->ulFlags & DETAILS_EditingConf)
                            lvi.iItem = lpPAI->nConfEditIndex;
                        else
                            lvi.iItem = ListView_GetItemCount(hWndLV);
                        lvi.cchTextMax = MAX_UI_STR;
                        lvi.iSubItem = 0;
                        lvi.pszText = szBuf;
                        ListView_InsertItem(hWndLV, &lvi);
            	        ListView_SetItemText (hWndLV, lvi.iItem, 1, szEmail);
                        SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szEmpty);
                        SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmpty);
                        if(lpPAI->ulFlags & DETAILS_EditingConf)
                        {
                            LV_ITEM lvii = {0};
                            lvii.mask = LVIF_PARAM;
                            lvii.iItem = lvi.iItem+1; lvii.iSubItem = 0;
                            ListView_GetItem(hWndLV, &lvii);
                            if(lvii.lParam)
                                LocalFreeServerItem((LPSERVER_ITEM) lvii.lParam);
                            ListView_DeleteItem(hWndLV, lvii.iItem);
                            if(lvi.iItem == lpPAI->nDefaultServerIndex)
                                lstrcpy(lpPAI->szDefaultServerName,lp);
                            else if(lvi.iItem == lpPAI->nBackupServerIndex)
                                lstrcpy(lpPAI->szBackupServerName,lp);
                            SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT, 0);
                        }
                        LVSelectItem(hWndLV, lvi.iItem);
                        SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        SetDefaultServer(hDlg, lpPAI, lpPAI->nDefaultServerIndex, TRUE);
                        SetBackupServer(hDlg, lpPAI, lpPAI->nBackupServerIndex, FALSE);
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
                    }
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_ADDSERVER),FALSE);
                    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_EDIT_ADDSERVER));
                }
                UpdateWindow(hWndLV);
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
                UpdateServerLVButtons(hDlg, lpPAI);
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_EDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    HWND hWndEditLabel;
                    int nItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    {
                        LV_ITEM lvi = {0};
                        lvi.iItem = nItem;
                        lvi.iSubItem = 0;
                        lvi.mask = LVIF_PARAM;
                        ListView_GetItem(hWndLV, &lvi);
                        if(lvi.lParam)
                        {
                            SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpServer);
                            SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpEmail);
                            // Remove these items from the ListView
                            SetFocus(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER));
                            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER), EM_SETSEL, 0, -1);
                            lpPAI->ulFlags |= DETAILS_EditingConf;
                            lpPAI->nConfEditIndex = nItem;
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT), SW_SHOW);
                            {
                                TCHAR sz[MAX_PATH];
                                LoadString(hinstMapiX, idsConfUpdate, sz, CharSizeOf(sz));
                                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, sz);
                            }
                        }
                    }
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                if(iItemIndex != -1)
                {
                    BOOL bDef = (iItemIndex == lpPAI->nDefaultServerIndex) ? TRUE : FALSE;
                    BOOL bBck = (iItemIndex == lpPAI->nBackupServerIndex) ? TRUE : FALSE;

                    if((lpPAI->ulFlags&DETAILS_EditingConf) && (iItemIndex==lpPAI->nConfEditIndex))
                        SendMessage(hDlg, WM_COMMAND, (WPARAM)IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT, 0);

                    {
                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = iItemIndex; lvi.iSubItem = 0;
                        ListView_GetItem(hWndLV, &lvi);
                        if(lvi.lParam)
                            LocalFreeServerItem((LPSERVER_ITEM) lvi.lParam);
                    }
                    ListView_DeleteItem(hWndLV, iItemIndex);
                    if(ListView_GetSelectedCount(hWndLV) <= 0)
                        LVSelectItem(hWndLV, (iItemIndex <= 0) ? iItemIndex : iItemIndex-1);
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if(iItemIndex < lpPAI->nDefaultServerIndex)
                        lpPAI->nDefaultServerIndex--;

                    if(iItemIndex < lpPAI->nBackupServerIndex)
                        lpPAI->nBackupServerIndex--;

                    if(bDef)
                    {
                        lpPAI->nDefaultServerIndex = -1;
                        lstrcpy(lpPAI->szDefaultServerName, szEmpty);
                        SetDefaultServer(hDlg, lpPAI, -1, FALSE);
                    }

                    if(bBck)
                    {
                        lpPAI->nBackupServerIndex = -1;
                        lstrcpy(lpPAI->szBackupServerName, szEmpty);
                        SetBackupServer(hDlg, lpPAI, -1, FALSE);
                    }

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }
                UpdateServerLVButtons(hDlg, lpPAI);
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT:
            SetDefaultServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case IDC_DETAILS_NTMTG_BUTTON_SETBACKUP:
            SetBackupServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;


        }
        break;

    default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), message, wParam, lParam);
        }
#endif // !WIN16
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propConferencing, lpbSomethingChanged);
            // if this is a readonly entry and there is no data in the listview,
            // disable the call now button
            if( lpPAI->ulOperationType == SHOW_ONE_OFF &&
                ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS)) <= 0)
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_CALL), FALSE);
            UpdateServerLVButtons(hDlg, lpPAI);
            //FillComboWithEmailAddresses(lpPAI, lpPAI->hWndComboConf, NULL);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            // In case there is something sitting in the edit boxes, add it to the lv
            //
            {
                TCHAR szBuf[MAX_UI_STR], szEmail[MAX_UI_STR];
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szBuf, CharSizeOf(szBuf));
                TrimSpaces(szBuf);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmail, CharSizeOf(szEmail));
                TrimSpaces(szEmail);
                if(lstrlen(szBuf) && lstrlen(szEmail))
                    SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, 0);
            }
            bUpdatePropArray(hDlg, lpPAI, propConferencing);
            ClearConfLV(hDlg);
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propConferencing);
            //ClearConfLV(hDlg);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingEmail) //cancel any editing else it faults #30235
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), -1);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            ClearConfLV(hDlg);
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_NTMTG_LIST_SERVERS:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        if( pnmcd->dwItemSpec == (DWORD) lpPAI->nDefaultServerIndex ||
                            pnmcd->dwItemSpec == (DWORD) lpPAI->nBackupServerIndex )
                        {
				            SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				            return TRUE;
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_NTMTG_LIST_SERVERS:
            SetDefaultServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
              break;
            }
            break;
        }
        return TRUE;
    }

    return bRet;

}

/*//$$***********************************************************************
*    FUNCTION: AddLVLDAPURLEntry
*
*    PURPOSE:  Takes an LDAP URL, converts it to a MailUser and adds the
*               MailUser to the List View
*
****************************************************************************/
void AddLVLDAPURLEntry(LPADRBOOK lpAdrBook, HWND hWndLV, LPTSTR lpszLDAPURL)
{
    LPMAILUSER lpMailUser = NULL;

    HrProcessLDAPUrl(lpAdrBook, GetParent(hWndLV),
                    WABOBJECT_LDAPURL_RETURN_MAILUSER,
                    lpszLDAPURL,
                    &lpMailUser);
    if(lpMailUser)
    {
        LPSPropValue lpPropArray = NULL;
        ULONG ulcProps = 0;
        if(!HR_FAILED(lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    NULL, MAPI_UNICODE,
                                                    &ulcProps, &lpPropArray)))
        {
            LPRECIPIENT_INFO lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		    if (lpItem)
            {
                GetRecipItemFromPropArray(ulcProps, lpPropArray, &lpItem);
                if(lpItem)
                    AddSingleItemToListView(hWndLV, lpItem);
            }
            MAPIFreeBuffer(lpPropArray);
        }
        lpMailUser->lpVtbl->Release(lpMailUser);
    }
}

/*//$$***********************************************************************
*    FUNCTION: FillOrgData
*
*    PURPOSE:  Fills in LDAP data in the Org prop sheets
*
****************************************************************************/
void FillOrgData(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    HWND hWndLVManager = GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER);
    HWND hWndLVReports = GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS);

    ULONG i,j;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPA = NULL;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    enum _org
    {
        oReports=0,
        oManager,
        oMax
    };
    SizedSPropTagArray(oMax, ptaOrg) = 
    {
        oMax,
        {
            PR_WAB_REPORTS,
            PR_WAB_MANAGER
        }
    };
    if(!HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj,
                                                    (LPSPropTagArray)&ptaOrg, 
                                                    MAPI_UNICODE,
                                                    &ulcPropCount, &lpPA)))
    {
        if(lpPA[oReports].ulPropTag == PR_WAB_REPORTS)
        {
            for(j=0;j<lpPA[oReports].Value.MVSZ.cValues;j++)
            {
                AddLVLDAPURLEntry(lpPai->lpIAB, hWndLVReports, lpPA[oReports].Value.MVSZ.LPPSZ[j]);
            }
        }
        if(lpPA[oManager].ulPropTag == PR_WAB_MANAGER)
        {
            AddLVLDAPURLEntry(lpPai->lpIAB, hWndLVManager, lpPA[oManager].Value.LPSZ);
        }
    }

    if(ListView_GetItemCount(hWndLVManager) > 0)
        LVSelectItem(hWndLVManager, 0);
    else
        EnableWindow(hWndLVManager, FALSE);

    if(ListView_GetItemCount(hWndLVReports) > 0)
        LVSelectItem(hWndLVReports, 0);
    else
        EnableWindow(hWndLVReports, FALSE);


    if(lpPA)
        MAPIFreeBuffer(lpPA);

    SetCursor(hOldCur);
}



/*//$$***********************************************************************
*
*    FUNCTION: FreeOrgLVData
*
*    PURPOSE:  Frees the Data from the Org LVs
*
****************************************************************************/
void FreeOrgLVData(HWND hWndLV)
{
    int i=0, nCount=ListView_GetItemCount(hWndLV);
    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        ListView_GetItem(hWndLV, &lvi);
        if(lvi.lParam)
        {
            LPRECIPIENT_INFO lpItem = (LPRECIPIENT_INFO) lvi.lParam;
            FreeRecipItem(&lpItem);
        }
    }
}



/*//$$***********************************************************************
*    FUNCTION: fnOrgProc
*
*    PURPOSE:  Callback function for handling the Organization Prop Sheets
*
****************************************************************************/
INT_PTR CALLBACK fnOrgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        HrInitListView(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER), LVS_REPORT, FALSE);
        HrInitListView(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS), LVS_REPORT, FALSE);
        UpdateWindow(hDlg);
        FillOrgData(hDlg, lpPAI);
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_APPLY:         //ok
            lpPAI->nRetVal = DETAILS_OK;
        case PSN_RESET:         //cancel
            FreeOrgLVData(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER));
            FreeOrgLVData(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS));
            if (lpPAI->nRetVal == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;


        // if enter pressed ...
        case LVN_KEYDOWN:
            if(((LV_KEYDOWN FAR *) lParam)->wVKey != VK_RETURN)
                break;
            // else fall thru
        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_ORG_LIST_MANAGER:
            case IDC_DETAILS_ORG_LIST_REPORTS:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
		                HrShowLVEntryProperties(pNm->hdr.hwndFrom, 0, lpPAI->lpIAB,NULL);
                }
                break;
            }
            break;
        } //WM_NOTIFY
        return TRUE;
    }
    return bRet;
}

void LocalFreeServerItem(LPSERVER_ITEM lpSI)
{
    if(lpSI)
    {
        if(lpSI->lpServer)
            LocalFree((LPVOID) lpSI->lpServer);
        if(lpSI->lpEmail)
            LocalFree((LPVOID) lpSI->lpEmail);
        LocalFree((LPVOID) lpSI);
    }
}



/*//$$***********************************************************************
*    FUNCTION: fnSummaryProc
*
*
****************************************************************************/
void UpdateSummaryInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    ULONG cValues = 0, i = 0, j = 0;
    LPSPropValue lpPropArray = NULL;
    BOOL bFoundEmail    = FALSE;
    BOOL bFoundHomeURL  = FALSE;
    BOOL bFoundBusURL   = FALSE;
    ULONG ulPropTag;
    HWND hURLBtn;

    if(!lpPai->lpPropObj)
        goto out;

    if (HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj,
                                        (LPSPropTagArray) &ptaUIDetlsPropsSummary, MAPI_UNICODE,
                                        &cValues,     
                                        &lpPropArray)))
    {
        goto out;
    }

    for(i=0;i<MAX_SUMMARY_ID;i++)
    {
        SetDlgItemText(hDlg, rgSummaryIDs[i], szEmpty);
        for(j=0;j<cValues;j++)
        {
            ulPropTag = lpPropArray[j].ulPropTag;
            if( ulPropTag == PR_DISPLAY_NAME)
            {
                SetWindowPropertiesTitle(GetParent(hDlg), lpPropArray[j].Value.LPSZ);
            }
            if(ulPropTag == ((LPSPropTagArray) &ptaUIDetlsPropsSummary)->aulPropTag[i])
            {
                if(ulPropTag == PR_EMAIL_ADDRESS)
                    bFoundEmail = TRUE;
                else if(ulPropTag == PR_PERSONAL_HOME_PAGE )
                    bFoundHomeURL = TRUE;
                else if( ulPropTag == PR_BUSINESS_HOME_PAGE )
                    bFoundBusURL = TRUE;

                SetDlgItemText(hDlg, rgSummaryIDs[i], lpPropArray[j].Value.LPSZ);
                break;
            }
        }
    }
        
    hURLBtn = GetDlgItem( hDlg, IDC_DETAILS_HOME_BUTTON_URL);
    if( bFoundHomeURL )
    {
        // enable and show button
        ShowWindow(hURLBtn, SW_SHOW);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(TRUE), (LPARAM)(0) ); 
    }
    else
    {
        // hide and disable button
        ShowWindow(hURLBtn, SW_HIDE);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(FALSE), (LPARAM)(0) );
    }
        
    hURLBtn = GetDlgItem( hDlg, IDC_DETAILS_BUSINESS_BUTTON_URL);
    if( bFoundBusURL )
    {
        // enable and show button
                
        ShowWindow(hURLBtn, SW_SHOW);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(TRUE), (LPARAM)(0) );        
    }
    else
    {
        // hide and disable button                
        ShowWindow(hURLBtn, SW_HIDE);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(FALSE), (LPARAM)(0) );
    }
    
    if(!bFoundEmail)
    {
        // Look for Contact_Email_Addresses and DefaultIndex
        ULONG nEmails = 0xFFFFFFFF, nDef = 0xFFFFFFFF;
        for(i=0;i<cValues;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                nEmails = i;
            if(lpPropArray[i].ulPropTag == PR_CONTACT_DEFAULT_ADDRESS_INDEX)
                nDef = i;
        }
        if(nEmails != 0xFFFFFFFF)
            SetDlgItemText( hDlg, IDC_DETAILS_SUMMARY_STATIC_EMAIL,
                            lpPropArray[nEmails].Value.MVSZ.LPPSZ[(nDef != 0xFFFFFFFF ? lpPropArray[nDef].Value.l : 0)]);
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return;
}

/*//$$***********************************************************************
*    FUNCTION: fnSummaryProc
*
*
****************************************************************************/
INT_PTR CALLBACK fnSummaryProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
            if (lpPAI->ulOperationType != SHOW_ONE_OFF ||
                lpPAI->ulFlags & DETAILS_HideAddToWABButton)
            {
                HWND hwnd = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB);
                EnableWindow(hwnd, FALSE);
                ShowWindow(hwnd, SW_HIDE);
            }
            if (lpPAI->ulOperationType == SHOW_ONE_OFF)
                EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
            return TRUE;
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB:
            lpPAI->nRetVal = DETAILS_ADDTOWAB;
            SendMessage(GetParent(hDlg), WM_COMMAND, (WPARAM) IDCANCEL, 0);
            break;
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_DETAILS_HOME_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB,NULL);
            break;
        case IDC_DETAILS_BUSINESS_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB,NULL);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            UpdateSummaryInfo(hDlg, lpPAI);
            break;

        case PSN_APPLY:         //ok
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if(lpbSomethingChanged)
                (*lpbSomethingChanged) = ChangedExtDisplayInfo(lpPAI, (*lpbSomethingChanged));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }
        return TRUE;
    }

    return bRet;

}



/*//$$***************************************************************************
*    FUNCTION: FillPersonalDetails(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillPersonalDetails(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    LPTSTR lpszDisplayName = NULL, lpszFirstName = NULL, lpszLastName = NULL;
    LPTSTR lpszMiddleName = NULL, lpszNickName = NULL, lpszCompanyName = NULL;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;
    BOOL bRichInfo = FALSE;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    SizedSPropTagArray(14, ptaUIDetlsPropsPersonal)=
    {
        14,
        {
            PR_DISPLAY_NAME,
            PR_EMAIL_ADDRESS,
            PR_ADDRTYPE,
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_ADDRTYPES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_GIVEN_NAME,
            PR_SURNAME,
            PR_MIDDLE_NAME,
            PR_NICKNAME,
            PR_SEND_INTERNET_ENCODING,
            PR_DISPLAY_NAME_PREFIX,
            PR_WAB_YOMI_FIRSTNAME,
            PR_WAB_YOMI_LASTNAME
        }
    };

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                        (LPSPropTagArray)&ptaUIDetlsPropsPersonal, 
                                        MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    // Check the check box on the UI for whether this contact can receive rich email messages
    for(i=0;i<ulcPropCount;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_SEND_INTERNET_ENCODING)
        {
            //Check the check box on the UI if no value is chosen for BODY_ENCODING_HTML
            // Bug 2285: wabtags.h had the wrong tag for BODY_ENCODING_HTML .. it was set to
            // be the same as BODY_ENCODING_TEXT_AND_HTML instead .. hence for backward compatibility
            // we have to also check for BODY_ENCODING_TEXT_AND_HTML here and then when
            // saving have to set it back to BODY_ENCODING_HTML ..

            int id = (lpPropArray[i].Value.l & BODY_ENCODING_HTML ||
                      lpPropArray[i].Value.l & BODY_ENCODING_TEXT_AND_HTML)
                      ? BST_UNCHECKED : BST_CHECKED;
            CheckDlgButton(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO, id);
            bRichInfo = TRUE;
            break;
        }
    }
    // if we didnt find the PR_SEND_INTERNET_ENCODING, we want to force a save on this contact
    // if the contact is writable ...
    if(!bRichInfo && lpPai->ulOperationType != SHOW_ONE_OFF)
        *lpbChangesMade = TRUE;

    for(i=0;i<ulcPropCount;i++)
    {
        switch(lpPropArray[i].ulPropTag)
        {
        case PR_DISPLAY_NAME:
            lpszDisplayName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_GIVEN_NAME:
            lpszFirstName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_SURNAME:
            lpszLastName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_MIDDLE_NAME:
            lpszMiddleName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_NICKNAME:
            lpszNickName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_COMPANY_NAME:
            lpszCompanyName = lpPropArray[i].Value.LPSZ;
            break;
        }
    }

    /*
    *
    * At this point we always have a display name. We need to track how this
    *   display name relates to F/M/L/Nick/Company
    *
    * So we check if
    *   Display Name == Nick Name
    *   Display Name == Company Name
    *   Display Name == FML
    */

    // Check if Display Name was created from First Middle Last
    if( (lpszFirstName && lstrlen(lpszFirstName)) ||
        (lpszMiddleName && lstrlen(lpszMiddleName)) ||
        (lpszLastName && lstrlen(lpszLastName))   )
    {
        ULONG ulSzBuf = 4*MAX_BUF_STR;
        LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
        LPTSTR lpszTmp = szBuf;

        if(!szBuf)
            goto out;

        if(!SetLocalizedDisplayName(lpszFirstName,
                                    lpszMiddleName,
                                    lpszLastName,
                                    NULL, // Company Name (not needed)
                                    NULL, // Nick Name (not needed here)
                                    (LPTSTR *) &lpszTmp, //&szBuf,
                                    ulSzBuf,
                                    bDNisByLN,
                                    NULL,
                                    NULL))
        {
            //TBD - do we really want to fail here .. ???
            LocalFreeAndNull(&szBuf);
            DebugPrintTrace(( TEXT("SetLocalizedDisplayName failed\n")));
            goto out;
        }

        if(lpszDisplayName && szBuf && !lstrcmp(lpszDisplayName, szBuf))
            lpPai->ulFlags |= DETAILS_DNisFMLName;
        else
            lpPai->ulFlags &= ~DETAILS_DNisFMLName;

        LocalFreeAndNull(&szBuf);
    }

    // if DN was not created from FML ..
    if(!(lpPai->ulFlags & DETAILS_DNisFMLName) )
    {
        // Check if DN == NickName
        if(lpszNickName)
        {
            if(!lstrlen(lpszDisplayName))
                lpszDisplayName = lpszNickName;

            if(!lstrcmp(lpszDisplayName, lpszNickName))
                lpPai->ulFlags |= DETAILS_DNisNickName;
            else
                lpPai->ulFlags &= ~DETAILS_DNisNickName;
        }

        // Check if DN == Company Name
        if(lpszCompanyName)
        {
            if(!lstrlen(lpszDisplayName))
                lpszDisplayName = lpszCompanyName;

            if(!lstrcmp(lpszDisplayName, lpszCompanyName))
                lpPai->ulFlags |= DETAILS_DNisCompanyName;
            else
                lpPai->ulFlags &= ~DETAILS_DNisCompanyName;
        }
    }
    else
    {
        lpPai->ulFlags &= ~DETAILS_DNisNickName;
        lpPai->ulFlags &= ~DETAILS_DNisCompanyName;
    }

    // if DN is none of the above and there is no FML,
    // parse the DN into F and L
    //
    if (    !lpszFirstName &&
            !lpszLastName &&
            !lpszMiddleName &&
            !(lpPai->ulFlags & DETAILS_DNisCompanyName) &&
            !(lpPai->ulFlags & DETAILS_DNisNickName) )
    {
        bChangesMade = ParseDisplayName(
                            lpszDisplayName,
                            &lpszFirstName,
                            &lpszLastName,
                            NULL,       // lpvRoot
                            &lpBuffer); // lppLocalFree

        lpPai->ulFlags |= DETAILS_DNisFMLName;
    }

    // Set the Dialog title to reflect the display name
    SetWindowPropertiesTitle(GetParent(hDlg), lpszDisplayName ? lpszDisplayName : szEmpty);

    //////////////////////////
    // A very inefficient and lazy way of filling the UI
    // but works for now
    //
    for(i=0;i<idPropPersonalCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == idPropPersonal[i].ulPropTag)
                SetDlgItemText(hDlg, idPropPersonal[i].idCtl, lpPropArray[j].Value.LPSZ);
        }
    }

    // Add the Yomi prop data
    for(j=0;j<ulcPropCount;j++)
    {
        if(lpPropArray[j].ulPropTag == PR_WAB_YOMI_FIRSTNAME)
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, lpPropArray[j].Value.LPSZ);
        if(lpPropArray[j].ulPropTag == PR_WAB_YOMI_LASTNAME)
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, lpPropArray[j].Value.LPSZ);
    }

    // Overwrite the first last name with out pre calculated values
    if (lpszFirstName)
        SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, lpszFirstName);
    if (lpszLastName)
        SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, lpszLastName);

    // Fill the Combo
    SetComboDNText(hDlg, NULL, FALSE, lpszDisplayName);

    {
        //
        // Now we fill in the Email addresses .. bunch of cases can exist in here
        // Single email, multiple email, no email etc ...
        //
        // First we search for all the props we need to fill in the email structure
        //
        LPSPropValue lpPropEmail = NULL;
        LPSPropValue lpPropAddrType = NULL;
        LPSPropValue lpPropMVEmail = NULL;
        LPSPropValue lpPropMVAddrType = NULL;
        LPSPropValue lpPropDefaultIndex = NULL;
        BOOL bDefaultSet = FALSE;
        HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);

        for(i=0;i<ulcPropCount;i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                lpPropEmail = &(lpPropArray[i]);
                break;
            case PR_ADDRTYPE:
                lpPropAddrType = &(lpPropArray[i]);
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                lpPropMVEmail = &(lpPropArray[i]);
                break;
            case PR_CONTACT_ADDRTYPES:
                lpPropMVAddrType = &(lpPropArray[i]);
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                lpPropDefaultIndex = &(lpPropArray[i]);
                break;
            }
        }

        // Assumption:
        // We must have a email address to work with even if we dont have
        // multiple email addresses
        if(lpPropEmail || lpPropMVEmail)
        {
            if(lpPropMVEmail)
            {
                // Assert(lpPropMVAddrType);

                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i=0;i<lpPropMVEmail->Value.MVSZ.cValues;i++)
                {
                    AddLVEmailItem( hWndLV,
                                    lpPropMVEmail->Value.MVSZ.LPPSZ[i],
                                    lpPropMVAddrType ? ((lpPropMVAddrType->Value.MVSZ.cValues > i) ? 
                                    lpPropMVAddrType->Value.MVSZ.LPPSZ[i] : (LPTSTR)szSMTP) : (LPTSTR)szSMTP);

                    if ( lpPropDefaultIndex && (i == (ULONG) lpPropDefaultIndex->Value.l) )
                    {
                        // This is the default one so set it ...
                        SetLVDefaultEmail(  hWndLV, i );
                    }
                }
            }
            else
            {
                LPTSTR lpszAddrType = NULL;
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                if (lpPropAddrType)
                    lpszAddrType = lpPropAddrType->Value.LPSZ;

                AddLVEmailItem( hWndLV,
                                lpPropEmail->Value.LPSZ,
                                lpszAddrType);

                // Flag that changes occured ...
                bChangesMade = TRUE;
            }

            if((ListView_GetItemCount(hWndLV)>0)&&(lpPai->ulOperationType != SHOW_ONE_OFF))
            {
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
            }
        }
    }

    if(!*lpbChangesMade)
        *lpbChangesMade = bChangesMade;

    bRet = TRUE;

out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*//$$***************************************************************************
*    FUNCTION: FillHomeBusinessNotesDetailsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillHomeBusinessNotesDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    switch(nPropSheet)
    {
/************/
    case propHome:
        idPropCount = idPropHomeCount;
        lpidProp = idPropHome;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        goto FillProp;
/************/
    case propBusiness:
        idPropCount = idPropBusinessCount;
        lpidProp = idPropBusiness;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;
        goto FillProp;
/************/
    case propNotes:
        {
            // See if this is a folder member and update the folder name on this tab
            BOOL bParent = FALSE;
            if( lpPai->ulOperationType != SHOW_DETAILS )
            {
                SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, szEmpty);
            }
            else
            {
                for(i=0;i<ulcPropCount;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_PARENT || lpPropArray[i].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP)
                    {
                        LPSBinary lpsbParent = &(lpPropArray[i].Value.MVbin.lpbin[0]);
                        LPWABFOLDER lpWABFolder = FindWABFolder((LPIAB)lpPai->lpIAB, lpsbParent, NULL, NULL);
                        if(lpWABFolder) // note if we didnt find the folder then the default  TEXT("Shared Contacts") name works fine
                        {
                            SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, lpWABFolder->lpFolderName);
                            bParent = TRUE;
                        }
                        break;
                    }
                }
            }
            if(!bParent && !bDoesThisWABHaveAnyUsers((LPIAB)lpPai->lpIAB))
            {
                TCHAR sz[MAX_PATH];
                LoadString(hinstMapiX, idsContacts, sz, CharSizeOf(sz));
                SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, sz);
            }

            // Find out all the groups in which this contact is a member ...
            //
            // if this is not a known entry id but is still non NULL ..
            //
            if( (0 == IsWABEntryID(lpPai->cbEntryID, lpPai->lpEntryID, NULL,NULL,NULL, NULL, NULL)) &&
                lpPai->cbEntryID && lpPai->lpEntryID)
            {
                // Only do this for WAB contacts
                TCHAR szBuf[MAX_BUF_STR];
                SPropertyRestriction PropRes = {0};
		        SPropValue sp = {0};
                HRESULT hr = E_FAIL;
                ULONG ulcCount = 0;
                LPSBinary rgsbEntryIDs = NULL;

		        sp.ulPropTag = PR_OBJECT_TYPE;
		        sp.Value.l = MAPI_DISTLIST;

                PropRes.ulPropTag = PR_OBJECT_TYPE;
                PropRes.relop = RELOP_EQ;
                PropRes.lpProp = &sp;

                lstrcpy(szBuf, szEmpty);

				// BUGBUG <JasonSo>: Need to pass in the current container here...
                hr = FindRecords(   ((LPIAB)lpPai->lpIAB)->lpPropertyStore->hPropertyStore,
									NULL, 0, TRUE, &PropRes, &ulcCount, &rgsbEntryIDs);

                if(!HR_FAILED(hr) && ulcCount)
                {
                    // Open all the groups and look at their contents
                    ULONG i,j,k;

                    for(i=0;i<ulcCount;i++)
                    {
                        ULONG ulcValues = 0;
                        LPSPropValue lpProps = NULL;
                        LPTSTR lpszName = NULL;

                        hr = HrGetPropArray(lpPai->lpIAB, NULL,
                                        rgsbEntryIDs[i].cb, (LPENTRYID) rgsbEntryIDs[i].lpb,
                                        MAPI_UNICODE,
                                        &ulcValues, &lpProps);
                        if(HR_FAILED(hr))
                            continue;

                        for(j=0;j<ulcValues;j++)
                        {
                            if (lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                            {
                                lpszName = lpProps[j].Value.LPSZ;
                                break;
                            }
                        }

                        for(j=0;j<ulcValues;j++)
                        {
                            if(lpProps[j].ulPropTag == PR_WAB_DL_ENTRIES)
                            {
                                // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
                                for (k = 0; k < lpProps[j].Value.MVbin.cValues; k++)
                                {
                                    ULONG cbEID = lpProps[j].Value.MVbin.lpbin[k].cb;
                                    LPENTRYID lpEID = (LPENTRYID) lpProps[j].Value.MVbin.lpbin[k].lpb;
                                    if (cbEID == lpPai->cbEntryID) // <TBD> we should be checking if its a wab entryid
                                                                   // but we'll just compare sizes for now ...
                                    {
                                        if(!memcmp(lpPai->lpEntryID, lpEID, cbEID))
                                        {
                                            if( (lstrlen(szCRLF) + lstrlen(szBuf) + lstrlen(lpszName) + 1)<CharSizeOf(szBuf))
                                            {
                                                lstrcat(szBuf, lpszName);
                                                lstrcat(szBuf, szCRLF);
                                                break;
                                            }
                                        }
                                    }
                                }
                                break; // just wanted to look at PR_WAB_DL_ENTRIES
                            }
                        } // for (j...

                        if(lpProps)
                            MAPIFreeBuffer(lpProps);

                    } // for(i...

                } ///if ..

                FreeEntryIDs(((LPIAB)lpPai->lpIAB)->lpPropertyStore->hPropertyStore,
                             ulcCount,
                             rgsbEntryIDs);

                if(lstrlen(szBuf))
                    SetDlgItemText(hDlg, IDC_DETAILS_NOTES_EDIT_GROUPS, szBuf);

            }
        }
        idPropCount = idPropNotesCount;
        lpidProp = idPropNotes;

/************/
FillProp:
        // A very inefficient and lazy way of filling the UI
        for(i=0;i<idPropCount;i++)
        {
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
                {
                    if(lpidProp[i].ulPropTag == PR_GENDER)
                    {
                        SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_SETCURSEL,
                                (WPARAM) lpPropArray[j].Value.i, 0);
                    }
                    else
                    if( lpidProp[i].ulPropTag == PR_WAB_POSTALID )
                    {
                        if(nPropSheet == propHome)
                            CheckDlgButton( hDlg, lpidProp[i].idCtl, 
                                            (lpPropArray[j].Value.l == ADDRESS_HOME)?BST_CHECKED:BST_UNCHECKED);
                        else if(nPropSheet == propBusiness)
                            CheckDlgButton( hDlg, lpidProp[i].idCtl, 
                                            (lpPropArray[j].Value.l == ADDRESS_WORK)?BST_CHECKED:BST_UNCHECKED);
                    }
                    else
                        SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
                }
            }

        }
        break;
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}


/*
-   FreeCertList - Frees the list of certificate items in memory
-
*
*/
void FreeCertList(LPCERT_ITEM * lppCItem)
{
    LPCERT_ITEM lpItem = NULL;
    if(!lppCItem)
        return;
    lpItem = *lppCItem;
    while(lpItem)
    {
        *lppCItem = lpItem->lpNext;
        FreeCertdisplayinfo(lpItem->lpCDI);
        if (lpItem->pcCert)
            CertFreeCertificateContext(lpItem->pcCert);
        LocalFree(lpItem);
        lpItem = *lppCItem;
    }
    *lppCItem = NULL;
}


/*//$$***************************************************************************
*    FUNCTION: FillCertTridentConfDetailsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillCertTridentConfDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    switch(nPropSheet)
    {
    case propCert:
        {
            //
            // Now we fill in the Certificate information
            // Cases that can exist are
            // - no certificates
            // - certificates
            //
            // First we search for all the props we need to fill in the email structure
            //
            LPSPropValue lpPropMVCert = NULL;
            BOOL bDefaultSet = FALSE;
            HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
            HRESULT hr = S_OK;
            for(i=0;i<ulcPropCount;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_USER_X509_CERTIFICATE)
                {
                    lpPropMVCert = &(lpPropArray[i]);
                    break;
                }
            }
            // Fill the combo with email addresses
            FillCertComboWithEmailAddresses(hDlg, lpPai, NULL);
            hr = HrSetCertInfoInUI(hDlg, lpPropMVCert, lpPai);
            if(hr == MAPI_E_NOT_FOUND && lpPropMVCert)
            {
                // The cert prop seems to contain bogus data .. need to nuke it
                // 48750 : if there is no cert data, dont show a cert icon ..
                // Problem is that we're not entirely sure that just because we couldnt
                // interpret the data that it's invalid, what if there is aata we don't interpret .. ?
            }
            if(lpPropMVCert)
            {
                // Enable the combo, the properties button, and the export button
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_COMBO),TRUE);
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),TRUE);
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),TRUE);
            }
        }
        break;
/************/
    case propTrident:
        {
            HrInit(lpPai->lpIWABDocHost, hDlg, IDC_TRIDENT_WINDOW, dhbNone);
            {
                ULONG i;
                LPTSTR lp = NULL, lpURL = NULL, lpLabel = NULL;
                // Find the labeledURI property and parse it
                // This string property contains a URL followed by spaces followed by the label (RFC 2079)
                for(i=0;i<ulcPropCount;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_LDAP_LABELEDURI)
                    {
                        // isolate the URL and the label
                        // The URL is followed by spaces
                        lpURL = lp = lpPropArray[i].Value.LPSZ;
                        while(lp && *lp)
                        {
                            if (IsSpace(lp))
                            {
                                lpLabel = CharNext(lp);
                                *lp = '\0';
                                break;
                            }
                            else
                                lp = CharNext(lp);
                        }
                        // The above is the URL
                        // Label starts at first non space char
                        while(lpLabel && IsSpace(lpLabel))
                            lpLabel = CharNext(lpLabel);
                    }
                    // Since the trident pane is shown first, update the windows title
                    if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                    {
                        lp = lpPropArray[i].Value.LPSZ;
                        if(lstrlen(lp))
                            SetWindowPropertiesTitle(GetParent(hDlg), lp);
                    }
                }
                if(lpLabel && lstrlen(lpLabel))
                    SetDlgItemText(hDlg, IDC_DETAILS_TRIDENT_STATIC_CAPTION, lpLabel);
                if(lpURL && lstrlen(lpURL))
                {
                    if(HR_FAILED(HrLoadURL(lpPai->lpIWABDocHost, lpURL)))
                    {
                        // remove this property sheet and set the focus to the first prop sheet
                        PropSheet_RemovePage(hDlg,lpPai->ulTridentPageIndex,NULL);
                        PropSheet_SetCurSel(hDlg, NULL, 0);
                    }
                    else
                        EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
                }
            }
        }
        break;
/************/
    case propConferencing:
        {
            HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL);

            FillComboWithEmailAddresses(lpPai, hWndCombo, NULL);

            // Fill in the conferencing related properties
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_WAB_CONF_SERVERS)
                {
                    LPSPropValue lpProp = &(lpPropArray[j]);
                    for(i=0;i<lpProp->Value.MVSZ.cValues; i++)
                    {
                        TCHAR sz[32];
                        if(lstrlen(lpProp->Value.MVSZ.LPPSZ[i]) < lstrlen(szCallto))
                            continue; //ignore this one

                        CopyMemory(sz, lpProp->Value.MVSZ.LPPSZ[i], sizeof(TCHAR)*(lstrlen(szCallto)+1));
                        sz[lstrlen(szCallto)] = '\0';

                        // if this is a callto
                        if(!lstrcmpi(sz, szCallto))
                        {
                            LV_ITEM lvi = {0};
                            LPSERVER_ITEM lpSI = LocalAlloc(LMEM_ZEROINIT, sizeof(SERVER_ITEM));
                            if(lpSI)
                            {
                                LPTSTR lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpProp->Value.MVSZ.LPPSZ[i])+1));
                                LPTSTR lpEmail = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpProp->Value.MVSZ.LPPSZ[i])+1));
                                if(lp && lpEmail)
                                {
                                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                                    lstrcpy(lp,lpProp->Value.MVSZ.LPPSZ[i]);
                                    *lpEmail = '\0';

                                    {
                                        // isolate just the server name by terminating
                                        // at the next '/'
                                        LPTSTR lp1 = lp + lstrlen(szCallto);
                                        lstrcpy(lp, lp1);
                                        lp1 = lp;
                                        while(lp1 && *lp1 && *lp1!='/')
                                            lp1 = CharNext(lp1);
                                        if(*lp1 == '/')
                                        {
                                            lstrcpy(lpEmail, lp1+1);
                                            *lp1 = '\0';
                                        }
                                        // Now lpEmail contains the email text ...
                                        // Walk along lpEmail till we hit the next /,?.or \0 and terminate
                                        lp1 = lpEmail;
                                        while(lp1 && *lp1 && *lp1!='/' && *lp1!='?')
                                            lp1 = CharNext(lp1);
                                        if(*lp1 == '/' || *lp1 == '?')
                                            *lp1 = '\0';
                                    }
                                    lvi.pszText = lp;
                                    lpSI->lpServer = lp;
                                    lpSI->lpEmail = lpEmail;
                                    lvi.lParam = (LPARAM) lpSI;
                                    lvi.cchTextMax = lstrlen(lp)+1;
                                    lvi.iItem = ListView_GetItemCount(hWndLV);
                                    lvi.iSubItem = 0;
                                    ListView_InsertItem(hWndLV, &lvi);
                                    ListView_SetItemText(hWndLV, lvi.iItem, 1, lpEmail);
                                }
                            }
                        }
                    }
                    LVSelectItem(hWndLV, 0);
                    break;
                }
            }
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_WAB_CONF_BACKUP_INDEX)
                {
                    lpPai->nBackupServerIndex = lpPropArray[j].Value.l;
                    lstrcpy(lpPai->szBackupServerName, szEmpty);
                    SetBackupServer(hDlg, lpPai, lpPai->nBackupServerIndex, FALSE);
                }
                else if(lpPropArray[j].ulPropTag == PR_WAB_CONF_DEFAULT_INDEX)
                {
                    lpPai->nDefaultServerIndex = lpPropArray[j].Value.l;
                    lstrcpy(lpPai->szDefaultServerName, szEmpty);
                    SetDefaultServer(hDlg, lpPai, lpPai->nDefaultServerIndex, TRUE);
                }
            }

            // For LDAP servers we will have a single item in PR_SERVERS and no default, backup etc
            // So if there is a single item available, force the default setting
            if(ListView_GetItemCount(hWndLV) == 1 && lpPai->nDefaultServerIndex == -1)
            {
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_PARAM;
                lvi.iItem = 0;
                if(ListView_GetItem(hWndLV, &lvi) && lvi.lParam)
                {
                    LPSERVER_ITEM lpSI = (LPSERVER_ITEM) lvi.lParam;
                    lpPai->nDefaultServerIndex = 0;
                    lstrcpy(lpPai->szDefaultServerName, lpSI->lpServer);
                    SetDefaultServer(hDlg, lpPai, lpPai->nDefaultServerIndex, TRUE);
                }
            }
        }
        break;
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*
-   HrAddEmailToObj
-   Adds a single Email to the PropObj
*
*
*/
HRESULT HrAddEmailToObj(LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail, LPTSTR szAddrType)
{
    ULONG ulcProps = 0, i =0;
    LPSPropValue lpProps = 0;
    HRESULT hr = S_OK;
    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;

    if(HR_FAILED(hr = lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                                    &ulcProps, &lpProps)))
        goto out;

    // Check if the PR_CONTACT_EMAIL_ADDRESSES already exists ..
    // if it does, tag the email onto it
    // if it doesnt and there is no pr_email_address, we create both
    // else if there is PR_EMAIL address then we cretae contact_email_addresses

    for(i=0;i<ulcProps;i++)
    {
        switch(lpProps[i].ulPropTag)
        {
        case PR_EMAIL_ADDRESS:
            nEmailAddress = i;
            break;
        case PR_ADDRTYPE:
            nAddrType = i;
            break;
        case PR_CONTACT_EMAIL_ADDRESSES:
            nMVEmailAddress = i;
            break;
        case PR_CONTACT_ADDRTYPES:
            nMVAddrTypes = i;
            break;
        case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
            nDefaultIndex = i;
            break;
        }
    }

    // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
    if(nEmailAddress == NOT_FOUND)
    {
        SPropValue spv[5];
        spv[0].ulPropTag = PR_EMAIL_ADDRESS;
        spv[0].Value.LPSZ = szEmail;
        spv[1].ulPropTag = PR_ADDRTYPE;
        spv[1].Value.LPSZ = szAddrType;
        spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        spv[2].Value.MVSZ.cValues = 1;
        spv[2].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));
        if(spv[2].Value.MVSZ.LPPSZ)
            spv[2].Value.MVSZ.LPPSZ[0] = szEmail;
        spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
        spv[3].Value.MVSZ.cValues = 1;
        spv[3].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));
        if(spv[3].Value.MVSZ.LPPSZ)
            spv[3].Value.MVSZ.LPPSZ[0] = szAddrType;
        spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        spv[4].Value.l = 0;
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, 5, (LPSPropValue)&spv, NULL);
        if(spv[2].Value.MVSZ.LPPSZ)
            LocalFree(spv[2].Value.MVSZ.LPPSZ);
        if(spv[3].Value.MVSZ.LPPSZ)
            LocalFree(spv[3].Value.MVSZ.LPPSZ);
        goto out;
    }
    else
    if(nMVEmailAddress == NOT_FOUND)
    {
        // we have an e-mail address but no contact-email-addresses
        // so we will need to create the contact e-mail addresses
        SPropValue spv[3];
        spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        spv[0].Value.MVSZ.cValues = 2;
        spv[0].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);
        if(spv[0].Value.MVSZ.LPPSZ)
        {
            spv[0].Value.MVSZ.LPPSZ[0] = lpProps[nEmailAddress].Value.LPSZ;
            spv[0].Value.MVSZ.LPPSZ[1] = szEmail;
        }
        spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
        spv[1].Value.MVSZ.cValues = 2;
        spv[1].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);
        if(spv[1].Value.MVSZ.LPPSZ)
        {
            spv[1].Value.MVSZ.LPPSZ[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpProps[nAddrType].Value.LPSZ;
            spv[1].Value.MVSZ.LPPSZ[1] = szAddrType;
        }
        spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        spv[2].Value.l = 0;
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, 3, (LPSPropValue)&spv, NULL);
        if(spv[0].Value.MVSZ.LPPSZ)
            LocalFree(spv[0].Value.MVSZ.LPPSZ);
        if(spv[1].Value.MVSZ.LPPSZ)
            LocalFree(spv[1].Value.MVSZ.LPPSZ);
        goto out;
    }
    else
    {
        // tag on the new props to the end of the existing contact_address_types
        if(HR_FAILED(hr = AddPropToMVPString(lpProps,ulcProps, nMVEmailAddress, szEmail)))
        {
            DebugPrintError(( TEXT("AddPropToMVString Email failed: %x"),hr));
            goto out;
        }

        if(HR_FAILED(hr = AddPropToMVPString(lpProps, ulcProps, nMVAddrTypes, szAddrType)))
        {
            DebugPrintError(( TEXT("AddPropToMVString AddrType failed: %x"),hr));
            goto out;
        }
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, ulcProps, lpProps, NULL);
    }
    
out:
    FreeBufferAndNull(&lpProps);
    return hr;
}

/*
-   ShowHideMapButton
-
*   The Expedia maps only work for US addresses right now .. therefore, if the current system locale
*   is not English-US, we will hide the button since we can't deal with international stuff just yet
*/
void ShowHideMapButton(HWND hWndButton)
{
    LCID lcid = GetUserDefaultLCID();
    
    switch (lcid)
    {
    case 0x0804: //chinese
    // case 0x0c04: //chinese - hongkong
    case 0x0411: //japanese
    case 0x0412: //korean
    case 0x0404: //taiwan
        EnableWindow(hWndButton, FALSE);
        ShowWindow(hWndButton, SW_HIDE);
        break;
    }
}

/*
-   ShowExpediaMAP
-   if there is sufficient address info in the supplied prop-obj, generate an expedia URL and shell exec it
*   Expedia currently handles US addresses differently from international ones so need to figure that one out <TBD>
*   bHome - TRUE if this is a home address
*/

// All spaces need to be replaced by '+'s
//
// Next two strings moved to resources
// const LPTSTR szExpediaTemplate =  TEXT("http://www.expediamaps.com/default.asp?Street=%1&City=%2&State=%4&Zip=%3");
// const LPTSTR szExpediaIntlTemplate =  TEXT("http://www.expediamaps.com/default.asp?Place=%2,%5"); //city,country
enum
{ 
    prStreet=0,
    prCity,
    prZip,
    prState,
    prCountry,
    prAddressMax,
};
void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome)
{
    ULONG ulcProps = 0;
    LPSPropValue lpProps = NULL;
    LPSPropTagArray lpta = (bHome ? (LPSPropTagArray)&ptaUIDetlsPropsHome : (LPSPropTagArray)&ptaUIDetlsPropsBusiness);

    if(!HR_FAILED(lpPropObj->lpVtbl->GetProps(  lpPropObj, lpta, MAPI_UNICODE, &ulcProps, &lpProps)))
    {
        LPTSTR lp[prAddressMax], lpURL = NULL;
        ULONG i,j, ulCount = 0;
        BOOL bUSAddress = FALSE;

        for(i=0;i<prAddressMax;i++)
        {
            if(lpProps[i].ulPropTag == lpta->aulPropTag[i])
            {
                ulCount++;
                lp[i] = lpProps[i].Value.LPSZ;
                // we need to replace all the spaces in these strings with '+'
                {
                    LPTSTR lpTemp = lp[i];
                    // need to knock out CRLFs
                    while(lpTemp && *lpTemp)
                    {
                        if(*lpTemp == '\r')
                        {
                            *lpTemp = '\0';
                            break;
                        }
                        lpTemp = CharNext(lpTemp);
                    }
                    lpTemp = lp[i];

                    while(lpTemp && *lpTemp)
                    {
                        if(IsSpace(lpTemp))
                        {
                            LPTSTR lpTemp2 = lpTemp;
                            lpTemp = CharNext(lpTemp);
                            *lpTemp2 = '+';
                            if(lpTemp != lpTemp2+1)
                                lstrcpy(lpTemp2+1, lpTemp);
                            lpTemp = lpTemp2;
                        }
                        lpTemp = CharNext(lpTemp);
                    }
                }
            }
            else
                lp[i] = szEmpty;
        }
        // <TBD> - Determine if this address is a US address or not ..
        if( !lstrlen(lp[prCountry]) || //no country - assume it's US
            !lstrcmpi(lp[prCountry], TEXT("US")) ||
            !lstrcmpi(lp[prCountry], TEXT("U.S.")) ||
            !lstrcmpi(lp[prCountry], TEXT("USA")) ||
            !lstrcmpi(lp[prCountry], TEXT("U.S.A.")) ||
            !lstrcmpi(lp[prCountry], TEXT("America")) ||
            !lstrcmpi(lp[prCountry], TEXT("United States")) ||
            !lstrcmpi(lp[prCountry], TEXT("United States of America")) )
        {
            bUSAddress = TRUE;
        }
        if( (bUSAddress && (!lstrlen(lp[prStreet]) || ulCount<2)) ||
            (!bUSAddress && !lstrlen(lp[prCity]) && !lstrlen(lp[prCountry])) )
        {
            ShowMessageBox(hDlg, idsInsufficientAddressInfo, MB_ICONINFORMATION);
        }
        else
        {
            TCHAR szText[MAX_BUF_STR] = {0};
            TCHAR *pchWorldAddr = NULL;
            LoadString(hinstMapiX, bUSAddress ? idsExpediaURL : idsExpediaIntlURL, szText, MAX_BUF_STR);

            if(!bUSAddress )
            {
                //IE6 we need to change a little string for World map in Expedia
                if(pchWorldAddr = LocalAlloc(LMEM_ZEROINIT, (lstrlen(lp[prStreet]) + lstrlen(lp[prCity]) + 
                    lstrlen(lp[prState]) + lstrlen(lp[prCountry]) + 20)*sizeof(TCHAR))) // we need add also space and  commas
                {
                    BOOL fAddComma = FALSE;

/*                    if(lstrlen(lp[prStreet]))
                    {
                        lstrcat(pchWorldAddr, lp[prStreet]);
                        fAddComma = TRUE;
                    }*/

                    if(lstrlen(lp[prCity]))
                    {
                        if(fAddComma)
                            lstrcat(pchWorldAddr, TEXT(", "));
                        lstrcat(pchWorldAddr, lp[prCity]);
                        fAddComma = TRUE;

                    }

                    if(lstrlen(lp[prState]))
                    {
                        if(fAddComma)
                            lstrcat(pchWorldAddr, TEXT(", "));
                        lstrcat(pchWorldAddr, lp[prState]);
                        fAddComma = TRUE;

                    }
                    if(lstrlen(lp[prCountry]))
                    {
                        if(fAddComma)
                            lstrcat(pchWorldAddr, TEXT(", "));
                        lstrcat(pchWorldAddr, lp[prCountry]);
                        fAddComma = TRUE;

                    }

                }
                lp[prCountry] = pchWorldAddr;
            }

            if (  FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
		                	      FORMAT_MESSAGE_ALLOCATE_BUFFER |
			                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                  szText,
			                      0,                    // stringid
			                      0,                    // dwLanguageId
			                      (LPTSTR)&lpURL,     // output buffer
			                      0,               
			                      (va_list *)lp))
            {
                //LPTSTR lpProperURL = NULL;
                //DWORD dw = lstrlen(lpURL)*3+1;
                DebugTrace( TEXT("Expedia URL: %s\n"),lpURL);
                //Need to canoncolize this URL just in case it has unsafe characters in it
                /*
                if(lpProperURL = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*dw)) // 3times bigger should be big enough
                {
                    if(!InternetCanonicalizeUrlA(lpURL, lpProperURL, &dw, 0))
                        DebugTrace( TEXT("Error converting URL:%d\n"),GetLastError());
                    if(lpProperURL && lstrlen(lpProperURL))
                    {
                        LocalFree(lpURL);
                        lpURL = lpProperURL;
                    }
                }
                */
                ShowURL(hDlg, 0, lpURL);
                LocalFreeAndNull(&lpURL);
                if(pchWorldAddr)
                    LocalFreeAndNull(&pchWorldAddr);
            }
        }
        MAPIFreeBuffer(lpProps);
    }
}   



/*//$$***********************************************************************
*    FUNCTION: fnRubyProc
*
-   WinProc for the RUBY dialog that lets the user enter the ruby first and last name
*
****************************************************************************/
enum 
{
    sFirst=0,
    sLast,
    sYomiFirst,
    sYomiLast,
    sMax
};

int rgIdPropPersonalRuby[] = 
{
    IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, 
    IDC_DETAILS_PERSONAL_EDIT_LASTNAME, 
    IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, 
    IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, 
};

int rgIdPropRubyDlg[] = 
{
    IDC_RUBY_EDIT_FIRSTNAME,
    IDC_RUBY_EDIT_LASTNAME,
    IDC_RUBY_EDIT_YOMIFIRSTNAME,
    IDC_RUBY_EDIT_YOMILASTNAME,
};


INT_PTR CALLBACK fnRubyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPTSTR * sz = (LPTSTR *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_YOMIFIRSTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_YOMILASTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_FIRSTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_LASTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            {
                int i = 0;
                for(i=0;i<sMax;i++)
                {
                    if(lstrlen(sz[i]))
                        SetDlgItemText(hDlg, rgIdPropRubyDlg[i], sz[i]);
                }
            }
        }
        return TRUE;
        break;

/***
    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;
/****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            {
                LPTSTR * sz = (LPTSTR *) GetWindowLongPtr(hDlg, DWLP_USER);
                int i =0;
                for(i=0;i<sMax;i++)
                {
                    if(!GetDlgItemText(hDlg, rgIdPropRubyDlg[i], sz[i], EDIT_LEN))
                        lstrcpy(sz[i], szEmpty);
                }
            }
            EndDialog(hDlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return FALSE;
}


/*
-   ShoWRubyNameEntryDlg
-
*   Let's the user enter Ruby First and Ruby Last names
*
*/
void ShowRubyNameEntryDlg(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    LPTSTR sz[sMax];
    int i=0;
    for(i=0;i<sMax;i++) //Read the data off the person tab
    {
        if(sz[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*EDIT_LEN))
        {
            lstrcpy(sz[i], szEmpty);
            GetDlgItemText(hDlg, rgIdPropPersonalRuby[i], sz[i], EDIT_LEN);
        }
    }

    if(DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_RUBY),
                    hDlg, fnRubyProc, (LPARAM)sz))
    {
        for(i=0;i<sMax;i++) // put it back in the personal tab
        {
            SetDlgItemText(hDlg, rgIdPropPersonalRuby[i], sz[i]);
            LocalFree(sz[i]);
        }
        lpPai->bSomethingChanged = TRUE;
    }
}




/*//$$***************************************************************************
*    FUNCTION: FillFamilyDetailsUI(HWND)
*
*    PURPOSE:  Fills in the data in the family tab
*
****************************************************************************/
BOOL FillFamilyDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0, k =0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                        (LPSPropTagArray)&ptaUIDetlsPropsFamily, 
                                        MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[propFamily] = TRUE;

    idPropCount = idPropFamilyCount;
    lpidProp = idPropFamily;

    // A very inefficient and lazy way of filling the UI
    for(i=0;i<idPropCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
            {
                switch(lpidProp[i].ulPropTag)
                {
                case PR_GENDER:
                    SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_SETCURSEL,
                            (WPARAM) lpPropArray[j].Value.i, 0);
                    break;
                case PR_BIRTHDAY:
                case PR_WEDDING_ANNIVERSARY:
                    {
                        SYSTEMTIME st = {0};
                        FileTimeToSystemTime((FILETIME *) (&lpPropArray[j].Value.ft), &st);
                        SendDlgItemMessage(hDlg, lpidProp[i].idCtl,DTM_SETSYSTEMTIME, 
                                            (WPARAM) GDT_VALID, (LPARAM) &st);
                    }
                    break;
                case PR_CHILDRENS_NAMES:
                    for(k=0;k<lpPropArray[j].Value.MVSZ.cValues;k++)
                        AddLVNewChild(hDlg, lpPropArray[j].Value.MVSZ.LPPSZ[k]);
                    break;
                default:
                    SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
                }
            }
        }
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*
-   AddLVNewChild
-
-   Adds a new child to the list of children
-   Basically we will add an item called  TEXT("New Child") and then 
-   force an in-place edit on that item
-
-   It would be nice to have some image associated with this ListView, eg a Boy/Girl image
-   but that means having to cache seperate Boy/Girl data which would be a pain ..
-   
*
*/
void AddLVNewChild(HWND hDlg, LPTSTR lpName)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
    LV_ITEM lvi = {0};
    TCHAR szBuf[MAX_PATH];
    ULONG nLen;
    int nPos;
    LoadString(hinstMapiX, idsNewChild, szBuf, CharSizeOf(szBuf));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.pszText = lpName ? lpName : szBuf;
    lvi.cchTextMax = MAX_PATH;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;
    lvi.iImage = imgChild+(lvi.iItem%3);//just add a little color by using more than 1 different colored image
    nPos = ListView_InsertItem(hWndLV, &lvi);
    LVSelectItem(hWndLV, nPos);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_BUTTON_EDITCHILD), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD), TRUE);
    return;
}



/*//$$***********************************************************************
*    FUNCTION: fnFamilyProc
*
*    PURPOSE:  Callback function for handling the Family property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnFamilyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propFamily);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_SELCHANGE: //gender combo
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            lpPAI->ulFlags |= DETAILS_GenderChanged;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_FAMILY_BUTTON_ADDCHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            AddLVNewChild(hDlg, NULL);
            SendMessage(hDlg, WM_COMMAND, (WPARAM)IDC_DETAILS_FAMILY_BUTTON_EDITCHILD, 0);
            break;
        case IDC_DETAILS_FAMILY_BUTTON_EDITCHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
                SetFocus(hWndLV);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    HWND hWndEditLabel = ListView_EditLabel(hWndLV, index);
                    //SendMessage(hWndEditLabel, EM_LIMITTEXT, MAX_PATH, 0);
                }
            }
            break;
        case IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    ListView_DeleteItem(hWndLV, index);
                    if(index >= ListView_GetItemCount(hWndLV))
                        index--;
                    LVSelectItem(hWndLV, index);
                }
            }
            break;
// [PaulHi] 12/4/98  Raid #58940
// This fix causes the system to go into an infinite message loop (stack overflow
// crash on intenational Win9X machines) with DBCS.  The fnPersonalProc property 
// sheet also doesn't handle this WM_COMMAND message, probably for the same reason.
// ESC still works correctly on this property sheet.
#if 0
/*
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
*/
#endif
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case DTN_DATETIMECHANGE: //change in the Month-Date-Time control
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            lpPAI->ulFlags |= DETAILS_DateChanged;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case LVN_BEGINLABELEDITA:
        case LVN_BEGINLABELEDITW:
            lpPAI->ulFlags |= DETAILS_EditingChild;
            break;

        case LVN_ENDLABELEDITA:
        case LVN_ENDLABELEDITW:
            {
                // After the user finishes editing the children's name, 
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                // if this is Win9x .. we'llget an LV_ITEMA here .. else a LV_ITEMW
                LPWSTR lpW = NULL;
                LPSTR lpA = NULL;
                if(!g_bRunningOnNT)
                {
                    lpA = (LPSTR)lvi.pszText;
                    lpW = ConvertAtoW(lpA);
                    lvi.pszText = lpW;
                }
                lpPAI->ulFlags &= ~DETAILS_EditingChild;
                if ((lvi.iItem >= 0) && lvi.pszText && (lstrlen(lvi.pszText)))
                {
                    ListView_SetItem(hWndLV, &lvi);
                }
                LocalFreeAndNull(&lpW);
                if(!g_bRunningOnNT)
                    ((LV_DISPINFO FAR *) lParam)->item.pszText = (LPWSTR)lpA; // reset it as we found it
            }
            break;

        case PSN_SETACTIVE:     //initialize
            FillFamilyDetailsUI(hDlg, lpPAI, propFamily, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propFamily);
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN));
            lpPAI->ulFlags &= ~DETAILS_GenderChanged;
            lpPAI->ulFlags &= ~DETAILS_DateChanged;
            lpPAI->ulFlags &= ~DETAILS_ChildrenChanged;
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingChild) 
            {
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN), -1);
                lpPAI->ulFlags &= ~DETAILS_EditingChild;
            }
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;
}


/*
-   CreateDateTimePickerControl
-
*
*  Description: Creates and initializes the control on the specified window. The controls destination
*				size is that of the static rectangle IDC_CONTROL_RECT
*  Parameters: idFrame - a dummy static used in the dialog layout to set a size and position for the new control
*                   The original static is hidden 
*               idControl - the Control ID to assign to the control
*
*               We also need to make sure that the tab order stays sane, 
*  Returns: none 
*/
void CreateDateTimeControl(HWND hDlg, int idFrame, int idControl)
{
	RECT rectControl;
	SIZE sizeControl;
    HWND hWndDP = NULL;
    HWND hWndFrame = GetDlgItem(hDlg,idFrame);
	// Get bounding rectangle of control and convert to client coordinates
	GetWindowRect(hWndFrame,&rectControl);
    MapWindowPoints(NULL, hDlg, (LPPOINT) &rectControl, 2);
	
	sizeControl.cx = rectControl.right-rectControl.left;
	sizeControl.cy = rectControl.bottom-rectControl.top;
    // Do not use ScreenToClient(), use MapWindowPoints for mirroring.
    //	ScreenToClient(hDlg,&pointControl);

	// Create control which starts at pointControl extends to sizeControl
	// >> Start control specific
	hWndDP =  CreateWindowEx(   WS_EX_CLIENTEDGE,
                                DATETIMEPICK_CLASS,
                                NULL,
                                WS_CHILD|WS_VISIBLE|WS_TABSTOP|DTS_SHORTDATEFORMAT|DTS_SHOWNONE,
                                rectControl.left,
                                rectControl.top,
                        		sizeControl.cx,
                                sizeControl.cy,
                                hDlg,
                                (HMENU)IntToPtr(idControl), // control identifier
                                hinstMapiXWAB,
                                NULL);

	// Check if control was created
	if(hWndDP)
	{
        TCHAR szFormat[MAX_PATH];
        SYSTEMTIME st = {0};
        LoadString(hinstMapiX, idsDateTimeFormat, szFormat, CharSizeOf(szFormat));
        SendMessage(hWndDP, DTM_SETFORMAT, 0, (LPARAM)szFormat);
        SendMessage(hWndDP, DTM_SETSYSTEMTIME, (WPARAM) GDT_NONE, (LPARAM) &st);

        SetWindowPos(hWndDP, hWndFrame,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_dl.c ===
/**********************************************************************************
*
*
*   DL.C - contains functions for the DL dialog
*
*
*
*
*
*
*
**********************************************************************************/

#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;
// extern LPPROPERTYSHEET        gpfnPropertySheet;
// extern LP_CREATEPROPERTYSHEETPAGE gpfnCreatePropertySheetPage;

extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;

extern LPTSTR szHTTP;
extern BOOL bIsHttpPrefix(LPTSTR szBuf);
extern void ShowURL(HWND hWnd, int id,LPTSTR lpURL);
extern void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome);
extern void ShowHideMapButton(HWND hWndButton);
extern void SetHTTPPrefix(HWND hDlg, int id);
extern BOOL bIsIE401OrGreater();
extern ChangeLocaleBasedTabOrder(HWND hDlg, int nPropSheet);

static DWORD rgDLHelpIDs[] =
{
    IDC_DISTLIST_EDIT_GROUPNAME,    IDH_WAB_GROUPNAME,
    IDC_DISTLIST_STATIC_GROUPNAME,  IDH_WAB_GROUPNAME,
    IDC_DISTLIST_EDIT_NOTES,        IDH_WAB_NOTES,
    IDC_DISTLIST_STATIC_NOTES,      IDH_WAB_NOTES,
    IDC_DISTLIST_LISTVIEW,          IDH_WAB_GROUP_NAME_LIST,
    IDC_DISTLIST_FRAME_MEMBERS,     IDH_WAB_GROUP_NAME_LIST,
    IDC_DISTLIST_BUTTON_ADD,        IDH_WAB_ADD_GROUP_MEMBERS,
    IDC_DISTLIST_BUTTON_REMOVE,     IDH_WAB_DELETE_GROUP_MEMBERS,
    IDC_DISTLIST_BUTTON_PROPERTIES, IDH_WAB_GROUP_PROPERTIES,
    IDC_DISTLIST_BUTTON_ADDNEW,     IDH_WAB_ADD_NEW_GROUP_CONTACTS,

    IDC_DISTLIST_STATIC_COUNT,      IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_ADD,        IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_ADDNAME,    IDH_WAB_GROUP_NAME,
    IDC_DISTLIST_EDIT_ADDNAME,      IDH_WAB_GROUP_NAME,
    IDC_DISTLIST_STATIC_ADDEMAIL,   IDH_WAB_GROUP_EMAIL,
    IDC_DISTLIST_EDIT_ADDEMAIL,     IDH_WAB_GROUP_EMAIL,
    IDC_DISTLIST_BUTTON_ADDUPDATE,  IDH_WAB_GROUP_UPDATE,
    IDC_DISTLIST_BUTTON_UPDATECANCEL,     IDH_WAB_GROUP_CANCEL_EDIT,
    IDD_DISTLIST_OTHER,             IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_STREET,     IDH_WAB_DETAILS_ADDRESS,
    IDC_DISTLIST_EDIT_ADDRESS,      IDH_WAB_DETAILS_ADDRESS,
    IDC_DISTLIST_STATIC_CITY,       IDH_WAB_DETAILS_CITY,
    IDC_DISTLIST_EDIT_CITY,         IDH_WAB_DETAILS_CITY,
    IDC_DISTLIST_STATIC_STATE,      IDH_WAB_DETAILS_STATE,
    IDC_DISTLIST_EDIT_STATE,        IDH_WAB_DETAILS_STATE,
    IDC_DISTLIST_STATIC_ZIP,        IDH_WAB_DETAILS_ZIP,
    IDC_DISTLIST_EDIT_ZIP,          IDH_WAB_DETAILS_ZIP,
    IDC_DISTLIST_STATIC_COUNTRY,    IDH_WAB_DETAILS_COUNTRY,
    IDC_DISTLIST_EDIT_COUNTRY,      IDH_WAB_DETAILS_COUNTRY,
    IDC_DISTLIST_STATIC_PHONE,      IDH_WAB_DETAILS_PHONE,
    IDC_DISTLIST_EDIT_PHONE,        IDH_WAB_DETAILS_PHONE,
    IDC_DISTLIST_STATIC_FAX,        IDH_WAB_DETAILS_FAX,
    IDC_DISTLIST_EDIT_FAX,          IDH_WAB_DETAILS_FAX,
    IDC_DISTLIST_STATIC_WEB,        IDH_WAB_DETAILS_WEBPAGE,
    IDC_DISTLIST_EDIT_URL,          IDH_WAB_DETAILS_WEBPAGE,
    IDC_DISTLIST_BUTTON_URL,        IDH_WAB_DETAILS_GO,
    IDC_DISTLIST_BUTTON_MAP,        IDH_WAB_BUSINESS_VIEWMAP,
    
    0,0
};


// forward declarations

INT_PTR CALLBACK fnDLProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnDLOtherProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
BOOL FillDLUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai,BOOL * lpbChangesMade);
BOOL GetDLFromUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai , BOOL bSomethingChanged, LPSPropValue * lppPropArray, LPULONG lpulcPropCount);
BOOL SetDLUI(HWND hDlg, int nPropSheet);
void RemoveSelectedDistListItems(HWND hWndLV, LPDL_INFO lpPai);
void AddDLMembers(HWND hwnd, HWND hWndLV, LPDL_INFO lpPai);
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);




/****************************************************************************
*    FUNCTION: CreateDLPropertySheet(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
INT_PTR CreateDLPropertySheet( HWND hwndOwner,
                           LPDL_INFO lpPropArrayInfo)
{
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    ULONG ulTotal = 0;
    HPROPSHEETPAGE * lph = NULL;
    ULONG ulCount = 0;
    int i = 0;
    INT_PTR nRet = 0;

    ulTotal = propDLMax // Predefined ones +
            + lpPropArrayInfo->nPropSheetPages;

    lph = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * ulTotal);
    if(!lph)
        return FALSE;

    // DL
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = hinstMapiX;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISTLIST);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = (DLGPROC) fnDLProc;
    LoadString(hinstMapiX, idsGroupTabName, szBuf, CharSizeOf(szBuf));
    psp.pszTitle = szBuf;
    psp.lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&psp);
    if(lph[ulCount])
        ulCount++;

    // DL "Other"
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = hinstMapiX;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISTLIST_OTHER);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = (DLGPROC) fnDLOtherProc;
    LoadString(hinstMapiX, idsGroupOtherTabName, szBuf, CharSizeOf(szBuf));
    psp.pszTitle = szBuf;
    psp.lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&psp);
    if(lph[ulCount])
        ulCount++;

    // Start page is personal page
    psh.nStartPage = propGroup;

    // Now do the extended props if any
    for(i=0;i<lpPropArrayInfo->nPropSheetPages;i++)
    {
        if(lpPropArrayInfo->lphpages)
        {
            lph[ulCount] = lpPropArrayInfo->lphpages[i];
            ulCount++;
        }
    }

/*** US dialogs get truncated on FE OSes .. we want the comctl to fix the truncation
     but this is only implemented in IE4.01 and beyond .. the problem with this being 
     that wab is specifically compiled with the IE = 0x0300 so we're not pulling in the
     correct flag from the commctrl header .. so we will define the flag here and pray
     that commctrl never changes it ***/
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
/***                                ***/

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW;
    if(bIsIE401OrGreater())
        psh.dwFlags |= PSH_USEPAGELANG;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, CharSizeOf(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = ulCount; // ulProp //sizeof(psp) / sizeof(PROPSHEETPAGE);

    psh.phpage = lph;

    nRet = gpfnPropertySheet(&psh);

    if(lph) 
        LocalFree(lph);

    return nRet;
}


typedef struct _tagIDProp
{
    ULONG ulPropTag;
    int   idCtl;

} ID_PROP;



// Control IDs corresponding to the Personal property sheet

ID_PROP idPropDL[]=
{
    {PR_DISPLAY_NAME,   IDC_DISTLIST_EDIT_GROUPNAME},
};
const ULONG idPropDLCount = 1;

ID_PROP idPropDLOther[]=
{
    {PR_HOME_ADDRESS_STREET,    IDC_DISTLIST_EDIT_ADDRESS},
    {PR_HOME_ADDRESS_CITY,      IDC_DISTLIST_EDIT_CITY},
    {PR_HOME_ADDRESS_POSTAL_CODE,   IDC_DISTLIST_EDIT_ZIP},
    {PR_HOME_ADDRESS_STATE_OR_PROVINCE,   IDC_DISTLIST_EDIT_STATE},
    {PR_HOME_ADDRESS_COUNTRY,   IDC_DISTLIST_EDIT_COUNTRY},
    {PR_HOME_TELEPHONE_NUMBER,  IDC_DISTLIST_EDIT_PHONE},
    {PR_HOME_FAX_NUMBER,        IDC_DISTLIST_EDIT_FAX},
    {PR_PERSONAL_HOME_PAGE,     IDC_DISTLIST_EDIT_URL},
    {PR_COMMENT,                IDC_DISTLIST_EDIT_NOTES},
};
const ULONG idPropDLOtherCount = 9;



/****************************************************************************
*    FUNCTION: SetDLUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
****************************************************************************/
BOOL SetDLUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;
    ID_PROP * lpidProp;
    ULONG idCount;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    //HrInitListView(	hWndLV,LVS_REPORT | LVS_SORTASCENDING,FALSE);

    // Have to make this list view sorted
    if(nPropSheet == propGroup)
    {
        DWORD dwStyle;
        HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
        HrInitListView(	hWndLV,LVS_LIST,FALSE);
        dwStyle = GetWindowLong(hWndLV,GWL_STYLE);
        SetWindowLong(hWndLV,GWL_STYLE,dwStyle | LVS_SORTASCENDING);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        EnableWindow(hWndLV, FALSE);
        lpidProp = idPropDL;
        idCount = idPropDLCount;
    }
    else if(nPropSheet == propGroupOther)
    {
        lpidProp = idPropDLOther;
        idCount = idPropDLOtherCount;
        ShowHideMapButton(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_MAP));
    }


    //Set max input limits on the edit fields
    for(i=0;i<idCount;i++)
        SendMessage(GetDlgItem(hDlg,lpidProp[i].idCtl),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR - 1,0);

    if(nPropSheet == propGroupOther)
    {
        SendMessage(GetDlgItem(hDlg,IDC_DISTLIST_EDIT_NOTES),EM_SETLIMITTEXT,(WPARAM) MAX_BUF_STR - 1,0);
        SetHTTPPrefix(hDlg, IDC_DISTLIST_EDIT_URL);
    }

    return TRUE;
}


/*
-
-   UpdateLVCount - shows a running count of how many members are in the ListView
*
*/
void UpdateLVCount(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
    HWND hWndStat =  GetDlgItem(hDlg, IDC_DISTLIST_STATIC_COUNT);

    int nCount = ListView_GetItemCount(hWndLV);

    if(nCount <= 0)
    {
        ShowWindow(hWndStat, SW_HIDE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        EnableWindow(hWndLV, FALSE);
    }
    else
    {
        TCHAR sz[MAX_PATH];
        TCHAR szStr[MAX_PATH];
        LoadString(hinstMapiX, idsGroupMemberCount, szStr, CharSizeOf(sz));
        wsprintf(sz, szStr, nCount);
        SetWindowText(hWndStat, sz);
        ShowWindow(hWndStat, SW_SHOWNORMAL);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
        EnableWindow(hWndLV, TRUE);
    }
}

/****************************************************************************
*    FUNCTION: FillDLUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillDLUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    
    if(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,  &ulcPropCount, &lpPropArray))
        goto exit;

    if(nPropSheet == propGroup)
    {
        idPropCount = idPropDLCount;
        lpidProp = idPropDL;
    }
    else if(nPropSheet == propGroupOther)
    {
        idPropCount = idPropDLOtherCount;
        lpidProp = idPropDLOther;
    }

    for(i=0;i<idPropCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
                SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
            if( nPropSheet == propGroup &&
                lpidProp[i].idCtl == IDC_DISTLIST_EDIT_GROUPNAME &&
                lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
            {
                SetWindowPropertiesTitle(GetParent(hDlg), lpPropArray[j].Value.LPSZ);
                lpPai->lpszOldName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpPropArray[j].Value.LPSZ)+1));
                if(lpPai->lpszOldName)
                    lstrcpy(lpPai->lpszOldName,lpPropArray[j].Value.LPSZ);
            }
        }

    }

    if(nPropSheet == propGroup)
    {
        HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
        for(j=0;j<ulcPropCount;j++)
        {
            if( lpPropArray[j].ulPropTag == PR_WAB_DL_ENTRIES  ||
                lpPropArray[j].ulPropTag == PR_WAB_DL_ONEOFFS   )
            {
                // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
                for (i = 0; i < lpPropArray[j].Value.MVbin.cValues; i++)
                {
                    AddWABEntryToListView(lpPai->lpIAB,
                                          hWndLV,
                                          lpPropArray[j].Value.MVbin.lpbin[i].cb,
									      (LPENTRYID)lpPropArray[j].Value.MVbin.lpbin[i].lpb,
                                          &(lpPai->lpContentsList));
                }
            }
        }

        // Select the first item ..
        if (ListView_GetItemCount(hWndLV) > 0)
            LVSelectItem(hWndLV, 0);
        UpdateLVCount(hDlg);
    }
    bRet = TRUE;

exit:

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return bRet;
}

extern BOOL bDoesEntryNameAlreadyExist(LPIAB lpIAB, LPTSTR lpsz);

//$$////////////////////////////////////////////////////////////////////////////
//
// bVerifyRequiredData
//
// Checks that all the data we are requesting has been filled up
// Returns CtrlID of the control that needs filling so we can set focus on it
//
/////////////////////////////////////////////////////////////////////////////////
BOOL bVerifyDLRequiredData(HWND hDlg, LPIAB lpIAB, LPTSTR szOldName, int * lpCtlID)
{
    TCHAR szBuf[2 * MAX_UI_STR];

    //
    // First check the required property (which is the GroupName)
    //
    *lpCtlID = 0;
    szBuf[0]='\0'; 
    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_GROUPNAME, szBuf, CharSizeOf(szBuf));
    TrimSpaces(szBuf);
    if(!lstrlen(szBuf))
    {
        ShowMessageBox(GetParent(hDlg), idsPleaseEnterGroupName, MB_ICONEXCLAMATION | MB_OK);
        *lpCtlID = IDC_DISTLIST_EDIT_GROUPNAME;
        return FALSE;
    }
    else
    {
        // Verify that this name does not already exist ..
        
        if( szOldName && lstrlen(szOldName) &&                          // we have an old name and
            lstrcmp(szBuf, szOldName) && !lstrcmpi(szBuf, szOldName))   // it's just a case change don't bother looking
            return TRUE;

        if(szOldName && !lstrcmp(szBuf, szOldName))
            return TRUE;

        if(bDoesEntryNameAlreadyExist(lpIAB, szBuf))
        {
            // the name already exists .. do don't let them use it ..
            ShowMessageBox(GetParent(hDlg), idsEntryAlreadyInWAB, MB_ICONEXCLAMATION | MB_OK);
            *lpCtlID = IDC_DISTLIST_EDIT_GROUPNAME;
            return FALSE;
        }
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
//
//  GetDL from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
//  bShowMsg is true when the user presses OK and we want to force a message
//      otherwise bShowMsg is false
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetDLFromUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai , BOOL bSomethingChanged, LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    BOOL bRet = FALSE;

    TCHAR szBuf[2 * MAX_BUF_STR];
    LPTSTR lpszGroupName = NULL;

    ULONG ulcPropCount = 0,ulIndex=0;
    LPSPropValue lpPropArray = NULL;
    ULONG i =0;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = hrSuccess;
    LPRECIPIENT_INFO lpItem;

    *lppPropArray = NULL;
    *lpulcPropCount = 0;

    if(nPropSheet == propGroup)
    {
        idPropCount = idPropDLCount;
        lpidProp = idPropDL;
    }
    else if(nPropSheet == propGroupOther)
    {
        idPropCount = idPropDLOtherCount;
        lpidProp = idPropDLOther;
    }

    // The idea is to first count all the properties that have non-zero values
    // Then create a lpPropArray of that size and fill in the text from the props ..
    //
    if (!bSomethingChanged)
    {
        // nothing to do, no changes to save
        bRet = TRUE;
        goto out;
    }

    ulNotEmptyCount = 0;
    for(i=0;i<idPropCount;i++)
    {
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
        if( lpidProp[i].idCtl == IDC_DISTLIST_EDIT_URL &&
            (lstrcmpi(szHTTP, szBuf)==0))
             ulNotEmptyCount--;
    }

    if (ulNotEmptyCount == 0)
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    if(nPropSheet == propGroup && lpPai->lpContentsList)
    {
        ulcPropCount++; //For PR_WAB_DL_ENTRIES
        ulcPropCount++; //For PR_WAB_DL_ONEOFFS
    }

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);

    if (sc!=S_OK)
    {
        DebugPrintError(( TEXT("Error allocating memory\n")));
        goto out;
    }


    ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        if( lpidProp[i].idCtl == IDC_DISTLIST_EDIT_URL &&
            (lstrcmpi(szHTTP, szBuf)==0))
             continue;
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));

            if (sc!=S_OK)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                goto out;
            }
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szBuf);
            ulIndex++;
        }
    }

    if(nPropSheet == propGroup  && lpPai->lpContentsList)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        lpPropArray[ulIndex].ulPropTag = PR_WAB_DL_ENTRIES;
        lpPropArray[ulIndex].Value.MVbin.cValues = 0;
        lpPropArray[ulIndex].Value.MVbin.lpbin = NULL;
        lpPropArray[ulIndex+1].ulPropTag = PR_WAB_DL_ONEOFFS;
        lpPropArray[ulIndex+1].Value.MVbin.cValues = 0;
        lpPropArray[ulIndex+1].Value.MVbin.lpbin = NULL;
        // Now add the entry IDs to the DistList
        lpItem = lpPai->lpContentsList;
        while(lpItem)
        {
            BOOL bOneOff = (WAB_ONEOFF == IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, NULL, NULL, NULL, NULL, NULL));
            if(pt_bIsWABOpenExSession)
                bOneOff = FALSE;
            if (HR_FAILED(hr = AddPropToMVPBin( lpPropArray, 
                                                bOneOff ? ulIndex+1 : ulIndex, 
                                                lpItem->lpEntryID, lpItem->cbEntryID,
                                                FALSE)))
            {
                DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
                goto out;
            }
            lpItem = lpItem->lpNext;
        }
        if(lpPropArray[ulIndex].Value.MVbin.cValues == 0)
            lpPropArray[ulIndex].ulPropTag = PR_NULL;
        if(lpPropArray[ulIndex+1].Value.MVbin.cValues == 0)
            lpPropArray[ulIndex+1].ulPropTag = PR_NULL;
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulcPropCount;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    return bRet;
}

/*
-
-  SetCancelOneOffUpdateUI - sets UI for Cancels/resets any update being done in the group
*
*/
void SetCancelOneOffUpdateUI(HWND hDlg, LPPROP_ARRAY_INFO lppai, LPTSTR lpName, LPTSTR lpEmail, BOOL bCancel)
{
    if(bCancel && lppai->ulFlags & DETAILS_EditingOneOff)
    {
        lppai->ulFlags &= ~DETAILS_EditingOneOff;
        lppai->sbDLEditingOneOff.cb = 0;
        LocalFreeAndNull((LPVOID *) (&(lppai->sbDLEditingOneOff.lpb)));
    }
    SetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDNAME, lpName ? lpName : szEmpty);
    SetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL, lpEmail ? lpEmail : szEmpty);
    EnableWindow(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_UPDATECANCEL), !bCancel);
    ShowWindow(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_UPDATECANCEL), bCancel ? SW_HIDE : SW_SHOWNORMAL);
    {
        TCHAR sz[MAX_PATH];
        LoadString(hinstMapiX, bCancel ? idsConfAdd : idsConfUpdate, sz, CharSizeOf(sz));
        SetDlgItemText(hDlg, IDC_DISTLIST_BUTTON_ADDUPDATE, sz);
    }
    SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
}

/*
-   HrShowGroupEntryProperties - If selected entry is a one-off, shows special props on it else
-           cascades call down to regular call
*
*/
HRESULT HrShowGroupEntryProperties(HWND hDlg, HWND hWndLV, LPPROP_ARRAY_INFO lppai)
{
	HRESULT hr = E_FAIL;
	int iItemIndex = ListView_GetSelectedCount(hWndLV);
    LPRECIPIENT_INFO lpItem=NULL;
    BOOL bOneOff = FALSE;

	// Open props if only 1 item is selected
	if (iItemIndex == 1)
	{
		// Get index of selected item
        if((iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED)) != -1)
		{
			lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			if(lpItem && lpItem->cbEntryID != 0)
			{
                if(WAB_ONEOFF == IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID,
                                         NULL, NULL, NULL, NULL, NULL))
                    bOneOff = TRUE;
            }
        }
    }

    if(!bOneOff)
    {
        // use our regular property processing 
        hr = HrShowLVEntryProperties(hWndLV, WAB_ONEOFF_NOADDBUTTON, lppai->lpIAB, NULL);
    }
    else
    {
        LPTSTR  lpName = NULL, lpEmail = NULL, lpAddrType = NULL;
        ULONG   ulMapiDataType = 0;
        
        // Deconstruct the entryid
        IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, &lpName, &lpAddrType, &lpEmail, (LPVOID *)&ulMapiDataType, NULL);

        // Set the flag marking that editing is in progress
        lppai->ulFlags |= DETAILS_EditingOneOff;
        // cache the item being edited so we can find it for updating
        LocalFreeAndNull((LPVOID *) (&((lppai->sbDLEditingOneOff).lpb)));
        SetSBinary(&(lppai->sbDLEditingOneOff), lpItem->cbEntryID, (LPBYTE)lpItem->lpEntryID);

        // [PaulHi] 3/4/99  Raid 73344
        // Check whether one off string data is ANSI or UNICODE
        if (!(ulMapiDataType & MAPI_UNICODE))
        {
            LPTSTR  lptszName = ConvertAtoW((LPSTR)lpName);
            LPTSTR  lptszAddrType = ConvertAtoW((LPSTR)lpAddrType);
            LPTSTR  lptszEmail = ConvertAtoW((LPSTR)lpEmail);

            SetCancelOneOffUpdateUI(hDlg, lppai, lptszName, lptszEmail, FALSE);

            LocalFreeAndNull(&lptszName);
            LocalFreeAndNull(&lptszAddrType);
            LocalFreeAndNull(&lptszEmail);
        }
        else
            SetCancelOneOffUpdateUI(hDlg, lppai, lpName, lpEmail, FALSE);

        SetFocus(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME));
        SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME), EM_SETSEL, 0, -1);
        hr = S_OK;
    }
    return hr;
}

/*
-
-   HrAddUpdateOneOffEntryToGroup - Adds or updates a one-off entry to a group
*       Status of a flag determines what the operation in progress is ..
*
*/
HRESULT HrAddUpdateOneOffEntryToGroup(HWND hDlg, LPPROP_ARRAY_INFO lppai)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_UI_STR];
    TCHAR szEmail[MAX_UI_STR];
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);

    lstrcpy(szName, szEmpty);
    lstrcpy(szEmail, szEmpty);

    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDNAME, szName, CharSizeOf(szName));
    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL, szEmail, CharSizeOf(szEmail));

    if(!lstrlen(szName) && !lstrlen(szEmail))
    {
        ShowMessageBox(hDlg, idsIncompleteOneoffInfo, MB_ICONEXCLAMATION);
        return hr;
    }

    //Check the e-mail address here
    if(lstrlen(szEmail) && !IsInternetAddress(szEmail, NULL))
    {
        if(IDNO == ShowMessageBox(hDlg, idsInvalidInternetAddress, MB_ICONEXCLAMATION | MB_YESNO))
            return hr;
    }

    if(!lstrlen(szName) && lstrlen(szEmail))
        lstrcpy(szName, szEmail);
    //else
    //if(!lstrlen(szEmail) && lstrlen(szName))
    //    lstrcpy(szEmail, szName);

    if(!lstrlen(szEmail))
        lstrcpy(szEmail, szEmpty);

    if(HR_FAILED(hr = CreateWABEntryID(WAB_ONEOFF,
                          (LPVOID)szName, (LPVOID)szSMTP, (LPVOID)szEmail,
                          0, 0, NULL, &cbEID, &lpEID)))
      return hr;
    
    if(lppai->ulFlags & DETAILS_EditingOneOff)
    {
        // This is an edit in progress .. the edit is pretty similar to the normal ADD .. 
        // except we knock out the existing entry from the listview and add the modified entry to it 
        int i=0, nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV,i);
            if( lpItem->cbEntryID == lppai->sbDLEditingOneOff.cb &&
                !memcmp(lpItem->lpEntryID, lppai->sbDLEditingOneOff.lpb, lpItem->cbEntryID) )
            {
                // match
                // Select the item and then call the remove function
                LVSelectItem(hWndLV, i);
                RemoveSelectedDistListItems(hWndLV, lppai);
                break;
            }
        }
    }
        

    AddWABEntryToListView(lppai->lpIAB, hWndLV, cbEID, lpEID, &(lppai->lpContentsList));

    SetCancelOneOffUpdateUI(hDlg, lppai, NULL, NULL, TRUE);

    UpdateLVCount(hDlg);

    if(lpEID)
        MAPIFreeBuffer(lpEID);

    return S_OK;
}

enum _DLProp
{
    dlDisplayName=0,
    dlDLEntries,
    dlDLOneOffs,
    dlMax
};

//$$//////////////////////////////////////////////////////////////////////////////
//
// bUpdateOldPropTagArray
//
// For each prop sheet that is accessed, we will update the list of old prop tags
// for that sheet so that the old props can be knocked out of existing mailuser objects
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bUpdateOldDLPropTagArray(LPPROP_ARRAY_INFO lpPai, int nIndex)
{
    LPSPropTagArray lpta = NULL;

    SizedSPropTagArray(3, ptaUIDetlsDL)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES,
            PR_WAB_DL_ONEOFFS,
        }
    };

    SizedSPropTagArray(9, ptaUIDetlsDLOther)=
    {
        9,
        {
            PR_HOME_ADDRESS_STREET,
            PR_HOME_ADDRESS_CITY,
            PR_HOME_ADDRESS_POSTAL_CODE,
            PR_HOME_ADDRESS_STATE_OR_PROVINCE,
            PR_HOME_ADDRESS_COUNTRY,
            PR_HOME_TELEPHONE_NUMBER,
            PR_HOME_FAX_NUMBER,
            PR_PERSONAL_HOME_PAGE,
            PR_COMMENT,
        }
    };

    switch(nIndex)
    {
    case propGroup:
        lpta = (LPSPropTagArray) &ptaUIDetlsDL;
        break;
    case propGroupOther:
        lpta = (LPSPropTagArray) &ptaUIDetlsDLOther;
        break;
    }

    if(!lpta)
        return TRUE;

    if(lpPai->lpPropObj)
    {
        // Knock out these old props from the PropObject
        if( (lpPai->lpPropObj)->lpVtbl->DeleteProps( (lpPai->lpPropObj), lpta, NULL))
            return FALSE;
    }

    return TRUE;
}

//$$/////////////////////////////////////////////////////////////////////////
//
// bUpdatePropSheetData
//
// Every time the user switches pages, we update the globally accessible data
// The sheet will get PSN_KILLACTIVE when switching pages and PSN_APPLY when ok
// is pressed. A little bit of duplicated effort in the latter case but thats ok
//
/////////////////////////////////////////////////////////////////////////////
BOOL bUpdatePropSheetData(HWND hDlg, LPDL_INFO lpPai, int nPropSheet)
{
    BOOL bRet = TRUE;
    ULONG cValues = 0;
    LPSPropValue rgPropVals = NULL;

    // update old props to knock out
    //
    if (lpPai->ulOperationType != SHOW_ONE_OFF)
    {
        bUpdateOldDLPropTagArray(lpPai, nPropSheet);

        lpPai->bSomethingChanged = ChangedExtDisplayInfo(lpPai, lpPai->bSomethingChanged);

        if(lpPai->bSomethingChanged)
        {
            bRet = GetDLFromUI(hDlg, nPropSheet, lpPai, lpPai->bSomethingChanged, &rgPropVals, &cValues );

            if(cValues && rgPropVals)
                lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, cValues, rgPropVals, NULL);
        }
    }    

    if(rgPropVals)
        MAPIFreeBuffer(rgPropVals);
    return bRet;
}


#define lpPAI ((LPDL_INFO) pps->lParam)
#define lpbSomethingChanged (&(lpPAI->bSomethingChanged))


void UpdateAddButton(HWND hDlg)
{
    BOOL    fEnable = TRUE;
    WPARAM  wpDefaultID = IDC_DISTLIST_BUTTON_ADDUPDATE;

    if (0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME)) &&
        0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL)))
    {
        fEnable = FALSE;
        wpDefaultID = IDOK;
    }

    EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_ADDUPDATE), fEnable);
    SendMessage(hDlg, DM_SETDEFID, wpDefaultID, 0);
}


/*//$$***********************************************************************
*    FUNCTION: fnHomeProc
*
*    PURPOSE:  Callback function for handling the HOME property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnDLProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDLUI(hDlg, propGroup);
        (*lpbSomethingChanged) = FALSE;

        // Show Details if we need to ...
        if (    (lpPAI->ulOperationType == SHOW_DETAILS) ||
                (lpPAI->ulOperationType == SHOW_ONE_OFF)    )
        {
            FillDLUI(hDlg, propGroup, lpPAI, lpbSomethingChanged);
        }

        UpdateAddButton(hDlg);
        return TRUE;

    default:
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
		break;

	case WM_CONTEXTMENU:
        {
            int id = GetDlgCtrlID((HWND)wParam);
            switch(id)
            {
            case IDC_DISTLIST_LISTVIEW:
    			ShowLVContextMenu(lvDialogABTo,(HWND)wParam, NULL, lParam, NULL,lpPAI->lpIAB, NULL);
                break;
            default:
                WABWinHelp((HWND) wParam,
                        g_szWABHelpFileName,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID) rgDLHelpIDs );
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(LOWORD(wParam) == IDC_DISTLIST_EDIT_ADDNAME || LOWORD(wParam) == IDC_DISTLIST_EDIT_ADDEMAIL)
            {
                UpdateAddButton(hDlg);
                return 0;
                break;
            }
            else if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            switch(LOWORD(wParam))
            { //update title as necessary
            case IDC_DISTLIST_EDIT_GROUPNAME:
                {
                    TCHAR szBuf[MAX_UI_STR];
                    GetWindowText((HWND) lParam,szBuf,CharSizeOf(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                }
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam)) //check the notification code
        {
        default:
            return ProcessActionCommands((LPIAB) lpPAI->lpIAB, 
                                        GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), 
                                        hDlg, message, wParam, lParam);
            break;

        case IDC_DISTLIST_BUTTON_UPDATECANCEL:
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            break;

        case IDC_DISTLIST_BUTTON_ADDUPDATE:
            HrAddUpdateOneOffEntryToGroup(hDlg, lpPAI);
            break;

        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDM_LVCONTEXT_COPY:
            HrCopyItemDataToClipboard(hDlg, lpPAI->lpIAB, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW));
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_DISTLIST_BUTTON_PROPERTIES:
            HrShowGroupEntryProperties(hDlg, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), lpPAI);
            break;

        case IDM_LVCONTEXT_DELETE:
        case IDC_DISTLIST_BUTTON_REMOVE:
            RemoveSelectedDistListItems( GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW),lpPAI);
            UpdateLVCount(hDlg);
            break;

        case IDC_DISTLIST_BUTTON_ADD:
            AddDLMembers(hDlg, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), lpPAI);
            UpdateLVCount(hDlg);
            break;

        case IDC_DISTLIST_BUTTON_ADDNEW:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
                AddNewObjectToListViewEx( lpPAI->lpIAB, hWndLV, NULL, NULL,
                                        NULL,
                                        MAPI_MAILUSER,
                                        NULL, &(lpPAI->lpContentsList), NULL, NULL, NULL);
                UpdateLVCount(hDlg);
            }
            break;
        }
        break;



    case WM_NOTIFY:
#ifdef WIN16 // Enable context menu for WIN16
        if((int) wParam == IDC_DISTLIST_LISTVIEW && ((NMHDR FAR *)lParam)->code == NM_RCLICK)
        {
            POINT pt;

            GetCursorPos(&pt);
    	    ShowLVContextMenu(lvDialogABTo,((NMHDR FAR *)lParam)->hwndFrom, NULL, MAKELPARAM(pt.x, pt.y), NULL,lpPAI->lpIAB, NULL);
    	}
#endif // WIN16
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropSheetData(hDlg, lpPAI, propGroup);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }

                if(!bVerifyDLRequiredData(hDlg, (LPIAB)lpPAI->lpIAB, lpPAI->lpszOldName, &CtlID))
                {
                    if (CtlID != 0) SetFocus(GetDlgItem(hDlg,CtlID));
                    //something failed ... abort this OK ... ie dont let them close
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                bUpdatePropSheetData(hDlg, lpPAI, propGroup);
            }
            lpPAI->nRetVal = DETAILS_OK;
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            ClearListView(GetDlgItem(hDlg,IDC_DISTLIST_LISTVIEW),
                          &(lpPAI->lpContentsList));
            break;

        case PSN_RESET:         //cancel
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            lpPAI->nRetVal = DETAILS_CANCEL;
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            ClearListView(GetDlgItem(hDlg,IDC_DISTLIST_LISTVIEW),
                          &(lpPAI->lpContentsList));
            break;

	    case LVN_KEYDOWN:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                {
                case VK_DELETE:
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_DISTLIST_BUTTON_REMOVE, 0);
                    return 0;
                    break;
                }
                break;
            }
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                SendMessage(hDlg, WM_COMMAND, IDC_DISTLIST_BUTTON_PROPERTIES,0);
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                break;
	        }
            break;



        }

        return TRUE;
    }

    return bRet;

}



//$$///////////////////////////////////////////////////////////////////
//
// Removes all the items on the list view which are selected ...
//
//
//////////////////////////////////////////////////////////////////////
void RemoveSelectedDistListItems(HWND hWndLV, LPDL_INFO lpPai)
{
    int iItemIndex = ListView_GetNextItem(hWndLV, -1 , LVNI_SELECTED);
    int iLastItem;

    while(iItemIndex != -1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;

        if (lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if (lpPai->lpContentsList == lpItem)
                lpPai->lpContentsList = lpItem->lpNext;

            if (lpItem)
                FreeRecipItem(&lpItem);
        }

        ListView_DeleteItem(hWndLV, iItemIndex);

        iLastItem = iItemIndex;
        iItemIndex = ListView_GetNextItem(hWndLV, -1 , LVNI_SELECTED);
    }

    // Select the first item ..
    if (ListView_GetItemCount(hWndLV) <= 0)
    {
        EnableWindow(GetDlgItem(GetParent(hWndLV),IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
        EnableWindow(GetDlgItem(GetParent(hWndLV),IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        EnableWindow(hWndLV, FALSE);
    }
    else
    {
        if(iLastItem > 0)
            iLastItem--;

        LVSelectItem(hWndLV, iLastItem);
    }

    return;

};


/***************************************************************************
//$$
    Name      : HrCreateAdrListFromLV

    Purpose   : Creates an AdrList from a List Views contents

    Parameters: lpIAB = adrbook
                hWndLV = hWnd of List View
                lpCOntentsList = ContentsList corresponding to the LV
                lppAdrList - returned AdrList ...

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrCreateAdrListFromLV(LPADRBOOK lpAdrBook,
                              HWND hWndLV,
                              LPADRLIST * lppAdrList)
{
    HRESULT hr = E_FAIL;
    ULONG nIndex = 0;
    LPADRLIST lpAdrList = NULL;
    SCODE sc = S_OK;
    int nEntryCount=0;
    LPRECIPIENT_INFO lpItem = NULL;
    int i = 0;



    if(!lppAdrList)
        goto out;
    else
        *lppAdrList = NULL;

    nEntryCount = ListView_GetItemCount(hWndLV);

    if (nEntryCount <= 0)
    {
        hr = S_OK;
        goto out;
    }

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + nEntryCount * sizeof(ADRENTRY),
                            &lpAdrList);

    if(FAILED(sc))
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpAdrList->cEntries = (ULONG) nEntryCount;

    nIndex = 0;

    for(i=nEntryCount;i>=0;i--)
    {
		LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, i);

        // Get item lParam LPRECIPIENT_INFO structure
        if (lpItem)
		{
            LPSPropValue rgProps = NULL;
            LPSPropValue lpPropArrayNew = NULL;
            ULONG cValues = 0;
            ULONG cValuesNew = 0;

            if (lpItem->cbEntryID != 0)
            {
                //resolved entry
                hr = HrGetPropArray(lpAdrBook,
                                    (LPSPropTagArray) &ptaResolveDefaults,
                                    lpItem->cbEntryID,
                                    lpItem->lpEntryID,
                                    MAPI_UNICODE,
                                    &cValues,
                                    &rgProps);

                if (!HR_FAILED(hr))
                {
                    SPropValue Prop = {0};
                    Prop.ulPropTag = PR_RECIPIENT_TYPE;
                    Prop.Value.l = MAPI_TO;

                    sc = ScMergePropValues( 1,
                                            &Prop,
                                            cValues,
                                            rgProps,
                                            &cValuesNew,
                                            &lpPropArrayNew);
                    if (sc != S_OK)
                    {
                        // oops this failed
                        if (lpPropArrayNew)
                            MAPIFreeBuffer(lpPropArrayNew);
                    }

                    //free rgProps
                    if (rgProps)
                        MAPIFreeBuffer(rgProps);

                    if(cValuesNew && lpPropArrayNew)
                    {
                        lpAdrList->aEntries[nIndex].cValues = cValuesNew;
                        lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                        nIndex++;
                    }
                }
                else
                {
                    if(cValues && rgProps)
                        MAPIFreeBuffer(rgProps);
                } // if(!HR_F...
            } //if(lpItem->cbE...
        }//if(lpItem...
    } // for i...

    *lppAdrList = lpAdrList;

    hr = S_OK;

out:

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////
//
// Scans an Adrlist for dupes - only scans the first nUpto entries since
// whenever we start adding an entry, we will only check vs its peers
//
// Returns TRUE if Dupe found
//      FALSE if no Dupe found
////////////////////////////////////////////////////////////////////////////
BOOL CheckForDupes( LPADRLIST lpAdrList,
                    int nUpto,
                    LPSBinary lpsbEntryID)
{
    BOOL bDupeFound = FALSE;

    int i;

    for(i=0;i<nUpto;i++)
    {
        LPSBinary lpsb = FindAdrEntryID(lpAdrList, i);
        if (lpsb)
        {
            if(lpsb->cb == lpsbEntryID->cb)
            {
                if(!memcmp(lpsb->lpb, lpsbEntryID->lpb, lpsb->cb))
                {
                    bDupeFound = TRUE;
                    break;
                }
                else if (lpsb->cb == SIZEOF_WAB_ENTRYID)
                {
                    // sometimes we dont find the match if we just replaced an entryid
                    // case to DWORDS and compare
                    DWORD dw1 = 0;
                    DWORD dw2 = 0;
                    CopyMemory(&dw1, lpsb->lpb, SIZEOF_WAB_ENTRYID);
                    CopyMemory(&dw2, lpsbEntryID->lpb, SIZEOF_WAB_ENTRYID);
                    if(dw1 == dw2)
                    {
                        bDupeFound = TRUE;
                        break;
                    }
                }

            }
        }
    }

    return bDupeFound;
}

/***************************************************************************

    Name      : AddDLMembers

    Purpose   : Shows Select Members dialog and adds selections to ListView

    Parameters: hWnd = hWndParent
                hWndLV hWnd of List View
                lpPai = DistList Info

    Returns   : void

    Comment   :

***************************************************************************/
void AddDLMembers(HWND hwnd, HWND hWndLV, LPDL_INFO lpPai)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    ADRPARM AdrParms = {0};
    HRESULT hResult = hrSuccess;
    LPADRLIST lpAdrList = NULL;
    ULONG i = 0;
    LPSBinary lpsbEntryID;
    LPADRBOOK lpAdrBook = lpPai->lpIAB;
    TCHAR szCaption[MAX_UI_STR];
    TCHAR szWellTitle[MAX_DISPLAY_NAME_LENGTH];
    TCHAR szMemberTitle[MAX_DISPLAY_NAME_LENGTH];
    LPTSTR lpszDT[1];
    HCURSOR hOldCur = NULL;

    LoadString(hinstMapiX, idsGroupAddCaption, szCaption, CharSizeOf(szCaption));
    LoadString(hinstMapiX, idsGroupAddWellButton, szWellTitle, CharSizeOf(szWellTitle));
    LoadString(hinstMapiX, idsGroupDestWellsTitle, szMemberTitle, CharSizeOf(szMemberTitle));

    // TBe - this is temp
    AdrParms.ulFlags = DIALOG_MODAL | MAPI_UNICODE;
    AdrParms.lpszCaption = szCaption;
    AdrParms.cDestFields = 1;
    AdrParms.lpszDestWellsTitle = szMemberTitle;
    lpszDT[0]=szWellTitle;
    AdrParms.lppszDestTitles = lpszDT;

    hResult = HrCreateAdrListFromLV(lpAdrBook,
                                    hWndLV,
                                    &lpAdrList);

    if(HR_FAILED(hResult))
    {
        // no need to fail here .. keep going
        lpAdrList = NULL;
    }

    hResult = lpAdrBook->lpVtbl->Address(lpAdrBook,
                                        (PULONG_PTR)&hwnd,
                                        &AdrParms,
                                        &lpAdrList);

    if (! hResult && lpAdrList)
    {
        BOOL bFirstNonWABEntry = FALSE;

        pt_bDisableParent = TRUE;

        hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        // Clear out the list view ...
        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        ClearListView(hWndLV, &(lpPai->lpContentsList));

        for (i = 0; i < lpAdrList->cEntries; i++)
        {
            if (lpsbEntryID = FindAdrEntryID(lpAdrList, i))
            {
                if(!CheckForDupes(lpAdrList, i, lpsbEntryID))
                {
                    ULONG cbEID = lpsbEntryID->cb;
                    LPENTRYID lpEID = (LPENTRYID)lpsbEntryID->lpb;
                    ULONG cbNewEID = 0;
                    LPENTRYID lpNewEID = NULL;

                    // if we have picked any entries from an LDAP server, we need
                    // to save these entries to the WAB before we can add them to this group.
                    if(WAB_LDAP_MAILUSER == IsWABEntryID(cbEID,
                                                         lpEID,
                                                         NULL,NULL,NULL, NULL, NULL))
                    {
                        HRESULT hr = S_OK;

                        // Add this entry to the WAB
                        if(!bFirstNonWABEntry)
                        {
                            bFirstNonWABEntry = TRUE;
                            ShowMessageBox(hwnd, idsNowAddingToWAB, MB_OK | MB_ICONINFORMATION);
                        }

                        hr = HrEntryAddToWAB(lpAdrBook,
                                            hwnd,
                                            cbEID,
                                            lpEID,
                                            &cbNewEID,
                                            &lpNewEID);

                        if(HR_FAILED(hr) || (!cbNewEID && !lpNewEID))
                        {
                            continue;
                        }

                        lpEID = lpNewEID;
                        cbEID = cbNewEID;

                        // if this newly added entry just replaced something already in the group,
                        // just go ahead and continue without changing anything else ...
                        {
                            SBinary SB = {0};
                            SB.cb = cbEID;
                            SB.lpb = (LPBYTE) lpEID;
                            if(CheckForDupes(lpAdrList, lpAdrList->cEntries, &SB))
                            {
                                continue;
                            }
                        }
                    }

                    if (CheckForCycle(  lpAdrBook,
                                        lpEID,
                                        cbEID,
                                        lpPai->lpEntryID,
                                        lpPai->cbEntryID))
                    {
                        DebugTrace( TEXT("DLENTRY_SaveChanges found cycle\n"));
                        {
                            LPTSTR lpszGroup=NULL;
                            ULONG k;
                            for(k=0;k<lpAdrList->aEntries[i].cValues;k++)
                            {
                                if (lpAdrList->aEntries[i].rgPropVals[k].ulPropTag == PR_DISPLAY_NAME)
                                {
                                    lpszGroup = lpAdrList->aEntries[i].rgPropVals[k].Value.LPSZ;
                                    break;
                                }
                            }
                            if(lpszGroup)
                            {
                                // TEXT("Could not add group %s to this group because group %s already contains this Group.")
                                ShowMessageBoxParam(hwnd, idsCouldNotAddGroupToGroup, MB_ICONERROR, lpszGroup);
                            }
                        }

                        if(lpNewEID)
                            MAPIFreeBuffer(lpNewEID);

                        continue;
                    }

                    AddWABEntryToListView(lpAdrBook,
                                          hWndLV,
                                          cbEID,
									      lpEID,
                                          &(lpPai->lpContentsList));

                    if(lpNewEID)
                        MAPIFreeBuffer(lpNewEID);

                    // Since LDAP entries take longer to add to the WAB, we will
                    // update the UI between additions if adding from LDAP so user
                    // knows that something is happening ...
                    if ((ListView_GetItemCount(hWndLV) > 0) &&
                        bFirstNonWABEntry )
                    {
                        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
                        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
                        EnableWindow(hWndLV, TRUE);
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
                    }
                }
            }
        }

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
    }



    if (ListView_GetItemCount(hWndLV) > 0)
    {
        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
        EnableWindow(hWndLV, TRUE);
    }

    UpdateWindow(hWndLV);

    if(lpAdrList)
        FreePadrlist(lpAdrList);

    if(hOldCur)
        SetCursor(hOldCur);

    pt_bDisableParent = FALSE;

    return;

}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}




/*//$$***********************************************************************
*    FUNCTION: fnDLOtherProc
*
*    PURPOSE:  Callback function for handling the OTHER property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnDLOtherProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        ChangeLocaleBasedTabOrder(hDlg, groupOther);
        SetDLUI(hDlg, propGroupOther);
        (*lpbSomethingChanged) = FALSE;

        // Show Details if we need to ...
        if (    (lpPAI->ulOperationType == SHOW_DETAILS) ||
                (lpPAI->ulOperationType == SHOW_ONE_OFF)    )
        {
            FillDLUI(hDlg, propGroupOther, lpPAI, lpbSomethingChanged);
        }
        return TRUE;

    default:
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

	case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDLHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam)) //check the notification code
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_DISTLIST_BUTTON_MAP:
            bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            ShowExpediaMAP(hDlg, lpPAI->lpPropObj, TRUE);
            break;

        case IDC_DISTLIST_BUTTON_URL:
            ShowURL(hDlg, IDC_DISTLIST_EDIT_URL,NULL);
            break;
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }

                bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            }
            lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }
        return TRUE;
    }
    return bRet;
}




/*
-   HrAssociateOneOffGroupMembersWithContacts()
-
*   Takes a group .. opens it up .. looks at all the one-off members
*   in the group, tries to match them up with corresponding entries that
*   have the same PR_DEFAULT_EMAIL address and for the ones that match,
*   removes the one-off entry and adds the entryid of the match to the group
*
*   lpsbGroupEID - EntryID of the Group
*   lpDistList - already open Distribution List object .. you can pass in 
*       either the entryid or the already opened object. If you pass in an 
*       open object, this function will not call SaveChanges on it. SaveChanges
*       is callers responsibility
*/
HRESULT HrAssociateOneOffGroupMembersWithContacts(LPADRBOOK lpAdrBook, 
                                                  LPSBinary lpsbGroupEID,
                                                  LPDISTLIST lpDistList)
{
    HRESULT hr = E_FAIL;

    SizedSPropTagArray(3, ptaDL)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES,
            PR_WAB_DL_ONEOFFS,
        }
    };

    SizedSPropTagArray(1, ptaEmail)= { 1, { PR_EMAIL_ADDRESS } };

    ULONG ulcValues = 0, i,ulCount = 0;
    int j = 0;
    LPSPropValue lpProps = NULL;
    LPDISTLIST lpDL = NULL;
    ULONG ulObjType = 0;
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    BOOL * lpbRemove = NULL;

    if(!lpDistList && (!lpsbGroupEID || !lpsbGroupEID->cb || !lpsbGroupEID->lpb) )
        goto out;

    if(lpDistList)
        lpDL = lpDistList;
    else
    {
        if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                        lpsbGroupEID->cb,    // cbEntryID
                                                        (LPENTRYID)lpsbGroupEID->lpb,    // entryid
                                                        NULL,         // interface
                                                        MAPI_MODIFY,                // ulFlags
                                                        &ulObjType,       // returned object type
                                                        (LPUNKNOWN *)&lpDL)))
        {
            // Failed!  Hmmm.
            DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
            goto out;
        }
        Assert(lpDL);

        if(ulObjType != MAPI_DISTLIST)
            goto out;
    }

    if (HR_FAILED(hr = lpDL->lpVtbl->GetProps(lpDL,(LPSPropTagArray)&ptaDL,
                                                    MAPI_UNICODE, &ulcValues, &lpProps)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto out;
    }

    // Check if this one has the one-offs prop or not
    if( ulcValues < dlMax ||
        lpProps[dlDLOneOffs].ulPropTag != PR_WAB_DL_ONEOFFS  ||
        lpProps[dlDLOneOffs].Value.MVbin.cValues == 0)
        goto out;

    ulCount = lpProps[dlDLOneOffs].Value.MVbin.cValues;
    lpbRemove = LocalAlloc(LMEM_ZEROINIT, sizeof(BOOL)*ulCount);
    if(!lpbRemove)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    for(i=0;i<ulCount;i++)
    {
        LPSBinary lpsb = &(lpProps[dlDLOneOffs].Value.MVbin.lpbin[i]);
        ULONG ulc = 0;
        LPSPropValue lpsp = NULL;
        lpbRemove[i]=FALSE;
        if(!HR_FAILED(hr = HrGetPropArray(lpAdrBook, (LPSPropTagArray)&ptaEmail, lpsb->cb, (LPENTRYID)lpsb->lpb,
                                        MAPI_UNICODE,
                                        &ulc, &lpsp)))
        {
            if(ulc == 1 && lpsp[0].ulPropTag == PR_EMAIL_ADDRESS &&
                lpsp[0].Value.LPSZ && lstrlen(lpsp[0].Value.LPSZ))
            {
                // got an e-mail address .. see if it resolves uniquely or not
                ULONG ulMatch = 0;
                LPSBinary rgsbEntryIDs = NULL;
                if(!HR_FAILED(HrFindFuzzyRecordMatches(lpIAB->lpPropertyStore->hPropertyStore,
                                                        NULL,
                                                        lpsp[0].Value.LPSZ,
                                                        AB_FUZZY_FIND_EMAIL | AB_FUZZY_FAIL_AMBIGUOUS,
                                                        &ulMatch,
                                                        &rgsbEntryIDs)))
                {
                    // Note: there is a problem with the above search is that
                    // ed@hotmail.com will uniquely match ted@hotmail.com since its a 
                    // substring search used
                    //
                    if(ulMatch == 1)
                    {
                        // Single unique match .. use it
                        // Reset this entryid in the original DL_ONEOFF props and
                        // set the found entryid in the DL_ENTRIES prop

                        // For now, mark the one-off as having 0 size .. we will clean this up
                        // after we've gone through this loop once
                        lpbRemove[i] = TRUE;
                        AddPropToMVPBin(lpProps, dlDLEntries, rgsbEntryIDs[0].lpb, rgsbEntryIDs[0].cb, TRUE);
                    }
                    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulMatch, rgsbEntryIDs);
                }
            }
            FreeBufferAndNull(&lpsp);
        }
    }
    // Now we've hopefully gone and changed everything, clean up the original list of oneoffs
    ulCount = lpProps[dlDLOneOffs].Value.MVbin.cValues;
    for(j=ulCount-1;j>=0;j--)
    {
        if(lpbRemove[j] == TRUE)
        {
            LPSBinary lpsb = &(lpProps[dlDLOneOffs].Value.MVbin.lpbin[j]);
            RemovePropFromMVBin(lpProps,dlMax,dlDLOneOffs,lpsb->lpb, lpsb->cb);
        }
    }

    // if we removed all the OneOffs from the entry, then RemovePropFromMVBin just sets
    // the prop tag on the prop to be PR_NULL .. instead we need to physically knock out
    // that prop from the object
    if( lpProps[dlDLOneOffs].Value.MVbin.cValues == 0 ||
        lpProps[dlDLOneOffs].ulPropTag == PR_NULL )
    {
        SizedSPropTagArray(1, tagDLOneOffs) =  { 1, PR_WAB_DL_ONEOFFS };
        lpDL->lpVtbl->DeleteProps(lpDL, (LPSPropTagArray) &tagDLOneOffs, NULL);
    }

    if (HR_FAILED(hr = lpDL->lpVtbl->SetProps(lpDL, ulcValues, lpProps, NULL)))
        goto out;

    if(!lpDistList)
        hr = lpDL->lpVtbl->SaveChanges(lpDL, 0);

out:

    if(lpDL && lpDL != lpDistList)
        lpDL->lpVtbl->Release(lpDL);

    FreeBufferAndNull(&lpProps);
    LocalFreeAndNull(&lpbRemove);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_ext.c ===
/**********************************************************************************
*
*
*   ui_ext.C - contains functions for handling/creating the extension property 
*           sheets to the wab property sheets
*
*   Created - 9/97 - vikramm
*
**********************************************************************************/
#include "_apipch.h"

static const TCHAR szExtDisplayMailUser[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\MailUser");
static const TCHAR szExtDisplayDistList[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\DistList");

DEFINE_GUID(CLSID_DsPropertyPages, 
            0xd45d530,  0x764b, 0x11d0, 0xa1, 0xca, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);

//$$/////////////////////////////////////////////////////////////////////////////
//
// AddPropSheetPageProc
//
// CallBack from the Extension Sheets Prop Sheet creation function
//
/////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK AddPropSheetPageProc( HPROPSHEETPAGE hpage, LPARAM lParam )
{
    LPPROP_ARRAY_INFO lpPropArrayInfo = (LPPROP_ARRAY_INFO) lParam;
    HPROPSHEETPAGE * lphTemp = NULL;
    int i = 0;
    BOOL bNTDSExt = IsEqualGUID(&lpPropArrayInfo->guidExt, &CLSID_DsPropertyPages); //special casing for NTDS extensions
    int nPages = bNTDSExt ? lpPropArrayInfo->nNTDSPropSheetPages : lpPropArrayInfo->nPropSheetPages;
    HPROPSHEETPAGE * lph = bNTDSExt ? lpPropArrayInfo->lphNTDSpages : lpPropArrayInfo->lphpages;

    if(!hpage)
        return FALSE;
    
    // Grow the lpPropArrayInfo->lphpages array
    lphTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * (nPages+1));
    if(!lphTemp)
        return FALSE;

    // really inefficient
    if(lph)
    {
        for(i=0;i<nPages;i++)
        {
            lphTemp[i] = lph[i];
        }
        LocalFree(lph);
    }
    if(bNTDSExt)
    {
        lpPropArrayInfo->lphNTDSpages = lphTemp;
        lpPropArrayInfo->lphNTDSpages[lpPropArrayInfo->nNTDSPropSheetPages] = hpage;
        lpPropArrayInfo->nNTDSPropSheetPages++;
    }
    else
    {
        lpPropArrayInfo->lphpages = lphTemp;
        lpPropArrayInfo->lphpages[lpPropArrayInfo->nPropSheetPages] = hpage;
        lpPropArrayInfo->nPropSheetPages++;
    }

    
    return TRUE;
}
 
//$$////////////////////////////////////////////////////////////////////
//
//  HrGetExtDLLInfo
//
//  Enumerate all the registered DLL names and Function procs from the 
//  registry
//
//  bMailUser - if true, look for mailuser extensions 
//            - if false, look for distlist extensions
////////////////////////////////////////////////////////////////////////
HRESULT HrGetExtDLLInfo(LPEXTDLLINFO * lppList, ULONG * lpulCount, BOOL bMailUser, LPGUID lpguidPSExt)
{

    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    LPTSTR lpReg = NULL;
    LPEXTDLLINFO lpList = NULL;
    ULONG ulCount = 0;

    if(!lppList || !lpulCount)
        goto out;

    *lppList = NULL;
    *lpulCount = 0;

    lpReg = (LPTSTR) (bMailUser ? szExtDisplayMailUser : szExtDisplayDistList);

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    lpReg,
                                    0, KEY_READ,
                                    &hKey))
    {
        goto out;
    }


    {
        TCHAR szGUIDName[MAX_PATH];
        DWORD dwGUIDIndex = 0, dwGUIDSize = CharSizeOf(szGUIDName), dwType = 0;

        *szGUIDName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwGUIDIndex, 
                                            szGUIDName, &dwGUIDSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The values under this entry are all GUIDs
            // Read the GUID string and translate it into a GUID
            //
            GUID guidTmp = {0};
            WCHAR szW[MAX_PATH];
            lstrcpy(szW, szGUIDName);
            if( lstrlen(szW) && !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
            {
                // Some applications may not want to see their property sheet extensions displayed
                // unless they have invoked the WAB. These applications can provide a GUID identifying 
                // them which will be compared to the extension GUIDs. If the GUID has a Data Value of
                // "1" this means it should only be loaded on-demand ..

                // First check the data Value
                TCHAR sz[32];
                DWORD dw = CharSizeOf(sz), dwT = 0;
                if(ERROR_SUCCESS == RegQueryValueEx(hKey, szGUIDName, NULL, &dwT,  (LPBYTE) sz, &dw))
                {
                    if( !lstrcmpi(sz,  TEXT("1"))   // this one wants to be loaded on demand only
                        && memcmp(&guidTmp, lpguidPSExt, sizeof(GUID)) ) //but guid doesnt match
                    {
                        goto endwhile;
                    }
                }
                {
                    LPEXTDLLINFO lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(EXTDLLINFO));
                    if(!lpTemp)
                    {
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(&(lpTemp->guidPropExt), &guidTmp, sizeof(GUID));
                    lpTemp->bMailUser = bMailUser;
                    lpTemp->lpNext = lpList;
                    lpList = lpTemp;
                    ulCount++;
                }
            }
endwhile:
            dwGUIDIndex++;
            *szGUIDName = '\0';
            dwGUIDSize = CharSizeOf(szGUIDName);
        }
    }

    *lppList = lpList;
    *lpulCount = ulCount;
    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    return hr;
}

BOOL fPropExtCoinit = FALSE;

//$$//////////////////////////////////////////////////////////////////////
//
// UninitExtInfo
//
//
//////////////////////////////////////////////////////////////////////////
void UninitExtInfo()
{
    if(fPropExtCoinit)
    {
        CoUninitialize();
        fPropExtCoinit = FALSE;
    }
}

//$$///////////////////////////////////////////////////////////////////
//
// FreePropExtList
//
///////////////////////////////////////////////////////////////////////
void FreePropExtList(LPEXTDLLINFO lpList)
{
    LPEXTDLLINFO lpTemp = lpList;
    while(lpList)
    {
        lpList = lpTemp->lpNext;
        SafeRelease(lpTemp->lpWABExtInit);
        SafeRelease(lpTemp->lpPropSheetExt);
        LocalFree(lpTemp);
        lpTemp = lpList;
    }
}

//$$///////////////////////////////////////////////////////////////////
//
// GetExtDisplayInfo
//
// Gets all the requisite info for the extended property pages
//
// fReadOnly - specifies if all prop sheet controls should be readonly
// fMailUser - true for contact, false for group
//
///////////////////////////////////////////////////////////////////////
HRESULT GetExtDisplayInfo(LPIAB lpIAB,
                          LPPROP_ARRAY_INFO lpPropArrayInfo,
                          BOOL fReadOnly,
                          BOOL bMailUser)
{
    ULONG i=0, nDLLs = 0;
    HRESULT hr = E_FAIL;
    LPEXTDLLINFO lpList = NULL, lpDLL = NULL;

    if(!lpIAB->lpPropExtDllList)
    {
        // There can be seperate registered entries for MailUsers and for DistLists
        // We will read everything and collate it into 1 large list

        LPEXTDLLINFO lpListMU = NULL, lpListDL = NULL;
        ULONG nDllsMU = 0, nDllsDL = 0;
        HRESULT hrMU = S_OK, hrDL = S_OK;

        // Get the list of registered DLL names for MailUsers
        //
        hrMU = HrGetExtDLLInfo(&lpListMU, &nDllsMU, TRUE, &lpIAB->guidPSExt);
        hrDL = HrGetExtDLLInfo(&lpListDL, &nDllsDL, FALSE, &lpIAB->guidPSExt);

        if( (!lpListMU && !lpListDL) || 
            !(nDllsDL + nDllsMU)     ||
            (HR_FAILED(hrMU) && HR_FAILED(hrDL)) )
        {
            hr = E_FAIL;
            goto out;
        }

        if(lpListMU)
        {
            lpIAB->lpPropExtDllList = lpListMU;
            while(lpListMU->lpNext)
                lpListMU = lpListMU->lpNext;
            lpListMU->lpNext = lpListDL;
        }
        else
            lpIAB->lpPropExtDllList = lpListDL;

        lpIAB->nPropExtDLLs = nDllsDL + nDllsMU;
    }

    lpList = lpIAB->lpPropExtDllList;
    nDLLs = lpIAB->nPropExtDLLs;

    lpPropArrayInfo->lpWED = LocalAlloc(LMEM_ZEROINIT, sizeof(WABEXTDISPLAY));
    if(!lpPropArrayInfo->lpWED)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpPropArrayInfo->lpWED->lpWABObject = (LPWABOBJECT) ((LPIAB)lpPropArrayInfo->lpIAB)->lpWABObject;
    lpPropArrayInfo->lpWED->lpAdrBook = lpPropArrayInfo->lpIAB;
    lpPropArrayInfo->lpWED->lpPropObj = lpPropArrayInfo->lpPropObj;
    lpPropArrayInfo->lpWED->fReadOnly = fReadOnly;
    lpPropArrayInfo->lpWED->fDataChanged = FALSE;

    if(lpPropArrayInfo->lpLDAPURL && lstrlen(lpPropArrayInfo->lpLDAPURL))
    {
        lpPropArrayInfo->lpWED->ulFlags |= WAB_DISPLAY_LDAPURL;
        lpPropArrayInfo->lpWED->lpsz = lpPropArrayInfo->lpLDAPURL;
        lpPropArrayInfo->lpWED->ulFlags |= MAPI_UNICODE;
        if(lpPropArrayInfo->bIsNTDSURL)
            lpPropArrayInfo->lpWED->ulFlags |= WAB_DISPLAY_ISNTDS;
    }

    if (CoInitialize(NULL) == S_FALSE) 
    {
        CoUninitialize(); // Already initialized, undo the extra.
    }
    else
        fPropExtCoinit = TRUE;

    lpDLL = lpList;
    for(i=0;i<nDLLs;i++)
    {
        if(lpDLL)
        {
            if(lpDLL->bMailUser==bMailUser)
            {
                if(!lpDLL->lpPropSheetExt || !lpDLL->lpWABExtInit)
                {
                    LPSHELLPROPSHEETEXT lpShellPropSheetExt = NULL;

                    hr = CoCreateInstance(  &(lpDLL->guidPropExt), 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                            &IID_IShellPropSheetExt, 
                                            (LPVOID *)&(lpDLL->lpPropSheetExt));
                    if(lpDLL->lpPropSheetExt && !HR_FAILED(hr))
                    {
                        hr = lpDLL->lpPropSheetExt->lpVtbl->QueryInterface(lpDLL->lpPropSheetExt,
                                                                &IID_IWABExtInit,
                                                                (LPVOID *)&(lpDLL->lpWABExtInit));
                        if(HR_FAILED(hr) || !lpDLL->lpWABExtInit)
                        {
                            SafeRelease(lpDLL->lpPropSheetExt);
                        }
                    }
                }

                if(lpDLL->lpPropSheetExt && lpDLL->lpWABExtInit)
                {
                    lpPropArrayInfo->guidExt = lpDLL->guidPropExt;

                    hr = lpDLL->lpWABExtInit->lpVtbl->Initialize(   lpDLL->lpWABExtInit,
                                                                    lpPropArrayInfo->lpWED);
                    if(!HR_FAILED(hr))
                    {
                        hr = lpDLL->lpPropSheetExt->lpVtbl->AddPages(lpDLL->lpPropSheetExt,
                                                                    &AddPropSheetPageProc, 
                                                                    (LPARAM) lpPropArrayInfo);
                    }
                }
            }
            lpDLL = lpDLL->lpNext;
        }
    }

    //lpPropArrayInfo->lpExtList = lpList;
    lpList = NULL;

    hr = S_OK;

out:
    if(lpList)
        FreePropExtList(lpList);

    return hr;
}


//$$//////////////////////////////////////////////////////////////////////
//
// FreeExtDisplayInfo 
//
//
//////////////////////////////////////////////////////////////////////////
void FreeExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo)
{
    if(lpPropArrayInfo->lpExtList)
        FreePropExtList(lpPropArrayInfo->lpExtList);
    if(lpPropArrayInfo->lpWED)
        LocalFree(lpPropArrayInfo->lpWED);
    if(lpPropArrayInfo->lphpages)
        LocalFree(lpPropArrayInfo->lphpages);
    //UninitExtInfo();
    return;
}


//$$/////////////////////////////////////////////////////////////////////
//
// ChangedExtDisplayInfo
//
// Returns true if the info changed on any of the prop sheets
//
/////////////////////////////////////////////////////////////////////////
BOOL ChangedExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL bChanged)
{
    if(lpPropArrayInfo->lpWED && lpPropArrayInfo->lpWED->fDataChanged)
            return TRUE;
    return bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_pwd.h ===
// ui_pwd.h
//
// definitions for WAB synchronization password request dialog
//

#ifndef __UI_PWD_H__
#define __UI_PWD_H__

#ifdef __cplusplus
extern "C"{
#endif 

typedef struct tagPASSINFO
{
    TCHAR           szTitle[50];
    LPTSTR          lpszPassword;
    ULONG           cbMaxPassword;
    LPTSTR          lpszAccount;
    ULONG           cbMaxAccount;
    LPTSTR          lpszServer;
    BOOL            fRememberPassword;
    DWORD           fAlwaysPromptPassword;
} PASSINFO, *LPPASSINFO;


// Forward Declarations
typedef struct INETSERVER *LPINETSERVER;

// =====================================================================================
// Prototypes
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo);
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd);


#ifdef __cplusplus
}
#endif 


#endif //__UI_PWD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_reslv.c ===
/*--------------------------------------------------------------
*
*
*   ui_reslv.c - shows the resolve name dialog
*
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;

#define MAX_RESLV_STRING 52 // Max # of characters to display in the static label ...

enum _ReturnValuesFromResolveDialog
{
    RESOLVE_PICKUSER=0,
    RESOLVE_CANCEL,
    RESOLVE_OK
};

typedef struct _ResolveInfo
{
    LPADRLIST * lppAdrList; // Stores the AdrList
    ULONG   nIndex;         // Index of the item of interest
    LPTSTR  lpszDisplayName;// Preextracted display name for that
    LPADRBOOK lpIAB;        // Pointer to the IAB object
    HWND    hWndParent;     // Stores hWndParents for dialog generating windows
    ULONG  ulFlag;          // Stores Resolved or Ambiguos state
    LPRECIPIENT_INFO lpContentsList;
    LPMAPITABLE lpMapiTable;
    BOOL    bUnicode;       // TRUE if MAPI_UNICODE specified in IAB::ResolveName
} RESOLVE_INFO, * LPRESOLVE_INFO;


static DWORD rgReslvHelpIDs[] =
{
    IDC_RESOLVE_BUTTON_BROWSE,  IDH_WAB_PICK_USER,
    IDC_RESOLVE_LIST_MATCHES,   IDH_WAB_CHK_NAME_LIST,
    IDC_RESOLVE_STATIC_1,       IDH_WAB_CHK_NAME_LIST,
    IDC_RESOLVE_BUTTON_PROPS,   IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_RESOLVE_BUTTON_NEWCONTACT,  IDH_WAB_PICK_RECIP_NAME_NEW,
    0,0
};


//forward declarations
HRESULT HrResolveName(LPADRBOOK lpIAB,
                      HWND hWndParent,
                      HANDLE hPropertyStore,
                      ULONG nIndex,
                      ULONG ulFlag,
                      BOOL bUnicode,
                      LPADRLIST * lppAdrList,
                      LPMAPITABLE lpMapiTable);


INT_PTR CALLBACK fnResolve(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL ProcessResolveLVNotifications(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT HrShowPickUserDialog(LPRESOLVE_INFO lpRI, LPTSTR lpszCaption);

HRESULT HrShowNewEntryFromResolve(LPRESOLVE_INFO lpRI, HWND hWndParent, ULONG ulObjectType);

HRESULT HrFillLVWithMatches(   HWND hWndLV,
                                LPRESOLVE_INFO lpRI);

HRESULT HrMergeSelectionWithOriginal(LPRESOLVE_INFO lpRI,
                                     ULONG cbEID,
                                     LPENTRYID lpEID);

void ExitResolveDialog(HWND hDlg, LPRESOLVE_INFO lpRI, int nRetVal);

BOOL GetLVSelectedItem(HWND hWndLV, LPRESOLVE_INFO lpRI);



///////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// HrShowResolveUI
//
// Wraps the UI for Resolve Names
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowResolveUI(IN  LPADRBOOK   lpIAB,
                        HWND hWndParent,
                        HANDLE hPropertyStore,
                        ULONG ulFlags,      // WAB_RESOLVE_NO_NOT_FOUND_UI
                        LPADRLIST * lppAdrList,
                        LPFlagList *lppFlagList,
                        LPAMBIGUOUS_TABLES lpAmbiguousTables)
{
    HRESULT hr = hrSuccess;
    ULONG i=0;
    LPFlagList lpFlagList= NULL;
    LPMAPITABLE lpMapiTable = NULL;
    BOOL bUnicode = (ulFlags & WAB_RESOLVE_UNICODE);

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(!hPropertyStore || !lppAdrList || !lppFlagList || !(*lppAdrList) || !(*lppFlagList))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    lpFlagList=(*lppFlagList);

     // we need to scan the lpFlagList and look for unresolved entries

    for (i = 0; i < lpFlagList->cFlags; i++)
    {
        //
        // Occasionally someone (like athena) may hand us an adrlist with null rgPropVals
        // We need to anticipate that.
        //
        if (    ((*lppAdrList)->aEntries[i].cValues == 0) ||
                ((*lppAdrList)->aEntries[i].rgPropVals == NULL)  )
            continue;

        switch (lpFlagList->ulFlag[i])
        {
            case MAPI_RESOLVED:
                break;

            case MAPI_AMBIGUOUS:
                //
                // W2 - we now have an Ambiguous Table parameter .. for Unresolved
                // entries, there is no Table but for Ambiguous entries, there is
                // a corresponding ambiguous table filled in from the LDAP servers
                //
                if(lpAmbiguousTables)
                {
                    if (lpAmbiguousTables->cEntries != 0)
                    {
                        lpMapiTable = lpAmbiguousTables->lpTable[i];
                    }
                }
                //Fall through
            case MAPI_UNRESOLVED:
                //
                // We show a dialog asking the user what they want to do ...
                // For this version, they can
                // (b) browse the list of users or (c) cancel this user ..
                // We will assume that we already the AdrList already has
                // Recipient_Type and Display_Name and we only need to fill
                // in the EntryID of this user ...
                //
                if ((! (ulFlags & WAB_RESOLVE_NO_NOT_FOUND_UI) ||
                  lpFlagList->ulFlag[i] == MAPI_AMBIGUOUS)) {
                    hr = HrResolveName( lpIAB,
                                        hWndParent,
                                        hPropertyStore,
                                        i,
                                        lpFlagList->ulFlag[i],
                                        bUnicode,
                                        lppAdrList,
                                        lpMapiTable);
                    if (!HR_FAILED(hr))
                        lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                    else
                    {
                        // Cancels are final .. other errors are not ..
                        if (hr == MAPI_E_USER_CANCEL)
                            goto out;
                    }
                }

                break;
        }
    }

out:

    return hr;
}



// *** Dont change *** the order of the first 2 properties between here and the similar structure
// in ui_addr.c
enum _lppAdrListReturnedProps
{
    propPR_DISPLAY_NAME,
    propPR_ENTRYID,
    TOTAL_ADRLIST_PROPS
};


////////////////////////////////////////////////////////////////////////////////////////
//
// HrResolveName - tackles one entry at a time ...
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrResolveName(  IN  LPADRBOOK   lpIAB,
                        HWND hWndParent,
                        HANDLE hPropertyStore,
                        ULONG nIndex,
                        ULONG ulFlag,
                        BOOL bUnicode,
                        LPADRLIST * lppAdrList,
                        LPMAPITABLE lpMapiTable)
{
    ULONG i=0;
    LPTSTR lpszDisplayName = NULL, lpszEmailAddress = NULL;
    int nRetVal = 0;
    HRESULT hr = hrSuccess;
    RESOLVE_INFO RI = {0};
    LPADRLIST lpAdrList = *lppAdrList;
    ULONG ulTagDN = PR_DISPLAY_NAME, ulTagEmail = PR_EMAIL_ADDRESS;

    if(!bUnicode)
    {
        ulTagDN = CHANGE_PROP_TYPE(ulTagDN, PT_STRING8);
        ulTagEmail = CHANGE_PROP_TYPE(ulTagEmail, PT_STRING8);
    }
    //Scan this adrlist entries properties
    for(i=0;i < lpAdrList->aEntries[nIndex].cValues; i++)
    {
        if (lpAdrList->aEntries[nIndex].rgPropVals[i].ulPropTag == ulTagDN)
        {
            lpszDisplayName = bUnicode ? 
                                (LPWSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ :
                                ConvertAtoW((LPSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ);
        }
        if (lpAdrList->aEntries[nIndex].rgPropVals[i].ulPropTag == ulTagEmail)
        {
            lpszEmailAddress = bUnicode ? 
                                (LPWSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ :
                                ConvertAtoW((LPSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ);
        }
    }

    // we need some display name info to resolve on ...
    if (lpszDisplayName == NULL) //we need this info or cant proceed
    {
        if (lpszEmailAddress) 
        {
            lpszDisplayName = lpszEmailAddress;
            lpszEmailAddress = NULL;
        } 
        else 
        {
            hr = MAPI_E_INVALID_PARAMETER;
            goto out;
        }
    }


    RI.nIndex = nIndex;
    RI.lppAdrList = lppAdrList;
    RI.lpszDisplayName = lpszDisplayName;
    RI.lpIAB = lpIAB;
    RI.hWndParent = hWndParent;
    RI.ulFlag = ulFlag;
    RI.lpContentsList = NULL;
    RI.lpMapiTable = lpMapiTable;
    RI.bUnicode = bUnicode;

    nRetVal = (int) DialogBoxParam( hinstMapiX,
                    MAKEINTRESOURCE(IDD_DIALOG_RESOLVENAME),
                    hWndParent,
                    (DLGPROC) fnResolve,
                    (LPARAM) &RI);

    switch(nRetVal)
    {
    case RESOLVE_CANCEL:
        hr = MAPI_E_USER_CANCEL; //Cancel, flag it as pass and dont change anything
        goto out;
        break;

    case RESOLVE_OK:
        hr = hrSuccess;
        goto out;

    case -1:        // something went wrong ...
        DebugPrintTrace(( TEXT("DialogBoxParam -> %u\n"), GetLastError()));
        hr = E_FAIL;
        goto out;
        break;

    } //switch


out:

    if(!bUnicode) // <note> assumes UNICODE defined
    {
        LocalFreeAndNull(&lpszDisplayName);
        LocalFreeAndNull(&lpszEmailAddress);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////
//
// SetResolveUI - 
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetResolveUI(HWND hDlg)
{

    // This function initializes a list view
    HrInitListView( GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES),
                    LVS_REPORT,
                    FALSE);		// Hide or show column headers

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);


    return TRUE;

}


void SetLabelLDAP(HWND hDlg, HWND hWndLV)
{
    // look at an entryid from the hWNdLV
    // Use it only if its an LDAP entryid

    // if the entryid is something else, we need to get its name and
    // fill the structure accordingly
    LPRECIPIENT_INFO lpItem;

    if(ListView_GetItemCount(hWndLV) <= 0)
        goto out;

    lpItem = GetItemFromLV(hWndLV, 0);
    if(lpItem)
    {
        LPTSTR lpServer = NULL;
        LPTSTR lpDNS = NULL;
	    LPTSTR lpName = NULL;
        TCHAR szName[40]; // we will limit the name to 40 chars so that the whole
                          // string will fit in the UI for really large chars

        // is this an LDAP entryid ?
        if (WAB_LDAP_MAILUSER == IsWABEntryID(  lpItem->cbEntryID,
                                                lpItem->lpEntryID,
                                                &lpServer,
                                                &lpDNS,
                                                NULL, NULL, NULL))
        {
            //lpServer contains the server name

            LPTSTR lpsz;
            TCHAR szBuf[MAX_UI_STR];
            TCHAR szTmp[MAX_PATH], *lpszTmp;

            CopyTruncate(szName, lpServer, CharSizeOf(szName));

            lpName = (LPTSTR) szName;

            LoadString(hinstMapiX, idsResolveMatchesOnLDAP, szBuf, CharSizeOf(szBuf));

            CopyTruncate(szTmp, lpName, MAX_PATH - 1);
            lpszTmp = szTmp;
            if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szBuf,
                                0,0, //ignored
                                (LPTSTR) &lpsz,
                                MAX_UI_STR,
                                (va_list *)&lpszTmp))
            {
                SetDlgItemText(hDlg, IDC_RESOLVE_STATIC_MATCHES, lpsz);
                IF_WIN32(LocalFree(lpsz);)
                IF_WIN16(FormatMessageFreeMem(lpsz);)
            }
        }
    }

out:
    return;
}


void FillUI(HWND hDlg, HWND hWndLV, LPRESOLVE_INFO lpRI)
{

    TCHAR szBuf[MAX_UI_STR];
    ULONG nLen = 0;
    LPTSTR lpszDisplayName = lpRI->lpszDisplayName;
    BOOL bNothingFound = FALSE;
    LPTSTR lpszBuffer = NULL;
	LPTSTR lpName = NULL;
    TCHAR szTmp[MAX_PATH], *lpszTmp;
    TCHAR szName[40]; // we will limit the name to 40 chars so that the whole
                      // string will fit in the UI for really large chars

    if (    (lpRI->ulFlag == MAPI_UNRESOLVED) ||
            (HR_FAILED(HrFillLVWithMatches(hWndLV, lpRI)))
        )
        bNothingFound = TRUE;

    nLen = CopyTruncate(szName, lpszDisplayName, CharSizeOf(szName));

    lpName = (LPTSTR) szName;

    LoadString(hinstMapiX, (bNothingFound ? IDS_RESOLVE_NO_MATCHES_FOR : IDS_ADDRBK_RESOLVE_CAPTION),
                szBuf, CharSizeOf(szBuf));

    // Win9x bug FormatMessage cannot have more than 1023 chars
    CopyTruncate(szTmp, lpName, MAX_PATH - 1);
    lpszTmp = szTmp;
    if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szBuf,
                        0,0, //ignored
                        (LPTSTR) &lpszBuffer,
                        MAX_UI_STR,
                        (va_list *)&lpszTmp))
    {
        SetDlgItemText(hDlg, IDC_RESOLVE_STATIC_1,lpszBuffer);
        IF_WIN32(LocalFreeAndNull(&lpszBuffer);)
        IF_WIN16(FormatMessageFreeMem(lpszBuffer);)
    }
    
    if(bNothingFound)
    {
        // If this has already been flagged as unresolved .. or
        // the attempt to find fuzzy matches was unsuccessful ...
        // tell 'em nothing found ...

        LoadString(hinstMapiX, IDS_RESOLVE_NO_MATCHES, szBuf, CharSizeOf(szBuf));
		{
			LV_ITEM lvI = {0};
			lvI.mask = LVIF_TEXT;
			lvI.cchTextMax = lstrlen(szBuf)+1;
			lvI.pszText = szBuf;
			ListView_InsertItem(hWndLV, &lvI);
			ListView_SetColumnWidth(hWndLV,0,400); //400 is a totally random number, we just want the column to be big enough not to truncate text
		}
        EnableWindow(hWndLV,FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_RESOLVE_BUTTON_PROPS),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_RESOLVE_BUTTON_OK*/),FALSE);
        ShowWindow(GetDlgItem(hDlg,IDC_RESOLVE_STATIC_MATCHES),SW_HIDE);
    }
    else
    {

        // if the search results are from an ldap server, we need
        // to set the label on the dialog to say the results are from
        // an LDAP server
        SetLabelLDAP(hDlg, hWndLV);

        // If the list view is filled, select the first item
        if (ListView_GetItemCount(hWndLV) > 0)
        {
            LVSelectItem(hWndLV, 0);
            SetFocus(hWndLV);
        }
    }

    return;
}
/*************************************************************************
//
//  resolve Dialog - simple implementation for 0.5
//
**************************************************************************/
INT_PTR CALLBACK fnResolve(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_UI_STR];
    ULONG nLen = 0, nLenMax = 0, nRetVal=0;
    HRESULT hr = hrSuccess;

    LPRESOLVE_INFO lpRI = (LPRESOLVE_INFO) GetWindowLongPtr(hDlg,DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            HWND hWndLV = GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
            lpRI = (LPRESOLVE_INFO) lParam;

            SetResolveUI(hDlg);

            FillUI(hDlg, hWndLV, lpRI);
        }
        break;

    default:
#ifndef WIN16
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), message, wParam, lParam);
            break;
        }
#endif // !WIN16
        return FALSE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), message, wParam, lParam);
		break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam,lParam))
        {
        default:
            return ProcessActionCommands((LPIAB) lpRI->lpIAB, 
                                        GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), 
                                        hDlg, message, wParam, lParam);
            break;

        case IDM_LVCONTEXT_DELETE: //We renamed the delete on the context menu to say  TEXT("Show more Names")
        case IDC_RESOLVE_BUTTON_BROWSE:
            GetWindowText(hDlg, szBuf, CharSizeOf(szBuf));
            lpRI->hWndParent = hDlg;
            hr = HrShowPickUserDialog(lpRI, szBuf);
            if(!HR_FAILED(hr))
            {
                if(lpRI->lpContentsList)
                    ClearListView(  GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES),
                                    &(lpRI->lpContentsList));
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
//                EndDialog( hDlg, RESOLVE_OK);
            }
            else
            {
                if(hr != MAPI_E_USER_CANCEL)
                {
                    // Some error occured .. dont know what .. but since this dialog
                    // will stick around, need to warn the user about it ...
                    ShowMessageBox(hDlg,idsCouldNotSelectUser,MB_ICONERROR | MB_OK);
                }
            }
            break;

        case IDOK:
        case IDC_RESOLVE_BUTTON_OK:
            if (GetLVSelectedItem(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES),lpRI))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDCANCEL:
        case IDC_RESOLVE_BUTTON_CANCEL:
            ExitResolveDialog(hDlg, lpRI, RESOLVE_CANCEL);
            break;

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDC_RESOLVE_BUTTON_NEWCONTACT:
            hr = HrShowNewEntryFromResolve(lpRI,hDlg,MAPI_MAILUSER);
            if (!HR_FAILED(hr))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDM_LVCONTEXT_NEWGROUP:
//        case IDC_RESOLVE_BUTTON_NEWCONTACT:
            hr = HrShowNewEntryFromResolve(lpRI,hDlg,MAPI_DISTLIST);
            if (!HR_FAILED(hr))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDM_LVCONTEXT_COPY:
            HrCopyItemDataToClipboard(hDlg, lpRI->lpIAB, GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES));
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_RESOLVE_BUTTON_PROPS:
            EnableWindow(GetDlgItem(hDlg, IDC_RESOLVE_BUTTON_PROPS), FALSE);
            HrShowLVEntryProperties(GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES), 0,
                                    lpRI->lpIAB, NULL);
            EnableWindow(GetDlgItem(hDlg, IDC_RESOLVE_BUTTON_PROPS), TRUE);
            break;

        }
        break;

    case WM_CLOSE:
        //treat it like a cancel button
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_RESOLVE_BUTTON_CANCEL, 0);
        break;

    case WM_CONTEXTMENU:
		if ((HWND)wParam == GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES))
		{
			ShowLVContextMenu(	lvDialogResolve, (HWND)wParam, NULL, lParam, NULL,lpRI->lpIAB, NULL);
		}
        else
        {
            WABWinHelp((HWND) wParam,
                    g_szWABHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) rgReslvHelpIDs );
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgReslvHelpIDs );
        break;


    case WM_NOTIFY:
        switch((int) wParam)
        {
        case IDC_RESOLVE_LIST_MATCHES:
            return ProcessResolveLVNotifications(hDlg,message,wParam,lParam);
        }
        break;
    }

    return TRUE;

}



/////////////////////////////////////////////////////////////
//
// Processes Notification messages for the list view control
//
//
////////////////////////////////////////////////////////////
BOOL ProcessResolveLVNotifications(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;

    switch(pNm->hdr.code)
    {
    case NM_DBLCLK:
        // Doubleclick on the list view is equivalent to a OK with a selected item
        SendMessage(hDlg, WM_COMMAND, (WPARAM) IDOK/*IDC_RESOLVE_BUTTON_OK*/, 0);
        break;

    case NM_CUSTOMDRAW:
        return (0 != ProcessLVCustomDraw(hDlg, lParam, TRUE));
    	break;

    }

	return FALSE;

}

//////////////////////////////////////////////////////////////////////////////
//
//
// Pops up the New Entry dialog and then replaces the old entry with the
//  newly created entry ...
//
//////////////////////////////////////////////////////////////////////////////
HRESULT HrShowNewEntryFromResolve(LPRESOLVE_INFO lpRI, HWND hWndParent, ULONG ulObjectType)
{
	ULONG cbEID=0;
	LPENTRYID lpEID=NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;

    //OutputDebugString( TEXT("HrShowNewEntryFromResolve entry\n"));

    if (ulObjectType!=MAPI_MAILUSER && ulObjectType!=MAPI_DISTLIST)
        goto out;

    if(HR_FAILED(hr = HrGetWABTemplateID(   lpRI->lpIAB,
                                            ulObjectType,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        DebugPrintError(( TEXT("HrGetWABTemplateID failed: %x\n"), hr));
        goto out;
    }

	if (HR_FAILED(hr = (lpRI->lpIAB)->lpVtbl->NewEntry(	lpRI->lpIAB,
				            					(ULONG_PTR) hWndParent,
							            		0,
									            0,NULL,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        DebugPrintError(( TEXT("NewEntry failed: %x\n"),hr));
        goto out;
    }


   // We created a new entry, and we want to use it to replace the old unresolved entry

    hr = HrMergeSelectionWithOriginal(lpRI, cbEID, lpEID);

out:
    FreeBufferAndNull(&lpEID);
    FreeBufferAndNull(&lpTplEID);

    //OutputDebugString( TEXT("HrShowNewEntryFromResolve exit\n"));
    return hr;
}


////////////////////////////////////////////////////////////////
//
// Takes entry id of users selection and returns it appropriately ...
//
//
////////////////////////////////////////////////////////////////
HRESULT HrMergeSelectionWithOriginal(LPRESOLVE_INFO lpRI,
                                     ULONG cbEID,
                                     LPENTRYID lpEID)
{
    HRESULT hr = hrSuccess;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    LPADRLIST lpAdrList = *(lpRI->lppAdrList);
    SCODE sc;
    ULONG nIndex = lpRI->nIndex;

    //OutputDebugString( TEXT("HrMergeSelectionWithOriginal entry\n"));

    hr = HrGetPropArray((lpRI->lpIAB),
                        (LPSPropTagArray) &ptaResolveDefaults,
                        cbEID,
                        lpEID,
                        lpRI->bUnicode ? MAPI_UNICODE : 0,
                        &cValues,
                        &lpPropArray);

    if (HR_FAILED(hr)) goto out;

    if ((!cValues) || (!lpPropArray))
    {
        hr = E_FAIL;
        goto out;
    }
    else
    {
        LPSPropValue lpPropArrayNew = NULL;
        ULONG cValuesNew = 0;

        sc = ScMergePropValues( lpAdrList->aEntries[nIndex].cValues,
                                lpAdrList->aEntries[nIndex].rgPropVals,
                                cValues,
                                lpPropArray,
                                &cValuesNew,
                                &lpPropArrayNew);
        if (sc != S_OK)
        {
            hr = ResultFromScode(sc);
            goto out;
        }

        if ((lpPropArrayNew) && (cValuesNew > 0))
        {
            // [PaulHi] Raid 69325
            // We need to convert these properties to ANSI since we are now the
            // UNICODE WAB and if our client is !MAPI_UNICODE
            if (!(lpRI->bUnicode))
            {
                if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0))
                    goto out;
            }

            MAPIFreeBuffer(lpAdrList->aEntries[nIndex].rgPropVals);
            lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
            lpAdrList->aEntries[nIndex].cValues = cValuesNew;
        }
    }


    hr = hrSuccess;

out:

    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);


    //OutputDebugString( TEXT("HrMergeSelectionWithOriginal exit\n"));

    return hr;

}

////////////////////////////////////////////////////////////////////////////////////////
//
// HrShowPickuserDialog - shows the pick user dialog
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowPickUserDialog(LPRESOLVE_INFO lpRI,
                             LPTSTR lpszCaption)
{
    LPADRLIST lpAdrList = *(lpRI->lppAdrList);
    ULONG nIndex = lpRI->nIndex;
    LPTSTR lpszDisplayName = lpRI->lpszDisplayName;

    LPADRLIST lpAdrListSingle = NULL;
    ADRPARM AdrParms = {0};
    SCODE sc;
    HRESULT hr = hrSuccess;

    //OutputDebugString( TEXT("HrShowPickUserDialog entry\n"));

    // create an AdrList structure which we pass to Address ... to show UI
    // We pass in the bare minimum props here which are - Display Name and Entry ID field (which is really NULL)
    // The Address UI, if successful, gives us a whole list of props back which we merge with
    // the original list, overwriting what we got back fresh ...

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListSingle);

    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    lpAdrListSingle->cEntries = 1;
    lpAdrListSingle->aEntries[0].ulReserved1 = 0;
    lpAdrListSingle->aEntries[0].cValues = TOTAL_ADRLIST_PROPS;

    sc = MAPIAllocateBuffer(   TOTAL_ADRLIST_PROPS * sizeof(SPropValue),
                             (LPVOID *) (&(lpAdrListSingle->aEntries[0].rgPropVals)));
    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    sc = MAPIAllocateMore( sizeof(TCHAR)*(lstrlen(lpszDisplayName)+1),
                            lpAdrListSingle->aEntries[0].rgPropVals,
                            (LPVOID *) (&lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].Value.LPSZ));

    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    lstrcpy(lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].Value.LPSZ, lpszDisplayName);

    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].ulPropTag = PR_ENTRYID;
    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].Value.bin.cb = 0;
    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].Value.bin.lpb = NULL;

    AdrParms.cDestFields = 0;
    AdrParms.ulFlags = DIALOG_MODAL | ADDRESS_ONE | MAPI_UNICODE;
    AdrParms.lpszCaption = lpszCaption;


    if (!HR_FAILED(hr = (lpRI->lpIAB)->lpVtbl->Address(
                                                lpRI->lpIAB,
                                                (PULONG_PTR) &(lpRI->hWndParent),
                                                &AdrParms,
                                                &lpAdrListSingle)))
    {
            // We successfully selected some user and the lpAdrListSingle contains
            // a new set of lpProps for that user ...
            //
            LPSPropValue lpPropArrayNew = NULL;
            ULONG cValuesNew = 0;

            sc = ScMergePropValues( lpAdrList->aEntries[nIndex].cValues,
                                    lpAdrList->aEntries[nIndex].rgPropVals,
                                    lpAdrListSingle->aEntries[0].cValues,
                                    lpAdrListSingle->aEntries[0].rgPropVals,
                                    &cValuesNew,
                                    &lpPropArrayNew);
            if (sc != S_OK)
            {
                hr = ResultFromScode(sc);
                goto out;
            }

            if ((lpPropArrayNew) && (cValuesNew > 0))
            {
                // [PaulHi] Raid 69325
                // We need to convert these properties to ANSI since we are now the
                // UNICODE WAB and if our client is !MAPI_UNICODE
                if (!(lpRI->bUnicode))
                {
                    if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0))
                        goto out;
                }

                MAPIFreeBuffer(lpAdrList->aEntries[nIndex].rgPropVals);
                lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                lpAdrList->aEntries[nIndex].cValues = cValuesNew;
            }

    }

out:

    if (lpAdrListSingle)
    {
        FreePadrlist(lpAdrListSingle);
    }

    //OutputDebugString( TEXT("HrShowPickUserDialog exit\n"));
    return hr;
}



//$$/////////////////////////////////////////////////////////////////////////////////
//
//
// HrFillLVWithMatches - fills the list view with close matches for the given name
//
// Fails (E_FAIL) if it doesnt find anything to fill in the List View
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrFillLVWithMatches(   HWND hWndLV,
                                LPRESOLVE_INFO lpRI)
{
    HRESULT hr = hrSuccess;
    LPSBinary * lprgsbEntryIDs = NULL;
    ULONG iolkci=0, colkci = 0;
	OlkContInfo *rgolkci;
    ULONG * lpcValues = NULL;
    ULONG i = 0, j = 0;
    LPSRowSet   lpSRowSet = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    ULONG ulFlags = AB_FUZZY_FIND_ALL;

    EnterCriticalSection(&(((LPIAB)(lpRI->lpIAB))->cs));

	if (pt_bIsWABOpenExSession) 
    {
		colkci = ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->colkci;
		Assert(colkci);
		rgolkci = ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->rgolkci;
		Assert(rgolkci);
    }
    else
	if (bAreWABAPIProfileAware((LPIAB)lpRI->lpIAB)) 
    {
		colkci = ((LPIAB)(lpRI->lpIAB))->cwabci;
		Assert(colkci);
		rgolkci = ((LPIAB)(lpRI->lpIAB))->rgwabci;
		Assert(rgolkci);
        if(colkci > 1 && !lpRI->lpMapiTable)
            ulFlags |= AB_FUZZY_FIND_PROFILEFOLDERONLY;
    }
    else
        colkci = 1;

    lprgsbEntryIDs = LocalAlloc(LMEM_ZEROINIT, colkci*sizeof(LPSBinary));
    lpcValues = LocalAlloc(LMEM_ZEROINIT, colkci*sizeof(ULONG));
    if(!lprgsbEntryIDs || !lpcValues)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    
    //
    // First search the property store
    //

    if(!(lpRI->lpMapiTable))
    {
        // if we dont have a ambiguous table to look in then that means we look in the
        // property store for ambiguous stuff ...
		while (iolkci < colkci) 
        {
            hr = HrFindFuzzyRecordMatches(
                            ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                            (colkci == 1) ? NULL : rgolkci[iolkci].lpEntryID,
                            lpRI->lpszDisplayName,
                            ulFlags, //flags
                            &(lpcValues[iolkci]),
                            &(lprgsbEntryIDs[iolkci]));
			iolkci++;
		}

        if (HR_FAILED(hr))
            goto out;


        if(bAreWABAPIProfileAware((LPIAB)lpRI->lpIAB))
        {
            // it's possible that nothing in the profile matched but other stuff in the WAB matched
            // Doublecheck that if we found nothing in the profile, we can search the whole WAB
            ULONG nCount = 0;
            for(i=0;i<colkci;i++)
                nCount += lpcValues[i];
            if(!nCount)
            {
                // search the whole WAB
                hr = HrFindFuzzyRecordMatches(
                                ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                                NULL,
                                lpRI->lpszDisplayName,
                                AB_FUZZY_FIND_ALL, //flags
                                &(lpcValues[0]),
                                &(lprgsbEntryIDs[0]));
            }
        }

        // Now we have a list of EntryIDs
        // Use them to populate the List View
        //
        // We can
        // (a) Read the entryids one by one and fill the list view
        //      AddWABEntryToListView
        // or
        // (b) We can create an lpContentsList and fill it in one shot
        //      HrFillListView

        // We'll go with (a) for now
        // If performance is bad, do (b)

        for(i=0;i<colkci;i++)
        {
            for(j=0;j<lpcValues[i];j++)
            {
                AddWABEntryToListView(  lpRI->lpIAB,
                                        hWndLV,
                                        lprgsbEntryIDs[i][j].cb,
                                        (LPENTRYID) lprgsbEntryIDs[i][j].lpb,
                                        &(lpRI->lpContentsList));
            }
        }

    }
    else if(lpRI->lpMapiTable)
    {
        // if there is a MAPI ambiguous contents table associated with this display name
        // use it to further fill in the lpContentsList
        BOOL bUnicode = ((LPVUE)lpRI->lpMapiTable)->lptadParent->bMAPIUnicodeTable;

        hr = HrQueryAllRows(lpRI->lpMapiTable,
                            NULL,
                            NULL,
                            NULL,
                            0,
                            &lpSRowSet);

        if (HR_FAILED(hr))
        {
            DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
            goto out;
        }

        for(i=0;i<lpSRowSet->cRows;i++)
        {
            LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;

            ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

            LPRECIPIENT_INFO lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		
            if (!lpItem)
		    {
			    DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			    hr = MAPI_E_NOT_ENOUGH_MEMORY;
			    goto out;
		    }

            if(!bUnicode) // the props are in ANSI - convert to UNICODE for our use
            {
                if(ScConvertAPropsToW((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArray, ulcPropCount, 0))
                    goto out;
            }

		    GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		    // The critical prop is display name - without it we are nothing ...
		    // If no display name, junk this entry and continue ..

		    if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		    {
			    FreeRecipItem(&lpItem);				
			    continue;
		    }


        	AddSingleItemToListView(hWndLV, lpItem);

            //
            // Hook in the lpItem into the lpContentsList so we can free it later
            //
            lpItem->lpPrev = NULL;
            lpItem->lpNext = lpRI->lpContentsList;
            if (lpRI->lpContentsList)
                lpRI->lpContentsList->lpPrev = lpItem;
            lpRI->lpContentsList = lpItem;

            lpItem = NULL;

        } //for i ....

    }


    //
    // If, after all this we still have an empty list box, we will report a failure
    //
    if(ListView_GetItemCount(hWndLV)<=0)
    {
        DebugPrintTrace(( TEXT("Empty List View - no matches found\n")));
        hr = E_FAIL;
        goto out;
    }


out:

    for(i=0;i<colkci;i++)
    {
        FreeEntryIDs(((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                     lpcValues[i],
                     lprgsbEntryIDs[i]);
    }
    if(lpcValues)
        LocalFree(lpcValues);
    if(lprgsbEntryIDs)
        LocalFree(lprgsbEntryIDs);

    if (lpSRowSet)
        FreeProws(lpSRowSet);

    //
    // ReSet the ListView SortAscending style off
    //
    // SetWindowLong(hWndLV, GWL_STYLE, (dwStyle | LVS_SORTASCENDING));
    LeaveCriticalSection(&(((LPIAB)(lpRI->lpIAB))->cs));

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Returns the item selected in the list view
//
////////////////////////////////////////////////////////////////////////
BOOL GetLVSelectedItem(HWND hWndLV, LPRESOLVE_INFO lpRI)
{
    int iItemIndex = 0;
    LV_ITEM lvi = {0};
    LPRECIPIENT_INFO lpItem;
    BOOL bRet = FALSE;

    //OutputDebugString( TEXT("GetLVSelectedItem Entry\n"));

    if (ListView_GetSelectedCount(hWndLV) != 1)
        goto out;

    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    lpItem = GetItemFromLV(hWndLV, iItemIndex);

    if(lpItem)
        HrMergeSelectionWithOriginal(lpRI,lpItem->cbEntryID,lpItem->lpEntryID);
    else
        goto out;

    bRet = TRUE;

out:
    //OutputDebugString( TEXT("GetLVSelectedItem Exit\n"));

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
// Generic exit function
//
////////////////////////////////////////////////////////////////////////
void ExitResolveDialog(HWND hDlg, LPRESOLVE_INFO lpRI, int nRetVal)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES);

    //OutputDebugString( TEXT("ExitResolveDialog Entry\n"));

    if(lpRI->lpContentsList)
    {
        ClearListView(hWndLV,&(lpRI->lpContentsList));
    }

    if(ListView_GetItemCount(hWndLV) > 0)
        ListView_DeleteAllItems(hWndLV);

    EndDialog(hDlg, nRetVal);

    //OutputDebugString( TEXT("ExitResolveDialog Exit\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_pwd.c ===
#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "resource.h"
#include "objbase.h"
#include "ui_pwd.h"
#include "commctrl.h"
#include "winuser.h"
#include "windowsx.h"
#include "imnxport.h"


// =====================================================================================
// Prototypes
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify);
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam);
extern VOID CenterDialog(HWND hwndDlg);

#define FIsStringEmpty(s)   (*s == 0)
#define ISFLAGSET(_dw, _f)           (BOOL)(((_dw) & (_f)) == (_f))
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

// --------------------------------------------------------------------------------
// HANDLE_COMMAND - Used in a WindowProc to simplify handling of WM_COMMAND messages
// --------------------------------------------------------------------------------
#define HANDLE_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
                case (id): { (fn)((HWND)(hwnd), (HWND)(hwndCtl), (UINT)(codeNotify)); break; }

// =====================================================================================
// HrGetPassword
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo)
{
    // Locals
    HRESULT     hr = S_OK;
    INT         nResult;

    // Check Params
    AssertSz (lpPassInfo,  TEXT("NULL Parameter"));
    AssertSz (lpPassInfo->lpszPassword && lpPassInfo->lpszAccount && lpPassInfo->lpszServer &&
              (lpPassInfo->fRememberPassword == TRUE || lpPassInfo->fRememberPassword == FALSE),  TEXT("PassInfo struct was not inited correctly."));

    // Display Dialog Box
    nResult = (INT) DialogBoxParam (hinstMapiX, MAKEINTRESOURCE (iddPassword), hwndParent, (DLGPROC)PasswordDlgProc, (LPARAM)lpPassInfo);
    if (nResult == IDCANCEL)
        hr = S_FALSE;

    // Done
    return hr;
}

// =====================================================================================
// PasswordDlgProc
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG (hwndDlg, WM_INITDIALOG, PasswordDlgProc_OnInitDialog);
		HANDLE_MSG (hwndDlg, WM_COMMAND,    PasswordDlgProc_OnCommand);
	}

	return 0;
}

// =====================================================================================
// OnInitDialog
// =====================================================================================
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
    // Locals
    LPPASSINFO          lpPassInfo = NULL;
    TCHAR               szServer[CCHMAX_ACCOUNT_NAME];

	// Center
	CenterDialog (hwndDlg);

    // Make foreground
    SetForegroundWindow (hwndDlg);

    // Get Pass info struct
    lpPassInfo = (LPPASSINFO)lParam;
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        return 0;
    }

    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)lpPassInfo);

	// Default
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->cbMaxAccount);
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->cbMaxPassword);

    // Set Defaults
    Edit_SetText (GetDlgItem (hwndDlg, IDS_SERVER), lpPassInfo->lpszServer);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword);
    CheckDlgButton (hwndDlg, IDCH_REMEMBER, lpPassInfo->fRememberPassword);
    if (lpPassInfo->fAlwaysPromptPassword)
        EnableWindow(GetDlgItem(hwndDlg, IDCH_REMEMBER), FALSE);

    // Set Focus
    if (!FIsStringEmpty(lpPassInfo->lpszAccount))
        SetFocus (GetDlgItem (hwndDlg, IDE_PASSWORD));

    // Done
	return FALSE;
}

// =====================================================================================
// OnCommand
// =====================================================================================
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
		HANDLE_COMMAND(hwndDlg, IDCANCEL, hwndCtl, codeNotify, PasswordDlgProc_OnCancel);		
		HANDLE_COMMAND(hwndDlg, IDOK, hwndCtl, codeNotify, PasswordDlgProc_OnOk);		
	}
	return;
}

// =====================================================================================
// OnCancel
// =====================================================================================
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
	EndDialog (hwndDlg, IDCANCEL);
}

// =====================================================================================
// OnOk
// =====================================================================================
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
    // Locals
    LPPASSINFO lpPassInfo = NULL;

    lpPassInfo = (LPPASSINFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        EndDialog (hwndDlg, IDOK);
        return;
    }

    Edit_GetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount, lpPassInfo->cbMaxAccount);
    Edit_GetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword, lpPassInfo->cbMaxPassword);
    lpPassInfo->fRememberPassword = IsDlgButtonChecked (hwndDlg, IDCH_REMEMBER);

    EndDialog (hwndDlg, IDOK);
}



//***************************************************************************
// Function: PromptUserForPassword
//
// Purpose:
//   This function prompts the user with a password dialog and returns the
// results to the caller.
//
// Arguments:
//   LPINETSERVER pInetServer [in/out] - provides default values for username
//     and password, and allows us to save password to account if user asks us
//     to. User-supplied username and password are saved to this structure
//     for return to the caller.
//   HWND hwnd [in] - parent hwnd to be used for password dialog.
//
// Returns:
//   TRUE if user pressed  TEXT("OK") on dialog, FALSE if user pressed  TEXT("CANCEL").
//***************************************************************************
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd)
{
    PASSINFO pi;
    HRESULT hrResult;
    BOOL bReturn;

    Assert(NULL != hwnd);

    // Initialize variables
    hrResult = S_OK;
    bReturn = FALSE;

    // Setup PassInfo Struct
    ZeroMemory (&pi, sizeof (PASSINFO));
    pi.cbMaxAccount = sizeof(pInetServer->szUserName);
    pi.cbMaxPassword = sizeof(pInetServer->szPassword);
    pi.lpszServer = ConvertAtoW(pInetServer->szAccount);    // We don't modify this in the dialog
    {
        LPWSTR  lpwszAccount;
        LPWSTR  lpwszPassword;

        pi.lpszAccount = LocalAlloc(LMEM_ZEROINIT, pi.cbMaxAccount * sizeof(WCHAR));
        pi.lpszPassword = LocalAlloc(LMEM_ZEROINIT, pi.cbMaxPassword * sizeof(WCHAR));

        // Convert to Unicode strings
        lpwszAccount = ConvertAtoW(pInetServer->szUserName);
        lpwszPassword = ConvertAtoW(pInetServer->szPassword);

        if (lpwszAccount)
            lstrcpy((pi.lpszAccount), lpwszAccount);
        if (lpwszPassword)
            lstrcpy((pi.lpszPassword), lpwszPassword);

        LocalFreeAndNull(&lpwszAccount);
        LocalFreeAndNull(&lpwszPassword);
    }
    pi.fRememberPassword = !ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    pi.fAlwaysPromptPassword = ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);

    // Prompt for password
    hrResult = HrGetPassword (hwnd, &pi);
    if (S_OK == hrResult) 
    {
        IImnAccount *pAcct;
        IImnAccountManager2 *pAcctMgr = NULL;

        // Update the INET server structure.  Must convert back to ANSI
        {
            LPSTR   lpszAccount = ConvertWtoA(pi.lpszAccount);
            LPSTR   lpszPassword = ConvertWtoA(pi.lpszPassword);

            // If the conversion from Wide to ANSI overflows the pInetServer string
            // buffers then we must fail.
            if (lpszAccount)
            {
                if (lstrlenA(lpszAccount) < (int)(pi.cbMaxAccount))
                    lstrcpyA(pInetServer->szUserName, lpszAccount);
                else
                    hrResult = TYPE_E_BUFFERTOOSMALL;
            }
            if (lpszPassword)
            {
                if (lstrlenA(lpszPassword) < (int)(pi.cbMaxPassword))
                    lstrcpyA(pInetServer->szPassword, lpszPassword);
                else
                    hrResult = TYPE_E_BUFFERTOOSMALL;
            }
            
            LocalFreeAndNull(&lpszAccount);
            LocalFreeAndNull(&lpszPassword);
        }

        if (SUCCEEDED(hrResult = InitAccountManager(NULL, &pAcctMgr, NULL)))
        {
            // User wishes to proceed. Save account and password info
    
            hrResult = pAcctMgr->lpVtbl->FindAccount(pAcctMgr, AP_ACCOUNT_NAME, pInetServer->szAccount, &pAcct);
            if (SUCCEEDED(hrResult)) 
            {
                // I'll ignore error results here, since not much we can do about 'em
                pAcct->lpVtbl->SetPropSz(pAcct, AP_HTTPMAIL_USERNAME, pInetServer->szUserName);
                if (pi.fRememberPassword)
                    pAcct->lpVtbl->SetPropSz(pAcct, AP_HTTPMAIL_PASSWORD, pInetServer->szPassword);
                else
                    pAcct->lpVtbl->SetProp(pAcct, AP_HTTPMAIL_PASSWORD, NULL, 0);

                pAcct->lpVtbl->SaveChanges(pAcct);
                pAcct->lpVtbl->Release(pAcct);
            }
            // don't release the lpAcctMgr since the WAB maintains a global reference.
        }
    
        bReturn = TRUE;
    }

    Assert(SUCCEEDED(hrResult));
    LocalFreeAndNull(&(pi.lpszAccount));
    LocalFreeAndNull(&(pi.lpszPassword));
    LocalFreeAndNull(&(pi.lpszServer));
    return bReturn;
} // PromptUserForPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_reslv.h ===
#ifndef _RESOLVE_H_
#define _RESOLVE_H_

HRESULT HrShowResolveUI(    IN  LPADRBOOK   lpIAB,
                            HWND        hWndParent,
                            HANDLE      hPropertyStore,
                            ULONG       ulFlags,
                            LPADRLIST * lppAdrList,
                      	    LPFlagList*	lppFlagList,
                            LPAMBIGUOUS_TABLES lpAmbiguousTables);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\unkobj.c ===
/*
 *	U N K O B J . C
 *
 * This is a generic implementation of the IUnknown plus GetLastError)
 * "IMAPIUnknown" part of objects that are derived from IUnknown with
 * GetLastError.
 *
 * This also implements several useful utility functions based on
 * IMAPIUnknown.
 *
 * To use this, you must implement your own init function.
 *
 * Used in:
 * IPROP
 * ITABLE
 *
 */


#include "_apipch.h"



/*
 *	Per-instance global data for the UNKOBJ Class
 */
typedef struct
{
	int				cRef;			//	reference count for instance data
	HLH				hlh;			//  Single heap used by UNKOBJ_ScCOxxx
									//	allocators for all Unkobj's
	CRITICAL_SECTION cs;			//	critical section for data access
} UNKOBJCLASSINST, FAR *LPUNKOBJCLASSINST;

#if defined (WIN32) && !defined (MAC)
CRITICAL_SECTION csUnkobjInit;
extern BOOL fGlobalCSValid;
#endif

// $MAC - Use Mac specific instance global handlers

#ifndef MAC
DefineInstList(UNKOBJ);
#undef  PvGetInstanceGlobals
#define PvGetInstanceGlobals()		PvGetInstanceGlobalsEx(UNKOBJ)
#undef  ScSetInstanceGlobals
#define ScSetInstanceGlobals(pinst)	ScSetInstanceGlobalsEx(pinst, UNKOBJ)
#else  // MAC
#include <utilmac.h>
#define	PvGetInstanceGlobals()				PvGetInstanceGlobalsMac(kInstMAPIU)
#define	PvGetInstanceGlobalsEx(_x)			PvGetInstanceGlobalsMac(kInstMAPIU)
#define ScSetInstanceGlobals(a)				ScSetInstanceGlobalsMac(a, kInstMAPIU)
#define	ScSetInstanceGlobalsEx(_pinst, _x)	ScSetInstanceGlobalsMac(_pinst, kInstMAPIU)
#endif // MAC

// #pragma SEGMENT(Common)

/*============================================================================
 *	UNKOBJ (IMAPIUnknown) Class
 *
 *	Routines for handling per-process global data for the UNKOBJ Class
 *
 */

/*============================================================================
 *
 *	Initializes per-process global data for the UNKOBJ Class
 *
 */
IF_WIN32(__inline) SCODE
ScGetUnkClassInst(LPUNKOBJCLASSINST FAR *ppinst)
{
	SCODE sc = S_OK;
	LPUNKOBJCLASSINST pinst = NULL;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		EnterCriticalSection(&csUnkobjInit);
#endif

	pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();

	if (pinst)
	{
		EnterCriticalSection(&pinst->cs);
		pinst->cRef++;
		LeaveCriticalSection(&pinst->cs);
		goto ret;
	}


	if (!(pinst = (LPUNKOBJCLASSINST) GlobalAllocPtr(GPTR, sizeof(UNKOBJCLASSINST))))
	{
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}

	//	Initialize the instance structure

//	DebugTrace( TEXT("Creating UnkObj Inst: %8x"), pinst);

	InitializeCriticalSection(&pinst->cs);
	pinst->cRef = 1;

	//	(the heap will be created when the first allocation is done) ....
	pinst->hlh = NULL;

#ifdef NEVER
	// Create a Heap for the UNKOBJ Class that will be used by
	// all unkobjs in this process.
	//$ NOTE: The heap creation can be removed from here and the
	//$ code to fault the heap in in UNKOBJ_ScCO(Re)Allocate()
	//$ enabled instead - that would *require* users of CreateIProp,
	//$ CreateITable etc not to do LH_SetHeapName().

	pinst->hlh = LH_Open(0);
	if (!pinst->hlh)
	{
		DebugTrace( TEXT("ScGetUnkClassInst():: Can't create Local Heap\n"));
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}
#endif

	// ... and install the instance globals.

	if (FAILED(sc = ScSetInstanceGlobals(pinst)))
	{
		DebugTrace( TEXT("ScGetUnkClassInst():: Failed to install instance globals\n"));
		goto ret;
	}

ret:
	if (FAILED(sc))
	{
		if (pinst)
		{
			DeleteCriticalSection(&pinst->cs);
			if (pinst->hlh)
				LH_Close(pinst->hlh);
			GlobalFreePtr(pinst);
			pinst = NULL;
		}
	}

	*ppinst = pinst;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		LeaveCriticalSection(&csUnkobjInit);
#endif

	DebugTraceSc(ScInitInstance, sc);
	return sc;
}

/*============================================================================
 *
 *	Cleans up per-process global data for the UNKOBJ Class
 *
 */
IF_WIN32(__inline) void
ReleaseUnkClassInst()
{
	LPUNKOBJCLASSINST 		pinst = NULL;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		EnterCriticalSection(&csUnkobjInit);
#endif

	pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();

	if (!pinst)
		goto out;

	EnterCriticalSection(&pinst->cs);
	if (--(pinst->cRef) > 0)
	{
		LeaveCriticalSection(&pinst->cs);
		goto out;
	}

	// The last Unkobj for this process is going away, hence close
	// our heap.

//	DebugTrace( TEXT("Deleting UnkObj Inst: %8x"), pinst);

	if (pinst->hlh)
	{
//		DebugTrace( TEXT("Destroying hlh (%8x) for Inst: %8x"), pinst->hlh, pinst);
		LH_Close(pinst->hlh);
	}

	pinst->hlh = 0;

	LeaveCriticalSection(&pinst->cs);
	DeleteCriticalSection(&pinst->cs);

	GlobalFreePtr(pinst);
	(void)ScSetInstanceGlobals(NULL);
out:

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		LeaveCriticalSection(&csUnkobjInit);
#endif

	return;
}


/*============================================================================
 *	UNKOBJ (IMAPIUnknown) Class
 *
 *		Object methods.
 */


/*============================================================================
 -	UNKOBJ::QueryInterface()
 -
 */

STDMETHODIMP
UNKOBJ_QueryInterface (LPUNKOBJ	lpunkobj,
					   REFIID	riid,
					   LPVOID FAR * lppUnk)
{
	LPIID FAR *	lppiidSupported;
	ULONG		ulcIID;
	SCODE		sc;

#if	!defined(NO_VALIDATION)
	/* Validate the object.
	 */
    if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, QueryInterface, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::QueryInterface() - Bad object passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

    Validate_IUnknown_QueryInterface(lpunkobj, riid, lppUnk);
#endif


	for ( lppiidSupported = lpunkobj->rgpiidList, ulcIID = lpunkobj->ulcIID
		; ulcIID
		; lppiidSupported++, ulcIID--)
	{
		if (IsEqualGUID(riid, *lppiidSupported))
		{
			/* We support the interface so break out of the search loop.
			 */
			break;
		}
	}

	/* Return error if the requested interface was not in our list of
	 * supported interfaces.
	 */
	if (!ulcIID)
	{
		*lppUnk = NULL;	// OLE requires zeroing [out] parameters
		sc = E_NOINTERFACE;
		goto error;
	}


	/* We found the requested interface so increment the reference count.
	 */
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->ulcRef++;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	*lppUnk = lpunkobj;

	return hrSuccess;

error:
	UNKOBJ_EnterCriticalSection(lpunkobj);
	UNKOBJ_SetLastError(lpunkobj, E_NOINTERFACE, 0);
	UNKOBJ_LeaveCriticalSection(lpunkobj);
	
	return ResultFromScode(sc);
}



/*============================================================================
 -	UNKOBJ::AddRef()
 -
 */

STDMETHODIMP_(ULONG)
UNKOBJ_AddRef( LPUNKOBJ lpunkobj )
{
	ULONG	ulcRef;


#if !defined(NO_VALIDATION)
	if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, AddRef, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::AddRef() - Bad object passed\n") );
		return 42;
	}
#endif

	UNKOBJ_EnterCriticalSection(lpunkobj);
	ulcRef = ++lpunkobj->ulcRef;
	UNKOBJ_LeaveCriticalSection(lpunkobj);
	return ulcRef;
}



/*============================================================================
 -	UNKOBJ::GetLastError()
 -
 * NOTE!
 *	An error in GetLastError will NOT cause the objects last error to be
 *	set again.  This will allow the caller to retry the call.
 */

STDMETHODIMP
UNKOBJ_GetLastError( LPUNKOBJ			lpunkobj,
					 HRESULT			hrError,
					 ULONG				ulFlags,
					 LPMAPIERROR FAR *	lppMAPIError)
{
	SCODE	sc = S_OK;
	HRESULT	hrLastError;
	IDS		idsLastError;
	LPTSTR	lpszMessage = NULL;
	LPMAPIERROR lpMAPIError = NULL;


#if !defined(NO_VALIDATION)
	if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, GetLastError, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - Bad object passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

    Validate_IMAPIProp_GetLastError(lpunkobj, hrError, ulFlags, lppMAPIError);
#endif

	/* Verify flags.
	 */
	if (ulFlags & ~(MAPI_UNICODE))
	{
		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	*lppMAPIError = NULL;

	/* Get a snapshot of the last error.
	 */
	UNKOBJ_EnterCriticalSection(lpunkobj);
	idsLastError = lpunkobj->idsLastError;
	hrLastError = lpunkobj->hrLastError;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	/* If last error doesn't match parameter or there is no
	 * provider-context specific error string then just succeed.
	 */
	if ((hrError != hrLastError) || !idsLastError)
		goto out;

	/*  Generate new lpMAPIError
	 */
	sc = UNKOBJ_ScAllocate(lpunkobj,
							sizeof(MAPIERROR),
							&lpMAPIError);
	if (FAILED(sc))
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - Unable to allocate memory\n"));
		goto err;
	}

	FillMemory(lpMAPIError, sizeof(MAPIERROR), 0x00);
	lpMAPIError->ulVersion = MAPI_ERROR_VERSION;

	/*	Load a copy of the error string.
	 */
	if ( FAILED(sc = UNKOBJ_ScSzFromIdsAllocMore(lpunkobj,
											 idsLastError,
											 ulFlags,
											 lpMAPIError,
											 cchLastError,
											 &lpszMessage)) )
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - WARNING: Unable to load error string (SCODE = 0x%08lX). Returning hrSuccess.\n"), sc );
		return ResultFromScode(sc);
	}

	lpMAPIError->lpszError = lpszMessage;

	*lppMAPIError = lpMAPIError;

out:

	DebugTraceSc(UNKOBJ_GetLastError, sc);
	return ResultFromScode(sc);

err:
	UNKOBJ_Free( lpunkobj, lpMAPIError );

	goto out;
}


/*
 * UNKOBJ utility functions.
 */


/*============================================================================
 -	UNKOBJ::ScAllocate()
 -
 *		Utility function to allocate memory using MAPI linked memory.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		out		MAPI-Allocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lplpv )
{
	// parameter validation
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
			
	return lpunkobj->pinst->lpfAllocateBuffer(ulcb, lplpv);
}



/*============================================================================
 -	UNKOBJ::ScAllocateMore()
 -
 *		Utility function to allocate more memory using MAPI linked memory.
 *		If the link buffer is null, this function just does a MAPI allocate.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lpv			in		Buffer to link to.
 *		lplpv		out		New buffer
 */

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lplpv )
{
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
			
	return lpv ?
		lpunkobj->pinst->lpfAllocateMore(ulcb, lpv, lplpv) :
		lpunkobj->pinst->lpfAllocateBuffer(ulcb, lplpv) ;
}



/*============================================================================
 -	UNKOBJ::Free()
 -
 *		Utility function to free MAPI linked memory.  NULL buffers are ignored.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lpv			in		Buffer to free.
 */

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv )
{
	// parameter validation
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
			
	if (lpv)
    {
        if (lpv == lpunkobj)
            lpunkobj->lpvtbl = NULL;

		(void) lpunkobj->pinst->lpfFreeBuffer(lpv);
    }
}



/*============================================================================
 -	UNKOBJ::FreeRows()
 -
 *		Frees a row set of the form returned from IMAPITable::QueryRows
 *		(i.e. where the row set and each individual *prop value array*
 *		in that row set are individually allocated with MAPI linked memory.)
 *		NULL row sets are ignored.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lprows		in		Row set to free.
 */

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows )
{
	LPSRow	lprow;

	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( !lprows || !FBadRowSet( lprows ),  TEXT("lprows fails address check") );
	
	if ( !lprows )
		return;

	/* Free each row in the set from last to first.  UNKOBJ_Free
	 * handles NULL pointers.
	 */
	lprow = lprows->aRow + lprows->cRows;
	while ( lprow-- > lprows->aRow )
		UNKOBJ_Free((LPUNKOBJ) lpunkobj, lprow->lpProps);

	UNKOBJ_Free(lpunkobj, lprows);
}



/*============================================================================
 -	UNKOBJ::ScCOAllocate()
 -
 *		Utility function to allocate memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		out		Pointer to allocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
					 ULONG			ulcb,
					 LPVOID FAR *	lplpv )
{
	HLH lhHeap;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );

	/*	If caller _really_ wants a 0 byte allocation, warn
	 *	them and give them back a NULL pointer so that they
	 *	can't dereference it, but should be able to free it.
	 */
	if ( ulcb == 0 )
	{
		DebugTrace(  TEXT("LH_Alloc() - WARNING: Caller requested 0 bytes; returning NULL\n") );
		*lplpv = NULL;
		return S_OK;
	}

	lhHeap = lpunkobj->lhHeap;

	// Enable following section when we fault in the Heap - requires changes
	// throughout where CreateIProp/CreateITable calls are
	// done followed by LH_SetHeapName(). The LH_SetHeapName
	// calls have to be used since we may not have a heap
	// at the time. Furthermore, there is only 1 heap, so
	// they are unnecessary anyway.

#if 1
	if (!lhHeap)
	{
		LPUNKOBJCLASSINST pinst;

		// The UNKOBJ heap *probably* does not exist, make sure
		// (to guard against a race) and create it if indeed so.

		pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();
		Assert(pinst);
		EnterCriticalSection(&pinst->cs);
		if (!pinst->hlh)
		{


			lhHeap = LH_Open(0);
			if (!lhHeap)
			{
				DebugTrace( TEXT("UNKOBJ_ScCOAllocate() - Can't create Local Heap"));
				LeaveCriticalSection(&pinst->cs);
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}

//			DebugTrace( TEXT("Faulting in heap (%8x). UnkObj Inst: %8x"), lhHeap, pinst);

			// Install the heap handle in the global data

			pinst->hlh = lhHeap;
		}
		else
		{
			// The rare event that the heap got created by some other
			// object between our UNKOBJ_Init and this (first) allocation ...
			// ... Take it and use it.

			lhHeap = pinst->hlh;
		}

		LeaveCriticalSection(&pinst->cs);

		// Install the heap handle in this object's internal data too
		// so we don't have to access the instance data for subsequent
		// allocations. This does not need to be crit-sectioned on lpunkobj
		// since an overwrite will be with the same heap!.

		lpunkobj->lhHeap = lhHeap;

		LH_SetHeapName(lhHeap,  TEXT("UNKOBJ Internal Heap"));
	}
#endif

	/* Allocate the buffer.
	 */
	*lplpv = LH_Alloc( lhHeap,(UINT) ulcb );
	if (!*lplpv)
	{
		DebugTrace(  TEXT("LH_Alloc() - OOM allocating *lppv\n") );
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}
	LH_SetName1(lhHeap, *lplpv,  TEXT("UNKOBJ::ScCOAllocate %ld"), *lplpv);

	return S_OK;
}



/*============================================================================
 -	UNKOBJ::ScCOReallocate()
 -
 *		Utility function to reallocate memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		in		Pointer to buffer to reallocate.
 *					out		Pointer to reallocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv )
{
	HLH lhHeap;
	SCODE sc = S_OK;
	LPVOID lpv = NULL;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
	
	lhHeap = lpunkobj->lhHeap;

	// Enable following section when we fault in the Heap - requires changes
	// throughout where CreateIProp/CreateITable calls are
	// done followed by LH_SetHeapName(). The LH_SetHeapName
	// calls have to be used since we may not have a heap
	// at the time. Furthermore, there is only 1 heap, so
	// they are unnecessary anyway.

#if 1
	if (!lhHeap)
	{
		LPUNKOBJCLASSINST pinst;

		// The UNKOBJ heap *probably* does not exist, make sure
		// (to guard against a race) and create it if indeed so.

		pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();
		Assert(pinst);
		EnterCriticalSection(&pinst->cs);
		if (!pinst->hlh)
		{
			lhHeap = LH_Open(0);
			if (!lhHeap)
			{
				DebugTrace( TEXT("UNKOBJ_ScCOReallocate() - Can't create Local Heap"));
				LeaveCriticalSection(&pinst->cs);
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}

//			DebugTrace( TEXT("Faulting in heap (%8x). UnkObj Inst: %8x"), lhHeap, pinst);

			// Install the heap handle in the global data

			pinst->hlh = lhHeap;
		}
		else
		{
			// The rare event that the heap got created by some other
			// object between our UNKOBJ_Init and this (first) allocation ...
			// ... Take it and use it.

			lhHeap = pinst->hlh;
		}

		LeaveCriticalSection(&pinst->cs);

		// Install the heap handle in this object's internal data too
		// so we don't have to access the instance data for subsequent
		// allocations. This does not need to be crit-sectioned on lpunkobj
		// since an overwrite will be with the same heap!.

		lpunkobj->lhHeap = lhHeap;

		LH_SetHeapName(lhHeap,  TEXT("UNKOBJ Internal Heap"));
	}	
#endif

//$BUG	Actually, the CO model is supposed do an Alloc() if
//$BUG	the pointer passed in is NULL, but it currently
//$BUG	doesn't seem to work that way....
	if ( *lplpv == NULL )
	{
		lpv = LH_Alloc(lhHeap, (UINT) ulcb);
		if (lpv)
		{
			*lplpv = lpv;
			LH_SetName1(lhHeap, lpv,  TEXT("UNKOBJ::ScCOReallocate %ld"), lpv);
		}
		else
			sc = E_OUTOFMEMORY;
		
		goto out;
	}

	/* Reallocate the buffer.
	 */
	lpv = LH_Realloc(lhHeap, *lplpv, (UINT) ulcb );
	if (!lpv)
	{
		DebugTrace(  TEXT("UNKOBJ::ScCOReallocate() - OOM reallocating *lplpv\n") );
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto out;
	}

	LH_SetName1(lhHeap, lpv,  TEXT("UNKOBJ::ScCOReallocate %ld"), lpv);
	*lplpv = lpv;

out:
	return sc;
}



/*============================================================================
 -	UNKOBJ::COFree()
 -
 *		Utility function to free memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lpv			in		Buffer to free.
 */

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			   LPVOID	lpv )
{
	HLH lhHeap;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	lhHeap = lpunkobj->lhHeap;
	
	/*	Free the buffer.
	 */
//$???	Don't know if CO properly handles freeing NULL pointers,
//$???	but I assume it doesn't....
	if ( lpv != NULL )
		LH_Free( lhHeap, lpv );
}



/*============================================================================
 -	UNKOBJ::ScSzFromIdsAlloc()
 -
 *		Utility function load a resource string into a MAPI-allocated buffer.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ids			in		ID of resource string.
 *		ulFlags		in		Flags (UNICODE or ANSI)
 *		cchBuf		in		Max length, in characters, to read.
 *		lpszBuf		out		Pointer to allocated buffer containing string.
 */

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lppszBuf )
{
	SCODE	sc;
	ULONG	ulStringMax;


	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lppszBuf && !IsBadWritePtr( lppszBuf, sizeof( LPVOID ) ),
			 TEXT("lppszBuf fails address check") );
	
	AssertSz( cchBuf > 0,  TEXT("cchBuf can't be less than 1") );

	ulStringMax =  cchBuf
				 * ((ulFlags & MAPI_UNICODE) ? sizeof(TCHAR) : sizeof(CHAR));
	if ( FAILED(sc = UNKOBJ_ScAllocate(lpunkobj,
									   ulStringMax,
									   (LPVOID FAR *) lppszBuf)) )
	{
		DebugTrace(  TEXT("UNKOBJ::ScSzFromIdsAlloc() - Error allocating string (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

#if !defined(WIN16) && !defined(MAC)
	if ( ulFlags & MAPI_UNICODE )
		(void) LoadStringW(hinstMapiX,
						   (UINT) ids,
						   (LPWSTR) *lppszBuf,
						   cchBuf);
	else
#endif
		(void) LoadStringA(hinstMapiX,
						   (UINT) ids,
						   (LPSTR) *lppszBuf,
						   cchBuf);
	return S_OK;
}

/*============================================================================
 -	UNKOBJ::ScSzFromIdsAllocMore()
 -
 *		Utility function load a resource string into a MAPI-allocated buffer.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ids			in		ID of resource string.
 *		ulFlags		in		Flags (UNICODE or ANSI)
 *		lpvBase		in		Base allocation
 *		cchBuf		in		Max length, in characters, to read.
 *		lpszBuf		out		Pointer to allocated buffer containing string.
 */

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf )
{
	SCODE	sc;
	ULONG	ulStringMax;


	ulStringMax =  cchBuf
				 * ((ulFlags & MAPI_UNICODE) ? sizeof(WCHAR) : sizeof(CHAR));
	if ( FAILED(sc = UNKOBJ_ScAllocateMore(lpunkobj,
									   ulStringMax,
									   lpvBase,
									   (LPVOID FAR *) lppszBuf)) )
	{
		DebugTrace(  TEXT("UNKOBJ::ScSzFromIdsAllocMore() - Error allocating string (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

#if !defined(WIN16) && !defined(MAC)
	if ( ulFlags & MAPI_UNICODE )
		(void) LoadStringW(hinstMapiX,
						   (UINT) ids,
						   (LPWSTR) *lppszBuf,
						   cchBuf);
	else
#endif
		(void) LoadStringA(hinstMapiX,
						   (UINT) ids,
						   (LPSTR) *lppszBuf,
						   cchBuf);
	return S_OK;
}

/*============================================================================
 -	UNKOBJ::Init()
 -
 *		Initialize an object of the UNKOBJ Class
 *
 *
 *	Parameters:
 *		lpunkobj		in		UNKOBJ with instance variable containing
 *								allocators.
 *		lpvtblUnkobj	in		the object v-table
 *		ulcbVtbl		in		size of the object v-table
 *		rgpiidList		in		list of iid's supported by this object
 *		ulcIID			in		count of iid's in the list above
 *		punkinst		in		pointer to object's private (instance) data
 */

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst )
{
	SCODE	sc = S_OK;
	LPUNKOBJCLASSINST 	pinst = NULL;

	// Create/Get per process global data for the Unkobj class
	// This gets faulted in the first time UNKOBJ_Init
	// is called by the process, i.e., when the process creates
	// its first Unkobj. Subsequent calls just Addref
	// the instance data. Note that this data is global to all
	// UNKOBJ objects (per process) and differs from the per object
	// data that *each* Unkobj keeps.

	sc = ScGetUnkClassInst(&pinst);
	if (FAILED(sc))
	{
		DebugTrace( TEXT("UNKOBJ_Init() - Can't create Instance Data"));
		goto ret;
	}

	Assert(pinst);

	lpunkobj->lpvtbl	= lpvtblUnkobj;
	lpunkobj->ulcbVtbl	= ulcbVtbl;
	lpunkobj->ulcRef	= 1;
	lpunkobj->rgpiidList= rgpiidList;
	lpunkobj->ulcIID	= ulcIID;
	lpunkobj->pinst		= punkinst;
	lpunkobj->hrLastError	= hrSuccess;
	lpunkobj->idsLastError	= 0;

	InitializeCriticalSection(&lpunkobj->csid);
	
	// If we have a heap for this instance, use it;
	// otherwise, wait and it'll get faulted in the first time
	// and allocation is made on this object.

	lpunkobj->lhHeap = pinst->hlh ? pinst->hlh : NULL;

ret:
	return sc;
}

/*============================================================================
 -	UNKOBJ::Deinit()
 -
 *		Deinitialize an object of the UNKOBJ Class
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 */

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj )
{
	// Cleanup per process global data for the Unkobj class,
	// if necessary. Last one out will end up shutting off
	// the lights.

	ReleaseUnkClassInst();

	DeleteCriticalSection(&lpunkobj->csid);
}

#ifdef WIN16
// Win16 version of inline function. These are no longer inline function because
// Watcom WCC doesn't support inline. (WPP(C++ compiler) support inline.
VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
    EnterCriticalSection(&lpunkobj->csid);
}

VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
    LeaveCriticalSection(&lpunkobj->csid);
}

HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ    lpunkobj,
                        HRESULT        hResult,
                        IDS            idsError )
{
    UNKOBJ_EnterCriticalSection(lpunkobj);
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
    UNKOBJ_LeaveCriticalSection(lpunkobj);

    return hResult;
}

HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ    lpunkobj,
                       SCODE    sc,
                       IDS        idsError )
{
    UNKOBJ_EnterCriticalSection(lpunkobj);
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
    UNKOBJ_LeaveCriticalSection(lpunkobj);

    return ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastError( LPUNKOBJ    lpunkobj,
                     SCODE        sc,
                     IDS        idsError )
{
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ    lpunkobj,
                       SCODE    sc )
{
    lpunkobj->hrLastError = ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ    lpunkobj,
                        IDS            ids )
{
    lpunkobj->idsLastError = ids;
}
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\unkobj.h ===
/*
 *	U N K O B J . H
 *
 * This is a generic definition of the IUnknown (plus GetLastError) part
 * of objects that are derived from IUnknown with GetLastError.
 *
 * Used in:
 * IPROP
 *
 */

// #include <_glheap.h>


typedef struct _UNKOBJ FAR *	LPUNKOBJ;

/* The instance portion of UNKOBJ structure members.
 */
typedef struct _UNKINST
{
	LPALLOCATEBUFFER	lpfAllocateBuffer;
	LPALLOCATEMORE		lpfAllocateMore;
	LPFREEBUFFER		lpfFreeBuffer;
	LPMALLOC			lpmalloc;
	HINSTANCE			hinst;

} UNKINST, * PUNKINST;

typedef ULONG	IDS;

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 * Vtable alignment
 */
#ifndef VTABLE_FILL
#ifdef MAC
#define VTABLE_FILL		NULL,
#else
#define VTABLE_FILL
#endif
#endif

/*============================================================================
 *
 *	UNKOBJ (IUnknown) Class
 */

#define	cchLastError	1024

#define MAPI_IMAPIUNKNOWN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\

#undef	INTERFACE
#define	INTERFACE	struct _UNKOBJ

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	UNKOBJ_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,UNKOBJ_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIUNKNOWN_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(UNKOBJ_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIUNKNOWN_METHODS(IMPL)
};

#define	UNKOBJ_MEMBERS					\
	ULONG				ulcbVtbl;		\
	ULONG				ulcRef;			\
	LPIID FAR *			rgpiidList;		\
	ULONG				ulcIID;			\
	CRITICAL_SECTION	csid;			\
	UNKINST *			pinst;			\
	HRESULT				hrLastError;	\
	IDS					idsLastError;	\
	HLH					lhHeap

typedef struct _UNKOBJ
{
	UNKOBJ_Vtbl FAR *	lpvtbl;
	UNKOBJ_MEMBERS;

} UNKOBJ;



#ifndef WIN16
__inline VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

__inline VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}

__inline HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ	lpunkobj,
						HRESULT		hResult,
						IDS			idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return hResult;
}

__inline HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ	lpunkobj,
					   SCODE	sc,
					   IDS		idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastError( LPUNKOBJ	lpunkobj,
					 SCODE		sc,
					 IDS		idsError )
{
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ	lpunkobj,
					   SCODE	sc )
{
	lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ	lpunkobj,
						IDS			ids )
{
	lpunkobj->idsLastError = ids;
}
#else  // !WIN16
// !!! Watcom C compiler does not support inline.
// The functions are defined in UNKOBJ.C
VOID UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj );
VOID UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj );
HRESULT UNKOBJ_HrSetLastResult( LPUNKOBJ lpunkobj, HRESULT hResult, IDS idsError );
HRESULT UNKOBJ_HrSetLastError( LPUNKOBJ lpunkobj, SCODE sc, IDS idsError );
VOID UNKOBJ_SetLastError( LPUNKOBJ lpunkobj, SCODE sc, IDS idsError );
VOID UNKOBJ_SetLastErrorSc( LPUNKOBJ lpunkobj, SCODE sc );
VOID UNKOBJ_SetLastErrorIds( LPUNKOBJ lpunkobj, IDS ids );
#endif // !WIN16

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst );

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj );

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lppv );

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows );


STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );


STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv );

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );



STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lpszBuf );

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf );


/* These should be moved to a more useful (generic) location (mapidefs.h?).
 */

#ifdef WIN16

/* IsEqualGUID is used to eliminate dependency on compob(j/32).lib. This
 * is only necessary on WIN16 because all other platforms define this
 * already. (see objbase.h)
 */
#define IsEqualGUID(a, b)			(memcmp((a), (b), sizeof(GUID)) == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\useragnt.h ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by Outlook Express
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#ifndef _USERAGNT_H
#define _USERAGNT_H

void InitWABUserAgent(BOOL fInit);

LPSTR GetWABUserAgentString(void);

#endif // _USERAGNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_srch.c ===
/*--------------------------------------------------------------
*
*
*   ui_srch.c - contains stuff for showing the WAB search dialog
*               with LDAP Search and Local Search
*
*
*
*
*
*  9/96 - created VikramM
--------------------------------------------------------------*/
#include "_apipch.h"

#define CONTROL_SPACE   7 //pixels
#define BORDER_SPACE  11 //pixels

typedef struct _ServerDat
{
    HIMAGELIST himl;
    SBinary SB;
} SERVERDAT, * LPSERVERDAT;

enum
{ 
    IS_LDAP = 0,
    IS_PAB,
    IS_OLK,
    IS_ERR
};

enum
{
    tabSimple=0,
    tabAdvanced,
    tabMax
};

// Structure passed to Search Dialog Proc
typedef struct _FindParams
{
    LDAP_SEARCH_PARAMS LDAPsp;
    SORT_INFO SortInfo;
    LPRECIPIENT_INFO lpContentsList;
    LPADRPARM_FINDINFO lpAPFI;
    BOOL bShowFullDialog; // Determines whether to show the full dialog or the truncated dialog
    BOOL bLDAPActionInProgress;
    LPLDAPURL lplu;
    BOOL bInitialized;
    BOOL bUserCancel;
    int MinDlgWidth;
    int MinDlgHeight;
    int MinDlgHeightWithResults;
} WAB_FIND_PARAMS, * LPWAB_FIND_PARAMS;


// Search dialog control arrays
int rgAdrParmButtonID[] =
{
    IDC_FIND_BUTTON_TO,
    IDC_FIND_BUTTON_CC,
    IDC_FIND_BUTTON_BCC
};

int rgAdvancedButtons[] = 
{
    IDC_FIND_BUTTON_ADDCONDITION,
    IDC_FIND_BUTTON_REMOVECONDITION
};

int rgSearchEditID[] =
{
    IDC_FIND_EDIT_NAME,
    IDC_FIND_EDIT_EMAIL,
    IDC_FIND_EDIT_STREET,
    IDC_FIND_EDIT_PHONE,
    IDC_FIND_EDIT_ANY,
};
#define SEARCH_EDIT_MAX 5 //sync with above array

/*
*   Prototypes
*/

// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A    gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W    gpfnImageList_LoadImageW;

extern LPIMAGELIST_DESTROY      gpfnImageList_Destroy;
extern LPIMAGELIST_DRAW         gpfnImageList_Draw;

extern BOOL bIsHttpPrefix(LPTSTR szBuf);
extern const LPTSTR  lpszRegFindPositionKeyValueName;
extern BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType);
extern HRESULT LDAPSearchWithoutContainer(HWND hWnd, LPLDAPURL lplu,
			   LPSRestriction  lpres,
			   LPTSTR lpAdvFilter,
			   BOOL bReturnSinglePropArray,
               ULONG ulFlags,
			   LPRECIPIENT_INFO * lppContentsList,
			   LPULONG lpulcProps,
			   LPSPropValue * lppPropArray);
extern HRESULT HrGetLDAPSearchRestriction(LDAP_SEARCH_PARAMS LDAPsp, LPSRestriction lpSRes);

#ifdef PAGED_RESULT_SUPPORT
extern BOOL bMorePagedResultsAvailable();
extern void ClearCachedPagedResultParams();
#endif //#ifdef PAGED_RESULT_SUPPORT


int ComboAddItem(HWND hWndLV, LPTSTR lpszItemText, LPARAM lParam, LPTSTR szPref, int * lpnStart, BOOL * lpbAddedPref);
INT_PTR CALLBACK fnSearch( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void UpdateButtons(HWND hDlg, HWND hWndLVResults, HWND hWndLV, LPLDAPURL lplu);
//HRESULT HrInitServerListLV(HWND hWndLV);
LRESULT ProcessLVMessages(HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam);
LRESULT ProcessLVResultsMessages(HWND   hWnd,
				 UINT   uMsg,
				 WPARAM   wParam,
				 LPARAM lParam,
				 LPWAB_FIND_PARAMS lpWFP);
BOOL DoTheSearchThing(HWND hDlg, LPWAB_FIND_PARAMS lpWFP);
void SaveFindWindowPos(HWND hWnd, LPIAB lpIAB);
int CurrentContainerIsPAB(HWND hWndLV);

static const LPTSTR szKeyLastFindServer = TEXT("Software\\Microsoft\\WAB\\WAB4\\LastFind");
static const LPTSTR c_tszPolicyPrefAccount = TEXT("Software\\Policies\\Microsoft\\Internet Account Manager\\Account Pref");


/***/
static DWORD rgSrchHelpIDs[] =
{
    IDC_FIND_STATIC_FINDIN,         IDH_WAB_DIR_SER_LIST,
    IDC_FIND_COMBO_LIST,            IDH_WAB_DIR_SER_LIST,
    IDC_FIND_STATIC_NAME,           IDH_WAB_FIND_FIRST,
    IDC_FIND_EDIT_NAME,             IDH_WAB_FIND_FIRST,
    IDC_FIND_STATIC_EMAIL,          IDH_WAB_FIND_E_MAIL,
    IDC_FIND_EDIT_EMAIL,            IDH_WAB_FIND_E_MAIL,
    IDC_FIND_STATIC_STREET,         IDH_WAB_FIND_ADDRESS,
    IDC_FIND_EDIT_STREET,           IDH_WAB_FIND_ADDRESS,
    IDC_FIND_STATIC_PHONE,          IDH_WAB_FIND_PHONE,
    IDC_FIND_EDIT_PHONE,            IDH_WAB_FIND_PHONE,
    IDC_FIND_STATIC_ANY,            IDH_WAB_FIND_OTHER,
    IDC_FIND_EDIT_ANY,              IDH_WAB_FIND_OTHER,
    IDC_FIND_BUTTON_FIND,           IDH_WAB_FIND_FINDNOW,
    IDC_FIND_BUTTON_CLEAR,          IDH_WAB_FIND_CLEARALL,
    IDC_FIND_BUTTON_CLOSE,          IDH_WAB_FIND_CLOSE,
    IDC_FIND_LIST_RESULTS,          IDH_WAB_FIND_RESULTS,
    IDC_FIND_BUTTON_PROPERTIES,     IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_FIND_BUTTON_DELETE,         IDH_WAB_FIND_DELETE,
    IDC_FIND_BUTTON_ADDTOWAB,       IDH_WAB_FIND_ADD2WAB,
    IDC_FIND_BUTTON_TO,             IDH_WAB_PICK_RECIP_NAME_TO_BUTTON,
    IDC_FIND_BUTTON_CC,             IDH_WAB_PICK_RECIP_NAME_CC_BUTTON,
    IDC_FIND_BUTTON_BCC,            IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON,
    IDC_TAB_FIND,                   IDH_WAB_COMM_GROUPBOX,
    IDC_FIND_BUTTON_SERVER_INFO,    IDH_WAB_VISITDS_BUTTON,
    IDC_FIND_BUTTON_STOP,           IDH_WAB_FIND_STOP,
    IDC_FIND_STATIC_ADVANCED,       IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_COMBO_FIELD,           IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_COMBO_CONDITION,       IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_EDIT_ADVANCED,         IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_LIST_CONDITIONS,       IDH_WAB_FIND_ADV_CRITERIA_DISPLAY,
    IDC_FIND_BUTTON_ADDCONDITION,   IDH_WAB_FIND_ADV_CRITERIA_ADD,
    IDC_FIND_BUTTON_REMOVECONDITION,IDH_WAB_FIND_ADV_CRITERIA_REMOVE,
    0,0
};


/*
-
- ShowHideMoreResultsButton
*
*   This is called to show the MORE RESULTS button whenever
*   a paged result was done and a Cookie was cached
*   The button is hidden whenever search parameters change
*
*/
void ShowHideMoreResultsButton(HWND hDlg, BOOL bShow)
{
    HWND hWnd = GetDlgItem(hDlg, IDC_FIND_BUTTON_MORE);
    EnableWindow(hWnd, bShow);
    ShowWindow(hWnd, bShow ? SW_NORMAL : SW_HIDE);
}


/***/
/*
-   ResizeSearchDlg
-
*
*/
void ResizeSearchDlg(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{
	// resize the dialog to show the full results and let the user
	// resize it henceforth without restriction
	RECT rc;
    HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);

	GetWindowRect(hDlg, &rc);
	lpWFP->bShowFullDialog = TRUE;
	SetWindowPos(hDlg, HWND_TOP, rc.left, rc.top,
			rc.right - rc.left, lpWFP->MinDlgHeightWithResults, 
			SWP_NOMOVE | SWP_NOZORDER);
	SetColumnHeaderBmp( hWndLVResults, lpWFP->SortInfo);

    // Also set the WS_TABSTOP style on the results Listview once the dialog is
    // expanded 
    {
	    DWORD dwStyle = GetWindowLong(hWndLVResults, GWL_STYLE);
	    dwStyle |= WS_TABSTOP;
	    SetWindowLong(hWndLVResults, GWL_STYLE, dwStyle);
    }
}

//$$///////////////////////////////////////////////////////////////////////////
//
// AddTabItem
//
////////////////////////////////////////////////////////////////////////////////
void AddTabItem(HWND hDlg, int nIndex)
{
    HWND hWndTab = GetDlgItem(hDlg, IDC_TAB_FIND);
    TC_ITEM tci ={0};
    TCHAR sz[MAX_PATH];
    LoadString(hinstMapiX, idsFindTabTitle+nIndex, sz, CharSizeOf(sz));
    tci.mask = TCIF_TEXT;
    tci.pszText = sz;
    tci.cchTextMax = lstrlen(sz)+1;
    TabCtrl_InsertItem(hWndTab, nIndex, &tci);
}

//$$////////////////////////////////////////////////////////////////////////////
//
// Gets the text of the currently selected item in the combo .. defaults to 
// item 0 if no selection
//
// szBuf should be a large enough predefined buffer
//
////////////////////////////////////////////////////////////////////////////////
void GetSelectedText(HWND hWndCombo, LPTSTR * lppBuf)
{
    int iItemIndex = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    int nLen = 0;

    if(!lppBuf)
	return;
    
    if(iItemIndex == CB_ERR)
    {
        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
        iItemIndex = 0;
    }

    nLen = (int) SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM) iItemIndex, 0);

    if(!nLen || nLen==CB_ERR)
        nLen = MAX_PATH*2;

    *lppBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen+1));
    
    if(*lppBuf)
    {
        lstrcpy(*lppBuf, szEmpty);
        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) iItemIndex, (LPARAM) *lppBuf);
    }
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// hrShowSearchDialog - wrapper for Search UI
//
// lpAPFI - is a special structure passed in by the select recipients dialog
//  that enables us to add memebers to the select recipients dialog from the
//  find dialog
//
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowSearchDialog(LPADRBOOK lpAdrBook,
		   HWND hWndParent,
		   LPADRPARM_FINDINFO lpAPFI,
	       LPLDAPURL lplu,
	       LPSORT_INFO lpSortInfo)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    HRESULT hr = hrSuccess;
    int nRetVal = SEARCH_ERROR;
    WAB_FIND_PARAMS fp = {0};

    InitLDAPClientLib();

    fp.lpContentsList = NULL;

    if(!lpSortInfo)
    	ReadRegistrySortInfo(lpIAB, &(fp.SortInfo));
    else
    	fp.SortInfo = *lpSortInfo;

#ifndef WIN16 // Disable until ldap16.dll is available.
    if(!lplu)   //dont want anything filled in if this was a ldapurl thing
	fp.LDAPsp = pt_LDAPsp;
    fp.LDAPsp.lpIAB = lpAdrBook;
#endif

    fp.lpAPFI = lpAPFI;
    fp.lplu = lplu;

    if(lplu)
    {
	    if(lplu->lpList)
	        fp.bShowFullDialog = TRUE;
    }
    fp.bLDAPActionInProgress = FALSE;

    nRetVal = (int) DialogBoxParam(
		    hinstMapiX,
		    MAKEINTRESOURCE(IDD_DIALOG_FIND),
		    hWndParent,
		    (DLGPROC) fnSearch,
		    (LPARAM) &fp);

#ifndef WIN16 // Disable until ldap16.dll is available.
    pt_LDAPsp = fp.LDAPsp;
#endif

	if(lpAPFI)
        lpAPFI->nRetVal = nRetVal;

    switch(nRetVal)
    {
    case SEARCH_CANCEL:
	    hr = MAPI_E_USER_CANCEL;
	    break;
	case SEARCH_CLOSE:
    case SEARCH_OK:
	case SEARCH_USE:
	    hr = S_OK;
	    break;
    case SEARCH_ERROR:
	    hr = E_FAIL;
	    break;
    }

    if(fp.lpContentsList)
    {
		LPRECIPIENT_INFO lpItem;
		lpItem = fp.lpContentsList;
		while(lpItem)
		{
			fp.lpContentsList = lpItem->lpNext;
			FreeRecipItem(&lpItem);
			lpItem = fp.lpContentsList;
		}
		fp.lpContentsList = NULL;
	}

    DeinitLDAPClientLib();

    return hr;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// SetEnableDisableUI - shows/hides edit fields based on whether selected item
//                       in the list view is WAB or Directory Service
//
//  hDlg - Parent dialog
//  hWndLV - List View
//
////////////////////////////////////////////////////////////////////////////////
void SetEnableDisableUI(HWND hDlg, HWND hWndCombo, LPLDAPURL lplu, int nTab)
{
    BOOL bIsWAB = FALSE, bHasLogo = FALSE;
    int swShowSimple, swShowSimpleWAB, swShowAdvanced;
    ULONG cbEID;
    LPENTRYID lpEID;

    // Just in case the list view lost its selection,
    // dont modify the UI


    if(!lplu && (CurrentContainerIsPAB(hWndCombo) != IS_LDAP))
        bIsWAB = TRUE;

    swShowSimple = (nTab == tabSimple) ? SW_SHOWNORMAL : SW_HIDE;
    swShowSimpleWAB = (nTab == tabSimple && bIsWAB) ? SW_SHOWNORMAL : SW_HIDE;
    swShowAdvanced = (nTab == tabAdvanced) ? SW_SHOWNORMAL : SW_HIDE;

    // Show / Hide the simple tab elements based on what this is
    //
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_NAME), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_NAME), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_EMAIL), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_EMAIL), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_STREET), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_STREET), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_PHONE), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_PHONE), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_ANY), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_ANY), swShowSimpleWAB);


    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_STREET), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_STREET), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_PHONE), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_PHONE), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_ANY), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_ANY), bIsWAB);


    // Show / Hide the advanced tab elements based on what this is
    //
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), swShowAdvanced);

    // Turn off advanced searching for WAB
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), !bIsWAB);


    if (! bIsWAB) 
    { // This is an LDAP container
	    LDAPSERVERPARAMS lsp = {0};
	    ULONG iItemIndex;
        LPTSTR lpBuf = NULL;

	    // Does it have a URL registered?
	    // Get the LDAP server properties for the selected container

        GetSelectedText(hWndCombo, &lpBuf);

        GetLDAPServerParams(lpBuf, &lsp);

    	if( nTab == tabSimple &&
            lsp.lpszLogoPath && lstrlen(lsp.lpszLogoPath) &&
	        GetFileAttributes(lsp.lpszLogoPath) != 0xFFFFFFFF )
        {
            HANDLE hbm = LoadImage( hinstMapiX, lsp.lpszLogoPath,
			            IMAGE_BITMAP, 134,38,
			            LR_LOADFROMFILE  | LR_LOADMAP3DCOLORS); //| LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS); //LR_DEFAULTCOLOR);
            if(hbm)
            {
                SendDlgItemMessage(hDlg, IDC_FIND_STATIC_LOGO, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) hbm);
                bHasLogo = TRUE;
            }
        }


        if (lsp.lpszURL && lstrlen(lsp.lpszURL) && bIsHttpPrefix(lsp.lpszURL)) 
	        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), TRUE);
        else
	        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), FALSE);

        FreeLDAPServerParams(lsp);

        if(lpBuf)
	        LocalFree(lpBuf);
    }
    else
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), FALSE);

    ShowWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_LOGO), (bHasLogo ? SW_SHOW : SW_HIDE));

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// SetSearchUI - Sets up the Search UI
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetSearchUI(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
			SetChildDefaultGUIFont,
			(LPARAM) 0);

    // Set the title on the TAB
    AddTabItem(hDlg, tabSimple);
    AddTabItem(hDlg, tabAdvanced);

    //
    // Set the max text length of all the edit boxes to MAX_UI_STR
    //
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
        SendMessage(GetDlgItem(hDlg,rgSearchEditID[i]),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-16,0);
    }
    SendMessage(GetDlgItem(hDlg,IDC_FIND_EDIT_ADVANCED),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-16,0);


    HrInitListView( GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
					LVS_REPORT,
					TRUE);

    {
        HWND hWndAnim = GetDlgItem(hDlg, IDC_FIND_ANIMATE1);
        if(Animate_Open(hWndAnim, MAKEINTRESOURCE(IDR_AVI_WABFIND)))
        {
	        if(Animate_Play(hWndAnim, 0, 1, 0))
	        Animate_Stop(hWndAnim);
        }
    }

    // Set the to, cc, bcc buttons appropriately
    if(lpWFP->lpAPFI)
    {
	    // if this pointer is not null then we were called by a select recipients dlg
	    if(lpWFP->lpAPFI->lpAdrParms)
	    {
            LPADRPARM lpAdrParms = lpWFP->lpAPFI->lpAdrParms;
            ULONG i;

			// If this is called from the PickUser dialog, then the results list view
			// needs to be single select
			if(lpWFP->lpAPFI->DialogState == STATE_PICK_USER)
			{
				HWND hWndLV = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
				DWORD dwStyle= GetWindowLong(hWndLV , GWL_STYLE);
				SetWindowLong(hWndLV , GWL_STYLE, dwStyle | LVS_SINGLESEL);
			}

            for(i=0;i < lpAdrParms->cDestFields; i++)
            {
	            HWND hWndButton = GetDlgItem(hDlg, rgAdrParmButtonID[i]);
	            ShowWindow(hWndButton, SW_NORMAL);
	            EnableWindow(hWndButton, TRUE);
	            if(lpAdrParms->lppszDestTitles)
	            {
                    LPTSTR lpTitle = (lpAdrParms->ulFlags & MAPI_UNICODE) ?
                                        (LPWSTR)lpAdrParms->lppszDestTitles[i] :
                                         ConvertAtoW((LPSTR)lpAdrParms->lppszDestTitles[i]);          
                    if(lpTitle)
                    {
		                ULONG Len = lstrlen(lpTitle);
		                TCHAR szBuf[32];
		                if (Len > CharSizeOf(szBuf) - 4)
		                {
			                ULONG iLen = TruncatePos(lpTitle, CharSizeOf(szBuf) - 4);
			                CopyMemory(szBuf,lpTitle, iLen*sizeof(TCHAR));
			                szBuf[iLen] = '\0';
		                }
		                else
			                lstrcpy(szBuf,lpTitle);
		                lstrcat(szBuf,szArrow);
		                SetWindowText(hWndButton, szBuf);
                        if(lpTitle != lpAdrParms->lppszDestTitles[i]) 
                            LocalFreeAndNull(&lpTitle);
                    }
	            }
            }
	    }
    }

    
    if(ReadRegistryPositionInfo((LPIAB)lpWFP->LDAPsp.lpIAB, &ABPosColSize, lpszRegFindPositionKeyValueName))
    {
        if( IsWindowOnScreen( &ABPosColSize.rcPos) )                      
        {
            int nW = ABPosColSize.rcPos.right-ABPosColSize.rcPos.left;
            MoveWindow(hDlg,
                ABPosColSize.rcPos.left,
                ABPosColSize.rcPos.top,
                (nW < lpWFP->MinDlgWidth) ? lpWFP->MinDlgWidth : nW,
                lpWFP->MinDlgHeight, 
                FALSE);
        }
    }
    else
    {
	    MoveWindow(hDlg,
		   20,
		   20,
		   lpWFP->MinDlgWidth, 
		   lpWFP->MinDlgHeight, 
		   FALSE);
    }

    if(ABPosColSize.nTab > tabMax)
        ABPosColSize.nTab = tabSimple;

    TabCtrl_SetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND), ABPosColSize.nTab);


    if(lpWFP->bShowFullDialog)
        ResizeSearchDlg(hDlg, lpWFP);

    {
	    TCHAR szBuf[MAX_PATH];
	    LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, CharSizeOf(szBuf));
	    SetWindowText(hDlg, szBuf);
    }

    ImmAssociateContext(GetDlgItem(hDlg, IDC_FIND_EDIT_PHONE), (HIMC)NULL);   
    
    return TRUE;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// ClearFieldCombo - Clears any allocated memory in the Advanced Field Combo
//
/////////////////////////////////////////////////////////////////////////////////
void ClearFieldCombo(HWND hWndCombo)
{
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    LPTSTR lp = NULL;
    if(!nCount || nCount == CB_ERR)
        return;

    if(nCount >= LDAPFilterFieldMax)
    {
        // Get the item behind the first element
        // This item is a pointer to an allocated string
        lp = (LPTSTR) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) LDAPFilterFieldMax, 0);
        if(lp && (CB_ERR != (ULONG_PTR)lp))
	        LocalFreeAndNull(&lp);
    }
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// FillAdvancedFieldCombos - Fills the Search UI with various information
//
/////////////////////////////////////////////////////////////////////////////////
void FillAdvancedFieldCombos(HWND hDlg, HWND hWndComboContainer)
{
    // The 2 advanced tab combos have data based on the current container ..
    // Hence need the CurrentContainerInfo here...
    BOOL bIsPAB =  (CurrentContainerIsPAB(hWndComboContainer) != IS_LDAP);
    HWND hWndComboField = GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD);
    HWND hWndComboCondition = GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION);
    int i = 0, nPos = 0, nMax = 0;
    TCHAR sz[MAX_PATH];

    ClearFieldCombo(hWndComboField);
    SendMessage(hWndComboCondition, CB_RESETCONTENT, 0, 0);

    {
        HWND hWndTab = GetDlgItem(hDlg, IDC_TAB_FIND);
        if(bIsPAB)
        {
	        TabCtrl_SetCurSel(hWndTab, tabSimple);
	        TabCtrl_DeleteItem(GetDlgItem(hDlg,IDC_TAB_FIND), tabAdvanced);
        }
        else
        {
	        if(TabCtrl_GetItemCount(hWndTab) < tabMax)
	        AddTabItem(hDlg, tabAdvanced);
        }
    }

    // If this is the WAB only give the "contains" option
    nMax = bIsPAB ? 1 : LDAPFilterOptionMax;

    for(i=0;i<nMax;i++)
    {
        LoadString(hinstMapiX, idsLDAPFilterOption1+i, sz, CharSizeOf(sz));
        nPos = (int) SendMessage(hWndComboCondition, CB_ADDSTRING, 0, (LPARAM) sz);
    }

    // Now add the default set of searchable attributes
    {
        LPTSTR lp = NULL;
        // If this is the WAB only give the Name and E-Mail option
        nMax = bIsPAB ? 2 : LDAPFilterFieldMax;

        for(i=0;i<nMax;i++)
        {
	        LoadString(hinstMapiX, idsLDAPFilterField1+i, sz, CharSizeOf(sz));
	        nPos = (int) SendMessage(hWndComboField, CB_ADDSTRING, 0, (LPARAM) sz);
	        SendMessage(hWndComboField, CB_SETITEMDATA, (WPARAM) nPos, (LPARAM) g_rgszAdvancedFindAttrs[i]);
        }
    }

    // Check if this server has advanced Search attributes registered
    if(!bIsPAB)
    {
        LDAPSERVERPARAMS lsp = {0};
        LPTSTR lpBuf = NULL;

        GetSelectedText(hWndComboContainer, &lpBuf);
        GetLDAPServerParams(lpBuf, &lsp);
        if(lpBuf)
            LocalFree(lpBuf);

        if(lsp.lpszAdvancedSearchAttr && *(lsp.lpszAdvancedSearchAttr))
        {
            // we need to use this advanced search attributes
            LPTSTR  lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lsp.lpszAdvancedSearchAttr)+1));
            LPTSTR  lpAttr = NULL, lpName = NULL;
            BOOL    bAssigned = FALSE;

            if(!lp)
                return;
            lstrcpy(lp, lsp.lpszAdvancedSearchAttr);

            // Attribute format is:
            // Attribute-Display-Name:Attribute,Attribute-Display-Name:Attribute, etc
            // e.g.
            // co:Company,cn:Common Name,etc
            //
            // So we will parse this string and feed it into the combo
            lpAttr = lp;
            while(*lpAttr)
            {
                LPTSTR lpTemp = lpAttr;
                while(*lpTemp && *lpTemp != ':')
	                lpTemp++;
                if(*lpTemp != ':')
	                break;
                lpName = lpTemp+1;
                *lpTemp = '\0';
                lpTemp = lpName;
                while(*lpTemp && *lpTemp != ',')
	                lpTemp++;
                if(*lpTemp == ',')
                {
	                *lpTemp = '\0';
	                lpTemp++;
                }

	            // Note that the LDAPFilterFieldMax-th item in the list will point to the allocated
	            // String 'lp'
	            // Hence to clean up we only need to free this item in the combo
                // [PaulHi] 3/4/99  Memory leak fix and @todo
                // Why not just make a copy of g_rgszAdvancedFindAttrs so
                // that special cases like these can be added?
	            nPos = (int) SendMessage(hWndComboField, CB_ADDSTRING, 0, (LPARAM) lpName);
	            SendMessage(hWndComboField, CB_SETITEMDATA, (WPARAM) nPos, (LPARAM) lpAttr);
                bAssigned = TRUE;

                lpAttr = lpTemp;
            }

            // [PaulHi] 3/4/99  Memory leak fix.  If this lp pointer isn't passed to the hWndComboField
            // combo box, for whatever reason, we need to deallocate it here.
            if (!bAssigned)
                LocalFreeAndNull(&lp);
	    }
    	FreeLDAPServerParams(lsp);
    }

    SendMessage(hWndComboField, CB_SETCURSEL, 0, 0);
    SendMessage(hWndComboCondition, CB_SETCURSEL, 0, 0);

}


//$$/////////////////////////////////////////////////////////////////////////////
//
// FillSearchUI - Fills the Search UI with various information
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillSearchUI(HWND hDlg,LPWAB_FIND_PARAMS lpWFP)
{

    int i;
    BOOL bRet = FALSE;
    HWND hWndCombo;

    TCHAR szBuf[MAX_UI_STR];
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);
    //
    // Fill the fields if there is anything in the LDAPsp structure
    //
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
	    switch(rgSearchEditID[i])
	    {
	    case IDC_FIND_EDIT_NAME:
		    lstrcpyn(szBuf,lpLDAPsp->szData[ldspDisplayName], MAX_UI_STR);
		    break;
	    case IDC_FIND_EDIT_EMAIL:
		    lstrcpyn(szBuf,lpLDAPsp->szData[ldspEmail], MAX_UI_STR);
		    break;
	    case IDC_FIND_EDIT_STREET:
		    lstrcpyn(szBuf,lpLDAPsp->szData[ldspAddress], MAX_UI_STR);
		    break;
	    case IDC_FIND_EDIT_PHONE:
		    lstrcpyn(szBuf,lpLDAPsp->szData[ldspPhone], MAX_UI_STR);
		    break;
	    case IDC_FIND_EDIT_ANY:
		    lstrcpyn(szBuf,lpLDAPsp->szData[ldspOther], MAX_UI_STR);
		    break;
	    }
        szBuf[MAX_UI_STR -1] = '\0';
	    SetDlgItemText(hDlg,rgSearchEditID[i],szBuf);
    }


    //
    // Populate the combo box with the list of LDAP containers and set it to the current selection
    //
    hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);

    FreeLVItemParam(hWndCombo);

    if(lpWFP->lplu)
    {
	    LPSERVERDAT lpSD = LocalAlloc(LMEM_ZEROINIT,sizeof(SERVERDAT));
	    // Add this one item in the directory service list only ..
	    if(lpSD)
	    {
	        lpSD->himl = NULL;
	        lpSD->SB.cb = 0;
	        lpSD->SB.lpb = NULL;
	        ComboAddItem(    hWndCombo, //hWndLV,
				    lpWFP->lplu->lpszServer,
				    (LPARAM) lpSD,
				    NULL, NULL, NULL);
	        SetWindowText(hWndCombo, lpWFP->lplu->lpszServer);
	        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
	    }

	    if(lpWFP->lplu->lpList)
	    {
	        HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
		    HrFillListView(hWndLVResults,
						       lpWFP->lplu->lpList);
	        UpdateButtons(hDlg, hWndLVResults, hWndCombo, lpWFP->lplu); //hWndLV);
	        if(ListView_GetItemCount(hWndLVResults) > 0)
	        {
		        TCHAR szBuf[MAX_PATH];
		        TCHAR szBufStr[MAX_PATH - 6];
		        LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, CharSizeOf(szBufStr));
		        wsprintf(szBuf, szBufStr, ListView_GetItemCount(hWndLVResults));
		        SetWindowText(hDlg, szBuf);
	        }
	    }
    }
    else
    {
	    TCHAR   tsz[MAX_PATH];
	    ULONG   cb = CharSizeOf(tsz);
        LPTSTR  lptszPreferredName = NULL;

	    if(!lstrlen(lpLDAPsp->szContainerName))
	    {
            LPIAB lpIAB = (LPIAB)lpLDAPsp->lpIAB;
            HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;

	        // Read the last used container name from the registry
            if(ERROR_SUCCESS == RegQueryValue(hKeyRoot,
                szKeyLastFindServer, tsz, &cb))
            {
                lstrcpy(lpLDAPsp->szContainerName, tsz);
            }
            
            // [PaulHi] 3/19/99  Raid 73461  First check to see if there is a policy setting
            // pointing to the preferred selected server.  If so pass this server name in as
            // the preferred container name.  We still use the below "szContainerName" as
            // back up if the preferred name doesn't exist in the server enumeration.
            // [PaulHi] 6/22/99  I acutally had this backwards.  The policy should be checked
            // in this order: HKLM, HKCU, Identity  (instead of Identity, HKCU, HKLM).
            cb = CharSizeOf(tsz);
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_tszPolicyPrefAccount, tsz, &cb))
            {
                lptszPreferredName = tsz;
            }
            else
            {
                // Try looking at HKCU
                cb = CharSizeOf(tsz);
                if ( (hKeyRoot != HKEY_CURRENT_USER) && 
                    (ERROR_SUCCESS == RegQueryValue(HKEY_CURRENT_USER, c_tszPolicyPrefAccount, tsz, &cb)) )
                {
                    lptszPreferredName = tsz;
                }
                else
                {
                    // Finally try looking in current identity
                    cb = CharSizeOf(tsz);
                    if(ERROR_SUCCESS == RegQueryValue(hKeyRoot, c_tszPolicyPrefAccount, tsz, &cb))
                    {
                        lptszPreferredName = tsz;
                    }
                }
            }
        }

	    PopulateContainerList(lpLDAPsp->lpIAB,
				    hWndCombo,                      // hWndLV,
				    lpLDAPsp->szContainerName,      // Last used server name
                    lptszPreferredName);            // Preferred server name
    }

    // Fill the combos for the advanced field
    FillAdvancedFieldCombos(hDlg, hWndCombo);

    SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu,
		    TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)) );

    return TRUE;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// UpdateButtons - Sets the state of the buttons based on various criteria
//
/////////////////////////////////////////////////////////////////////////////////
void UpdateButtons(HWND hDlg, HWND hWndLVResults, HWND hWndCombo, LPLDAPURL lplu) 
{

    BOOL bIsWAB = FALSE;
    BOOL bHasResults = (ListView_GetItemCount(hWndLVResults) > 0) ? TRUE : FALSE;
    int i;

    if(!lplu && CurrentContainerIsPAB(hWndCombo) != IS_LDAP)
	bIsWAB = TRUE;

    if (bIsWAB && bHasResults)
    {
	    // We have some search results
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_DELETE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_DELETE), FALSE);
    }

    if (!bIsWAB && bHasResults)
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), FALSE);
    }

    if(bHasResults)
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), TRUE);
	    SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_PROPERTIES, 0);

	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO), TRUE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC), TRUE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC), TRUE);
    }
    else
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), FALSE);
	    SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);

	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO), FALSE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC), FALSE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC), FALSE);
    }
    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// GetAdvancedFilter - Creates an advanced filter from the pieces in the listbox
//
/////////////////////////////////////////////////////////////////////////////////
void GetAdvancedFilter(HWND hDlg, LPTSTR * lppAdvFilter, BOOL bLocalSearch, LPLDAP_SEARCH_PARAMS lpLDAPsp)
{
    LPTSTR lpF = NULL, lp =NULL;
    HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
    int nCount = 0, nLen = 0, i = 0;

    *lppAdvFilter = NULL;

    nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
    if(!nCount)
        return;

    for(i=0;i<nCount;i++)
    {
        lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
        if(lp)
            nLen += lstrlen(lp) + 1; 
    }

    lpF = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen+4)); //add enough extra spaces for a 3 chars to each subfilter '(''&'')'
    if(!lpF)
        return;

    lstrcpy(lpF, szEmpty);

    // We have to AND all the filters together 
    if(nCount > 1)
        lstrcat(lpF,  TEXT("(&"));

    for(i=0;i<nCount;i++)
    {
        lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
        if(lp)
	        lstrcat(lpF, lp);
    }

    if(nCount > 1)
        lstrcat(lpF,  TEXT(")"));

    DebugTrace( TEXT("Filter:%s\n"),lpF);

    *lppAdvFilter = lpF;

    if(bLocalSearch)
    {
	// the local search only allows searching on
    }
}

extern OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEID);

//$$/////////////////////////////////////////////////////////////////////////////
//
// DoTheSearchThing - Does the search thing and produces results
//
/////////////////////////////////////////////////////////////////////////////////
BOOL DoTheSearchThing(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{

    int i =0, iItemIndex=0;
    LPTSTR lpBuf = NULL;
    TCHAR szBuf[MAX_UI_STR];
    HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
    HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
    BOOL bRet = FALSE;
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);
    HWND hWndAnim = GetDlgItem(hDlg, IDC_FIND_ANIMATE1);
    BOOL bAnimateStart = FALSE;
    HRESULT hr = E_FAIL;
    int SearchType = TRUE;
    LPSBinary lpsbCont = NULL;
    SBinary sbCont = {0};
	LPPTGDATA lpPTGData=GetThreadStoragePointer();

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    int nTab = TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND));
    LPTSTR lpAdvFilter = NULL;

    // Check if the current container is an LDAP container or a PAB container
    // or an Outlook contact store container
    if(lpWFP->lplu)
        SearchType = IS_LDAP;
    else
        SearchType = CurrentContainerIsPAB(hWndCombo);

    // if this is an advanced search, assemble a search filter
    if(tabAdvanced == nTab)
        GetAdvancedFilter(hDlg, &lpAdvFilter, (SearchType != IS_LDAP),  lpLDAPsp);
    else
    {
        for(i=0;i<SEARCH_EDIT_MAX;i++)
        {
	        if(IsWindowEnabled(GetDlgItem(hDlg, rgSearchEditID[i])))
	        {
		        GetDlgItemText(hDlg,rgSearchEditID[i],szBuf,CharSizeOf(szBuf));
		        TrimSpaces(szBuf);
		        if (lstrlen(szBuf))
                    bRet = TRUE;

		        switch(rgSearchEditID[i])
		        {
		        case IDC_FIND_EDIT_NAME:
			        lstrcpy(lpLDAPsp->szData[ldspDisplayName],szBuf);
			        break;
		        case IDC_FIND_EDIT_EMAIL:
			        lstrcpy(lpLDAPsp->szData[ldspEmail],szBuf);
			        break;
		        case IDC_FIND_EDIT_STREET:
			        lstrcpy(lpLDAPsp->szData[ldspAddress],szBuf);
			        break;
		        case IDC_FIND_EDIT_PHONE:
			        lstrcpy(lpLDAPsp->szData[ldspPhone],szBuf);
			        break;
		        case IDC_FIND_EDIT_ANY:
			        lstrcpy(lpLDAPsp->szData[ldspOther],szBuf);
			        break;
		        }
	        }
        }
    }
   
    GetSelectedText(hWndCombo, &lpBuf);
    
    lstrcpy(lpLDAPsp->szContainerName, lpBuf ? lpBuf : szEmpty);

    if(lpBuf)
        LocalFree(lpBuf);

    if((!bRet && nTab == tabSimple) ||
       (!lpAdvFilter && nTab == tabAdvanced) )
    {
	    ShowMessageBox(hDlg,idsSpecifySearchCriteria,MB_ICONEXCLAMATION | MB_OK);
	    goto out;
    }

    if(Animate_Open(hWndAnim, MAKEINTRESOURCE(IDR_AVI_WABFIND)))
    {
        if(Animate_Play(hWndAnim, 0, -1, -1))
	        bAnimateStart = TRUE;
    }

    {   // reset the window title
	    TCHAR szBuf[MAX_PATH];
	    LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, CharSizeOf(szBuf));
	    SetWindowText(hDlg, szBuf);
    }

    if(SearchType == IS_PAB)
    {
        lpsbCont = NULL;
    }
    else if(SearchType == IS_OLK)
    {
        if (pt_bIsWABOpenExSession)
        {
	        OlkContInfo *polkci;
	        // is this an outlook container ?
	        GetCurrentContainerEID(hWndCombo,
			          &(sbCont.cb),
			          (LPENTRYID *)&(sbCont.lpb));

            EnterCriticalSection((&((LPIAB)lpLDAPsp->lpIAB)->cs));
	        polkci = FindContainer((LPIAB)(lpLDAPsp->lpIAB), 
				        sbCont.cb, (LPENTRYID) sbCont.lpb);
	        if(polkci)
                lpsbCont = &sbCont;
            LeaveCriticalSection((&((LPIAB)lpLDAPsp->lpIAB)->cs));
        }
    }

    // We do the actual search over here ....
    if(SearchType != IS_LDAP)
    {
	    // Local Search
	    ULONG ulFoundCount = 0;
        LPSBinary rgsbEntryIDs = NULL;

	    ClearListView(hWndLVResults, &(lpWFP->lpContentsList));

	    HrDoLocalWABSearch( ((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore,
                lpsbCont,
				lpWFP->LDAPsp,
				&ulFoundCount,
				&rgsbEntryIDs);

	    if(ulFoundCount && rgsbEntryIDs)
	    {
            ULONG i;

            for(i=0;i<ulFoundCount;i++)
            {
	            LPRECIPIENT_INFO lpItem = NULL;

		            if(!ReadSingleContentItem(  lpWFP->LDAPsp.lpIAB,
					            rgsbEntryIDs[i].cb,
					            (LPENTRYID) rgsbEntryIDs[i].lpb,
					            &lpItem))
		            continue;

	            if(!lpItem)
		            continue;
	            //
	            // Hook in the lpItem into the lpContentsList so we can free it later
	            //
	            lpItem->lpPrev = NULL;
	            lpItem->lpNext = lpWFP->lpContentsList;
	            if (lpWFP->lpContentsList)
		            (lpWFP->lpContentsList)->lpPrev = lpItem;
	            (lpWFP->lpContentsList) = lpItem;
            }

            HrFillListView(hWndLVResults,
				               lpWFP->lpContentsList);
	    }

        FreeEntryIDs(((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore,
		         ulFoundCount, 
		         rgsbEntryIDs);

	    if(ListView_GetItemCount(hWndLVResults) <= 0)
            ShowMessageBox(hDlg, 
                            pt_bIsWABOpenExSession ? idsNoFolderSearchResults : idsNoLocalSearchResults, 
                            MB_OK | MB_ICONINFORMATION);

	    hr = S_OK;
    }
    else
    {

	    pt_hWndFind = hDlg;

	    //
	    // At this point we can discard the old data
	    //
	    ClearListView(hWndLVResults, 
                    (lpWFP->lplu && lpWFP->lplu->lpList) ? &(lpWFP->lplu->lpList) : &(lpWFP->lpContentsList));
	
        if(lpWFP->lplu)
        {
	        SRestriction Sres = {0};
	        if(!lpAdvFilter)
                hr = HrGetLDAPSearchRestriction(lpWFP->LDAPsp, &Sres);

	        hr = LDAPSearchWithoutContainer(hDlg, lpWFP->lplu,
					        &Sres,
					        lpAdvFilter,
					        FALSE,
                            MAPI_DIALOG,
					        &(lpWFP->lpContentsList),
					        NULL,
					        NULL);

	        if(!lpAdvFilter && Sres.res.resAnd.lpRes)
                MAPIFreeBuffer(Sres.res.resAnd.lpRes);
        }
        else
        {

	        hr = HrSearchAndGetLDAPContents( lpWFP->LDAPsp,
                            lpAdvFilter,
					        hWndCombo,
					        lpWFP->LDAPsp.lpIAB,
					        lpWFP->SortInfo,
					        &(lpWFP->lpContentsList));
        }

	    pt_hWndFind = NULL;

	    if(!HR_FAILED(hr))
	    {
#ifdef PAGED_RESULT_SUPPORT
            if(bMorePagedResultsAvailable())
                ShowHideMoreResultsButton(hDlg, TRUE);
#endif //#ifdef PAGED_RESULT_SUPPORT
            hr = HrFillListView(hWndLVResults,
							    lpWFP->lpContentsList);
	    }
        else
        {
#ifdef PAGED_RESULT_SUPPORT
            ClearCachedPagedResultParams();
            ShowHideMoreResultsButton(hDlg, FALSE);
#endif //#ifdef PAGED_RESULT_SUPPORT
        }
    }

    UpdateButtons(hDlg, hWndLVResults, hWndCombo, lpWFP->lplu);

    if(!HR_FAILED(hr))
    {
	    // The LDAp search results may not be in any sorted order - so always sort ...
	    SortListViewColumn((LPIAB)lpWFP->LDAPsp.lpIAB, hWndLVResults, colDisplayName, &(lpWFP->SortInfo), TRUE);

		LVSelectItem(hWndLVResults, 0);
        SetFocus(hWndLVResults);
    }

    if(ListView_GetItemCount(hWndLVResults) > 0)
    {
	    TCHAR szBuf[MAX_PATH];
	    TCHAR szBufStr[MAX_PATH - 6];
	    LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, CharSizeOf(szBufStr));
	    wsprintf(szBuf, szBufStr, ListView_GetItemCount(hWndLVResults));
	    SetWindowText(hDlg, szBuf);
    }

    bRet = TRUE;

out:
    if (bAnimateStart)
    	Animate_Stop(hWndAnim);

    SetCursor(hOldCur);

    if( bRet &&
	    !lpWFP->bShowFullDialog &&
	    (ListView_GetItemCount(hWndLVResults) > 0))
    {
        ResizeSearchDlg(hDlg, lpWFP);
    }
    LocalFreeAndNull(&lpAdvFilter);
    return bRet;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// Enforces a size in response to user resizing
//
///////////////////////////////////////////////////////////////////////////
LRESULT EnforceSize(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPWAB_FIND_PARAMS lpWFP )
{
	LPPOINT lppt = (LPPOINT)lParam;                 // lParam points to array of POINTs
    if(!lpWFP->bInitialized)
    {
        RECT rc, rc1;
        TCHAR sz[32];
        GetWindowRect(hWnd, &rc);
        GetWindowRect(GetDlgItem(hWnd, IDC_FIND_LIST_RESULTS), &rc1);
        LoadString(hinstMapiX, idsFindDlgWidth, sz, CharSizeOf(sz));
        lpWFP->MinDlgWidth = my_atoi(sz); // the resource is really wide to help localizers .. dont need that much
        lpWFP->MinDlgHeight = (rc1.top - rc.top - 3);
        lpWFP->MinDlgHeightWithResults = (rc.bottom - rc.top);
    }
    lppt[3].x  = lpWFP->MinDlgWidth;
    if(!lpWFP->bShowFullDialog)
    {
	    lppt[4].y = lppt[3].y  = lpWFP->MinDlgHeight; 
    }
    else
    {
	    lppt[3].y  = lpWFP->MinDlgHeightWithResults; 
    }
	return DefWindowProc(hWnd, uMsg, wParam, lParam);

}


#define FIND_BUTTON_MAX 12 //Keep in sync with array below
int rgFindButtonID[]=
{
    IDC_FIND_BUTTON_FIND,
    IDC_FIND_BUTTON_SERVER_INFO,
    IDC_FIND_BUTTON_STOP,
    IDC_FIND_BUTTON_CLEAR,
    IDC_FIND_BUTTON_CLOSE,
    IDC_FIND_BUTTON_PROPERTIES,
    IDC_FIND_BUTTON_DELETE,
    IDC_FIND_BUTTON_ADDTOWAB,
    IDC_FIND_BUTTON_MORE,
    IDC_FIND_BUTTON_TO,
    IDC_FIND_BUTTON_CC,
    IDC_FIND_BUTTON_BCC
};

//$$*************************************************************************
//
//  ResizeFindDialog - Resizes the child controls on the dialog in response to
//                  a WM_SIZE message
//
//
//***************************************************************************
void ResizeFindDialog(HWND hDlg, WPARAM wParam, LPARAM lParam, LPWAB_FIND_PARAMS lpWFP)
{
    DWORD fwSizeType = (DWORD) wParam;      // resizing flag
    int nWidth = LOWORD(lParam);  // width of client area
    int nHeight = HIWORD(lParam); // height of client area
    POINT ptLU; // Left, Upper vertex
    POINT ptRB; // Right, Bottom vertex
    RECT rc, rc1, rcDlg;
    int nButtonWidth, nButtonHeight;
    int nEditWidth, nEditHeight;
    int nLVWidth, nLVHeight;
    int nFrameWidth;
    int nAnimateWidth, nAnimateHeight;
    HWND hWndC = NULL;

    int i;

	HDWP hdwp = BeginDeferWindowPos(12);

    // Resize based on width

    // Move all the buttons to the right edge
    for(i=0;i<FIND_BUTTON_MAX;i++)
    {
        hWndC = GetDlgItem(hDlg,rgFindButtonID[i]);
	    GetWindowRect(hWndC,&rc);
	    nButtonWidth = (rc.right - rc.left);
	    nButtonHeight = (rc.bottom - rc.top);

	    ptLU.y = rc.top;
	    ptLU.x = 0;

	    ScreenToClient(hDlg, &ptLU);
	    ptLU.x = nWidth - BORDER_SPACE - nButtonWidth;

	    MoveWindow(hWndC,ptLU.x,ptLU.y,nButtonWidth, nButtonHeight, TRUE);
    }

    nLVWidth = nWidth - BORDER_SPACE - BORDER_SPACE - nButtonWidth - BORDER_SPACE;

    // Move the animation control too
    hWndC = GetDlgItem(hDlg,IDC_FIND_ANIMATE1);
    GetWindowRect(hWndC,&rc1);
    nAnimateWidth = rc1.right - rc1.left;
    nAnimateHeight = rc1.bottom - rc1.top;
    ptLU.x = rc1.left;
    ptLU.y = rc1.top;
    ScreenToClient(hDlg, &ptLU);
    ptLU.x = nWidth - BORDER_SPACE - nButtonWidth + (nButtonWidth - nAnimateWidth)/2;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nAnimateWidth, nAnimateHeight,TRUE);

    // Resize the Combo
    hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_LIST);
    GetWindowRect(hWndC,&rc);
    nLVHeight = rc.bottom - rc.top;
    //
    //This api works for both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nFrameWidth = nLVWidth + BORDER_SPACE - ptLU.x;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nFrameWidth, nLVHeight,TRUE);
    ptRB.x = ptLU.x + nFrameWidth;

    // Resize the TAB
    hWndC = GetDlgItem(hDlg,IDC_TAB_FIND);
    GetWindowRect(hWndC,&rc);
    nLVHeight = rc.bottom - rc.top;
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nFrameWidth = nLVWidth + BORDER_SPACE - ptLU.x;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nFrameWidth, nLVHeight,TRUE);
    ptRB.x = ptLU.x + nFrameWidth;

    // Resize the Edit Controls
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
        hWndC = GetDlgItem(hDlg,rgSearchEditID[i]);
	    GetWindowRect(hWndC,&rc);

        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

	    ptLU.y = rc.top;
	    ptLU.x = rc.left;

	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of frame right edge

	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Resize the advanced controls
    // First the group-box
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_STATIC_ADVANCED);
	    GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of tab right edge
        // update this variable with the group-box right border
        ptRB.x = ptLU.x + nEditWidth;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Resize the Advanced edit controls also
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_FIELD);
	    GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = (ptRB.x - BORDER_SPACE - 2*CONTROL_SPACE - ptLU.x)/3; //ptRB.x is x coordinate of frame right edge
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);

        hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_CONDITION);
        ptLU.x += nEditWidth + CONTROL_SPACE;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);

        hWndC = GetDlgItem(hDlg,IDC_FIND_EDIT_ADVANCED);
        ptLU.x += nEditWidth + CONTROL_SPACE;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Move the two advanced buttons
    for(i=0;i<2;i++)
    {
        hWndC = GetDlgItem(hDlg,rgAdvancedButtons[i]);
        GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = rc.right - rc.left; // Dont modify width of the button
        ptLU.x = ptRB.x - BORDER_SPACE - nEditWidth;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }
    // update this variable with the left edge of the button
    // List box width is adjusted based on this
    ptRB.x = ptLU.x;

    // Adjust the listbox width
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_LIST_CONDITIONS);
        GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of frame right edge
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // For the height, we only adjust the list view height

    // Resize the List View
    hWndC = GetDlgItem(hDlg,IDC_FIND_LIST_RESULTS);
    GetWindowRect(hWndC,&rc);
    //
    //This api works for both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nLVHeight = nHeight - BORDER_SPACE - ptLU.y;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nLVWidth, nLVHeight,TRUE);

	EndDeferWindowPos(hdwp);

    return;
}


//$$**************************************************************************
//
//  ShowContainerContextMenu - Shows the context menu for the container list
//
//
//****************************************************************************
/****/
void ShowContainerContextMenu(HWND hDlg,
			      HWND hWndCombo, //hWndLV,
			      LPARAM lParam)
{
	HMENU hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDM_FIND_CONTEXTMENU_CONTAINER));
	HMENU hMenuTrackPopUp = GetSubMenu(hMenu, 0);

	if (!hMenu || !hMenuTrackPopUp)
	{
		DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
		goto out;
	}

    if (CurrentContainerIsPAB(hWndCombo) != IS_LDAP)
        EnableMenuItem(hMenuTrackPopUp,IDM_FIND_CONTAINERPROPERTIES,MF_BYCOMMAND | MF_GRAYED);

    //
    // Popup the menu
    //
	TrackPopupMenu( hMenuTrackPopUp,
					TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam),
					HIWORD(lParam),
					0,
					hDlg,
					NULL);
	
	DestroyMenu(hMenu);

out:
	return;
}
/****/
//$$**************************************************************************
//
//  ShowContainerProperties - Shows the context menu for the container list
//
//  hWndLV - list containing the list of containers
//          We dont show any properties for the address book
//
//****************************************************************************
void ShowContainerProperties(   HWND hDlg,
						HWND hWndCombo,
						LPWAB_FIND_PARAMS lpWFP)
{
    LPTSTR lpBuf = NULL, lpOldName = NULL;
	TCHAR szOldName[MAX_UI_STR];

    GetSelectedText(hWndCombo, &lpBuf);

    if(!lpBuf || !lstrlen(lpBuf))
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        lpOldName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpBuf)+1));
	    if(CurrentContainerIsPAB(hWndCombo) == IS_LDAP)
	    {
		    lstrcpy(lpOldName, lpBuf);
		    HrShowDSProps(  hDlg, lpBuf, FALSE);

		    if(lstrcmpi(lpOldName, lpBuf))
		    {
                // The name changed, update it in the list view ...
                SendMessage(hWndCombo, WM_SETREDRAW, FALSE, 0);
                FreeLVItemParam(hWndCombo);
                SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
                PopulateContainerList(  lpWFP->LDAPsp.lpIAB,
				                hWndCombo, lpBuf, NULL);

                SendMessage(hWndCombo, WM_SETREDRAW, TRUE, 0);
                SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu,
                TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
		    }
	    }
    }
    LocalFreeAndNull(&lpBuf);
    LocalFreeAndNull(&lpOldName);
    return;
}

enum
{
    filtContains=0,
    filtIs,
    filtStartsWith,
    filtEndsWith,
    filtSoundsLike,
    filtMax
};


extern void EscapeIllegalChars(LPTSTR lpszSrcStr, LPTSTR lpszDestStr);

/*//$$************************************************************************
//
//  CreateSubFilter();
//  Creates a subfilter basedon available data
//
//  szFIlter is a preallocated buffer big enough
//
/////////////////////////////////////////////////////////////////////////////*/
void CreateSubFilter(LPTSTR lpField, int nCondition, LPTSTR lpText, LPTSTR szFilter)
{
    LPTSTR lpTemplate = NULL;
    TCHAR szCleanText[MAX_PATH*2];
    
    EscapeIllegalChars(lpText, szCleanText);

    switch(nCondition)
    {
    case filtContains:
        lpTemplate =  TEXT("(%s=*%s*)");
        break;
    case filtIs:
        lpTemplate =  TEXT("(%s=%s)");
        break;
    case filtStartsWith:
        lpTemplate =  TEXT("(%s=%s*)");
        break;
    case filtEndsWith:
        lpTemplate =  TEXT("(%s=*%s)");
        break;
    case filtSoundsLike:
        lpTemplate =  TEXT("(%s=~%s)");
        break;
    }
    wsprintf(szFilter,lpTemplate,lpField, szCleanText);
}

/*//$$************************************************************************
//
//  HrAddFindFilterCondition(hDlg);
//  Adds a condition to the advanced find list box
//
/////////////////////////////////////////////////////////////////////////////*/
HRESULT HrAddFindFilterCondition(HWND hDlg)
{
    HWND hWndComboField = GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD);
    HWND hWndComboCondition = GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION);
    HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
    HRESULT hr = E_FAIL;
    int nID = 0, nCount = 0, nPos = 0;
    LPTSTR lpField = NULL, lpCondition = NULL, lpsz[3], lpFilter = NULL;
    TCHAR szField[MAX_PATH], szCondition[MAX_PATH];
    TCHAR szText[MAX_PATH], szString[MAX_PATH], szFormat[MAX_PATH];

    // if the text field is empty, do nothing
    GetDlgItemText(hDlg, IDC_FIND_EDIT_ADVANCED, szText, CharSizeOf(szText));
    if(!lstrlen(szText))
        goto out;

    // depending on whether this is the 1st item or not, there is an And in the beginning
    nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
    nID = (nCount > 0) ? idsFindFilterAnd : idsFindFilter;
    LoadString(hinstMapiX, nID, szFormat, CharSizeOf(szFormat));

    // Get the selected item in the Field Combo
    nPos = (int) SendMessage(hWndComboField, CB_GETCURSEL, 0, 0);
    if(nPos == CB_ERR)
        goto out;
    SendMessage(hWndComboField, CB_GETLBTEXT, (WPARAM) nPos, (LPARAM) szField);
    lpField = (LPTSTR) SendMessage(hWndComboField, CB_GETITEMDATA, (WPARAM) nPos, 0);

    // Get the selected item in the Condition Combo
    nPos = (int) SendMessage(hWndComboCondition, CB_GETCURSEL, 0, 0);
    if(nPos == CB_ERR)
        goto out;
    SendMessage(hWndComboCondition, CB_GETLBTEXT, (WPARAM) nPos, (LPARAM) szCondition);

    // Now create the formatted message
    if(     (lstrlen(szField) > 1023) ||
            (lstrlen(szCondition) > 1023) ||
            (lstrlen(szText) > 1023))
        goto out;

    lpsz[0] = szField;
    lpsz[1] = szCondition;
    lpsz[2] = szText;

    if (! FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
			  FORMAT_MESSAGE_ALLOCATE_BUFFER |
			  FORMAT_MESSAGE_ARGUMENT_ARRAY,
			  szFormat,
			  0,                    // stringid
			  0,                    // dwLanguageId
			  (LPTSTR)&lpCondition,     // output buffer
			  0,               
			  (va_list *)lpsz))
    {
        DebugTrace( TEXT("FormatMessage -> %u\n"), GetLastError());
        goto out;
    }
    // <TBD> create the sub filter at this point
    CreateSubFilter(lpField, nPos, szText, szString);

    lpFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szString)+1));
    if(!lpFilter)
        goto out;
    lstrcpy(lpFilter, szString);

    nPos = (int) SendMessage(hWndLB, LB_ADDSTRING, 0, (LPARAM) lpCondition);
    SendMessage(hWndLB, LB_SETITEMDATA, (WPARAM) nPos, (LPARAM) lpFilter);
    SendMessage(hWndLB, LB_SETCURSEL, (WPARAM) nPos, 0);
    DebugTrace( TEXT("%s\n"), lpFilter);

    hr = S_OK;
out:
    IF_WIN32(LocalFree(lpCondition);)
    IF_WIN16(FormatMessageFreeMem(lpCondition);)
    return hr;
}


//$$*************************************************************************
//
//  DoInitialFindDlgResizing -
//
//  There are so many controls (some which overlap) on the find dialog that 
//  localizers can't make head or tail of them - so we spread the controls around
//  in the resource description and then at runtime, we move them all to their 
//  appropriate locations - right now, this means shifting the Advanced-Pane
//  controls to be flush left with the beginning of the name static ..
//
//***************************************************************************
void DoInitialFindDlgResizing (HWND hDlg)
{
    POINT ptLU; // Left, Upper vertex
    RECT rcN, rcF, rc;
    HWND hWndC = NULL;
    int nMove = 0, nButtonWidth = 0 , nButtonHeight = 0;

    int rgAdv[] = { IDC_FIND_STATIC_ADVANCED,
            IDC_FIND_COMBO_FIELD,
            IDC_FIND_COMBO_CONDITION,
            IDC_FIND_EDIT_ADVANCED,
            IDC_FIND_LIST_CONDITIONS,
            IDC_FIND_BUTTON_ADDCONDITION,
            IDC_FIND_BUTTON_REMOVECONDITION };
    int i = 0, nAdvMax = 7;

    GetWindowRect(GetDlgItem(hDlg, IDC_FIND_STATIC_NAME), &rcN);
    GetWindowRect(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), &rcF);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcN, 2);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcF, 2);    
    
    nMove = rcF.left - rcN.left; // we want to move everything left this many units

    for(i=0;i<nAdvMax;i++)
    {
        hWndC = GetDlgItem(hDlg,rgAdv[i]);
        GetWindowRect(hWndC,&rc);

        nButtonWidth = (rc.right - rc.left);
        nButtonHeight = (rc.bottom - rc.top);

        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    

        ptLU.y = rc.top;
        ptLU.x = rc.left;

        // ScreenToClient(hDlg, &ptLU);
        ptLU.x -= nMove;

        MoveWindow(hWndC,ptLU.x,ptLU.y,nButtonWidth, nButtonHeight, TRUE);
    }
}
/****/

/*//$$************************************************************************
//
//  fnSearch - Search Dialog Proc
//
**************************************************************************/
INT_PTR CALLBACK fnSearch(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    ULONG nLen = 0, nLenMax = 0, nRetVal=0;
    HRESULT hr = hrSuccess;
    static FILETIME ftLast = {0};

    LPWAB_FIND_PARAMS lpWFP = (LPWAB_FIND_PARAMS) GetWindowLongPtr(hDlg,DWLP_USER);
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);

    switch(message)
    {
    case WM_INITDIALOG:
	    SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
	    lpWFP = (LPWAB_FIND_PARAMS) lParam;
	    lpLDAPsp = &(lpWFP->LDAPsp);
	    {
            HICON hIcon = LoadIcon(hinstMapiX, MAKEINTRESOURCE(IDI_ICON_ABOOK));
            SendMessage(hDlg, WM_SETICON, (WPARAM) ICON_BIG, (LPARAM) hIcon);
	    }
        DoInitialFindDlgResizing (hDlg);
        SetSearchUI(hDlg,lpWFP);
        FillSearchUI(hDlg,lpWFP);
        if(!GetParent(hDlg))
        {
            // Then this is going to be a top level dialog and won't block any identity
            // changes .. most likely it came from the Find | People option
            // In case the address book object is ready to receive identity change 
            // notifications, we should set our hWnd on the LPIAB object so we get a 
            // message telling us to refresh the user ..
            ((LPIAB)(lpLDAPsp->lpIAB))->hWndBrowse = hDlg;
        }
        SetForegroundWindow(hDlg); // On OSR2, this window will sometimes not come up in focus - needs explicit call
        lpWFP->bInitialized = TRUE;
	    break;

	case WM_GETMINMAXINFO:
		//enforce a minimum size for sanity
		return EnforceSize(hDlg, message, wParam, lParam, lpWFP);
		break;

    default:
#ifndef WIN16
	if((g_msgMSWheel && message == g_msgMSWheel) 
        // || message == WM_MOUSEWHEEL
        )
	{
	    if(GetFocus() == GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS))
		SendMessage(GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), message, wParam, lParam);
	    break;
	}
#endif
	    return FALSE;
	break;

   case WM_COMMAND:
	    switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
	    {
	    case EN_CHANGE: //some edit box changed - dont care which
            ShowHideMoreResultsButton(hDlg, FALSE);
            switch(LOWORD(wParam))
            {
            case IDC_FIND_EDIT_ADVANCED:
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), TRUE);
                // Set focus on the ADD button
                SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_ADDCONDITION, 0);
                break;
            default:
	            SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);
	            break;
            }
            break;
        case CBN_SELCHANGE:
            ShowHideMoreResultsButton(hDlg, FALSE);
            switch(LOWORD(wParam))
            {
            case IDC_FIND_COMBO_LIST:
                FillAdvancedFieldCombos(hDlg, (HWND) lParam);
                SetEnableDisableUI(hDlg, (HWND) lParam, lpWFP->lplu,
                TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
                break;
            }
            break;
	    }
	    switch (GET_WM_COMMAND_ID(wParam,lParam))
	    {
        default:
            return ProcessActionCommands(   (LPIAB) lpWFP->LDAPsp.lpIAB, 
					            GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), 
					            hDlg, message, wParam, lParam);
            break;

        case IDC_FIND_BUTTON_REMOVECONDITION:
            {
                HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
                int nCount = 0, nPos = (int) SendMessage(hWndLB, LB_GETCURSEL, 0, 0);
                if(nPos != LB_ERR)
                {
	                LPTSTR lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) nPos, 0);
	                if(lp)
                        LocalFree(lp);
	                SendMessage(hWndLB, LB_DELETESTRING, (WPARAM) nPos, 0);
	                nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
	                if(nCount == 0)
                        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), FALSE);
	                else
	                {
                        if(nPos >= nCount)
                            nPos--;
                        SendMessage(hWndLB, LB_SETCURSEL, (WPARAM) nPos, 0);
	                }
                }
            }
            break;
        case IDC_FIND_BUTTON_ADDCONDITION:
            HrAddFindFilterCondition(hDlg);
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), TRUE);
            // Default button is FIND
	            SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);
            break;

        case IDC_FIND_BUTTON_STOP:
	        if(lpWFP->bLDAPActionInProgress)
	        {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_hDlgCancel)
	                SendMessage(pt_hDlgCancel, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	        }
	        break;


            // only difference between FIND and MORE is that
            // in MORE we repeat the search with the cached paged result cookie
            // if one exists. If the cookie doesnt exist, user wouldnt get to 
            // see the MORE button
            // Any change in search parameters also hides the MORE button
	    case IDC_FIND_BUTTON_FIND:
#ifdef PAGED_RESULT_SUPPORT
	        if(!lpWFP->bLDAPActionInProgress)
                ClearCachedPagedResultParams(); 
#endif //#ifdef PAGED_RESULT_SUPPORT
        case IDC_FIND_BUTTON_MORE:
	        // 96/11/20 markdu  BUG 11030
	        // Disable the find now button so we only get one search.
	        if(!lpWFP->bLDAPActionInProgress)
	        {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                pt_bDontShowCancel = TRUE;
                lpWFP->bUserCancel = FALSE;
		        lpWFP->bLDAPActionInProgress = TRUE;
                ShowHideMoreResultsButton(hDlg, FALSE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_FIND), FALSE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_STOP), TRUE);
		        DoTheSearchThing(hDlg, lpWFP);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_FIND), TRUE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_STOP), FALSE);
		        lpWFP->bLDAPActionInProgress = FALSE;
                pt_bDontShowCancel = FALSE;
                if(lpWFP->bUserCancel) // DId the user try to cancel while the search was happening
                {
	                lpWFP->bUserCancel = FALSE;
	                PostMessage(hDlg, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_CLOSE, 0);
                }
	        }
	        break;

	    case IDC_FIND_BUTTON_CLEAR:
            if(!lpWFP->bLDAPActionInProgress)
            {
	            int i;
	            TCHAR szBuf[MAX_PATH];

	            LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, CharSizeOf(szBuf));
	            SetWindowText(hDlg, szBuf);

	            for(i=0;i<SEARCH_EDIT_MAX;i++)
		            SetDlgItemText(hDlg, rgSearchEditID[i], szEmpty);

                // Clear the advanced buttons too
                SetDlgItemText(hDlg, IDC_FIND_EDIT_ADVANCED, szEmpty);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), FALSE);
                SendDlgItemMessage(hDlg, IDC_FIND_LIST_CONDITIONS, LB_RESETCONTENT, 0, 0);

	            ClearListView(  GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
	            (lpWFP->lplu && lpWFP->lplu->lpList) ? &(lpWFP->lplu->lpList) : &(lpWFP->lpContentsList));

	            for(i=0;i<ldspMAX;i++)
	            {
		            lstrcpy(lpLDAPsp->szData[i], szEmpty);
	            }
            }
            break;

	    case IDOK:
	    case IDCANCEL:
	    case IDC_FIND_BUTTON_CLOSE:
	    // Clear any contents in the Advanced LB
    	    {
	            int nCount = 0, i = 0;
	            HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
	            nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
	            if(nCount)
	            {
		            for(i=0;i<nCount;i++)
		            {
		            LPTSTR lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
		            if(lp)
			            LocalFree(lp);
		            }
		            SendMessage(hWndLB, LB_RESETCONTENT, 0, 0);
	            }
	            // Clear any allocated memory in the field combo box
	            ClearFieldCombo(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD));
	        }
	        // if there is an LDAP operation in progress, close it and set the
	        // flag to cancel from where the LDAP operation was initialized
	        // This prevents aborting any process incompletely and faulting
	        if(lpWFP->bLDAPActionInProgress)
	        {
	            LPPTGDATA lpPTGData=GetThreadStoragePointer();
	            if(pt_hDlgCancel)
		            SendMessage(pt_hDlgCancel, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	            lpWFP->bUserCancel= TRUE;
	        }
	        else
	        {
		        SaveFindWindowPos(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
		        FreeLVItemParam(GetDlgItem(hDlg, IDC_FIND_COMBO_LIST));//IDC_FIND_LIST));
		        EndDialog(hDlg, SEARCH_CLOSE);
	        }
	        break;

	    case IDM_LVCONTEXT_COPY:
    		HrCopyItemDataToClipboard(  hDlg,
			            lpWFP->LDAPsp.lpIAB,
					    GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS));
	        break;

	    case IDM_LVCONTEXT_PROPERTIES:
	    case IDC_FIND_BUTTON_PROPERTIES:
            if(!lpWFP->bLDAPActionInProgress)
            {
	            lpWFP->bLDAPActionInProgress = TRUE;
	            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), FALSE);
	            HrShowLVEntryProperties(GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), 0,
				            lpWFP->LDAPsp.lpIAB,
				            &ftLast);
	            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), TRUE);
	            lpWFP->bLDAPActionInProgress = FALSE;
            }
            break;

	    case IDM_LVCONTEXT_DELETE:
	    case IDC_FIND_BUTTON_DELETE:
            if(!lpWFP->bLDAPActionInProgress)
            {
                HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
			    DeleteSelectedItems(hWndLVResults,
                                    (LPADRBOOK)lpWFP->LDAPsp.lpIAB,
                                    ((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore, &ftLast);
                UpdateButtons(  hDlg,
		                hWndLVResults,
		                GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
			            lpWFP->lplu);
                {
                    TCHAR szBuf[MAX_PATH];
                    ULONG nItemCount = ListView_GetItemCount(hWndLVResults);
                    if (nItemCount <= 0)
                    {
                        LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, CharSizeOf(szBuf));
                        // also free up the contents list so we dont show the deleted contents again
                        FreeRecipList(&(lpWFP->lpContentsList));
                    }
                    else
                    {
                        TCHAR szBufStr[MAX_PATH - 6];
                        LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, CharSizeOf(szBufStr));
                        wsprintf(szBuf, szBufStr, ListView_GetItemCount(hWndLVResults));
                    }
                    SetWindowText(hDlg, szBuf);
                }
                return 0;
            }
            break;

	    case IDM_LVCONTEXT_ADDTOWAB:
	    case IDC_FIND_BUTTON_ADDTOWAB:
            if(!lpWFP->bLDAPActionInProgress)
            {
                HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
                lpWFP->bLDAPActionInProgress = TRUE;
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), FALSE);
                EnableWindow(hWndLVResults, FALSE); // need to do this to preserve the selection in the list
	            HrAddToWAB( lpWFP->LDAPsp.lpIAB,
		            hWndLVResults,
		            &ftLast);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), TRUE);
                EnableWindow(hWndLVResults, TRUE);
                SetColumnHeaderBmp(hWndLVResults, lpWFP->SortInfo);
                lpWFP->bLDAPActionInProgress = FALSE;
                SetFocus(hWndLVResults);
            }
            break;

        case IDM_FIND_CONTAINERPROPERTIES:
            if(!lpWFP->lplu)
            {
	            ShowContainerProperties(hDlg,
				            GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
				            lpWFP);
            }
            break;

        case IDM_NOTIFY_REFRESHUSER:
            ReadWABCustomColumnProps((LPIAB)lpWFP->LDAPsp.lpIAB);
            ReadRegistrySortInfo((LPIAB)lpWFP->LDAPsp.lpIAB, &(lpWFP->SortInfo));
        case IDM_FIND_DIRECTORYSERVICES:
	        if(!lpWFP->bLDAPActionInProgress)
	        {
                LPTSTR lpBuf = NULL;
                HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
                GetSelectedText(hWndCombo, &lpBuf);
                if(lpBuf)
                {
                    if(GET_WM_COMMAND_ID(wParam,lParam) == IDM_FIND_DIRECTORYSERVICES)
                        HrShowDirectoryServiceModificationDlg(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
                    FreeLVItemParam(hWndCombo);
                    PopulateContainerList(  lpWFP->LDAPsp.lpIAB, hWndCombo, lpBuf, NULL);
                    SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu, TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
                    LocalFree(lpBuf);
                }
            }
	        break;

        case IDC_FIND_BUTTON_TO:
		    {
                if(lpWFP->lpAPFI->DialogState == STATE_SELECT_RECIPIENTS)
                {
	                ULONG ulMapiTo = MAPI_TO;
	                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[0];
	                ListAddItem(    GetParent(hDlg),
			                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
			                IDC_ADDRBK_LIST_TO,
			                lpWFP->lpAPFI->lppTo,
			                ulMapiTo);
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
                }
                else if(lpWFP->lpAPFI->DialogState == STATE_PICK_USER)
                {
                    // Here we need to do a couple of things:
                    // - if no entry is selected, tell the user to select one
                    // - if an entry is selected, get its entryid and cache it
                    //      and close this dialog
                    HWND hWndLV = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    if (iItemIndex == -1)
	                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
                    else
                    {
                        // Get the entryid of this selected item
                        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
                        if (lpItem)
                        {
                            // remove this item from our linked list of arrays
                            // if this is the first item in the list then handle that special case too
                            lpWFP->lpAPFI->lpEntryID = LocalAlloc(LMEM_ZEROINIT, lpItem->cbEntryID);
                            if(lpWFP->lpAPFI->lpEntryID)
                            {
                                CopyMemory(lpWFP->lpAPFI->lpEntryID, lpItem->lpEntryID, lpItem->cbEntryID);
                                lpWFP->lpAPFI->cbEntryID = lpItem->cbEntryID;
                                SaveFindWindowPos(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
                                FreeLVItemParam(GetDlgItem(hDlg, IDC_FIND_COMBO_LIST));
                                EndDialog(hDlg, SEARCH_USE);
                            }
                        }
                    }
                }
            }
            break;

	    case IDC_FIND_BUTTON_CC:
            {
                ULONG ulMapiTo = MAPI_CC;
                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[1];
                ListAddItem(    GetParent(hDlg),
		                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
		                IDC_ADDRBK_LIST_CC,
		                lpWFP->lpAPFI->lppCC,
		                ulMapiTo);
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
            }
            break;

	    case IDC_FIND_BUTTON_BCC:
    		{
                ULONG ulMapiTo = MAPI_BCC;
                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[2];
                ListAddItem(    GetParent(hDlg),
		                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
		                IDC_ADDRBK_LIST_BCC,
		                lpWFP->lpAPFI->lppBCC,
		                ulMapiTo);
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
		    }
		    break;

	    case IDC_FIND_BUTTON_SERVER_INFO:
		    {
			    LDAPSERVERPARAMS lsp = {0};
			    ULONG iItemIndex;
                LPTSTR lpBuf = NULL;
			    HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
			    HINSTANCE hInst;

			    // Does it have a URL registered?
			    // Get the LDAP server properties for the selected container

                GetSelectedText(hWndCombo, &lpBuf);

                if(lpBuf)
                {
	                GetLDAPServerParams(lpBuf, &lsp);
                    if (lsp.lpszURL && lstrlen(lsp.lpszURL) && bIsHttpPrefix(lsp.lpszURL)) 
	                {
		                // Yes, there is a URL, shell execute it to bring up the browser.
		                HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
		                hInst = ShellExecute(GetParent(hDlg),  TEXT("open"), lsp.lpszURL, NULL, NULL, SW_SHOWNORMAL);
		                SetCursor(hOldCur);
                    }
                    FreeLDAPServerParams(lsp);
                    LocalFree(lpBuf);
                }
		    }
		    break;
	    }
	    break;

    case WM_SIZE:
	    ResizeFindDialog(hDlg, wParam, lParam, lpWFP);
	    return 0;
	    break;

    case WM_CLOSE:
	    //treat it like a cancel button
	    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	    break;

    case WM_HELP:
	    WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
			    g_szWABHelpFileName,
			    HELP_WM_HELP,
			    (DWORD_PTR)(LPSTR) rgSrchHelpIDs );
	    break;

	case WM_CONTEXTMENU:
		if ((HWND)wParam == GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS))
		{
			ShowLVContextMenu(  lvDialogFind,
				GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
				GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
				lParam,
				NULL,
				lpWFP->LDAPsp.lpIAB, NULL);
		}
        else if ((HWND)wParam == GetDlgItem(hDlg, IDC_FIND_COMBO_LIST) && (!lpWFP->lplu))
		{
            ShowContainerContextMenu(   hDlg,
                                    GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
                                    lParam);
		}
	    else
	    {
            WABWinHelp((HWND) wParam,
	            g_szWABHelpFileName,
	            HELP_CONTEXTMENU,
	            (DWORD_PTR)(LPVOID) rgSrchHelpIDs );
	    }
		break;

		break;

    case WM_VKEYTOITEM:
        if( VK_DELETE == LOWORD(wParam) &&
	        SendMessage((HWND) lParam, LB_GETCOUNT, 0, 0) > 0) // Delete pressed
        {
	        SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_REMOVECONDITION, 0);
	        return -2; // means we handled the keystroke completely
        }
        else
	        return DefWindowProc(hDlg, message, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch((int) wParam)
        {
        case IDC_TAB_FIND:
	        if(((NMHDR FAR *)lParam)->code == TCN_SELCHANGE)
	        {
                int nTab = TabCtrl_GetCurSel(((NMHDR FAR *)lParam)->hwndFrom);
                SetEnableDisableUI( hDlg, 
		                GetDlgItem(hDlg, IDC_FIND_COMBO_LIST), 
		                lpWFP->lplu,
		                nTab);
                if(nTab == tabSimple)
                    SetFocus(GetDlgItem(hDlg, IDC_FIND_EDIT_NAME));
                else
                    SetFocus(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED));
	        }
	        break;

        case IDC_FIND_LIST_RESULTS:
        #ifdef WIN16 // Context menu handler for WIN16
	        if(((NMHDR FAR *)lParam)->code == NM_RCLICK)
	        {
	            POINT pt;

	            GetCursorPos(&pt);
	            ShowLVContextMenu( lvDialogFind,
			               GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
			               GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
			               MAKELPARAM(pt.x, pt.y),
			               NULL,
			               lpWFP->LDAPsp.lpIAB, NULL);
	        }
        #endif
	        return ProcessLVResultsMessages(hDlg,message,wParam,lParam, lpWFP);
	        break;
        }
        break;
    }
    return TRUE;
}

/**********
//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVMessages - Processes messages for the Container list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVMessages(HWND   hWnd, UINT   uMsg, UINT   wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	HWND hWndLV = pNm->hdr.hwndFrom;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    switch(pNm->hdr.code)
	{

    case NM_DBLCLK:
	    SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FIND_CONTAINERPROPERTIES, 0);
	    break;

    case LVN_ITEMCHANGED:
    case NM_SETFOCUS:
    case NM_CLICK:
    case NM_RCLICK:
	    SetEnableDisableUI(hWnd, hWndLV);
		break;

    case NM_CUSTOMDRAW:
	{
		    NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
	    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	    NMLVCUSTOMDRAW * pnmlvcd = (NMLVCUSTOMDRAW * )lParam;

		    if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		    {
		SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			    return TRUE;
		    }
		    else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
	    {
		LPSERVERDAT lpSD = (LPSERVERDAT) pnmcd->lItemlParam;

		if(lpSD != 0 &&
		   (WAB_PAB != IsWABEntryID(lpSD->SB.cb, 
					    (LPENTRYID) lpSD->SB.lpb, 
					    NULL, NULL, NULL)) &&
		   lpSD->himl)
		{
		    HDC hdcLV = pnmlvcd->nmcd.hdc;
		    RECT rcLVItem;
		    UINT fType = ILD_NORMAL;

		    ListView_GetItemRect(hWndLV, pnmcd->dwItemSpec, &rcLVItem, LVIR_BOUNDS);
		    if (ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED) == (int) pnmcd->dwItemSpec)
		    {
			FillRect(hdcLV, &rcLVItem, (HBRUSH) (COLOR_HIGHLIGHT+1));
			//fType |= ILD_BLEND25;
			DrawFocusRect(hdcLV, &rcLVItem);
		    }
		    else
			FillRect(hdcLV, &rcLVItem, (HBRUSH) (COLOR_WINDOW+1));

		    if(!gpfnImageList_Draw( lpSD->himl, 
					0, 
					hdcLV, 
					rcLVItem.left + L_BITMAP_WIDTH + 1, //gives enough space to paint the icon
					rcLVItem.top, 
					fType))
		    {
			DebugPrintError(( TEXT("ImageList_Draw failed\n")));
		    }

		    if (ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED) == (int) pnmcd->dwItemSpec)
			fType |= ILD_BLEND25;

		    {
			HIMAGELIST himlLV = ListView_GetImageList(hWndLV,LVSIL_SMALL);
			gpfnImageList_Draw(himlLV, imageDirectoryServer, hdcLV, rcLVItem.left + 1, rcLVItem.top, fType);
		    }
		    SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_SKIPDEFAULT);
				    return TRUE;
		}
		    }
	    SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_DODEFAULT);
	    return TRUE;
	}
	break;

    }

	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
/********/

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVResultsMessages - Processes messages for the Search Results list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVResultsMessages(HWND   hWnd,
				 UINT   uMsg,
				 WPARAM   wParam,
				 LPARAM lParam,
				 LPWAB_FIND_PARAMS lpWFP)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	HWND hWndLV = pNm->hdr.hwndFrom;

	// Bug 17027: GPF due to null lpWFP
	if(lpWFP)
	{
		if(lpWFP->bLDAPActionInProgress)
			return 0;
	}

    switch(pNm->hdr.code)
	{
    case LVN_COLUMNCLICK:
		if(lpWFP)
	        SortListViewColumn((LPIAB)lpWFP->LDAPsp.lpIAB, hWndLV, pNm->iSubItem, &(lpWFP->SortInfo), FALSE);
    	break;


	case LVN_KEYDOWN:
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            if(CurrentContainerIsPAB(GetDlgItem(hWnd, IDC_FIND_COMBO_LIST)) != IS_LDAP)
                SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_DELETE, 0);
            return 0;
            break;
        case VK_RETURN:
	        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_PROPERTIES, 0);
	        return 0;
        }
        break;


    case NM_DBLCLK:
        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_PROPERTIES, 0);
        return 0;
        break;

	case NM_CUSTOMDRAW:
        return ProcessLVCustomDraw(hWnd, lParam, TRUE);
        break;
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


//$$////////////////////////////////////////////////////////////////////////////
//
// SaveFindWindowPos - saves the find window position and size
//
////////////////////////////////////////////////////////////////////////////////
void SaveFindWindowPos(HWND hWnd, LPIAB lpIAB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    WINDOWPLACEMENT wpl = {0};

    wpl.length = sizeof(WINDOWPLACEMENT);

    // This call tells us the window state and normal size and position
    GetWindowPlacement(hWnd, &wpl);

	// There seems to be a bug in GetWindowPlacement that
	// doesnt account for various taskbars on the screen when
	// returning the Window's Normal Position .. as a result
	// the stored coordinates won't be accurate. Instead, we'll
	// use those coordinates only if the window is maximized or
	// minimized - otherwise we will use the GetWindowRect
	// coordinates.

    // Get the screen position of this window
    GetWindowRect(hWnd, &(ABPosColSize.rcPos));

    if(wpl.showCmd != SW_SHOWNORMAL)
    {
        ABPosColSize.rcPos = wpl.rcNormalPosition;
    }

    ABPosColSize.nTab = TabCtrl_GetCurSel(GetDlgItem(hWnd, IDC_TAB_FIND));

    WriteRegistryPositionInfo(lpIAB, &ABPosColSize,lpszRegFindPositionKeyValueName);

    // Also save the last used server name in the registry for the next
    // session
    {
        LPTSTR lpBuf = NULL;
        GetSelectedText(GetDlgItem(hWnd, IDC_FIND_COMBO_LIST), &lpBuf);
        if(lpBuf)
        {
            HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
	        RegSetValue(hKeyRoot, szKeyLastFindServer, REG_SZ, lpBuf,  lstrlen(lpBuf));
	        LocalFree(lpBuf);
        }
    }

    return;
}


/*************************************************************************
//$$
//  HrInitServerListLV - Initializes the list view that displays the list
//          of servers ...
//
//  hWndLV - handle of list view
//
**************************************************************************/
/****
HRESULT HrInitServerListLV(HWND hWndLV)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
	HIMAGELIST hSmall=NULL;

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(dwLVStyle & LVS_EDITLABELS)
	SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS));

    hSmall = gpfnImageList_LoadImage(   hinstMapiX,     
				    MAKEINTRESOURCE(IDB_BITMAP_LARGE),
				    L_BITMAP_WIDTH,
				    0,
				    RGB_TRANSPARENT,
				    IMAGE_BITMAP,       
				    0);

	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

    {
	RECT rc;
	GetWindowRect(hWndLV, &rc);
	lvC.cx = rc.right - rc.left - L_BITMAP_WIDTH - 10;
    }
	lvC.pszText = NULL;

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		hr = E_FAIL;
		goto out;
	}


out:    

	return hr;
}
/***/


//$$
//*------------------------------------------------------------------------
//| FreeLVItemParam: Frees the LPSBinary structure associated with each element
//|                     of the list view containing a container list
//|
//| hWndLV - Handle of List View whose data we are freeing
//|
//*------------------------------------------------------------------------
void FreeLVItemParam(HWND hWndCombo)//hWndLV)
{
    int i = 0;
    int nCount;

    if(!hWndCombo)
	return;

    nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    
    // Each Combo item has a entryid associated with it which we need to free up
    for(i=0;i<nCount;i++)
    {
        LPSERVERDAT lpSD = NULL;

        lpSD = (LPSERVERDAT) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) i, 0);

        if(lpSD != NULL)
        {
	        if(lpSD->himl)
	        gpfnImageList_Destroy(lpSD->himl);
	        LocalFreeAndNull((LPVOID *) (&(lpSD->SB.lpb)));
	        LocalFreeAndNull(&lpSD);
        }
    }
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    return;
}


//$$
//*------------------------------------------------------------------------
//| PopulateContainerList: Enumerates potential container names and fills
//| combo ...
//|
//| lpIAB       - AdrBook Object
//| hWndCombo   - Handle of Combo we are populating
//| lpszSelection - NULL or some value - if exists, this value is set as the
//|                 combo selection otherwise the local store is the default
//|                 selection
//| lptszPreferredSelection - NULL or some value - if exists then set as the
//|                           combo selection, otherwise the above 
//|                           lpszSelection or local store is the default.
//|
//*------------------------------------------------------------------------
HRESULT PopulateContainerList(
    LPADRBOOK lpAdrBook,
    HWND hWndCombo,
    LPTSTR lpszSelection,
    LPTSTR lptszPreferredSelection)
{
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();
    HRESULT     hr = hrSuccess;
    ULONG       ulObjectType = 0;
    LPROOT      lpRoot = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
    ULONG       i=0,j=0;
    TCHAR       szPref[MAX_PATH];
    int         nPos = 0;
    int         nStart = 1; // pos we start sorting at ... always after the  TEXT("WAB") item
    BOOL        bAddedPref = FALSE;
    LPIAB       lpIAB = (LPIAB)lpAdrBook;
    BOOL        bFoundSelection = FALSE;
    BOOL        bFoundPreferredSelection = FALSE;

    if( !lpAdrBook ||
    	!hWndCombo)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        DebugPrintError(( TEXT("Invalid Params\n")));
        goto out;
    }

    // if running against outlook, there can be more than 1 contact folder and
    // we need to push them all to the top of the list .. so we will really start 
    // adding generic stuff after the colkci position
    //
    if (pt_bIsWABOpenExSession) 
    {
        nStart = lpIAB->lpPropertyStore->colkci;
    }

    *szPref = '\0';
    LoadString(hinstMapiX, idsPreferedPartnerCode, szPref, CharSizeOf(szPref));

    hr = lpAdrBook->lpVtbl->OpenEntry( lpAdrBook,
				    0,
				    NULL,       
				    NULL,       
				    0,  
				    &ulObjectType,      
				    (LPUNKNOWN *) &lpRoot );

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }

    // if this is a profile aware session, only put the All Contacts item in the drop down list
    // unless it's an outlook session in which case don't do anything
    {
        ULONG ulFlags = MAPI_UNICODE;
        if(bIsWABSessionProfileAware(lpIAB))
            ulFlags |= WAB_NO_PROFILE_CONTAINERS;

        hr = lpRoot->lpVtbl->GetContentsTable( lpRoot,
					        ulFlags,
					        &lpContentsTable);
    }

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

    hr = HrQueryAllRows(lpContentsTable,
			NULL, NULL, NULL, 0,
			&lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPTSTR lpszDisplayName = NULL;
        LPSERVERDAT lpSD = LocalAlloc(LMEM_ZEROINIT, sizeof(SERVERDAT));

        if(!lpSD)
        {
	        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
	        goto out;
        }
        lpSD->himl = NULL;

        for(j=0;j<lpSRowSet->aRow[i].cValues;j++)
        {
            LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;

            switch(lpPropArray[j].ulPropTag)
            {
            case PR_DISPLAY_NAME:
                lpszDisplayName = lpPropArray[j].Value.LPSZ;
                break;
            case PR_ENTRYID:
                lpSD->SB.cb = lpPropArray[j].Value.bin.cb;
                if(lpSD->SB.cb > 0)
                {
                    lpSD->SB.lpb = LocalAlloc(LMEM_ZEROINIT, lpSD->SB.cb);
                    if(!lpSD->SB.lpb)
                    {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                    }
                    CopyMemory(lpSD->SB.lpb, lpPropArray[j].Value.bin.lpb,lpSD->SB.cb);
                }
                break;
            }
        }

        nPos = ComboAddItem( hWndCombo, 
			        lpszDisplayName,
			        (LPARAM) lpSD,
			        szPref,
			        &nStart, &bAddedPref);

        if(!bFoundPreferredSelection && lpszSelection && !lstrcmpi(lpszDisplayName, lpszSelection))
        {
            bFoundSelection = TRUE;
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)nPos, 0);
            SetWindowText(hWndCombo, lpszSelection);
        }

        if (lptszPreferredSelection && !lstrcmpi(lpszDisplayName, lptszPreferredSelection))
        {
            bFoundPreferredSelection = TRUE;
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)nPos, 0);
            SetWindowText(hWndCombo, lptszPreferredSelection);
        }
    }

out:

    if (!bFoundSelection && !bFoundPreferredSelection)
	    SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);

    if (lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpRoot)
        lpRoot->lpVtbl->Release(lpRoot);

    return hr;
}


//$$/////////////////////////////////////////////////////////////////////////////////
//
// CurrentContainerIsPAB - Returns TRUE if the current viewed container is the PAB
//
//  hWndLV - List Containing the list of containers.
//
////////////////////////////////////////////////////////////////////////////////////////
int CurrentContainerIsPAB(HWND hWndCombo)
{
    HRESULT hr = hrSuccess;
    ULONG cbContainerEID = 0;
    LPENTRYID lpContainerEID = NULL;
    BYTE bType = 0;

    GetCurrentContainerEID(hWndCombo, 
			  &cbContainerEID,
			  &lpContainerEID);

    //
    // Check if this entryid is a Local WAB store
    //
    if(!cbContainerEID && !lpContainerEID)
        return IS_PAB;

    bType = IsWABEntryID(cbContainerEID, lpContainerEID, NULL, NULL, NULL, NULL, NULL);

    if(bType == WAB_LDAP_CONTAINER)
        return IS_LDAP;

    if(bType == WAB_PAB || bType == WAB_PABSHARED)
        return IS_PAB;

    // for now we'll figure anything else is a Outlook container
    return IS_OLK;
}

//$$
/******************************************************************************
//
// HrSearchAndGetLDAPContents - Gets and fills the current list view with contents from
//                      an LDAP server.
//
// hWndCombo    - Handle to  TEXT("ShowNames") combo (in case we need to update it
// hWndList     - Handle to List View which we will populate
// lpIAB        - Handle to Address Bok object
// SortInfo     - Current Sort State
// lppContentsList - linked list in which we will store info about entries
// lpAdvFilter - an advanced search filter that is used for advanced searches
//
/******************************************************************************/
HRESULT HrSearchAndGetLDAPContents( LDAP_SEARCH_PARAMS LDAPsp,
				    LPTSTR lpAdvFilter,
				    HWND hWndCombo, 
				    LPADRBOOK lpAdrBook,
				    SORT_INFO SortInfo,
				    LPRECIPIENT_INFO * lppContentsList)
{
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();
    HRESULT hr = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG cbContainerEID = 0;
    LPENTRYID lpContainerEID = NULL;
    TCHAR szBuf[MAX_UI_STR];

    ULONG ulCurSel = 0;
    SRestriction SRes = {0};
    LPSRestriction lpPropRes = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;
    HCURSOR hOldCursor = NULL;
    BOOL bKeepSearching = TRUE;

    //while(bKeepSearching)
    {
        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        //
        // Then we get the container entry id for thie container
        //
        GetCurrentContainerEID( hWndCombo, 
			        &cbContainerEID,
			        &lpContainerEID);

        //
        // Now we have the search dialog data .. we need to create a restriction from it which
        // we can use with the LDAP contents table..
        //
        if(!lpAdvFilter)
        {
	        if(HR_FAILED(HrGetLDAPSearchRestriction(LDAPsp, &SRes)))
	        goto out;
	        lpPropRes = SRes.res.resAnd.lpRes;
        }

        hr = HrGetLDAPContentsList(
			        lpAdrBook,
			        cbContainerEID,
			        lpContainerEID,
			        SortInfo,
			        &SRes,
			        lpAdvFilter,
			        NULL,
			        0,
			        lppContentsList);

        if((HR_FAILED(hr)) && (MAPI_E_USER_CANCEL != hr))
        {
	        int ids;
	        UINT flags = MB_OK | MB_ICONEXCLAMATION;

	        switch(hr)
	        {
	        case MAPI_E_UNABLE_TO_COMPLETE:
                ids = idsLDAPSearchTimeExceeded;
                break;
	        case MAPI_E_AMBIGUOUS_RECIP:
                ids = idsLDAPAmbiguousRecip;
                break;
	        case MAPI_E_NOT_FOUND:
                ids = idsLDAPSearchNoResults;
                break;
	        case MAPI_E_NO_ACCESS:
                ids = idsLDAPAccessDenied;
                break;
	        case MAPI_E_TIMEOUT:
                ids = idsLDAPSearchTimedOut;
                break;
	        case MAPI_E_NETWORK_ERROR:
                ids = idsLDAPCouldNotFindServer;
                break;
	        default:
                ids = idsLDAPErrorOccured;
                DebugPrintError(( TEXT("HrGetLDAPContentsList failed:%x\n"),hr));
                break;
	        }
	        ShowMessageBox( GetParent(hWndCombo),ids, flags);
	        goto out;
        }
        else
        {
	        if(hr == MAPI_W_PARTIAL_COMPLETION)
	        ShowMessageBox( GetParent(hWndCombo),
			        idsLDAPPartialResults, MB_OK | MB_ICONINFORMATION);
        }
    } // while(bKeepSearching)

out:

    if(lpPropRes)
        MAPIFreeBuffer(lpPropRes);

    if(hOldCursor)
        SetCursor(hOldCursor);

    return(hr);
}

//$$
//*------------------------------------------------------------------------
//| GetCurrentContainerEID: Gets EntryID of Current Container - takes a handle
//|                 to a populated combo, gets the current selection, and then
//|                 gets the ItemData (EntryID) for that current selection.
//|
//| hWndLV   - Handle of a ListView containing the container list
//| lpcbContEID,lppContEID - returned Container Entry ID
//|
//| **NOTE** lpContEID is not allocated - its just a pointer and should not be freed
//|
//*------------------------------------------------------------------------
void GetCurrentContainerEID(HWND hWndCombo, //hWndLV,
			    LPULONG lpcbContEID,
			    LPENTRYID * lppContEID)
{
    LPSERVERDAT lpSD = NULL;
    int iItemIndex = 0;

    if(!lpcbContEID || !lppContEID)
        goto out;

    *lpcbContEID = 0;
    *lppContEID = NULL;

    iItemIndex = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

    if(iItemIndex == CB_ERR)
        goto out;

    lpSD = (LPSERVERDAT) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) iItemIndex, 0);

    if(!lpSD)
        goto out;

    *lpcbContEID = lpSD->SB.cb;
    *lppContEID = (LPENTRYID) lpSD->SB.lpb;

out:
    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ComboAddItem Generic function for adding items to list view
//
// hWndLV   -   HWND of List View
// lpszItemText - ItemText
// lParam - LPARAM (can be NULL)
// lpnStart - position at which to start adding generic servers .. in the case where there
//      is more than one server at the top of the list
//
////////////////////////////////////////////////////////////////////////////////////////////
int ComboAddItem( HWND hWndCombo, //hWndLV,
		     LPTSTR lpszItemText,
		     LPARAM lParam,
		     LPTSTR szPref,
		     int * lpnStart, BOOL * lpbAddedPref)
{
    LPTSTR lp = NULL;
    int nPos = 0, nStart = 1;
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    LDAPSERVERPARAMS Params = {0};

    if(lpnStart && *lpnStart)
        nStart = *lpnStart;

    GetLDAPServerParams(lpszItemText, &Params);

    
    if( Params.dwIsNTDS == LDAP_NTDS_IS) // NTDS accounts need to come upfront after the Address Book
    {
        // if the prefered accounts have already been added at nStart .. only add the NT accounts at
        // nStart - 1
        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, 
                        (WPARAM) ((lpbAddedPref && *lpbAddedPref == TRUE) ? nStart - 1 : nStart), 
                        (LPARAM) lpszItemText); 
        if(lpnStart)
	        (*lpnStart)++;
    }
    else
    if( ( szPref && lstrlen(szPref) &&  lpszItemText && lstrlen(lpszItemText) && SubstringSearch(lpszItemText, szPref)) )
    {
        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) nStart, (LPARAM) lpszItemText); // Prefered partner goes in after contact folders at top of the list
        if(lpnStart)
	        (*lpnStart)++;
        if(lpbAddedPref)
            *lpbAddedPref = TRUE;
    }
    else
    {
        // Once we add the pref server, we only need to compare from after that item 
        if(nCount >= nStart)
        {
	        // need to start adding alphabetically
	        // We cant set this list to a sorted state because we always want the Address Book first
	        // and then the prefered partner second
	        int i,nLen;

	        for(i=nStart; i< nCount; i++)
	        {
                // get the current string in the combo
                nLen = (int) SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM) i, 0);
                if(nLen)
                {
                    if(lp)
                    {
                        LocalFree(lp);
                        lp = NULL;
                    }
                    lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen+1));
                    if(lp)
                    {
                        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM)lp);
                        if(lstrlen(lp) && lstrcmpi(lp, lpszItemText) >= 0)
                        {
	                        nPos = i;
	                        break;
                        }
    		        }
	            }
	        }
        }
        if(nPos)
        {
	        // we have a valid position to add the string to
	        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) nPos, (LPARAM) lpszItemText); // Prefered partner goes in after Address book at top of the list
        }
        else
        {
	        // just tag it to the end
	        nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpszItemText);
        }
    }

    SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM) nPos, lParam);

    if(lp)
        LocalFree(lp);

    FreeLDAPServerParams(Params);

    return nPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\useragnt.c ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//  
// converted to wab: Christopher Evans [cevans]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by WAB
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#include "_apipch.h"

#include <iert.h>
#include "useragnt.h"
#include "demand.h"
#include <string.h>

static LPSTR       g_pszWABUserAgent = NULL;
CRITICAL_SECTION    g_csWABUserAgent = {0};

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

LPSTR c_szCompatible = "compatible";
LPSTR c_szEndUATokens = ")";
LPSTR c_szWABUserAgent = "Windows-Address-Book/6.0";
LPSTR c_szBeginUATokens = " (";
LPSTR c_szSemiColonSpace = "; ";

// --------------------------------------------------------------------------------
// PszSkipWhiteA
// --------------------------------------------------------------------------
static LPSTR PszSkipWhiteA(LPSTR psz)
{
    while(*psz && (*psz == ' ' || *psz == '\t'))
        psz++;
    return psz;
}

static LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }
    return (NULL);
}

//----------------------------------------------------------------------
// InitWABUserAgent
//
// Initialize or tear down WAB's user agent support.
//----------------------------------------------------------------------
void InitWABUserAgent(BOOL fInit)
{
    if (fInit)
        InitializeCriticalSection(&g_csWABUserAgent);
    else
    {
        if (g_pszWABUserAgent)
        {
            LocalFree(g_pszWABUserAgent);
            g_pszWABUserAgent = NULL;
        }
        DeleteCriticalSection(&g_csWABUserAgent);
    }
}

//----------------------------------------------------------------------
// GetWABUserAgentString
//
// Returns the Outlook Express user agent string. The caller MUST
// delete the string that is returned.
//----------------------------------------------------------------------
LPSTR GetWABUserAgentString(void)
{
    LPSTR pszReturn = NULL;

    // thread safety
    EnterCriticalSection(&g_csWABUserAgent);

    if (NULL == g_pszWABUserAgent)
    {
        CHAR            szUrlMonUA[4048];
        DWORD           cbSize = ARRAYSIZE(szUrlMonUA) - 1;
        CHAR            szResult[4096];
        CHAR            *pch, *pchBeginTok;
        BOOL            fTokens = FALSE;
        HRESULT         hr = S_OK;
        
        lstrcpyA (szResult, c_szWABUserAgent);
        
        // allow urlmon to generate our base user agent
        if (SUCCEEDED(ObtainUserAgentString(0, szUrlMonUA, &cbSize)))
        {
            // make sure the string we obtained is null terminated
            szUrlMonUA[cbSize] = '\0';

            // find the open beginning of the token list
            pch = _StrChrA(szUrlMonUA, '(');
            if (NULL != pch)
            {
                pch++;
                pchBeginTok = pch;
                while (pch)
                {
                    // find the next token
                    pch = StrTokEx(&pchBeginTok, "(;)");
                    if (pch)
                    {
                        // skip past white space
                        pch = PszSkipWhiteA(pch);

                        // omit the "compatible" token...it doesn't apply to WAB
                        if (0 != lstrcmpiA(pch, c_szCompatible))
                        {
                            if ((lstrlenA(szResult) + lstrlenA(pch) + 5) > ARRAYSIZE(szResult))
                                break;

                            // begin the token list with an open paren, or insert a delimeter
                            if (!fTokens)
                            {
                                lstrcatA(szResult, c_szBeginUATokens);
                                fTokens = TRUE;
                            }
                            else
                                lstrcatA(szResult, c_szSemiColonSpace);

                            // write the token
                            lstrcatA(szResult, pch);
                        }
                    }
                }
                
                // if one or more tokens were added, close the parens
                if (fTokens)
                    lstrcatA(szResult, c_szEndUATokens);
            }
        }
    
        g_pszWABUserAgent = LocalAlloc(LMEM_FIXED, lstrlenA(szResult) + 1);
        if (g_pszWABUserAgent)
            lstrcpyA(g_pszWABUserAgent, szResult);
    }
    
    // duplicate the user agent
    if (g_pszWABUserAgent)
    {
        pszReturn = LocalAlloc(LMEM_FIXED, lstrlenA(g_pszWABUserAgent) + 1);
        if (pszReturn)
            lstrcpyA(pszReturn, g_pszWABUserAgent);
    }

    // thread safety
    LeaveCriticalSection(&g_csWABUserAgent);
    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\validate.c ===
/*
 *	V A L I D A T E . C
 *	
 *	Functions used to validate parameters on standard MAPI object methods.
 *
 *	Used in conjunction with macros found in VALIDATE.H.
 *	
 *	Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */

#include <_apipch.h>


/*
 *	FBadRgPropVal()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		property value array, LPSPropVal
 */
/*
 *BOOL
 *FBadPropVal( LPSPropValue lpPropVal)
 *{
 *	ULONG		ulPropType;
 *	BOOL		fLongMVProp = FALSE;
 *	ULONG		cbItemType = 0;
 *	ULONG		cMVVals;
 *	LPVOID FAR	*lppvMVArray;
 *
 *	switch (ulPropType = PROP_TYPE(lpPropVal->ulPropTag))
 *	{
 *	case PT_STRING8:
 *
 *		if (IsBadStringPtrA( lpPropVal->Value.lpszA, (UINT)-1 ))
 *		{
 *			return TRUE;
 *		}
 *
 *		break;
 *
 *
 *#ifdef WIN32
 *	case PT_UNICODE:
 *
 *		if (IsBadStringPtrW( lpPropVal->Value.lpszW, (UINT)-1 ))
 *		{
 *			return TRUE;
 *		}
 *		break;
 *#endif
 *
 *
 *	case PT_BINARY:
 *
 *		if (IsBadReadPtr( lpPropVal->Value.bin.lpb
 *						, (UINT) lpPropVal->Value.bin.cb))
 *		{
 *			return TRUE;
 *		}
 *
 *		break;
 *
 *	case PT_MV_I2:					// 16 bit quantities
 *
 *		cbItemType = sizeof(lpPropVal->Value.i);
 *		break;
 *
 *
 *	case PT_MV_UNICODE:				// Arrays of strings
 *	case PT_MV_STRING8:
 *
 *		fLongMVProp = TRUE;
 *
 *		// Now fall thru to the 32 bit quantity code below to size the
 *		// top level array of ptrs
 *
 *
 *	case PT_MV_LONG:				// 32 bit quantities
 *	case PT_MV_R4:
 *
 *		cbItemType = sizeof(long);
 *		break;
 *
 *
 *	case PT_MV_BINARY:				// Arrays of counted binary data
 *
 *		fLongMVProp = TRUE;
 *
 *		// Now fall thru to the 64 bit quantity code below to size the array
 *		// of ULONG lengths / ULONG ptrs that comprise the top level stream
 *
 *
 *	case PT_MV_DOUBLE:				// 64 bit quantities
 *	case PT_MV_CURRENCY:
 *	case PT_MV_APPTIME:
 *	case PT_MV_SYSTIME:
 *	case PT_MV_I8:
 *
 *		// Assert that all array elements for this case are the same size.
 *		Assert( sizeof( double ) == sizeof( LARGE_INTEGER ));
 *		cbItemType = sizeof( double );
 *		break;
 *
 *
 *	case PT_MV_CLSID:				// 128 bit quantity
 *
 *		cbItemType = sizeof( GUID );
 *		break;
 *
 *
 *	case PT_OBJECT:
 *	case PT_NULL:
 *	default:
 *		if (ulPropType & MV_FLAG)
 *		{
 *			return TRUE;		// Unknown multivalue prop is bad
 *		}
 *
 *		break;
 *	}
 *
 *	if (!(ulPropType & MV_FLAG))
 *	{
 *		return FALSE;
 *	}
 *
 *	// Try to validate the multivalue props
 *
 *	// This code assumes that the count and ptr of every multivalue
 *	// property are in the same place.
 *	// Asserts check that the sizes of the grouped types above are
 *	// matched
 *
 *	cMVVals = lpPropVal->Value.MVl.cValues;
 *	lppvMVArray = (LPVOID FAR *) (lpPropVal->Value.MVl.lpl);
 *
 *	if (IsBadReadPtr( lppvMVArray, (UINT) (cMVVals * cbItemType)))
 *	{
 *		return TRUE;
 *	}
 *
 *	if (fLongMVProp)
 *	{
 *		// Go verify the array of pointers.
 *		for ( ; cMVVals; cMVVals--, lppvMVArray++)
 *		{
 *			switch (ulPropType)
 *			{
 *#ifdef WIN32
 *			case PT_MV_UNICODE:
 *
 *				if (IsBadStringPtrW( (LPCWSTR) (*lppvMVArray), (UINT) -1))
 *				{
 *					return TRUE;
 *				}
 *
 *				break;
 *#endif
 *			case PT_MV_STRING8:
 *
 *				if (IsBadStringPtrA( (LPCSTR) (*lppvMVArray), (UINT) -1))
 *				{
 *					return TRUE;
 *				}
 *
 *				break;
 *
 *			case PT_MV_BINARY:
 *
 *				if (IsBadReadPtr( ((SBinary FAR *)(*lppvMVArray))->lpb
 *								, (UINT)
 *								  ((SBinary FAR *)(*lppvMVArray))->cb))
 *				{
 *					return TRUE;
 *				}
 *				break;
 *			}
 *		}
 *	}
 *
 *	return FALSE;
 *}
 */

/*
 *	FBadRgPropVal()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		property value array, LPSPropVal
 */
/*BOOL
 *FBadRgPropVal( LPSPropValue lpPropVal,
 *			   ULONG cValues)
 *{
 *
 *	if (IsBadReadPtr( lpPropVal, sizeof(SPropValue) * (UINT) cValues))
 *	{
 *		return TRUE;
 *	}
 *
 *	// Warning!  Modifies the function parameters (NOT what they point to!).
 *	//
 *	for ( ; cValues ; cValues--, lpPropVal++)
 *	{
 *		if (FBadPropVal( lpPropVal))
 *		{
 *			return TRUE;
 *		}
 *	}
 *
 *	return FALSE;
 *}
 */

/*
 *	FBadRglpszA()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of string8 pointers, LPSTR FAR *.
 */
STDAPI_(BOOL)
FBadRglpszA( LPSTR FAR	*lppszA,
			 ULONG		cStrings)
{
	if (IsBadReadPtr( lppszA, (UINT) (cStrings * sizeof(LPSTR FAR *))))
	{
		return TRUE;
	}


	/* Check for readability of each string in the array.
	 *
	 * WARNING!
	 * Function pointers and counts are modified (NOT what they point to).
	 */
	for (; cStrings; cStrings--, lppszA++)
	{
		if (IsBadStringPtrA( *lppszA, (UINT)-1 ))
		{
			return TRUE;
		}
	}


	return FALSE;
}


/*
 *	FBadRglpszW()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of UNICODE string pointers, LPSTR FAR *.
 */
STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR	*lppszW,
			 ULONG		cStrings)
{
	if (IsBadReadPtr( lppszW, (UINT) (cStrings * sizeof(LPWSTR FAR *))))
	{
		return TRUE;
	}


	// Check for readability of each string in the array.
	//
	// WARNING!
	// Function pointers and counts are modified (NOT what they point to).
	//
	for (; cStrings; cStrings--, lppszW++)
	{
#ifdef MAC		
		if (IsBadStringPtr( *lppszW, (UINT)-1 ))
#else
		if (IsBadStringPtrW( *lppszW, (UINT)-1 ))
#endif			
		{
			return TRUE;
		}
	}


	return FALSE;
}


/*
 *	FBadRowSet()
 *
 *	Purpose:
 *		Routine to validate all rows of properties in a row set.
 *
 *	NOTE!	A NULL row pointer is assumed to be a VALID entry in a row set.
 *			A NULL row set pointer is assumed to be INVALID.
 */
STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet)
{
	LPSRow	lpRow;
	ULONG	cRows;

	if (IsBadReadPtr( lpRowSet, CbNewSRowSet(0)))
		return TRUE;
	
	if (IsBadWritePtr( lpRowSet, CbSRowSet(lpRowSet)))
		return TRUE;

	//  Short cut
	if (!lpRowSet->cRows)
		return FALSE;

	// Check each row in the set.
	// cValues == 0 is valid if and only if lpProps == NULL
	//
	for ( lpRow = lpRowSet->aRow, cRows = lpRowSet->cRows
		; cRows
		; lpRow++, cRows--)
	{
		if (   IsBadReadPtr( lpRow, sizeof(*lpRow))
#ifndef _WIN64
			|| FBadRgPropVal( lpRow->lpProps, (int) (lpRow->cValues))
#endif // _WIN64
            )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	FBadRglpNameID()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of MAPINAMEID pointers, LPMAPINAMEID FAR *.
 */
STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames)
{
	if (IsBadReadPtr( lppNameId, (UINT) (cNames * sizeof(LPMAPINAMEID FAR *))))
	{
		return TRUE;
	}


	// Check for readability of each string in the array.
	//
	for (; cNames; cNames--, lppNameId++)
	{
		LPMAPINAMEID lpName = *lppNameId;

		if (IsBadReadPtr(lpName, sizeof(MAPINAMEID)))
		{
			return TRUE;
		}

		if (IsBadReadPtr(lpName->lpguid, sizeof(GUID)))
		{
			return TRUE;
		}

		if (lpName->ulKind != MNID_ID && lpName->ulKind != MNID_STRING)
		{
			return TRUE;
		}

		if (lpName->ulKind == MNID_STRING)
		{
			if (IsBadStringPtrW( lpName->Kind.lpwstrName, (UINT)-1 ))				
			{
				return TRUE;
			}
		}

	}
	return FALSE;
}


/* FBadEntryList moved to src\lo\msvalid. */


/*============================================================================
 *	The following functions are used to determine the validity of various
 *	table-related structures.  These functions should most definitely
 *	be moved to proputil when it becomes a lib (or DLL).
 */



/*============================================================================
 -	FBadPropTag()
 -
 *		Returns TRUE if the specified prop tag isn't one of the known
 *		MAPI property types, FALSE otherwise.
 *
 *
 *	Parameter:
 *		ulPropTag	in	Proptag to validate.
 */

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag )
{
	//	Just check the type
	switch ( PROP_TYPE(ulPropTag) & ~MV_FLAG )
	{
		default:
			return TRUE;

		case PT_UNSPECIFIED:
		case PT_NULL:
		case PT_I2:
		case PT_LONG:
		case PT_R4:
		case PT_DOUBLE:
		case PT_CURRENCY:
		case PT_APPTIME:
		case PT_ERROR:
		case PT_BOOLEAN:
		case PT_OBJECT:
		case PT_I8:
		case PT_STRING8:
		case PT_UNICODE:
		case PT_SYSTIME:
		case PT_CLSID:
		case PT_BINARY:
			return FALSE;
	}
}


/*============================================================================
 -	FBadRow()
 -
 *		Returns TRUE if the specified row contains invalid (PT_ERROR or
 *		PT_NULL) columns or if any of those columns are invalid.
 *
 *
 *	Parameter:
 *		lprow	in		Row	to validate.
 */

STDAPI_(ULONG)
FBadRow( LPSRow lprow )
{
	LPSPropValue	lpprop;
	LPSPropValue	lppropT;


	if ( IsBadReadPtr(lprow, sizeof(SRow)) ||
		 IsBadReadPtr(lprow->lpProps, (size_t)(lprow->cValues * sizeof(SPropValue))) )
		return TRUE;

	lpprop = lprow->lpProps + lprow->cValues;
	while ( lpprop-- > lprow->lpProps )
	{
		if ( FBadProp(lpprop) )
			return TRUE;

		lppropT = lpprop;
		while ( lppropT-- > lprow->lpProps )
			if ( lppropT->ulPropTag == lpprop->ulPropTag &&
				 PROP_TYPE(lppropT->ulPropTag) != PT_ERROR &&
				 PROP_TYPE(lppropT->ulPropTag) != PT_NULL )
			{
				DebugTrace(  TEXT("FBadRow() - Row has multiple columns with same proptag!\n") );
				return TRUE;
			}
	}

	return FALSE;
}


/*============================================================================
 -	FBadProp()
 -
 *		Returns TRUE if the specified property is invalid.
 *
 *
 *	Parameters:
 *		lpprop	in		Property to validate.
 */

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop )
{
	ULONG	ulcb;
	LPVOID	lpv;

	if ( IsBadReadPtr(lpprop, sizeof(SPropValue)) ||
		 FBadPropTag(lpprop->ulPropTag) )
		return TRUE;

	switch ( PROP_TYPE(lpprop->ulPropTag) )
	{
		default:
			return FALSE;

		case PT_BINARY:
			ulcb = lpprop->Value.bin.cb;
			lpv = lpprop->Value.bin.lpb;
			break;

		case PT_STRING8:
			ulcb = sizeof(CHAR);
			lpv = lpprop->Value.lpszA;
			break;

#ifndef WIN16
		case PT_UNICODE:
			ulcb = sizeof(WCHAR);
			lpv = lpprop->Value.lpszW;
			break;
#endif
		case PT_CLSID:
			ulcb = sizeof(GUID);
			lpv = lpprop->Value.lpguid;
			break;

		case PT_MV_I2:
		case PT_MV_LONG:
		case PT_MV_R4:
		case PT_MV_DOUBLE:
		case PT_MV_CURRENCY:
		case PT_MV_I8:
			ulcb = UlPropSize(lpprop);
			lpv = lpprop->Value.MVi.lpi;
			break;

		case PT_MV_BINARY:
		{
			LPSBinary lpbin;
			
			if ( IsBadReadPtr(lpprop->Value.MVbin.lpbin,
							  (size_t)(lpprop->Value.MVbin.cValues *
									   sizeof(SBinary))) )
				return TRUE;

			lpbin = lpprop->Value.MVbin.lpbin + lpprop->Value.MVbin.cValues;
			while ( lpprop->Value.MVbin.lpbin < lpbin-- )
				if ( IsBadReadPtr(lpbin->lpb, (size_t)(lpbin->cb) ))
					return TRUE;

			return FALSE;
		}

		case PT_MV_STRING8:
		{
			LPCSTR FAR * lppsz;
			
			if ( IsBadReadPtr(lpprop->Value.MVszA.lppszA,
							  (size_t)(lpprop->Value.MVszA.cValues * sizeof(LPSTR))) )
				return TRUE;

			lppsz = lpprop->Value.MVszA.lppszA + lpprop->Value.MVszA.cValues;
			while ( lpprop->Value.MVszA.lppszA < lppsz-- )
// Need to break the code up this way for the Mac version
				if ( IsBadReadPtr(*lppsz, sizeof(CHAR)))
					return TRUE;
			return FALSE;
		}

		case PT_MV_UNICODE:
		{
			UNALIGNED LPWSTR FAR * lppsz;
			
			if ( IsBadReadPtr(lpprop->Value.MVszW.lppszW,
							  (size_t)(lpprop->Value.MVszW.cValues * sizeof(LPWSTR))) )
				return TRUE;

			lppsz = lpprop->Value.MVszW.lppszW + lpprop->Value.MVszW.cValues;
			while ( lpprop->Value.MVszW.lppszW < lppsz-- )
				if ( IsBadReadPtr(*lppsz, sizeof(WCHAR)))
					return TRUE;
			return FALSE;
		}
	}

	return IsBadReadPtr(lpv, (size_t) ulcb);
}


/* FBadSortOrderSet moved to src\lo\MSVALID.C */


/*============================================================================
 -	FBadColumnSet()
 -
 *		Returns TRUE if the specified column set is invalid.  For use
 *		with IMAPITable::SetColumns(), this function treats PT_ERROR columns
 *		as invalid and PT_NULL columns as valid.
 *
 *
 *	Parameter:
 *		lpptaCols		in		Column set to validate.
 */

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols )
{
	UNALIGNED ULONG FAR * pulPropTag;
	
	if ( IsBadReadPtr(lpptaCols,CbNewSPropTagArray(0)) ||
		 IsBadReadPtr(lpptaCols,CbSPropTagArray(lpptaCols)))
	{
		DebugTrace(  TEXT("FBadColumnSet() - Bad column set structure\n") );
		return TRUE;
	}

	// maximum number of proptags we can calculate size for. raid 4460
	
	if ( lpptaCols->cValues > ((INT_MAX - offsetof( SPropTagArray, aulPropTag ))
		/ sizeof( ULONG )))
	{
		DebugTrace(  TEXT("FBadColumnSet(): Exceeded maximum number of tags\n") );
		return TRUE;
	}

	pulPropTag = lpptaCols->aulPropTag + lpptaCols->cValues;
	while ( pulPropTag-- > lpptaCols->aulPropTag )
	{
		//	DCR 978: Disallow PT_ERROR columns.
		//	DCR 715: Ignore PT_NULL columns and only allow columns
		//	from initial column set.
		if ( PROP_TYPE(*pulPropTag) != PT_NULL &&
			 (PROP_TYPE(*pulPropTag) == PT_ERROR ||
			  FBadPropTag(*pulPropTag)) )
		{
			DebugTrace(  TEXT("FBadColumnSet() - Bad column 0x%08lX\n"), *pulPropTag );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\vcard.c ===
/*
 *      VCard.C - Implement VCard
 *
 * Wrap VCard in a mailuser object
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "_apipch.h"

#ifdef VCARD

// This is the current vCard version implemented in this file
//
#define CURRENT_VCARD_VERSION "2.1"
//#define CURRENT_VCARD_VERSION "2.1+"  <- The code is really this version, see the URL section in WriteVCard.

typedef enum _VC_STATE_ENUM {
    VCS_INITIAL,
    VCS_ITEMS,
    VCS_FINISHED,
    VCS_ERROR,
} VC_STATE_ENUM, *LPVC_STATE_ENUM;

typedef struct _VC_STATE {
    VC_STATE_ENUM vce;  // state
    ULONG ulEmailAddrs; // count of email addresses
    BOOL fBusinessURL;  // TRUE if we have already got a business URL
    BOOL fPersonalURL;  // TRUE if we have already got a personal URL
} VC_STATE, *LPVC_STATE;


typedef enum _VCARD_KEY {
    VCARD_KEY_NONE = -1,     // Always first
    VCARD_KEY_BEGIN = 0,
    VCARD_KEY_END,
    VCARD_KEY_ADR,
    VCARD_KEY_ORG,
    VCARD_KEY_N,
    VCARD_KEY_NICKNAME,
    VCARD_KEY_AGENT,
    VCARD_KEY_LOGO,
    VCARD_KEY_PHOTO,
    VCARD_KEY_LABEL,
    VCARD_KEY_FADR,
    VCARD_KEY_FN,
    VCARD_KEY_TITLE,
    VCARD_KEY_SOUND,
    VCARD_KEY_LANG,
    VCARD_KEY_TEL,
    VCARD_KEY_EMAIL,
    VCARD_KEY_TZ,
    VCARD_KEY_GEO,
    VCARD_KEY_NOTE,
    VCARD_KEY_URL,
    VCARD_KEY_BDAY,
    VCARD_KEY_ROLE,
    VCARD_KEY_REV,
    VCARD_KEY_UID,
    VCARD_KEY_KEY,
    VCARD_KEY_MAILER,
    VCARD_KEY_X,
    VCARD_KEY_VCARD,
    VCARD_KEY_VERSION,
    VCARD_KEY_X_WAB_GENDER,
    VCARD_KEY_MAX,
} VCARD_KEY, *LPVCARD_KEY;


// MUST be maintained in same order as _VCARD_KEY enum
const LPSTR vckTable[VCARD_KEY_MAX] = {
     "BEGIN",            // VCARD_KEY_BEGIN
     "END",              // VCARD_KEY_END
     "ADR",              // VCARD_KEY_ADR
     "ORG",              // VCARD_KEY_ORG
     "N",                // VCARD_KEY_N
     "NICKNAME",         // VCARD_KEY_NICKNAME
     "AGENT",            // VCARD_KEY_AGENT
     "LOGO",             // VCARD_KEY_LOGO
     "PHOTO",            // VCARD_KEY_PHOTO
     "LABEL",            // VCARD_KEY_LABEL
     "FADR",             // VCARD_KEY_FADR
     "FN",               // VCARD_KEY_FN
     "TITLE",            // VCARD_KEY_TITLE
     "SOUND",            // VCARD_KEY_SOUND
     "LANG",             // VCARD_KEY_LANG
     "TEL",              // VCARD_KEY_TEL
     "EMAIL",            // VCARD_KEY_EMAIL
     "TZ",               // VCARD_KEY_TZ
     "GEO",              // VCARD_KEY_GEO
     "NOTE",             // VCARD_KEY_NOTE
     "URL",              // VCARD_KEY_URL
     "BDAY",             // VCARD_KEY_BDAY
     "ROLE",             // VCARD_KEY_ROLE
     "REV",              // VCARD_KEY_REV
     "UID",              // VCARD_KEY_UID
     "KEY",              // VCARD_KEY_KEY
     "MAILER",           // VCARD_KEY_MAILER
     "X-",               // VCARD_KEY_X
     "VCARD",            // VCARD_KEY_VCARD
     "VERSION",          // VCARD_KEY_VERSION
     "X-WAB-GENDER",     // VCARD_KEY_X_WAB_GENDER
};

typedef enum _VCARD_TYPE {
    VCARD_TYPE_NONE = -1,    // always first
    VCARD_TYPE_DOM = 0,
    VCARD_TYPE_INTL,
    VCARD_TYPE_POSTAL,
    VCARD_TYPE_PARCEL,
    VCARD_TYPE_HOME,
    VCARD_TYPE_WORK,
    VCARD_TYPE_PREF,
    VCARD_TYPE_VOICE,
    VCARD_TYPE_FAX,
    VCARD_TYPE_MSG,
    VCARD_TYPE_CELL,
    VCARD_TYPE_PAGER,
    VCARD_TYPE_BBS,
    VCARD_TYPE_MODEM,
    VCARD_TYPE_CAR,
    VCARD_TYPE_ISDN,
    VCARD_TYPE_VIDEO,
    VCARD_TYPE_AOL,
    VCARD_TYPE_APPLELINK,
    VCARD_TYPE_ATTMAIL,
    VCARD_TYPE_CIS,
    VCARD_TYPE_EWORLD,
    VCARD_TYPE_INTERNET,
    VCARD_TYPE_IBMMAIL,
    VCARD_TYPE_MSN,
    VCARD_TYPE_MCIMAIL,
    VCARD_TYPE_POWERSHARE,
    VCARD_TYPE_PRODIGY,
    VCARD_TYPE_TLX,
    VCARD_TYPE_X400,
    VCARD_TYPE_GIF,
    VCARD_TYPE_CGM,
    VCARD_TYPE_WMF,
    VCARD_TYPE_BMP,
    VCARD_TYPE_MET,
    VCARD_TYPE_PMB,
    VCARD_TYPE_DIB,
    VCARD_TYPE_PICT,
    VCARD_TYPE_TIFF,
    VCARD_TYPE_ACROBAT,
    VCARD_TYPE_PS,
    VCARD_TYPE_JPEG,
    VCARD_TYPE_QTIME,
    VCARD_TYPE_MPEG,
    VCARD_TYPE_MPEG2,
    VCARD_TYPE_AVI,
    VCARD_TYPE_WAVE,
    VCARD_TYPE_AIFF,
    VCARD_TYPE_PCM,
    VCARD_TYPE_X509,
    VCARD_TYPE_PGP,
    VCARD_TYPE_MAX
} VCARD_TYPE, *LPVCARD_TYPE;


// MUST be maintained in same order as _VCARD_TYPE enum
const LPSTR vctTable[VCARD_TYPE_MAX] = {
     "DOM",              // VCARD_TYPE_DOM
     "INTL",             // VCARD_TYPE_INTL
     "POSTAL",           // VCARD_TYPE_POSTAL
     "PARCEL",           // VCARD_TYPE_PARCEL
     "HOME",             // VCARD_TYPE_HOME
     "WORK",             // VCARD_TYPE_WORK
     "PREF",             // VCARD_TYPE_PREF
     "VOICE",            // VCARD_TYPE_VOICE
     "FAX",              // VCARD_TYPE_FAX
     "MSG",              // VCARD_TYPE_MSG
     "CELL",             // VCARD_TYPE_CELL
     "PAGER",            // VCARD_TYPE_PAGER
     "BBS",              // VCARD_TYPE_BBS
     "MODEM",            // VCARD_TYPE_MODEM
     "CAR",              // VCARD_TYPE_CAR
     "ISDN",             // VCARD_TYPE_ISDN
     "VIDEO",            // VCARD_TYPE_VIDEO
     "AOL",              // VCARD_TYPE_AOL
     "APPLELINK",        // VCARD_TYPE_APPLELINK
     "ATTMAIL",          // VCARD_TYPE_ATTMAIL
     "CIS",              // VCARD_TYPE_CIS
     "EWORLD",           // VCARD_TYPE_EWORLD
     "INTERNET",         // VCARD_TYPE_INTERNET
     "IBMMAIL",          // VCARD_TYPE_IBMMAIL
     "MSN",              // VCARD_TYPE_MSN
     "MCIMAIL",          // VCARD_TYPE_MCIMAIL
     "POWERSHARE",       // VCARD_TYPE_POWERSHARE
     "PRODIGY",          // VCARD_TYPE_PRODIGY
     "TLX",              // VCARD_TYPE_TLX
     "X400",             // VCARD_TYPE_X400
     "GIF",              // VCARD_TYPE_GIF
     "CGM",              // VCARD_TYPE_CGM
     "WMF",              // VCARD_TYPE_WMF
     "BMP",              // VCARD_TYPE_BMP
     "MET",              // VCARD_TYPE_MET
     "PMB",              // VCARD_TYPE_PMB
     "DIB",              // VCARD_TYPE_DIB
     "PICT",             // VCARD_TYPE_PICT
     "TIFF",             // VCARD_TYPE_TIFF
     "ACROBAT",          // VCARD_TYPE_ACROBAT
     "PS",               // VCARD_TYPE_PS
     "JPEG",             // VCARD_TYPE_JPEG
     "QTIME",            // VCARD_TYPE_QTIME
     "MPEG",             // VCARD_TYPE_MPEG
     "MPEG2",            // VCARD_TYPE_MPEG2
     "AVI",              // VCARD_TYPE_AVI
     "WAVE",             // VCARD_TYPE_WAVE
     "AIFF",             // VCARD_TYPE_AIFF
     "PCM",              // VCARD_TYPE_PCM
     "X509",             // VCARD_TYPE_X509
     "PGP",              // VCARD_TYPE_PGP
};


typedef enum _VCARD_PARAM{
    VCARD_PARAM_NONE = -1,      // always first
    VCARD_PARAM_TYPE = 0,
    VCARD_PARAM_ENCODING,
    VCARD_PARAM_LANGUAGE,
    VCARD_PARAM_VALUE,
    VCARD_PARAM_CHARSET,
    VCARD_PARAM_MAX,
} VCARD_PARAM, *LPVCARD_PARAM;

// MUST be maintained in same order as _VCARD_PARAM enum
const LPSTR vcpTable[VCARD_PARAM_MAX] = {
     "TYPE",             // VCARD_PARAM_TYPE
     "ENCODING",         // VCARD_PARAM_ENCODING
     "LANGUAGE",         // VCARD_PARAM_LANGUAGE
     "VALUE",            // VCARD_PARAM_VALUE
     "CHARSET",          // VCARD_PARAM_CHARSET
};


typedef enum _VCARD_ENCODING{
    VCARD_ENCODING_NONE = -1,  // always first
    VCARD_ENCODING_QUOTED_PRINTABLE = 0,
    VCARD_ENCODING_BASE64,
    VCARD_ENCODING_7BIT,
    VCARD_ENCODING_8BIT,
    VCARD_ENCODING_X,
    VCARD_ENCODING_MAX,
} VCARD_ENCODING, *LPVCARD_ENCODING;


// MUST be maintained in same order as _VCARD_ENCODING enum
const LPSTR vceTable[VCARD_ENCODING_MAX] = {
     "QUOTED-PRINTABLE", // VCARD_ENCODING_QUOTED_PRINTABLE
     "BASE64",           // VCARD_ENCODING_BASE64
     "7BIT",             // VCARD_ENCODING_7BIT
     "8BIT",             // VCARD_ENCODING_8BIT
     "X-",               // VCARD_ENCODING_X
};

const LPTSTR szColon =   TEXT(":");
const LPSTR szColonA =   ":";
const LPTSTR szSemicolon =   TEXT(";");
const LPSTR szEquals =   "=";
const LPSTR szCRLFA =   "\r\n";
const LPTSTR szCRLF =   TEXT("\r\n");
const LPTSTR szCommaSpace =   TEXT(", ");
const LPTSTR szSpace = TEXT(" ");
const LPTSTR szX400 =   TEXT("X400");
const LPSTR szSMTPA =  "SMTP";

typedef struct _VCARD_PARAM_FLAGS {
    int fTYPE_DOM:1;
    int fTYPE_INTL:1;
    int fTYPE_POSTAL:1;
    int fTYPE_PARCEL:1;
    int fTYPE_HOME:1;
    int fTYPE_WORK:1;
    int fTYPE_PREF:1;
    int fTYPE_VOICE:1;
    int fTYPE_FAX:1;
    int fTYPE_MSG:1;
    int fTYPE_CELL:1;
    int fTYPE_PAGER:1;
    int fTYPE_BBS:1;
    int fTYPE_MODEM:1;
    int fTYPE_CAR:1;
    int fTYPE_ISDN:1;
    int fTYPE_VIDEO:1;
    int fTYPE_AOL:1;
    int fTYPE_APPLELINK:1;
    int fTYPE_ATTMAIL:1;
    int fTYPE_CIS:1;
    int fTYPE_EWORLD:1;
    int fTYPE_INTERNET:1;
    int fTYPE_IBMMAIL:1;
    int fTYPE_MSN:1;
    int fTYPE_MCIMAIL:1;
    int fTYPE_POWERSHARE:1;
    int fTYPE_PRODIGY:1;
    int fTYPE_TLX:1;
    int fTYPE_X400:1;
    int fTYPE_GIF:1;
    int fTYPE_CGM:1;
    int fTYPE_WMF:1;
    int fTYPE_BMP:1;
    int fTYPE_MET:1;
    int fTYPE_PMB:1;
    int fTYPE_DIB:1;
    int fTYPE_PICT:1;
    int fTYPE_TIFF:1;
    int fTYPE_ACROBAT:1;
    int fTYPE_PS:1;
    int fTYPE_JPEG:1;
    int fTYPE_QTIME:1;
    int fTYPE_MPEG:1;
    int fTYPE_MPEG2:1;
    int fTYPE_AVI:1;
    int fTYPE_WAVE:1;
    int fTYPE_AIFF:1;
    int fTYPE_PCM:1;
    int fTYPE_X509:1;
    int fTYPE_PGP:1;
    int fPARAM_TYPE:1;
    int fPARAM_ENCODING:1;
    int fPARAM_LANGUAGE:1;
    int fPARAM_VALUE:1;
    int fPARAM_CHARSET:1;
    int fENCODING_QUOTED_PRINTABLE:1;
    int fENCODING_BASE64:1;
    int fENCODING_7BIT:1;
    int fENCODING_X:1;
    LPSTR szPARAM_LANGUAGE;
    LPSTR szPARAM_CHARSET;

} VCARD_PARAM_FLAGS, *LPVCARD_PARAM_FLAGS;

// 
// For WAB clients that use named props and want to get/put their unique data
// in the vCards as extended vCard properties, we will store these extended
// props in a linked list and use it when importing/exporting a vCard
//
typedef struct _ExtVCardProp
{
    ULONG ulExtPropTag;
    LPSTR lpszExtPropName;
    struct _ExtVCardProp * lpNext;
} EXTVCARDPROP, * LPEXTVCARDPROP;


CONST CHAR six2base64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

CONST INT base642six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

HRESULT ReadLn(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppLine, LPULONG lpcbItem,
  LPSTR * lppBuffer, LPULONG lpcbBuffer);
HRESULT InterpretVCardItem (LPSTR lpName, LPSTR lpOption, LPSTR lpData,
  LPMAILUSER lpMailUser, LPEXTVCARDPROP lpList, LPVC_STATE lpvcs);
void ParseVCardItem(LPSTR lpBuffer, LPSTR * lppName, LPSTR * lppOption, LPSTR * lppData);
HRESULT ParseVCardType(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
HRESULT ParseVCardParams(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
VCARD_KEY RecognizeVCardKeyWord(LPSTR lpName);
HRESULT ParseVCardEncoding(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
HRESULT ReadVCardItem(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppBuffer, LPULONG lpcbBuffer);
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten);
HRESULT ParseCert( LPSTR lpData, ULONG cbData, LPMAILUSER lpMailUser );
HRESULT DecodeBase64(LPSTR bufcoded,LPSTR pbuffdecoded, PDWORD pcbDecoded);
HRESULT WriteVCardValue(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE lpData, ULONG cbData);

/***************************************************************************

    Name      : FreeExtVCardPropList

    Purpose   : Frees the localalloced list of extended props that we
                get/set on a vCard

    Parameters: lpList -> list to free up

    Returns   : void

    Comment   :

***************************************************************************/
void FreeExtVCardPropList(LPEXTVCARDPROP lpList)
{
    LPEXTVCARDPROP lpTmp = lpList;
    while(lpTmp)
    {
        lpList = lpList->lpNext;
        LocalFreeAndNull(&lpTmp->lpszExtPropName);
        LocalFree(lpTmp);
        lpTmp = lpList;
    }
}

/***************************************************************************

    Name      : HrGetExtVCardPropList

    Purpose   : Reads the registry for registered named props for VCard 
                import/export and gets the named prop names and guids
                and extended prop strings and turns them into proper tags
                and stores these tags and strings in a linked list 

    Parameters: lppList -> list to return

    Returns   : HRESULT

    Comment   :

***************************************************************************/
static const TCHAR szNamedVCardPropsRegKey[] =  TEXT("Software\\Microsoft\\WAB\\WAB4\\NamedVCardProps");
 
HRESULT HrGetExtVCardPropList(LPMAILUSER lpMailUser, LPEXTVCARDPROP * lppList)
{
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    LPEXTVCARDPROP lpList = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    TCHAR szGuidName[MAX_PATH];

    if(!lppList)
        goto out;
    *lppList = NULL;

    // 
    // We will look in the registry under HKLM\Software\Microsoft\WAB\WAB4\NamedVCardProps
    // If this key exists, we enumerate all sub keys under it
    // The format for this key is
    //
    // HKLM\Software\Microsoft\WAB\WAB4\NamedVCardProps
    //          Guid1
    //              PropString1:PropName1
    //              PropString1:PropName2
    //          Guid2
    //              PropString1:PropName1
    // etc
    //

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    szNamedVCardPropsRegKey,
                                    0, KEY_READ,
                                    &hKey))
    {
        goto out;
    }

    *szGuidName = '\0';
    dwSize = CharSizeOf(szGuidName);

    // Found the key, now enumerate all sub keys ...
    while(ERROR_SUCCESS == RegEnumKeyEx(hKey, dwIndex, szGuidName, &dwSize, NULL, NULL, NULL, NULL))
    {
        GUID guidTmp = {0};
        unsigned short szW[MAX_PATH];

        lstrcpy(szW, szGuidName);
        if( !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
        {
            HKEY hGuidKey = NULL;

            // Open the GUID key
            if(ERROR_SUCCESS == RegOpenKeyEx(hKey, szGuidName, 0, KEY_READ, &hGuidKey))
            {
                TCHAR szValName[MAX_PATH];
                DWORD dwValIndex = 0, dwValSize = CharSizeOf(szValName);
                DWORD dwType = 0, dwTagName = 0, dwTagSize = sizeof(DWORD);
                TCHAR szTagName[MAX_PATH];

                *szValName = '\0';

                while(ERROR_SUCCESS == RegEnumValue(hGuidKey, dwValIndex, 
                                                    szValName, &dwValSize, 
                                                    0, &dwType, 
                                                    NULL, NULL))
                {
                    MAPINAMEID mnid = {0};
                    LPMAPINAMEID lpmnid = NULL;
                    LPSPropTagArray lpspta = NULL;

                    *szTagName = '\0';
                    // Check if this is a NAME or an ID
                    
                    if(dwType == REG_DWORD)
                    {
                        dwTagSize = sizeof(DWORD);
                        //Read in the Value
                        if(ERROR_SUCCESS != RegQueryValueEx(hGuidKey, szValName,
                                                            0, &dwType, 
                                                            (LPBYTE) &dwTagName, &dwTagSize))
                        {
                            continue;
                        }
                    }
                    else if(dwType == REG_SZ)
                    {
                        dwTagSize = CharSizeOf(szTagName);
                        //Read in the Value
                        if(ERROR_SUCCESS != RegQueryValueEx(hGuidKey, szValName,
                                                            0, &dwType, 
                                                            (LPBYTE) szTagName, &dwTagSize))
                        {
                            continue;
                        }
                    }

                    //
                    // At this point I have the GUID, the name of the named prop, and the
                    // ExtendedPropString for this prop ..
                    //
                    // First get the actual named proptag from this GUID
                    //

                    mnid.lpguid = &guidTmp;
                    if(lstrlen(szTagName))
                    {
                        mnid.ulKind = MNID_STRING;
                        mnid.Kind.lpwstrName = (LPWSTR) szTagName;
                    }
                    else
                    {
                        mnid.ulKind = MNID_ID;
                        mnid.Kind.lID = dwTagName;
                    }
                    lpmnid = &mnid;
                    if(!HR_FAILED(lpMailUser->lpVtbl->GetIDsFromNames(  lpMailUser, 
                                                                        1, &lpmnid,
                                                                        MAPI_CREATE, // Dont create if it dont exist 
                                                                        &lpspta)))
                    {
                        // Got the tag
                        if(lpspta->aulPropTag[0] && lpspta->cValues)
                        {
                            LPEXTVCARDPROP lpTmp = LocalAlloc(LMEM_ZEROINIT, sizeof(EXTVCARDPROP));
                            if(lpTmp)
                            {
                                lpTmp->lpszExtPropName = ConvertWtoA(szValName);
                                if(lpTmp->lpszExtPropName)
                                {
                                    lpTmp->ulExtPropTag = CHANGE_PROP_TYPE(lpspta->aulPropTag[0],PT_STRING8);
                                    lpTmp->lpNext = lpList;
                                    lpList = lpTmp;
                                }
                                else
                                    LocalFree(lpTmp);
                            }
                        }
                        if(lpspta)
                            MAPIFreeBuffer(lpspta);
                    }

                    dwValIndex++;
                    *szValName = '\0';
                    dwValSize = CharSizeOf(szValName);
                }
            }
            if(hGuidKey)
                RegCloseKey(hGuidKey);
        }
        dwIndex++;
        *szGuidName = '\0';
        dwSize = CharSizeOf(szGuidName);
    }

    *lppList = lpList;
    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    if(HR_FAILED(hr) && lpList)
        FreeExtVCardPropList(lpList);

    return hr;

}

const static int c_cchMaxWin9XBuffer = 1000;

/***************************************************************************

    Name      : ReadVCard

    Purpose   : Reads a vCard from a file to a MAILUSER object.

    Parameters: hVCard = open handle to VCard object
                ReadFn = Read function to read hVCard, looks like ReadFile().
                lpMailUser -> open mailuser object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ReadVCard(HANDLE hVCard, VCARD_READ ReadFn, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    LPSTR lpBuffer = NULL;
    LPSTR lpName, lpOption, lpData;
    ULONG cbBuffer;
    VC_STATE vcs;
    LPEXTVCARDPROP lpList = NULL;

    vcs.vce = VCS_INITIAL;
    vcs.ulEmailAddrs = 0;
    vcs.fBusinessURL = FALSE;
    vcs.fPersonalURL = FALSE;

    //
    // See if there are any named props we need to handle on import
    //
    HrGetExtVCardPropList(lpMailUser, &lpList);


    while ( !HR_FAILED(hResult) && 
            !(HR_FAILED(hResult = ReadVCardItem(hVCard, ReadFn, &lpBuffer, &cbBuffer))) && 
            lpBuffer &&
            (vcs.vce != VCS_FINISHED)) 
    {
        ParseVCardItem(lpBuffer, &lpName, &lpOption, &lpData);

        // [PaulHi] 5/13/99  Win9X cannot handle strings larger than 1023 characters
        // in length (FormatMessage() is one example).  And can cause buffer overruns
        // and crashes.  If we get VCard data greater than this then we must not add
        // it to the lpMailUser object, or risk crashing Win9X when trying to display.
        // Instead just truncate so user can salvage as much as possible.
		//
		// YSt 6/25/99 if vCard has certificate then buffer may be more than 1000 bytes, we need to exlude this case
		// from this checkin.
		// I suppose that certificate has VCARD_KEY_KEY tag
        if (!g_bRunningOnNT && (lpName && lstrcmpiA(lpName, vckTable[VCARD_KEY_KEY])) && lpData && (lstrlenA(lpData) > c_cchMaxWin9XBuffer) )
            lpData[c_cchMaxWin9XBuffer] = '\0';

        if (lpName && lpData) 
        {
            if (hResult = InterpretVCardItem(lpName, lpOption, lpData, lpMailUser, lpList, &vcs)) 
            {
                DebugTrace( TEXT("ReadVCard:InterpretVCardItem -> %x"), GetScode(hResult));
            }
        }
        LocalFreeAndNull(&lpBuffer);
    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    if(lpList)
        FreeExtVCardPropList(lpList);

    return(hResult);
}

/***************************************************************************

    Name      : BufferReadFn

    Purpose   : Read from the supplied buffer

    Parameters: handle = pointer to SBinary in which the
                        lpb contains the source buffer and the
                        cb param contains how much of the buffer has
                        been parsed
                lpBuffer -> buffer to read to
                uBytes = size of lpBuffer
                lpcbRead -> returned bytes read

    Returns   : HRESULT

***************************************************************************/
HRESULT BufferReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead) {

    LPSBinary lpsb = (LPSBinary) handle;
    LPSTR lpBuf = (LPSTR) lpsb->lpb;
    LPSTR lpSrc = lpBuf + lpsb->cb;

    *lpcbRead = 0;

    if(!lstrlenA(lpSrc))
        return(ResultFromScode(WAB_W_END_OF_DATA));

    if(uBytes > (ULONG) lstrlenA(lpSrc))
        uBytes = lstrlenA(lpSrc);

    CopyMemory(lpBuffer, lpSrc, uBytes);

    lpsb->cb += uBytes;

    *lpcbRead = uBytes;

    return(hrSuccess);
}


/***************************************************************************

    Name      : FileReadFn

    Purpose   : Read from the file handle

    Parameters: handle = open file handle
                lpBuffer -> buffer to read to
                uBytes = size of lpBuffer
                lpcbRead -> returned bytes read

    Returns   : HRESULT

    Comment   : ReadFile callback for ReadVCard

***************************************************************************/
HRESULT FileReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead) {
    *lpcbRead = 0;

    if (! ReadFile(handle,
      lpBuffer,
      uBytes,
      lpcbRead,
      NULL)) {
        DebugTrace( TEXT("FileReadFn:ReadFile -> %u\n"), GetLastError());
        return(ResultFromScode(MAPI_E_DISK_ERROR));
    }

    if (*lpcbRead == 0) {
        return(ResultFromScode(WAB_W_END_OF_DATA));
    }

    return(hrSuccess);
}


/***************************************************************************

    Name      : TrimLeadingWhitespace

    Purpose   : Move the pointer past any whitespace.

    Parameters: lpBuffer -> string (null terminated)

    Returns   : pointer to next non-whitespace or NULL if end of line

    Comment   :

***************************************************************************/
LPBYTE TrimLeadingWhitespace(LPBYTE lpBuffer) {
    while (*lpBuffer) {
        switch (*lpBuffer) {
            case ' ':
            case '\t':
                lpBuffer++;
                break;
            default:
                return(lpBuffer);
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : TrimTrailingWhiteSpace

    Purpose   : Trims off the trailing white space

    Parameters: lpString = string to trim

    Returns   : none

    Comment   : Starts at the end of the string, moving the EOS marker back
                until a non-whitespace character is found.  Space and Tab
                are the only whitespace characters recognized.

***************************************************************************/
void TrimTrailingWhiteSpace(LPSTR lpString)
{
   register LPSTR lpEnd;

   lpEnd = lpString + (lstrlenA(lpString) - 1);
   while ((lpEnd >= lpString) && ((*lpEnd == ' ') || (*lpEnd == '\t'))) {
       *(lpEnd--) = '\0';
   }
}


/***************************************************************************

    Name      : ParseWord

    Purpose   : Move the pointer to the next word and null the end of the
                current word.  (null terminated)

    Parameters: lpBuffer -> current word
                ch = delimiter character

    Returns   : pointer to next word or NULL if end of line

    Comment   :

***************************************************************************/
LPSTR ParseWord(LPSTR lpString, TCHAR ch) {
    while (*lpString) {
        if (*lpString == ch) {
            *lpString++ = '\0';
            lpString = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpString);
            if (lpString && *lpString) {
                return(lpString);
            } else {
                return(NULL);
            }
        }
        lpString++;
    }

    // Didn't find another word.
    return(NULL);
}


/***************************************************************************

    Name      : RecognizeVCardKeyWord

    Purpose   : Recognize the vCard keyword (null terminated)

    Parameters: lpName -> start of key name

    Returns   : VCARD_KEY value

    Comment   :

***************************************************************************/
VCARD_KEY RecognizeVCardKeyWord(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_KEY_MAX; i++) {
        if (! lstrcmpiA(vckTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_KEY_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : RecognizeVCardType

    Purpose   : Recognize the vCard type option (null terminated)

    Parameters: lpName -> start of type name

    Returns   : VCARD_OPTION value

    Comment   :

***************************************************************************/
VCARD_TYPE RecognizeVCardType(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_TYPE_MAX; i++) {
        if (! lstrcmpiA(vctTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_TYPE_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : RecognizeVCardParam

    Purpose   : Recognize the vCard param (null terminated)

    Parameters: lpName -> start of param name

    Returns   : VCARD_PARAM value

    Comment   :

***************************************************************************/
VCARD_PARAM RecognizeVCardParam(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_PARAM_MAX; i++) {
        if (! lstrcmpiA(vcpTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_PARAM_NONE);
}


/***************************************************************************

    Name      : RecognizeVCardEncoding

    Purpose   : Recognize the vCard encoding (null terminated)

    Parameters: lpName -> start of encoding name

    Returns   : VCARD_ENCODING value

    Comment   :

***************************************************************************/
VCARD_ENCODING RecognizeVCardEncoding(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_ENCODING_MAX; i++) {
        if (! lstrcmpiA(vceTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_ENCODING_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : ParseVCardItem

    Purpose   : Parse the vCard item into components

    Parameters: lpBuffer = current input line (null terminated)
                lppName -> returned property name pointer
                lppOption -> returned options string pointer
                lppData -> returned data string pointer

    Returns   : none

    Comment   : Expects the keyword to be in the current line (lpBuffer), but
                may read more lines as necesary to get a complete item.

***************************************************************************/
void ParseVCardItem(LPSTR lpBuffer, LPSTR * lppName, LPSTR * lppOption, LPSTR * lppData) {
    TCHAR ch;
    BOOL fColon = FALSE;
    BOOL fSemicolon = FALSE;


    *lppName = *lppOption = *lppData = NULL;

    // Find the Name
    if (lpBuffer = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer)) {
        *lppName = lpBuffer;

        while (ch = *lpBuffer) {
            switch (ch) {
                case ':':   // found end of name/options
                    fColon = TRUE;
                    // data follows whitespace
                    *lppData = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                    *lpBuffer = '\0';   // null out colon
                    goto exit;

                case ';':   // found an option seperator
                    if (! fSemicolon) {
                        fSemicolon = TRUE;
                        // option follows semicolon and whitespace
                        *lppOption = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                        *lpBuffer = '\0';   // null out first semicolon
                    }
                    break;

                case '.':   // end of a group prefix
                    if (! fColon && ! fSemicolon) {
                        // Yes, this is a group prefix.  Get past it.
                        *lppName = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                    }
                    break;

                default:    // normal character
                    break;
            }

            lpBuffer++;
        }
    }
exit:
    return;
}


/***************************************************************************

    Name      : ParseName

    Purpose   : parse the name into properites

    Parameters: lpvcpf = parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard names are of the form:
                 TEXT("surname; given name; middle name; prefix; suffix")

***************************************************************************/
HRESULT ParseName(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[5] = {0};
    register LPSTR lpCurrent;
    ULONG i = 0;

    // Look for Surname
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_SURNAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_GIVEN_NAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_MIDDLE_NAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_DISPLAY_NAME_PREFIX, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_GENERATION, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseName:SetProps -> %x\n"), GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : ParseAdr

    Purpose   : parse the address into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard addreses are of the form:
                 TEXT("PO box; extended addr; street addr; city; region; postal code; country")

                Option: DOM; INTL; POSTAL; PARCEL; HOME; WORK; PREF; CHARSET; LANGUAGE

                We will combine extended addr and street addr into PR_STREET_ADDRESS.

***************************************************************************/
HRESULT ParseAdr(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[7] = {0};   // must keep up with props set from ADR!
    register LPSTR lpCurrent;
    ULONG i = 0;
    LPSTR lpStreetAddr = NULL;
    LPSTR lpExtendedAddr = NULL;
    ULONG cbAddr = 0;
    LPSTR lpAddr = NULL;
    SCODE sc;
    BOOL fHome = lpvcpf->fTYPE_HOME;
    BOOL fBusiness = lpvcpf->fTYPE_WORK;  
    //
    // default is other type of address

    // Look for PO box
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_POST_OFFICE_BOX, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_POST_OFFICE_BOX, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_POST_OFFICE_BOX, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }
    // extended addr
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            lpExtendedAddr = lpCurrent;
        }
    }
    // Street address
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            lpStreetAddr = lpCurrent;
        }
    }
    if (fBusiness) {    // BUSINESS
         if (lpExtendedAddr) {
            // have a business extended addr field
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OFFICE_LOCATION, PT_STRING8);
            spv[i].Value.lpszA = lpExtendedAddr;;
            i++;
         }
         if (lpStreetAddr) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA = lpStreetAddr;;
            i++;
         }
    } else {            // HOME
        // Don't have extended for home
        if (! lpExtendedAddr && lpStreetAddr) {
            if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA= lpStreetAddr;
            i++;
        } else if (lpExtendedAddr && ! lpStreetAddr) {
            if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA= lpExtendedAddr;
            i++;
        } else {
            // Have to concatenate Extended and Street address
            if (lpExtendedAddr) {
                cbAddr = (lstrlenA(lpExtendedAddr)+1);
            }
            if (lpStreetAddr) {
                cbAddr += (lstrlenA(lpStreetAddr)+1);
            }
            if (cbAddr) {
                // room for CR and NULL
                if (sc = MAPIAllocateBuffer(cbAddr, &lpAddr)) {
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                if (lpExtendedAddr) {
                    lstrcpyA(lpAddr, lpExtendedAddr);
                    if (lpStreetAddr) {
                        lstrcatA(lpAddr,  "\n");
                    }
                    lstrcatA(lpAddr, lpStreetAddr);
                } else if (lpStreetAddr) {
                    lstrcpyA(lpAddr, lpStreetAddr);
                }

                if(fHome)
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
                else
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
                spv[i].Value.lpszA= lpAddr;
                i++;
            }
        }
    }


    // locality (city)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_CITY, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_CITY, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_CITY, PT_STRING8);
           spv[i].Value.lpszA= lpCurrent;
           i++;
        }
    }

    // region (state/province)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    // postal code
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_POSTAL_CODE, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_POSTAL_CODE, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_POSTAL_CODE, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    // Country
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_COUNTRY, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_COUNTRY, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_COUNTRY, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseAdr:SetProps -> %x\n"), GetScode(hResult));
        }
    }
exit:
    FreeBufferAndNull(&lpAddr);

    return(hResult);
}


enum {
    iphPR_BUSINESS_FAX_NUMBER,
    iphPR_HOME_FAX_NUMBER,
    iphPR_CELLULAR_TELEPHONE_NUMBER,
    iphPR_CAR_TELEPHONE_NUMBER,
    iphPR_ISDN_NUMBER,
    iphPR_PAGER_TELEPHONE_NUMBER,
    iphPR_BUSINESS_TELEPHONE_NUMBER,
    iphPR_BUSINESS2_TELEPHONE_NUMBER,
    iphPR_HOME_TELEPHONE_NUMBER,
    iphPR_HOME2_TELEPHONE_NUMBER,
    iphPR_PRIMARY_TELEPHONE_NUMBER,
    iphPR_OTHER_TELEPHONE_NUMBER,
    iphMax
};

SizedSPropTagArray(iphMax, tagaPhone) = {
        iphMax,
   {
       PR_BUSINESS_FAX_NUMBER,
       PR_HOME_FAX_NUMBER,
       PR_CELLULAR_TELEPHONE_NUMBER,
       PR_CAR_TELEPHONE_NUMBER,
       PR_ISDN_NUMBER,
       PR_PAGER_TELEPHONE_NUMBER,
       PR_BUSINESS_TELEPHONE_NUMBER,
       PR_BUSINESS2_TELEPHONE_NUMBER,
       PR_HOME_TELEPHONE_NUMBER,
       PR_HOME2_TELEPHONE_NUMBER,
       PR_PRIMARY_TELEPHONE_NUMBER,
       PR_OTHER_TELEPHONE_NUMBER
        }
};
/***************************************************************************

    Name      : ParseTel

    Purpose   : parse the telephone number into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseTel(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[iphMax] = {0};
    ULONG i = 0;
    BOOL fBusiness = lpvcpf->fTYPE_WORK;// || ! lpvcpf->fTYPE_HOME;  // default is business
    BOOL fHome = lpvcpf->fTYPE_HOME;
    BOOL fFax = lpvcpf->fTYPE_FAX;
    BOOL fCell = lpvcpf->fTYPE_CELL;
    BOOL fCar = lpvcpf->fTYPE_CAR;
    BOOL fModem = lpvcpf->fTYPE_MODEM;
    BOOL fISDN = lpvcpf->fTYPE_ISDN;
    BOOL fPager = lpvcpf->fTYPE_PAGER;
    BOOL fBBS = lpvcpf->fTYPE_BBS;
    BOOL fVideo = lpvcpf->fTYPE_VIDEO;
    BOOL fMsg = lpvcpf->fTYPE_MSG;
    BOOL fVoice = lpvcpf->fTYPE_VOICE | (! (fMsg | fFax | fModem | fISDN | fPager | fBBS));
    BOOL fPref = lpvcpf->fTYPE_PREF;
    LPSPropValue lpaProps = NULL;
    ULONG ulcProps;

    // if this is not a prefered address, and its not home or business
    // turn it into a business number - we make this exception for the
    // primary_telephone_number which we output with the PREF prefix
    if(!fPref && !fBusiness && !fHome && !fVoice)
        fBusiness = TRUE;

    // FAX #
    if (lpData && *lpData) {

        // What is already there?
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaPhone,
          0, //MAPI_UNICODE,    // ulFlags,
          &ulcProps,
          &lpaProps))) {
            DebugTraceResult( TEXT("ParseTel:GetProps(DL)\n"), hResult);
            // No properties, not fatal.
        }


        if (fFax) {
            if (fBusiness) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS_FAX_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_FAX_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            if (fHome) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME_FAX_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_FAX_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
        }

        // CELL #
        if (fCell) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_CELLULAR_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_CELLULAR_TELEPHONE_NUMBER, PT_STRING8);    // not business/home specific
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // CAR #
        if (fCar) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_CAR_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_CAR_TELEPHONE_NUMBER, PT_STRING8);         // not business/home specific
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // ISDN #
        if (fISDN) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_ISDN_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_ISDN_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // PAGER #
        if (fPager) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_PAGER_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_PAGER_TELEPHONE_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // VOICE #
        if (fVoice) {
            if (fBusiness) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
                else if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS2_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS2_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            else
            if (fHome) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
                else if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME2_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME2_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            else
            {
                if (lpvcpf->fTYPE_VOICE && PROP_ERROR(lpaProps[iphPR_OTHER_TELEPHONE_NUMBER])
                    && !(fFax | fCell | fCar | fModem | fISDN | fPager | fBBS | fVideo | fMsg) ) 
                {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
        }

        if(fPref && !fFax && !fCell && !fCar && !fModem && !fISDN && !fPager && !fBBS && !fMsg)
        {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_PRIMARY_TELEPHONE_NUMBER, PT_STRING8);
            spv[i].Value.lpszA= lpData;
            i++;
        }

        // Store the first one of BBS, MODEM, or VIDEO that we get
        //
        if (fMsg || fBBS || fModem || fVideo) 
        {
            if (PROP_ERROR(lpaProps[iphPR_OTHER_TELEPHONE_NUMBER])) 
            {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_TELEPHONE_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        FreeBufferAndNull(&lpaProps);

        if (i) {
            if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
              i,
              spv,
              NULL))) {
                DebugTrace( TEXT("ParseTel:SetProps -> %x\n"), GetScode(hResult));
            }
        }
    }

    return(hResult);
}


enum {
    iemPR_CONTACT_EMAIL_ADDRESSES,
    iemPR_CONTACT_ADDRTYPES,
    iemPR_CONTACT_DEFAULT_ADDRESS_INDEX,
    iemPR_EMAIL_ADDRESS,
    iemPR_ADDRTYPE,
    iemMax
};

SizedSPropTagArray(iemMax, tagaEmail) = {
        iemMax,
   {
       PR_CONTACT_EMAIL_ADDRESSES,
       PR_CONTACT_ADDRTYPES,
       PR_CONTACT_DEFAULT_ADDRESS_INDEX,
       PR_EMAIL_ADDRESS,
       PR_ADDRTYPE,
        }
};

const char szAtSign[] =  "@";
#define cbAtSign    sizeof(szAtSign)

const char szMSNpostfix[] =  "@msn.com";
#define cbMSNpostfix    sizeof(szMSNpostfix)

const char szAOLpostfix[] =  "@aol.com";
#define cbAOLpostfix    sizeof(szAOLpostfix)

const char szCOMPUSERVEpostfix[] =  "@compuserve.com";
#define cbCOMPUSERVEpostfix    sizeof(szCOMPUSERVEpostfix)

/***************************************************************************

    Name      : ParseEmail

    Purpose   : parse an email address into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object
                lpvcs -> vCard import state

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseEmail(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser, LPVC_STATE lpvcs) {
    HRESULT hResult = hrSuccess;
    ULONG i = 0;
    BOOL fBusiness = ! lpvcpf->fTYPE_HOME;  // default is business
    LPSPropValue lpaProps = NULL;
    ULONG ulcProps;
    SCODE sc;
    LPSTR lpAddrType = szSMTPA;
    LPSTR lpEmailAddress = lpData;
    LPSTR lpTemp = NULL;
    LPTSTR lpAddrTypeW = NULL;
    LPTSTR lpEmailAddressW = NULL;


    if (lpData && *lpData) {

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaEmail,
          MAPI_UNICODE,    // ulFlags,
          &ulcProps,
          &lpaProps))) {
            DebugTraceResult( TEXT("ParseEmail:GetProps(DL)\n"), hResult);
            // No property, not fatal.

            // allocate a buffer
            if (sc = MAPIAllocateBuffer(iemMax * sizeof(SPropValue), &lpaProps)) {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                sc = ResultFromScode(sc);
                goto exit;
            }
            // fill in with prop errors
            lpaProps[iemPR_EMAIL_ADDRESS].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_EMAIL_ADDRESS));
            lpaProps[iemPR_ADDRTYPE].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_ADDRTYPE));
            lpaProps[iemPR_CONTACT_EMAIL_ADDRESSES].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_EMAIL_ADDRESSES));
            lpaProps[iemPR_CONTACT_ADDRTYPES].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_ADDRTYPES));
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_DEFAULT_ADDRESS_INDEX));
        }

        if (lpvcpf->fTYPE_INTERNET) {
            // default
        } else if (lpvcpf->fTYPE_MSN) {
            // convert to SMTP
            // Allocate a new, longer string
            if (sc = MAPIAllocateBuffer(
              lstrlenA(lpData) + 1 + cbMSNpostfix,
              &lpTemp)) {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the msn site
            lstrcpyA(lpTemp, lpData);
            lstrcatA(lpTemp, szMSNpostfix);
            lpEmailAddress = lpTemp;
        } else if (lpvcpf->fTYPE_CIS) {
            // convert to SMTP
            // Allocate a new, longer string
            if (sc = MAPIAllocateBuffer(
              lstrlenA(lpData) + 1 + cbCOMPUSERVEpostfix,
              &lpTemp)) {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the MSN site
            lstrcpyA(lpTemp, lpData);
            lstrcatA(lpTemp, szCOMPUSERVEpostfix);
            // I need to convert the ',' to a '.'
            lpEmailAddress = lpTemp;
            while (*lpTemp) {
                if (*lpTemp == ',') {
                    *lpTemp = '.';
                    break;          // should only be one comma
                }
                lpTemp = CharNextA(lpTemp);
            }
            lpTemp = lpEmailAddress;
        } else if (lpvcpf->fTYPE_AOL) {
            // convert to SMTP
            // Allocate a new, longer string
            if (sc = MAPIAllocateBuffer(
              lstrlenA(lpData) + 1 + cbAOLpostfix,
              &lpTemp)) {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the AOL site
            lstrcpyA(lpTemp, lpData);
            lstrcatA(lpTemp, szAOLpostfix);
            lpEmailAddress = lpTemp;
        }

        // Don't know of any mappings to SMTP for these:
        else if (lpvcpf->fTYPE_X400) {
            // Mark as X400
            lpAddrType = vctTable[VCARD_TYPE_X400];
        } else if (lpvcpf->fTYPE_ATTMAIL) {
            // Mark as ATTMAIL
            lpAddrType = vctTable[VCARD_TYPE_ATTMAIL];
        } else if (lpvcpf->fTYPE_EWORLD) {
            // Mark as EWORLD
            lpAddrType = vctTable[VCARD_TYPE_EWORLD];
        } else if (lpvcpf->fTYPE_IBMMAIL) {
            // Mark as IBMMAIL
            lpAddrType = vctTable[VCARD_TYPE_IBMMAIL];
        } else if (lpvcpf->fTYPE_MCIMAIL) {
            // Mark as MCIMAIL
            lpAddrType = vctTable[VCARD_TYPE_MCIMAIL];
        } else if (lpvcpf->fTYPE_POWERSHARE) {
            // Mark as POWERSHARE
            lpAddrType = vctTable[VCARD_TYPE_POWERSHARE];
        } else if (lpvcpf->fTYPE_PRODIGY) {
            // Mark as PRODIGY
            lpAddrType = vctTable[VCARD_TYPE_PRODIGY];
//
// Telex Number should go in PR_TELEX_NUMBER
//        } else if (lpvcpf->fTYPE_TLX) {
//            // Mark as TLX
//            lpAddrType = vctTable[VCARD_TYPE_TLX];
        }

        lpEmailAddressW = ConvertAtoW(lpEmailAddress);
        lpAddrTypeW = ConvertAtoW(lpAddrType);

        if (hResult = AddPropToMVPString(lpaProps,
          ulcProps,
          iemPR_CONTACT_EMAIL_ADDRESSES,
          lpEmailAddressW)) {
            goto exit;
        }

        if (hResult = AddPropToMVPString(lpaProps,
          ulcProps,
          iemPR_CONTACT_ADDRTYPES,
          lpAddrTypeW)) {
            goto exit;
        }

        // Is this the default email address?
        if (lpvcpf->fTYPE_PREF || lpvcs->ulEmailAddrs == 0) {
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].Value.l = lpvcs->ulEmailAddrs;

            lpaProps[iemPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
            lpaProps[iemPR_EMAIL_ADDRESS].Value.LPSZ = lpEmailAddressW;

            lpaProps[iemPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE;
            lpaProps[iemPR_ADDRTYPE].Value.LPSZ = lpAddrTypeW;
        } else {
            ulcProps = 2;     // contact addresses and contact addrtypes
        }

        lpvcs->ulEmailAddrs++;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          ulcProps,
          lpaProps,
          NULL))) {
            DebugTrace( TEXT("ParseEmail:SetProps -> %x\n"), GetScode(hResult));
        }
    }
exit:
    FreeBufferAndNull(&lpaProps);
    FreeBufferAndNull(&lpTemp);
    LocalFreeAndNull(&lpAddrTypeW);
    LocalFreeAndNull(&lpEmailAddressW);
    return(hResult);
}

/***************************************************************************

    Name      : ParseBday

    Purpose   : parse the birthday from string into FileTime

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseBday(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpDataA, LPMAILUSER lpMailUser) 
{
    HRESULT hResult = hrSuccess;
    SPropValue  spv[1] = {0};
    SYSTEMTIME st = {0};
    TCHAR sz[32];
    LPTSTR lpTmp = NULL;
    LPTSTR lpData = ConvertAtoW(lpDataA);
    
    // Birthday can be in 2 formats:
    // basic ISO 8601: YYYYMMDD
    // or
    // extended ISO 8601: YYYY-MM-DDTHH-MM-SSetc
    //
    // we'll assume that if the strlen == 8, then it is basic
    //
    if (lpData && *lpData && (lstrlen(lpData) >= 8)) 
    {
        lstrcpyn(sz, lpData,31);
        sz[31] = '\0';

        if(lstrlen(lpData) == 8) //basic ISO 8601
        {
            lpTmp = &(sz[6]);
            st.wDay = (WORD) my_atoi(lpTmp);
            *lpTmp = '\0';
            lpTmp = &(sz[4]);
            st.wMonth = (WORD) my_atoi(lpTmp);
            *lpTmp = '\0';
            st.wYear = (WORD) my_atoi(sz);
        }
        else //extended ISO 8601
        {
            sz[10]='\0';
            lpTmp = &(sz[8]);
            st.wDay = (WORD) my_atoi(lpTmp);
            sz[7]='\0';
            lpTmp = &(sz[5]);
            st.wMonth = (WORD) my_atoi(lpTmp);
            sz[4]='\0';
            st.wYear = (WORD) my_atoi(sz);
        }
        SystemTimeToFileTime(&st, &(spv[0].Value.ft));
        spv[0].ulPropTag = PR_BIRTHDAY;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                              1, spv,
                                                              NULL))) 
        {
            DebugTrace( TEXT("ParseBday(0x%08x):SetProps -> %x\n"), PR_BIRTHDAY, GetScode(hResult));
        }
    }

    LocalFreeAndNull(&lpData);

    return(hResult);
}



/***************************************************************************

    Name      : ParseSimple

    Purpose   : parse the simple text prop into the property

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object
                ulPropTag = property to save

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseSimple(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser,
  ULONG ulPropTag) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[1] = {0};

    if (lpData && *lpData) {
        spv[0].ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
        spv[0].Value.lpszA= lpData;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          1,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseSimple(0x%08x):SetProps -> %x\n"), ulPropTag, GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardEncoding

    Purpose   : Recognize the VCard encoding and set the flags

    Parameters: lpType = encoding string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT InterpretVCardEncoding(LPSTR lpEncoding, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;

    if (*lpEncoding) {
        // what is it?
        switch (RecognizeVCardEncoding(lpEncoding)) {
            case VCARD_ENCODING_NONE:
                break;

            case VCARD_ENCODING_QUOTED_PRINTABLE:
                lpvcpf->fENCODING_QUOTED_PRINTABLE = TRUE;
                break;
            case VCARD_ENCODING_BASE64:
                lpvcpf->fENCODING_BASE64 = TRUE;
                break;

            case VCARD_ENCODING_7BIT:
                lpvcpf->fENCODING_7BIT = TRUE;
                break;

            default:
                // Assert(FALSE);
                break;
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardType

    Purpose   : Recognize the VCard type and set the flags

    Parameters: lpType = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT InterpretVCardType(LPSTR lpType, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;

    if (*lpType) {
        // what is it?
        switch (RecognizeVCardType(lpType)) {
            case VCARD_TYPE_DOM:
                lpvcpf->fTYPE_DOM = TRUE;
                break;
            case VCARD_TYPE_INTL:
                lpvcpf->fTYPE_INTL = TRUE;
                break;
            case VCARD_TYPE_POSTAL:
                lpvcpf->fTYPE_POSTAL = TRUE;
                break;
            case VCARD_TYPE_PARCEL:
                lpvcpf->fTYPE_PARCEL = TRUE;
                break;
            case VCARD_TYPE_HOME:
                lpvcpf->fTYPE_HOME = TRUE;
                break;
            case VCARD_TYPE_WORK:
                lpvcpf->fTYPE_WORK = TRUE;
                break;
            case VCARD_TYPE_PREF:
                lpvcpf->fTYPE_PREF = TRUE;
                break;
            case VCARD_TYPE_VOICE:
                lpvcpf->fTYPE_VOICE = TRUE;
                break;
            case VCARD_TYPE_FAX:
                lpvcpf->fTYPE_FAX = TRUE;
                break;
            case VCARD_TYPE_MSG:
                lpvcpf->fTYPE_MSG = TRUE;
                break;
            case VCARD_TYPE_CELL:
                lpvcpf->fTYPE_CELL = TRUE;
                break;
            case VCARD_TYPE_PAGER:
                lpvcpf->fTYPE_PAGER = TRUE;
                break;
            case VCARD_TYPE_BBS:
                lpvcpf->fTYPE_BBS = TRUE;
                break;
            case VCARD_TYPE_MODEM:
                lpvcpf->fTYPE_MODEM = TRUE;
                break;
            case VCARD_TYPE_CAR:
                lpvcpf->fTYPE_CAR = TRUE;
                break;
            case VCARD_TYPE_ISDN:
                lpvcpf->fTYPE_ISDN = TRUE;
                break;
            case VCARD_TYPE_VIDEO:
                lpvcpf->fTYPE_VIDEO = TRUE;
                break;
            case VCARD_TYPE_AOL:
                lpvcpf->fTYPE_AOL = TRUE;
                break;
            case VCARD_TYPE_APPLELINK:
                lpvcpf->fTYPE_APPLELINK = TRUE;
                break;
            case VCARD_TYPE_ATTMAIL:
                lpvcpf->fTYPE_ATTMAIL = TRUE;
                break;
            case VCARD_TYPE_CIS:
                lpvcpf->fTYPE_CIS = TRUE;
                break;
            case VCARD_TYPE_EWORLD:
                lpvcpf->fTYPE_EWORLD = TRUE;
                break;
            case VCARD_TYPE_INTERNET:
                lpvcpf->fTYPE_INTERNET = TRUE;
                break;
            case VCARD_TYPE_IBMMAIL:
                lpvcpf->fTYPE_IBMMAIL = TRUE;
                break;
            case VCARD_TYPE_MSN:
                lpvcpf->fTYPE_MSN = TRUE;
                break;
            case VCARD_TYPE_MCIMAIL:
                lpvcpf->fTYPE_MCIMAIL = TRUE;
                break;
            case VCARD_TYPE_POWERSHARE:
                lpvcpf->fTYPE_POWERSHARE = TRUE;
                break;
            case VCARD_TYPE_PRODIGY:
                lpvcpf->fTYPE_PRODIGY = TRUE;
                break;
            case VCARD_TYPE_TLX:
                lpvcpf->fTYPE_TLX = TRUE;
                break;
            case VCARD_TYPE_X400:
                lpvcpf->fTYPE_X400 = TRUE;
                break;
            case VCARD_TYPE_GIF:
                lpvcpf->fTYPE_GIF = TRUE;
                break;
            case VCARD_TYPE_CGM:
                lpvcpf->fTYPE_CGM = TRUE;
                break;
            case VCARD_TYPE_WMF:
                lpvcpf->fTYPE_WMF = TRUE;
                break;
            case VCARD_TYPE_BMP:
                lpvcpf->fTYPE_BMP = TRUE;
                break;
            case VCARD_TYPE_MET:
                lpvcpf->fTYPE_MET = TRUE;
                break;
            case VCARD_TYPE_PMB:
                lpvcpf->fTYPE_PMB = TRUE;
                break;
            case VCARD_TYPE_DIB:
                lpvcpf->fTYPE_DIB = TRUE;
                break;
            case VCARD_TYPE_PICT:
                lpvcpf->fTYPE_PICT = TRUE;
                break;
            case VCARD_TYPE_TIFF:
                lpvcpf->fTYPE_TIFF = TRUE;
                break;
            case VCARD_TYPE_ACROBAT:
                lpvcpf->fTYPE_ACROBAT = TRUE;
                break;
            case VCARD_TYPE_PS:
                lpvcpf->fTYPE_PS = TRUE;
                break;
            case VCARD_TYPE_JPEG:
                lpvcpf->fTYPE_JPEG = TRUE;
                break;
            case VCARD_TYPE_QTIME:
                lpvcpf->fTYPE_QTIME = TRUE;
                break;
            case VCARD_TYPE_MPEG:
                lpvcpf->fTYPE_MPEG = TRUE;
                break;
            case VCARD_TYPE_MPEG2:
                lpvcpf->fTYPE_MPEG2 = TRUE;
                break;
            case VCARD_TYPE_AVI:
                lpvcpf->fTYPE_AVI = TRUE;
                break;
            case VCARD_TYPE_WAVE:
                lpvcpf->fTYPE_WAVE = TRUE;
                break;
            case VCARD_TYPE_AIFF:
                lpvcpf->fTYPE_AIFF = TRUE;
                break;
            case VCARD_TYPE_PCM:
                lpvcpf->fTYPE_PCM = TRUE;
                break;
            case VCARD_TYPE_X509:
                lpvcpf->fTYPE_X509 = TRUE;
                break;
            case VCARD_TYPE_PGP:
                lpvcpf->fTYPE_PGP = TRUE;
                break;
            case VCARD_TYPE_NONE:
                // Wasn't a TYPE, try an encoding
                hResult = InterpretVCardEncoding(lpType, lpvcpf);
                break;
            default:
                // Assert(FALSE);
                break;
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardParams

    Purpose   : Parse out the vCard's parameters

    Parameters: lpBuffer = option string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   : Assumes lpvcpf is initialized to all false.

***************************************************************************/
HRESULT ParseVCardParams(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    LPSTR lpOption, lpArgs;
    BOOL fReady;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {

        while (*lpBuffer) {
            fReady = FALSE;
            lpOption = lpBuffer;
            lpArgs = NULL;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ';':           // end of this param
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    case '=':           // found a param with args
                        if (! lpArgs) {
                            lpArgs = lpBuffer + 1;
                            *lpBuffer = '\0';
                        }
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }
            if (*lpOption) {
                // what is it?
                switch (RecognizeVCardParam(lpOption)) {
                    case VCARD_PARAM_TYPE:
                        if (lpArgs) {
                            ParseVCardType(lpArgs, lpvcpf);
                        }
                        break;

                    case VCARD_PARAM_ENCODING:
                        if (lpArgs) {
                            ParseVCardEncoding(lpArgs, lpvcpf);
                        }
                        break;

                    case VCARD_PARAM_LANGUAGE:
                        lpvcpf->szPARAM_LANGUAGE = lpArgs;
                        break;

                    case VCARD_PARAM_CHARSET:
                        lpvcpf->szPARAM_CHARSET = lpArgs;
                        break;

                    case VCARD_PARAM_VALUE:
                        // BUGBUG: Should reject those that we can't process (like URL)
                        break;

                    case VCARD_PARAM_NONE:
                        if (hResult = InterpretVCardType(lpOption, lpvcpf)) {
                            goto exit;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : ParseOrg

    Purpose   : parse the organization into properites

    Parameters: lpvcpf ->
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard organizations are of the form:
                 TEXT("organization; org unit; org unit; ...")

***************************************************************************/
HRESULT ParseOrg(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[2] = {0};
    register LPSTR lpCurrent;
    ULONG i = 0;

    // Look for Organization (company)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_COMPANY_NAME, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }
    // Everything else goes into PR_DEPARTMENT_NAME
    if (lpData && *lpData) {
        spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_DEPARTMENT_NAME, PT_STRING8);
        spv[i].Value.lpszA= lpData;
        i++;
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseName:SetProps -> %x\n"), GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardType

    Purpose   : Parse out the vCard's type parameter

    Parameters: lpBuffer = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ParseVCardType(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    BOOL fReady;
    LPSTR lpType;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {
        while (*lpBuffer) {
            fReady = FALSE;
            lpType = lpBuffer;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ',':           // end of this type
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }

            hResult = InterpretVCardType(lpType, lpvcpf);
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardEncoding

    Purpose   : Parse out the vCard encoding parameter

    Parameters: lpBuffer = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ParseVCardEncoding(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    BOOL fReady;
    LPSTR lpEncoding;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {
        while (*lpBuffer) {
            fReady = FALSE;
            lpEncoding = lpBuffer;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ',':           // end of this type
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }

            hResult = InterpretVCardEncoding(lpEncoding, lpvcpf);
        }
    }
    return(hResult);
}



/***************************************************************************

    Name      : Base64DMap

    Purpose   : Decoding mapping for Base64

    Parameters: chIn = character from Base64 encoding

    Returns   : 6-bit value represented by chIn.

    Comment   :

***************************************************************************/
/*  
this function is not necessary any more because of the DecodeBase64 function

UCHAR Base64DMap(UCHAR chIn) {
    UCHAR chOut;

    // 'A' -> 0, 'B' -> 1, ... 'Z' -> 25
    if (chIn >= 'A' && chIn <= 'Z') {
        chOut = chIn - 'A';
    } else if (chIn >= 'a' && chIn <= 'z') {    // 'a' -> 26
        chOut = (chIn - 'a') + 26;
    } else if (chIn >= '0' && chIn <= '9') {   // '0' -> 52
        chOut = (chIn - '0') + 52;
    } else if (chIn == '+') {
        chOut = 62;
    } else if (chIn == '/') {
        chOut = 63;
    } else {
        // uh oh
        Assert(FALSE);
        chOut = 0;
    }

    return(chOut);
}

*/

/***************************************************************************

    Name      : DecodeVCardData

    Purpose   : Decode QUOTED_PRINTABLE or BASE64 data

    Parameters: lpData = data string
                cbData = the length of the decoded data string  // changed t-jstaj
                lpvcs -> state variable

    Returns   : hResult

    Comment   : Decode in place is possible since both encodings are
                guaranteed to take at least as much space as the original data.

***************************************************************************/
HRESULT DecodeVCardData(LPSTR lpData, PULONG cbData, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;
    LPSTR lpTempIn = lpData;
    LPSTR lpTempOut = lpData;
    char chIn, chOut;
    char chA, chB, chC, chD;
    if (lpvcpf->fENCODING_QUOTED_PRINTABLE) {
        // Look for '=', this is the escape character for QP
        while (chIn = *lpTempIn) {
            if (chIn == '=') {
                chIn = *(++lpTempIn);
                // is it a soft line break or a hex character?
                if (chIn == '\n' || chIn == '\r') {
                    // Soft line break
                    while (chIn && (chIn == '\n' || chIn == '\r')) {
                        chIn = *(++lpTempIn);
                    }
                    continue;   // We're now pointing to next good data or NULL
                } else {
                    // hex encoded char
                    // high nibble
                    if (chIn >= '0' && chIn <= '9') {
                        chOut = (chIn - '0') << 4;
                    } else if (chIn >= 'A' && chIn <= 'F') {
                        chOut = ((chIn - 'A') + 10) << 4;
                    } else if (chIn >= 'a' && chIn <= 'f') {
                        chOut = ((chIn - 'a') + 10) << 4;
                    } else {
                        // bogus QUOTED_PRINTABLE data
                        // Cut it short right here.
                        break;
                    }
                    chIn = *(++lpTempIn);

                    // low nibble
                    if (chIn >= '0' && chIn <= '9') {
                        chOut |= (chIn - '0');
                    } else if (chIn >= 'A' && chIn <= 'F') {
                        chOut |= ((chIn - 'A') + 10);
                    } else if (chIn >= 'a' && chIn <= 'f') {
                        chOut |= ((chIn - 'a') + 10);
                    } else {
                        // bogus QUOTED_PRINTABLE data
                        // Cut it short right here.
                        break;
                    }
                }
            } else {
                chOut = chIn;
            }

            *(lpTempOut++) = chOut;
            lpTempIn++;
        }
        *lpTempOut = '\0';  // terminate it
    } else if (lpvcpf->fENCODING_BASE64) {
         // eliminate white spaces
        LPSTR lpTempCopyPt;
        for( lpTempCopyPt = lpTempIn = lpData;
             lpTempIn && *lpTempIn; 
             lpTempCopyPt++, lpTempIn++ )
        {
             while( /*IsSpace(lpTempIn)*/
                    *lpTempIn == ' '
                    || *lpTempIn == '\t') 
                 lpTempIn++;                 
             if( lpTempCopyPt != lpTempIn )
                 *(lpTempCopyPt) = *(lpTempIn);
        }
        *(lpTempCopyPt) = '\0';
        lpTempIn = lpData;
        lpTempOut = lpData;
        if( HR_FAILED(hResult = DecodeBase64(lpTempIn, lpTempOut, cbData) ) )
        {
            DebugTrace( TEXT("couldn't decode buffer\n"));
        }
       
     /** This is the original code for vcard decoding base64, however, it wasn't working so new decoding is all done
         within DecodeBase64 function.
     
        lpTempIn = lpData;
        lpTempOut = lpData;
        while (*lpTempIn) {
            chA = Base64DMap(*(PUCHAR)(lpTempIn)++);
            if (! (chB = Base64DMap(*(PUCHAR)(lpTempIn)++) )) {
                chC = chD = 0;
            } else if (chC = Base64DMap(*(PUCHAR)(lpTempIn)++)) {
                chD = 0;
            } else {
                chD = Base64DMap(*(PUCHAR)(lpTempIn)++);
            }
            // chA = high 6 bits
            // chD = low 6 bits

            *(lpTempOut++) = (chA << 0x02) | ((chB & 0x60)  >> 6);
            *(lpTempOut++) = ((chB & 0x0F) << 4) | ((chC & 0x3B) >> 2);
            *(lpTempOut++) = ((chC & 0x03) << 6) | (chD & 0x3F);
        }
        *lpTempOut = '\0';  // terminate it
        */
    }

    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardItem

    Purpose   : Recognize the vCard item

    Parameters: lpName = property name
                lpOption = option string
                lpData = data string
                lpMailUser -> output mailuser object
                lpvcs -> state variable

    Returns   : hResult

    Comment   : Expects the keyword to be in the current line (lpBuffer), but
                may read more lines as necesary to get a complete item.

***************************************************************************/
HRESULT InterpretVCardItem(LPSTR lpName, LPSTR lpOption, LPSTR lpData,
  LPMAILUSER lpMailUser, LPEXTVCARDPROP lpList, LPVC_STATE lpvcs) {
    HRESULT hResult = hrSuccess;
    VCARD_PARAM_FLAGS vcpf = {0};
    ULONG cbData = 0;
    ParseVCardParams(lpOption, &vcpf);

#if 0
#ifdef DEBUG
    if(lstrcmpiA(lpName, "KEY"))
    {
        LPTSTR lpW1 = ConvertAtoW(lpName);
        LPTSTR lpW2 = ConvertAtoW(lpData);
        DebugTrace( TEXT("%s:%s\n"), lpW1, lpW2);
        LocalFreeAndNull(&lpW1);
        LocalFreeAndNull(&lpW2);
    }
    else
        DebugTrace(TEXT("KEY:\n"));
#endif
#endif

    if (hResult = DecodeVCardData(lpData, &cbData, &vcpf)) {
        goto exit;
    }

    switch (RecognizeVCardKeyWord(lpName)) {
        case VCARD_KEY_VCARD:
            hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            break;

        case VCARD_KEY_BEGIN:
            if (lpvcs->vce != VCS_INITIAL) {
                // uh oh, already saw BEGIN
                hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            } else {
                switch (RecognizeVCardKeyWord(lpData)) {
                    case VCARD_KEY_VCARD:
                        lpvcs->vce = VCS_ITEMS;
                        break;
                    default:
                        lpvcs->vce = VCS_ERROR;
                        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
                        break;
                }
            }
            break;

        case VCARD_KEY_END:
            if (lpvcs->vce != VCS_ITEMS) {
                // uh oh, haven't seen begin yet
                hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            } else {
                switch (RecognizeVCardKeyWord(lpData)) {
                    case VCARD_KEY_VCARD:
                        lpvcs->vce = VCS_FINISHED;
                        break;
                    default:
                        lpvcs->vce = VCS_ERROR;
                        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
                        break;
                }
            }
            break;

        case VCARD_KEY_N:   // structured name
            // Data: surname; given name; middle name; prefix; suffix
            hResult = ParseName(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_ORG: // organization info
            // Data: company name; org unit; org unit; ...
            hResult = ParseOrg(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_ADR:
            // Data:  TEXT("PO box; extended addr; street addr; city; region; postal code; country")
            // Option: DOM; INTL; POSTAL; PARCEL; HOME; WORK; PREF; CHARSET; LANGUAGE
            hResult = ParseAdr(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_TEL:
            // Data: canonical form phone number
            // Options: HOME, WORK, MSG, PREF, FAX, CELL, PAGER, VIDEO, BBS, MODEM, ISDN
            hResult = ParseTel(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_TITLE:
            // Data: job title
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_TITLE);
            break;

        case VCARD_KEY_NICKNAME:
            // Data: job title
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_NICKNAME);
            break;

        case VCARD_KEY_URL:
            // Data: URL
            // Options: none (though we'd like to see HOME, WORK)
            if (vcpf.fTYPE_HOME) {
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PERSONAL_HOME_PAGE);
                lpvcs->fPersonalURL = TRUE;
            } else if (vcpf.fTYPE_WORK) {
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_BUSINESS_HOME_PAGE);
                lpvcs->fBusinessURL = TRUE;
            } else if (! lpvcs->fPersonalURL) {
                // assume it is HOME page
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PERSONAL_HOME_PAGE);
                lpvcs->fPersonalURL = TRUE;
            } else if (! lpvcs->fBusinessURL) {
                // assume it is BUSINESS web page
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_BUSINESS_HOME_PAGE);
                lpvcs->fBusinessURL = TRUE;
            }   // else, toss it
            break;

        case VCARD_KEY_NOTE:
            // Data: note text
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_COMMENT);
            break;

        case VCARD_KEY_FN:
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_DISPLAY_NAME);
            break;

        case VCARD_KEY_EMAIL:
            // since we are forcibly putting the telex value into the EMAIL type,
            // we also need to be able to get it out of there
            if(vcpf.fTYPE_TLX)
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_TELEX_NUMBER);
            else
                hResult = ParseEmail(&vcpf, lpData, lpMailUser, lpvcs);
            break;

        case VCARD_KEY_ROLE:
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PROFESSION);
            break;

        case VCARD_KEY_BDAY:
            hResult = ParseBday(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_AGENT:
        case VCARD_KEY_LOGO:
        case VCARD_KEY_PHOTO:
        case VCARD_KEY_LABEL:
        case VCARD_KEY_FADR:
        case VCARD_KEY_SOUND:
        case VCARD_KEY_LANG:
        case VCARD_KEY_TZ:
        case VCARD_KEY_GEO:
        case VCARD_KEY_REV:
        case VCARD_KEY_UID:
        case VCARD_KEY_MAILER:
            // Not yet implemented: ignore
#ifdef DEBUG
            {
                LPTSTR lpW = ConvertAtoW(lpName);
                DebugTrace( TEXT("===>>> NYI: %s\n"), lpW);
                LocalFreeAndNull(&lpW);
            }
#endif
            break;       
        case VCARD_KEY_KEY:
            {
                hResult = ParseCert( lpData, cbData, lpMailUser);
                break;
            }
        case VCARD_KEY_X_WAB_GENDER:
            {
                SPropValue  spv[1] = {0};
                if (lpData )
                {
                    INT fGender = (INT)lpData[0] - '0';
                    if( fGender < 0 || fGender > 2 )
                        fGender = 0;

                    spv[0].Value.l = fGender;                
                    spv[0].ulPropTag = PR_GENDER;
                    
                    if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                        1, spv,
                        NULL))) 
                    {
                        DebugTrace( TEXT("could not set props\n"));
                    }
                }
                break;
            }
        case VCARD_KEY_X:
        case VCARD_KEY_NONE:
            //
            // Check if this is an X- named prop that we might care about
            //
            if(lpList)
            {
                LPEXTVCARDPROP lpTemp = lpList;
                while(  lpTemp && lpTemp->ulExtPropTag && 
                        lpTemp->lpszExtPropName && lstrlenA(lpTemp->lpszExtPropName) )
                {
                    if(!lstrcmpiA(lpName, lpTemp->lpszExtPropName))
                    {
                        hResult = ParseSimple(&vcpf, lpData, lpMailUser, lpTemp->ulExtPropTag);
                        break;
                    }
                    lpTemp = lpTemp->lpNext;
                }
            }
#ifdef DEBUG
            {
                LPTSTR lpW = ConvertAtoW(lpName);
                DebugTrace( TEXT("Unrecognized or extended vCard key %s\n"), lpW);
                LocalFreeAndNull(&lpW);
            }
#endif //debug 
            break;

        default:
//            Assert(FALSE);
            break;
    }

    if (lpvcs->vce == VCS_INITIAL) {
        // We are still in initial state.  This is not a vCard.
        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : ReadLn

    Purpose   : Read a line from the handle

    Parameters: handle = open file handle
                ReadFn = function to read from handle
                lppLine -> returned pointer to this line's read into.
                lpcbItem -> [in] size of data in lppBuffer.  [out] returned size of
                  data in lppBuffer.  If zero, there is no more data.  (Does not
                  include terminating NULL)
                lppBuffer -> [in] start of item buffer or NULL if none yet.
                  [out] start of allocated item buffer.  Caller must
                  LocalFree this buffer once the item is read in.
                lpcbBuffer -> [in/out] size of lppBuffer allocation.

    Returns   : hResult: 0 on no error (recognized)

    Comment   : Reads a line from the handle, discarding any carriage return
                characters and empty lines.  Will not overwrite buffer, and
                will always terminate the string with a null.  Trims trailing
                white space.

                This is very inefficient since we're reading a byte at a time.
                I think we can get away with it since vCards are typically
                small.  If not, we'll have to do some read caching.

***************************************************************************/
#define READ_BUFFER_GROW    256
HRESULT ReadLn(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppLine, LPULONG lpcbItem, LPSTR * lppBuffer, LPULONG lpcbBuffer)
{
    HRESULT hResult = hrSuccess;
    LPSTR lpBuffer = *lppBuffer;
    LPSTR lpBufferTemp;
    register LPSTR lpRead = NULL;
    ULONG cbRead;
    ULONG cbBuffer;
    char ch;
    ULONG cbItem;
    ULONG cbStart;

    if (! lpBuffer) {
        cbBuffer = READ_BUFFER_GROW;
        cbItem = 0;
        if (! (lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
            DebugTrace( TEXT("ReadLn:LocalAlloc -> %u\n"), GetLastError());
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    } else {
        cbBuffer = *lpcbBuffer;
        cbItem = *lpcbItem;
        // Make certain we have room for at least one more character.
        if (cbItem >= cbBuffer) {
            // Time to grow the buffer
            cbBuffer += READ_BUFFER_GROW;
            if (! (lpRead = LocalReAlloc(lpBuffer, cbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                DebugTrace( TEXT("ReadLn:LocalReAlloc(%u) -> %u\n"), cbBuffer, GetLastError());
                goto exit;
            }
            lpBuffer = lpRead;
        }
    }

    cbStart = cbItem;
    lpRead = lpBuffer + cbItem;  // read pointer

    do {
        // read next character
        if (hResult = ReadFn(hVCard, lpRead, 1, &cbRead)) {
            goto exit;
        }

        if (! cbRead) {
            // End of file
            *lpRead = '\0';         // eol
            goto exit;
        } else {
//                Assert(cbRead == 1);
            ch = *lpRead;
            switch (ch) {
                case '\r':    // These are ignored
                    break;

                case '\n':    // Linefeed terminates string
                    *lpRead = '\0'; // eol
                    break;                    
                default:    // All other characters are added to string
                    cbItem += cbRead;
                    if (cbItem >= cbBuffer) {
                        // Time to grow the buffer
                        cbBuffer += READ_BUFFER_GROW;
                        lpBufferTemp = (LPSTR)LocalReAlloc(lpBuffer, cbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT);
                        if (!lpBufferTemp) {
                            DebugTrace( TEXT("ReadLn:LocalReAlloc(%u) -> %u\n"), cbBuffer, GetLastError());
                            hResult = E_OUTOFMEMORY;
                            goto exit;
                        }
                        else
                        {
                            lpBuffer = lpBufferTemp;
                        }
                        lpRead = lpBuffer + cbItem;
                    } else {
                        lpRead++;
                    }
                    break;
            }
        }
    } while (ch != '\n');

exit:
    *lppLine = &lpBuffer[cbStart];
    if (hResult || cbItem == 0) {
        LocalFreeAndNull(&lpBuffer);
        cbItem = 0;
        lpBuffer = NULL;
    } else {
        // If we didn't read anything more, we should return NULL in lppLine.
        if (cbItem == cbStart) {
            *lppLine = NULL;
        } else {
//            DebugTrace( TEXT("ReadLn: \")%s\ TEXT("\n"), *lppLine);
        }
    }

    *lpcbItem = cbItem;
    *lppBuffer = lpBuffer;
    *lpcbBuffer = cbBuffer;

    return(hResult);
}


/***************************************************************************

    Name      : FindSubstringBefore

    Purpose   : Find a substring before a particular character

    Parameters: lpString = full string
                lpSubstring = search string
                chBefore = character to terminate search

    Returns   : pointer to substring or NULL if not found

    Comment   :

***************************************************************************/
LPSTR FindSubstringBefore(LPSTR lpString, LPSTR lpSubstring, char chBefore) {
    ULONG cbSubstring = lstrlenA(lpSubstring);
    register ULONG i;
    BOOL fFound = FALSE;
    char szU[MAX_PATH];
    char szL[MAX_PATH];
    lstrcpyA(szU, lpSubstring);
    lstrcpyA(szL, lpSubstring);
    CharUpperA(szU);
    CharLowerA(szL);

    while (*lpString && *lpString != chBefore) {
        for (i = 0; i < cbSubstring; i++) {
             if (lpString[i] != szU[i] && lpString[i] != szL[i]) {
                 goto nomatch;
             }
        }
        return(lpString);
nomatch:
        lpString++;
    }
    return(NULL);
}


/***************************************************************************

    Name      : ReadVCardItem

    Purpose   : Read the next VCard item

    Parameters: handle = open file handle
                ReadFn = function to read from handle
                lppBuffer -> returned buffer containing the item.  Caller must
                  LocalFree this buffer.  (on input, if this is non-NULL,
                  the existing buffer should be used.)
                lpcbBuffer -> returned size of buffer.  If zero, there is no
                  more data.

    Returns   : hResult: 0 on no error (recognized)

    Comment   : Reads a vCard item from the handle, discarding any carriage return
                characters and empty lines.  Will not overwrite buffer, and
                will always terminate the string with a null.  Trims trailing
                white space.

***************************************************************************/
HRESULT ReadVCardItem(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppBuffer, LPULONG lpcbBuffer) {
    HRESULT hResult;
    LPSTR lpLine = NULL;
    LPSTR lpBuffer = NULL;
    ULONG cbBuffer = 0;
    ULONG cbItem = 0;
    BOOL fDone = FALSE;
    BOOL fQuotedPrintable = FALSE;
    BOOL fBase64 = FALSE;
    BOOL fFirst = TRUE;
    ULONG cbStart;


    while (! fDone) {
        cbStart = cbItem;
        if (hResult = ReadLn(hVCard, ReadFn, &lpLine, &cbItem, &lpBuffer, &cbBuffer)) {
            if (HR_FAILED(hResult)) {
                DebugTrace( TEXT("ReadVCardItem: ReadLn -> %x\n"), GetScode(hResult));
            } else if (GetScode(hResult) == WAB_W_END_OF_DATA) {
                // EOF
                // all
            }
            fDone = TRUE;
        } else {
            if (lpBuffer) {
                // Do we need to read more data?
                // Look for the following
                if (fFirst) {
                    // look for the data type indications in the first line of the item.
                    fQuotedPrintable = FindSubstringBefore(lpBuffer, (LPSTR)vceTable[VCARD_ENCODING_QUOTED_PRINTABLE], ':') ? TRUE : FALSE;
                    fBase64 = FindSubstringBefore(lpBuffer, (LPSTR)vceTable[VCARD_ENCODING_BASE64], ':') ? TRUE : FALSE;
                    fFirst = FALSE;
                }

                if (fQuotedPrintable) {
                    // watch for soft line breaks (= before CRLF)
                    if (lpBuffer[cbItem - 1] == '=') {
                        // overwrite the soft break character
                        cbItem--;
                        lpBuffer[cbItem] = '\0';
                    } else {
                        fDone = TRUE;
                    }
                } else if (fBase64) {
                    // looking for empty line
                    if (cbStart == cbItem) {
                        fDone = TRUE;
                    }
                } else {
                    fDone = TRUE;
                }
            } else {
                // BUG Fix - if we set fDone to true here, we will exit out of our
                // vCard reading loop. lpBuffer can also be NULL because the
                // vCard contained blank lines. Better we dont set fDone here.
                
                //fDone = TRUE;
            }
        }
    }

    if (! HR_FAILED(hResult)) {
        *lppBuffer = lpBuffer;
        if (lpBuffer) {
            TrimTrailingWhiteSpace(lpBuffer);
        }
    }
    return(hResult);
}


enum {
    ivcPR_GENERATION,
    ivcPR_GIVEN_NAME,
    ivcPR_SURNAME,
    ivcPR_NICKNAME,
    ivcPR_BUSINESS_TELEPHONE_NUMBER,
    ivcPR_HOME_TELEPHONE_NUMBER,
    ivcPR_LANGUAGE,
    ivcPR_POSTAL_ADDRESS,
    ivcPR_COMPANY_NAME,
    ivcPR_TITLE,
    ivcPR_DEPARTMENT_NAME,
    ivcPR_OFFICE_LOCATION,
    ivcPR_BUSINESS2_TELEPHONE_NUMBER,
    ivcPR_CELLULAR_TELEPHONE_NUMBER,
    ivcPR_RADIO_TELEPHONE_NUMBER,
    ivcPR_CAR_TELEPHONE_NUMBER,
    ivcPR_OTHER_TELEPHONE_NUMBER,
    ivcPR_DISPLAY_NAME,
    ivcPR_PAGER_TELEPHONE_NUMBER,
    ivcPR_BUSINESS_FAX_NUMBER,
    ivcPR_HOME_FAX_NUMBER,
    ivcPR_TELEX_NUMBER,
    ivcPR_ISDN_NUMBER,
    ivcPR_HOME2_TELEPHONE_NUMBER,
    ivcPR_MIDDLE_NAME,
    ivcPR_PERSONAL_HOME_PAGE,
    ivcPR_BUSINESS_HOME_PAGE,
    ivcPR_HOME_ADDRESS_CITY,
    ivcPR_HOME_ADDRESS_COUNTRY,
    ivcPR_HOME_ADDRESS_POSTAL_CODE,
    ivcPR_HOME_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_HOME_ADDRESS_STREET,
    ivcPR_HOME_ADDRESS_POST_OFFICE_BOX,
    ivcPR_POST_OFFICE_BOX,
    ivcPR_BUSINESS_ADDRESS_CITY,
    ivcPR_BUSINESS_ADDRESS_COUNTRY,
    ivcPR_BUSINESS_ADDRESS_POSTAL_CODE,
    ivcPR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_BUSINESS_ADDRESS_STREET,
    ivcPR_COMMENT,
    ivcPR_EMAIL_ADDRESS,
    ivcPR_ADDRTYPE,
    ivcPR_CONTACT_ADDRTYPES,
    ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX,
    ivcPR_CONTACT_EMAIL_ADDRESSES,
    ivcPR_PROFESSION,
    ivcPR_BIRTHDAY,
    ivcPR_PRIMARY_TELEPHONE_NUMBER,
    ivcPR_OTHER_ADDRESS_CITY,
    ivcPR_OTHER_ADDRESS_COUNTRY,
    ivcPR_OTHER_ADDRESS_POSTAL_CODE,
    ivcPR_OTHER_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_OTHER_ADDRESS_STREET,
    ivcPR_OTHER_ADDRESS_POST_OFFICE_BOX,
    ivcPR_DISPLAY_NAME_PREFIX,
    ivcPR_USER_X509_CERTIFICATE,
    ivcPR_GENDER,
    ivcMax
};

const SizedSPropTagArray(ivcMax, tagaVCard) = {
    ivcMax,
    {
        PR_GENERATION,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_NICKNAME,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_LANGUAGE,
        PR_POSTAL_ADDRESS,
        PR_COMPANY_NAME,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_BUSINESS2_TELEPHONE_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_RADIO_TELEPHONE_NUMBER,
        PR_CAR_TELEPHONE_NUMBER,
        PR_OTHER_TELEPHONE_NUMBER,
        PR_DISPLAY_NAME,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_TELEX_NUMBER,
        PR_ISDN_NUMBER,
        PR_HOME2_TELEPHONE_NUMBER,
        PR_MIDDLE_NAME,
        PR_PERSONAL_HOME_PAGE,
        PR_BUSINESS_HOME_PAGE,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_COUNTRY,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_POST_OFFICE_BOX,
        PR_POST_OFFICE_BOX,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_STREET,
        PR_COMMENT,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
        PR_CONTACT_ADDRTYPES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_PROFESSION,
        PR_BIRTHDAY,
        PR_PRIMARY_TELEPHONE_NUMBER,
        PR_OTHER_ADDRESS_CITY,
        PR_OTHER_ADDRESS_COUNTRY,
        PR_OTHER_ADDRESS_POSTAL_CODE,
        PR_OTHER_ADDRESS_STATE_OR_PROVINCE,
        PR_OTHER_ADDRESS_STREET,
        PR_OTHER_ADDRESS_POST_OFFICE_BOX,
        PR_DISPLAY_NAME_PREFIX,
        PR_USER_X509_CERTIFICATE,
        PR_GENDER
    }
};

HRESULT WriteOrExit(HANDLE hVCard, LPTSTR lpsz, VCARD_WRITE WriteFn)   
{
    LPSTR lpszA = NULL;
    HRESULT hr = S_OK;
    lpszA = ConvertWtoA(lpsz);
    hr = WriteFn(hVCard, lpszA, lstrlenA(lpszA), NULL);
    LocalFreeAndNull(&lpszA);
    return hr;
}

#define WRITE_OR_EXITW(string) {\
    if (hResult = WriteOrExit(hVCard, string, WriteFn)) \
        goto exit; \
    }

#define WRITE_OR_EXIT(string) {\
    if (hResult = WriteFn(hVCard, string, lstrlenA(string), NULL)) \
        goto exit; \
    }

HRESULT WriteValueOrExit(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE data, ULONG size)   
{
    LPSTR lpszA = NULL;
    HRESULT hr = S_OK;
    if(!size)
        lpszA = ConvertWtoA((LPTSTR)data);
    hr = WriteVCardValue(hVCard, WriteFn, lpszA ? (LPBYTE)lpszA : data, size);
    LocalFreeAndNull(&lpszA);
    return hr;
}

#define WRITE_VALUE_OR_EXITW(data, size) {\
    if (hResult = WriteValueOrExit(hVCard, WriteFn, (LPBYTE)data, size)) {\
        goto exit;\
    }\
}

#define WRITE_VALUE_OR_EXIT(data, size) {\
    if (hResult = WriteVCardValue(hVCard, WriteFn, (LPBYTE)data, size)) {\
        goto exit;\
    }\
}


/***************************************************************************

    Name      : EncodeQuotedPrintable

    Purpose   : Encodes QUOTED_PRINTABLE

    Parameters: lpBuffer -> input buffer

    Returns   : encoded string buffer (must be LocalFree'd by caller)

    Comment   :

***************************************************************************/
#define QUOTED_PRINTABLE_MAX_LINE 76
#define QP_LOWRANGE_MIN ' '
#define QP_LOWRANGE_MAX '<'
#define QP_HIGHRANGE_MIN '>'
#define QP_HIGHRANGE_MAX '~'
LPSTR EncodeQuotedPrintable(LPBYTE lpInput) {
    LPSTR lpBuffer = NULL;
    register LPBYTE lpTempIn = lpInput;
    register LPSTR lpTempOut;
    ULONG cbBuffer = 0;
    ULONG cbLine;
    BYTE bOut;
    char ch;

    // How big must the buffer be?
    cbLine = 0;
    while (ch = *lpTempIn++) {
        if (ch == '\t' || (ch >= QP_LOWRANGE_MIN && ch <= QP_LOWRANGE_MAX) ||
          (ch >= QP_HIGHRANGE_MIN && ch <= QP_HIGHRANGE_MAX)) {
            cbBuffer++;
            cbLine++;
            if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE)) {
                // 1 chars would overshoot max, wrap here
                cbLine = 0;
                cbBuffer += 3;
            }
        } else {
            if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE - 3)) {
                // 3 chars would overshoot max, wrap here
                cbLine = 0;
                cbBuffer += 3;
            }
            cbLine += 3;
            cbBuffer += 3;  //  TEXT("=xx")
        }
    }

    // BUGBUG: Should handle terminating spaces

    if (cbBuffer) {
        cbBuffer++;     // Room for terminator
        if (lpBuffer = LocalAlloc(LPTR, sizeof(TCHAR)*cbBuffer)) {
            lpTempIn = lpInput;
            lpTempOut = lpBuffer;
            cbLine = 0;
            while (ch = *lpTempIn++) {
                if (ch == '\t' || (ch >= QP_LOWRANGE_MIN && ch <= QP_LOWRANGE_MAX) ||
                  (ch >= QP_HIGHRANGE_MIN && ch <= QP_HIGHRANGE_MAX)) {
                    if (cbLine >= QUOTED_PRINTABLE_MAX_LINE) {
                        //  char would overshoot max, wrap here
                        *(lpTempOut++) = '=';
                        *(lpTempOut++) = '\r';
                        *(lpTempOut++) = '\n';
                        cbLine = 0;
                    }
                    *(lpTempOut++) = ch;
                    cbLine++;
                } else {
                    if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE - 3)) {
                        // 3 chars would overshoot max, wrap here
                        *(lpTempOut++) = '=';
                        *(lpTempOut++) = '\r';
                        *(lpTempOut++) = '\n';
                        cbLine = 0;
                    }

                    *(lpTempOut++) = '=';
                    if ((bOut = ((ch & 0xF0) >> 4)) > 9) {
                        *(lpTempOut++) = bOut + ('A' - 10);
                    } else {
                        *(lpTempOut++) = bOut + '0';
                    }
                    if ((bOut = ch & 0x0F) > 9) {
                        *(lpTempOut++) = bOut + ('A' - 10);
                    } else {
                        *(lpTempOut++) = bOut + '0';
                    }
                    cbLine += 3;
                }
            }
            *lpTempOut = '\0';  // terminate the string
        } // else fail
    }

    return(lpBuffer);
}


/***************************************************************************

    Name      : EncodeBase64

    Purpose   : Encodes BASE64
    Parameters: lpBuffer -> input buffer
                cbBuffer = size of input buffer
                lpcbReturn -> returned size of output buffer

    Returns   : encoded string buffer (must be LocalFree'd by caller)

    Comment   :

***************************************************************************/
#define BASE64_MAX_LINE 76
LPSTR EncodeBase64(LPBYTE lpInput, ULONG cbBuffer, LPULONG lpcbReturn) {
//#ifdef NEW_STUFF
    LPSTR lpBuffer = NULL;
    PUCHAR outptr;   
    UINT   i, cExtras;
    UINT   j, cCount, nBreakPt = ( (BASE64_MAX_LINE/4) - 1 );  // 72 encoded chars per line plus 4 spaces makes 76
                                // = (76 - 4)/ 4  for num of non space lines with 4 encoded characters per 3 data chars
    CONST CHAR * rgchDict = six2base64;
    // 4 spaces and 2 chars = 6 for new line
    cExtras = 6 * ((cbBuffer / BASE64_MAX_LINE) + 2); // want to add newline at beginning and end
    lpBuffer = LocalAlloc( LMEM_ZEROINIT, sizeof( TCHAR ) * (3 * cbBuffer  + cExtras));
    if (!lpBuffer)
        return NULL;

    // need to add a new line every 76 characters...
    outptr = (UCHAR *)lpBuffer;
    cCount = 0;

    for (i=0; i < cbBuffer; i += 3) 
    {// want it to start on next line from tag anyways so it is okay when i=0
        if( cCount++ % nBreakPt == 0 ) 
        {
            *(outptr++) = (CHAR)(13);
            *(outptr++) = (CHAR)(10);
            // then 4 spaces
            for( j = 0; j < 4; j++)
                *(outptr++) = ' ';
        }
        *(outptr++) = rgchDict[*lpInput >> 2];            /* c1 */
        *(outptr++) = rgchDict[((*lpInput << 4) & 060)      | ((lpInput[1] >> 4) & 017)]; /*c2*/
        *(outptr++) = rgchDict[((lpInput[1] << 2) & 074)    | ((lpInput[2] >> 6) & 03)];/*c3*/
        *(outptr++) = rgchDict[lpInput[2] & 077];         /* c4 */
        
        lpInput += 3;
    }
    /* If cbBuffer was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
    if(i == cbBuffer+1) {
        /* There were only 2 bytes in that last group */
        outptr[-1] = '=';
    } else if(i == cbBuffer+2) {
        /* There was only 1 byte in that last group */
        outptr[-1] = '=';
        outptr[-2] = '=';
    }
    
    cCount = ((cCount - 1) % nBreakPt != 0) ? 2 : 1; // prevent an extra newline
    for ( i = 0; i < cCount; i++)
    {
        *(outptr++) = (CHAR)(13);
        *(outptr++) = (CHAR)(10);
    }
    *outptr = '\0';
   
    return lpBuffer;
}


/***************************************************************************

    Name      : WriteVCardValue

    Purpose   : Encode and write the value of a vCard item.

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpData -> data to be written
                cbData = length of data (or 0 if null-terminated string data)

    Returns   : HRESULT

    Comment   : Assumes that the Key and any parameters have been written,
                and we are ready for a ':' and some value data.

***************************************************************************/
HRESULT WriteVCardValue(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE lpData,
  ULONG cbData) {
    HRESULT hResult = hrSuccess;
    register LPSTR lpTemp = (LPSTR)lpData;
    BOOL fBase64 = FALSE, fQuotedPrintable = FALSE;
    LPSTR lpBuffer = NULL;
    register TCHAR ch;

    if (cbData) {
        // Binary data, use BASE64 encoding
        fBase64 = TRUE;
        // Mark it as BASE64
        WRITE_OR_EXITW(szSemicolon);
        WRITE_OR_EXIT(vcpTable[VCARD_PARAM_ENCODING]);
        WRITE_OR_EXIT(szEquals);
        WRITE_OR_EXIT(vceTable[VCARD_ENCODING_BASE64]);
        lpBuffer = EncodeBase64(lpData, cbData, &cbData);
    } else {
        // Text data, do we need to encode?
        while (ch = *lpTemp++) {
            // If there are characters with the high bit set or control characters,
            // then we must use QUOTED_PRINTABLE

/* New vCard draft says default type is 8 bit so we should allow non-ASCII chars
    Some confusion about charsets if we need to fill that data in and also if we
    need to covert the current language to UTF-8

            if (ch > 0x7f) {        // high bits set.  Not ASCII!
                DebugTrace( TEXT("WriteVCardValue found non-ASCII data\n"));
                hResult = ResultFromScode(WAB_E_VCARD_NOT_ASCII);
                goto exit;
            }
*/
            if (ch < 0x20) {
                fQuotedPrintable = TRUE;
                // Mark it as QUOTED_PRINTABLE
                WRITE_OR_EXITW(szSemicolon);
                WRITE_OR_EXIT(vcpTable[VCARD_PARAM_ENCODING]);
                WRITE_OR_EXIT(szEquals);
                WRITE_OR_EXIT(vceTable[VCARD_ENCODING_QUOTED_PRINTABLE]);
                lpBuffer = EncodeQuotedPrintable(lpData);
                break;
            }
        }
    }
    WRITE_OR_EXIT(szColonA);
    WRITE_OR_EXIT(lpBuffer ? lpBuffer : lpData);
    WRITE_OR_EXIT(szCRLFA);

exit:
    if( lpBuffer) 
        LocalFree(lpBuffer);
    return(hResult);
}

/***************************************************************************

    Name:       bIsValidStrProp

    Purpose:    Checks if this is a valid string prop not an empty string
                (Outlook sometimes feeds us blank strings which we print out
                and then other apps go and die ..
*****************************************************************************/
BOOL bIsValidStrProp(SPropValue spv)
{
    return (!PROP_ERROR(spv) && spv.Value.LPSZ && lstrlen(spv.Value.LPSZ));
}

/***************************************************************************

    Name      : WriteVCardTel

    Purpose   : Writes a vCard Telephone entry

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                fPref = TRUE if prefered phone number
                fBusiness = TRUE if a work number
                fHome = TRUE if a home number
                fVoice = TRUE if a voice number
                fFax = TRUE if a fax number
                fISDN = TRUE if an ISDN number
                fCell = TRUE if a cellular number
                fPager = TRUE if a pager number
                fCar = TRUE if a car phone

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCardTel(HANDLE hVCard, VCARD_WRITE WriteFn,
  SPropValue spv,
  BOOL fPref,
  BOOL fBusiness,
  BOOL fHome,
  BOOL fVoice,
  BOOL fFax,
  BOOL fISDN,
  BOOL fCell,
  BOOL fPager,
  BOOL fCar) {
    HRESULT hResult = hrSuccess;

    if (!bIsValidStrProp(spv))
        return hResult;

    if (! PROP_ERROR(spv)) {
        WRITE_OR_EXIT(vckTable[VCARD_KEY_TEL]);
        if (fPref) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PREF]);
        }
        if (fBusiness) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
        }
        if (fHome) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
        }
        if (fFax) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_FAX]);
        }
        if (fCell) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_CELL]);
        }
        if (fCar) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_CAR]);
        }
        if (fPager) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PAGER]);
        }
        if (fISDN) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_ISDN]);
        }
        if (fVoice) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_VOICE]);
        }

        WRITE_VALUE_OR_EXITW(spv.Value.LPSZ, 0);
    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : WriteVCardEmail

    Purpose   : Writes a vCard Email entry

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpEmailAddress -> Email address
                lpAddrType -> Addrtype or NULL (Default is SMTP)
                fDefault = TRUE if this is the preferred email address

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCardEmail(HANDLE hVCard, VCARD_WRITE WriteFn, LPTSTR lpEmailAddress,
  LPTSTR lpAddrType, BOOL fDefault) {
    HRESULT hResult = hrSuccess;

    if (lpEmailAddress && lstrlen(lpEmailAddress)) {

        WRITE_OR_EXIT(vckTable[VCARD_KEY_EMAIL]);
        WRITE_OR_EXITW(szSemicolon);
        if (fDefault) {
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PREF]);
            WRITE_OR_EXITW(szSemicolon);
        }

        if (lpAddrType && lstrlen(lpAddrType)) {
            if (! lstrcmpi(lpAddrType, szSMTP)) {
                WRITE_OR_EXIT(vctTable[VCARD_TYPE_INTERNET]);
            } else if (! lstrcmpi(lpAddrType, szX400)) {
                WRITE_OR_EXIT(vctTable[VCARD_TYPE_X400]);
            } else {
                // BUGBUG: This is questionable... we should stick to
                // the spec defined types, but what if they don't match?
                // Maybe I should ignore the type in that case.
                WRITE_OR_EXITW(lpAddrType);
            }
        } else {
            // Assume SMTP
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_INTERNET]);
        }
        WRITE_VALUE_OR_EXITW(lpEmailAddress, 0);
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : PropLength

    Purpose   : string length of string property

    Parameters: spv = SPropValue
                lppString -> return pointer to string value or NULL

    Returns   : size of string (not including null)

    Comment   :

***************************************************************************/
ULONG PropLength(SPropValue spv, LPTSTR * lppString) {
    ULONG cbRet = 0;

    if (! PROP_ERROR(spv) && spv.Value.LPSZ && lstrlen(spv.Value.LPSZ)) 
    {
        *lppString = spv.Value.LPSZ;
        cbRet = sizeof(TCHAR)*lstrlen(*lppString);
    } else 
    {
        *lppString = NULL;
    }
    return(cbRet);
}


/***************************************************************************

    Name      : WriteVCard

    Purpose   : Writes a vCard to a file from a MAILUSER object.

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpMailUser -> open mailuser object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCard(HANDLE hVCard, VCARD_WRITE WriteFn, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    ULONG ulcValues;
    LPSPropValue lpspv = NULL,
                 lpspvAW = NULL;
    ULONG i;
    LPTSTR lpTemp = NULL;
    ULONG cbTemp = 0;
    LPTSTR lpSurname, lpGivenName, lpMiddleName, lpGeneration, lpPrefix;
    ULONG cbSurname, cbGivenName, cbMiddleName, cbGeneration, cbPrefix;
    LPTSTR lpCompanyName, lpDepartmentName;
    LPTSTR lpPOBox, lpOffice, lpStreet, lpCity, lpState, lpPostalCode, lpCountry;
    LPTSTR lpEmailAddress, lpAddrType;
    ULONG iDefaultEmail;
    LPEXTVCARDPROP lpList       = NULL;
    LPBYTE lpDataBuffer         = NULL;
    LPCERT_DISPLAY_INFO lpCDI   = NULL, lpCDITemp = NULL;

    // See if there are any named props we need to export
    //
    HrGetExtVCardPropList(lpMailUser, &lpList);

    // Get the interesting properties from the MailUser object
    if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
       (LPSPropTagArray)&tagaVCard,
       MAPI_UNICODE,      // flags
       &ulcValues,
       &lpspv)))
    {
        // @hack [bobn] {IE5-Raid 90265} Outlook cannot handle MAPI_UNICODE on Win9x
        // lets try not asking for unicode and converting...

        if(HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaVCard,
          0,      // flags
          &ulcValues,
          &lpspv)))
        {
            DebugTrace( TEXT("WriteVCard:GetProps -> %x\n"), GetScode(hResult));
            goto exit;
        }

        if(HR_FAILED(hResult = HrDupeOlkPropsAtoWC(ulcValues, lpspv, &lpspvAW)))
            goto exit;

        FreeBufferAndNull(&lpspv);
        lpspv = lpspvAW;
    }

    if (ulcValues) {

        WRITE_OR_EXIT(vckTable[VCARD_KEY_BEGIN]);
        WRITE_VALUE_OR_EXIT(vckTable[VCARD_KEY_VCARD], 0);

        WRITE_OR_EXIT(vckTable[VCARD_KEY_VERSION]);
        WRITE_VALUE_OR_EXIT(CURRENT_VCARD_VERSION, 0);

        //
        // Required props
        //

        //
        // Name
        //

        // Make sure we have a name.
        // If there is no FML, create them from DN.  If no DN, fail.
        cbSurname = PropLength(lpspv[ivcPR_SURNAME], &lpSurname);
        cbGivenName = PropLength(lpspv[ivcPR_GIVEN_NAME], &lpGivenName);
        cbMiddleName = PropLength(lpspv[ivcPR_MIDDLE_NAME], &lpMiddleName);
        cbGeneration = PropLength(lpspv[ivcPR_GENERATION], &lpGeneration);
        cbPrefix = PropLength(lpspv[ivcPR_DISPLAY_NAME_PREFIX], &lpPrefix);

        if (! lpSurname && ! lpGivenName && ! lpMiddleName) {
            // No FML, create them from DN.
            ParseDisplayName(
              lpspv[ivcPR_DISPLAY_NAME].Value.LPSZ,
              &lpGivenName,
              &lpSurname,
              lpspv,        // lpvRoot
              NULL);        // lppLocalFree

            cbGivenName = lstrlen(lpGivenName);
            cbSurname = lstrlen(lpSurname);
        }

        cbTemp = 0;
        cbTemp += cbSurname;
        cbTemp++;   // ';'
        cbTemp += cbGivenName;
        cbTemp++;   // ';'
        cbTemp += cbMiddleName;
        cbTemp++;   // ';'
        cbTemp += cbPrefix;
        cbTemp++;   // ';'
        cbTemp += cbGeneration;

        if (! (lpSurname || lpGivenName || lpMiddleName)) {
            hResult = ResultFromScode(MAPI_E_MISSING_REQUIRED_COLUMN);
            goto exit;
        }
        if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*(cbTemp + 1)))) {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        *lpTemp = '\0';
        if (lpSurname) {
            lstrcat(lpTemp, lpSurname);
        }
        if (lpGivenName || lpMiddleName || lpPrefix || lpGeneration) {
            lstrcat(lpTemp, szSemicolon);
        }
        if (lpGivenName) {
            lstrcat(lpTemp, lpGivenName);
        }
        if (lpMiddleName || lpPrefix || lpGeneration) {
            lstrcat(lpTemp, szSemicolon);
        }
        if (lpMiddleName) {
            lstrcat(lpTemp, lpMiddleName);
        }
        if (lpPrefix || lpGeneration) {
            lstrcat(lpTemp, szSemicolon);
        }
        if (lpPrefix) {
            lstrcat(lpTemp, lpPrefix);
        }
        if (lpGeneration) {
            lstrcat(lpTemp, szSemicolon);
            lstrcat(lpTemp, lpGeneration);
        }
        WRITE_OR_EXIT(vckTable[VCARD_KEY_N]);
        WRITE_VALUE_OR_EXITW(lpTemp, 0);
        LocalFreeAndNull(&lpTemp);

        //
        // Optional props
        //

        //
        // Formatted Name: PR_DISPLAY_NAME
        //
        if(bIsValidStrProp(lpspv[ivcPR_DISPLAY_NAME]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_FN]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_DISPLAY_NAME].Value.LPSZ, 0);
        }


        //
        // Title: PR_NICKNAME
        //
        if(bIsValidStrProp(lpspv[ivcPR_NICKNAME]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_NICKNAME]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_NICKNAME].Value.LPSZ, 0);
        }

        //
        // Organization: PR_COMPANY_NAME, PR_DEPARTMENT_NAME
        //
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_COMPANY_NAME], &lpCompanyName);
        cbTemp++;   // semicolon
        cbTemp += PropLength(lpspv[ivcPR_DEPARTMENT_NAME], &lpDepartmentName);
        if (lpCompanyName || lpDepartmentName) {
            if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*(cbTemp + 1)))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpCompanyName) {
                lstrcat(lpTemp, lpCompanyName);
            }
            if (lpDepartmentName) {
                lstrcat(lpTemp, szSemicolon);
                lstrcat(lpTemp, lpDepartmentName);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ORG]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Title: PR_TITLE
        //
        if(bIsValidStrProp(lpspv[ivcPR_TITLE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_TITLE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_TITLE].Value.LPSZ, 0);
        }

        //
        // Note: PR_COMMENT
        //
        if(bIsValidStrProp(lpspv[ivcPR_COMMENT]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_NOTE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_COMMENT].Value.LPSZ, 0);
        }


        //
        // Phone numbers
        //

        //
        // PR_BUSINESS_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS_TELEPHONE_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }


        //
        // PR_BUSINESS2_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS2_TELEPHONE_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_HOME_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_CELLULAR_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_CELLULAR_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          TRUE,         // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_CAR_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_CAR_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          TRUE)) {      // fCar
            goto exit;
        }

        //
        // PR_OTHER_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_OTHER_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_PAGER_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_PAGER_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          TRUE,         // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_BUSINESS_FAX_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS_FAX_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          TRUE,         // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }
        //
        // PR_HOME_FAX_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME_FAX_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          FALSE,        // fVoice
          TRUE,         // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_HOME2_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME2_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_ISDN_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_ISDN_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          TRUE,         // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_PRIMARY_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_PRIMARY_TELEPHONE_NUMBER],
          TRUE,         // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // Business Address
        //
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OFFICE_LOCATION], &lpOffice);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_COUNTRY], &lpCountry);
        if (lpPOBox || lpOffice || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*(cbTemp + 1)))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
            }
            if (lpOffice || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpOffice) {
                lstrcat(lpTemp, lpOffice);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
            }
            if (lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
            }
            if (lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
            }
            if (lpCountry) {
                lstrcat(lpTemp, szSemicolon);
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);


            // Business Delivery Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpOffice) {
                lstrcat(lpTemp, lpOffice);
                if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
                if (lpState) {
                    lstrcat(lpTemp, szCommaSpace);
                } else if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
                if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
                if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCountry) {
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Home Address
        //
        lpPOBox = lpStreet = lpCity = lpState = lpPostalCode = lpCountry = NULL;
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        lpOffice = NULL;
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_COUNTRY], &lpCountry);
        if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR,  sizeof(TCHAR)*(cbTemp + 1)))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);   // WAB doesn't have extended on HOME address
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
            }
            if (lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
            }
            if (lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
            }
            if (lpCountry) {
                lstrcat(lpTemp, szSemicolon);
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);


            // Home Delivery Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
                if (lpState) {
                    lstrcat(lpTemp, szCommaSpace);
                } else if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
                if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
                if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCountry) {
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Other Address
        //
        lpPOBox = lpStreet = lpCity = lpState = lpPostalCode = lpCountry = NULL;
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        lpOffice = NULL;
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_COUNTRY], &lpCountry);
        if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR,  sizeof(TCHAR)*(cbTemp + 1)))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);   // WAB doesn't have extended on HOME address
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
            }
            if (lpState || lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
            }
            if (lpPostalCode || lpCountry) {
                lstrcat(lpTemp, szSemicolon);
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
            }
            if (lpCountry) {
                lstrcat(lpTemp, szSemicolon);
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_POSTAL]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);

            // Adr Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpPOBox) {
                lstrcat(lpTemp, lpPOBox);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpStreet) {
                lstrcat(lpTemp, lpStreet);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCity) {
                lstrcat(lpTemp, lpCity);
                if (lpState) {
                    lstrcat(lpTemp, szCommaSpace);
                } else if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpState) {
                lstrcat(lpTemp, lpState);
                if (lpPostalCode) {
                    lstrcat(lpTemp, szSpace);
                } else if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpPostalCode) {
                lstrcat(lpTemp, lpPostalCode);
                if (lpCountry) {
                    lstrcat(lpTemp, szCRLF);
                }
            }
            if (lpCountry) {
                lstrcat(lpTemp, lpCountry);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_POSTAL]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        // GENDER
        if(! PROP_ERROR(lpspv[ivcPR_GENDER] ) )
        {           
            TCHAR szBuf[4];
            INT fGender = lpspv[ivcPR_GENDER].Value.l;

            // don't want to export gender data if
            // it is unspecified

            if( fGender == 1 || fGender == 2 ) 
            {
                szBuf[0] = '0' + fGender;
                szBuf[1] = '\0';                
                WRITE_OR_EXIT(vckTable[VCARD_KEY_X_WAB_GENDER]);             
                WRITE_OR_EXIT(szColonA);
                WRITE_OR_EXITW(szBuf);
                WRITE_OR_EXIT(szCRLFA);
            }
        }

        //
        // URL's.  Must do personal first.  Note that the vCard 2.0 standard does
        // not distinguish between HOME and WORK URL's.  Too bad.  Thus, if we export
        // a contact with only a business home page, then import it, we will end up
        // with a contact that has a personal home page.  Hopefully, the vCard 3.0 standard
        // will fix this.
        //

        // 62808: The above is really a big problem in Outlook because there is perceived data loss
        // Hence to prevent this, we will take advantage of a bug in WAB code .. blank URLS are not
        // ignored .. we will write out a blank URL for the personal one when only a business URL exists
        // That way, when round-tripping the business URL shows up in the right place
        //
        
		//
		// It's September of 2000.  The European Commission is looking at Outlook for their mail client,
		// one of the things that is hanging them up is this bug, the WORK URL jumps from the WORK URL 
		// box to the HOME URL if you export/import the vCard.  We need this functioning, so I looked
		// for the vCard 3.0 standard to see how they are handling the URL.  Every place I look says that
		// the people in charge of the vCard standard is www.versit.com, this however is a now defunct web
		// site, I queried the other companies that use the vCard, Apple, IBM, AT&T all give press releases
		// telling you to look at the www.versit.com web site, they also give a 1-800 number to call.  I've 
		// called the 1-800 number and that number is now a yellow pages operator.  I can't find a vCard 3.0 
		// standard, so......
		// 
		// Now, we all wish we could do this: URL;HOME: and URL;WORK:.  Well I'm going to do it!
		//
		
		//
        // URL: PR_PERSONAL_HOME_PAGE
        //
        if(bIsValidStrProp(lpspv[ivcPR_PERSONAL_HOME_PAGE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_URL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);

            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_PERSONAL_HOME_PAGE].Value.LPSZ, 0);
        }

        //
        // URL: PR_BUSINESS_HOME_PAGE
        //
        if(bIsValidStrProp(lpspv[ivcPR_BUSINESS_HOME_PAGE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_URL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);

            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_BUSINESS_HOME_PAGE].Value.LPSZ, 0);
        }

        //
        // ROLE: PR_PROFESSION
        //
        if(bIsValidStrProp(lpspv[ivcPR_PROFESSION]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ROLE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_PROFESSION].Value.LPSZ, 0);
        }

        //
        // BDAY: PR_BIRTHDAY
        //
        // Format is YYYYMMDD e.g. 19970911 for September 11, 1997
        //
        if (! PROP_ERROR(lpspv[ivcPR_BIRTHDAY])) 
        {
            SYSTEMTIME st = {0};
            FileTimeToSystemTime((FILETIME *) (&lpspv[ivcPR_BIRTHDAY].Value.ft), &st);
            lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*32);
            wsprintf(lpTemp, TEXT("%.4d%.2d%.2d"), st.wYear, st.wMonth, st.wDay);
            WRITE_OR_EXIT(vckTable[VCARD_KEY_BDAY]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // DIGITAL CERTIFICATES
        //
        if(! PROP_ERROR(lpspv[ivcPR_USER_X509_CERTIFICATE] ) 
            // && ! PROP_ERROR(lpspv[ivcPR_EMAIL_ADDRESS])  
            )
        {   

            // LPTSTR              lpszDefaultEmailAddress = lpspv[ivcPR_EMAIL_ADDRESS].Value.LPSZ;
            LPSPropValue        lpSProp                 = &lpspv[ivcPR_USER_X509_CERTIFICATE];
            lpCDI = lpCDITemp = NULL;
            if( HR_FAILED(hResult = HrGetCertsDisplayInfo( NULL, lpSProp, &lpCDI) ) )
            {
                DebugTrace( TEXT("get cert display info failed\n"));
            }
            else
            {
                lpCDITemp = lpCDI;
                while( lpCDITemp )
                {
                /*        if( (lstrcmp(lpCDITemp->lpszEmailAddress, lpszDefaultEmailAddress) == 0)
                && lpCDITemp->bIsDefault )
                    break;*/
                    
                    if( lpCDITemp )  // found a certificate now export it to buffer and write to file          
                    {
                        ULONG  cbBufLen;                
                        
                        if( HR_SUCCEEDED(hResult = HrExportCertToFile( NULL, lpCDITemp->pccert, 
                            &lpDataBuffer, &cbBufLen, TRUE) ) )
                        {
                            WRITE_OR_EXIT(vckTable[VCARD_KEY_KEY]);
                            WRITE_OR_EXITW(szSemicolon);
                            WRITE_OR_EXIT(vctTable[VCARD_TYPE_X509]);
                            WRITE_VALUE_OR_EXITW(lpDataBuffer, cbBufLen);
                        }
                        else
                        {
                            DebugTrace( TEXT("unable to write to buffer at address %x\n"), lpDataBuffer);
                        }
                        LocalFreeAndNull(&lpDataBuffer);
                    }
                    lpCDITemp = lpCDITemp->lpNext;
                }                                        
            }
            while( lpCDI )  // free the cert info
            {
                lpCDITemp = lpCDI->lpNext;
                FreeCertdisplayinfo(lpCDI);
                lpCDI = lpCDITemp;
            }
            lpCDI = lpCDITemp = NULL;
        }
        //
        // E-Mail addresses
        //
        if (! PROP_ERROR(lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES])) {
            // What's the default?
            if (PROP_ERROR(lpspv[ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX])) {
                iDefaultEmail = 0;
            } else {
                iDefaultEmail = lpspv[ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX].Value.l;
            }

            // for each email address, add an EMAIL key
            for (i = 0; i < lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.cValues; i++) {
                lpEmailAddress = lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.LPPSZ[i];
                if (PROP_ERROR(lpspv[ivcPR_CONTACT_ADDRTYPES])) {
                    lpAddrType = (LPTSTR)szSMTP;
                } else {
                    lpAddrType = lpspv[ivcPR_CONTACT_ADDRTYPES].Value.MVSZ.LPPSZ[i];
                }
                if (hResult = WriteVCardEmail(hVCard, WriteFn, lpEmailAddress, lpAddrType, (iDefaultEmail == i))) {
                    goto exit;
                }
            }
        } else {
            // no PR_CONTACT_EMAIL_ADDRESSES, try PR_EMAIL_ADDRESS

            PropLength(lpspv[ivcPR_EMAIL_ADDRESS], &lpEmailAddress);
            PropLength(lpspv[ivcPR_ADDRTYPE], &lpAddrType);

            if (hResult = WriteVCardEmail(hVCard, WriteFn, lpEmailAddress, lpAddrType, TRUE)) {
                goto exit;
            }
        }

        //
        // EMAIL;TLX: PR_TELEX_NUMBER
        //
        // There is no place to put a telex number in a vCard but the EMAIL field
        // allows us to specify any AddrType .. hence under pressure from Outlook,
        // we force this Telex number into email .. Must make sure to filter this out
        // when we read in a vCard
        //
        if(bIsValidStrProp(lpspv[ivcPR_TELEX_NUMBER]))
        {
            if (hResult = WriteVCardEmail(hVCard, WriteFn, 
                                lpspv[ivcPR_TELEX_NUMBER].Value.LPSZ, 
                                TEXT("TLX"), FALSE)) 
            {
                goto exit;
            }
            
        }


        // Check if there are any outlook specific named properties
        // that need to be written out to the vCard
        if(lpList)
        {
            LPEXTVCARDPROP lpTemp = lpList;
            while(  lpTemp && lpTemp->ulExtPropTag && 
                    lpTemp->lpszExtPropName && lstrlenA(lpTemp->lpszExtPropName))
            {
                LPSPropValue lpspv = NULL;
                if(!HR_FAILED(HrGetOneProp( (LPMAPIPROP)lpMailUser,
                                            lpTemp->ulExtPropTag,
                                            &lpspv ) ))
                {
                    if(lpspv->Value.LPSZ && lstrlen(lpspv->Value.LPSZ))
                    {
                        WRITE_OR_EXIT(lpTemp->lpszExtPropName);
                        WRITE_VALUE_OR_EXITW(lpspv->Value.LPSZ, 0);
                    }
                    FreeBufferAndNull(&lpspv);
                }
                lpTemp = lpTemp->lpNext;
            }
        }

        //
        // REV: Current Modification Time
        //
        // Format is YYYYMMDD e.g. 19970911 for September 11, 1997
        //
        {
            SYSTEMTIME st = {0};
            GetSystemTime(&st);
            lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*32);
            wsprintf(lpTemp, TEXT("%.4d%.2d%.2dT%.2d%.2d%.2dZ"), 
                            st.wYear, st.wMonth, st.wDay,
                            st.wHour,st.wMinute,st.wSecond);
            WRITE_OR_EXIT(vckTable[VCARD_KEY_REV]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }
        // End of VCARD

        WRITE_OR_EXIT(vckTable[VCARD_KEY_END]);
        WRITE_VALUE_OR_EXIT(vckTable[VCARD_KEY_VCARD], 0);
    }

exit:
    if(lpList)
        FreeExtVCardPropList(lpList);

    while( lpCDI )  // free the cert info
    {
        lpCDITemp = lpCDI->lpNext;
        FreeCertdisplayinfo(lpCDI);
        lpCDI = lpCDITemp;
    }
    lpCDI = lpCDITemp = NULL;
    LocalFreeAndNull(&lpTemp);
    FreeBufferAndNull(&lpspv);
    LocalFreeAndNull(&lpDataBuffer);
    return(hResult);
}


/***************************************************************************

    Name      : FileWriteFn

    Purpose   : write to the file handle

    Parameters: handle = open file handle
                lpBuffer -> buffer to write
                uBytes = size of lpBuffer
                lpcbWritten -> returned bytes written (may be NULL)

    Returns   : HRESULT

    Comment   : WriteFile callback for WriteVCard

***************************************************************************/
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten) {
    ULONG cbWritten = 0;

    if (lpcbWritten) {
        *lpcbWritten = 0;
    } else {
        lpcbWritten = &cbWritten;
    }

#ifdef DEBUG
    {
        LPTSTR lpW = ConvertAtoW((LPCSTR)lpBuffer);
        DebugTrace(lpW);
        LocalFreeAndNull(&lpW);
    }
#endif

    if (! WriteFile(handle,
      lpBuffer,
      uBytes,
      lpcbWritten,
      NULL)) {
        DebugTrace( TEXT("FileWriteFn:WriteFile -> %u\n"), GetLastError());
        return(ResultFromScode(MAPI_E_DISK_ERROR));
    }

    return(hrSuccess);
}

////////////////////////////////////////////////////////////////

/*
-
- VCardGetBuffer
-
*   Retreives a vCard Buffer from a given filename or
*   retrieves a copy of a given buffer
*   Also inspects the buffer to see how many vCard
*   files are nested in it
*
*   lpszFileName - File to open
*   lpszBuf - Stream to open
*   ulFlags - MAPI_DIALOG or none
*   lppBuf - Local Alloced returned buf
*/
BOOL VCardGetBuffer(LPTSTR lpszFileName, LPSTR lpszBuf, LPSTR * lppBuf)
{
    BOOL bRet = FALSE;
    LPSTR lpBuf = NULL;
    HANDLE hFile = NULL;

    if(!lpszFileName && !lpszBuf)
        goto out;

    // first look for a buffer and not for the filename
    if(lpszBuf && lstrlenA(lpszBuf))
    {
        lpBuf = LocalAlloc(LMEM_ZEROINIT, lstrlenA(lpszBuf)+1);
        if(!lpBuf)
            goto out;
        lstrcpyA(lpBuf, lpszBuf);
    }
    else
    if(lpszFileName && lstrlen(lpszFileName))
    {
        if (INVALID_HANDLE_VALUE == 
            (hFile = CreateFile(lpszFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
                                OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL)))
        {
            goto out;
        }

        // Read the whole file into a buffer
        {
            DWORD dwSize = GetFileSize(hFile, NULL);
            DWORD dwRead = 0;
            if(!dwSize || dwSize == 0xFFFFFFFF)
                goto out; //err
            lpBuf = LocalAlloc(LMEM_ZEROINIT, dwSize+1);
            if(!lpBuf)
                goto out;
            if(!ReadFile(hFile, lpBuf, dwSize, &dwRead, NULL))
                goto out;
        }
    }

    *lppBuf = lpBuf;
    bRet = TRUE;
out:
    if(hFile)
        IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
    return bRet;
}

/*
- 
- VCardGetNextBuffer
-
*   Scans a vCard buffer and returns pointers to the next vCard and the one after that
*
*/
static const LPSTR szVBegin = "BEGIN:VCARD";
static const LPSTR szVEnd = "END:VCARD";
BOOL VCardGetNextBuffer(LPSTR lpBuf, LPSTR * lppVCard, LPSTR * lppNext)
{
    LPSTR lpTemp = lpBuf;
    char sz[64];
    int nStr = lstrlenA(szVEnd);
    BOOL bFound = FALSE;
    BOOL bRet = TRUE;

    Assert(lppVCard);
    Assert(lppNext);
    *lppVCard = lpBuf;
    *lppNext = NULL;

    // Scan along lpBuf till we get to END:VCARD
    // After finding END:VCARD - insert a NULL to terminate the string 
    // and find the start of the next string

    if (!lpTemp)
        return FALSE;
    
    while((lstrlenA(lpTemp) >= nStr) && !bFound)
    {
        CopyMemory(sz,lpTemp,nStr);
        sz[nStr] = '\0';
        if(!lstrcmpiA(sz, szVEnd))
        {
            // Add a terminating NULL to isolate the vCard
            *(lpTemp + nStr) = '\0';
            lpTemp += nStr + 1;
            bFound = TRUE;
        }
        // scan to the end of the line
        while(*lpTemp && *lpTemp != '\n')
            lpTemp++;

        // Start from the next line
        if (*lpTemp)
            lpTemp++;
    }

    bFound = FALSE;
    nStr = lstrlenA(szVBegin);

    // Find the starting of the next BEGIN:VCARD
    while((lstrlenA(lpTemp) >= nStr) && !bFound)
    {
        CopyMemory(sz,lpTemp,sizeof(TCHAR)*nStr);
        sz[nStr] = '\0';
        if(!lstrcmpiA(sz, szVBegin))
        {
            *lppNext = lpTemp;
            bFound = TRUE;
        }
        else
        {
            // scan to the end of the line
            while(*lpTemp && *lpTemp != '\n')
                lpTemp++;

            // Start from the next line
            if (*lpTemp)
                lpTemp++;
        }
    }

    return bRet;
}


SizedSPropTagArray(2, tagaCerts) = { 2,
        {
            PR_USER_X509_CERTIFICATE,
            PR_WAB_TEMP_CERT_HASH
        }
};
/**
    ParseCert: will parse the binary data in the buffer and set the certificate 
               as a prop for the specified mailuser.
    [IN] lpData - address of the binary data buffer containing the certificate
    [IN] cbData - length of the binary data buffer
    [IN] lpMailUser - access to the mail user so the certificate can be set
*/
HRESULT ParseCert( LPSTR lpData, ULONG cbData, LPMAILUSER lpMailUser)
{
    HRESULT         hr          = hrSuccess;
    ULONG           ulcProps    = 0;
    LPSPropValue    lpSpv       = NULL;
    if( lpData && *lpData )
    {
        if( HR_FAILED( hr = lpMailUser->lpVtbl->GetProps( lpMailUser, 
                    (LPSPropTagArray)&tagaCerts, 
                    MAPI_UNICODE,
                    &ulcProps,
                    &lpSpv) ) )
        {
            DebugTrace( TEXT("could not get Props\n"));
            return hr;
        }
        if(lpSpv[0].ulPropTag != PR_USER_X509_CERTIFICATE )
        {
            MAPIFreeBuffer( lpSpv );
            MAPIAllocateBuffer( sizeof(SPropValue) * 2, &lpSpv);            
            if( lpSpv )            
            {
                lpSpv[0].ulPropTag = PR_USER_X509_CERTIFICATE;
                lpSpv[0].dwAlignPad = 0;
                lpSpv[0].Value.MVbin.cValues = 0;
                lpSpv[1].ulPropTag = PR_WAB_TEMP_CERT_HASH;
                lpSpv[1].dwAlignPad = 0;
                lpSpv[1].Value.MVbin.cValues = 0;
            }
            else
            {
                DebugTrace( TEXT("could not allocate mem for props\n"));
                hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                return hr;
            }
        }
        else
        {
            // [PaulHi] 5/3/99  Check the PR_WAB_TEMP_CERT_HASH to see if it is 
            // of type PT_ERROR.  If it is then this is Ok, it is just empty of
            // data.  We only use this to hold temporary data which is freed below.
            if ( PROP_TYPE(lpSpv[1].ulPropTag) == PT_ERROR )
            {
                lpSpv[1].ulPropTag = PR_WAB_TEMP_CERT_HASH;
                lpSpv[1].Value.MVbin.cValues = 0;
                lpSpv[1].Value.MVbin.lpbin = NULL;
            }
        }
        // Put the certs into the prop array.
        hr = HrLDAPCertToMAPICert( lpSpv, 0, 1, cbData, (LPBYTE)lpData, 1);
        if( HR_SUCCEEDED( hr ) )
        {
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,
                1,
                lpSpv,
                NULL))) 
            {
                DebugTrace( TEXT("failed setting props\n"));
            }
        }
        else
        {
            DebugTrace( TEXT("LDAPCertToMapiCert failed\n"));
        }  
        MAPIFreeBuffer( lpSpv );
    }
    else 
    {
        DebugTrace( TEXT("lpData was null\n"));
        hr = E_FAIL;
    }
    return hr;
}

/**
  DecodeBase64:  decode BASE64 data
  [IN] bufcoded - access to the BASE64 encoded data
  [OUT] pbuffdecoded - address of the buffer where decoded data will go
  [OUT] pcbDecode - length of the decoded data buffer
*/
HRESULT DecodeBase64(LPSTR bufcoded, LPSTR pbuffdecoded, PDWORD pcbDecoded)
{
    INT            nbytesdecoded;
    LPSTR         bufin;
    LPSTR         bufout;
    INT            nprbytes; 
    CONST INT     *rgiDict = base642six;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(rgiDict[*(bufin++)] <= 63);
    nprbytes = (INT) (bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (LPSTR)pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (char) (rgiDict[*bufin] << 2 | rgiDict[bufin[1]] >> 4);
        *(bufout++) =
            (char) (rgiDict[bufin[1]] << 4 | rgiDict[bufin[2]] >> 2);
        *(bufout++) =
            (char) (rgiDict[bufin[2]] << 6 | rgiDict[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(rgiDict[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((LPSTR)pbuffdecoded)[nbytesdecoded] = '\0';

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\w9xwraps.h ===
/*****************************************************************************\
*                                                                             *
* w9xwraps.h - Unicode wrappers for ANSI functions on Win9x                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W9XWRAPS
#define _INC_W9XWRAPS

#ifndef  DONOT_USE_WRAPPER

#define RegOpenKeyExW                RegOpenKeyExWrapW
#define RegQueryValueW               RegQueryValueWrapW
#define RegEnumKeyExW                RegEnumKeyExWrapW
#define RegSetValueW                 RegSetValueWrapW
#define RegDeleteKeyW                RegDeleteKeyWrapW
#define GetUserNameW                 GetUserNameWrapW
#define RegEnumValueW                RegEnumValueWrapW
#define RegDeleteValueW              RegDeleteValueWrapW
#define RegCreateKeyW                RegCreateKeyWrapW
//#define CryptAcquireContextW         CryptAcquireContextWrapW
#define RegQueryValueExW             RegQueryValueExWrapW
#define RegCreateKeyExW              RegCreateKeyExWrapW
#define RegSetValueExW               RegSetValueExWrapW
#define RegQueryInfoKeyW             RegQueryInfoKeyWrapW
#define GetObjectW                   GetObjectWrapW
#define StartDocW                    StartDocWrapW
#define CreateFontIndirectW          CreateFontIndirectWrapW
#define GetLocaleInfoW               GetLocaleInfoWrapW
#define CreateDirectoryW             CreateDirectoryWrapW
#define GetWindowsDirectoryW         GetWindowsDirectoryWrapW
#define GetSystemDirectoryW          GetSystemDirectoryWrapW
#define GetProfileIntW               GetProfileIntWrapW
#define LCMapStringW                 LCMapStringWrapW
#define GetFileAttributesW           GetFileAttributesWrapW
#define CompareStringW              CompareStringWrapW
#define GetStringTypeW              GetStringTypeWrapW
#define lstrcpyW                     lstrcpyWrapW
#define lstrcmpiW                    lstrcmpiWrapW
#define LoadLibraryW                 LoadLibraryWrapW
#define GetTimeFormatW               GetTimeFormatWrapW
#define GetTextExtentPoint32W        GetTextExtentPoint32WrapW
#define GetDateFormatW               GetDateFormatWrapW
#define lstrcpynW                    lstrcpynWrapW
#define CreateFileW                  CreateFileWrapW
#define OutputDebugStringW           OutputDebugStringWrapW
#define lstrcatW                     lstrcatWrapW
#define FormatMessageW               FormatMessageWrapW
#define GetModuleFileNameW           GetModuleFileNameWrapW
#define GetPrivateProfileIntW        GetPrivateProfileIntWrapW
#define IsBadStringPtrW              IsBadStringPtrWrapW
#define GetPrivateProfileStringW     GetPrivateProfileStringWrapW
#define lstrcmpW                     lstrcmpWrapW
#define CreateMutexW                 CreateMutexWrapW
#define GetTempPathW                 GetTempPathWrapW
#define ExpandEnvironmentStringsW    ExpandEnvironmentStringsWrapW
#define GetTempFileNameW             GetTempFileNameWrapW
#define DeleteFileW                  DeleteFileWrapW
#define CopyFileW                    CopyFileWrapW
#define FindFirstChangeNotificationW FindFirstChangeNotificationWrapW
#define FindFirstFileW               FindFirstFileWrapW
#define GetDiskFreeSpaceW            GetDiskFreeSpaceWrapW
#define MoveFileW                    MoveFileWrapW
#define ShellExecuteW                ShellExecuteWrapW
#define DragQueryFileW               DragQueryFileWrapW
#define CharPrevW                    CharPrevWrapW
#define DrawTextW                    DrawTextWrapW
#define ModifyMenuW                  ModifyMenuWrapW
#define InsertMenuW                  InsertMenuWrapW
#define LoadImageW                   LoadImageWrapW
#define GetClassInfoExW              GetClassInfoExWrapW
#define LoadStringW                  LoadStringWrapW
#define CharNextW                    CharNextWrapW
#define SendMessageW                 SendMessageWrapW
#define DefWindowProcW               DefWindowProcWrapW
#define DialogBoxParamW              DialogBoxParamWrapW
#define SendDlgItemMessageW          SendDlgItemMessageWrapW
#define SetWindowLongW               SetWindowLongWrapW
#define GetWindowLongW               GetWindowLongWrapW
#define CreateWindowExW              CreateWindowExWrapW
#define UnRegisterClassW             UnRegisterClassWrapW
#define RegisterClassW               RegisterClassWrapW
#define LoadCursorW                  LoadCursorWrapW
#define wsprintfW                    wsprintfWrapW
#define wvsprintfW                   wvsprintfWrapW
#define RegisterWindowMessageW       RegisterWindowMessageWrapW
#define SystemParametersInfoW        SystemParametersInfoWrapW
#define CreateDialogParamW           CreateDialogParamWrapW
#define SetWindowTextW               SetWindowTextWrapW
#define PostMessageW                 PostMessageWrapW
#define GetMenuItemInfoW             GetMenuItemInfoWrapW
#define GetClassInfoW                GetClassInfoWrapW
#define CharUpperW                   CharUpperWrapW
#define CharUpperBuffW               CharUpperBuffWrapW
#define CharLowerW                   CharLowerWrapW
#define CharLowerBuffW               CharLowerBuffWrapW
#define IsCharUpperW                 IsCharUpperWrapW
#define IsCharLowerW                 IsCharLowerWrapW
#define RegisterClipboardFormatW     RegisterClipboardFormatWrapW
#define DispatchMessageW             DispatchMessageWrapW
#define IsDialogMessageW             IsDialogMessageWrapW
#define GetMessageW                  GetMessageWrapW
#define SetDlgItemTextW              SetDlgItemTextWrapW
#define RegisterClassExW             RegisterClassExWrapW
#define LoadAcceleratorsW            LoadAcceleratorsWrapW
#define LoadMenuW                    LoadMenuWrapW
#define LoadIconW                    LoadIconWrapW
#define GetWindowTextW               GetWindowTextWrapW
#define CallWindowProcW              CallWindowProcWrapW
#define GetClassNameW                GetClassNameWrapW
#define TranslateAcceleratorW        TranslateAcceleratorWrapW
#define GetDlgItemTextW              GetDlgItemTextWrapW
#define SetMenuItemInfoW             SetMenuItemInfoWrapW
#define PeekMessageW                 PeekMessageWrapW
#define GetWindowTextLengthW         GetWindowTextLengthWrapW
#define CreateEventW                 CreateEventWrapW

// for RunTime loaded functions in Comctl32.dll

#define gpfnImageList_LoadImage      gpfnImageList_LoadImageWrapW
#define gpfnPropertySheet            gpfnPropertySheetWrapW
#define gpfnCreatePropertySheetPage  gpfnCreatePropertySheetPageWrapW

// for APIs in Commdlg32.dll

#define pfnGetOpenFileName           pfnGetOpenFileNameWrapW
#define pfnGetSaveFileName           pfnGetSaveFileNameWrapW 

#define pfnPrintDlgEx                pfnPrintDlgExWrapW
#define pfnPrintDlg                  pfnPrintDlgWrapW

#endif  // DONOT_USER_WRAPPER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\valcopy.c ===
/*
 *	VALCOPY.C
 *
 *	Utility functions for validating, copying, and (yeech) relocating
 *	complex MAPI structures.
 *
 *	For each data type there are three functions:
 *		ScCountXXX address-checks and calculates the size
 *		ScCopyXXX copies to a contiguous block of memory, which
 *			must be pre-allocated
 *		ScRelocXXX adjusts pointers, assuming that a structure in a
 *			contiguous block of memory has been moved
 *
 *	Data types supported:
 *		NOTIFICATION (and array of), in ScCountNotifications etc.
 *		SPropValue (and array of), in ScCountProps etc.
 *
 *	//$ SIZE Returning the byte count from ScRelocXXX may not be necessary.
 */

#include <_apipch.h>



#if defined (_AMD64_) || defined (_IA64_)
#define AlignProp(_cb)	Align8(_cb)
#else
#define AlignProp(_cb)	(_cb)
#endif

#define ALIGN_RISC		8
#define ALIGN_X86		1


//	Pointer manipulation macros for use in the Reloc functions
#ifdef WIN16
#define SEG(_fp)	HIWORD((DWORD)_fp)
#define OFF(_fp)	LOWORD((DWORD)_fp)

#define PvRelocPv(_p,_baseOld,_baseNew) \
	((LPVOID)MAKELONG(OFF(_p) - OFF(_baseOld) + OFF(_baseNew), SEG(_baseNew)))
#else
#define PvRelocPv(_p,_baseOld,_baseNew)	\
	((LPVOID)((LPBYTE)(_p) - (LPBYTE)(_baseOld) + (LPBYTE)(_baseNew)))
#endif


#ifdef NOTIFICATIONS    // save this for notifications
STDAPI_(SCODE)
ScCountNotifications(int cntf, LPNOTIFICATION rgntf, ULONG FAR *pcb)
{
	ULONG			cb;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	SCODE			sc = S_OK;

	// validate parameters

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
		 TEXT("pcb fails address check"));

	for (cb = 0, pntf = rgntf; cntf--; ++pntf)
	{
		if (IsBadReadPtr(pntf, sizeof(NOTIFICATION)))
		{
			DebugTraceArg(ScCountNotification,  TEXT("pntf fails address check"));
			goto badNotif;
		}
		cb += sizeof(NOTIFICATION);

		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
//		case (fnevSpooler >> 16):
			//	fnevSpooler and fnevExtended both use the EXTENDED_NOTIFICATION
			//	structure for their parameters
			if (pntf->info.ext.cb &&
				IsBadReadPtr(pntf->info.ext.pbEventParameters, (UINT)pntf->info.ext.cb))
			{
				DebugTraceArg(ScCountNotification,  TEXT("ext.pbEventParameters fails address check"));
				goto badNotif;
			}
			cb += AlignProp(pntf->info.ext.cb);
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr = &pntf->info.err;

				if ( IsBadReadPtr( perr->lpEntryID, (UINT)perr->cbEntryID ) )
				{
					DebugTraceArg( ScCountNotification,  TEXT("lpEntryID fails address check") );
					goto badNotif;
				}

				cb += AlignProp(((UINT)perr->cbEntryID));

				if (perr->lpMAPIError)
				{
					cb += AlignProp(sizeof( MAPIERROR ));

#if defined(_WINNT) && !defined(MAC)
					if (perr->ulFlags & MAPI_UNICODE)
					{
						//$	No error check in WIN16
						if (IsBadStringPtrW((LPWSTR)perr->lpMAPIError->lpszError, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (UNICODE) fails address check"));
							goto badNotif;
						}

						cb += AlignProp(((lstrlenW((LPWSTR)perr->lpMAPIError->lpszError) + 1)
							* sizeof(WCHAR)));

						if ( perr->lpMAPIError->lpszComponent )
						{
							if (IsBadStringPtrW((LPWSTR)perr->lpMAPIError->lpszComponent, INFINITE))
							{
								DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszComponent (UNICODE) fails address check"));
								goto badNotif;
							}

							cb += AlignProp(((lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent) + 1)
								* sizeof(WCHAR)));

						}
					}
					else
#endif
					{
						if (IsBadStringPtrA((LPSTR)perr->lpMAPIError->lpszError, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (ASCII) fails address check"));
							goto badNotif;
						}

						cb += AlignProp((lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1));

						if ( perr->lpMAPIError->lpszComponent )
						{
							if (IsBadStringPtrA((LPSTR)perr->lpMAPIError->lpszComponent, INFINITE))
							{
								DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (ASCII) fails address check"));
								goto badNotif;
							}

							cb += AlignProp((lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1));
						}
					}
				}
				break;
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (IsBadReadPtr(pnew->lpEntryID, (UINT)pnew->cbEntryID))
				{
					DebugTraceArg(ScCountNotification,  TEXT("lpEntryID fails address check"));
					goto badNotif;
				}
				cb += AlignProp(((UINT)pnew->cbEntryID));
				if (IsBadReadPtr(pnew->lpParentID, (UINT)pnew->cbParentID))
				{
					DebugTraceArg(ScCountNotification,  TEXT("lpParentID fails address check"));
					goto badNotif;
				}
				cb += AlignProp(((UINT)pnew->cbParentID));
				if (pnew->lpszMessageClass)
				{
					if (pnew->ulFlags & MAPI_UNICODE)
					{
#if defined(_WINNT) && !defined(MAC)
						//$	No error check in WIN16
						if (IsBadStringPtrW((LPWSTR)pnew->lpszMessageClass, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("newmail.lpszMessageClass (UNICODE) fails address check"));
							goto badNotif;
						}
#endif
						cb += AlignProp(((lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR)));
					}
					else
					{
						if (IsBadStringPtrA((LPSTR)pnew->lpszMessageClass, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("newmail.lpszMessageClass (ASCII) fails address check"));
							goto badNotif;
						}
						cb += AlignProp((lstrlenA((LPSTR)pnew->lpszMessageClass) + 1));
					}
				}

				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->cbEntryID)
				{
					if (IsBadReadPtr(pobj->lpEntryID, (UINT)pobj->cbEntryID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpEntryID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbEntryID);
				}
				if (pobj->cbParentID)
				{
					if (IsBadReadPtr(pobj->lpParentID, (UINT)pobj->cbParentID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpParentID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbParentID);
				}
				if (pobj->cbOldID)
				{
					if (IsBadReadPtr(pobj->lpOldID, (UINT)pobj->cbOldID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpOldID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbOldID);
				}
				if (pobj->cbOldParentID)
				{
					if (IsBadReadPtr(pobj->lpOldParentID, (UINT)pobj->cbOldParentID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpOldParentID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbOldParentID);
				}
				if (pobj->lpPropTagArray)
				{
					if (IsBadReadPtr(pobj->lpPropTagArray, sizeof(ULONG)) ||
						IsBadReadPtr(pobj->lpPropTagArray,
							offsetof(SPropTagArray, aulPropTag) +
								(UINT)pobj->lpPropTagArray->cValues * sizeof(ULONG)))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpPropTagArray fails address check"));
						goto badNotif;
					}
					cb += AlignProp(offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG));
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;
				UINT	n = (UINT) ptn->ulTableEvent;

				if (n != TABLE_CHANGED &&
					n != TABLE_RELOAD &&
					n != TABLE_ERROR &&
					n != TABLE_ROW_ADDED &&
					n != TABLE_ROW_DELETED &&
					n != TABLE_ROW_MODIFIED &&
					n != TABLE_SORT_DONE &&
					n != TABLE_RESTRICT_DONE &&
					n != TABLE_SETCOL_DONE)
				{
					DebugTraceArg(ScCountNotifications,  TEXT("invalid tab.ulTableEvent"));
					goto badNotif;
				}

				if (ptn->propIndex.ulPropTag)
				{
					if (sc = ScCountProps(1, &ptn->propIndex, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->propPrior.ulPropTag)
				{
					if (sc = ScCountProps(1, &ptn->propPrior, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->row.cValues)
				{
					if (sc = ScCountProps((int)ptn->row.cValues, ptn->row.lpProps,
							&cbT))
						goto ret;
					cb += cbT;
				}
				else if (ptn->row.lpProps)
				{
					DebugTraceArg(ScCountNotifications,  TEXT("non-NULL row.lpProps with zero row.cValues in table notification"));
					goto badNotif;
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->cbEntryID)
				{
					if (IsBadReadPtr(pstat->lpEntryID, (UINT)pstat->cbEntryID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("statobj.lpEntryID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pstat->cbEntryID);
				}
				if (pstat->cValues)
				{
					if (sc = ScCountProps((int)pstat->cValues,
							pstat->lpPropVals, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScCountNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScCountNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = cb;

ret:
	DebugTraceSc(ScCountNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;
}

STDAPI_(SCODE)
ScCopyNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvDst,
	ULONG FAR *pcb)
{
	LPBYTE			pb = pvDst;
	ULONG			cb = 0;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	LPNOTIFICATION	pntfDst;
	SCODE			sc = S_OK;

	// validate parameters

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(!cntf || !IsBadWritePtr(pvDst, sizeof(NOTIFICATION) * cntf),
			 TEXT("pvDst fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	cb = cntf * sizeof(NOTIFICATION);
	MemCopy(pvDst, rgntf, (UINT)cb);
	pb = (LPBYTE)pvDst + cb;

	for (pntf = rgntf, pntfDst = (LPNOTIFICATION)pvDst;
		cntf--;
			++pntf, ++pntfDst)
	{
		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
//     case (fnevSpooler >> 16):
			if (pntf->info.ext.cb)
			{
				pntfDst->info.ext.pbEventParameters = pb;
				cbT = pntf->info.ext.cb;
				MemCopy(pb, pntf->info.ext.pbEventParameters, (UINT)cbT);
				pb += AlignProp(cbT);
				cb += AlignProp(cbT);
			}
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr = &pntf->info.err;

				if ( perr->cbEntryID )
				{
					pntfDst->info.err.lpEntryID = (LPENTRYID)pb;
					cbT = perr->cbEntryID;
					MemCopy(pb, perr->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}


				if ( perr->lpMAPIError )
				{
					pntfDst->info.err.lpMAPIError = (LPMAPIERROR)pb;
					cbT = sizeof(MAPIERROR);
					MemCopy( pb, perr->lpMAPIError, sizeof( MAPIERROR ) );
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);

					if (perr->lpMAPIError->lpszError)
					{
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
						{
							cbT = (lstrlenW((LPWSTR)perr->lpMAPIError->lpszError)
									+ 1) * sizeof(WCHAR);
						}
						else
#endif
						{
							cbT = lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1;

						}

						pntfDst->info.err.lpMAPIError->lpszError = (LPSTR)pb;
						MemCopy(pb, perr->lpMAPIError->lpszError, (UINT)cbT);
						pb += AlignProp(cbT);
						cb += AlignProp(cbT);
					}

					if (perr->lpMAPIError->lpszComponent)
					{
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
						{
							cbT = (lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent)
									+ 1) * sizeof(WCHAR);
						}
						else
#endif
						{
							cbT = lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1;

						}

						pntfDst->info.err.lpMAPIError->lpszComponent = pb;
						MemCopy(pb, perr->lpMAPIError->lpszComponent, (UINT)cbT);
						pb += AlignProp(cbT);
						cb += AlignProp(cbT);
					}
				}

				break;
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (pnew->cbEntryID)
				{
					pntfDst->info.newmail.lpEntryID = (LPENTRYID)pb;
					cbT = pnew->cbEntryID;
					MemCopy(pb, pnew->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (pnew->cbParentID)
				{
					pntfDst->info.newmail.lpParentID = (LPENTRYID)pb;
					cbT = pnew->cbParentID;
					MemCopy(pb, pnew->lpParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (pnew->lpszMessageClass)
				{
					if (pnew->ulFlags & MAPI_UNICODE)
						cbT = (lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR);
					else
						cbT = lstrlenA((LPSTR)pnew->lpszMessageClass) + 1;
					pntfDst->info.newmail.lpszMessageClass = (LPTSTR)pb;
					MemCopy(pb, pnew->lpszMessageClass, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->cbEntryID)
				{
					pntfDst->info.obj.lpEntryID = (LPENTRYID)pb;
					cbT = pobj->cbEntryID;
					MemCopy(pb, pobj->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbParentID)
				{
					pntfDst->info.obj.lpParentID = (LPENTRYID)pb;
					cbT = pobj->cbParentID;
					MemCopy(pb, pobj->lpParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbOldID)
				{
					pntfDst->info.obj.lpOldID = (LPENTRYID)pb;
					cbT = pobj->cbOldID;
					MemCopy(pb, pobj->lpOldID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbOldParentID)
				{
					pntfDst->info.obj.lpOldParentID = (LPENTRYID)pb;
					cbT = pobj->cbOldParentID;
					MemCopy(pb, pobj->lpOldParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->lpPropTagArray)
				{
					cbT = offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG);
					pntfDst->info.obj.lpPropTagArray = (LPSPropTagArray)pb;
					MemCopy(pb, pobj->lpPropTagArray, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;

				if (ptn->propIndex.ulPropTag)
				{
					//	Wastes 16 bytes when the property doesn't have a tail
					if (sc = ScCopyProps(1, &ptn->propIndex, pb, &cbT))
						goto ret;
                    //
                    //  This was once a straight structure assignment.  However, on RISC platforms
                    //  if pntfDst is not on an 8-byte boundary, this raises a Datatype
                    //  Misalignment Exception.  Changed this to a memcpy in order to not worry
                    //  about alignment and not cause any extra exception handling.
                    //
					memcpy(&(pntfDst->info.tab.propIndex), (LPSPropValue)pb, sizeof(SPropValue));
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (ptn->propPrior.ulPropTag)
				{
					//	Wastes 16 bytes when the property doesn't have a tail
					if (sc = ScCopyProps(1, &ptn->propPrior, pb, &cbT))
						goto ret;
                    //
                    //  This was once a straight structure assignment.  However, on RISC platforms
                    //  if pntfDst is not on an 8-byte boundary, this raises a Datatype
                    //  Misalignment Exception.  Changed this to a memcpy in order to not worry
                    //  about alignment and not cause any extra exception handling.
                    //
					memcpy(&(pntfDst->info.tab.propPrior), (LPSPropValue)pb, sizeof(SPropValue));
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (ptn->row.cValues)
				{
					pntfDst->info.tab.row.lpProps = (LPSPropValue)pb;
					if (sc = ScCopyProps((int)ptn->row.cValues, ptn->row.lpProps, pb, &cbT))
						goto ret;
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->cbEntryID)
				{
					pntfDst->info.statobj.lpEntryID = (LPENTRYID)pb;
					cbT = pstat->cbEntryID;
					MemCopy(pb, pstat->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pstat->cValues)
				{
					pntfDst->info.statobj.lpPropVals = (LPSPropValue)pb;
					if (sc = ScCopyProps((int)pstat->cValues,
							pstat->lpPropVals, pb, &cbT))
						goto ret;
					pb += cbT;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScCopyNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScCopyNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = (ULONG)cb;

ret:
	DebugTraceSc(ScCopyNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;

#undef COPY
}

STDAPI_(SCODE)
ScRelocNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvBaseOld,
	LPVOID pvBaseNew, ULONG FAR *pcb)
{
	ULONG			cb;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	SCODE			sc = S_OK;

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(pvBaseOld,  TEXT("pvBaseOld fails address check"));

	AssertSz(!IsBadWritePtr(pvBaseNew, sizeof(LPVOID)),
			 TEXT("pvBaseNew fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	cb = cntf * sizeof(NOTIFICATION);
	for (pntf = rgntf; cntf--; ++pntf)
	{
		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
 //      case (fnevSpooler >> 16):
			if (pntf->info.ext.cb)
			{
				pntf->info.ext.pbEventParameters =
					PvRelocPv(pntf->info.ext.pbEventParameters, pvBaseOld,
						pvBaseNew);
				cb += AlignProp(pntf->info.ext.cb);
			}
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr 	= &pntf->info.err;

				if ( perr->lpEntryID )
				{
					perr->lpEntryID = PvRelocPv( perr->lpEntryID, pvBaseOld,
							pvBaseNew );
					cb += AlignProp( (UINT)perr->cbEntryID );
				}

				if ( perr->lpMAPIError )
				{
					perr->lpMAPIError = PvRelocPv( perr->lpMAPIError, pvBaseOld,
							pvBaseNew );

					if (perr->lpMAPIError->lpszError)
					{
						perr->lpMAPIError->lpszError = PvRelocPv(
								perr->lpMAPIError->lpszError, pvBaseOld,
								pvBaseNew );

#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
							cb += AlignProp((lstrlenW((LPWSTR)perr->lpMAPIError->lpszError)
									+ 1) * sizeof(WCHAR));
						else
#endif
							cb += AlignProp(lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1);
					}

					if (perr->lpMAPIError->lpszComponent)
					{
						perr->lpMAPIError->lpszComponent = PvRelocPv(
								perr->lpMAPIError->lpszComponent, pvBaseOld,
								pvBaseNew );
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
							cb += AlignProp((lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent) + 1)
								* sizeof(WCHAR));
						else
#endif
							cb += AlignProp(lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1);
					}
				}
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (pnew->lpEntryID)
				{
					pnew->lpEntryID = PvRelocPv(pnew->lpEntryID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp((UINT)pnew->cbEntryID);
				}

				if (pnew->lpParentID)
				{
					pnew->lpParentID = PvRelocPv(pnew->lpParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp((UINT)pnew->cbParentID);
				}

				if (pnew->lpszMessageClass)
				{
					pnew->lpszMessageClass = PvRelocPv(pnew->lpszMessageClass,
						pvBaseOld, pvBaseNew);
					if (pnew->ulFlags & MAPI_UNICODE)
						cbT = (lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR);
					else
						cbT = lstrlenA((LPSTR)pnew->lpszMessageClass) + 1;
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->lpEntryID)
				{
					pobj->lpEntryID = PvRelocPv(pobj->lpEntryID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbEntryID);
				}
				if (pobj->lpParentID)
				{
					pobj->lpParentID = PvRelocPv(pobj->lpParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbParentID);
				}
				if (pobj->lpOldID)
				{
					pobj->lpOldID = PvRelocPv(pobj->lpOldID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbOldID);
				}
				if (pobj->lpOldParentID)
				{
					pobj->lpOldParentID = PvRelocPv(pobj->lpOldParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbOldParentID);
				}
				if (pobj->lpPropTagArray)
				{
					pobj->lpPropTagArray = PvRelocPv(pobj->lpPropTagArray,
						pvBaseOld, pvBaseNew);
					cb += offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG);
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;

				Assert (FIsAligned (&ptn->propIndex));
				if (ptn->propIndex.ulPropTag)
				{
					if (sc = ScRelocProps(1, &ptn->propIndex, pvBaseOld,
							pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				Assert (FIsAligned (&ptn->propPrior));
				if (ptn->propPrior.ulPropTag)
				{
					if (sc = ScRelocProps(1, &ptn->propPrior, pvBaseOld,
							pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->row.cValues)
				{
					Assert (FIsAligned (ptn->row.lpProps));
					ptn->row.lpProps = PvRelocPv(ptn->row.lpProps,
						pvBaseOld, pvBaseNew);
					if (sc = ScRelocProps((int)ptn->row.cValues, ptn->row.lpProps,
							pvBaseOld, pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->lpEntryID)
				{
					pstat->lpEntryID = PvRelocPv(pstat->lpEntryID, pvBaseOld,
						pvBaseNew);

					//	Whoa, this is not sufficient to buffer the size of
					//	the entryid.  If the entryid is not aligned, then the
					//	the properties that follow will not be aligned either.
					//
					Assert (FIsAligned (pstat->lpEntryID));
					cb += AlignProp(pstat->cbEntryID);
				}
				if (pstat->cValues)
				{
					pstat->lpPropVals = PvRelocPv(pstat->lpPropVals,
						pvBaseOld, pvBaseNew);
					Assert (FIsAligned (pstat->lpPropVals));
					if (sc = ScRelocProps((int)pstat->cValues, pstat->lpPropVals,
							pvBaseOld, pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScRelocNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScRelocNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = cb;

ret:
	DebugTraceSc(ScRelocNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;
}
#endif // NOTIFICATIONS

STDAPI_(LPSPropValue)
LpValFindProp( ULONG ulPropTag, ULONG cprop, LPSPropValue rgprop)
{
	//	Mutate the property tag to a property ID
	ulPropTag = PROP_ID(ulPropTag);

	while (cprop--)
	{
		Assert( !IsBadReadPtr( rgprop, sizeof(SPropValue)));

		if (PROP_ID(rgprop->ulPropTag) == ulPropTag)
		{
			return rgprop;
		}

		rgprop++;
	}

	// No match was found so return NULL.
	return NULL;
}

/*
 * 	ScCountPropsEx()
 *
 * 	Internal routine that computes the size required
 * 	to hold a given propval array based on specified alignment
 */

SCODE
ScCountPropsEx(int cprop, LPSPropValue rgprop, ULONG ulAlign, ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	ULONG			cb = 0;
	ULONG			cbMV;
	int				iValue;

#define Align(_cb)	((ULONG)( ((DWORD_PTR) ((_cb) + (ulAlign-1))) & ~(((DWORD_PTR) ulAlign-1))))

	// validate parameters

	AssertSz(ulAlign && ulAlign <= ALIGN_RISC,
			 TEXT("invalid alignment value"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	if (   (rgprop && !cprop)
		|| IsBadReadPtr(rgprop, cprop*sizeof(SPropValue)))
	{
		DebugTraceArg(ScCountProps,  TEXT("rgprop fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}

	for (pprop = rgprop; cprop--; ++pprop)
	{
		ULONG	ulID = PROP_ID(pprop->ulPropTag);
		ULONG	ulType = PROP_TYPE(pprop->ulPropTag);

		//	Check for valid PROP_ID
		if (   (ulID == PROP_ID_INVALID)
			|| ((ulType == PT_NULL) && (ulID != PROP_ID_NULL))
			|| ((ulID == PROP_ID_NULL) && (ulType != PT_NULL) && (ulType != PT_ERROR)))
			return MAPI_E_INVALID_PARAMETER;

		//	Check for valid PROP_TYPE and count memory consumed
		cb += sizeof(SPropValue);
		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			case PT_UNSPECIFIED:
			default:
				DebugTrace( TEXT("ScCountProps: Unknown property type %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return MAPI_E_INVALID_PARAMETER;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				break;

			case PT_CLSID:
				if (IsBadReadPtr(pprop->Value.lpguid, sizeof(GUID)))
					goto badProp;
				cb += Align(sizeof(GUID));
				break;

			case PT_BINARY:
				//$Hack:  IsBadReadPtr works funny under Win16.
				//$Hack:  It doesn't handle the case of 0 cb, and
				//$Hack:  non-0 lpb.
				if (pprop->Value.bin.cb && IsBadReadPtr( pprop->Value.bin.lpb
								, (UINT) (pprop->Value.bin.cb)))
					goto badProp;

				cb += Align(pprop->Value.bin.cb);
				break;

			case PT_STRING8:
				if (IsBadStringPtrA(pprop->Value.lpszA, INFINITE))
					goto badProp;
				cb += Align((lstrlenA( pprop->Value.lpszA ) + 1) * sizeof(CHAR));

				break;

			case PT_UNICODE:
#if defined(WIN32) && !defined(MAC)
				//$	No validation code available on Win16
				if (IsBadStringPtrW(pprop->Value.lpszW, INFINITE))
					goto badProp;
#endif
				cb += Align((lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR));
				break;


            //	Note!	MVxxx.cValues may NOT be zero (DCR 2789).

			case PT_MV_I2:
				if (   !(cbMV = pprop->Value.MVi.cValues * sizeof(short int))
					|| IsBadReadPtr(pprop->Value.MVi.lpi, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_LONG:
				if (   !(cbMV = pprop->Value.MVl.cValues * sizeof(LONG))
					|| IsBadReadPtr(pprop->Value.MVl.lpl, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_R4:
				if (   !(cbMV = pprop->Value.MVflt.cValues * sizeof(float))
					|| IsBadReadPtr(pprop->Value.MVflt.lpflt, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_APPTIME:
				if (   !(cbMV = pprop->Value.MVat.cValues * sizeof(double))
					|| IsBadReadPtr(pprop->Value.MVat.lpat, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_DOUBLE:
				if (   !(cbMV = pprop->Value.MVdbl.cValues * sizeof(double))
					|| IsBadReadPtr(pprop->Value.MVdbl.lpdbl, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_CURRENCY:
				if (   !(cbMV = pprop->Value.MVcur.cValues * sizeof(CURRENCY))
					|| IsBadReadPtr(pprop->Value.MVcur.lpcur, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_SYSTIME:
				if (   !(cbMV = pprop->Value.MVft.cValues * sizeof(FILETIME))
					|| IsBadReadPtr(pprop->Value.MVft.lpft, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_CLSID:
				if (   !(cbMV = pprop->Value.MVguid.cValues * sizeof(GUID))
					|| IsBadReadPtr(pprop->Value.MVguid.lpguid, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_I8:
				if (   !(cbMV = pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER))
					|| IsBadReadPtr(pprop->Value.MVli.lpli, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;


			case PT_MV_BINARY:
				if (   !(cbMV = pprop->Value.MVbin.cValues * sizeof(SBinary))
					|| IsBadReadPtr(pprop->Value.MVbin.lpbin, (UINT) cbMV))
					goto badProp;

				Assert(Align(cbMV) == cbMV);
				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++ )
				{
					if (IsBadReadPtr(pprop->Value.MVbin.lpbin[iValue].lpb,
							(UINT)pprop->Value.MVbin.lpbin[iValue].cb))
						goto badProp;
					cb += Align(pprop->Value.MVbin.lpbin[iValue].cb);
				}

				break;

			case PT_MV_STRING8:
				if (   !(cbMV = pprop->Value.MVszA.cValues * sizeof(LPVOID))
					|| IsBadReadPtr(pprop->Value.MVszA.lppszA, (UINT) cbMV))
					goto badProp;

				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++ )
				{
					if (IsBadStringPtrA(pprop->Value.MVszA.lppszA[iValue],
										INFINITE))
						goto badProp;
					cb += lstrlenA(pprop->Value.MVszA.lppszA[iValue]) + 1;
				}

				cb = Align(cb);

				break;

			case PT_MV_UNICODE:
				if (   !(cbMV = pprop->Value.MVszW.cValues * sizeof(LPVOID))
					|| IsBadReadPtr(pprop->Value.MVszW.lppszW, (UINT) cbMV))
					goto badProp;

				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++ )
				{
#if defined(WIN32) && !defined(MAC)
					//$	No validation on Win16
					if (IsBadStringPtrW(pprop->Value.MVszW.lppszW[iValue], INFINITE))
						goto badProp;
#endif
					cb += (lstrlenW(pprop->Value.MVszW.lppszW[iValue]) + 1)
						  * sizeof(WCHAR);
				}

				cb = Align(cb);

				break;
		}
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;

badProp:
	DebugTrace( TEXT("ScCountProps: Unreadable property %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
	return MAPI_E_INVALID_PARAMETER;

#undef Align
}

STDAPI_(SCODE)
ScCountProps(int cprop, LPSPropValue rgprop, ULONG FAR *pcb)
{
#if defined (_AMD64_) || defined(_IA64_)
	return ScCountPropsEx( cprop, rgprop, ALIGN_RISC, pcb );
#else
	return ScCountPropsEx( cprop, rgprop, ALIGN_X86, pcb );
#endif
}

STDAPI_(SCODE)
ScCopyProps(int cprop, LPSPropValue rgprop, LPVOID pvDst, ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	LPSPropValue	ppropDst;
	ULONG			cb;
	ULONG			cbMV;
	LPBYTE			pb;
	UINT			cbT;
	int				iValue;

	// validate parameters

	AssertSz(!cprop || !IsBadReadPtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!cprop || !IsBadWritePtr(pvDst, sizeof(SPropValue) * cprop),
			 TEXT("pvDst fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	cb = cprop * sizeof(SPropValue);
	MemCopy(pvDst, rgprop, (UINT)cb);
	pb = (LPBYTE)pvDst + cb;

	for (pprop = rgprop, ppropDst = pvDst; cprop--; ++pprop, ++ppropDst)
	{
		//	Tricky: common code after the switch increments pb and cb
		//	by the amount copied. If no increment is necessary, the case
		//	uses 'continue' rather than 'break' to exit the switch, thus
		//	skipping the increment -- AND any other code which may be
		//	added after the switch.

		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			default:
				DebugTrace( TEXT("ScCopyProps: Unknown property type %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return E_INVALIDARG;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				continue;	//	nothing to add

			case PT_CLSID:
				ppropDst->Value.lpguid = (LPGUID) pb;
				cbT = sizeof(GUID);
				MemCopy(pb, (LPBYTE) pprop->Value.lpguid, cbT);
				break;

			case PT_BINARY:
				ppropDst->Value.bin.lpb = pb;
				cbT = (UINT)pprop->Value.bin.cb;
				MemCopy(pb, pprop->Value.bin.lpb, cbT);
				break;

			case PT_STRING8:
				ppropDst->Value.lpszA = (LPSTR)pb;
				cbT = lstrlenA( pprop->Value.lpszA ) + 1;
				MemCopy(pb, pprop->Value.lpszA, cbT);
				break;

			case PT_UNICODE:
				ppropDst->Value.lpszW = (LPWSTR)pb;
				cbT = (lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR);
				MemCopy(pb, pprop->Value.lpszW, cbT);
				break;

			case PT_MV_I2:
				ppropDst->Value.MVi.lpi = (short int FAR *)pb;
				cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
				MemCopy(pb, pprop->Value.MVi.lpi, cbT);
				break;

			case PT_MV_LONG:
				ppropDst->Value.MVl.lpl = (LONG FAR *)pb;
				cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
				MemCopy(pb, pprop->Value.MVl.lpl, cbT);
				break;

			case PT_MV_R4:
				ppropDst->Value.MVflt.lpflt = (float FAR *)pb;
				cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
				MemCopy(pb, pprop->Value.MVflt.lpflt, cbT);
				break;

			case PT_MV_APPTIME:
				ppropDst->Value.MVat.lpat = (double FAR *)pb;
				cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
				MemCopy(pb, pprop->Value.MVat.lpat, cbT);
				break;

			case PT_MV_DOUBLE:
				ppropDst->Value.MVdbl.lpdbl = (double FAR *)pb;
				cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
				MemCopy(pb, pprop->Value.MVdbl.lpdbl, cbT);
				break;

			case PT_MV_CURRENCY:
				ppropDst->Value.MVcur.lpcur = (CURRENCY FAR *)pb;
				cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
				MemCopy(pb, pprop->Value.MVcur.lpcur, cbT);
				break;

			case PT_MV_SYSTIME:
				ppropDst->Value.MVft.lpft = (FILETIME FAR *)pb;
				cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
				MemCopy(pb, pprop->Value.MVft.lpft, cbT);
				break;

			case PT_MV_CLSID:
				ppropDst->Value.MVguid.lpguid = (GUID FAR *)pb;
				cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
				MemCopy(pb, pprop->Value.MVguid.lpguid, cbT);
				break;

			case PT_MV_I8:
				ppropDst->Value.MVli.lpli = (LARGE_INTEGER FAR *)pb;
				cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
				MemCopy(pb, pprop->Value.MVli.lpli, cbT);
				break;

			case PT_MV_BINARY:
				ppropDst->Value.MVbin.lpbin = (SBinary *) pb;
				cbMV = pprop->Value.MVbin.cValues * sizeof(SBinary);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVbin.lpbin[iValue].lpb = pb;
					cbT = (UINT)pprop->Value.MVbin.lpbin[iValue].cb;
					ppropDst->Value.MVbin.lpbin[iValue].cb = (ULONG)cbT;
					MemCopy(pb, pprop->Value.MVbin.lpbin[iValue].lpb, cbT);
					cbT = AlignProp(cbT);
					cb += cbT;
					pb += cbT;
				}
				continue;	//	already updated, don't do it again

			case PT_MV_STRING8:
				ppropDst->Value.MVszA.lppszA = (LPSTR *) pb;
				cbMV = pprop->Value.MVszA.cValues * sizeof(LPSTR);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVszA.lppszA[iValue] = (LPSTR)pb;
					cbT = lstrlenA(pprop->Value.MVszA.lppszA[iValue]) + 1;
					MemCopy(pb, pprop->Value.MVszA.lppszA[iValue], cbT);
					pb += cbT;
					cb += cbT;
				}
				cbT = (UINT)AlignProp(cb);
				pb += cbT - cb;
				cb  = cbT;
				continue;	//	already updated, don't do it again

			case PT_MV_UNICODE:
				ppropDst->Value.MVszW.lppszW = (LPWSTR *) pb;
				cbMV = pprop->Value.MVszW.cValues * sizeof(LPWSTR);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVszW.lppszW[iValue] = (LPWSTR)pb;
					cbT = (lstrlenW(pprop->Value.MVszW.lppszW[iValue]) + 1)
						* sizeof(WCHAR);
					MemCopy(pb, pprop->Value.MVszW.lppszW[iValue], cbT);
					pb += cbT;
					cb += cbT;
				}
				cbT = (UINT)AlignProp(cb);
				pb += cbT - cb;
				cb  = cbT;
				continue;	//	already updated, don't do it again
		}

		//	Advance pointer and total count by the amount copied
		cbT = AlignProp(cbT);
		pb += cbT;
		cb += cbT;
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;
}

#ifdef NOTIFICATIONS
STDAPI_(SCODE)
ScRelocProps(	int cprop,
				LPSPropValue rgprop,
				LPVOID pvBaseOld,
				LPVOID pvBaseNew,
				ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	ULONG			cb;
	UINT			cbT;
	LPVOID			pvT;
	int				iValue;
	BOOL			fBaseNewValid = !IsBadReadPtr (pvBaseNew, sizeof (LPVOID));

	// validate parameters

	AssertSz(!cprop || !IsBadWritePtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	// The old behavior of this code assumed that pvBaseNew was a usable
	// pointer and that there would be no relocation to or from an unusable
	// pointer. We've changed this so that you may relocate to or from an
	// unusable pointer -- but logic to figure out whether to use the
	// original or new pointer to fixup internal pointers was added.
	// What we mean by this is that things like strlens and mv prop arrays
	// need to be computed based on where the data ** CURRENTLY ** lives.
	// The old rules allowed us to assume that the NEW location was always
	// the right place. The new rules make us figure it out based on the
	// validity of the two pointers pvBaseNew/Old, that are passed in.
	//
	// In order to preserve the old behavior, we try to use the new pointer
	// (the one that was always used before) as the basis for internal
	// pointer fixup. If it is bad (for example if we are relocating from
	// something to zero), we will use the old pointer.
	//
	// A new wrinkle in the behavior of this code is a return of
	// MAPI_E_INVALID_PARAMETER if both addresses appear invalid. This is
	// to help protect this code for the mv or strlen case (though all
	// other cases would have worked OK).

	if (!fBaseNewValid && IsBadReadPtr (pvBaseOld, sizeof (LPVOID)))
	{
		DebugTrace ( TEXT("pvBaseOld and pvBaseNew failed address check"));
		DebugTraceSc (ScRelocProps, MAPI_E_INVALID_PARAMETER);
		return MAPI_E_INVALID_PARAMETER;
	}

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	cb = cprop * sizeof(SPropValue);

	for (pprop = rgprop; cprop--; ++pprop)
	{
		//	Tricky: common code after the switch increments cb.
		//	If no increment is necessary, the case
		//	uses 'continue' rather than 'break' to exit the switch, thus
		//	skipping the increment -- AND any other code which may be
		//	added after the switch.

		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			default:
				DebugTrace(	 TEXT("ScRelocProps: Unknown property type %s")
							 TEXT(" (index %d)\n"),
							SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return E_INVALIDARG;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				continue;	//	nothing to add or relocate

			case PT_CLSID:
				pprop->Value.lpguid = PvRelocPv(pprop->Value.lpguid,
					pvBaseOld, pvBaseNew);
				cbT = sizeof(GUID);
				break;

			case PT_BINARY:
				pprop->Value.bin.lpb = PvRelocPv(pprop->Value.bin.lpb,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.bin.cb;
				break;

			case PT_STRING8:

				// If we're assuming that the old pointer is OK (this
				// means that we determined that the new one is not OK),
				// save the current lpszA value in a temp variable. After
				// the relocation, if the reverse is true, we'll put the
				// relocated lpszA value into the temp variable.
				//
				// We then use the strlen of the string we hope the temp
				// variable is pointing to, in order to compute the amount
				// of space in the blob which is occupied by the string.

				if (!fBaseNewValid)
					pvT = pprop->Value.lpszA;

				pprop->Value.lpszA = PvRelocPv(pprop->Value.lpszA,
					pvBaseOld, pvBaseNew);

				if (fBaseNewValid)
					pvT = pprop->Value.lpszA;

				cbT = lstrlenA((LPSTR)pvT) + 1;

				break;

			case PT_UNICODE:

				// If we're assuming that the old pointer is OK (this
				// means that we determined that the new one is not OK),
				// save the current lpszW value in a temp variable. After
				// the relocation, if the reverse is true, we'll put the
				// relocated lpszW value into the temp variable.
				//
				// We then use the strlen of the string we hope the temp
				// variable is pointing to, in order to compute the amount
				// of space in the blob which is occupied by the string.

				if (!fBaseNewValid)
					pvT = pprop->Value.lpszW;

				pprop->Value.lpszW = PvRelocPv(pprop->Value.lpszW,
					pvBaseOld, pvBaseNew);

				if (fBaseNewValid)
					pvT = pprop->Value.lpszW;

				cbT = (lstrlenW((LPWSTR)pvT) + 1) * sizeof(WCHAR);

				break;

			case PT_MV_I2:
				pprop->Value.MVi.lpi = PvRelocPv(pprop->Value.MVi.lpi,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
				break;

			case PT_MV_LONG:
				pprop->Value.MVl.lpl = PvRelocPv(pprop->Value.MVl.lpl,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
				break;

			case PT_MV_R4:
				pprop->Value.MVflt.lpflt = PvRelocPv(pprop->Value.MVflt.lpflt,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
				break;

			case PT_MV_APPTIME:
				pprop->Value.MVat.lpat = PvRelocPv(pprop->Value.MVat.lpat,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
				break;

			case PT_MV_DOUBLE:
				pprop->Value.MVdbl.lpdbl = PvRelocPv(pprop->Value.MVdbl.lpdbl,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
				break;

			case PT_MV_CURRENCY:
				pprop->Value.MVcur.lpcur = PvRelocPv(pprop->Value.MVcur.lpcur,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
				break;

			case PT_MV_SYSTIME:
				pprop->Value.MVft.lpft = PvRelocPv(pprop->Value.MVft.lpft,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
				break;

			case PT_MV_CLSID:
				pprop->Value.MVguid.lpguid = PvRelocPv(pprop->Value.MVguid.lpguid,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
				break;

			case PT_MV_I8:
				pprop->Value.MVli.lpli = PvRelocPv(pprop->Value.MVli.lpli,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
				break;

			case PT_MV_BINARY:
			{
				LPSBinary lpsbT = pprop->Value.MVbin.lpbin;

				pprop->Value.MVbin.lpbin = PvRelocPv(lpsbT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVbin array.

				if (fBaseNewValid)
					lpsbT = pprop->Value.MVbin.lpbin;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++)
				{
					lpsbT[iValue].lpb = PvRelocPv(lpsbT[iValue].lpb, pvBaseOld, pvBaseNew);
					cb += (UINT)AlignProp(lpsbT[iValue].cb);
				}
				continue;	//	already updated, don't do it again
			}

			case PT_MV_STRING8:
			{
				LPSTR * lppszT = pprop->Value.MVszA.lppszA;

				pprop->Value.MVszA.lppszA = PvRelocPv(lppszT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVszA array.

				if (fBaseNewValid)
					   lppszT = pprop->Value.MVszA.lppszA;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++)
				{
					// If we're assuming that the old pointer is OK (this
					// means that we determined that the new one is not OK),
					// save the current lppszT value in a temp variable. After
					// the relocation, if the reverse is true, we'll put the
					// relocated lppszT value into the temp variable.
					//
					// We then use the strlen of the string we hope the temp
					// variable is pointing to, in order to compute the amount
					// of space in the blob which is occupied by the string.

					if (!fBaseNewValid)
						pvT = lppszT[iValue];

					lppszT[iValue] = PvRelocPv(lppszT[iValue], pvBaseOld, pvBaseNew);

					if (fBaseNewValid)
						pvT = lppszT[iValue];

					cb += lstrlenA((LPSTR)pvT) + 1;
				}
				cb = AlignProp(cb);
				continue;	//	already updated, don't do it again
			}

			case PT_MV_UNICODE:
			{
				LPWSTR * lppszwT = pprop->Value.MVszW.lppszW;

				pprop->Value.MVszW.lppszW = PvRelocPv(lppszwT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVszW array.

				if (fBaseNewValid)
					   lppszwT = pprop->Value.MVszW.lppszW;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++)
				{
					// If we're assuming that the old pointer is OK (this
					// means that we determined that the new one is not OK),
					// save the current lppszwT value in a temp variable. After
					// the relocation, if the reverse is true, we'll put the
					// relocated lppszwT value into the temp variable.
					//
					// We then use the strlen of the string we hope the temp
					// variable is pointing to, in order to compute the amount
					// of space in the blob which is occupied by the string.

					if (!fBaseNewValid)
						pvT = lppszwT[iValue];

					lppszwT[iValue] = PvRelocPv(lppszwT[iValue], pvBaseOld, pvBaseNew);

					if (fBaseNewValid)
						pvT = lppszwT[iValue];

					cb += (lstrlenW(lppszwT[iValue]) + 1) * sizeof(WCHAR);
				}
				cb = AlignProp(cb);
				continue;	//	already updated, don't do it again
			}
		}

		//	Advance total count
		cb += AlignProp(cbT);
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;
}
#endif

/*
 *	Wrapper function to just duplicate a property value array
 *	into a single block of MAPI memory.
 */
STDAPI_(SCODE)
ScDupPropset(int cprop, LPSPropValue rgprop, LPALLOCATEBUFFER palloc,
	LPSPropValue FAR *prgprop)
{
	ULONG		cb;
	SCODE		sc;

	// validate parameters

	AssertSz(!cprop || !IsBadReadPtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!IsBadCodePtr((FARPROC)palloc),  TEXT("palloc fails address check"));

	AssertSz(!IsBadWritePtr(prgprop, sizeof(LPSPropValue)),
			 TEXT("prgprop fails address check"));

	//	Find out how much memory we need
	if (sc = ScCountProps(cprop, rgprop, &cb))
		goto ret;
	//	Obtain memory
	if (sc = (*palloc)(cb, (LPVOID *)prgprop))
		goto ret;
	//	Copy the properties
	if (sc = ScCopyProps(cprop, rgprop, *prgprop, &cb))
		goto ret;

ret:
	DebugTraceSc(ScDupPropset, sc);
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wab16.h ===
/*****************************************************************************\
*                                                                             *
* Wab16.h                                                                  *
*                                                                             *
\*****************************************************************************/

#ifndef __WAB16_H__
#define __WAB16_H__

#ifdef __cplusplus
extern "C"{
#endif

/*****************************************************************************\
*                                                                             *
*  From windowsx.h(INC32)
*                                                                             *
\*****************************************************************************/
typedef WCHAR  PWCHAR;
#define END_INTERFACE

// From capi.h
#define      WTD_UI_ALL              1
#define      WTD_UI_NONE             2
#define      WTD_UI_NOBAD            3
#define      WTD_UI_NOGOOD           4
#define      WTD_REVOKE_NONE         0x00000000
#define      WTD_REVOKE_WHOLECHAIN   0x00000001

#pragma pack(8)

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional
#                       define      WTD_STATEACTION_IGNORE  0x00000000
#                       define      WTD_STATEACTION_VERIFY  0x00000001
#                       define      WTD_STATEACTION_CLOSE   0x00000002

    HANDLE          hWVTStateData;                      // optional

    WCHAR           *pwszURLReference;          // optional: currently used to determine zone.

} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath
      
} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD               dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR             pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR             pcwszMemberTag;         // required: tag to member in Catalog
    LPCWSTR             pcwszMemberFilePath;    // required: path/name to member file
    HANDLE              hMemberFile;            // optional: open handle to pcwszMemberFilePath

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID                gSubject;               // SIP to load

    LPCWSTR             pcwszDisplayName;       // display name of object

    DWORD               cbMemObject;
    BYTE                *pbMemObject;

    DWORD               cbMemSignedMsg;
    BYTE                *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR             pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO    *psSignerInfo;

    DWORD               chStores;               // number of stores in pahStores
    HCERTSTORE          *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR             pcwszDisplayName;       // display name

    CERT_CONTEXT        *psCertContext;

    DWORD               chStores;               // number of stores in pahStores
    HCERTSTORE          *pahStores;             // array of stores to add to internal list

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#pragma pack()

// End of Capi.h

const CLSID CLSID_HTMLDocument;

#ifdef __cplusplus
}
#endif

#endif // !__WAB16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink
#define USES_IID_IWABExtInit

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include "_apipch.h"

#include <imnxport.h>       // required for transports for syncing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wab16.c ===
#include "_apipch.h"

/*****************************************************************************\
*                                                                             *
*  Unknown local functions in wab\wabapi
*                                                                             *
\*****************************************************************************/
int
AlertIdsCtx( HWND hwnd,
             HINSTANCE hinst,
             UINT idsMsg,
             LPSTR szComponent,
             ULONG ulContext,
             ULONG ulLow,
             UINT fuStyle)
{
    return 0;
}

int
AlertSzCtx( HWND hwnd,
            LPSTR szMsg,
            LPSTR szComponent,
            ULONG ulContext,
            ULONG ulLow,
            UINT fuStyle)
{
    return 0;
}

LPVOID
PvGetInstanceGlobals(void)
{
    return NULL;
}

LPVOID
PvGetInstanceGlobalsInt(LPInstList lpInstListX)
{
    return NULL;
}

SCODE
ScSetInstanceGlobalsInt(LPVOID pv, LPInstList lpInstListX)
{
    return NULL;
}

SCODE
ScSetInstanceGlobals(LPVOID pv)
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabimprt.c ===
/*
-
-
-   WABImprt.c - Contains code for importing another WAB into the currently opened WAB
*
*
*/
#include "_apipch.h"

/*
-
-   PromptForWABFile 
*
*   Shows the OpenFileName dialog to prompt for the WAB file to import
*   <TBD>:Cache the last imported WAB file in the registry
*
*   bOpen - if TRUE, calls GetOpenFileName; if false, calls GetSaveFileName
*/
BOOL PromptForWABFile(HWND hWnd, LPTSTR szFile, BOOL bOpen)
{
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(idsWABImportString, TEXT("*.WAB"),0,NULL,0,NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    TCHAR szTitle[MAX_PATH] =  TEXT("");
    BOOL bRet = FALSE;

    LoadString( hinstMapiX, bOpen ? idsSelectWABToImport : idsSelectWABToExport, 
                szTitle, CharSizeOf(szTitle));
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt =  TEXT("wab");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if(bOpen)
        bRet = GetOpenFileName(&ofn);
    else

        bRet = GetSaveFileName(&ofn);

    if(bRet)
        lstrcpy(szFile, szFileName);

    LocalFreeAndNull(&lpFilter);

    return bRet;
}


/*
- MapOldNamedPropsToNewNamedProps
-
*   Takes all the props from the wab being imported and finds or creates appropriate
*   named props from the store being imported into
*   *lpulOldNP and *lpulNewNP are LocalAlloced and should be freed by caller

typedef struct _NamedProp
{
    ULONG   ulPropTag;  // Contains the proptag for this named prop
    LPTSTR  lpsz;       // Contains the string for this named prop
} NAMED_PROP, * LPNAMED_PROP;
typedef struct _tagGuidNamedProps
{
    LPGUID lpGUID;  // Application GUID for which these named props are
    ULONG cValues;  // Number of entries in the lpmn array
    LPNAMED_PROP lpnm;  // Array of Named Props for this Guid.
} GUID_NAMED_PROPS, * LPGUID_NAMED_PROPS;

*/
HRESULT MapOldNamedPropsToNewNamedProps(HANDLE hPropertyStore, LPADRBOOK lpAdrBook, ULONG * lpulPropCount,
                                        LPULONG * lppulOldNP, LPULONG * lppulNewNP)
{
    ULONG ulcGUIDCount = 0,i=0,j=0,ulCount=0;
    LPGUID_NAMED_PROPS lpgnp = NULL;
    HRESULT hr = S_OK;
    LPULONG lpulOldNP = NULL, lpulNewNP = NULL;
    ULONG ulcOldNPCount = 0;
    LPSPropTagArray lpta = NULL;
    LPMAPINAMEID * lppPropNames = NULL;
    SCODE sc ;

    if(HR_FAILED(hr = GetNamedPropsFromPropStore(hPropertyStore, &ulcGUIDCount, &lpgnp)))
        goto exit;

    if(ulcGUIDCount)
    {
        for(i=0;i<ulcGUIDCount;i++)
            ulcOldNPCount += lpgnp[i].cValues;
    
        lpulOldNP = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulcOldNPCount);
        lpulNewNP = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulcOldNPCount);

        if(!lpulOldNP || !lpulNewNP)
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                lpulOldNP[ulCount++] = lpgnp[i].lpnm[j].ulPropTag;
            }
        }

        sc = MAPIAllocateBuffer(sizeof(LPMAPINAMEID) * ulcOldNPCount, (LPVOID *) &lppPropNames);
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                if(sc = MAPIAllocateMore(sizeof(MAPINAMEID), lppPropNames, &(lppPropNames[ulCount])))
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }
                lppPropNames[ulCount]->lpguid = lpgnp[i].lpGUID;
                lppPropNames[ulCount]->ulKind = MNID_STRING;

                {
                    int nSize = lstrlen(lpgnp[i].lpnm[j].lpsz);
                    if(!nSize)
                        continue;
                    else
                    {
                        nSize++;
                        if(sc = MAPIAllocateMore(sizeof(WCHAR)*nSize, lppPropNames, &(lppPropNames[ulCount]->Kind.lpwstrName)))
                        {
                            hr = ResultFromScode(sc);
                            goto exit;
                        }
                    }
                    lstrcpy(lppPropNames[ulCount]->Kind.lpwstrName,lpgnp[i].lpnm[j].lpsz);
                    ulCount++;
                }
            }
        }

        // [PaulHi] 3/25/99  Use the actual count of the lppPropNames array, or we will walk off
        // into unknown memory and crash.
        ulcOldNPCount = ulCount;
        hr = lpAdrBook->lpVtbl->GetIDsFromNames(lpAdrBook, ulcOldNPCount, lppPropNames, MAPI_CREATE, &lpta);
        if(HR_FAILED(hr))
            goto exit;

        // Note that of the tags that are returned, we don't know the tag type .. this we will have
        // to infer based on the original tags when we see them being used

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                lpulNewNP[ulCount++] = lpta->aulPropTag[ulCount];
            }
        }
    }

    *lppulNewNP = lpulNewNP;
    *lppulOldNP = lpulOldNP;
    *lpulPropCount = ulcOldNPCount;

    hr = S_OK;
exit:

    if(lpta)
        MAPIFreeBuffer(lpta);

    if(lppPropNames)
        MAPIFreeBuffer(lppPropNames);

    if(HR_FAILED(hr))
    {
        LocalFreeAndNull(&lpulNewNP);
        LocalFreeAndNull(&lpulOldNP);
    }

    FreeGuidnamedprops(ulcGUIDCount, lpgnp);
    
    return hr;
}

/***************************************************************************
****************************************************************************/
void ChangeOldNamedPropsToNewNamedProps(ULONG ulcProps, LPSPropValue lpProps, 
                                           ULONG ulcNPCount, ULONG * lpulOldNP, ULONG *lpulNewNP)
{
    ULONG i,j;
    for(i=0;i<ulcProps;i++)
    {
        ULONG ulPropId = PROP_ID(lpProps[i].ulPropTag);
        if(ulPropId >= 0x8000) //this is a named prop
        {
            ULONG ulType = PROP_TYPE(lpProps[i].ulPropTag);
            for(j=0;j<ulcNPCount;j++)
            {
                if(ulPropId == PROP_ID(lpulOldNP[j]))
                {
                    lpProps[i].ulPropTag = CHANGE_PROP_TYPE(lpulNewNP[j], ulType);
                    break;
                }
            }
        }
    }
    return;
}


enum
{
    eidOld=0,
    eidTemp,
    eidNew,
    eidMax
};

void SetTempSBinary(LPSBinary lpsbTemp, LPSBinary lpsbOld)
{
    DWORD dwTemp = 0;
    if(lpsbOld->cb != SIZEOF_WAB_ENTRYID)
    {
        // perhaps this is a Folder EID in it's formal proper form ..
        // We should try to reduce it to a DWORD...
        // this may be a WAB container .. reset the entryid to a WAB entryid
        if(WAB_CONTAINER == IsWABEntryID(lpsbTemp->cb, (LPENTRYID)lpsbTemp->lpb, 
                                        NULL,NULL,NULL,NULL,NULL))
        {
            SBinary sbEID = {0};
            IsWABEntryID(lpsbTemp->cb, (LPENTRYID)lpsbTemp->lpb, 
                             (LPVOID*)&sbEID.lpb,(LPVOID*)&sbEID.cb,NULL,NULL,NULL);
            if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                CopyMemory(&dwTemp, sbEID.lpb, sbEID.cb);
            else return;
        }
    }
    else
        CopyMemory(&dwTemp, lpsbOld->lpb, lpsbOld->cb);
    dwTemp = 0xFFFFFFFF - dwTemp;
    SetSBinary(lpsbTemp, lpsbOld->cb, (LPBYTE)&dwTemp);
}

/*
- GetNewEID
-
*   Finds a new entryid or a temp entryid for a given old entryid
*   When bTemp is true, only looks in the temp entryid column 
*/
LPSBinary GetNewEID(LPSBinary lpsbOldEID, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    DWORD dw = 0;

    while(lppsbEIDs[eidOld][dw].cb && dw < dwCount)
    {
        if( lppsbEIDs[eidOld][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidOld][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            if(bTemp)
                return lpsbOldEID;

            if(lppsbEIDs[eidNew][dw].cb)
                return &(lppsbEIDs[eidNew][dw]);
            else if(lppsbEIDs[eidTemp][dw].cb)
                return &(lppsbEIDs[eidTemp][dw]);
            else
                return lpsbOldEID;
        }
        else 
        if( lppsbEIDs[eidTemp][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidTemp][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            if(lppsbEIDs[eidNew][dw].cb)
                return &(lppsbEIDs[eidNew][dw]);
            else
                return lpsbOldEID;
        }
        dw++;
    }
    // if we reached here, then we haven't cached an appropriate temp or new eid for the current one
    // so add the current one to this table
    if(dw<dwCount && !lppsbEIDs[eidOld][dw].cb)
    {
        SetSBinary(&(lppsbEIDs[eidOld][dw]), lpsbOldEID->cb, lpsbOldEID->lpb);
        SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
        return(&(lppsbEIDs[eidTemp][dw]));
    }
    return lpsbOldEID;
}

/*
-   SetNewEID
-
*
*/
void SetNewEID(LPSBinary lpsbOldEID, LPSBinary lpsbNewEID, DWORD dwCount, LPSBinary * lppsbEIDs)
{
    DWORD dw = 0;

    while(lppsbEIDs[eidOld][dw].cb && dw < dwCount)
    {
        if( lppsbEIDs[eidOld][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidOld][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            SetSBinary(&(lppsbEIDs[eidNew][dw]), lpsbNewEID->cb, lpsbNewEID->lpb);
            if(!lppsbEIDs[eidTemp][dw].cb)
                SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
            return;
        }
        dw++;
    }
    if(dw<dwCount && !lppsbEIDs[eidOld][dw].cb)
    {
        SetSBinary(&lppsbEIDs[eidOld][dw], lpsbOldEID->cb, lpsbOldEID->lpb);
        SetSBinary(&lppsbEIDs[eidNew][dw], lpsbNewEID->cb, lpsbNewEID->lpb);
        SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
    }
}

/*
-
-   Replace EID
*
*/
void ReplaceEID(LPSBinary lpsb, LPSPropValue lpProps, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    LPSBinary lpsbOldEID = lpsb;
    LPSBinary lpsbNewEID = GetNewEID(lpsbOldEID, dwCount, lppsbEIDs, bTemp);

    if(lpsbOldEID == lpsbNewEID)
        return;

    if(lpsbOldEID->cb != lpsbNewEID->cb)
    {
        if(!bTemp)
        {
            // this is a prop array read from a WAB file using readrecord
            LocalFree(lpsbOldEID->lpb);
            lpsbOldEID->lpb = LocalAlloc(LMEM_ZEROINIT, lpsbNewEID->cb);
        }
        else
        {
            // this was called from GetProps and is a MAPI Array
            lpsbOldEID->lpb = NULL;
            MAPIAllocateMore(lpsbNewEID->cb, lpProps, (LPVOID *) (&(lpsbOldEID->lpb)));
        }
    }
    if(lpsbOldEID->lpb)
    {
        lpsbOldEID->cb = lpsbNewEID->cb;
        CopyMemory(lpsbOldEID->lpb, lpsbNewEID->lpb, lpsbNewEID->cb);
    }
}

/*
- UpdateEntryIDReferences
-
*   Updates entryids in the given prop array
*
*   The first time the function is called, btemp is FALSE and we replace all EIDs in the
*   array with temp or new eids
*   The second time this function is called, bTemp is TRUE and we replace all temp EIDS in
*   the array with the new EIDs
*
*/
void UpdateEntryIDReferences(ULONG ulcProps, LPSPropValue lpProps, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    ULONG i, j, k, l;

    ULONG ulEntryIDTags[] = 
    {
        PR_WAB_DL_ENTRIES,
        PR_WAB_FOLDER_PARENT,
        PR_WAB_FOLDER_PARENT_OLDPROP,
        PR_WAB_USER_SUBFOLDERS,
    };
    DWORD dwEntryIDTagCount = 4; //keep in sync with above array
    

    for(i=0;i<ulcProps;i++)
    {
        ULONG ulType = PROP_TYPE(lpProps[i].ulPropTag);
        // Props containing entryids will be of Binary or MV_Binary type
        if(ulType == PT_BINARY || ulType == PT_MV_BINARY)
        {
            // Check against the known set of props dealing with entryids
            for(j=0;j<dwEntryIDTagCount;j++)
            {
                if(lpProps[i].ulPropTag == ulEntryIDTags[j])
                {
                    LPSBinary lpsbOldEID = NULL, lpsbNewEID = NULL;

                    switch(ulType)
                    {
                    case PT_BINARY:
                        //if(lpProps[i].Value.bin.cb == SIZEOF_WAB_ENTRYID)
                        {
                            ReplaceEID(&(lpProps[i].Value.bin), lpProps, dwCount, lppsbEIDs, bTemp);
                        }
                        break;
                    case PT_MV_BINARY:
                        for(k=0;k<lpProps[i].Value.MVbin.cValues;k++)
                        {
                            //if(lpProps[i].Value.MVbin.lpbin[k].cb == SIZEOF_WAB_ENTRYID)
                            {
                                ReplaceEID(&(lpProps[i].Value.MVbin.lpbin[k]), lpProps, dwCount, lppsbEIDs, bTemp);
                            }
                        }
                        break;
                    }
                    break;
                }
            }
        }
    }
}



/***************************************************************************

    Name      : HrImportWABFile

    Purpose   : Merges an external WAB file with the current on

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object
                ulFlags = 0 or MAPI_DIALOG - MAPI_DIALOG means show msgs and progress bar
                lpszFileName - file name to open, if 0 prompts with GetOpenFileName dialog
    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpAdrBook, ULONG ulFlags, LPTSTR lpszFileName)
{
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    BOOL bFoldersImported = FALSE;
    HRESULT hr = E_FAIL;
    HRESULT hrDeferred = S_OK;
    TCHAR szWABFile[MAX_PATH+1] = TEXT("");
    TCHAR szFile[MAX_PATH+1] = TEXT(""), szPath[MAX_PATH] = TEXT("");
    HANDLE hPropertyStore = NULL;
    DWORD dwWABEntryCount = 0;
    LPSBinary * lppsbWABEIDs = NULL;
    ULONG ulcNPCount = 0;
    LPULONG lpulOldNP = NULL,lpulNewNP = NULL;
    ULONG i,j,k,n;
    BOOL bShowUI = (hWnd && (ulFlags & MAPI_DIALOG));
    
    ULONG rgObj[] = { MAPI_MAILUSER, MAPI_DISTLIST, MAPI_ABCONT };
#ifdef IMPORT_FOLDERS
#define ulrgObjMax 3
#else
#define ulrgObjMax 2
#endif

    SBinary sbPAB = {0};

    SPropertyRestriction PropRes = {0};
    //HCURSOR hOldCur = NULL;
    SPropValue sp = {0};
    ULONG ulcOldProps = 0;
    LPSPropValue lpOldProps = NULL;
    LPMAPIPROP lpObject = NULL;

    ULONG ulEIDCount = 0;
    LPSBinary rgsbEntryIDs = NULL;

    TCHAR szBuf[MAX_UI_STR];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(lpszFileName && lstrlen(lpszFileName))
        lstrcpy(szWABFile, lpszFileName);
    else
    if (!PromptForWABFile(hWnd, szWABFile, TRUE))
    {
        hr = MAPI_E_USER_CANCEL;   
        goto exit;
    }

    //hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // when importing old format files, there is always a possibility that the file data may get
    // munged when opening the file ..
    // therefore, before we attempt to import it, we will try to make a copy of the file
    if(GetFileAttributes(szWABFile) == 0xFFFFFFFF)
        goto exit;
    if(!GetTempPath(CharSizeOf(szPath), szPath))
        goto exit;
    if(!GetTempFileName(szPath, TEXT("WAB"), 0, szFile))
        goto exit;
    if(!CopyFile(szWABFile, szFile, FALSE))
        goto exit;
    if(GetFileAttributes(szFile) == 0xFFFFFFFF)
        goto exit;

    // First let's open this file
    hr = OpenPropertyStore(szFile, AB_OPEN_EXISTING | AB_DONT_RESTORE | AB_IGNORE_OUTLOOK, hWnd, &hPropertyStore);

    if(HR_FAILED(hr) || (!hPropertyStore))
    {
        //if(bShowUI)
        //    ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFile);
        goto exit;
    }

    // get a count of how many entries exist in this new .wab file
    if(!(dwWABEntryCount = GetWABFileEntryCount(hPropertyStore)))
    {
        hr = S_OK;
        goto exit;
    }

    if(bShowUI)
    {
        EnableWindow(hWnd, FALSE);
        CreateShowAbortDialog(hWnd, idsImporting, IDI_ICON_IMPORT, dwWABEntryCount*2 + 1, 0);
    }

    if(lppsbWABEIDs = LocalAlloc(LMEM_ZEROINIT, sizeof(LPSBinary) * eidMax))
    {
        for(i=0;i<eidMax;i++)
        {
            lppsbWABEIDs [i] = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary) * dwWABEntryCount);
            if(!lppsbWABEIDs [i])
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
    }
    else
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }


    // Before we start doing anything we need to get the appropriate named properties
    // from the importee so that we can correctly map them to stuff in the new store ..
    // By calling GetIDsFromNames, all the old GUIDs etc will automatically be migrated into the
    // final file from the importee
    if(HR_FAILED(hr = MapOldNamedPropsToNewNamedProps(hPropertyStore, lpAdrBook, &ulcNPCount, 
                                                        &lpulOldNP, &lpulNewNP)))
        goto exit;

    if(HR_FAILED(lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &sbPAB.cb, (LPENTRYID *)&sbPAB.lpb)))
        goto exit;

    for(n=0;n<ulrgObjMax;n++) 
    {
        // Next we want to get a list of all the contacts in the WAB ...
        PropRes.ulPropTag = PR_OBJECT_TYPE;
        PropRes.relop = RELOP_EQ;
        sp.ulPropTag = PR_OBJECT_TYPE;
        sp.Value.l = rgObj[n];
        PropRes.lpProp = &sp;

        // skip doing folders for Outlook
        if(pt_bIsWABOpenExSession && rgObj[n]==MAPI_ABCONT)
            continue;

        if(HR_FAILED(hr = FindRecords(hPropertyStore, NULL, AB_IGNORE_OUTLOOK, TRUE, &PropRes, &ulEIDCount, &rgsbEntryIDs)))
            goto exit;

        if(bTimeToAbort())
        {
            hr = MAPI_E_USER_CANCEL;
            goto exit;
        }

        // Now that we have a list of all contacts we want to open them one by one and
        //  - change named props to new named props
        //  - tag all existing entryid properties in it
        //  - remove existing entryid from it
        //  - do a save changes with create merge
        //  - get the new entryid and cache it
        //
        for(i=0;i<ulEIDCount;i++)
        {
            SBinary sbOldEID = {0};
            SBinary sbNewEID = {0};
            BOOL bIsFolderMember = FALSE;

            if(bTimeToAbort())
            {
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }

            if(HR_FAILED(hr = ReadRecord(hPropertyStore, &rgsbEntryIDs[i], AB_IGNORE_OUTLOOK, &ulcOldProps, &lpOldProps)))
                continue; // ignore errors

            // just make sure no container has snuck in here
            if(rgObj[n] != MAPI_ABCONT)
            {
                for(j=0;j<ulcOldProps;j++)
                {
                    if( lpOldProps[j].ulPropTag == PR_OBJECT_TYPE && 
                        lpOldProps[j].Value.l == MAPI_ABCONT)
                    {
                        goto endofthisloop;
                    }
                }
            }

            for(j=0;j<ulcOldProps;j++)
            {
                if(lpOldProps[j].ulPropTag == PR_DISPLAY_NAME)
                {
                    if(bShowUI)
                        SetPrintDialogMsg(0, idsImportingName, lpOldProps[j].Value.LPSZ);
                }
                if(lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP && PR_WAB_FOLDER_PARENT)
                    lpOldProps[j].ulPropTag = PR_WAB_FOLDER_PARENT;

                if(lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT)
                {
#ifdef IMPORT_FOLDERS
                    bIsFolderMember = TRUE;
#else
                    // remove any folder parent info on this entry
                    ULONG k = 0;
                    lpOldProps[j].ulPropTag = PR_NULL;
                    for(k=0;k<lpOldProps[j].Value.MVbin.cValues;k++)
                        LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.MVbin.lpbin[k].lpb)));
                    LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.MVbin.lpbin)));
#endif
                }
            }

            // Scan these props and change any old named props in them
            ChangeOldNamedPropsToNewNamedProps(ulcOldProps, lpOldProps, ulcNPCount, lpulOldNP, lpulNewNP);

            // Update any references to entryids in any of the properties
            UpdateEntryIDReferences(ulcOldProps, lpOldProps, dwWABEntryCount, lppsbWABEIDs, FALSE);

            // negate the old eid after caching it
            for(j=0;j<ulcOldProps;j++)
            {
                if(lpOldProps[j].ulPropTag == PR_ENTRYID)
                {
                    Assert(lpOldProps[j].Value.bin.cb == SIZEOF_WAB_ENTRYID);
                    SetSBinary(&sbOldEID, lpOldProps[j].Value.bin.cb, lpOldProps[j].Value.bin.lpb);
                    LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.bin.lpb)));
                    lpOldProps[j].Value.bin.cb = 0;
                    lpOldProps[j].ulPropTag = PR_NULL;
                    break;
                }
            }

#ifdef IMPORT_FOLDERS
            // if these are containers, they may have ProfileIDs in them .. negate the profile ids
            // to some random number so they don't cause problems with the existing profile ids in this contact
            if(rgObj[n]==MAPI_ABCONT)
            {
                bFoldersImported = TRUE;
                bIsFolderMember = FALSE; //folders shouldnt end up nested.. all should be at top level
                for(j=0;j<ulcOldProps;j++)
                {
                    if( lpOldProps[j].ulPropTag == PR_WAB_USER_PROFILEID )
                    {
                        // This is some kind of user-folder .. well we don't know how this relates
                        // to the users of the WAB into which this is being imported, so we hide this value
                        lpOldProps[j].ulPropTag = PR_NULL;
                        LocalFreeAndNull(&(lpOldProps[j].Value.LPSZ));
                        // If we were importing a User Folder, and there is no current user, this folder
                        // is going to get lost .. so instead we set the SHARED flag to true on it and it
                        // will show up under Shared Contacts
                        if(!bIsThereACurrentUser(lpIAB) && bDoesThisWABHaveAnyUsers(lpIAB))
                        {
                            lpOldProps[j].ulPropTag = PR_WAB_SHAREDFOLDER;
                            lpOldProps[j].Value.l = FOLDER_SHARED;
                        }
                    }
                    else
                    if( lpOldProps[j].ulPropTag == PR_WAB_FOLDEROWNER) // folder-owner info is meaningless here ..
                    {
                        lpOldProps[j].ulPropTag = PR_NULL;
                        LocalFreeAndNull(&(lpOldProps[j].Value.LPSZ));
                    }
                    else
                    if( lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT) // don't want a folder parent here.
                    {
                        ULONG k = 0;
                        lpOldProps[j].ulPropTag = PR_NULL;
                        for(k=0;k<lpOldProps[j].Value.MVbin.cValues;k++)
                            LocalFreeAndNull(&(lpOldProps[j].Value.MVbin.lpbin[k].lpb));
                        LocalFreeAndNull(&(lpOldProps[j].Value.MVbin.lpbin));
                    }
                }
            }
#endif

            {
                LPSBinary lpsb = NULL;
#ifdef IMPORT_FOLDERS
                lpsb = bIsFolderMember ? NULL : &sbPAB;//if this is already a member of some folder, don't reset parenthood on it
#else
                lpsb = &sbPAB;
#endif
                // Create a new mailuser for this entry
                if(HR_FAILED(hr = HrCreateNewObject(lpAdrBook, lpsb,
                                                    MAPI_MAILUSER, 
                                                    CREATE_CHECK_DUP_STRICT | CREATE_REPLACE | CREATE_MERGE, 
                                                    &lpObject)))
                {
                    hrDeferred = hr;
                    hr = S_OK;
                    goto endofthisloop;
                }
            }

            // Set the old guys props on the new guy - note that this overwrites any common props on 
            // potential duplicates when calling savechanges
            if(HR_FAILED(hr = lpObject->lpVtbl->SetProps(lpObject, ulcOldProps, lpOldProps, NULL)))
            {
                hrDeferred = hr;
                hr = S_OK;
                goto endofthisloop;
            }

            // SaveChanges
            if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READONLY)))
            {
                hrDeferred = hr;
                hr = S_OK;
                goto endofthisloop;
            }

            // By now the object has a new or existin EID .. if so, use this EID
            {
                ULONG ulcNewProps = 0;
                LPSPropValue lpNewProps = NULL;
            
                if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcNewProps, &lpNewProps)))
                {
                    hrDeferred = hr;
                    hr = S_OK;
                    goto endofthisloop;
                }

                for(j=0;j<ulcNewProps;j++)
                {
                    if(lpNewProps[j].ulPropTag == PR_ENTRYID)
                    {
                        if(rgObj[n] != MAPI_ABCONT)
                            SetSBinary(&sbNewEID, lpNewProps[j].Value.bin.cb, lpNewProps[j].Value.bin.lpb);
#ifdef IMPORT_FOLDERS
                        else
                        {
                            ULONG cb = 0; LPENTRYID lpb = NULL;
                            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                                            lpNewProps[j].Value.bin.lpb, NULL, NULL,
                                                            lpNewProps[j].Value.bin.cb, 0,
                                                            NULL, &cb, &lpb)))
                            {
                                // Add the entryids to this prop - ignore errors
                                SetSBinary(&sbNewEID, cb, (LPBYTE)lpb);
                                MAPIFreeBuffer(lpb);
                            }
                        }
                        if(rgObj[n] == MAPI_ABCONT && bIsThereACurrentUser(lpIAB))
                            hr = HrAddRemoveFolderFromUserFolder(lpIAB, NULL, &sbNewEID, NULL, TRUE);
#endif
                        break;
                    }
                }
                MAPIFreeBuffer(lpNewProps);
            }

            SetNewEID(&sbOldEID, &sbNewEID, dwWABEntryCount, lppsbWABEIDs);

endofthisloop:
            if(sbOldEID.lpb)
                LocalFree(sbOldEID.lpb);
            if(sbNewEID.lpb)
                LocalFree(sbNewEID.lpb);
            ReadRecordFreePropArray(NULL, ulcOldProps, &lpOldProps);
            ulcOldProps = 0;
            lpOldProps = NULL;

            if(lpObject)
                lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
        } //for i..

        FreeEntryIDs(NULL, ulEIDCount, rgsbEntryIDs);
        rgsbEntryIDs = NULL;
        ulEIDCount = 0;
    } // for n..

    if(bShowUI)
        SetPrintDialogMsg(idsImportProcessing, 0, szEmpty);

    // Now that we have opened all the entries, we need to reopen the new entries in the new WAB and
    // reset any temp entryids we might have put in them
    for(n=0;n<dwWABEntryCount;n++)
    {
        ULONG ulObjType = 0;

        if(bShowUI)
            SetPrintDialogMsg(0, 0, szEmpty);

        if(bTimeToAbort())
        {
            hr = MAPI_E_USER_CANCEL;
            goto exit;
        }

        if(!lppsbWABEIDs[eidNew][n].cb)
            continue;

        if(HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, lppsbWABEIDs[eidNew][n].cb, 
                                                (LPENTRYID) lppsbWABEIDs[eidNew][n].lpb,
                                                NULL, MAPI_BEST_ACCESS, &ulObjType,
                                                (LPUNKNOWN *)&lpObject)))
        {
            hrDeferred = hr;
            hr = S_OK;
            continue;
        }

        if(ulObjType == MAPI_ABCONT)
            goto endloop;
        
        if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcOldProps, &lpOldProps)))
        {
            hrDeferred = hr;
            hr = S_OK;
            goto endloop;
        }

        // open the record and reset any temp eids in it
        UpdateEntryIDReferences(ulcOldProps, lpOldProps, dwWABEntryCount, lppsbWABEIDs, TRUE);
    
        // SaveChanges
        if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READONLY)))
        {
            hrDeferred = hr;
            hr = S_OK;
        }

endloop:
        if(lpOldProps)
        {
            MAPIFreeBuffer(lpOldProps);
            ulcOldProps = 0;
            lpOldProps = NULL;
        }
        if(lpObject)
        {
            lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
        }
    } // for n...

    hr = S_OK;

exit:
    if(lstrlen(szFile))
        DeleteFile(szFile);

    if(sbPAB.lpb)
        MAPIFreeBuffer(sbPAB.lpb);

    if(ulcOldProps && lpOldProps)
        LocalFreePropArray(NULL, ulcOldProps, &lpOldProps);

    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    if(lppsbWABEIDs)
    {
        for(i=0;i<eidMax;i++)
        {
            for(j=0;j<dwWABEntryCount;j++)
                LocalFreeAndNull((LPVOID *) (&lppsbWABEIDs[i][j].lpb));
            LocalFreeAndNull(&lppsbWABEIDs[i]);
        }
        LocalFree(lppsbWABEIDs);
    }

    if(hPropertyStore)
        ClosePropertyStore(hPropertyStore,AB_DONT_BACKUP | AB_IGNORE_OUTLOOK);

    FreeEntryIDs(NULL, ulEIDCount, rgsbEntryIDs);

    //if(hOldCur)
    //    SetCursor(hOldCur);

    LocalFreeAndNull(&lpulNewNP);
    LocalFreeAndNull(&lpulOldNP);

    if(bShowUI)
    {
        EnableWindow(hWnd, TRUE);
        CloseAbortDlg();

        if(hr!=MAPI_E_USER_CANCEL)
            ShowMessageBox(hWnd, (  HR_FAILED(hr) ? idsImportError : 
                                    (HR_FAILED(hrDeferred) ? idsImportCompleteError : idsImportComplete) ),
                                    MB_OK | MB_ICONINFORMATION);
    }

    if(!hr && HR_FAILED(hrDeferred))
        hr = MAPI_W_ERRORS_RETURNED;

    if(!HR_FAILED(hr) && bFoldersImported)
        HrGetWABProfiles(lpIAB);

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabapi.c ===
/*
 * WABAPI.C - Main entry to WAB API
 *
 */

#include <_apipch.h>

const LPTSTR  lpszOldKeyName = TEXT("Software\\Microsoft\\WAB\\Wab File Name");
const LPTSTR  lpszKeyName = TEXT("Software\\Microsoft\\WAB\\WAB4\\Wab File Name");

#if 0
CRITICAL_SECTION csOMIUnload;
// @todo [PaulHi] DLL Leak.  Remove this or implement
static s_bIsReallyOnlyWABOpenExSession = FALSE; // [PaulHi] TRUE if any thread in process creates a 
                                                // WAB object through the WABOpenEx() function
#endif


//
//  IWABObject jump table is defined here...
//

IWOINT_Vtbl vtblIWOINT = {
    VTABLE_FILL
    (IWOINT_QueryInterface_METHOD FAR *)    UNKOBJ_QueryInterface,
    (IWOINT_AddRef_METHOD FAR *)            UNKOBJ_AddRef,
    IWOINT_Release,
    (IWOINT_GetLastError_METHOD FAR *)      UNKOBJ_GetLastError,
    IWOINT_AllocateBuffer,
    IWOINT_AllocateMore,
    IWOINT_FreeBuffer,
    IWOINT_Backup,
    IWOINT_Import,
    IWOINT_Find,
    IWOINT_VCardDisplay,
    IWOINT_LDAPUrl,
    IWOINT_VCardCreate,
    IWOINT_VCardRetrieve,
    IWOINT_GetMe,
    IWOINT_SetMe
};

/* Interface which can be queried from lpWABOBJECT.
 *
 * It is important that the order of the interfaces supported be preserved
 * and that IID_IUnknown be the last in the list.
 */
IID const FAR * argpiidIWABOBJECT[] =
{
    &IID_IUnknown
};


#define WAB_USE_OUTLOOK_ALLOCATORS    0x20000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs


/****************************************************************
 *
 -  CreateWABObject
 -
 *      Purpose
 *              Used for creating a WABObject interface in memory.
 *
 *      Arguments
 *              lppWABObject        Pointer to memory location which will receive a
 *                                                      pointer to the new WABObject.
 *     lpPropertyStore     Property store structure
 *
 *      Returns
 *              SCODE
 *
 */


STDAPI_(SCODE)
CreateWABObject(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore, LPWABOBJECT FAR * lppWABObject)
{
    SCODE       sc;
    LPIWOINT    lpIWOINT = NULL;


    // validate paremeters
    AssertSz(lppWABObject &&
      !IsBadWritePtr(lppWABObject, sizeof(LPWABOBJECT)) &&
      !IsBadWritePtr(lpPropertyStore, sizeof(LPPROPERTY_STORE)),
       TEXT("lppWABObject fails address check"));

    //
    //  Create a IPDAT per object for lpMAPIPropInternal so that it gets
    //  called first.

    if (FAILED(sc = MAPIAllocateBuffer(CBIWOINT, &lpIWOINT))) {
        goto error;
    }

    // Init the object to 0, NULL
    memset((BYTE *)lpIWOINT, 0, sizeof(*lpIWOINT));

    MAPISetBufferName(lpIWOINT,  TEXT("WABAPI: lpIWOINT in CreateWABObject"));

    // Tag each object that it is created using the OLK MAPI allocators.
    if ( lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_ALLOCATORS) )
        lpIWOINT->bSetOLKAllocators = TRUE;

    // Fill in the object specific instance data.
    lpIWOINT->inst.hinst = hinstMapiX;//HinstMapi();

#ifdef DEBUG
    if (lpIWOINT->inst.hinst == NULL)
        TraceSz1( TEXT("WABObject: GetModuleHandle failed with error %08lX"),
          GetLastError());
#endif /* DEBUG */

    //
    // Open the property store
    //
    if (FAILED(sc = OpenAddRefPropertyStore(lpWP, lpPropertyStore))) {
        goto error;
    }

    lpIWOINT->lpPropertyStore = lpPropertyStore;

    // Initialize the  TEXT("standard") object. This must be the last operation that can fail.
    // If not, explicitly call UNKOBJ_Deinit() for failures after a successful UNKOBJ_Init.
    if (FAILED(sc = UNKOBJ_Init((LPUNKOBJ)lpIWOINT,
      (UNKOBJ_Vtbl FAR *)&vtblIWOINT,
      sizeof(vtblIWOINT),
      (LPIID FAR *) argpiidIWABOBJECT,
      dimensionof(argpiidIWABOBJECT),
      &(lpIWOINT->inst)))) {
        DebugTrace( TEXT("CreateWABObject() - Error initializing IWOINT object (SCODE = 0x%08lX)\n"), sc);
        ReleasePropertyStore(lpPropertyStore);   // undo the above operation
        goto error;
    }

    // Initialize the defaults in WABObject specific part of the object.
    lpIWOINT->ulObjAccess = IPROP_READWRITE;

    *lppWABObject = (LPWABOBJECT)lpIWOINT;

    return(S_OK);

error:
    FreeBufferAndNull(&lpIWOINT);

    return(sc);
}



// --------
// IUnknown



/*
 -      IWOINT_Release
 -
 *      Purpose:
 *              Decrements reference count on the WABObject and
 *              removes instance data if reference count becomes zero.
 *
 *      Arguments:
 *               lpWABObject The object to be released.
 *
 *      Returns:
 *               Decremented reference count
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP_(ULONG)
IWOINT_Release(LPIWOINT lpWABObject)
{
    ULONG   ulcRef;
    BOOL    bSetOLKAllocators;

#if !defined(NO_VALIDATION)
        // Make sure the object is valid.
        //
    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Release, lpVtbl)) {
        DebugTrace( TEXT("IWOINT::Release() - Bad object passed\n"));
        return(1);
    }
#endif


    UNKOBJ_EnterCriticalSection((LPUNKOBJ)lpWABObject);
    ulcRef = --lpWABObject->ulcRef;
    UNKOBJ_LeaveCriticalSection((LPUNKOBJ)lpWABObject);

    // Free the object.
    //
    // No critical section lock is required since we are guaranteed to be
    // the only thread accessing the object (ie ulcRef == 0).
    //
    if (!ulcRef) {
        // Free the object.
        //
        UNKOBJ_Deinit((LPUNKOBJ)lpWABObject);

        lpWABObject->lpVtbl = NULL;

        ReleaseOutlookStore(lpWABObject->lpPropertyStore->hPropertyStore, lpWABObject->lpOutlookStore);

        ReleasePropertyStore(lpWABObject->lpPropertyStore);

        bSetOLKAllocators = lpWABObject->bSetOLKAllocators;
        FreeBufferAndNull(&lpWABObject);

        // [PaulHi] 5/5/99  Raid 77138  Null out Outlook allocator function
        // pointers if our global count goes to zero.
        if (bSetOLKAllocators)
        {
            Assert(g_nExtMemAllocCount > 0);
            InterlockedDecrement((LPLONG)&g_nExtMemAllocCount);
            if (g_nExtMemAllocCount == 0)
            {
                lpfnAllocateBufferExternal = NULL;
                lpfnAllocateMoreExternal = NULL;
                lpfnFreeBufferExternal = NULL;
            }
        }
    }

    return(ulcRef);
}


/*
 -  IWOINT_AllocateBuffer
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      cbSize                          number of bytes to allocate
 *      lppBuffer                       -> Returned buffer
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_AllocateBuffer(LPIWOINT lpWABObject, ULONG cbSize, LPVOID FAR * lppBuffer) {
    SCODE sc = S_OK;


#if !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, AllocateBuffer, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::AllocateBuffer() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_AllocateBuffer(
      lpWABObject,
      cbSize,
      lppBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lppBuffer)
        return MAPI_E_INVALID_PARAMETER;

    sc = MAPIAllocateBuffer(cbSize, lppBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}


/*
 -  IWOINT_AllocateMore
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      cbSize                          number of bytes to allocate
 *      lpObject                        original allocation
 *      lppBuffer                       -> Returned buffer
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_AllocateMore(LPIWOINT lpWABObject, ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    SCODE sc = S_OK;


#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, AllocateMore, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::AllocateMore() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_AllocateMore(
      lpWABObject,
      cbSize,
      lpObject,
      lppBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lppBuffer || !lpObject)
        return MAPI_E_INVALID_PARAMETER;


    sc = MAPIAllocateMore(cbSize, lpObject, lppBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}


/*
 -  IWOINT_FreeBuffer
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpBuffer                        Buffer to free
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_FreeBuffer(LPIWOINT lpWABObject, LPVOID lpBuffer) {
    SCODE sc = S_OK;


#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, FreeBuffer, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::FreeBuffer() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_FreeBuffer(
      lpWABObject,
      lpBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpBuffer)
        return MAPI_E_INVALID_PARAMETER;


    sc = MAPIFreeBuffer(lpBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}



/*
 -  IWOINT_Backup
 -
 *  Purpose:
 *      Backup the current database to a file.
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpFileName                      Filename to backup to
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_Backup(LPIWOINT lpWABObject, LPSTR lpFileName) {
    SCODE sc = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Backup, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Backup() - Bad object passed\n"));
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    Validate_IWABObject_Backup(
      lpWABObject,
      lpFileName);

#endif  // not NO_VALIDATION


    // Not yet implemented.
    DebugTrace( TEXT("IWABOBJECT::Backup() - Not yet implemented!\n"));
    sc = MAPI_E_NO_SUPPORT;

    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(MakeResult(sc));
}


/*
 -  IWOINT_Import
 -
 *  Purpose:
 *      Imports an address book into the current WAB database.
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpwip - WABIMPORTPARAM struct
 *
 *  Returns:
 *      HRESULT - MAPI_W_ERRORS_RETURNED if some errors occured during import
 *              Failure code if something really failed, S_OK otherwise ..
 *
 */
STDMETHODIMP
IWOINT_Import(LPIWOINT lpWABObject, LPSTR lpWIP) 
{
    LPWABIMPORTPARAM lpwip = (LPWABIMPORTPARAM) lpWIP;
    LPTSTR lpFile = NULL;
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Import, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Import() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_Import(
      lpWABObject,
      lpWIP);

#endif  // not NO_VALIDATION

    if(!lpwip || !lpwip->lpAdrBook || !lpWABObject)
        return MAPI_E_INVALID_PARAMETER;

    lpFile = 
        ConvertAtoW(lpwip->lpszFileName);

    hr = HrImportWABFile(lpwip->hWnd, lpwip->lpAdrBook, lpwip->ulFlags, lpFile);

    LocalFreeAndNull(&lpFile);

    return hr;
}


/*
 -  IWOINT_Find
 -
 *  Purpose:
 *      Displays the Find dialog so we can do Start | Find | People
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      hWnd                            hWnd of parent for the find dialog
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_Find(LPIWOINT  lpWABObject,
            LPADRBOOK lpAdrBook,
            HWND hWnd)
{
    HRESULT hr = S_OK;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Find, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Find() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;


    hr = HrShowSearchDialog(lpAdrBook,
                            hWnd,
                            (LPADRPARM_FINDINFO) NULL,
                            (LPLDAPURL) NULL,
                            NULL);

    return(hr);
}


/*
 -  IWOINT_VCardDisplay
 -
 *  Purpose:
 *      Displays One off props on a vCard File
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      lpszFileName                    Null terminated file name to display
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardDisplay(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    HWND hWnd,
                    LPSTR szvCardFile)
{
    HRESULT hr = S_OK;
    LPTSTR lpVCard = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    lpVCard = 
        ConvertAtoW(szvCardFile);

    hr = HrShowOneOffDetailsOnVCard( lpAdrBook,
                                     hWnd,
                                     lpVCard);
    LocalFreeAndNull(&lpVCard);
    return(hr);
}


/*
 -  IWOINT_VCardCreate
 -
 *  Purpose:
 *      Takes input mailuser object, and converts its properties
 *      into a vCard file
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      lpszFileName                    Null terminated file name to create
 *      lpMailUser                      MailUser object to convert to vCard
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardCreate(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    ULONG ulFlags,
                    LPSTR szvCardFile,
                    LPMAILUSER lpMailUser)
{
    HRESULT hr = S_OK;
    LPTSTR lpVCardFile = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook || !lpMailUser)
        return MAPI_E_INVALID_PARAMETER;

    lpVCardFile = 
        ConvertAtoW(szvCardFile);

    hr = VCardCreate(lpAdrBook,
                     NULL,
                     0,
                     lpVCardFile,
                     lpMailUser);
    LocalFreeAndNull(&lpVCardFile);
    return(hr);
}

/*
 -  IWOINT_VCardRetrieve
 -
 *  Purpose:
 *      Opens a vCard file and creates a corresponding MailUser out of it
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         STREAM or FILE
 *      lpszFileName                    Null terminated file name to display
 *      lppMailUser                     returned MailUser object
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardRetrieve(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    ULONG  ulFlags,
                    LPSTR szvCard,
                    LPMAILUSER * lppMailUser)
{
    HRESULT hr = S_OK;
    LPSTR lpStream = NULL;
    LPTSTR lpFileName = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if( !lpWABObject || !lpAdrBook || !lppMailUser || 
        !szvCard || (!(ulFlags&WAB_VCARD_STREAM) && !lstrlenA(szvCard)) )
        return MAPI_E_INVALID_PARAMETER;

    if(ulFlags & WAB_VCARD_STREAM)
    {
        if(!(lpStream = LocalAlloc(LMEM_ZEROINIT, lstrlenA(szvCard)+1)))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        lstrcpyA(lpStream, szvCard);
    }
    else
    {
        lpFileName = ConvertAtoW(szvCard);
    }

    hr = VCardRetrieve(lpAdrBook,
                       NULL,
                       0,
                       lpFileName,
                       lpStream,
                       lppMailUser);
    LocalFreeAndNull(&lpFileName);
    LocalFreeAndNull(&lpStream);

    return(hr);
}

/*
 -  IWOINT_LDAPUrl
 -
 *  Purpose:
 *      Handles an LDAP URL
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      ulFlags                         flags saying how we want the results returned
 *      lpszUrl                         Null terminated file name to display
 *      lppMailUser                     Possible Mailuser to return based on flag
 *
 *      With this API, users can pass in a Wide string URL by casting it to a 
 *      LPSTR and setting ulFlags to MAPI_UNICODE .. if we detect MAPI_UNICODE,
 *      we cast the string back to a WideChar
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_LDAPUrl( LPIWOINT  lpWABObject,
                LPADRBOOK lpAdrBook,
                HWND hWnd,
                ULONG ulFlags,
                LPSTR szLDAPUrl,
                LPMAILUSER * lppMailUser)
{
    HRESULT hr = S_OK;
    LPTSTR lpUrl = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, LDAPUrl, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::LDAPUrl() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook || !szLDAPUrl)// || !lstrlen(szLDAPUrl))
        return MAPI_E_INVALID_PARAMETER;

    if(ulFlags & MAPI_UNICODE)
    {
        lpUrl = (LPWSTR)szLDAPUrl;
    }
    else
    {
        lpUrl = ConvertAtoW(szLDAPUrl);
    }

    if(!lstrlen(lpUrl))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    hr = HrProcessLDAPUrl(  lpAdrBook,
                            hWnd,
                            ulFlags | ((!ulFlags && hWnd) ? MAPI_DIALOG : 0),
                            lpUrl,
                            lppMailUser);
out:
    if(lpUrl && lpUrl != (LPTSTR)szLDAPUrl)
        LocalFreeAndNull(&lpUrl);

    return hr;
}


/*
 -  IWOINT_GetMe
 -
 *  Purpose:
 *      Retrieves the 'Me' entry from the WAB .. if the entry doesnt exist,
 *      prompts the user to create one or select someone from his address book.
 *      Unless the caller surpresses the dialog by passing in AB_NO_DIALOG, in
 *      which case, the entry is created behind-the-scenes. Caller can also
 *      call this function to check existence of a ME entry without causing a new
 *      one created as a side effect - to do that they specify the WABOBJECT_ME_NOCREATE flag
 *      which causes failure with MAPI_E_NOT_FOUND if nothing found
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         0 or AB_NO_DIALOG
 *                                      or WABOBJECT_ME_NOCREATE                                       
 *      lpdwAction                      if supplied, returns WABOBJECT_ME_NEW if a new ME was created
 *      SBinary *                       returns the entry id of the ME,
 *      ulParam                         HWND of parent cast as a (ULONG)
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_GetMe(   LPIWOINT    lpWABObject,
                LPADRBOOK   lpAdrBook,
                ULONG       ulFlags,
                DWORD *     lpdwAction,
                SBinary *   lpsbEID,
                ULONG       ulParam) 
{
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, GetMe, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::GetMe() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    hr = HrGetMeObject(lpAdrBook, ulFlags, lpdwAction, lpsbEID, ulParam);

    return hr;

}

/*
 -  IWOINT_SetMe
 -
 *  Purpose:
 *      Sets the specified object as the Me object .. only 1 Me object will exist in a WAB
 *      Hence it strips the previous Me object, if different, of its Me status.
 *      If no entryid is passed in, and MAPI_DIALOG is specified, a dialog pops up 
 *          asking the user to create a ME or to select a ME object .. the selection in the SetMe
 *          dialog is set to the current ME object, if any
 *      If no entryid is passed in, and MAPI_DIALOG is not specified, the function fails
 *      If an entryid is passed in, and MAPI_DIALOG is specified, the SetME dialog is displayed
 *          with the corresponding entryid-object selected in it
 *      If an entryid is passed in, and MAPI_DIALOG is not specified, the entryid, if exists, is 
 *          set as the ME object and the old ME object stripped
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         0 or MAPI_DIALOG
 *      sbEID                           entry id of the object to set as ME,
 *      ulParam                         HWND of parent for DIalogs cast as a ULONG
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_SetMe(   LPIWOINT    lpWABObject,
                LPADRBOOK   lpAdrBook,
                ULONG       ulFlags,
                SBinary     sbEID,
                ULONG       ulParam) 
{
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, SetMe, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::GetMe() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if( !lpAdrBook ||
        ((!sbEID.cb||!sbEID.lpb) && !ulFlags) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto exit;
    }

    hr = HrSetMeObject(lpAdrBook, ulFlags, sbEID, ulParam);

exit:
    return hr;

}






/*
 -  ReleasePropertyStore
 -
 *  Purpose:
 *      Keep track of property store refcount
 *
 *  Arguments:
 *      lpPropertyStore     PROPERTY_STORE structure
 *
 *  Returns:
 *      Current reference count.  When 0, property store is
 *      no longer open.
 *
 */
ULONG ReleasePropertyStore(LPPROPERTY_STORE lpPropertyStore) {
    if (lpPropertyStore->ulRefCount) {
        IF_WIN32(Assert(lpPropertyStore->hPropertyStore);)
        if (0 == (--(lpPropertyStore->ulRefCount))) {
            // Reference goes to zero, release the property store

            ClosePropertyStore(lpPropertyStore->hPropertyStore,0);
            lpPropertyStore->hPropertyStore = NULL;

			// Free the container list
			FreeBufferAndNull(&(lpPropertyStore->rgolkci));
            lpPropertyStore->colkci = 0;

            // [PaulHi] Raid #61556
            // Must reset this global variable or OUT32WAB.DLL will crash
            // the next time it is loaded and the store opened.
            pmsessOutlookWabSPI = NULL;
        }
    }
    return(lpPropertyStore->ulRefCount);
}

#ifdef WIN16
BOOL WINAPI WABInitThread()
{
    // allocate a TLS index
    if ((dwTlsIndex = TlsAlloc()) == 0xfffffff)
        return FALSE;

    return TRUE;
}
#endif

#define WAB_USE_OUTLOOK_CONTACT_STORE 0x10000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs

//
// Input information to pass to WABOpen from IE4 WAB
//
typedef struct _tagWAB_PARAM_V4
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPTSTR  szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // Currently no flags.
} WAB_PARAM_V4, * LPWAB_PARAM_V4;



/*
 -  WABOpen
 -
 *  Purpose:
 *      Entry point into the WAB API
 *
 *  Arguments:
 *      lppAdrBook                      Returned IAdrBook object
 *      lppWABOBJECT                    Returned WABObject
 *      Reserved1                       Reserved for future filename?
 *      Reserved2                       Reserved for future flags
 *
 *  Returns:
 *      HRESULT
 *          S_OK
 *          E_FAIL                      // some generic error
 *          MAPI_E_NOT_ENOUGH_MEMORY:   // ran out of memory
 *          MAPI_E_NO_ACCESS:           // file is locked by someone
 *          MAPI_E_CORRUPT_DATA:        // file corrupt
 *          MAPI_E_DISK_ERROR:          // some disk related error opening file
 *          MAPI_E_INVALID_OBJECT:      // secified file exists but its GUID doesnt match
 *
 */
STDMETHODIMP WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP, DWORD Reserved2) {
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;
    static PROPERTY_STORE PropertyStore = {NULL, 0, 0, 0, NULL, 0};
    static OUTLOOK_STORE OutlookStore = {NULL, 0};
    BOOL bUseOutlook = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPTSTR lpFile = NULL;

    AssertSz(lppAdrBook && !IsBadWritePtr(lppAdrBook, sizeof(LPADRBOOK)),
       TEXT("lppAdrBook fails address check"));

    AssertSz(lppWABObject && !IsBadWritePtr(lppWABObject, sizeof(LPWABOBJECT)),
       TEXT("lppWABObject fails address check"));

    if(!lppAdrBook || !lppWABObject)
        return MAPI_E_INVALID_PARAMETER;

    IF_WIN16(ScInitMapiUtil(0);)

    // First check if this is supposed to be an Outlook session
    // If we are explicitly told to use the contact store ...
    if((lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_CONTACT_STORE)) &&
        PropertyStore.ulRefCount == 0)  // Bad bug where wabopen process calls outlook which 
                                        // calls wabopenex and we flunk everywhere since this PropertyStore
                                        // information is a static in the original process.. 
                                        // force the wabopenex to be a wabopen if this rare case happens
        bUseOutlook = TRUE;
    else
    {
        // if a file name is specified and this is not wabopenex, then override any
        // outlook use .. this way we can explicitly call the wab to open a .wab file
        // from anywhere
        if(lpWP && lpWP->szFileName && lstrlenA(lpWP->szFileName))
            bUseOutlook = FALSE;
        else 
            bUseOutlook = bUseOutlookStore();
    }

#if 0
    // @todo [PaulHi] DLL Leak.  Remove this or implement
    // [PaulHi] Set this process global boolean ONLY if the WAB is opened through the WABOpenEx()
    // function ,i.e., by the Outlook process
    if (lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_CONTACT_STORE))
    {
        EnterCriticalSection(&csOMIUnload);
        s_bIsReallyOnlyWABOpenExSession = TRUE;
        LeaveCriticalSection(&csOMIUnload);
    }
#endif

    //
    // if a .wab file is already initialized in this process space, just inherit that file
    // [PaulHi] 12/5/98  Raid #56437
    // We still need to allow the Outlook refcount to increment if this store has been created.
    // So we need to check both the WAB PropertyStore and OutlookStore ref counts to determine
    // if we should prevent the Outlook store from being opened.
    // Note that these two lines fixes the following problem:
    // 1)  User opens OE5 (which opens WAB in non-outlook store mode)
    // 2)  User has the Outlook set as their default mail client.
    // 3)  User uses the WAB to initiate a send email.
    // 4)  Since Outlook is the default client it is launched, and in turn opens WAB
    //     in outlook store mode.  At this point the WAB is already open in non-outlook store
    //     mode so we want to prevent the Outlook store from being initialized.
    //
    if (PropertyStore.ulRefCount && !OutlookStore.ulRefCount)
        bUseOutlook = FALSE;

    if(bUseOutlook)
    {
        // If this call fails, we will just end up defaulting to the WAB store...
        // so we can ignore any errors here
        OpenAddRefOutlookStore(&OutlookStore);
    }

    //
    // Create the WAB Object
    //
    if (FAILED(sc = CreateWABObject(lpWP, &PropertyStore, lppWABObject))) {
        hResult = ResultFromScode(sc);
        if(bUseOutlook)   // IE6 bug 15174
            pt_bIsWABOpenExSession = FALSE; 
        goto exit;
    }

    //
    // Create the IAdrBook Object
    //
    if (HR_FAILED(hResult = HrNewIAB(&PropertyStore, *lppWABObject, lppAdrBook))) {
        // IAdrBook creation failed, fail WABOpen and clean up.
        UlRelease(*lppWABObject);
        goto exit;
    }
    DebugTrace( TEXT("WABOpen succeeds\n"));

    if(bUseOutlook)
    {
        if( lppWABObject && *lppWABObject &&
            OutlookStore.hOutlookStore)
        {
            ((LPIWOINT)(*lppWABObject))->lpOutlookStore = &OutlookStore;
        }

        // Bug - Outlook needs a way for its secondary threads to know this is a WABOpenEx session
        // without their calling WABOpenEx (They pass the iAdrBook pointer around it seems). Hence
        // tag this IADRbook pointer
        if(!HR_FAILED(hResult) && lppAdrBook && *lppAdrBook && pt_bIsWABOpenExSession)
            ((LPIAB)(*lppAdrBook))->lpPropertyStore->bIsWABOpenExSession = TRUE;
    }

    if(lppAdrBook && *lppAdrBook)
    {
        // Load the WABs private named properties
        HrLoadPrivateWABProps((LPIAB) *lppAdrBook);

        if(lpWP && (lpWP->cbSize > sizeof(WAB_PARAM_V4)) )
            ((LPIAB)*lppAdrBook)->guidPSExt = lpWP->guidPSExt;

        // As long as this is not an Outlook session, profiles are always
        // enabled in the UI
        if( !pt_bIsWABOpenExSession &&
            !((LPIAB)(*lppAdrBook))->lpPropertyStore->bIsWABOpenExSession )
        {
            ((LPIAB)(*lppAdrBook))->bProfilesEnabled = TRUE;
        }

        if( ((LPIAB)(*lppAdrBook))->bProfilesEnabled )
        {
            if(lpWP && (lpWP->ulFlags & WAB_ENABLE_PROFILES)) // only check for profiles the first time we enter for this process
            {
                if(PropertyStore.ulRefCount >= 2)
                {
                    ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = ((LPIAB)(*lppAdrBook))->bProfilesIdent = TRUE;
                }
                else
                {
                    ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = PropertyStore.bProfileAPIs;
                }

                if(((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled )
                    hResult = HrLogonAndGetCurrentUserProfile(lpWP->hwnd, ((LPIAB)(*lppAdrBook)), FALSE, FALSE);
                
                // if there is some identity related error we should then revert to
                // non-identity mode
                if(HR_FAILED(hResult))
                {
                    PropertyStore.bProfileAPIs = ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = FALSE;
                    hResult = S_OK;
                }
                else
                    PropertyStore.bProfileAPIs = ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = TRUE;
            }
        }

        if( ((LPIAB)(*lppAdrBook))->bProfilesEnabled )
        {
            if(HR_FAILED(hResult = HrGetWABProfiles((LPIAB) *lppAdrBook)))
            {
                // UGH! If this failed then we are quite in trouble and won't be able to support a profile-enabled
                // session without crashing badly .. hence above failure is critical enough to stop
                // loading the WAB
                (*lppAdrBook)->lpVtbl->Release(*lppAdrBook);
                (*lppWABObject)->lpVtbl->Release(*lppWABObject);
            }
        }
        
        ReadWABCustomColumnProps((LPIAB) *lppAdrBook);

        // need to be aware of Identity Notifications if this is a profile aware WAB independent
        // of whether the store is switched to using Outlook or not
        //
        // If the caller specifically asked for profiles 
        // (then assume it is identity aware and register for Identity Notifications
        // because if the caller is using Identites, WAB launched as a child window
        // needs to be able to shut down when it gets a switch_identites message
        if( lpWP && (lpWP->ulFlags & WAB_ENABLE_PROFILES)) 
            HrRegisterUnregisterForIDNotifications( (LPIAB) *lppAdrBook, TRUE);

        if( lpWP && (lpWP->ulFlags & WAB_USE_OE_SENDMAIL)) 
            ((LPIAB) *lppAdrBook)->bUseOEForSendMail = TRUE;
    }

exit:
    return(hResult);
}


/*
 -  WABOpenEx
 -
 *  Purpose:
 *      Extended Entry point into the WAB API
 *
 *  Arguments:
 *      lppAdrBook                      Returned IAdrBook object
 *      lppWABOBJECT                    Returned WABObject
 *      lpMP                            WAB Parameter structure (NULL by default)
 *      Reserved                        Optional IMAPISession parameter
 *      fnAllocateBuffer                AllocateBuffer function (may be NULL)
 *      fnAllocateMore                  AllocateMore function (may be NULL)
 *      fnFreeBuffer                    FreeBuffer function (may be NULL)
 *
 *  Returns:
 *      HRESULT
 *          S_OK
 *          E_FAIL                      // some generic error
 *          MAPI_E_NOT_ENOUGH_MEMORY:   // ran out of memory
 *          MAPI_E_NO_ACCESS:           // file is locked by someone
 *          MAPI_E_CORRUPT_DATA:        // file corrupt
 *          MAPI_E_DISK_ERROR:          // some disk related error opening file
 *          MAPI_E_INVALID_OBJECT:      // secified file exists but its GUID doesnt match
 *
 */
STDMETHODIMP WABOpenEx(LPADRBOOK FAR * lppAdrBook,
  LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP,
  DWORD Reserved,
  ALLOCATEBUFFER * lpfnAllocateBuffer,
  ALLOCATEMORE * lpfnAllocateMore,
  FREEBUFFER * lpfnFreeBuffer) {

    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    WAB_PARAM wp = {0};
    
    if (Reserved) {
        // This is an IMAPISession that needs to be passed to the
        // Outlook storage provider interface ..
		pmsessOutlookWabSPI = (LPUNKNOWN)IntToPtr(Reserved);
    }

    if(!lppWABObject || !lppAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    wp.cbSize = sizeof(WAB_PARAM);
    if(!lpWP)
        lpWP = &wp;
    lpWP->ulFlags |= WAB_USE_OUTLOOK_CONTACT_STORE;
    
    // Did we get allocators?  Set up the globals
    if (lpfnAllocateBuffer || lpfnAllocateMore || lpfnFreeBuffer)
    {
        if (lpfnAllocateBuffer && lpfnAllocateMore && lpfnFreeBuffer)
        {
            DebugTrace( TEXT("WABOpenEx found external allocators\n"));
            lpfnAllocateBufferExternal = lpfnAllocateBuffer;
            lpfnAllocateMoreExternal = lpfnAllocateMore;
            lpfnFreeBufferExternal = lpfnFreeBuffer;
            lpWP->ulFlags |= WAB_USE_OUTLOOK_ALLOCATORS;
            InterlockedIncrement((LPLONG)&g_nExtMemAllocCount); // Incremented twice for each object created; IAB and IWO
            InterlockedIncrement((LPLONG)&g_nExtMemAllocCount);
        }
        else
        {
            DebugTrace( TEXT("WABOpenEx got one or two allocator functions, but not all three\n"));
            hResult = ResultFromScode(MAPI_E_INVALID_PARAMETER);
            goto exit;
        }
    }

    hResult = WABOpen(  lppAdrBook, lppWABObject, lpWP, 0);

    if(lpWP == &wp)
        lpWP = NULL;

    if(HR_FAILED(hResult))
        goto exit;

exit:
    return(hResult);
}

/*
 -
 -  GetNewDataDirName
 *
 *  Purpose:
 *      Gets the path of the new data directory in which the WAB file should be placed
 *
 *      We look for:
 *          Roaming User App Data Dir; else
 *          Program Files\IE\OE\Current User\Address Book; else
 *          Common Files\Microsoft Shared\Address Book; else
 *          Create c:\Address book\ else
 *          Create c:\wab\
 *
 *  Returns a valid, existing directory name terminated by a \
 *
 */
HRESULT GetNewDataDirName(LPTSTR szDir)
{
    HRESULT hr = E_FAIL;
    const LPTSTR lpszShellFolders = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    const LPTSTR lpszAppData = TEXT("AppData");
    const LPTSTR lpszCurrentVer = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    const LPTSTR lpszCommonFiles = TEXT("CommonFilesDir");
    const LPTSTR lpszMicrosoftShared = TEXT("\\Microsoft Shared");
    const LPTSTR lpszAddressBook = TEXT("\\Address Book");
    const LPTSTR lpszOEKey = TEXT("Software\\Microsoft\\Outlook Express\\5.0");
    const LPTSTR lpszOERoot = TEXT("Store Root");
    const LPTSTR lpszMicrosoft = TEXT("\\Microsoft");
    const LPTSTR lpszCAddressBook = TEXT("c:\\Address book");
    const LPTSTR lpszCWAB = TEXT("c:\\WAB");

    HKEY hKey = NULL;
    DWORD dwSize = 0;

    DWORD dwType = 0;
    TCHAR szPath[MAX_PATH];
    TCHAR szUser[MAX_PATH];

    *szPath='\0';

    if(!szDir)
        goto out;

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,lpszShellFolders,0,KEY_READ,&hKey))
    {
    // Look for the App Data directory
        dwSize = CharSizeOf(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszAppData, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                lstrcpy(szDir, szPath);
                if(GetFileAttributes(szDir) != 0xFFFFFFFF)
                {
                    lstrcat(szDir, lpszMicrosoft);
                    if(GetFileAttributes(szDir) == 0xFFFFFFFF)
                        CreateDirectory(szDir, NULL);
                    lstrcat(szDir, lpszAddressBook);
                    if(GetFileAttributes(szDir) == 0xFFFFFFFF)
                        CreateDirectory(szDir, NULL);
                }
                hr = S_OK;
                goto out;
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    hKey = NULL;

    // Didnt find this directory
    // Look for MyDocuments folder - it will only be installed with Office so no gaurantee it will be found
    // <TBD> - there doesnt seem to be a definite location for this except under
    // CurrentVersion\Explorer\Shell Folders\Personal

    // Didnt find a My Documents directory
    // See if OE is installed for the current user ..

    /** commented out until OE has stable dir structure
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszOEKey, 0, KEY_READ, &hKey))
    {
        dwSize = CharSizeOf(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszOERoot, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                lstrcat(szPath,lpszAddressBook);

                //if directory doesnt exist, create it 
                CreateDirectory(szPath, NULL); //ignore error if it already exists

                if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                {
                    lstrcpy(szDir, szPath);
                    hr = S_OK;
                    goto out;
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    */
  hKey = NULL;

    // No user name .. just get the common files directory and put  TEXT("Microsoft Shared\Address Book") under it
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszCurrentVer, 0, KEY_READ, &hKey))
    {
        dwSize = CharSizeOf(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszCommonFiles, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                lstrcat(szPath, lpszMicrosoftShared);
                CreateDirectory(szPath, NULL);
                if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                {
                    lstrcat(szPath, lpszAddressBook);
                    CreateDirectory(szPath, NULL);
                    if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                    {
                        lstrcpy(szDir, szPath);
                        hr = S_OK;
                        goto out;
                    }
                }
            }
        }
    }

    // if all of the above failed then we'll have problems since this function must NEVER fail when
    // it is called,
    // Hence go ahead and try to create c:\address book (which might fail on an 8.3 machine) in which case
    // create c:\wab
    if(CreateDirectory(lpszCAddressBook, NULL))
    {
        lstrcpy(szDir, lpszCAddressBook);
        lstrcat(szDir, TEXT("\\"));
        hr = S_OK;
        goto out;
    }

    // failed - try c:\wab
    if(CreateDirectory(lpszCWAB, NULL))
    {
        lstrcpy(szDir, lpszCWAB);
        hr = S_OK;
        goto out;
    }

    // still failed !!!!!???!!? !@#!@#!!!
    // just return the windows directory if we can
    if(GetWindowsDirectory(szPath, CharSizeOf(szPath)))
    {
        lstrcpy(szDir, szPath);
        hr = S_OK;
        goto out;
    }
 
    // still failed !!!!!???!!? !@#!@#!!!
    // just return 'c:' 
    lstrcpy(szDir, TEXT("c:\\"));
    hr = S_OK;


out:
    if(hKey)
        RegCloseKey(hKey);

    if(szDir && lstrlen(szDir))
    {
        // Add a terminating slash to the directory name if one doesnt exist
        if( *(szDir+lstrlen(szDir)-1) != '\\' )
            lstrcat(szDir, szBackSlash);
    }

    return hr;
}

/*
 -
 -  DoFirstRunMigrationAndProcessing
 *
 *  Purpose:
 *      If this is an IE4 or later first run, move the old WAB file from
 *      windows to a new location and/or create a new WAB file so that the
 *      old WAB file is not mucked around with
 *
 */
HRESULT DoFirstRunMigrationAndProcessing()
{
    HRESULT hr = S_OK;
    const LPTSTR lpszFirstRunValue = TEXT("FirstRun");
    const LPTSTR lpszIE3Ext = TEXT(".ie3");
    DWORD dwType = 0;
    DWORD dwValue = 0;  
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    TCHAR szDir[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    HKEY hKey = NULL;
    DWORD dwSize = sizeof(DWORD);

    // First check if this is a first run - if its not a first run then we can just skip out
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0, KEY_READ, &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpszFirstRunValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize))
        {
            goto out;
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    hKey = NULL;

    // So this is the first run ..

    // First thing to do is to Migrate the LDAP accounts in this session only ...
    // Set the first run flag
    pt_bFirstRun = TRUE;

    // Get the directory name of the new directory in which the WAB file will be created/copied
    *szDir = '\0';

    if(hr = GetNewDataDirName(szDir))
        goto out;

    *szFileName = '\0';

    // Do we have a pre-existing wab data file ? Check by looking in the registry for the appropriate reg key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszOldKeyName, 0, KEY_ALL_ACCESS, &hKey))
    {
        TCHAR szOldPath[MAX_PATH];
        TCHAR szWinPath[MAX_PATH];
        TCHAR szNewName[MAX_PATH];

        // Get the file path ..
        dwSize = CharSizeOf(szOldPath);
        *szOldPath = '\0';
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szOldPath, &dwSize))
        {
            if(lstrlen(szOldPath) && GetFileAttributes(szOldPath)!= 0xFFFFFFFF)
            {
                LPTSTR lp1= NULL, lp2 = NULL;

                // isolate the wab file name here
                lp1 = szOldPath;
                while(lp1 && *lp1)
                {
                    if(*lp1 == '\\')
                        lp2 = lp1;
                    lp1 = CharNext(lp1);
                }

                if(!lp2)
                    lp2 = szOldPath;
                else
                {
                    lp1 = lp2;
                    lp2 = CharNext(lp1);
                }

                lstrcpy(szFileName, lp2);

                // rename the old file as an ie3 file by appending .ie3 to the end of the file name
                lstrcpy(szNewName, szOldPath);
                lstrcat(szNewName, lpszIE3Ext);

                if(MoveFile(szOldPath, szNewName))
                {
                    // Update the new name and path in the old registry setting
                    RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                }
            
                lstrcpy(szOldPath, szNewName);
                *szNewName = '\0';

                // Is this in the Windows Directory ??
                *szWinPath = '\0';
                GetWindowsDirectory(szWinPath, CharSizeOf(szWinPath));
                if(lstrlen(szWinPath) &&
                   lstrlen(szWinPath) < lstrlen(szOldPath))
                {
                    // Terminate the old file path just before the filename
                    // If the file is in the Windows directory, the remaining filename
                    // will be the same as the windows path

                    if(*lp1 == '\\') //lp1 was set above
                    {
                        // First check that the windows directory is not the root directory (e.g. C:\)
                        if(lstrlen(szWinPath) == 3 && szWinPath[1]==':' && szWinPath[2]=='\\')
                            lp1 = CharNext(lp1); // Move lp1 past the '\'
                        *lp1 = '\0';
                    }

                    if(!lstrcmpi(szOldPath, szWinPath))
                    {
                        dwSize = CharSizeOf(szOldPath);
                        RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE) szOldPath, &dwSize);

                        lstrcpy(szNewName, szDir);
                        lstrcat(szNewName, szFileName);
                        lstrcat(szNewName, lpszIE3Ext);

                        // move this file to the new directory
                        if(MoveFile(szOldPath, szNewName))
                        {
                            // Update the newname in the registry
                            RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                        }

                        lstrcpy(szOldPath, szNewName);
                    }
                }

                // Since the old WAB file exists, we will make a copy and put it in the newdir
                lstrcpy(szNewName, szDir);
                lstrcat(szNewName, szFileName);

                CopyFile(szOldPath, szNewName, TRUE);
                {
                    // if the CopyFile fails because something already exists in the new dir, still update
                    // the path to the new dir (prevent using the old file no matter what)
                    HKEY hKeyNew = NULL;
                    DWORD dwDisposition = 0;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, lpszKeyName, 0, NULL, 0, KEY_ALL_ACCESS, 
                                                        NULL, &hKeyNew, &dwDisposition))
                    {
                        RegSetValueEx(hKeyNew, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                    }
                    if(hKeyNew)
                        RegCloseKey(hKeyNew);
                }                                       
            }
        }
    }


    // update the first run flag
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0, KEY_ALL_ACCESS, &hKey))
    {
        dwValue = 1;
        dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS != RegSetValueEx( hKey, lpszFirstRunValue, 0, REG_DWORD, (LPBYTE) &dwValue, dwSize))
        {
            goto out;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    hKey = NULL;

    hr = S_OK;

out:

    if(hKey)
        RegCloseKey(hKey);

    return hr;
}

// Random test data .. ignore
// static OlkContInfo rgOlk[2];
// LPTSTR lp1 = "Contact Folder 1";
// LPTSTR lp2 = "Second Contact Folder";
extern void ConvertOlkConttoWABCont( ULONG * lpcolk,   OutlookContInfo ** lprgolk, 
                                     ULONG * lpcolkci, OlkContInfo ** lprgolkci);

/*
 -  OpenAddRefPropertyStore
 -
 *  Purpose:
 *      Get the property store name from the registry and open it.
 *      Addref it
 *
 *  Arguments:
 *      lpPropertyStore     PROPERTY_STORE structure
 *
 *  Returns:
 *      SCODE
 *
 *  Notes:
 *      This routine is kind of a mess with all these gotos and special cases
 *      for failed registry functions.  I'm not sure why, but the registry
 *      functions operate differently on NT and Win95, but in both cases,
 *      they sometimes act as though the key already exists even when it doesn't.
 *
 */
SCODE OpenAddRefPropertyStore(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore) {
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    TCHAR   szFileName[MAX_PATH];
    LPTSTR  lpCurrent;
    HKEY    hKey = NULL;
    DWORD   dwLenName = CharSizeOf(szFileName);
    DWORD   dwCurrent;
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;
    HWND    hWnd = NULL;
    ULONG   ulFlags = AB_OPEN_ALWAYS;
    LPTSTR  lpszWABExt = TEXT(".wab");
    BOOL    fNewKey = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    szFileName[0]='\0';

    if (lpWP)
    {
        // The cbSize parameter will, in the future, tell us what version
        // of the WAB_PARAM is being called so we can upgrade the WAB_PARAM
        // structure in future releases. For this version the cbSize
        // doesnt really matter.
        hWnd = lpWP->hwnd;

        if(!lpWP->ulFlags && lpWP->szFileName )
        {
            LPWSTR lpW = ConvertAtoW(lpWP->szFileName);
            lstrcpy(szFileName, lpW);
            LocalFreeAndNull(&lpW);
        }

    }

    if (! lpPropertyStore->ulRefCount) {
		if (pt_bIsWABOpenExSession) {
			hResult = OpenPropertyStore(NULL, 0, hWnd,
					&(lpPropertyStore->hPropertyStore));
			if (SUCCEEDED(hResult)) 
            {
				LPWABSTORAGEPROVIDER lpWSP;
                ULONG colk = 0;
                OutlookContInfo * rgolk = NULL;
				Assert(lpPropertyStore->hPropertyStore);
				Assert(!lpPropertyStore->rgolkci);
				Assert(!lpPropertyStore->colkci);
				lpWSP = (LPWABSTORAGEPROVIDER)(lpPropertyStore->hPropertyStore);
				hResult = lpWSP->lpVtbl->GetContainerList(lpWSP, &colk, &rgolk);
                if(!HR_FAILED(hResult))
                {
    				DebugTrace(TEXT("WABStorageProvider::GetContainerList returns:%x\n"),hResult);
                    ConvertOlkConttoWABCont(&colk, &rgolk, &lpPropertyStore->colkci, &lpPropertyStore->rgolkci);
                    FreeBufferAndNull(&rgolk);
                }
                else
				{
					lpWSP->lpVtbl->Release(lpWSP);
					lpPropertyStore->hPropertyStore = NULL;
				}
			}
			if (FAILED(hResult)) {
				sc = ResultFromScode(hResult);
				goto error;
			}
            //lpPropertyStore->colkci = 2;
            //rgOlk[0].lpEntryID = rgOlk[1].lpEntryID = lpPropertyStore->rgolkci[0].lpEntryID;
            //rgOlk[0].lpszName = lp1;
            //rgOlk[1].lpszName = lp2;
            //lpPropertyStore->rgolkci = rgOlk;
			goto out;
		}

        //
        // Get the default WAB file name from the registry
        // if we don't have a name supplied in lpWP
        //
try_again:
        if(!lstrlen(szFileName))
        {
            DoFirstRunMigrationAndProcessing();

            // First, try to open an existing key
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              lpszKeyName,
                                              0,    // options, MBZ
                                              KEY_ALL_ACCESS,
                                              &hKey))
            {
                dwDisposition = REG_OPENED_EXISTING_KEY;
            }
            else
            {
                // Create the key
                if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                                    lpszKeyName,
                                                    0,      //reserved
                                                    NULL,
                                                    REG_OPTION_NON_VOLATILE,
                                                    KEY_ALL_ACCESS,
                                                    NULL,
                                                    &hKey,
                                                    &dwDisposition))
                {
                    DebugTrace( TEXT("RegCreateKeyEx failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }
            }

            if (dwDisposition == REG_CREATED_NEW_KEY)
            {
new_key:
                // prevent more than one retry
                if (fNewKey)
                {
                    hResult = ResultFromScode(MAPI_E_NOT_INITIALIZED);
                    goto error;
                }
                fNewKey = TRUE;
                //
                // New key ... need to give it a value ..
                //

                // BUG - dont use windows directory for new wab files ..
                // use one of the application data directories ...
                if(GetNewDataDirName(szFileName))
                {
                    DebugTrace( TEXT("GetNewDataDirName failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }

                dwCurrent = lstrlen(szFileName);

                //Tag on a trailing slash if 1 doesnt exist ..
                if(szFileName[dwCurrent-1] != '\\')
                {
                    lstrcat(szFileName, szBackSlash);
                }

                // Get a user name ...

                dwCurrent = lstrlen(szFileName);
                lpCurrent = szFileName + dwCurrent;
                dwLenName = CharSizeOf(szFileName) - dwCurrent;
                if (! GetUserName(lpCurrent, &dwLenName))
                {
                    // On failure just create some dummy file name
                    lstrcpy(lpCurrent, TEXT("AddrBook"));
                }

                // Fix any invalid characters in the filename
                while (*lpCurrent) {
                    switch (*lpCurrent) {
                        case '\\':
                        case '/':
                        case '<':
                        case '>':
                        case ':':
                        case '"':
                        case '|':
                        case '?':
                        case '*':
                        case '.':
                            *lpCurrent = '_';   // replace with underscore
                            break;

                        default:
                            break;
                    }

                    lpCurrent++;
                }

                lstrcat(szFileName, lpszWABExt);

                dwLenName = sizeof(TCHAR)*lstrlen(szFileName);

                //save this as the value of the Wab file in the registry
                if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                                    NULL,
                                                    0,
                                                    REG_SZ,
                                                    (LPBYTE)szFileName,
                                                    dwLenName))
                {
                    DebugTrace( TEXT("RegSetValue failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }
            }
            else
            {
                // Didn't create a new key, so get the key value
                if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                    NULL,
                                                    NULL,
                                                    &dwType,      //reserved
                                                    (LPBYTE)szFileName,
                                                    &dwLenName))
                {
                    DebugTrace( TEXT("RegSetValue failed\n"));
                    goto new_key;
                }
                else if (! lstrlen(szFileName))
                {
                    DebugTrace( TEXT("Warning: Found empty name key!\n"));
                    goto new_key;
                }

                //Check that the name in the existing key is a valid filename
                // If it is not a valid file name then we should remove it
                // from the registry and create a new default file name
                if(0xFFFFFFFF == GetFileAttributes(szFileName))
                {
                    // There is some problem with this file ...
                    // Remove it from the registry and recreate a new file name
                    // only if the path doesnt exist. Its possible that the file
                    // doesnt exist, in which case we create a new file in open
                    // property store
                    DWORD dwErr = GetLastError();
                    //NT5 bug 180007 - upgrading from Win95 to WinNT 5, if the
                    // old file name had quotes around it, CreateFile will fail and
                    // so will GetFileAttributes.
                    // Strip out the quotes and try again
                    if( (dwErr == ERROR_PATH_NOT_FOUND || dwErr == ERROR_INVALID_NAME) &&
                        lstrlen(szFileName) && szFileName[0] == '"' && szFileName[lstrlen(szFileName)-1] == '"')
                    {
                        // remove the quotes
                        szFileName[lstrlen(szFileName)-1] = '\0';
                        lstrcpy(szFileName, szFileName+1);
                        if(0xFFFFFFFF != GetFileAttributes(szFileName))
                            goto open_file;
                    }
                    // otherwise some unknown error with the file name - just discard the
                    // file name and try again
                    RegCloseKey(hKey);
                    RegDeleteKey(HKEY_CURRENT_USER,
                                 lpszKeyName);
                    szFileName[0]='\0';
                    fNewKey = FALSE;
                    goto try_again;
                }
            }
        }
open_file:
        //
        // now we have the file name, open the property store
        //
        if (HR_FAILED(hResult = OpenPropertyStore(szFileName,
                                        AB_OPEN_ALWAYS,
                                        hWnd, // HWND for potential Message Boxes
                                        &(lpPropertyStore->hPropertyStore))))
        {
            // The above call should always pass unless we ran out of disk space or
            // some such thing ..
            DebugTrace( TEXT("OpenPropertyStore failed\n"));

            if(hResult == MAPI_E_NO_ACCESS)
            {
                sc = GetScode(hResult);
                goto error;
            }

            // There is a chance that this may have failed due to a long file name
            // which the machine could not accept.
            if(lstrlen(szFileName) > 8 + 1 + lstrlen(lpszWABExt)) // 8+.+3
            {
                LPTSTR lpLast = szFileName;
                LPTSTR lpTemp = szFileName;

                while(*lpTemp)
                {
                    if((*lpTemp) == '\\')
                        lpLast = lpTemp;
                    lpTemp = CharNext(lpTemp);
                }

                // lpLast points to the last \ .. everything after this will be the file name
                if(lstrlen(lpLast+1) > 12)
                {
                    // we need to truncate this name
                    *(lpLast+8) = '\0';
                    lstrcat(szFileName, lpszWABExt);
                    hResult = OpenPropertyStore(szFileName,
                                                AB_OPEN_ALWAYS,
                                                hWnd, // HWND for potential Message Boxes
                                                &(lpPropertyStore->hPropertyStore));
                }
            }

            if(HR_FAILED(hResult))
            {
                sc = GetScode(hResult);
                goto error;
            }
        }
    }

out:
    lpPropertyStore->ulRefCount++;

error:
    if (hKey) {
        RegCloseKey(hKey);
    }


    return(sc);
}


/*
 -  ReleaseOutlookStore
 -
 *  Purpose:
 *      Keep track of outlook store dll refcount
 *
 *  Arguments:
 *      lpOutlookStore     OUTLOOK_STORE structure
 *
 *  Returns:
 *      Current reference count.  When 0, unload outlook-wab dll
 *      no longer open.
 *
 */
ULONG ReleaseOutlookStore(HANDLE hPropertyStore, LPOUTLOOK_STORE lpOutlookStore)
{
    if(lpOutlookStore)
    {
        lpOutlookStore->ulRefCount--;

        if(0==lpOutlookStore->ulRefCount)
        {
            LPPTGDATA lpPTGData=GetThreadStoragePointer();
            
            if(pt_bIsWABOpenExSession && hPropertyStore)
            {
                // This is a WABOpenEx session using outlooks storage provider
                LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
                lpWSP->lpVtbl->Release(lpWSP);
            }

            if(lpOutlookStore->hOutlookStore)
            {
                FreeLibrary(lpOutlookStore->hOutlookStore);
                lpOutlookStore->hOutlookStore = NULL;

#if 0
                // @todo [PaulHi] DLL Leak.  Remove this or implement
                // [PaulHi] 3/12/99  @hack Serious HACK warning
                // The Outlook outlwab.dll store module is not unloading some Outlook
                // dlls.  This causes Outlook to get confused about who loaded these dlls
                // and whether Outlook or OE should service MAPI calls.  
                // HACK Forcibly remove these dlls HACK
                // But only if the WAB WASN'T opened by OL process.
                EnterCriticalSection(&csOMIUnload);
                if (!s_bIsReallyOnlyWABOpenExSession)
                {
                    LPCSTR      c_lpszOMI9DLL = "omi9.dll";
                    LPCSTR      c_lpszOMI9PSTDLL = "omipst9.dll";
                    LPCSTR      c_lpszOMINTDLL = "omint.dll";
                    LPCSTR      c_lpszOMINTPSTDLL = "omipstnt.dll";
                    HINSTANCE   hinst;

                    // It is essential to unload the omipst9.dll and omipstnt.dll
                    // modules first because they load the omi9.dll and omint.dll
                    // modules.  The FreeLibary() on the omi9/omint modules should
                    // not be necessary.
                    if ( hinst = GetModuleHandleA(c_lpszOMI9PSTDLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMINTPSTDLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMI9DLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMINTDLL) )
                        FreeLibrary(hinst);
                }
                LeaveCriticalSection(&csOMIUnload);
#endif
            }
        }

        return lpOutlookStore->ulRefCount;
    }

    return 0;
}


/*
 -  OpenAddRefOutlookStore
 -
 *  Purpose:
 *      Open or ref count outlook-wab dll
 *
 *  Arguments:
 *      lpOutlookStore     OUTLOOK_STORE structure
 *
 *  Returns:
 *      
 */
SCODE OpenAddRefOutlookStore(LPOUTLOOK_STORE lpOutlookStore)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(!lpOutlookStore)
        return(MAPI_E_INVALID_PARAMETER);

    if(!lpOutlookStore->ulRefCount)
    {
        TCHAR szOutlWABPath[MAX_PATH];
        *szOutlWABPath = '\0';
        if( !bCheckForOutlookWABDll(szOutlWABPath) ||
            !lstrlen(szOutlWABPath) ||
            !(lpOutlookStore->hOutlookStore = LoadLibrary(szOutlWABPath)) )
            return MAPI_E_NOT_INITIALIZED;

        // Load the Outlook WABStorageProvider Dll Entry Point here

        // First try to load the Unicode version (doesn't exist but we're thinking forward here)
        lpfnWABOpenStorageProvider = (LPWABOPENSTORAGEPROVIDER) GetProcAddress(lpOutlookStore->hOutlookStore, WAB_SPI_ENTRY_POINT_W);
        if(lpfnWABOpenStorageProvider)
            pt_bIsUnicodeOutlook = TRUE;
        else
        {
            pt_bIsUnicodeOutlook = FALSE;
            lpfnWABOpenStorageProvider = (LPWABOPENSTORAGEPROVIDER) GetProcAddress(lpOutlookStore->hOutlookStore, WAB_SPI_ENTRY_POINT);
        }
    }

    if(lpfnWABOpenStorageProvider && lpOutlookStore->hOutlookStore)
    {
        // Tag this thread as a valid Outlook store session
        // If this flag below is false, we willd default to 
        // using the WAB store 
        pt_bIsWABOpenExSession = TRUE; 
    }

    lpOutlookStore->ulRefCount++;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabprint.c ===
/*
 *    wabprint.c
 *
 *    Purpose:
 *        Print Contacts
 *
 *    Owner:
 *        vikramm.
 *
 *  History:
 *
 *      Ported from Athena mailnews\mail\msgprint.cpp 10/30/96
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */


#include <_apipch.h>

// Function prototypes
extern BOOL PrintDlg(LPPRINTDLG lppd);
extern HRESULT PrintDlgEx(LPPRINTDLGEX lppdex);

INT_PTR CALLBACK fnPrintDialogProc( HWND    hDlg, UINT    message, WPARAM    wParam, LPARAM  lParam);
HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle);
void ReleaseWABPrintCallbackObject(LPWABPRINTDIALOGCALLBACK lpWABPCO);
SCODE ScInitPrintInfo(   PRINTINFO * ppi, HWND hwnd, LPTSTR szHeader, RECT * prcBorder, HWND hWndRE);
int GetNumberFromStringResource(int idNumString);
BOOL bCheckForPrintExtensions(LPTSTR lpDLLPath);
HRESULT HrUseWABPrintExtension(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV);


//
// Some string constants used in text formatting
//
const LPTSTR lpszTab = TEXT("\t");
const LPTSTR lpszFlatLine = TEXT("________________________________________________________________");
const LPTSTR lpszSpace = TEXT(" ");


//
// Print options ...
//
enum _PrintRange
{
    rangeAll=0,
    rangeSelected
};

enum _PrintStyles
{
    styleMemo=0,
    styleBusinessCard,
    stylePhoneList
};

static DWORD rgPrintHelpIDs[] =
{
    IDC_PRINT_FRAME_STYLE,  IDH_WAB_COMM_GROUPBOX,
    IDC_PRINT_RADIO_MEMO,   IDH_WAB_PRINT_MEMO,
    IDC_PRINT_RADIO_CARD,   IDH_WAB_PRINT_BIZCARD,
    IDC_PRINT_RADIO_PHONELIST,  IDH_WAB_PRINT_PHONELIST,
    0,0
};


//
// This structure contains information about a specific contact
//
enum _MemoStrings
{
    memoTitleName=0, // the big name that will be displayed based on the current sort settings ..
    memoName,
    memoJobTitle,
    memoDepartment,
    memoOffice,
    memoCompany,
    memoBusinessAddress,        // Don't mess with the order of home and business address tags
    memoBusinessAddressStreet,
    memoBusinessAddressCity,
    memoBusinessAddressState,
    memoBusinessAddressZip,
    memoBusinessAddressCountry,
    memoHomeAddress,
    memoHomeAddressStreet,
    memoHomeAddressCity,
    memoHomeAddressState,
    memoHomeAddressZip,
    memoHomeAddressCountry,
    memoBusinessPhone,      // Dont mess with the phone numbers - they should all be together in this order
    memoBusinessFax,
    memoBusinessPager,
    memoHomePhone,
    memoHomeFax,
    memoHomeCellular,
    memoEmail,
    memoBusinessWebPage,
    memoHomeWebPage,
    memoNotes,
    memoGroupMembers,
    memoMAX
};

typedef struct _MemoInfo
{
    LPTSTR lpszLabel[memoMAX];
    LPTSTR lpsz[memoMAX];
} MEMOINFO, * LPMEMOINFO;


TCHAR szDontDisplayInitials[16];

/*
 * c o n s t a n t s
 */
#define     cTwipsPerInch           1440
#define     cPtsPerInch             72
#ifndef WIN16
#define     INT_MAX                 2147483647
#endif
#define     cySepFontSize(_ppi)     (12 * (_ppi)->sizeInch.cy / cPtsPerInch)

#define     CCHMAX_STRINGRES        MAX_UI_STR


/*
 * m a c r o s
 */
#define ScPrintRestOfPage(_ppi,_fAdvance)    ScGetNextBand( (_ppi), (_fAdvance))


/*
 * g l o b a l s
 */
static TCHAR    szDefFont[]  = TEXT("Arial");
static TCHAR    szThaiDefFont[]  = TEXT("Cordia New");
static BOOL     s_bUse20 = TRUE;

// Default margin settings
static RECT        g_rcBorder =
{
    cTwipsPerInch * 1 / 2,                    // distance from left
    cTwipsPerInch * 3 / 4,                    // distance from top
    cTwipsPerInch * 1 / 2,                    // distance from right
    cTwipsPerInch * 1 / 2                    // distance from bottom
};


/*
 * p r o t o t y p e s
 */
SCODE ScGetNextBand( PRINTINFO * ppi, BOOL fAdvance );
LONG LGetHeaderIndent();




//$$/////////////////////////////////////////////////////////////////////////////
//
// CleanPrintAddressString
//
// The Home and Business addresses are FormatMessaged and may contain redundant
// spaces and line breaks if input data is incomplete
// We strip out those spaces etc
//
/////////////////////////////////////////////////////////////////////////////////
void CleanPrintAddressString(LPTSTR szAddress)
{
    LPTSTR lpTemp = szAddress;
    LPTSTR lpTemp2 = NULL;

    // The original template for styleMemo is
    //       TEXT("%1\r\n\t%2 %3 %4\r\n\t%5")
    //
    // Worst case, we will get
    //       TEXT("\r\n\t   \r\n\t")
    //
    // We want to reduce double spaces to single space
    // We want to strip out empty line breaks
    // We want to strip out redundant tabs
    //
    // For style styleBusinessCard, there are no tabs and we
    //  strip out redundancies accordingly
    //

    TrimSpaces(szAddress);

    // Squish multiple space blocks to a single space
    while (*lpTemp) {
        if (IsSpace(lpTemp) && IsSpace(CharNext(lpTemp))) {
            // There are >= 2 spaces starting at lpTemp
            lpTemp2 = CharNext(lpTemp); // point to 2nd space
            lstrcpy(lpTemp, lpTemp2);
            continue;   // Cycle again with same lpTemp
        }
        lpTemp = CharNext(lpTemp);
    }

    TrimSpaces(szAddress);

    lpTemp = szAddress;

    // Dont let it start with a line break
    while(*lpTemp == '\r' && *(lpTemp+1) == '\n')
    {
        lpTemp2 = lpTemp+2;
        if(*lpTemp2 == '\t')
            lpTemp2 = CharNext(lpTemp2);
        lstrcpy(lpTemp, lpTemp2);
        TrimSpaces(lpTemp);
    }

    // Dont let it end with a line break
    if(lstrlen(szAddress))
    {
        int nLen = lstrlen(szAddress);
        lpTemp = szAddress;
        while(  (*(lpTemp + nLen - 3)=='\r' && *(lpTemp + nLen - 2)=='\n') ||
                (*(lpTemp + nLen - 2)=='\r' && *(lpTemp + nLen - 1)=='\n') )
        {
            if(*(lpTemp + nLen -3) == '\r')
                *(lpTemp + nLen - 3)='\0';
            else
                *(lpTemp + nLen - 2)='\0';

            TrimSpaces(szAddress);
            nLen = lstrlen(szAddress);
            lpTemp = szAddress;
        }
    }

    TrimSpaces(szAddress);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
//  AddTabsToLineBreaks - For the memo format, our paragraph format for the
//          data on the right side gives each paragraph a default indentation
//          of 1 tab space after the first line. However if the data contains
//          line breaks, the paragraph format gets messed up. So we take
//          a data string and insert a tab after each line break. There are
//          only a few data values such as Address and Notes that need this
//          multi-line treatment.
//
////////////////////////////////////////////////////////////////////////////
void AddTabsToLineBreaks(LPTSTR * lppsz)
{
    ULONG nBreaks = 0, nLen = 0;
    LPTSTR lpTemp,lpStart;
    LPTSTR lpsz;

    if(!lppsz || !(*lppsz))
        goto out;

    lpTemp = *lppsz;

    // count the number of breaks which are not followed by tabs
    while(*lpTemp)
    {
        if(*lpTemp == '\n' && *(lpTemp+1) != '\t')
            nBreaks++;
        lpTemp = CharNext(lpTemp);
    }

    if(!nBreaks)
        goto out;

    // Allocate a new string
    lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(*lppsz)+1+nBreaks));
    if(!lpsz)
        goto out;

    lpTemp = *lppsz;
    lpStart = lpTemp;

    lstrcpy(lpsz, szEmpty);

    // Copy over the old string into the new with appropriate breaks
    while(*lpTemp)
    {
        if((*lpTemp == '\n') && (*(lpTemp+1)!='\t'))
        {
            *lpTemp = '\0';
            lstrcat(lpsz, lpStart);
            lstrcat(lpsz, TEXT("\n"));
            lstrcat(lpsz, lpszTab);
            lpStart = lpTemp+1;
            lpTemp = lpStart;
        }
        else
            lpTemp = CharNext(lpTemp);
    }

    if(lstrlen(lpStart))
        lstrcat(lpsz,lpStart);

    LocalFreeAndNull(lppsz);
    *lppsz = lpsz;

out:
    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
//  FreeMemoInfoStruct - Frees the MemoInfo struct allocated strings
//
////////////////////////////////////////////////////////////////////////////
void FreeMemoInfoStruct(LPMEMOINFO lpMI)
{
    int i;
    for(i=0;i<memoMAX;i++)
    {
        if(lpMI->lpsz[i] && (lpMI->lpsz[i] != szEmpty))
#ifdef WIN16
            if(i == memoBusinessAddress || i == memoHomeAddress)
                FormatMessageFreeMem(lpMI->lpsz[i]);
            else
#endif
            LocalFree(lpMI->lpsz[i]);
        if(lpMI->lpszLabel[i] && (lpMI->lpszLabel[i] != szEmpty))
            LocalFree(lpMI->lpszLabel[i]);
    }
}


//$$////////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetMemoInfoStruct - Parses the data in a PropArray and puts it into a Memo_Info struch along with
//      the propert labels, bsaed on the given style
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
void GetMemoInfoStruct(LPADRBOOK lpAdrBook,
                       ULONG ulcPropCount,
                       LPSPropValue lpPropArray,
                       DWORD dwStyle,
                       LPMEMOINFO lpMI,
                       BOOL bCurrentSortIsByLastName)
{
    ULONG i,j;
    TCHAR szBuf[MAX_UI_STR];

    LPTSTR lpszFirst = NULL;
    LPTSTR lpszMiddle = NULL;
    LPTSTR lpszLast = NULL;
    LPTSTR lpszDisplayName = NULL;
    LPTSTR lpszCompany = NULL;
    LPTSTR lpszNickName = NULL;

    BOOL bIsGroup = FALSE;
    int len = 0;

    if(!lpPropArray || !ulcPropCount)
        goto out;

    // special case initialization
    for(j=memoHomeAddressStreet;j<=memoHomeAddressCountry;j++)
    {
        lpMI->lpsz[j]=szEmpty;
    }

    for(j=memoBusinessAddressStreet;j<=memoBusinessAddressCountry;j++)
    {
        lpMI->lpsz[j]=szEmpty;
    }

    // Find out if this is a mailuser or a group
    for(i=0;i<ulcPropCount;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_OBJECT_TYPE)
        {
            bIsGroup = (lpPropArray[i].Value.l == MAPI_DISTLIST);
            break;
        }
    }


    for(i=0;i<ulcPropCount;i++)
    {
        LPTSTR lpszData = NULL;
        int nIndex = -1;
        int nStringID = 0;

        switch(lpPropArray[i].ulPropTag)
        {
        case PR_DISPLAY_NAME:
            nIndex = memoName;
            if(bIsGroup)
                nStringID = idsPrintGroupName;
            else
                nStringID = idsPrintDisplayName;
            lpszDisplayName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_NICKNAME:
            lpszNickName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_GIVEN_NAME:
            lpszFirst = lpPropArray[i].Value.LPSZ;
            break;
        case PR_SURNAME:
            lpszLast = lpPropArray[i].Value.LPSZ;
            break;
        case PR_MIDDLE_NAME:
            lpszMiddle = lpPropArray[i].Value.LPSZ;
            break;
        case PR_TITLE:
            nIndex = memoJobTitle;
            nStringID = idsPrintTitle;
            break;
        case PR_DEPARTMENT_NAME:
            nIndex = memoDepartment;
            nStringID = idsPrintDepartment;
            break;
        case PR_OFFICE_LOCATION:
            nIndex = memoOffice;
            nStringID = idsPrintOffice;
            break;
        case PR_COMPANY_NAME:
            lpszCompany = lpPropArray[i].Value.LPSZ;
            nIndex = memoCompany;
            nStringID = idsPrintCompany;
            break;

        case PR_BUSINESS_ADDRESS_STREET:
            nIndex = memoBusinessAddressStreet;
            break;
        case PR_BUSINESS_ADDRESS_CITY:
            nIndex = memoBusinessAddressCity;
            break;
        case PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE:
            nIndex = memoBusinessAddressState;
            break;
        case PR_BUSINESS_ADDRESS_POSTAL_CODE:
            nIndex = memoBusinessAddressZip;
            break;
        case PR_BUSINESS_ADDRESS_COUNTRY:
            nIndex = memoBusinessAddressCountry;
            break;

        case PR_HOME_ADDRESS_STREET:
            nIndex = memoHomeAddressStreet;
            break;
        case PR_HOME_ADDRESS_CITY:
            nIndex = memoHomeAddressCity;
            break;
        case PR_HOME_ADDRESS_STATE_OR_PROVINCE:
            nIndex = memoHomeAddressState;
            break;
        case PR_HOME_ADDRESS_POSTAL_CODE:
            nIndex = memoHomeAddressZip;
            break;
        case PR_HOME_ADDRESS_COUNTRY:
            nIndex = memoHomeAddressCountry;
            break;

        case PR_BUSINESS_TELEPHONE_NUMBER:
            nIndex = memoBusinessPhone;
            nStringID = (dwStyle == styleMemo) ? idsPrintBusinessPhone : idsPrintBusCardBusinessPhone;
            break;
         case PR_BUSINESS_FAX_NUMBER:
            nIndex = memoBusinessFax;
            nStringID = (dwStyle == styleMemo) ? idsPrintBusinessFax : idsPrintBusCardBusinessFax;
            break;
        case PR_PAGER_TELEPHONE_NUMBER:
            nIndex = memoBusinessPager;
            nStringID = idsPrintBusinessPager;
            break;
        case PR_HOME_TELEPHONE_NUMBER:
            nIndex = memoHomePhone;
            nStringID = (dwStyle == styleMemo) ? idsPrintHomePhone : idsPrintBusCardHomePhone;
            break;
        case PR_HOME_FAX_NUMBER:
            nIndex = memoHomeFax;
            nStringID = idsPrintHomeFax;
            break;
        case PR_CELLULAR_TELEPHONE_NUMBER:
            nIndex = memoHomeCellular;
            nStringID = idsPrintHomeCellular;
            break;
        case PR_BUSINESS_HOME_PAGE:
            nIndex = memoBusinessWebPage;
            nStringID = idsPrintBusinessWebPage;
            break;
        case PR_PERSONAL_HOME_PAGE:
            nIndex = memoHomeWebPage;
            nStringID = idsPrintHomeWebPage;
            break;
        case PR_COMMENT:
            nIndex = memoNotes;
            nStringID = idsPrintNotes;
            break;
        default:
            continue;
            break;
        }

        if(nIndex != -1)
        {
            if(nStringID != 0)
            {
                LoadString(hinstMapiX, nStringID, szBuf, CharSizeOf(szBuf));
                lpMI->lpszLabel[nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                if(!lpMI->lpszLabel[nIndex])
                    goto out;
                lstrcpy(lpMI->lpszLabel[nIndex], szBuf);
            }

            lpMI->lpsz[nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ)+1));
            if(!lpMI->lpsz[nIndex])
                goto out;
            lstrcpy(lpMI->lpsz[nIndex], lpPropArray[i].Value.LPSZ);
        }
    }

    // Email is a special case since a contact can hace PR_EMAIL_ADDRESS or
    // PR_CONTACT_EMAIL_ADDRESSES or both or neither
    // We first look for PR_CONTACT_EMAIL_ADDRESS .. if not found, then for
    // PR_EMAIL_ADDRESS
    {
        BOOL bMVEmail = FALSE;
        LPTSTR lpszEmails = NULL;

        for(i=0;i<ulcPropCount;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
            {
                ULONG k,ulBufSize=0;
                for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                {
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.MVSZ.LPPSZ[k])+1);
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szCRLF)+1);
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpszTab)+1);
                }
                ulBufSize -= sizeof(TCHAR)*(lstrlen(szCRLF)+1);
                ulBufSize -= sizeof(TCHAR)*(lstrlen(lpszTab)+1);

                lpszEmails = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                if(!lpszEmails)
                {
                    DebugPrintError(( TEXT("Local Alloc Failed\n")));
                    goto out;
                }
                lstrcpy(lpszEmails, szEmpty);
                for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                {
                    if(k>0)
                    {
                        lstrcat(lpszEmails, szCRLF);
                        lstrcat(lpszEmails, lpszTab);
                    }
                    lstrcat(lpszEmails,lpPropArray[i].Value.MVSZ.LPPSZ[k]);
                }

                bMVEmail = TRUE;
                break;
            }
        }

        if(!bMVEmail)
        {
            // No CONTACT_EMAIL_ADDRESSES
            // Should look for email address
            for(i=0;i<ulcPropCount;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_EMAIL_ADDRESS)
                {
                    lpszEmails = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ)+1));
                    if(!lpszEmails)
                        goto out;
                    lstrcpy(lpszEmails, lpPropArray[i].Value.LPSZ);
                    break;
                }
            }
        }

        if(lpszEmails)
        {
            lpMI->lpsz[memoEmail] = lpszEmails;

            LoadString(hinstMapiX, idsPrintEmail, szBuf, CharSizeOf(szBuf));

            lpMI->lpszLabel[memoEmail] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
            if(!lpMI->lpszLabel[memoEmail])
                goto out;
            lstrcpy(lpMI->lpszLabel[memoEmail], szBuf);
        }
    }

    //Now we have to format the Home and Business Addresses
    //

    {
        LPTSTR lpszData[5];

        for(i=memoHomeAddressStreet;i<=memoHomeAddressCountry;i++)
        {
            // Win9x bug FormatMessage cannot have more than 1023 chars
            len += lstrlen(lpMI->lpsz[i]);
            if(len < 1023)
                lpszData[i-memoHomeAddressStreet] = lpMI->lpsz[i];
            else
                lpszData[i-memoHomeAddressStreet] = NULL;
        }
        for(i=memoHomeAddressStreet;i<=memoHomeAddressCountry;i++)
        {
            if(lpMI->lpsz[i] && lpMI->lpsz[i] != szEmpty)
            {
                LPTSTR lpszHomeAddress = NULL;
                TCHAR szBuf[MAX_UI_STR];

                int nStringID = (dwStyle == styleMemo) ? idsPrintAddressTemplate : idsPrintBusCardAddressTemplate ;

                LoadString(hinstMapiX, nStringID, szBuf, CharSizeOf(szBuf));

                if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf,
                      0,                    // stringid
                      0,                    // dwLanguageId
                      (LPTSTR)&lpszHomeAddress,     // output buffer
                      0,                    //MAX_UI_STR
                      (va_list *)&lpszData[0]))
                {
                        CleanPrintAddressString(lpszHomeAddress);
                        lpMI->lpsz[memoHomeAddress] = lpszHomeAddress;
                        szBuf[0]='\0';
                        LoadString(hinstMapiX, idsPrintHomeAddress, szBuf, CharSizeOf(szBuf));
                        lpMI->lpszLabel[memoHomeAddress] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                        if(!lpMI->lpszLabel[memoHomeAddress])
                            goto out;
                        lstrcpy(lpMI->lpszLabel[memoHomeAddress], szBuf);
                        break;
                }

            }
        }

        len = 0;
        for(i=memoBusinessAddressStreet;i<=memoBusinessAddressCountry;i++)
        {
            // Win9x bug FormatMessage cannot have more than 1023 chars
            len += lstrlen(lpMI->lpsz[i]);
            if(len < 1023)
                lpszData[i-memoBusinessAddressStreet] = lpMI->lpsz[i];
            else
                lpszData[i-memoBusinessAddressStreet] = NULL;
        }
        for(i=memoBusinessAddressStreet;i<=memoBusinessAddressCountry;i++)
        {
            if(lpMI->lpsz[i] && lpMI->lpsz[i] != szEmpty)
            {
                LPTSTR lpszBusinessAddress = NULL;
                TCHAR szBuf[MAX_UI_STR];
                int nStringID = (dwStyle == styleMemo) ? idsPrintAddressTemplate : idsPrintBusCardAddressTemplate ;
                TCHAR szTmp[MAX_PATH], *lpszTmp;

                LoadString(hinstMapiX, nStringID, szBuf, CharSizeOf(szBuf));

                if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf,
                      0,                    // stringid
                      0,                    // dwLanguageId
                      (LPTSTR)&lpszBusinessAddress,     // output buffer
                      0,                    //MAX_UI_STR
                      (va_list *)&lpszData[0]))
                {
                        CleanPrintAddressString(lpszBusinessAddress);
                        lpMI->lpsz[memoBusinessAddress] = lpszBusinessAddress;
                        szBuf[0]='\0';
                        LoadString(hinstMapiX, idsPrintBusinessAddress, szBuf, CharSizeOf(szBuf));
                        lpMI->lpszLabel[memoBusinessAddress] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                        if(!lpMI->lpszLabel[memoBusinessAddress])
                            goto out;
                        lstrcpy(lpMI->lpszLabel[memoBusinessAddress], szBuf);
                        break;
                }

            }
        }


    }

    // Set the name that will be printed out for each entry
    // This is dependent on the current view and on the local language setting
    {
        LPTSTR lpszTmp = NULL;

        if( bCurrentSortIsByLastName != bDNisByLN)
        {
            // for auto add to WABs we dont have all this info .. so
            // if we just have a displayname we use it as it is
            if(lpszFirst || lpszMiddle || lpszLast || lpszNickName || (lpszCompany && !lpszDisplayName))
            {
                if(SetLocalizedDisplayName(lpszFirst,
                                           lpszMiddle,
                                           lpszLast,
                                           lpszCompany,
                                           lpszNickName,
                                           NULL, //&szBuf,
                                           0,
                                           bCurrentSortIsByLastName,
                                           NULL,
                                           &lpszTmp))
                {
                    lpMI->lpsz[memoTitleName]=lpszTmp;
                }
            }
        }
        if(!lpMI->lpsz[memoTitleName])
        {
            // use whatever DisplayName we have
            lpMI->lpsz[memoTitleName] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszDisplayName)+1));
            if(!lpMI->lpsz[memoTitleName])
                goto out;
            lstrcpy(lpMI->lpsz[memoTitleName],lpszDisplayName);
        }
    }

    if(bIsGroup)
    {
        LPTSTR lpszMembers = NULL;
        ULONG nLen = 0;

        // Get the group members
        for(i=0;i<ulcPropCount;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS )
            {
                // Look at each entry in the PR_WAB_DL_ENTRIES.
                for (j = 0; j < lpPropArray[i].Value.MVbin.cValues; j++)
                {
                    ULONG cbEID = lpPropArray[i].Value.MVbin.lpbin[j].cb;
                    LPENTRYID lpEID = (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[j].lpb;
                    ULONG ulcProps=0;
                    LPSPropValue lpProps=NULL;
                    LPTSTR lpszName = NULL;
                    ULONG k;

                    if (HR_FAILED(  HrGetPropArray( lpAdrBook,NULL,cbEID,lpEID,MAPI_UNICODE,&ulcProps,&lpProps)))
                    {
                        DebugPrintError(( TEXT("HrGetPropArray failed\n")));
                        continue;
                    }

                    for(k=0;k<ulcProps;k++)
                    {
                        if(lpProps[k].ulPropTag == PR_DISPLAY_NAME)
                        {
                            lpszName = lpProps[k].Value.LPSZ;
                            break;
                        }
                    }

                    if(lpszName)
                    {
                        LPTSTR lpsz;
                        if(!lpszMembers)
                            nLen = 0;
                        else
                        {
                            nLen = lstrlen(lpszMembers)+1;
                            nLen += lstrlen(lpszTab) + lstrlen(szCRLF) + 1;
                        }

                        nLen += lstrlen(lpszName)+1;

                        lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*nLen);
                        if(!lpsz)
                        {
                            if(lpProps)
                                MAPIFreeBuffer(lpProps);
                            goto out;
                        }

                        *lpsz='\0';
                        if(lpszMembers)
                        {
                            lstrcpy(lpsz,lpszMembers);
                            lstrcat(lpsz,szCRLF);
                            lstrcat(lpsz,lpszTab);
                        }
                        lstrcat(lpsz,lpszName);
                        LocalFreeAndNull(&lpszMembers);
                        lpszMembers = lpsz;
                    }

                    if(lpProps)
                        MAPIFreeBuffer(lpProps);
                } // for(j...
            }
        } // for(i...

        if(lpszMembers)
        {
            szBuf[0]='\0';
            LoadString(hinstMapiX, idsPrintGroupMembers, szBuf, CharSizeOf(szBuf));
            lpMI->lpszLabel[memoGroupMembers] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
            if(!lpMI->lpszLabel[memoGroupMembers])
                goto out;
            lstrcpy(lpMI->lpszLabel[memoGroupMembers], szBuf);
            lpMI->lpsz[memoGroupMembers]=lpszMembers;
        }
    }

    //Speacial case formatting of multiline data
    if(dwStyle == styleMemo)
    {
        AddTabsToLineBreaks(&(lpMI->lpsz[memoNotes]));
        AddTabsToLineBreaks(&(lpMI->lpsz[memoHomeAddress]));
        AddTabsToLineBreaks(&(lpMI->lpsz[memoBusinessAddress]));
    }

out:
    // special case uninitialization
    for(j=memoHomeAddressStreet;j<=memoHomeAddressCountry;j++)
    {
        if(lpMI->lpsz[j] && (lpMI->lpsz[j] != szEmpty))
            LocalFreeAndNull(&(lpMI->lpsz[j]));
    }

    for(j=memoBusinessAddressStreet;j<=memoBusinessAddressCountry;j++)
    {
        if(lpMI->lpsz[j] && (lpMI->lpsz[j] != szEmpty))
            LocalFreeAndNull(&(lpMI->lpsz[j]));
    }

    return;
}

/*
 *        NTwipsToPixels
 *
 *        Purpose:
 *            Converts a measurement in twips into pixels
 *
 *        Arguments:
 *            nTwips                    the value to be converted
 *            cPixels                    number of pixels per inch
 *
 *        Returns:
 *            Returns a int representing the number of pixels in nTwips
 */
int NTwipsToPixels(int nTwips, int cPixelsPerInch)
{
    LONG lT = (LONG) nTwips * (LONG) cPixelsPerInch / (LONG) cTwipsPerInch;

    return (int) lT;
}

/*
 *      LPixelsToTwips
 *
 *      Purpose:
 *          Converts a measurement in pixles into twips
 *
 *      Arguments:
 *          nPixels                 the value to be converted
 *          cPixels                 number of pixels per inch
 *
 *      Returns:
 *          Returns a int representing the number of pixels in nTwips
 */
LONG LPixelsToTwips(int nPixels, int cPixelsPerInch)
{

    LONG lT = (LONG) nPixels * (LONG) cTwipsPerInch / (LONG) cPixelsPerInch;

    return lT;
}


/*
 *        PrintPageNumber
 *
 *        Purpose:
 *            To print the page number for each page
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *
 *        Returns:
 *            SCODE indicating success or failure.
 *            Currently always return S_OK
 */
void PrintPageNumber(PRINTINFO * ppi)
{
    RECT        rcExt;
    HFONT        hfontOld;
    TCHAR        szT[20];

    DebugPrintTrace(( TEXT("PrintPageNumber\n")));

    // Find out how much space our text take will take
    rcExt = ppi->rcBand;
    rcExt.top = ppi->yFooter;
    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontPlain);
    DrawText(ppi->hdcPrn, szT, wsprintf(szT, ppi->szPageNumber,
                ppi->lPageNumber), &rcExt, DT_CENTER);
    SelectObject(ppi->hdcPrn, hfontOld);

}



/*
 *        ScGetNextBand
 *
 *        Purpose:
 *            Retrieves the next band to print on. Adjusts the band to conform
 *            to the margins established in the PRINTINFO structure. Bumps up
 *            the page number as appropriate.
 *
 *        Arguments:
 *            ppi                        print information
 *            fAdvance                flag whether to move to the next page
 *
 *        Returns:
 *            SCODE indicating the success or failure
 */
SCODE ScGetNextBand(PRINTINFO * ppi, BOOL fAdvance)
{
    SCODE    sc = S_OK;
    int        nCode;

    DebugPrintTrace(( TEXT("ScGetNextBand\n")));

    // Call the abort proc to see if the user wishes to stop

    if (!ppi->pfnAbortProc(ppi->hdcPrn, 0))
    {
        sc=E_FAIL;
        nCode = AbortDoc(ppi->hdcPrn);
        if(nCode < 0)
        {
            DebugPrintTrace(( TEXT("Abort Doc error: %d\n"),GetLastError()));
            ShowMessageBox(ppi->hwndDlg, idsPrintJobCannotStop, MB_OK | MB_ICONEXCLAMATION);
        }
        goto CleanUp;
    }

    // brettm:
    // USE_BANDING stuff removed, as we're always on Win32

    // End the previous page
    if (ppi->lPageNumber)
    {
        nCode = EndPage(ppi->hdcPrn);
        DebugPrintTrace(( TEXT("+++++++++EndPage\n")));
        if (nCode <= 0)
        {
        sc=E_FAIL;
        goto CleanUp;
        }
    }

    if (fAdvance)
    {
        nCode = StartPage(ppi->hdcPrn);
        DebugPrintTrace(( TEXT("+++++++++StartPage\n")));
        // Start a new page
        if (nCode <= 0)
            {
            sc=E_FAIL;
            goto CleanUp;
            }
        // Let the entire page be the band
        ppi->rcBand        = ppi->rcMargin;
        ppi->fEndOfPage    = TRUE;                // end of page!

        // Bump up the page number and print
        ppi->lPrevPage = ppi->lPageNumber++;
        PrintPageNumber(ppi);
        {
            TCHAR szBuf[MAX_UI_STR];
            TCHAR szString[MAX_UI_STR];
            LoadString(hinstMapiX, idsPrintingPageNumber, szString, CharSizeOf(szString));
            wsprintf(szBuf, szString, ppi->lPageNumber);
            SetPrintDialogMsg(0, 0, szBuf);
        }
    }

CleanUp:
    return sc;
}




/*
 *  LGetHeaderIndent
 *
 *  Purpose:
 *      Retrieves from the resource file the suggested indent overhang for
 *      headers.
 *
 *  Arguments:
 *      none.
 *
 *  Returns:
 *      LONG            The suggested indent overhang in twips
 */
LONG LGetHeaderIndent()
{
    LONG    lOver = 1440;               // default
    //TCHAR    szT[10];

    //if (LoadString(hinstMapiX, idsHeaderIndent, szT, CharSizeOf(szT)))
    //    lOver = atoi(szT);
    return lOver;
}















//$$////////////////////////////////////////////////////////////////////////////////
//
//  AppendText - Simple routine that appends a given string to the End of the text
//      in the given richedit control
//
////////////////////////////////////////////////////////////////////////////////////
void AppendText(HWND hWndRE, LPTSTR lpsz)
{
    // Set the insertion point to the end of the current text
    int nLastChar =  (int) SendMessage(hWndRE, WM_GETTEXTLENGTH, 0, 0);
    CHARRANGE charRange = {0};

    charRange.cpMin = charRange.cpMax = nLastChar + 1;
    SendMessage(hWndRE, EM_EXSETSEL, 0, (LPARAM) &charRange);

    // Insert the text
    // [PaulHi] 7/7/99  Raid 82350  RichEdit 1.0 can't handle Unicode
    // strings even though the window is created Unicode.
    if (s_bUse20)
    {
        // RichEdit 2.0
        SendMessage(hWndRE, EM_REPLACESEL, (WPARAM) FALSE, (LPARAM) lpsz);
    }
    else
    {
        // RichEdit 1.0
        LPSTR   lpszTemp = ConvertWtoA(lpsz);

        Assert(lpszTemp);
        if (lpszTemp)
            SendMessageA(hWndRE, EM_REPLACESEL, (WPARAM) FALSE, (LPARAM) lpszTemp);

        LocalFreeAndNull(&lpszTemp);
    }

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// ParaCmd - Sets/Unsets paragraph formatting in the Rich Edit Control
//
// We want all the information on the right side to be indented
// so we will put an indent on that information and remove it when
// adding labels
////////////////////////////////////////////////////////////////////////////
void ParaCmd(HWND hWndRE, BOOL bIndent)
{
    // We want no indentation on the first line and we want a
    // 1 tab indentation on the second line onwards

    PARAFORMAT pf ={0};
    int nTabStop = (int) (1.5 * cTwipsPerInch);

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_OFFSET  |
                PFM_TABSTOPS |
                PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);


    pf.wNumbering = 0;


    if (bIndent)
    {
        //pf.dxStartIndent = nTabStop;
        pf.dxOffset = nTabStop;
        pf.cTabCount = 1;
        pf.rgxTabs[0] = nTabStop;
    }
    else
    {
        //pf.dxStartIndent = 0;
        pf.dxOffset = 0;
        pf.cTabCount = 1;
        pf.rgxTabs[0] = 720; //seems to be the default = 0.5 inches
    }

    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);
    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// BoldCmd - Sets/Unsets current font to bold in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void BoldCmd(HWND hWndRE, BOOL bBold)
{
    CHARFORMAT cf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_BOLD;

    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

    if (bBold)
        cf.dwEffects = cf.dwEffects | CFE_BOLD;
    else
        cf.dwEffects = cf.dwEffects & ~CFE_BOLD;

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &cf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// TitleCmd - Sets/Unsets title text (BOLD, Bigger) in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void TitleCmd(HWND hWndRE, BOOL bBold)
{
    CHARFORMAT cf = {0};
    PARAFORMAT pf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_BOLD /*| CFM_ITALIC*/ | CFM_SIZE;

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);
    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

    if (bBold)
    {
        cf.dwEffects = cf.dwEffects | CFE_BOLD; // | CFE_ITALIC;
        cf.yHeight += 50;
        pf.wNumbering = PFN_BULLET;
    }
    else
    {
        cf.dwEffects = cf.dwEffects & ~CFE_BOLD;
//        cf.dwEffects = cf.dwEffects & ~CFE_ITALIC;
        cf.yHeight -= 50;
        pf.wNumbering = 0;
    }

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &cf);
    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// ReduceFontCmd - Reduces the displayed font in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void ReduceFontCmd(HWND hWndRE, BOOL bReduce, int nReduceBy, BOOL bSelectionOnly)
{
    CHARFORMAT cf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_SIZE;

    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) bSelectionOnly, (LPARAM) &cf);

    if (bReduce)
        cf.yHeight -= nReduceBy; //40;
    else
        cf.yHeight += nReduceBy; //40;

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) bSelectionOnly ? SCF_SELECTION : SCF_DEFAULT, (LPARAM) &cf);

    return;
}


//$$////////////////////////////////////////////////////////////////////////
//
// SetTabsCmd - Sets and Unsets the Tabs in the RichEdit Control
//
////////////////////////////////////////////////////////////////////////////
void SetTabsCmd(HWND hWndRE, BOOL bSet)
{
    PARAFORMAT pf ={0};
    int nTabStop = (int) (1.5 * cTwipsPerInch);
    int j;

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_TABSTOPS | PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);

    pf.wNumbering = 0;

    if (bSet)
    {
        for(j=0;j<5;j++)
            pf.rgxTabs[j] = nTabStop;
    }
    else
    {
        for(j=0;j<5;j++)
            pf.rgxTabs[j] = 720;
    }

    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStylePhoneList - Fills the Rich edit control with info from MI as per the
//                      Phone List style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//  lpszPrevEntry - the first TCHAR of the previous entry - this lets us break the list
//      alphabetically - this points to a preallocated buffer
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStylePhoneList(HWND hWndRE, MEMOINFO MI, LPTSTR lpszPrevEntry)
{
    // We want an extra gap between certain groups of information
    // we'll track these groups using these BOOLs
    ULONG i,j,k;

    TCHAR szBufChar1[16];
    TCHAR szBufChar2[16];
    LPTSTR lpTemp = NULL;
    int nReduceFontBy = GetNumberFromStringResource(idsPhoneFontReduceBy);


    // First we compare the first character of the current string with the previous
    // string - if it is the same, then we do nothing - if it different, we ouput
    // the lower case TCHAR as a heading for the phone directory
    //
    // If the character is not alphanumeric, we ignore it as a heading (e.g. ' )

    // Bug: 25710
    // We ignore these initialls totally if localizers have set idsDontDisplayInitials
    //  these initials to anything other than 0 because in some FE languages
    //  names have double characters in them and they look strange with a single
    //  character up front
    if(szDontDisplayInitials[0] == '0')
    {
        lstrcpy(szBufChar1, lpszPrevEntry);

        if(lstrlen(MI.lpsz[memoTitleName]) > 16)
        {
            ULONG iLen = TruncatePos(MI.lpsz[memoTitleName], 16-1);
            CopyMemory(szBufChar2, MI.lpsz[memoTitleName], sizeof(TCHAR)*iLen);
            szBufChar2[iLen]='\0';
        }
        else
            lstrcpy(szBufChar2, MI.lpsz[memoTitleName]);

/***********
    // Bug 14615 - this alphanumeric filtering doesnt work for DBCS and FE names
    //

    // Ignore all non-alpha numeric characters
    lpTemp = szBufChar2;
    {
        //Temp Hack
        TCHAR szTemp[16];
        LPTSTR lpTemp2 = NULL;
        lstrcpy(szTemp, lpTemp);
        lpTemp2 = CharNext(szTemp);
        *lpTemp2 = '\0';
        while(lpTemp && lstrlen(lpTemp))
        {
            if(IsCharAlphaNumeric(szTemp[0]))
                break;
            lpTemp = CharNext(lpTemp);
            lstrcpy(szTemp, lpTemp);
            lpTemp2 = CharNext(szTemp);
            *lpTemp2 = '\0';
        }
    }
    if(lpTemp != szBufChar2)
        lstrcpy(szBufChar2, lpTemp);
***************/


        // Isolate the first TCHAR of the above strings
        lpTemp = CharNext(szBufChar1);
        *lpTemp = '\0';
        lpTemp = CharNext(szBufChar2);
        *lpTemp = '\0';

        // Compare these two characters
        CharLower(szBufChar1);
        CharLower(szBufChar2);

        if(lstrcmp(szBufChar1, szBufChar2))
        {
            // They are different

            // Add the TCHAR as a title string
            AppendText(hWndRE, szCRLF);
            TitleCmd(hWndRE, TRUE);
            BoldCmd(hWndRE, TRUE);
            AppendText(hWndRE, lpszSpace);
            AppendText(hWndRE, szBufChar2);
            AppendText(hWndRE, szCRLF);
            TitleCmd(hWndRE, FALSE);
            BoldCmd(hWndRE, FALSE);
            ParaCmd(hWndRE, TRUE);
            AppendText(hWndRE, lpszFlatLine);
            AppendText(hWndRE, szCRLF);
            AppendText(hWndRE, szCRLF);
            ParaCmd(hWndRE, FALSE);

            lstrcpy(lpszPrevEntry, szBufChar2);
        }
    } //dontdisplayinitials

    ReduceFontCmd(hWndRE, TRUE, nReduceFontBy, TRUE);
    SetTabsCmd(hWndRE, TRUE);


    // Figure out how much space the name will take up ...
    {
        TCHAR szBuf[MAX_PATH];
        int nMaxTabs = 2;
        int nTabStop = (int)(1.5 * cTwipsPerInch);
        int MaxWidth = nMaxTabs * nTabStop;
        int sizeCxTwips;
        int PixelsPerInch;

        int nLen = lstrlen(MI.lpsz[memoTitleName]);
        SIZE size = {0};
        HDC hdc = GetDC(hWndRE);

        {
            HDC hDC = GetDC(NULL);
            PixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX);
            ReleaseDC(NULL, hDC);
        }


		if (nLen >= MAX_PATH)
		{
		    ULONG iLen = TruncatePos(MI.lpsz[memoTitleName], MAX_PATH-1);
            CopyMemory(szBuf, MI.lpsz[memoTitleName], sizeof(TCHAR)*iLen);
            szBuf[iLen]='\0';
        }
        else
            lstrcpy(szBuf, MI.lpsz[memoTitleName]);

        nLen = lstrlen(szBuf);
        GetTextExtentPoint32(hdc, szBuf, nLen, &size);

        sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);

        // We dont want our displayed name to be more than 2 tabstops
        // so we decide where to truncate the name to fit it on screen
        if(sizeCxTwips > MaxWidth)
        {
            while(sizeCxTwips > MaxWidth)
            {
                nLen--;
		        nLen = TruncatePos(szBuf, nLen);
                szBuf[nLen]='\0';
                nLen = lstrlen(szBuf);
                GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
            }
            // chop of 3 more characters for good measure
            nLen-=3;
		    nLen = TruncatePos(szBuf, nLen);
            szBuf[nLen]='\0';
            nLen = lstrlen(szBuf);
            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
        }


        while((sizeCxTwips < MaxWidth) && (nLen < CharSizeOf(szBuf)-1))
        {
            lstrcat(szBuf, TEXT("."));
            nLen = lstrlen(szBuf);
            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
        }

        lstrcat(szBuf, lpszTab);
        AppendText(hWndRE, szBuf);

        // Now we are ready to tag on the phone numbers
        {
            int nPhoneCount = 0; //counts how many phones there are
            int nPhoneLabelSpaceTwips = GetNumberFromStringResource(idsPhoneTextSpaceTwips); //1150

            for(j=memoBusinessPhone;j<=memoHomeCellular;j++)
            {
                if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
                {
                    if(nPhoneCount != 0)
                    {
                        int k;
                        AppendText(hWndRE, szCRLF);

                        // Bug 73266
                        if(s_bUse20)
                            ReduceFontCmd(hWndRE, TRUE, nReduceFontBy, TRUE);

                        lstrcpy(szBuf, szEmpty);
                        nLen = lstrlen(szBuf);
                        GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                        sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        while((sizeCxTwips < MaxWidth) && (nLen < CharSizeOf(szBuf)-1))
                        {
                            lstrcat(szBuf, lpszSpace);
                            nLen = lstrlen(szBuf);
                            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        }
                        lstrcat(szBuf, lpszTab);
                        AppendText(hWndRE, szBuf);
                    }

                    TrimSpaces(MI.lpszLabel[j]);
                    lstrcpy(szBuf, MI.lpszLabel[j]);

                    nLen = lstrlen(szBuf);
                    GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                    sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);

                    if(sizeCxTwips < nPhoneLabelSpaceTwips)
                    {
                        while((sizeCxTwips < nPhoneLabelSpaceTwips) && (nLen < CharSizeOf(szBuf)-1))
                        {
                            lstrcat(szBuf, lpszSpace);
                            nLen = lstrlen(szBuf);
                            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        }
                        lstrcat(szBuf, lpszTab);
                    }
                    lstrcat(szBuf, MI.lpsz[j]);
                    AppendText(hWndRE, szBuf);
                    nPhoneCount++;
                }
            }
            if(nPhoneCount == 0)
            {
                LoadString(hinstMapiX, idsPrintNoPhone, szBuf, CharSizeOf(szBuf));
                AppendText(hWndRE, szBuf);
            }
        }

        AppendText(hWndRE, szCRLF);

        ReleaseDC(hWndRE, hdc);
    }

    SetTabsCmd(hWndRE, FALSE);
    ReduceFontCmd(hWndRE, FALSE, nReduceFontBy, TRUE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStyleBusinessCard - Fills the Rich edit control with info from MI as per the
//                      business card style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStyleBusinessCard(HWND hWndRE, MEMOINFO MI)
{
    // We want an extra gap between certain groups of information
    // we'll track these groups using these BOOLs
    ULONG i,j,k;
    int nReduceBy = GetNumberFromStringResource(idsBusCardFontReduceBy);

    // Add the contact name as a heading
    //TitleCmd(hWndRE, TRUE);
    BoldCmd(hWndRE, TRUE);
    //AppendText(hWndRE, lpszSpace);
    AppendText(hWndRE, MI.lpsz[memoTitleName]);
    AppendText(hWndRE, szCRLF);
    //TitleCmd(hWndRE, FALSE);
    BoldCmd(hWndRE, FALSE);

    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    AppendText(hWndRE, szCRLF);
    AppendText(hWndRE, szCRLF);
    ParaCmd(hWndRE, FALSE);

    ReduceFontCmd(hWndRE, TRUE, nReduceBy, TRUE);

    for(j=memoName;j<memoMAX;j++)
    {
        if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
        {
            switch(j)
            {
            case memoJobTitle:
            //case memoDepartment:
            //case memoOffice:
            case memoCompany:
            case memoBusinessAddress:
                break;
            case memoEmail:
                // Add the label
                AppendText(hWndRE, MI.lpszLabel[j]);
                AppendText(hWndRE, lpszTab);
                break;
            case memoBusinessWebPage:
            case memoBusinessPhone:
            case memoBusinessFax:
            case memoBusinessPager:
            case memoHomePhone:
            case memoHomeFax:
            case memoHomeCellular:
                // Add the label
                AppendText(hWndRE, MI.lpszLabel[j]);
                AppendText(hWndRE, lpszSpace);
                break;
            default:
                continue;
            }

            // Add the value
            AppendText(hWndRE, MI.lpsz[j]);
            // line break
            AppendText(hWndRE, szCRLF);
        }

    } //for j...

    ReduceFontCmd(hWndRE, FALSE, nReduceBy, TRUE);

    // Closing line
    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    ParaCmd(hWndRE, FALSE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStyleMemo - Fills the Rich edit control with info from MI as per the memo style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//
//
//  The memo style consists of a dump of all the WAB Contacts properties one by one with
//      labels. Some properties are grouped togethor (eg all the phone properties)
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStyleMemo(HWND hWndRE, MEMOINFO MI)
{
    BOOL bGapAddress = FALSE; // a gap before the address fields
    BOOL bGapPhone = FALSE;   // a gap before the phone fields
    BOOL bGapEmail = FALSE;
    BOOL bGapNotes = FALSE;
    BOOL bGapWeb = FALSE;
    ULONG i,j,k;

    // Add the heading
    TitleCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszSpace);
    AppendText(hWndRE, MI.lpsz[memoTitleName]);
    AppendText(hWndRE, szCRLF);
    TitleCmd(hWndRE, FALSE);

    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    AppendText(hWndRE, szCRLF);
    AppendText(hWndRE, szCRLF);
    ParaCmd(hWndRE, FALSE);


    for(j=memoName;j<memoMAX;j++)
    {
        int nLastChar;
        LPTSTR lpSpace = NULL;
        ULONG nLen = 0;

        if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
        {
            // Append an additional space if necessary ..
            switch(j)
            {
            case memoBusinessAddress:
            case memoHomeAddress:
                if(!bGapAddress)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapAddress = TRUE;
                }
                break;
            case memoBusinessPhone:
            case memoBusinessFax:
            case memoBusinessPager:
            case memoHomePhone:
            case memoHomeFax:
            case memoHomeCellular:
                if(!bGapPhone)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapPhone = TRUE;
                }
                break;
            case memoEmail:
                if(!bGapEmail)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapEmail = TRUE;
                }
                break;
            case memoBusinessWebPage:
            case memoHomeWebPage:
            case memoGroupMembers: // stick in group members here to save an extra variable
                if(!bGapWeb)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapWeb = TRUE;
                }
                break;
            case memoNotes:
                if(!bGapNotes)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapNotes = TRUE;
                }
                break;
            } // switch

            // Set the paragraph formating
            ParaCmd(hWndRE, TRUE);
            // Set the current insertion font to bold
            BoldCmd(hWndRE, TRUE);
            // Add the label
            AppendText(hWndRE, MI.lpszLabel[j]);
            BoldCmd(hWndRE, FALSE);
            // Tab
            AppendText(hWndRE, lpszTab);
            // Add the value
            AppendText(hWndRE, MI.lpsz[j]);
            // line break
            AppendText(hWndRE, szCRLF);
            ParaCmd(hWndRE, FALSE);
        }

    } //for j...

    // Closing line
    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    ParaCmd(hWndRE, FALSE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
//  WABFormatData - takes the given information and formats it into the
//      RichEdit Control for subsequent printing ..
//
//  lpIAB - LPADRBOOK pointer
//  hWndParent - HWND of Parent
//  hWndRE - HWDN of rich edit control used for formatting
//  hWndLV - List View containing the items which need to be printed
//  dwRange - Range to print (ALL or SELECTION)
//  dwStyle - Style to print (Phone List, Memo, Business Card)
//  ppi - PRINT INFO struct
//  bCurrentSortIsByLastName - Used to determine whether the names are printed
//      by first name or by last name. Current sort option in the list view decides
//
////////////////////////////////////////////////////////////////////////////////////
BOOL WABFormatData( LPADRBOOK   lpIAB,
                    HWND hWndParent,
                    HWND hWndRE,
                    HWND hWndLV,
                    DWORD dwRange,
                    DWORD dwStyle,
                    PRINTINFO * ppi,
                    BOOL bCurrentSortIsByLastName)
{
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    //LPTSTR lpszPrevEntry = NULL;
    TCHAR szPrevEntry[MAX_DISPLAY_NAME_LENGTH]; //32 chars

    if (!hWndRE || !hWndLV)
        goto out;

    if(ListView_GetItemCount(hWndLV) <= 0)
        goto out;

    if(dwStyle == stylePhoneList)
    {
        LoadString(hinstMapiX, idsDontDisplayInitials, szDontDisplayInitials, CharSizeOf(szDontDisplayInitials));
    }

    if((dwRange == rangeSelected) && (ListView_GetSelectedCount(hWndLV)<=0))
    {
        ShowMessageBox(hWndParent, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    lstrcpy(szPrevEntry, szEmpty);

    {
        int iItemIndex = 0, i = 0;
        int iLastItemIndex = -1;
        int nItemCount;

        if(dwRange == rangeSelected)
            nItemCount = ListView_GetSelectedCount(hWndLV);
        else if(dwRange == rangeAll)
            nItemCount = ListView_GetItemCount(hWndLV);


        for(i=0;i<nItemCount;i++)
        {
            int j;
            LPTSTR lpszData = NULL;
            ULONG ulMemSize = 0;
            HRESULT hr;
            MEMOINFO MI = {0};
            LPRECIPIENT_INFO lpItem = NULL;

            if(dwRange == rangeSelected)
                iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);
            else if(dwRange == rangeAll)
                iItemIndex = i;

            lpItem = GetItemFromLV(hWndLV, iItemIndex);

            if(lpItem)
            {
                if (HR_FAILED(  HrGetPropArray( lpIAB,
                                                NULL,
                                                lpItem->cbEntryID,
                                                lpItem->lpEntryID,
                                                MAPI_UNICODE,
                                                &ulcPropCount,
                                                &lpPropArray) ) )
                {
                    DebugPrintError(( TEXT("HrGetPropArray failed\n")));
                    goto out;
                }

                GetMemoInfoStruct(lpIAB, ulcPropCount, lpPropArray, dwStyle, &MI, bCurrentSortIsByLastName);

                SetPrintDialogMsg(0, idsPrintFormattingName, MI.lpsz[memoTitleName]);

                // Poll the cancel dialog to see if the user wants to cancel
                if (!ppi->pfnAbortProc(ppi->hdcPrn, 0))
                {
                    FreeMemoInfoStruct(&MI);
                    DebugPrintError(( TEXT("User canceled printing ...\n")));
                    goto out;
                }

                switch(dwStyle)
                {
                case styleMemo:
                    WABStyleMemo(hWndRE, MI);
                    break;
                case styleBusinessCard:
                    WABStyleBusinessCard(hWndRE, MI);
                    break;
                case stylePhoneList:
                    WABStylePhoneList(hWndRE, MI, szPrevEntry);
                    //if(lpszPrevEntry)
                    //    LocalFreeAndNull(&lpszPrevEntry);
                    //lpszPrevEntry = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(MI.lpsz[memoTitleName])+1));
                    //if(!lpszPrevEntry)
                        //goto out;
                    //lstrcpy(lpszPrevEntry, MI.lpsz[memoTitleName]);
                    break;
                }

                FreeMemoInfoStruct(&MI);
            }

            if(lpPropArray)
                MAPIFreeBuffer(lpPropArray);

            lpPropArray = NULL;

            // fill in some space between multiple contacts
            {
                int numBreaks = (dwStyle == stylePhoneList) ? 1 : 4;
                for(j=0;j<numBreaks;j++)
                    AppendText(hWndRE, szCRLF);
            }

            if(dwRange == rangeSelected)
                iLastItemIndex = iItemIndex;

        } // for i ...
    }


    bRet = TRUE;
out:

    //if(lpszPrevEntry)
    //    LocalFreeAndNull(&lpszPrevEntry);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return bRet;
}







/*
 *        ScPrintBody
 *
 *        Purpose:
 *            To print the body of each message
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *            cyGap                Gap above message text
 //*            pmsg                Pointer to message whose body is to be printed
 *            hwndRE                Pre-rendered body
 *            lpszTxt               Txt to print
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 */
SCODE ScPrintBody(PRINTINFO * ppi, int cyGap)
{
    SCODE           sc=S_OK;
    RECT            rcSep;
    FORMATRANGE     fr;
    HWND            hwndRE = ppi->hwndRE;

    int                ifrm;
    LONG        lTextLength = 0;   
    LONG        lTextPrinted = 0;  

    DebugPrintTrace(( TEXT("ScPrintBody\n")));

    // Put a gap between the fields the message text

    rcSep = ppi->rcBand;
    if (rcSep.top + cyGap > ppi->yFooter)
    {
        // Adding the gap will go past the page. Just go to the next page
        sc = ScGetNextBand(ppi, TRUE);
    }
    else
    {
        // Keep on getting a band till the bottom of the band passes the gap
        while (rcSep.top + cyGap > ppi->rcBand.bottom)
            if ((sc = ScGetNextBand(ppi, TRUE)) != S_OK)
                goto CleanUp;

        // Adjust the band so that we don't damage the gap
        ppi->rcBand.top += cyGap + 1;
    }


#ifdef DEBUG_PRINTMSGS
    InvalidateRect(ppi->hwndRE, NULL, TRUE);
    UpdateWindow(ppi->hwndRE);
#endif

    // Format the text for printing
    fr.hdc = ppi->hdcPrn;
    fr.hdcTarget = 0;
    fr.rcPage.left = fr.rcPage.top = 0;
    fr.rcPage.right = (int)LPixelsToTwips(ppi->sizePage.cx, ppi->sizeInch.cx);
    fr.rcPage.bottom = (int)LPixelsToTwips(ppi->sizePage.cy, ppi->sizeInch.cy);
    fr.chrg.cpMin = 0;
    fr.chrg.cpMax = -1;
    
    lTextLength = (LONG) SendMessage(hwndRE, WM_GETTEXTLENGTH, 0, 0);
    lTextPrinted = 0;

    // Handle no body case
    if (lTextLength <= 0)
        goto CleanUp;

    // tell RichEdit not to erase the background before rendering text
    SetBkMode(fr.hdc, TRANSPARENT);

    do
    {
        fr.chrg.cpMin = lTextPrinted;

        // Tell format range where to render to
        fr.rc.top = (int) LPixelsToTwips(ppi->rcBand.top, ppi->sizeInch.cy);
        fr.rc.left = (int) LPixelsToTwips(ppi->rcBand.left, ppi->sizeInch.cx);
        fr.rc.right = (int) LPixelsToTwips(ppi->rcBand.right, ppi->sizeInch.cx);
        fr.rc.bottom = (int) LPixelsToTwips(min(ppi->rcBand.bottom, ppi->yFooter), ppi->sizeInch.cy);

        // Go draw it
        DebugPrintTrace(( TEXT("Rendering\r\n")));
        lTextPrinted = (LONG) SendMessage(hwndRE, EM_FORMATRANGE, TRUE,(LPARAM) &fr);
        //TextOut(ppi->hdcPrn, fr.rc.left, fr.rc.top, lpszTxt, lstrlen(lpszTxt));

        // weird bug with RichEdit20 .. lTextPrinted is actually reduces in size
        // Another weird bug ... lTextPrinted is never incremented.  [PaulHi]
        if(lTextPrinted <= fr.chrg.cpMin)
            break;

    } while (lTextPrinted > 0 &&
              lTextPrinted < lTextLength &&
              (sc = ScGetNextBand(ppi, TRUE)) == S_OK);

    //$ Raid 1137: Need to clear out the cached font characteristics
    fr.chrg.cpMin = fr.chrg.cpMax + 1;
    //SendMessage(hwndRE, EM_FORMATRANGE, 0, 0);

    // Don't damage what we have just printed
    ppi->rcBand.top = NTwipsToPixels(fr.rc.bottom, ppi->sizeInch.cy);

CleanUp:
    DebugPrintTrace(( TEXT("ScPrintBody:%d\n"), sc));
    return sc;
}













/*
 *        ScPrintMessage
 *
 *        Purpose:
 *            To print the header and body of a message
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *            pmsg                Pointer to the message which needs its header
 *                                to be printed.
 *            hwndRE                Pre-rendered body
 *            phi                    Message header info
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 */
SCODE ScPrintMessage(PRINTINFO * ppi, HWND hWndRE)
{
    RECT            rcExt;
    RECT            rcSep;
    HFONT           hfontOld = NULL;
    HBRUSH          hbrushOld = NULL;
    HPEN            hpenOld = NULL;
    SIZE            sizeExt;
    int             cyHeader;
    SCODE           sc = S_OK;
    PARAFORMAT      pf = { 0 };

    pf.cbSize = sizeof(PARAFORMAT);


    // If we currently have no band, get the next band
    if (IsRectEmpty(&ppi->rcBand) &&
         (sc = ScGetNextBand(ppi, TRUE)) != S_OK)
        goto CleanUp;

    // Determine how much room we need for the header string and separator

    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontSep);
    hbrushOld = (HBRUSH)SelectObject(ppi->hdcPrn, GetStockObject(BLACK_BRUSH));
    hpenOld = (HPEN)SelectObject(ppi->hdcPrn, GetStockObject(BLACK_PEN));

    // Find out how much space our text take will take
    GetTextExtentPoint(ppi->hdcPrn, ppi->szHeader, lstrlen(ppi->szHeader),
                        &sizeExt);
    cyHeader = 2 * sizeExt.cy + 1 + (cySepFontSize(ppi) / 4);

    // Check if enough room on page. Move to the next page as needed

    if (ppi->rcBand.top + cyHeader > ppi->yFooter)
    {
        // No more room on this page, see if it'll fit on the next page
        if (ppi->rcMargin.top + cyHeader > ppi->yFooter)
        {
            DebugPrintTrace(( TEXT("Header too big for any page.\n")));
            goto CleanUp;
        }

        // Go on to the next page
        if ((sc = ScPrintRestOfPage(ppi, TRUE)) != S_OK)
            goto CleanUp;
    }

    // Calculate the rectangle that our header will take up
    rcExt = ppi->rcBand;
    rcExt.bottom = rcExt.top + cyHeader;
    rcSep = rcExt;
    rcSep.top += sizeExt.cy;
    rcSep.bottom = rcSep.top + (cySepFontSize(ppi) / 4);
    rcSep.right = rcSep.left + sizeExt.cx;

    // Draw the text and separator
    TextOut(ppi->hdcPrn, rcExt.left, rcExt.top, ppi->szHeader,
             lstrlen(ppi->szHeader));

    Rectangle(ppi->hdcPrn, rcSep.left, rcSep.top, rcSep.right, rcSep.bottom);
    MoveToEx(ppi->hdcPrn, rcSep.right, rcSep.top, NULL);
    LineTo(ppi->hdcPrn, rcExt.right, rcSep.top);

    rcExt.top = rcExt.bottom + 5;


/***/
    // Adjust the band so that we don't damage the header
    ppi->rcBand.top = rcExt.bottom + 1;

    // Create a header in a richedit control

    pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_ALIGNMENT |
                PFM_OFFSET | PFM_TABSTOPS;
    pf.dxOffset = LGetHeaderIndent();
    pf.cTabCount = 1;
    pf.rgxTabs[0] = pf.dxOffset;
    pf.wAlignment = PFA_LEFT;

    sc = ScPrintBody(ppi, sizeExt.cy);
/***/
CleanUp:
    if (hfontOld != NULL)
        SelectObject(ppi->hdcPrn, hfontOld);
    if (hbrushOld != NULL)
        SelectObject(ppi->hdcPrn, hbrushOld);
    if (hpenOld != NULL)
        SelectObject(ppi->hdcPrn, hpenOld);

    return sc;
}


#ifdef WIN16
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
#endif


#ifdef WIN16
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
#endif

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//
// SetPrintDlgExStruct - Fills in the default PDEX values
//
//  hWnd - HWND of parent dialog
//  PD - PrintDLG struct
//  hWndLV - HWND of listView to print from - if there are no selections in the list view,
//          the selections option is turned off in the print dialog
//
////////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDlgExStruct(HWND hWnd, PRINTDLGEX * lpPD, HWND hWndLV, LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    // set up the print dialog stuff
    // Call the common print dialog to get the default
    PRINTDLGEX    pd={0};

    pd.lStructSize = sizeof(PRINTDLGEX);
    pd.hwndOwner = hWnd;
    pd.hDevMode = (HANDLE) NULL;
    pd.hDevNames = (HANDLE) NULL;
    pd.hDC = (HDC) NULL;
    pd.Flags =  PD_RETURNDC |           // return PrintDC
                PD_DISABLEPRINTTOFILE |
                PD_ENABLEPRINTTEMPLATE |
                PD_HIDEPRINTTOFILE |
                PD_NOPAGENUMS;
    pd.Flags2 = 0;
    if(ListView_GetSelectedCount(hWndLV) > 0)
        pd.Flags |= PD_SELECTION;
    else
        pd.Flags |= PD_NOSELECTION;

    pd.nCopies = 1;

    pd.hInstance = hinstMapiX;
    pd.lpPrintTemplateName = MAKEINTRESOURCE(IDD_DIALOG_PRINTDLGEX); //(LPSTR) NULL;
    pd.lpCallback = (LPUNKNOWN)lpWABPCO;           // app callback interface
    
    pd.nPropertyPages = 0;
    pd.lphPropertyPages = NULL;
    
    pd.nStartPage = START_PAGE_GENERAL;

    *lpPD = pd;

    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//
// SetPrintDlgStruct - Fills in the default PD values
//
//  hWnd - HWND of parent dialog
//  PD - PrintDLG struct
//  hWndLV - HWND of listView to print from - if there are no selections in the list view,
//          the selections option is turned off in the print dialog
//
////////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDlgStruct(HWND hWnd, PRINTDLG * lpPD, HWND hWndLV, LPARAM lCustData)
{
    // set up the print dialog stuff
    // Call the common print dialog to get the default
    PRINTDLG    pd={0};

    pd.lStructSize = sizeof(PRINTDLG);
    pd.hDevMode = (HANDLE) NULL;
    pd.hDevNames = (HANDLE) NULL;

    pd.Flags =  PD_RETURNDC |           // return PrintDC
                PD_NOPAGENUMS |         // Disable Page number option
                PD_DISABLEPRINTTOFILE |
                PD_HIDEPRINTTOFILE |
                PD_ENABLEPRINTHOOK |
                PD_ENABLEPRINTTEMPLATE;

    if(ListView_GetSelectedCount(hWndLV) > 0)
        pd.Flags |= PD_SELECTION;
    else
        pd.Flags |= PD_NOSELECTION;

    pd.hwndOwner = hWnd;
    pd.hDC = (HDC) NULL;
    pd.nFromPage = 1;
    pd.nToPage = 1;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 1;
    pd.hInstance = hinstMapiX;
    pd.lCustData = lCustData;
    pd.lpfnPrintHook = (LPPRINTHOOKPROC) &fnPrintDialogProc; //NULL;
    pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL;
    pd.lpPrintTemplateName = MAKEINTRESOURCE(IDD_DIALOG_PRINTDLGORD); //(LPSTR) NULL;
    pd.lpSetupTemplateName = (LPTSTR)  NULL;
    pd.hPrintTemplate = (HANDLE) NULL;
    pd.hSetupTemplate = (HANDLE) NULL;

    *lpPD = pd;

    return;
}


/*
-
-   HrGetPrintData
-
    Determines whether to show the new print dialog or the old print dialog
    Fills in all the structures appropriately and returns the values we
    care about such as nCopies, Print style, etc
*
*
*/
HRESULT HrGetPrintData(LPADRBOOK lpAdrBook, HWND hWndParent, HWND hWndLV, 
                       HDC * lphdcPrint, int * lpnCopies, 
                       DWORD * lpdwStyle, DWORD * lpdwRange)
{
    DWORD dwSelectedStyle = styleMemo;
    HRESULT hr = S_OK;
    LPWABPRINTDIALOGCALLBACK lpWABPCO = NULL;
    PRINTDLG pd = {0};
    PRINTDLGEX pdEx = {0};

    // Test for presence of NT5 PrintDlgEx

    if(!HR_FAILED(hr = PrintDlgEx(NULL)))
    {
        if(HR_FAILED(hr = HrCreatePrintCallbackObject((LPIAB)lpAdrBook,&lpWABPCO,dwSelectedStyle)))
            goto out;
        if(!lpWABPCO)
        {
            hr = E_FAIL;
            goto out;
        }
        SetPrintDlgExStruct(hWndParent, &pdEx, hWndLV, lpWABPCO);
        if(HR_FAILED(hr = PrintDlgEx(&pdEx)))
        {
            DebugTrace( TEXT("PrintDlgEx returns 0x%.8x\n"),hr);
            // #98841 Millenium returns fail in this case, but for PrintDlgEx(NULL) it returns S_OK (YST)
            goto doOldPrint;
        }
        *lphdcPrint = pdEx.hDC;
        *lpnCopies = pdEx.nCopies;
        *lpdwStyle = lpWABPCO->dwSelectedStyle;
        if (pdEx.Flags & PD_SELECTION)
            *lpdwRange = rangeSelected;
        else
            *lpdwRange = rangeAll;
    }
    else
    {
doOldPrint:
        SetPrintDlgStruct(hWndParent, &pd, hWndLV, (LPARAM) &dwSelectedStyle);
        // Show the print dialog
        if(!PrintDlg(&pd))
            goto out;
        *lphdcPrint = pd.hDC;
        *lpnCopies = pd.nCopies;
        *lpdwStyle = dwSelectedStyle;
        if (pd.Flags & PD_SELECTION)
            *lpdwRange = rangeSelected;
        else
            *lpdwRange = rangeAll;
        hr = S_OK;
    }    
out:
    if(lpWABPCO)
        lpWABPCO->lpVtbl->Release(lpWABPCO);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// HrPrintItems - Prints selected contacts
//      Prints the contents of the address book
//      Pops up a dialog that lets user select what he wants to print
//          Options are (or will be)
//          All or selected
//          Style - memo, business, or phone book
//
//      Items are printed using the current sort style in the list view
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT HrPrintItems(   HWND hWnd,
                        LPADRBOOK lpAdrBook,
                        HWND hWndLV,
                        BOOL bCurrentSortisByLastName)
{
    HRESULT hr = E_FAIL;
    HWND hWndRE = NULL; // we'll do our formating in a riceh edit control and use that for printing
    PRINTINFO 	*ppi=0;
    BOOL fStartedDoc = FALSE;
    BOOL fStartedPage= FALSE;
    DOCINFO     docinfo={0};
    HCURSOR hOldCur = NULL;
    int i,nCode;
    HINSTANCE hRELib = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB)lpAdrBook;

    HDC hdcPrint = NULL;
    int nCopies = 0;
    DWORD dwStyle;
    DWORD dwRange;
    
    // Double check if there are any print extensions that we need to accomodate
    //
    if(bCheckForPrintExtensions(NULL))
    {
        // Found a print extension
        hr = HrUseWABPrintExtension(hWnd, lpAdrBook, hWndLV);
        goto out;
    }

    if(!(ppi = LocalAlloc(LMEM_ZEROINIT, sizeof(PRINTINFO))))
        goto out;
    ppi->hwndDlg = hWnd;

    if(HR_FAILED(HrGetPrintData(lpAdrBook, hWnd, hWndLV, &hdcPrint, &nCopies, &dwStyle, &dwRange)))
        goto out;

    if(!hdcPrint)
        goto out;

    // Take care of zilch copies
    //
    // Actually it seems that this number is meaningless if the printer can handle multiple
    // copies. If the printer can't handle multiple copies, we will get info in this number.
    //
    if(!nCopies)
		nCopies = 1;

    ppi->hdcPrn = hdcPrint;

    // Create a RichEdit control in which we will do our formatting
    hRELib = LoadLibrary( TEXT("riched20.dll"));
    if(!hRELib)
    {
        hRELib = LoadLibrary( TEXT("riched32.dll"));
        s_bUse20 = FALSE;
    }
    //IF_WIN16(hRELib = LoadLibrary( TEXT("riched.dll"));)
    if(!hRELib)
        goto out;

    hWndRE = CreateWindowEx(0, 
                            (s_bUse20 ? RICHEDIT_CLASS : TEXT("RichEdit")), 
                            TEXT(""),WS_CHILD | ES_MULTILINE,
                            CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                            hWnd,(HMENU) NULL,hinstMapiX,NULL);

    if (!hWndRE)
        goto out;

    //////////////////////////
    {
        CHARFORMAT  cf = {0};
        TCHAR       rgch[CCHMAX_STRINGRES];
        DWORD       dwCodepage ;
        CHARSETINFO rCharsetInfo;
        LOGFONT lfSystem;
        BOOL bNeedLargeFont = FALSE;

        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_FACE;

        SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

        if(LoadString(hinstMapiX, idsDefaultFontFace, rgch, CharSizeOf(rgch)))
            lstrcpy(cf.szFaceName, rgch);
        else
            lstrcpy(cf.szFaceName, szDefFont);

        // [a-msadek] bug#56478
        // Arail does not support Thai so as all other base fonts
        // The best way to determine the OS language is from system font charset
        if(GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfSystem), (LPVOID)&lfSystem))
        {
            if (lfSystem.lfCharSet == THAI_CHARSET)
            {
                lstrcpy(cf.szFaceName, szThaiDefFont);

                // Thai Font sizes are always smaller than English as the vowl and tone
                // markes consumes some of the font height
                bNeedLargeFont = TRUE;
            }
        }

        // bug #53058 - set correct CharSet info for Eastern European
        dwCodepage = GetACP();
        // Get GDI charset info
        if ( dwCodepage != 1252 && TranslateCharsetInfo((LPDWORD) IntToPtr(dwCodepage) , &rCharsetInfo, TCI_SRCCODEPAGE))
            cf.bCharSet = (BYTE) rCharsetInfo.ciCharset;

        SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_ALL, (LPARAM) &cf);
        if(bNeedLargeFont)
        {
            ReduceFontCmd(hWndRE, FALSE, 80, TRUE);
        }

    }
    //////////////////////////


    // At the top of the print job, print the header with the users name or with
    // the default  TEXT("Windows Address Book") title
    {
        TCHAR szHead[MAX_PATH];
        DWORD dwLen = CharSizeOf(szHead);
        SCODE sc;
        *szHead = '\0';
        if(bIsThereACurrentUser(lpIAB) && lstrlen(lpIAB->szProfileName))
            lstrcpy(szHead, lpIAB->szProfileName);
        else 
            GetUserName(szHead, &dwLen);
        if(!lstrlen(szHead))
            LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szHead, CharSizeOf(szHead));

        if (( sc = ScInitPrintInfo( ppi, hWnd, szHead, &g_rcBorder, hWndRE)) != S_OK)
            goto out;
    }

    // While the printing is in progress, we dont want the user to mess with the
    // listview selection otherwise the print job will print the wrong entries
    // Hence we disable this window (since the print cancel dialog is really a modeless dialog)
    EnableWindow(hWnd, FALSE);

    CreateShowAbortDialog(hWnd, 0, 0, ListView_GetSelectedCount(hWndLV), 0);

    // Format the prop data into the Rich Edit Control
    if(!WABFormatData(lpAdrBook, hWnd, hWndRE, hWndLV, dwRange, dwStyle, ppi, bCurrentSortisByLastName))
        goto out;

	if(bTimeToAbort())
        goto out;

    for(i=0;i<nCopies;i++)
    {
        TCHAR szBuf[MAX_PATH];

        LoadString(hinstMapiX, idsPrintDocTitle, szBuf, CharSizeOf(szBuf));

        docinfo.cbSize = sizeof(docinfo);
        docinfo.lpszDocName = szBuf;
        docinfo.lpszOutput = NULL;

        SetMapMode(hdcPrint, MM_TEXT);

        // Set the abort procedure
        if ((nCode=SetAbortProc(ppi->hdcPrn, ppi->pfnAbortProc)) <= 0)
        {
            hr = E_FAIL;
            break;
        }

	    if(bTimeToAbort())
            goto out;

        // Start a print job
        if (StartDoc(ppi->hdcPrn, &docinfo) <= 0)
        {
            DebugPrintError(( TEXT("StartDoc failed: %d\n"), GetLastError()));
            goto out;
        }
        fStartedDoc = TRUE;

        //StartPage(pd.hDC);
	    if(bTimeToAbort())
            goto out;


        // Go on and print the message!
        if (ScPrintMessage(ppi, hWndRE) != S_OK)
                goto out;

	    if(bTimeToAbort())
            goto out;

        // End the page
        if(ScGetNextBand( ppi, FALSE) != S_OK)
            goto out;

	    if(bTimeToAbort())
            goto out;

        // Finish up the print job if it had been started
        if (fStartedDoc)
        {
            EndDoc(ppi->hdcPrn);
            fStartedDoc = FALSE;
        }
    }

    hr = hrSuccess;

out:

    if(hWndRE)
    {
        SendMessage(hWndRE, WM_SETTEXT, 0, (LPARAM)szEmpty);
        SendMessage(hWndRE, WM_CLEAR, 0, 0);
    }

    if(bTimeToAbort())
    {
        hr = MAPI_E_USER_CANCEL;
        pt_bPrintUserAbort = FALSE;
    }

    // Re-enable the window and ensure it stays put
    EnableWindow(hWnd, TRUE);
    //SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);

    CloseAbortDlg();

    // Finish up the print job if it had been started
    if (fStartedDoc)
        EndDoc(ppi->hdcPrn);

    // Get rid of our Rich Edit control
    if (hWndRE)
        DestroyWindow(hWndRE);

    if(hOldCur)
        SetCursor(hOldCur);

    if(ppi)
    {
        if(ppi->hfontPlain)
            DeleteObject(ppi->hfontPlain);
        if(ppi->hfontBold)
            DeleteObject(ppi->hfontBold);
        if(ppi->hfontSep)
            DeleteObject(ppi->hfontSep);
        LocalFreeAndNull(&ppi);
    }

    if(hRELib)
        FreeLibrary((HMODULE) hRELib);

    return hr;
}


/*
*   Handles the WM_INITDIALOG for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMInitDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle)
{
    DWORD dwStyle = lpdwStyle ? *lpdwStyle : styleMemo;
    int nID;

    switch (dwStyle)
    {
    case styleBusinessCard:
        nID = IDC_PRINT_RADIO_CARD;
        break;
    case stylePhoneList:
        nID = IDC_PRINT_RADIO_PHONELIST;
        break;
    default:
    case styleMemo:
        nID = IDC_PRINT_RADIO_MEMO; //default
        break;
    }
    CheckRadioButton(   hDlg, IDC_PRINT_RADIO_MEMO, IDC_PRINT_RADIO_PHONELIST, nID);
    SetFocus(hDlg);
    return 0;
}
/*
*   Handles the WM_COMMAND for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle )
{
    switch (GET_WM_COMMAND_ID(wParam,lParam))
    {
    case IDC_PRINT_RADIO_MEMO:
        //lpPD->lCustData = (DWORD) styleMemo;
        *lpdwStyle = (DWORD) styleMemo;
        break;
    case IDC_PRINT_RADIO_CARD:
        //lpPD->lCustData = (DWORD) styleBusinessCard;
        *lpdwStyle = (DWORD) styleBusinessCard;
        break;
    case IDC_PRINT_RADIO_PHONELIST:
        //lpPD->lCustData = (DWORD) stylePhoneList;
        *lpdwStyle = (DWORD) stylePhoneList;
        break;
    }
    return 0;
}
/*
*   Handles the WM_HELP for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMHelp(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle )
{
    int id = ((LPHELPINFO)lParam)->iCtrlId;
    if( id == IDC_PRINT_FRAME_STYLE ||
        id == IDC_PRINT_RADIO_MEMO ||
        id == IDC_PRINT_RADIO_CARD ||
        id == IDC_PRINT_RADIO_PHONELIST)
    {
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgPrintHelpIDs );
    }

    return FALSE;
}
/*
*   Handles the WM_CONTEXTMENU for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMContextMenu(HWND hDlg, UINT message, WPARAM wParam,LPARAM lParam,LPDWORD lpdwStyle )
{
    HWND hwnd = (HWND) wParam;
    if( hwnd == GetDlgItem(hDlg, IDC_PRINT_FRAME_STYLE) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_MEMO) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_CARD) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_PHONELIST) )
    {
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgPrintHelpIDs );
    }
    
    return FALSE;
}

//$$*****************************************************************
//
//  FUNCTION:   fnPrintDialogProc
//
//  PURPOSE:    Printer dialog hook procedure
//
//              We have modified the CommDlg print template with the
//              WAB print styles.
//              This is a hook procedure that takes care of our
//              newly added controls
//
// When WM_INITDIALOG is called, the lParam contains a pointer to the
//  PRINTDLG structure controling the print setup dialog
//
//*******************************************************************
INT_PTR CALLBACK fnPrintDialogProc( HWND    hDlg,
                                    UINT    message,
                                    WPARAM  wParam,
                                    LPARAM  lParam)
{

    LPDWORD lpdwStyle = (LPDWORD) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPPRINTDLG lpPD = (LPPRINTDLG) lParam;
#ifdef WIN16
// Strange situation here. If I don't create edt1 and edt2 which are used for page range, entire print dialog work incorrectly.
// So I just add two controls(edt1 and edt2) and hide those here.
            ShowWindow(GetDlgItem(hDlg, edt1), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, edt2), SW_HIDE);
#endif
            if(lpPD)
            {
                lpdwStyle = (LPDWORD) lpPD->lCustData;
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpdwStyle); //Save this for future reference
                return bHandleWMInitDialog(hDlg,message,wParam,lParam,lpdwStyle);
            }
        }
        SetFocus(hDlg);
        return 0;
        break;

   case WM_COMMAND:
       if(lpdwStyle)
            return bHandleWMCommand(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_HELP:
        return bHandleWMHelp(hDlg,message,wParam,lParam,lpdwStyle);
        break;


#ifndef WIN16
    case WM_CONTEXTMENU:
        return bHandleWMContextMenu(hDlg,message,wParam,lParam,lpdwStyle);
        break;
#endif // !WIN16



    default:
        return FALSE;
        break;
    }

    return FALSE;
}


/**************************************************************************************************
 *        ScInitPrintInfo
 *
 *        Purpose:
 *            Initialize the fields of a print info structure relevant for
 *            the actual printing.
 *
 *        Arguments:
 *            ppi                 Pointer to the PRINTINFO structure
 *            hwnd                The owner of the print dialog box
 *            szHeader            The string to be printed at the top of each
 *                                message
 *            prcBorder           Pointer to a rect whose fields contain the
 *                                number of twips to use as a margin around the
 *                                printed text.
 *              hWndRE            rich edit control in which we will do our formatting
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 ***************************************************************************************************/
SCODE ScInitPrintInfo(   PRINTINFO * ppi,
                                HWND hwnd,
                                LPTSTR szHeader,
                                RECT * prcBorder,
                                HWND hWndRE)
{
    SIZE        sizeExt;
    LOGFONT     logfont    = {0};
    HFONT       hfontOld;
    TCHAR       szT[20];
    SCODE       sc = S_OK;
    TCHAR       rgch[CCHMAX_STRINGRES];

    // Save handle to our parent window
    ppi->hwnd = hwnd;

    // Save a pointer to our header string
    ppi->szHeader = szHeader;

    // Set up pointer to our abort procedure
    ppi->pfnAbortProc = FAbortProc;

    ppi->hwndRE = hWndRE;

    // Determine the page size in pixels
    ppi->sizePage.cx = GetDeviceCaps(ppi->hdcPrn, HORZRES);
    ppi->sizePage.cy = GetDeviceCaps(ppi->hdcPrn, VERTRES);

    // Exchange 13497: If we have nothing to render to abort now.
    if (!ppi->sizePage.cx || !ppi->sizePage.cy)
    {
        sc = E_FAIL;
        goto CleanUp;
    }

    ///MoveWindow(hWndRE, 0, 0, ppi->sizepage.cx, ppi->sizepage.cy, FALSE);

    // Determine the number of pixels in a logical inch
    ppi->sizeInch.cx = GetDeviceCaps(ppi->hdcPrn, LOGPIXELSX);
    ppi->sizeInch.cy = GetDeviceCaps(ppi->hdcPrn, LOGPIXELSY);

    // Exchange 13497: If we failed to get some info make some assumptions.
    //                    At worst assume 300 dpi.
    if (!ppi->sizeInch.cx)
        ppi->sizeInch.cx = ppi->sizeInch.cy ? ppi->sizeInch.cy : 300;
    if (!ppi->sizeInch.cy)
        ppi->sizeInch.cy = 300;

    //$ Raid 2667: Determine if we still fit within the page in twips
    if (LPixelsToTwips(ppi->sizePage.cx, ppi->sizeInch.cx) > INT_MAX ||
         LPixelsToTwips(ppi->sizePage.cy, ppi->sizeInch.cy) > INT_MAX)
    {
        sc = E_FAIL;
        goto CleanUp;
    }


    // Set up the margin settings
    ppi->rcMargin.top = NTwipsToPixels(prcBorder->top, ppi->sizeInch.cy);
    ppi->rcMargin.bottom = ppi->sizePage.cy
                        - NTwipsToPixels(prcBorder->bottom, ppi->sizeInch.cy);
    if (ppi->rcMargin.bottom < ppi->rcMargin.top)
    {
        // Bottom is above top. Top/Bottom margins ignored
        ppi->rcMargin.top = 0;
        ppi->rcMargin.bottom = ppi->sizePage.cy;
    }

    ppi->rcMargin.left = NTwipsToPixels(prcBorder->left, ppi->sizeInch.cx);
    ppi->rcMargin.right = ppi->sizePage.cx
                        - NTwipsToPixels(prcBorder->right, ppi->sizeInch.cx);
    if (ppi->rcMargin.right < ppi->rcMargin.left)
    {
        // Right is left of left. Left/Right margins ignored
        ppi->rcMargin.left = 0;
        ppi->rcMargin.right = ppi->sizePage.cx;
    }


    // Set up the separator font
    //$ Raid 2773: Let user customize separator font
    logfont.lfHeight = - cySepFontSize(ppi);
    logfont.lfWeight = FW_BOLD;
    logfont.lfCharSet =  DEFAULT_CHARSET;
    if(LoadString(hinstMapiX, idsDefaultFontFace, rgch, CharSizeOf(rgch)))
        lstrcpy(logfont.lfFaceName, rgch);
    else
    lstrcpy(logfont.lfFaceName, szDefFont);

    ppi->hfontSep = CreateFontIndirect(&logfont);

    // Set up common font
    ZeroMemory(&logfont, sizeof(LOGFONT));
    logfont.lfHeight = - 10 *  ppi->sizeInch.cy / cPtsPerInch;

    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet =  DEFAULT_CHARSET;
    if(LoadString(hinstMapiX, idsDefaultFontFace, rgch, CharSizeOf(rgch)))
        lstrcpy(logfont.lfFaceName, rgch);
    else
    lstrcpy(logfont.lfFaceName, szDefFont);
    ppi->hfontPlain = CreateFontIndirect(&logfont);

    logfont.lfWeight = FW_BOLD;
    ppi->hfontBold = CreateFontIndirect(&logfont);

    // Calculate where to put the footer

    // Load up the formatting string to use for page numbers
    //LoadString(hinstMapiX, idsFmtPageNumber, ppi->szPageNumber, CharSizeOf(ppi->szPageNumber));
    lstrcpy(ppi->szPageNumber, TEXT("%d"));
    wsprintf(szT, ppi->szPageNumber, ppi->lPageNumber);

    // Sample the height
    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontPlain);
    GetTextExtentPoint(ppi->hdcPrn, szT, lstrlen(szT), &sizeExt);
    ppi->yFooter = ppi->rcMargin.bottom - sizeExt.cy;
    SelectObject(ppi->hdcPrn, hfontOld);

    // Make sure our footer doesn't go above the top of the page
    if (ppi->yFooter < ppi->rcMargin.top)
        sc = E_FAIL;

CleanUp:
    return sc;
}



//$$////////////////////////////////////////
//
// GetNumberFromStringResource
//
////////////////////////////////////////////
int GetNumberFromStringResource(int idNumString)
{
    TCHAR szBuf[MAX_PATH];

    if(LoadString(hinstMapiX, idNumString, szBuf, CharSizeOf(szBuf)))
        return my_atoi(szBuf);
    else
        return 0;
}



/*--------------------------------------------------------------------------------------------------*/
/*--IPrintDialogCallback stuff----------------------------------------------------------------------*/
/*--Special stuff for the new NT5 Print Dialog------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------*/

WAB_PRINTDIALOGCALLBACK_Vtbl vtblWABPRINTDIALOGCALLBACK = {
    VTABLE_FILL
    WAB_PRINTDIALOGCALLBACK_QueryInterface,
    WAB_PRINTDIALOGCALLBACK_AddRef,
    WAB_PRINTDIALOGCALLBACK_Release,
    WAB_PRINTDIALOGCALLBACK_InitDone,
    WAB_PRINTDIALOGCALLBACK_SelectionChange,
    WAB_PRINTDIALOGCALLBACK_HandleMessage
};

/*
-   HrCreatePrintCallbackObject
-
*
*   This callback object is needed so the new NT5 print dialog can provide send messages back to
*   us for the customization we do for the print dialog ..
*
*/
HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle)
{
    LPWABPRINTDIALOGCALLBACK lpWABPCO = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(WABPRINTDIALOGCALLBACK), (LPVOID *) &lpWABPCO))) 
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpWABPCO,  TEXT("WAB Print Dialog Callback Object"));

    ZeroMemory(lpWABPCO, sizeof(WABPRINTDIALOGCALLBACK));

    lpWABPCO->lpVtbl = &vtblWABPRINTDIALOGCALLBACK;

    lpWABPCO->lpIAB = lpIAB;

    lpWABPCO->dwSelectedStyle = dwSelectedStyle;

    lpWABPCO->lpVtbl->AddRef(lpWABPCO);

    *lppWABPCO = lpWABPCO;

    return(hrSuccess);

err:

    FreeBufferAndNull(&lpWABPCO);
    return(hr);
}


void ReleaseWABPrintCallbackObject(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    MAPIFreeBuffer(lpWABPCO);
}


STDMETHODIMP_(ULONG)
WAB_PRINTDIALOGCALLBACK_AddRef(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    return(++(lpWABPCO->lcInit));
}



STDMETHODIMP_(ULONG)
WAB_PRINTDIALOGCALLBACK_Release(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    ULONG ulc = (--(lpWABPCO->lcInit));
    if(ulc==0)
       ReleaseWABPrintCallbackObject(lpWABPCO);
    return(ulc);
}


STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_QueryInterface(LPWABPRINTDIALOGCALLBACK lpWABPCO,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpWABPCO;

    if(IsEqualIID(lpiid, &IID_IPrintDialogCallback))
        lp = (LPVOID) lpWABPCO;

    if(!lp)
        return E_NOINTERFACE;

    ((LPWABPRINTDIALOGCALLBACK) lp)->lpVtbl->AddRef((LPWABPRINTDIALOGCALLBACK) lp);

    *lppNewObj = lp;

    return S_OK;

}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_InitDone(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    HRESULT hr = S_FALSE;
    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_InitDone\n"));
    return hr;
}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_SelectionChange(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    HRESULT hr = S_FALSE;
    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_SelectionChange\n"));
    return hr;
}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_HandleMessage(LPWABPRINTDIALOGCALLBACK lpWABPCO,
                                      HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
    BOOL bRet = FALSE;
    LPDWORD lpdwStyle = &lpWABPCO->dwSelectedStyle;

    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_HandleMessage: 0x%.8x\n"), message);

    switch(message)
    {
    case WM_INITDIALOG:
        bRet = bHandleWMInitDialog(hDlg,message,wParam,lParam,lpdwStyle);
        break;

   case WM_COMMAND:
        bRet = bHandleWMCommand(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_HELP:
        bRet = bHandleWMHelp(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_CONTEXTMENU:
        bRet = bHandleWMContextMenu(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return (bRet ? S_OK : S_FALSE);
}


/******************************************************************************************/


/*
-   bCheckForPrintExtensions
-
*   In case any app has implemented a Print Extension to the WAB, we should hook into
*   that print extension
*
*   lpDLLPath can be NULL or should point to a buffer big enough to receive the module Path
*
*/
static const LPTSTR szExtDisplayMailUser = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtPrint");
extern HrGetActionAdrList(LPADRBOOK lpAdrBook,HWND hWndLV,LPADRLIST * lppAdrList,LPTSTR * lppURL, BOOL * lpbIsNTDSEntry);

BOOL bCheckForPrintExtensions(LPTSTR lpDLLPath)
{
    BOOL bRet = FALSE;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,szExtDisplayMailUser,0, KEY_READ,&hKey))
    {
        goto out;
    }

    {
        TCHAR szExt[MAX_PATH];
        DWORD dwIndex = 0, dwSize = CharSizeOf(szExt), dwType = 0;
        *szExt = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szExt, &dwSize, 
                                        0, &dwType, NULL, NULL))
        {
            // we found some entry in here .. the value name will be the full path
            // to the module containing the print function
            // Double-check that this module actually exists
            if(szExt && lstrlen(szExt) && GetFileAttributes(szExt) != 0xFFFFFFFF)
            {
                if(lpDLLPath)
                    lstrcpy(lpDLLPath, szExt);
                bRet = TRUE;
                goto out;
            }
        }
    }
    
out:
    if(hKey)
        RegCloseKey(hKey);
    return bRet;
}

/*
-
-   HrUseWABPrintExtension()
-
*   Loads the WAB Print Extension from the extension DLL
*   and calls into it
*
*   hWnd        - Handle of WAB parent
*   lpAdrBook   - lpAdrBook pointer
*   hWndLV      - listview from which a user may have chosen selections
*
*/
HRESULT HrUseWABPrintExtension(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV)
{
    TCHAR szExt[MAX_PATH];
    HRESULT hr = E_FAIL;
    HINSTANCE hInstPrint = NULL;
    LPWABPRINTEXT lpfnWABPrintExt = NULL;
    LPADRLIST lpAdrList = NULL;
    LPWABOBJECT lpWABObject = (LPWABOBJECT)((LPIAB)lpAdrBook)->lpWABObject;

    *szExt = '\0';
    if(!bCheckForPrintExtensions(szExt) || !lstrlen(szExt))
        goto out;

    if(!(hInstPrint = LoadLibrary(szExt)))
        goto out;

    lpfnWABPrintExt = (LPWABPRINTEXT) GetProcAddress(hInstPrint, "WABPrintExt");
    if(!lpfnWABPrintExt)
        goto out;

    // Get the currently selected data from the list view
    if(HR_FAILED(hr = HrGetActionAdrList(lpAdrBook,hWndLV,&lpAdrList,NULL,NULL)))
        goto out;

    hr = lpfnWABPrintExt(lpAdrBook, lpWABObject, hWnd, lpAdrList);

out:
    if(lpAdrList)
        FreePadrlist(lpAdrList);
    if(hInstPrint)
        FreeLibrary(hInstPrint);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wrap.c ===
/*
 *	WRAP.C
 *	
 *	Wrapped IProp
 */

#include "_apipch.h"

/*********************************************************************
 *
 *  The actual Wrapped IMAPIProp methods
 *
 */





//
//  Wrapped IMAPIProp jump table is defined here...
//  Try to use as much of IAB as possible.
//


WRAP_Vtbl vtblWRAP_OOP = {
	VTABLE_FILL
	(WRAP_QueryInterface_METHOD *)	IAB_QueryInterface,
	WRAP_AddRef,
	WRAP_Release,
	(WRAP_GetLastError_METHOD *)	IAB_GetLastError,
	WRAP_SaveChanges,
	WRAP_GetProps,
	WRAP_GetPropList,
	WRAP_OpenProperty,
	WRAP_SetProps,
	WRAP_DeleteProps,
	WRAP_CopyTo,
	WRAP_CopyProps,
	WRAP_GetNamesFromIDs,
	WRAP_GetIDsFromNames,
};




/**************************************************
 *
 *  WRAP_AddRef
 *		Increment lcInit
 *
 */
STDMETHODIMP_(ULONG) WRAP_AddRef(LPWRAP lpWRAP)
{

#ifdef PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpWRAP, sizeof(LPVOID))) {
        //No jump table found
        return(1);
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpWRAP->lpVtbl, 3 * sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(1);
    }

    // Check to see if the method is the same
    if (WRAP_AddRef != lpWRAP->lpVtbl->AddRef) {
        // Wrong object - the object passed doesn't have this
        // method.
        return(1);
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpWRAP->cs);

    ++lpWRAP->lcInit;

    LeaveCriticalSection(&lpWRAP->cs);

    return(lpWRAP->lcInit);
}


STDMETHODIMP_(ULONG)
WRAP_Release (LPWRAP	lpWRAP)
{

#if	!defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, Release, lpVtbl)) {
        return(1);
    }
#endif


    EnterCriticalSection(&lpWRAP->cs);

    --lpWRAP->lcInit;

    if (lpWRAP->lcInit == 0) {

        UlRelease(lpWRAP->lpPropData);

        //
        //  Need to free the object
        //
        LeaveCriticalSection(&lpWRAP->cs);
        DeleteCriticalSection(&lpWRAP->cs);
        FreeBufferAndNull(&lpWRAP);
        return(0);
    }

    LeaveCriticalSection(&lpWRAP->cs);
    return(lpWRAP->lcInit);
}


// IProperty

STDMETHODIMP
WRAP_SaveChanges (LPWRAP	lpWRAP,
				  ULONG		ulFlags)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, SaveChanges, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->SaveChanges(
					lpWRAP->lpPropData,
					ulFlags);
}


STDMETHODIMP
WRAP_GetProps (LPWRAP			lpWRAP,
			   LPSPropTagArray	lpPropTagArray,
			   ULONG			ulFlags,
			   ULONG *			lpcValues,
			   LPSPropValue *	lppPropArray)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetProps(
		lpWRAP->lpPropData,
		lpPropTagArray,
		ulFlags,
		lpcValues,
		lppPropArray);
}


STDMETHODIMP
WRAP_GetPropList (LPWRAP			lpWRAP,
				  ULONG				ulFlags,
				  LPSPropTagArray *	lppPropTagArray)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetPropList, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetPropList(
		lpWRAP->lpPropData,
		ulFlags,
		lppPropTagArray);
}



STDMETHODIMP
WRAP_OpenProperty (LPWRAP		lpWRAP,
				   ULONG		ulPropTag,
				   LPCIID		lpiid,
				   ULONG		ulInterfaceOptions,
				   ULONG		ulFlags,
				   LPUNKNOWN *	lppUnk)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, OpenProperty, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->OpenProperty(
				lpWRAP->lpPropData,
				ulPropTag,
				lpiid,
				ulInterfaceOptions,
				ulFlags,
				lppUnk);
}


STDMETHODIMP
WRAP_SetProps (LPWRAP					lpWRAP,
			   ULONG					cValues,
			   LPSPropValue				lpPropArray,
			   LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, SetProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->SetProps(
		lpWRAP->lpPropData,
		cValues,
		lpPropArray,
		lppProblems);
}


STDMETHODIMP
WRAP_DeleteProps (LPWRAP				lpWRAP,
				  LPSPropTagArray		lpPropTagArray,
				  LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, DeleteProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->DeleteProps(
		lpWRAP->lpPropData,
		lpPropTagArray,
		lppProblems);
}

STDMETHODIMP
WRAP_CopyTo (	LPWRAP					lpWRAP,
				ULONG					ciidExclude,
				LPCIID					rgiidExclude,
				LPSPropTagArray			lpExcludeProps,
				ULONG_PTR    			ulUIParam,
				LPMAPIPROGRESS			lpProgress,
				LPCIID					lpInterface,
				LPVOID					lpDestObj,
				ULONG					ulFlags,
				LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, CopyTo, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	// Make sure we're not copying to ourselves
	
	if ((LPVOID)lpWRAP == (LPVOID)lpDestObj)
	{
		DebugTrace( TEXT("OOP WRAP_CopyTo(): Copying to self is not supported\n"));
		return ResultFromScode(MAPI_E_NO_ACCESS);
	}
	

	return lpWRAP->lpPropData->lpVtbl->CopyTo(
		lpWRAP->lpPropData,
		ciidExclude,
		rgiidExclude,
		lpExcludeProps,
		ulUIParam,
		lpProgress,
		lpInterface,
		lpDestObj,
		ulFlags,
		lppProblems);
}

STDMETHODIMP
WRAP_CopyProps (	LPWRAP					lpWRAP,
					LPSPropTagArray			lpIncludeProps,
					ULONG_PTR				ulUIParam,
					LPMAPIPROGRESS			lpProgress,
					LPCIID					lpInterface,
					LPVOID					lpDestObj,
					ULONG					ulFlags,
					LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, CopyProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->CopyProps(
		lpWRAP->lpPropData,
		lpIncludeProps,
		ulUIParam,
		lpProgress,
		lpInterface,
		lpDestObj,
		ulFlags,
		lppProblems);
}


STDMETHODIMP
WRAP_GetNamesFromIDs (	LPWRAP				lpWRAP,
						LPSPropTagArray *	lppPropTags,
						LPGUID				lpPropSetGuid,
						ULONG				ulFlags,
						ULONG *				lpcPropNames,
						LPMAPINAMEID **		lpppPropNames)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetNamesFromIDs, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetNamesFromIDs(
		lpWRAP->lpPropData,
		lppPropTags,
		lpPropSetGuid,
		ulFlags,
		lpcPropNames,
		lpppPropNames);
}

STDMETHODIMP
WRAP_GetIDsFromNames (	LPWRAP				lpWRAP,
						ULONG				cPropNames,
						LPMAPINAMEID *		lppPropNames,
						ULONG				ulFlags,
						LPSPropTagArray *	lppPropTags)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetIDsFromNames, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetIDsFromNames(
		lpWRAP->lpPropData,
		cPropNames,
		lppPropNames,
		ulFlags,
		lppPropTags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_abcont.h ===
/***********************************************************************
 *
 *  _ABCONT.H
 *
 *  Header file for code in ABCONT.C: Container Object
 *
 *  Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer object.
 */

#undef	INTERFACE
#define INTERFACE	struct _CONTAINER

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, CONTAINER_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, CONTAINER_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(CONTAINER_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _CONTAINER {
    MAILUSER_BASE_MEMBERS(CONTAINER)
    ULONG ulType;
    BOOL fLoadedLDAP;
} CONTAINER, *LPCONTAINER;

#define CBCONTAINER sizeof(CONTAINER)

HRESULT HrSetCONTAINERAccess(LPCONTAINER lpCONTAINER,
  ULONG ulFlags);

//
// Create a new AB Container object
//
HRESULT HrNewCONTAINER(LPIAB lpIAB,
  ULONG ulType,
  LPCIID lpInterface,
  ULONG  ulOpenFlags,
  ULONG cbEID,
  LPENTRYID lpEID,
  ULONG  *lpulObjType,
  LPVOID *lppContainer);

//  Internal flags for HrNewCONTAINER - these flags determine the type of
//  container being created
typedef enum _ContainerType {
    AB_ROOT = 0,        // Root Container
    AB_WELL,
    AB_DL,              // Distribution list container
    AB_CONTAINER,       // Normal container
    AB_PAB,             // "PAB" or default container
    AB_LDAP_CONTAINER   // Special LDAP container
} CONTAINER_TYPE, *LPCONTAINER_TYPE;



// Inside the WAB when we call GetContentsTable followed by SetColumns, we basically end up 
// reading everything from the WAB twice which is a time consuming process 
// To improve performance we can try avoiding one unnecessary call but we need to do
// this carefully .. 
// The following flag is specified to GetContentsTable ONLY WHEN that call will
// be imediately followed by SetColumns .. do not expose this flag to anyone else..
// this is a WAB-internal flag only
//
#define WAB_CONTENTTABLE_NODATA 0x00400000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabval.h ===
/*
 *	M A P I V A L . H
 *	
 *	Macros used to validate parameters on standard MAPI object methods.
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	_INC_VALIDATE
#define	_INC_VALIDATE

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_ENUM(Method, Interface)	Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
	MAKE_ENUM(QueryInterface, IUnknown) = 0,
	MAKE_ENUM(AddRef, IUnknown),			/* For completness */
	MAKE_ENUM(Release, IUnknown),			/* For completness */
	
/* IMAPIProps */
	MAKE_ENUM(GetLastError, IMAPIProp),
	MAKE_ENUM(SaveChanges, IMAPIProp),
	MAKE_ENUM(GetProps, IMAPIProp),
	MAKE_ENUM(GetPropList, IMAPIProp),
	MAKE_ENUM(OpenProperty, IMAPIProp),
	MAKE_ENUM(SetProps, IMAPIProp),
	MAKE_ENUM(DeleteProps, IMAPIProp),
	MAKE_ENUM(CopyTo, IMAPIProp),
	MAKE_ENUM(CopyProps, IMAPIProp),
	MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
	MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_ENUM(GetLastError, IMAPITable),
	MAKE_ENUM(Advise, IMAPITable),
	MAKE_ENUM(Unadvise, IMAPITable),
	MAKE_ENUM(GetStatus, IMAPITable),
	MAKE_ENUM(SetColumns, IMAPITable),
	MAKE_ENUM(QueryColumns, IMAPITable),
	MAKE_ENUM(GetRowCount, IMAPITable),
	MAKE_ENUM(SeekRow, IMAPITable),
	MAKE_ENUM(SeekRowApprox, IMAPITable),
	MAKE_ENUM(QueryPosition, IMAPITable),
	MAKE_ENUM(FindRow, IMAPITable),
	MAKE_ENUM(Restrict, IMAPITable),
	MAKE_ENUM(CreateBookmark, IMAPITable),
	MAKE_ENUM(FreeBookmark, IMAPITable),
	MAKE_ENUM(SortTable, IMAPITable),
	MAKE_ENUM(QuerySortOrder, IMAPITable),
	MAKE_ENUM(QueryRows, IMAPITable),
	MAKE_ENUM(Abort, IMAPITable),
	MAKE_ENUM(ExpandRow, IMAPITable),
	MAKE_ENUM(CollapseRow, IMAPITable),
	MAKE_ENUM(WaitForCompletion, IMAPITable),
	MAKE_ENUM(GetCollapseState, IMAPITable),
	MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_ENUM(GetContentsTable, IMAPIContainer),
	MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
	MAKE_ENUM(OpenEntry, IMAPIContainer),
	MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
	MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_ENUM(CreateEntry, IABContainer),
	MAKE_ENUM(CopyEntries, IABContainer),
	MAKE_ENUM(DeleteEntries, IABContainer),
	MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
	MAKE_ENUM(CreateEntry, IDistList),
	MAKE_ENUM(CopyEntries, IDistList),
	MAKE_ENUM(DeleteEntries, IDistList),
	MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_ENUM(CreateMessage, IMAPIFolder),
	MAKE_ENUM(CopyMessages, IMAPIFolder),
	MAKE_ENUM(DeleteMessages, IMAPIFolder),
	MAKE_ENUM(CreateFolder, IMAPIFolder),
	MAKE_ENUM(CopyFolder, IMAPIFolder),
	MAKE_ENUM(DeleteFolder, IMAPIFolder),
	MAKE_ENUM(SetReadFlags, IMAPIFolder),
	MAKE_ENUM(GetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SaveContentsSort, IMAPIFolder),
	MAKE_ENUM(EmptyFolder, IMAPIFolder),

#ifdef OLD_STUFF
/* IMsgStore */
	MAKE_ENUM(Advise, IMsgStore),
	MAKE_ENUM(Unadvise, IMsgStore),
	MAKE_ENUM(CompareEntryIDs, IMsgStore),
	MAKE_ENUM(OpenEntry, IMsgStore),
	MAKE_ENUM(SetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
	MAKE_ENUM(StoreLogoff, IMsgStore),
	MAKE_ENUM(AbortSubmit, IMsgStore),
	MAKE_ENUM(GetOutgoingQueue, IMsgStore),
	MAKE_ENUM(SetLockState, IMsgStore),
	MAKE_ENUM(FinishedMsg, IMsgStore),
	MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_ENUM(GetAttachmentTable, IMessage),
	MAKE_ENUM(OpenAttach, IMessage),
	MAKE_ENUM(CreateAttach, IMessage),
	MAKE_ENUM(DeleteAttach, IMessage),
	MAKE_ENUM(GetRecipientTable, IMessage),
	MAKE_ENUM(ModifyRecipients, IMessage),
	MAKE_ENUM(SubmitMessage, IMessage),
	MAKE_ENUM(SetReadFlag, IMessage),

/* IABProvider */
	MAKE_ENUM(Shutdown, IABProvider),
	MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
	MAKE_ENUM(GetLastError, IABLogon),
	MAKE_ENUM(Logoff, IABLogon),
	MAKE_ENUM(OpenEntry, IABLogon),
	MAKE_ENUM(CompareEntryIDs, IABLogon),
	MAKE_ENUM(Advise, IABLogon),
	MAKE_ENUM(Unadvise, IABLogon),
	MAKE_ENUM(OpenStatusEntry, IABLogon),
	MAKE_ENUM(OpenTemplateID, IABLogon),
	MAKE_ENUM(GetOneOffTable, IABLogon),
	MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_ENUM(Shutdown, IXPProvider),
	MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_ENUM(AddressTypes, IXPLogon),
	MAKE_ENUM(RegisterOptions, IXPLogon),
	MAKE_ENUM(TransportNotify, IXPLogon),
	MAKE_ENUM(Idle, IXPLogon),
	MAKE_ENUM(TransportLogoff, IXPLogon),
	MAKE_ENUM(SubmitMessage, IXPLogon),
	MAKE_ENUM(EndMessage, IXPLogon),
	MAKE_ENUM(Poll, IXPLogon),
	MAKE_ENUM(StartMessage, IXPLogon),
	MAKE_ENUM(OpenStatusEntry, IXPLogon),
	MAKE_ENUM(ValidateState, IXPLogon),
	MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_ENUM(Shutdown, IMSProvider),
	MAKE_ENUM(Logon, IMSProvider),
	MAKE_ENUM(SpoolerLogon, IMSProvider),
	MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_ENUM(GetLastError, IMSLogon),
	MAKE_ENUM(Logoff, IMSLogon),
	MAKE_ENUM(OpenEntry, IMSLogon),
	MAKE_ENUM(CompareEntryIDs, IMSLogon),
	MAKE_ENUM(Advise, IMSLogon),
	MAKE_ENUM(Unadvise, IMSLogon),
	MAKE_ENUM(OpenStatusEntry, IMSLogon),
	
/* IMAPIControl */
	MAKE_ENUM(GetLastError, IMAPIControl),
	MAKE_ENUM(Activate, IMAPIControl),
	MAKE_ENUM(GetState, IMAPIControl),

/* IMAPIStatus */
	MAKE_ENUM(ValidateState, IMAPIStatus),
	MAKE_ENUM(SettingsDialog, IMAPIStatus),
	MAKE_ENUM(ChangePassword, IMAPIStatus),
	MAKE_ENUM(FlushQueues, IMAPIStatus),

#endif

/* IStream */
	MAKE_ENUM(Read, IStream),
	MAKE_ENUM(Write, IStream),
	MAKE_ENUM(Seek, IStream),
	MAKE_ENUM(SetSize, IStream),
	MAKE_ENUM(CopyTo, IStream),
	MAKE_ENUM(Commit, IStream),
	MAKE_ENUM(Revert, IStream),
	MAKE_ENUM(LockRegion, IStream),
	MAKE_ENUM(UnlockRegion, IStream),
	MAKE_ENUM(Stat, IStream),
	MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_ENUM(OnNotify, IMAPIAdviseSink),

/* IWABObject */
	MAKE_ENUM(GetLastError, IWABObject),
	MAKE_ENUM(AllocateBuffer, IWABObject),
	MAKE_ENUM(AllocateMore, IWABObject),
	MAKE_ENUM(FreeBuffer, IWABObject),
	MAKE_ENUM(Backup, IWABObject),
	MAKE_ENUM(Import, IWABObject),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, &First);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)				\
		AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients
   - validate always */

#define ValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)				\
		AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal)	(FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
		(FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
		(   AssertSz(   (   offsetof( ADRLIST, cEntries) \
						 == offsetof( SRowSet, cRows)) \
					 && (   offsetof( ADRLIST, aEntries) \
						 == offsetof( SRowSet, aRow)) \
					 && (   offsetof( ADRENTRY, cValues) \
						 == offsetof( SRow, cValues)) \
					 && (   offsetof( ADRENTRY, rgPropVals) \
						 == offsetof( SRow, lpProps)) \
					,  TEXT("ADRLIST doesn't match SRowSet")) \
		 || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR	*lppszW,
			 ULONG		cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST	lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *	This depends upon using the standard method of declaring the object
 *	interface.
 *
 *	prefix is the method prefix you chose when declaring the object interface.
 *	method is the standard method name of the calling method.
 *	lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
	(   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
	 || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
	 ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
	(	IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
	 ||	IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
	 ||	IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)	\
	(   IsBadReadPtr( riid, sizeof(IID)) \
	 || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *	No parameter validation required.
 */
#define FBadAddRef( lpObj)	FALSE


/*
 * Release
 *	No parameter validation required.
 */
#define FBadRelease( lpObj)	FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
	(IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *	No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)	FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
	(   (   lpPTagA \
		 && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
	 || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
	(IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
						, lppUnk) \
	(   IsBadReadPtr( lpiid, sizeof(IID)) \
	 || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
	(   FBadRgPropVal( lpPropArray, (UINT) cValues) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
	(   (   !lpPTagA \
		 || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
				  , ulUIParam, lpProgress, lpInterface, lpDestObj \
				  , ulFlags, lppProblems) \
	(	(	ciidExclude \
		 && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
	 || (   lpExcludeProps \
		 && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpExcludeProps \
			 				, (UINT)(  (lpExcludeProps->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
					 , ulUIParam, lpProgress, lpInterface, lpDestObj \
					 , ulFlags, lppProblems) \
	(   (   lpPropTagArray \
		 && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPropTagArray \
			 				, (UINT)(  (lpPropTagArray->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
							 lpcPropNames, lpppPropNames) \
	(   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
	 || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
	 || (   *lppPropTags \
		 && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
		 	 || IsBadReadPtr( *lppPropTags \
			 				, (UINT)( ( ( *lppPropTags)->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
	 || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
						   , lppPropTags) \
	(   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
	 || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

	The eMethod parameter tells us which internal validation to perform.
	
	The ppThis parameter tells us where the stack is, so we can access the other
	parameters.
	
	Becuase of this *magic* we MUST obtain the pointer to the This pointer in
	the method function.
	
*/

#ifdef WIN16
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParameters x), "Parameter validation failed for method called by MAPI!")
#else
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")
#endif

#if defined(_X86_) || defined( WIN16 )

#define ValidateParameters1( m, a1 )
#define ValidateParameters2( m, a1, a2 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters3( m, a1, a2, a3 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define UlValidateParameters1( m, a1 )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters3( m, a1, a2, a3 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define CheckParameters1( m, a1 )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters3( m, a1, a2, a3)	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )

#else /* !_X86_  && !WIN16 */

#define ValidateParameters1( m, a1 ) \
			ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )	\
			ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )	\
			ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
			UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )	\
			UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
			CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )	\
			CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *  	M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
			 CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
			 ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
			 UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
			 CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
			 ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
			 UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
			 CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
			 ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
			 UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
			 CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
			 CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
			 CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
			 ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
			 UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
			 CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
			 ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
			 UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
			 CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
			 ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
			 UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
			 CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
			 ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
			 UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
			 CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
			 ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
			 UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
			 CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
			 ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
			 UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
			 CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


/* IWABObject */

#define Validate_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IWABObject_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IWABOBject_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IWABObject_GetLastError, a1, a2, a3, a4 )


#define Validate_IWABObject_AllocateBuffer( a1, a2, a3 ) \
			 ValidateParameters3( IWABObject_AllocateBuffer, a1, a2, a3 )
#define UlValidate_IWABObject_AllocateBuffer( a1, a2, a3) \
			 UlValidateParameters3( IWABOBject_AllocateBuffer, a1, a2, a3 )
#define CheckParameters_IWABObject_AllocateBuffer( a1, a2, a3 ) \
			 CheckParameters3( IWABObject_AllocateBuffer, a1, a2, a3 )


#define Validate_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 ValidateParameters4( IWABObject_AllocateMore, a1, a2, a3, a4 )
#define UlValidate_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IWABOBject_AllocateMore, a1, a2, a3, a4 )
#define CheckParameters_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 CheckParameters4( IWABObject_AllocateMore, a1, a2, a3, a4 )


#define Validate_IWABObject_FreeBuffer( a1, a2 ) \
			 ValidateParameters2( IWABObject_FreeBuffer, a1, a2 )
#define UlValidate_IWABObject_FreeBuffer( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_FreeBuffer, a1, a2 )
#define CheckParameters_IWABObject_FreeBuffer( a1, a2 ) \
			 CheckParameters2( IWABObject_FreeBuffer, a1, a2 )


#define Validate_IWABObject_Backup( a1, a2 ) \
			 ValidateParameters2( IWABObject_Backup, a1, a2 )
#define UlValidate_IWABObject_Backup( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_Backup, a1, a2 )
#define CheckParameters_IWABObject_Backup( a1, a2 ) \
			 CheckParameters2( IWABObject_Backup, a1, a2 )


#define Validate_IWABObject_Import( a1, a2 ) \
			 ValidateParameters2( IWABObject_Import, a1, a2 )
#define UlValidate_IWABObject_Import( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_Import, a1, a2 )
#define CheckParameters_IWABObject_Import( a1, a2 ) \
			 CheckParameters2( IWABObject_Import, a1, a2 )






#ifdef WIN16
HRESULT
PASCAL	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV	HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabprint.h ===
#ifndef _MSGPRNT_H
#define _MSGPRNT_H

typedef struct _PrintInfo
{
    // Public fields for use
    HDC         hdcPrn;                 // The HDC to use for printing
    RECT        rcMargin;               // The margin settings for printing
    SIZE        sizeInch;               // Pixels to an inch
    SIZE        sizePage;               // Pixels to an page

    // Private fields used by the printing subroutines
    RECT        rcBand;                 // The current drawing area
    BOOL        fEndOfPage;             // Whether rcBand represents the end of
                                        //  of the page
    LONG        lPageNumber;            // The current page number
    LONG        lPrevPage;              // The last page we printed out so far
    TCHAR       szPageNumber[20];       // Formatting string for page number

    INT         yFooter;                // Where to put the footer

    HFONT       hfontSep;               // Font for separator
    HFONT       hfontPlain;             // Font for footer
    HFONT       hfontBold;             // Font for footer

    ABORTPROC   pfnAbortProc;           // Pointer to our abort proc

    HWND        hwnd;                   // Handle of our parent window
    TCHAR *     szHeader;               // Pointer to our header string
    HWND        hwndRE;                 // RichEdit control for rendering
    HWND        hwndDlg;                // Handle of the original note form
    // Form mode print support
    //PRINTDETAILS *  pprintdetails;
} PRINTINFO;


HRESULT HrPrintItems(HWND hWnd, LPADRBOOK lpIAB, HWND hWndListAB, BOOL bCurrentSortisByLastName);


// STDMETHODIMP WABPrintExt(LPADRBOOK FAR lpAdrBook, LPWABOBJECT FAR lpWABObject, HWND hWnd, LPADRLIST lpAdrList);

typedef HRESULT (STDMETHODCALLTYPE WABPRINTEXT)(LPADRBOOK FAR lpAdrBook, LPWABOBJECT FAR lpWABObject, HWND hWnd, LPADRLIST lpAdrList);
typedef WABPRINTEXT FAR * LPWABPRINTEXT;

#endif //_MSGPRNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\wabspi.h ===
#ifndef _WABSPI_H_
#define _WABSPI_H_

#ifdef __cplusplus
extern "C" {
#endif

// WAB object types
#define RECORD_CONTACT      0x00000001
#define RECORD_DISTLIST     0x00000002
#define RECORD_CONTAINER    0x00000003

//Flags used in property-type record searching (independent of property data)
#define AB_MATCH_PROP_ONLY  0x00000001

/**Flags used for calling find HrFindFuzzyRecordMatches**/
#define AB_FUZZY_FAIL_AMBIGUOUS 0x0000001
#define AB_FUZZY_FIND_NAME      0x0000010
#define AB_FUZZY_FIND_EMAIL     0x0000100
#define AB_FUZZY_FIND_ALIAS     0x0001000
#define AB_FUZZY_FIND_ALL       AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL | AB_FUZZY_FIND_ALIAS

// Container info struct
typedef struct _OutlookContInfo
{
	LPSBinary lpEntryID;
	LPSTR lpszName;
} OutlookContInfo;

// Container info struct - we need a LPTSTR version for the WAB
typedef struct _OlkContInfo
{
	LPSBinary lpEntryID;
	LPTSTR lpszName;
} OlkContInfo;

/* IWABStorageProvider Interface ---------------------------------------------------- */

#define CBIWABSTORAGEPROVIDER sizeof(IWABSTORAGEPROVIDER)


#define WAB_IWABSTORAGEPROVIDER_METHODS(IPURE)					\
	MAPIMETHOD(GetContainerList)								\
		(THIS_	LPULONG					lpulcCount,				\
				OutlookContInfo 		**prgolkci) IPURE;		\
	MAPIMETHOD(ReadRecord)										\
		(THIS_	LPSBinary				lpEntryID,				\
				ULONG					ulFlags,				\
				LPULONG					lpulcProps,				\
				LPSPropValue			*lppPropArray) IPURE;	\
	MAPIMETHOD(WriteRecord)										\
		(THIS_	LPSBinary				lpFolderID,				\
				LPSBinary				*lppEntryID,			\
				ULONG					ulFlags,				\
				ULONG					ulRecordType,			\
				ULONG					ulcProps,				\
				LPSPropValue			lpPropArray) IPURE;		\
	MAPIMETHOD(ReadPropArray)									\
		(THIS_	LPSBinary				lpFolderID,				\
				SPropertyRestriction	*lpPropRes,				\
				ULONG					ulFlags,				\
				ULONG					ulPropTagCount,			\
				LPULONG					lpPropTagArray,			\
				LPADRLIST				*lppContentList) IPURE;	\
	MAPIMETHOD(FindRecords)										\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulFlags,				\
				SPropertyRestriction	*lpPropRes,				\
				LPULONG					lpulcCount,				\
				LPSBinary				*rgEntryIDs) IPURE;		\
	MAPIMETHOD(DeleteRecord)									\
		(THIS_	LPSBinary				lpEntryID) IPURE;		\
	MAPIMETHOD(GetContentsTable)								\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulFlags,				\
				LPMAPITABLE				*lppTable) IPURE;		\
	MAPIMETHOD(FindFuzzyRecordMatches)							\
		(THIS_	LPSBinary				lpFolderID,				\
				LPSTR					lpszDisplayName,		\
				ULONG					ulFlags,				\
				LPULONG					lpulcCount,				\
				LPSBinary				*rgEntryIDs) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)									\
		(THIS_	ULONG					cPropNames,				\
				LPMAPINAMEID			*lppPropNames,			\
				ULONG					ulFlags,				\
				LPSPropTagArray			*lppPropTags) IPURE;	\
	MAPIMETHOD(ReadMessage)										\
		(THIS_	LPMESSAGE				pmess,					\
				LPULONG					lpulcProps,				\
				LPSPropValue			*lppPropArray) IPURE;	\
	MAPIMETHOD(CreateRecord)									\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulcProps,				\
				LPSPropValue			lpPropArray,			\
				IMessage				**lppMessage) IPURE;	\
	MAPIMETHOD(FreeEntryIDs)									\
		(THIS_	ULONG					ulcCount,				\
				LPSBinary				rgEntryIDs) IPURE;		\
	MAPIMETHOD(FreePropArray)									\
		(THIS_	ULONG					ulcProps,				\
				LPSPropValue			lpPropArray) IPURE;		\
	MAPIMETHOD(FreeContentList)									\
		(THIS_	LPADRLIST				lpContentList) IPURE;	\

#undef           INTERFACE
#define          INTERFACE      IWABStorageProvider
DECLARE_MAPI_INTERFACE_(IWABStorageProvider, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABSTORAGEPROVIDER_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABStorageProvider, LPWABSTORAGEPROVIDER);


#undef  INTERFACE
#define INTERFACE       struct _IWABSTORAGEPROVIDER

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABSTORAGEPROVIDER_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABSTORAGEPROVIDER_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABSTORAGEPROVIDER_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABSTORAGEPROVIDER_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
};



//
// Root public entry point for WAB SPI
//
STDMETHODIMP WABOpenStorageProvider(HWND hwnd, LPUNKNOWN pmsess,
		LPALLOCATEBUFFER lpAllocateBuffer, LPALLOCATEMORE lpAllocateMore,
		LPFREEBUFFER lpFreeBuffer, BOOL fUnicode,
		LPWABSTORAGEPROVIDER FAR * lppWSP);

typedef HRESULT (STDMETHODCALLTYPE WABOPENSTORAGEPROVIDER)(
	HWND hwnd,
	LPUNKNOWN pmsess,
	LPALLOCATEBUFFER lpAllocateBuffer,
	LPALLOCATEMORE lpAllocateMore,
	LPFREEBUFFER lpFreeBuffer,
	BOOL fUnicode,
	LPWABSTORAGEPROVIDER FAR * lppWSP
);
typedef WABOPENSTORAGEPROVIDER FAR * LPWABOPENSTORAGEPROVIDER;

#define OUTLWAB_DLL_NAME "OUTLWAB.DLL"

#define WAB_SPI_ENTRY_POINT "WABOpenStorageProvider"
#define WAB_SPI_ENTRY_POINT_W "WABOpenStorageProviderW"

#ifdef __cplusplus
}
#endif

#endif /* _WABSPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_contabl.h ===
/***********************************************************************
 *
 *  _CONTABL.H
 *
 *  Header file for code in CONTABLE.C
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//  Entry point to create the AB Hierarchy object
//

// Creates a new content table
//
HRESULT NewContentsTable(LPABCONT lpABContainer,
  LPIAB lpIAB,
  ULONG ulFlags,
  LPCIID  lpInterface,
  LPVOID *lppROOT);

CALLERRELEASE ContentsViewGone;

HRESULT GetEntryProps(
  LPABCONT lpContainer,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPSPropTagArray lpSPropTagArray,
  LPVOID lpAllocMoreHere,
  ULONG ulFlags,
  LPULONG lpulcProps,
  LPSPropValue * lppSPropValue);

// Reads in data from the WAB store and fills in the ContentsTable
//
HRESULT FillTableDataFromPropertyStore(LPIAB lpIAB,
  LPSPropTagArray lppta,
  LPTABLEDATA lpTableData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_abroot.h ===
/***********************************************************************
 *
 *  _ABROOT.H
 *
 *  Header file for code in ABROOT.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer for ROOT object.  (i.e. IAB::OpenEntry() with an
 *  lpEntryID of NULL).
 */

#undef	INTERFACE
#define INTERFACE	struct _ROOT

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ROOT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ROOT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ROOT_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _ROOT {
    MAILUSER_BASE_MEMBERS(ROOT)
    ULONG ulType;
} ROOT, *LPROOT;

#define CBROOT	sizeof(ROOT)

//
//  Entry point to create the AB Hierarchy object
//

HRESULT NewROOT(LPVOID lpObj,
  ULONG ulIntFlag,
  LPCIID lpInterface,
  ULONG ulOpenFlags,
  ULONG *lpulObjType,
  LPVOID *lppROOT);


//  Internal flags for NewROOT
#define AB_ROOT ((ULONG)0x00000000)
#define AB_WELL ((ULONG)0x00000001)

// Internal flag that tells the root contents table that even if this is a 
// profile session, ignore all the user containers except the "All Contacts" 
// item and only add the "All contact" item
// This simulates the old-type behaviour where you get a single local container
// Internal-only flag
//
#define WAB_NO_PROFILE_CONTAINERS   0x00400000

// registry settings
extern const LPTSTR szWABKey;

/*
 *  Creates a new Hierarchy table off the Root object
 */
HRESULT MergeHierarchy(LPROOT lpROOT,
  LPIAB lpIAB,
  ULONG ulFlags);

//BOOL ResolveLDAPServers(void);

/*
 *	 call back function used to rebuild hierarchy and one off tables
 */
NOTIFCALLBACK lTableNotifyCallBack;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_distlst.h ===
/*
-
-   Distribution List interface
-
*/
#ifndef _DISTLIST_H_
#define _DISTLIST_H_


#ifdef OLD_STUFF
#undef	INTERFACE
#define INTERFACE	struct _DistList

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, DistList_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, DistList_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(DistList_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _DistList {
    MAILUSER_BASE_MEMBERS(DistList)
} DistList, FAR * LPDistList;	
#endif

extern CONTAINER_Vtbl vtblDISTLIST;



#undef	INTERFACE
#define INTERFACE	struct _DLENTRY

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, DLENTRY_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, DLENTRY_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(DLENTRY_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _DLENTRY {
    MAILUSER_BASE_MEMBERS(DLENTRY)
    LPCONTAINER         lpCONTAINER;    // DistList containing this DLENTRY
} DLENTRY, FAR * LPDLENTRY;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_apipch.h ===
/*
 *      _APIPCH.H
 *
 *      Precompile these headers.
 *      
 *      When adding new .h and .c files into the WAB, add the .h
 *      file here and include this file in the .C file
 *
 */

#define UNICODE
// This flag ensures that all we only pull in functions that return
// ASCII and not UTF-8.
//#define LDAP_UNICODE 0

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrls ... the base requirement for the WAB is the
// IE 3.0x common control. WAB doesn't use any of the newer commctrl features
// and so does not have an IE4 dependency
//
#ifndef _WIN64
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0400
#endif

// Turns on the Parameter checking for most of the WAB API
#define PARAMETER_VALIDATION 1

#ifdef WIN16
#define WINAPI_16 WINAPI
#endif

#define _COMDLG32_ // We delayload common dialogs

#include <windows.h>
#include <windowsx.h>
#ifdef WIN16
#include <shlwapi.h>
#include <shellapi.h>
#include <winregp.h>
#include <ver.h>
#include <dlgs.h>
#include <commdlg.h>
#include <comctlie.h>
#include <athena16.h>
#include <mapi.h>
#include <wab16.h>
#include <prsht.h>
#else
#include <zmouse.h>
#endif // WIN16
#include <wab.h>
#include <wabdbg.h>
#include <wabguid.h>
#ifndef WIN16
#include <mapi.h>
#endif
#include <shlobj.h>
#include <wininet.h>
#include <docobj.h>
#include <mshtml.h>
#include <urlmon.h>
#include <msident.h>
#include <_layguid.h>
#include <_entryid.h>
#include <_imem.h>
#include <_imemx.h>
#include <glheap.h>
#include <_glheap.h>
#include <_mapiprv.h>
#include <limits.h>
#include <unkobj.h>
#include <wabval.h>
#include <_iprop.h>
#include <_memcpy.h>
//#include <_huntype.h>
#include <_mapiu.h>
#include <_runt.h>
#include <_itable.h>
#include <structs.h>
#include <_wabapi.h>
#include <_wabobj.h>
#include <iadrbook.h>
#include <_wrap.h>
#include "_notify.h"
#include <_iab.h>
#include <_errctx.h>
#include <_mailusr.h>
#include <_abcont.h>
#include <winldap.h>
#include <wabspi.h>
#include <imnact.h>
#include <_ldapcnt.h>
#include <_distlst.h>
#include <_abroot.h>
#include <mutil.h>
#include <mapiperf.h>
#include <_contabl.h>
#include <ui_clbar.h>
#ifndef WIN16
#include <commctrl.h>
#endif
#include "..\wab32res\resource.h"
#include "..\wab32res\resrc1.h"
#include <wincrypt.h>
#include <certs.h>
#include <_idrgdrp.h>
#include <_dochost.h>
#include <uimisc.h>
#include <ui_detls.h>
#include <ui_addr.h>
#include <ui_reslv.h>
#include "fonts.h"
#include <_vcard.h>
#include <globals.h>
#include "wabprint.h"
#include "_profile.h"
#include "_wabtags.h"
#include "..\wabhelp\adcs_ids.h"
#include <cryptdlg.h>

#ifndef WIN16
#include <capi.h>
#endif
#include "dial.h"
#include "_printex.h"
#include <pstore.h>
#include "demand.h"     // must be last!

#define TABLES TRUE

#include <ansiwrap.h>
#include "w9xwraps.h"

#ifdef WIN16
#ifndef GetLastError
#define GetLastError()     (-1)
#endif // !GetLastError
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_dochost.h ===
/****
*
*
*
* DocHost2 - second attempt at the WAB Doc Host interface
*
*
*    Purpose:
*        basic implementation of a docobject host. Used by the body class to
*        host Trident and/or MSHTML - when we do LDAP searches, LDAP providers
-       are allowed to return URLs in the LDAPURI attribute. WAB then addds
-       a "general" property tab that hosts trident and shows the contents
-       of the URL within the WAB. This allows the providers to add ADs and
-       branding to their data to diffrentiate themselves from each other.
-       Oh, the things we do for business relationships ... 
*
*  History
*      August '96: brettm - created
*      Ported to WAB - vikramm 4/97
*    
*    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
****/

#ifndef _DOCHOST_H
#define _DOCHOST_H

#define RECYCLE_TRIDENT
//#define ASYNC_LOADING

// DocHost border sytles
enum
{
    dhbNone     =0x0,   // no border
    dhbHost     =0x01,  // dochost paints border
    dhbObject   =0x02   // docobj paints border
};



/* IWABDocHost Interface ---------------------------------------------------- */

struct _IWABDOCHOST;
typedef struct _IWABDOCHOST *LPIWABDOCHOST;



/* IWDH_OLEWINDOW ------------------------------------------------------ */
#define CBIWDH_OLEWINDOW sizeof(IWDH_OLEWINDOW)

/* This contains these interfaces ...

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

*/

#define IWDH_OLEWINDOW_METHODS(IPURE)	                    \
    MAPIMETHOD(GetWindow)                                       \
        (THIS_  HWND *                  phWnd)          IPURE;  \
    MAPIMETHOD(ContextSensitiveHelp)                            \
        (THIS_  BOOL                    fEnterMode)     IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleWindow
DECLARE_MAPI_INTERFACE_(IWDH_OleWindow, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLEWINDOW_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEWINDOW

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEWINDOW_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEWINDOW_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEWINDOW_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEWINDOW_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEWINDOW_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEWINDOW_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
};


typedef struct _IWDH_OLEWINDOW
{
    MAPIX_BASE_MEMBERS(IWDH_OLEWINDOW)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEWINDOW, * LPIWABDOCHOST_OLEWINDOW;

/* ----------------------------------------------------------------------------------------------*/




/* IWDH_OLEINPLACEFRAME ------------------------------------------------------ */
#define CBIWDH_OLEINPLACEFRAME sizeof(IWDH_OLEINPLACEFRAME)

/* This contains these interfaces ...

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

*/

#undef TranslateAccelerator

#define IWDH_OLEINPLACEFRAME_METHODS(IPURE)	                    \
    MAPIMETHOD(GetBorder)                                       \
        (THIS_  LPRECT                  lprc)           IPURE;  \
    MAPIMETHOD(RequestBorderSpace)                              \
        (THIS_  LPCBORDERWIDTHS         pborderwidths)  IPURE;  \
    MAPIMETHOD(SetBorderSpace)                                  \
        (THIS_  LPCBORDERWIDTHS         pborderwidths)  IPURE;  \
    MAPIMETHOD(SetActiveObject)                                 \
        (THIS_  IOleInPlaceActiveObject * pActiveObject,        \
                LPCOLESTR               lpszObjName)    IPURE;  \
    MAPIMETHOD(InsertMenus)                                     \
        (THIS_  HMENU                   hMenu,                  \
                LPOLEMENUGROUPWIDTHS    lpMenuWidths)   IPURE;  \
    MAPIMETHOD(SetMenu)                                         \
        (THIS_  HMENU                   hMenu,                  \
                HOLEMENU                hOleMenu,               \
                HWND                    hWnd)           IPURE;  \
    MAPIMETHOD(RemoveMenus)                                     \
        (THIS_  HMENU                   hMenu)          IPURE;  \
    MAPIMETHOD(SetStatusText)                                   \
        (THIS_  LPCOLESTR               pszStatusText)  IPURE;  \
    MAPIMETHOD(EnableModeless)                                  \
        (THIS_  BOOL                    fEnable)        IPURE;  \
    MAPIMETHOD(TranslateAccelerator)                            \
        (THIS_  MSG *                   lpmsg,                  \
                WORD                    wID)            IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleInPlaceFrame
DECLARE_MAPI_INTERFACE_(IWDH_OleInPlaceFrame, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
    	IWDH_OLEWINDOW_METHODS(PURE)
        IWDH_OLEINPLACEFRAME_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEINPLACEFRAME

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEINPLACEFRAME_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEINPLACEFRAME_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACEFRAME_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEINPLACEFRAME_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACEFRAME_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEINPLACEFRAME_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
	IWDH_OLEINPLACEFRAME_METHODS(IMPL)
};


typedef struct _IWDH_OLEINPLACEFRAME
{
    MAPIX_BASE_MEMBERS(IWDH_OLEINPLACEFRAME)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEINPLACEFRAME, * LPIWABDOCHOST_OLEINPLACEFRAME;

/* ----------------------------------------------------------------------------------------------*/



/* IWDH_OLEINPLACESITE ------------------------------------------------------ */
#define CBIWDH_OLEINPLACESITE sizeof(IWDH_OLEINPLACESITE)

/* This contains these interfaces ...

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

*/

#define IWDH_OLEINPLACESITE_METHODS(IPURE)	                    \
    MAPIMETHOD(CanInPlaceActivate)                              \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnInPlaceActivate)                               \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnUIActivate)                                    \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(GetWindowContext)                                \
        (THIS_  LPOLEINPLACEFRAME *     ppFrame,                \
                LPOLEINPLACEUIWINDOW *  ppDoc,                  \
                LPRECT                  lprcPosRect,            \
                LPRECT                  lprcClipRect,           \
                LPOLEINPLACEFRAMEINFO   lpFrameInfo)    IPURE;  \
    MAPIMETHOD(Scroll)                                          \
        (THIS_  SIZE                    scrollExtent)   IPURE;  \
    MAPIMETHOD(OnUIDeactivate)                                  \
        (THIS_  BOOL                    fUndoable)      IPURE;  \
    MAPIMETHOD(OnInPlaceDeactivate)                             \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(DiscardUndoState)                                \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(DeactivateAndUndo)                               \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnPosRectChange)                                 \
        (THIS_  LPCRECT                 lprcPosRect)    IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleInPlaceSite
DECLARE_MAPI_INTERFACE_(IWDH_OleInPlaceSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
    	IWDH_OLEWINDOW_METHODS(PURE)
        IWDH_OLEINPLACESITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEINPLACESITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEINPLACESITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEINPLACESITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACESITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEINPLACESITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACESITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEINPLACESITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
	IWDH_OLEINPLACESITE_METHODS(IMPL)
};


typedef struct _IWDH_OLEINPLACESITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLEINPLACESITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEINPLACESITE, * LPIWABDOCHOST_OLEINPLACESITE;

/* ----------------------------------------------------------------------------------------------*/



/* IWDH_OLECLIENTSITE ------------------------------------------------------ */
#define CBIWDH_OLECLIENTSITE sizeof(IWDH_OLECLIENTSITE)

/* This contains these interfaces ...

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

*/

#define IWDH_OLECLIENTSITE_METHODS(IPURE)	                    \
    MAPIMETHOD(SaveObject)                                      \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(GetMoniker)                                      \
        (THIS_  DWORD                   dwAssign,               \
                DWORD                   dwWhichMoniker,         \
                LPMONIKER *             ppmnk)          IPURE;  \
    MAPIMETHOD(GetContainer)                                    \
        (THIS_  LPOLECONTAINER *        ppCont)         IPURE;  \
    MAPIMETHOD(ShowObject)                                      \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnShowWindow)                                    \
        (THIS_  BOOL                    fShow)          IPURE;  \
    MAPIMETHOD(RequestNewObjectLayout)                          \
        (THIS)                                          IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleClientSite
DECLARE_MAPI_INTERFACE_(IWDH_OleClientSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLECLIENTSITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLECLIENTSITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLECLIENTSITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLECLIENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLECLIENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLECLIENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLECLIENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLECLIENTSITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLECLIENTSITE_METHODS(IMPL)
};


typedef struct _IWDH_OLECLIENTSITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLECLIENTSITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLECLIENTSITE, * LPIWABDOCHOST_OLECLIENTSITE;

/* ----------------------------------------------------------------------------------------------*/








/* IWDH_OLEDOCUMENTSITE ------------------------------------------------------ */
#define CBIWDH_OLEDOCUMENTSITE sizeof(IWDH_OLEDOCUMENTSITE)

/* This contains these interfaces ...

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

*/

#define IWDH_OLEDOCUMENTSITE_METHODS(IPURE)	                    \
    MAPIMETHOD(ActivateMe)                                      \
        (THIS_  LPOLEDOCUMENTVIEW       pViewToActivate)IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleDocumentSite
DECLARE_MAPI_INTERFACE_(IWDH_OleDocumentSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLEDOCUMENTSITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEDOCUMENTSITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEDOCUMENTSITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEDOCUMENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEDOCUMENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEDOCUMENTSITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
};


typedef struct _IWDH_OLEDOCUMENTSITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLEDOCUMENTSITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEDOCUMENTSITE, * LPIWABDOCHOST_OLEDOCUMENTSITE;

/* ----------------------------------------------------------------------------------------------*/








/*********************************************/


#undef           INTERFACE
#define          INTERFACE      IWABDocHost
DECLARE_MAPI_INTERFACE_(IWABDocHost, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
};

#undef	INTERFACE
#define INTERFACE	struct _IWABDOCHOST


#undef  METHOD_PREFIX
#define METHOD_PREFIX       IWABDOCHOST_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM         lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IWABDOCHOST_)
		MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IWABDOCHOST_)
		MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABDOCHOST_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
};



typedef struct _IWABDOCHOST
{
    MAPIX_BASE_MEMBERS(IWABDOCHOST)

    // Pointer to self ...
    LPIWABDOCHOST lpIWDH;

    LPIWABDOCHOST_OLEWINDOW lpIWDH_OleWindow;

    LPIWABDOCHOST_OLEINPLACEFRAME lpIWDH_OleInPlaceFrame;
    
    LPIWABDOCHOST_OLEINPLACESITE lpIWDH_OleInPlaceSite;

    LPIWABDOCHOST_OLECLIENTSITE lpIWDH_OleClientSite;

    LPIWABDOCHOST_OLEDOCUMENTSITE lpIWDH_OleDocumentSite;


    //protected
    HWND                        m_hwnd;
    HWND                        m_hwndDocObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    BOOL                        m_fInPlaceActive;
    BOOL                        m_fUIActive;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
    //LPOLEINPLACEACTIVEOBJECT    m_pIPObj;
    LPOLEINPLACEOBJECT          m_pIPObj;

       
} IWABDOCHOST, * LPIWABDOCHOST;




// Exposed functions 

// Create a new WAB DocHost object
HRESULT HrNewWABDocHostObject(LPVOID * lppIWABDOCHOST);
void ReleaseDocHostObject(LPIWABDOCHOST lpIWABDocHost);
void UninitTrident();
// Loads the URL from the URL string
HRESULT HrLoadURL(LPIWABDOCHOST lpIWABDocHost, LPTSTR lpszURL);
// Initialization
HRESULT HrInit(LPIWABDOCHOST lpIWABDocHost, HWND hwndParent, int idDlgItem, DWORD dhbBorder);


/////////////////


typedef HRESULT (STDMETHODCALLTYPE CREATEURLMONIKER)
(
    LPMONIKER pMkCtx, 
    LPCWSTR szURL, 
    LPMONIKER FAR * ppmk             
);

typedef CREATEURLMONIKER FAR * LPCREATEURLMONIKER;


// statics
//static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Not ported over ...
//
// BOOL WMNotify(int idFrom, NMHDR *pnmh) PURE;
// BOOL WMCommand(HWND, int, WORD) PURE;
// void OnDownloadComplete();
// HWND Hwnd();



#ifndef WIN16 // Win16 uses shlwapi.h rather than copy some of data from it.

////////////////////////////////
// This is copied from shwlapi.h - not sure if its a good idea to 
// copy this but shwlapi.h has bunch of stuff we're not interested in ..
//
//
//====== DllGetVersion  =======================================================
//
typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//
typedef HRESULT (STDMETHODCALLTYPE DLLGETVERSIONPROC)(DLLVERSIONINFO *);
#endif // !WIN16
typedef DLLGETVERSIONPROC FAR * LPDLLGETVERSIONPROC;

 
#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_glheap.h ===
/*
 * glheap.h
 *
 * Private definitions for GLHEAP facility
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef _GLHEAP_H_
#define _GLHEAP_H_

#ifndef __GLHEAP_H_
#include "_glheap.h"
#endif

#if defined (WIN32) && !defined (MAC) && !defined(_WIN64)
#define HEAPMON
#endif

#define chDefaultFill	((BYTE)0xFE)
#define NCALLERS		20

typedef struct LH		LH,		* PLH,		** PPLH;
typedef struct LHBLK	LHBLK,	* PLHBLK,	** PPLHBLK;

#ifdef HEAPMON
typedef BOOL (APIENTRY HEAPMONPROC)(PLH plh, ULONG ulFlags);
typedef HEAPMONPROC FAR *LPHEAPMONPROC;
typedef BOOL (APIENTRY GETSYMNAMEPROC)(DWORD, LPSTR, LPSTR, DWORD FAR *);
typedef GETSYMNAMEPROC FAR *LPGETSYMNAMEPROC;

#define HEAPMON_LOAD		((ULONG) 0x00000001)
#define HEAPMON_UNLOAD		((ULONG) 0x00000002)
#define HEAPMON_PING		((ULONG) 0x00000003)
#endif

#define HEAP_USE_VIRTUAL		((ULONG) 0x00000001)
#define HEAP_DUMP_LEAKS			((ULONG) 0x00000002)
#define HEAP_ASSERT_LEAKS		((ULONG) 0x00000004)
#define HEAP_FILL_MEM			((ULONG) 0x00000008)
#define HEAP_HEAP_MONITOR		((ULONG) 0x00000010)
#define HEAP_USE_VIRTUAL_4		((ULONG) 0x00000020)
#define HEAP_FAILURES_ENABLED	((ULONG) 0x00000040)
#define HEAP_LOCAL				((ULONG) 0x10000000)
#define HEAP_GLOBAL				((ULONG) 0x20000000)


typedef void (__cdecl *LPLHSETNAME)(LPVOID, char *, ...);

struct LHBLK
{
	HLH			hlh;			// Heap this block was allocated on
	PLHBLK		plhblkPrev;		// Pointer to the previous allocation this heap
	PLHBLK		plhblkNext;		// Pointer to the next allocation this heap
	TCHAR		szName[128];		// We can name blocks allocated on a heap
	ULONG		ulAllocNum;		// Allocation number (Id) for this block
	ULONG		ulSize;			// Number of bytes the client requested
	FARPROC		pfnCallers[NCALLERS]; // Call stack during this allocation
	LPVOID		pv;				// Pointer to the client data
};

struct LH
{
	LPLHSETNAME	pfnSetName;		// Pointer to LH_SetNameFn function
	_HLH		_hlhData;		// The underlying heap that we alloc data from
	_HLH		_hlhBlks;		// The underlying heap that we alloc lhblks from
	PLH			pNext;			// Pointer to the next heap in a list of heaps
	TCHAR		szHeapName[32];	// We can name our heaps for display purposes
	ULONG		ulAllocNum;		// Allocation number this heap since Open
	PLHBLK		plhblkHead;		// Link-list of allocations on this heap
	ULONG		ulFlags;		// Combination of the HEAP_ flags above
	BYTE		chFill;			// Character to fill memory with
#ifdef HEAPMON
	HINSTANCE	hInstHeapMon;	// DLL instance of the HeapMonitor DLL
	LPHEAPMONPROC pfnHeapMon;	// Entry point into HeapMonitor DLL
#endif
#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION cs;		// Critcal section to protect access to heap
#endif
	UINT		uiFailBufSize;	// If HEAP_FAILURES_ENABLED, this is the minimum size in
								// which failures occur.  1 means alloc's of any size fail.
								// 0 means never fail.
	ULONG		ulFailInterval;	// If HEAP_FAILURES_ENABLED, this is the period on which the
								// failures occur.  1 means every alloc will fail. 0 means never
								// fail.
	ULONG		ulFailStart;	// If HEAP_FAILURES_ENABLED, this is the allocation number that
								// the first failure will occur on.  1 means the first alloc.  0
								// means never start failing.	
	// Put at end to avoid re-compile of World!
#ifdef HEAPMON
	LPGETSYMNAMEPROC pfnGetSymName;	// Resolve address to Symbol
#endif
};

PLHBLK	PvToPlhblk(HLH hlh, LPVOID pv);
#define PlhblkToPv(pblk)		((LPVOID)((PLHBLK)(pblk)->pv))
#define CbPlhblkClient(pblk)	(((PLHBLK)(pblk))->ulSize)
#define CbPvClient(hlh, pv)		(CbPlhblkClient(PvToPlhblk(hlh, pv)))
#define CbPvAlloc(hlh, pv)		(CbPlhblkAlloc(PvToPlhblk(hlh, pv)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_entryid.h ===
/***********************************************************************
 *
 * _ENTRYID.H
 *
 * Internal headers for the WABAPI: entryid.c
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 05.13.96     Bruce Kelley        Created
 *
 ***********************************************************************/


// Types of WAB EntryIDs.  This byte sized value indicates what type of
// entryid this is.
enum _WAB_ENTRYID_TYPE {
    // Must not use 0, this value is invalid.
    WAB_PAB = 1,        // "PAB" entryif
    WAB_DEF_DL,         // Default DistList - used for the DistList Template EIDs (used in CreateEntry/NewEntry)
    WAB_DEF_MAILUSER,   // Default Mailuser - used for the MailUser Template EIDs (used in CreateEntry/NewEntry)
    WAB_ONEOFF,         // One Off entryid
    WAB_ROOT,           // Root object
    WAB_DISTLIST,       // Distribution list
    WAB_CONTAINER,      // Container object
    WAB_LDAP_CONTAINER, // LDAP containers - these are special because the container really doesn't exist
    WAB_LDAP_MAILUSER,  // LDAP mailuser entryid
    WAB_PABSHARED,      // "Shared Contacts" folder which is virtual so needs special treatment
};

// Creates WAB entryids
HRESULT CreateWABEntryID(
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG cbData1,
    ULONG cbData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID);

HRESULT CreateWABEntryIDEx(
    BOOL bIsUnicode,
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG cbData1,
    ULONG cbData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID);

// Checks if it's a valid WAB entryID
BYTE IsWABEntryID(
    ULONG cbEntryID,
    LPENTRYID lpEntryID,
    LPVOID * lppData1,
    LPVOID * lppData2,
    LPVOID * lppData3,
    LPVOID * lppData4,
    LPVOID * lppData5);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_errctx.h ===
/***********************************************************************
 *
 * _ERRCTX.H
 *
 * Error contexts defines for MAPI Components.
 *
 * Copyright 1992-95 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*********
VIKRAMM 10/10/98
I don't have a clue what this file is about - in 3 years this is the first
time I've looked in it .. 
But don't delete it since we don't know what it does
*********/


/*
 * Names for defines are of the following form:
 *
 * CONT_ ==> abbreviation for Error Context
 * <object type>_ ==> will be either SESS, SUPP, ADDR, OOP, PRP, BASE
 * <abbreviated method name>_ ==> an abbreviated form of the method
 * <index> ==> starts at 1, and grows to as many contexts as are needed
 *
 *	Example: CONT_SESS_GETMSTABLE_1 is the first error context define for
 *		IMAPISession::GetMessageStoresTable.
 */

/* Base number that all contexts are offset from. */
#define MAPIX_CONTEXT_BASE			(0x0200)

/* Multiplier to separate each section. Note that this means that this */
/* mechanism only allows 0x20 (32) contexts per section. */
#define MAPIX_CONTEXT_MULT			(0x20)

#define OFFSET_CONTEXT(a,b)			\
		(((a)*MAPIX_CONTEXT_MULT) + ((b) + MAPIX_CONTEXT_BASE))


//	The following context groups belong to IMAPISession methods.

#define CONT_SESS_GETMSTABLE_1		OFFSET_CONTEXT(0, 0)
#define CONT_SESS_GETMSTABLE_2		OFFSET_CONTEXT(0, 1)
#define CONT_SESS_GETMSTABLE_3		OFFSET_CONTEXT(0, 2)
#define CONT_SESS_GETMSTABLE_4		OFFSET_CONTEXT(0, 3)

#define CONT_SESS_OPENAB_1			OFFSET_CONTEXT(1, 0)
#define CONT_SESS_OPENAB_2			OFFSET_CONTEXT(1, 1)
#define CONT_SESS_OPENAB_3			OFFSET_CONTEXT(1, 2)

#define CONT_SESS_ADVISE_1			OFFSET_CONTEXT(2, 0)
#define CONT_SESS_ADVISE_2			OFFSET_CONTEXT(2, 1)
#define CONT_SESS_ADVISE_3			OFFSET_CONTEXT(2, 2)
#define CONT_SESS_ADVISE_4			OFFSET_CONTEXT(2, 3)
#define CONT_SESS_ADVISE_5			OFFSET_CONTEXT(2, 4)
#define CONT_SESS_ADVISE_6			OFFSET_CONTEXT(2, 5)

#define CONT_SESS_UNADVISE_1		OFFSET_CONTEXT(3, 0)

#define CONT_SESS_OPENMS_1			OFFSET_CONTEXT(4, 0)
#define CONT_SESS_OPENMS_2			OFFSET_CONTEXT(4, 1)
#define CONT_SESS_OPENMS_3			OFFSET_CONTEXT(4, 2)
#define CONT_SESS_OPENMS_4			OFFSET_CONTEXT(4, 3)
#define CONT_SESS_OPENMS_5			OFFSET_CONTEXT(4, 4)
#define CONT_SESS_OPENMS_6			OFFSET_CONTEXT(4, 5)
#define CONT_SESS_OPENMS_7			OFFSET_CONTEXT(4, 6)
#define CONT_SESS_OPENMS_8			OFFSET_CONTEXT(4, 7)
#define CONT_SESS_OPENMS_9			OFFSET_CONTEXT(4, 8)
#define CONT_SESS_OPENMS_10			OFFSET_CONTEXT(4, 9)
#define CONT_SESS_OPENMS_11			OFFSET_CONTEXT(4, 10)
#define CONT_SESS_OPENMS_12			OFFSET_CONTEXT(4, 11)
#define CONT_SESS_OPENMS_13			OFFSET_CONTEXT(4, 12)

#define CONT_SESS_SETDEFMS_1		OFFSET_CONTEXT(5, 0)
#define CONT_SESS_SETDEFMS_2		OFFSET_CONTEXT(5, 1)
#define CONT_SESS_SETDEFMS_3		OFFSET_CONTEXT(5, 2)
#define CONT_SESS_SETDEFMS_4		OFFSET_CONTEXT(5, 3)
#define CONT_SESS_SETDEFMS_5		OFFSET_CONTEXT(5, 4)

#define CONT_SESS_GETSTATTBL_1		OFFSET_CONTEXT(6, 0)
#define CONT_SESS_GETSTATTBL_2		OFFSET_CONTEXT(6, 1)

#define CONT_SESS_MSGOPT_1			OFFSET_CONTEXT(7, 0)
#define CONT_SESS_MSGOPT_2			OFFSET_CONTEXT(7, 1)
#define CONT_SESS_MSGOPT_3			OFFSET_CONTEXT(7, 2)
#define CONT_SESS_MSGOPT_4			OFFSET_CONTEXT(7, 3)
#define CONT_SESS_MSGOPT_5			OFFSET_CONTEXT(7, 4)
#define CONT_SESS_MSGOPT_6			OFFSET_CONTEXT(7, 5)
#define CONT_SESS_MSGOPT_7			OFFSET_CONTEXT(7, 6)
#define CONT_SESS_MSGOPT_8			OFFSET_CONTEXT(7, 7)

#define CONT_SESS_OPENPROF_1		OFFSET_CONTEXT(8, 0)
#define CONT_SESS_OPENPROF_2		OFFSET_CONTEXT(8, 1)

#define CONT_SESS_COMPEID_1			OFFSET_CONTEXT(9, 0)
#define CONT_SESS_COMPEID_2			OFFSET_CONTEXT(9, 1)

#define CONT_SESS_OPENENTRY_1		OFFSET_CONTEXT(10, 0)
#define CONT_SESS_OPENENTRY_2		OFFSET_CONTEXT(10, 1)
#define CONT_SESS_OPENENTRY_3		OFFSET_CONTEXT(10, 2)
#define CONT_SESS_OPENENTRY_4		OFFSET_CONTEXT(10, 3)
#define CONT_SESS_OPENENTRY_5		OFFSET_CONTEXT(10, 4)
#define CONT_SESS_OPENENTRY_6		OFFSET_CONTEXT(10, 5)
#define CONT_SESS_OPENENTRY_7		OFFSET_CONTEXT(10, 6)
#define CONT_SESS_OPENENTRY_8		OFFSET_CONTEXT(10, 7)
#define CONT_SESS_OPENENTRY_9		OFFSET_CONTEXT(10, 8)
#define CONT_SESS_OPENENTRY_10		OFFSET_CONTEXT(10, 9)
#define CONT_SESS_OPENENTRY_11		OFFSET_CONTEXT(10, 10)

#define CONT_SESS_QDEFMSGOPTS_1		OFFSET_CONTEXT(11, 0)
#define CONT_SESS_QDEFMSGOPTS_2		OFFSET_CONTEXT(11, 1)

#define CONT_SESS_ENUMATYPES_1		OFFSET_CONTEXT(12, 0)
#define CONT_SESS_ENUMATYPES_2		OFFSET_CONTEXT(12, 1)

#define CONT_SESS_QID_1				OFFSET_CONTEXT(13, 0)
#define CONT_SESS_QID_2				OFFSET_CONTEXT(13, 1)
#define CONT_SESS_QID_3				OFFSET_CONTEXT(13, 2)
#define CONT_SESS_QID_4				OFFSET_CONTEXT(13, 3)
#define CONT_SESS_QID_5				OFFSET_CONTEXT(13, 4)

#define CONT_SESS_ADMINSVCS_1		OFFSET_CONTEXT(14, 0)

#define CONT_SESS_SENDNOTE_1		OFFSET_CONTEXT(15, 0)
#define CONT_SESS_SENDNOTE_2		OFFSET_CONTEXT(15, 1)

// The INITPROV context group is used by MDBInitProvider in mdbsup.c. Both
// IMAPISession::OpenMsgStore and IMAPISession::SetDefaultStore call this.

#define CONT_SESS_INITPROV_1		OFFSET_CONTEXT(16, 0)
#define CONT_SESS_INITPROV_2		OFFSET_CONTEXT(16, 1)
#define CONT_SESS_INITPROV_3		OFFSET_CONTEXT(16, 2)
#define CONT_SESS_INITPROV_4		OFFSET_CONTEXT(16, 3)
#define CONT_SESS_INITPROV_5		OFFSET_CONTEXT(16, 4)
#define CONT_SESS_INITPROV_6		OFFSET_CONTEXT(16, 5)
#define CONT_SESS_INITPROV_7		OFFSET_CONTEXT(16, 6)

// The following context groups are used in the default profile provider
// which is built into MAPI.

#define CONT_PRP_OPENPROFILE_1		OFFSET_CONTEXT(17, 1)
#define CONT_PRP_OPENPROFILE_2		OFFSET_CONTEXT(17, 2)
#define CONT_PRP_OPENPROFILE_3		OFFSET_CONTEXT(17, 3)
#define CONT_PRP_OPENPROFILE_4		OFFSET_CONTEXT(17, 3)
#define CONT_PRP_CREATEPROFILE_1	OFFSET_CONTEXT(17, 5)
#define CONT_PRP_CREATEPROFILE_2	OFFSET_CONTEXT(17, 6)
#define CONT_PRP_CREATEPROFILE_3	OFFSET_CONTEXT(17, 7)
#define CONT_PRP_DELETEPROFILE_1	OFFSET_CONTEXT(17, 8)
#define CONT_PRP_DELETEPROFILE_2	OFFSET_CONTEXT(17, 9)
#define CONT_PRP_DELETEPROFILE_3	OFFSET_CONTEXT(17, 10)
#define CONT_PRP_DELETEPROFILE_4	OFFSET_CONTEXT(17, 11)
#define CONT_PRP_DELETEPROFILE_5	OFFSET_CONTEXT(17, 12)
#define CONT_PRP_DELETEPROFILE_6	OFFSET_CONTEXT(17, 13)
#define CONT_PRP_CHANGEPW_1			OFFSET_CONTEXT(17, 14)
#define CONT_PRP_CHANGEPW_2			OFFSET_CONTEXT(17, 15)
#define CONT_PRP_CHANGEPW_3			OFFSET_CONTEXT(17, 16)
#define CONT_PRP_CHANGEPW_4			OFFSET_CONTEXT(17, 17)
#define CONT_PRP_CHANGEPW_5			OFFSET_CONTEXT(17, 18)
#define CONT_PRP_CHANGEPW_6			OFFSET_CONTEXT(17, 19)
#define CONT_PRP_GETTABLE_1			OFFSET_CONTEXT(17, 20)
#define CONT_PRP_GETTABLE_2			OFFSET_CONTEXT(17, 21)
#define CONT_PRP_COPYPROFILE_1		OFFSET_CONTEXT(17, 22)
#define CONT_PRP_COPYPROFILE_2		OFFSET_CONTEXT(17, 23)
#define CONT_PRP_COPYPROFILE_3		OFFSET_CONTEXT(17, 24)
#define CONT_PRP_COPYPROFILE_4		OFFSET_CONTEXT(17, 25)
#define CONT_PRP_COPYPROFILE_5		OFFSET_CONTEXT(17, 26)
#define CONT_PRP_COPYPROFILE_6		OFFSET_CONTEXT(17, 27)
#define CONT_PRP_COPYPROFILE_7		OFFSET_CONTEXT(17, 28)
#define CONT_PRP_COPYPROFILE_8		OFFSET_CONTEXT(17, 29)

#define CONT_PRP_RENAMEPROFILE_1	OFFSET_CONTEXT(18, 1)
#define CONT_PRP_RENAMEPROFILE_2	OFFSET_CONTEXT(18, 2)
#define CONT_PRP_RENAMEPROFILE_3	OFFSET_CONTEXT(18, 3)
#define CONT_PRP_RENAMEPROFILE_4	OFFSET_CONTEXT(18, 4)
#define CONT_PRP_SETDEFAULT_1		OFFSET_CONTEXT(18, 5)
#define CONT_PRP_SETDEFAULT_2		OFFSET_CONTEXT(18, 6)

#define CONT_PSESS_OPENSECTION_1	OFFSET_CONTEXT(18, 7)

#define CONT_PROF_GETPROPS_1		OFFSET_CONTEXT(19, 1)
#define CONT_PROF_GETPROPS_2		OFFSET_CONTEXT(19, 2)
#define CONT_PROF_GETPROPS_3		OFFSET_CONTEXT(19, 3)
#define CONT_PROF_GETPROPLIST_1		OFFSET_CONTEXT(19, 4)
#define CONT_PROF_GETPROPLIST_2		OFFSET_CONTEXT(19, 5)
#define CONT_PROF_GETPROPLIST_3		OFFSET_CONTEXT(19, 6)
#define CONT_PROF_GETPROPLIST_4		OFFSET_CONTEXT(19, 7)
#define CONT_PROF_OPENPROPERTY_1	OFFSET_CONTEXT(19, 8)
#define CONT_PROF_SETPROPS_1		OFFSET_CONTEXT(19, 9)
#define CONT_PROF_SETPROPS_2		OFFSET_CONTEXT(19, 10)
#define CONT_PROF_SETPROPS_3		OFFSET_CONTEXT(19, 11)
#define CONT_PROF_DELETEPROPS_1		OFFSET_CONTEXT(19, 12)
#define CONT_PROF_DELETEPROPS_2		OFFSET_CONTEXT(19, 13)
#define CONT_PROF_COPYTO_1			OFFSET_CONTEXT(19, 14)
#define CONT_PROF_COPYTO_2			OFFSET_CONTEXT(19, 15)
#define CONT_PROF_COPYPROPS_1		OFFSET_CONTEXT(19, 16)
#define CONT_PROF_COPYPROPS_2		OFFSET_CONTEXT(19, 17)
#define CONT_PROF_GETNAMEID_1		OFFSET_CONTEXT(19, 18)
#define CONT_PROF_GETIDNAME_1		OFFSET_CONTEXT(19, 19)

//	The following context groups belong to the IProfAdmin interface.

#define CONT_IPA_RENAME_1			OFFSET_CONTEXT(20, 1)


//	The following context groups belong to the IMsgServiceAdmin interface.

#define CONT_ISA_CREATE_1			OFFSET_CONTEXT(21, 1)
#define CONT_ISA_CREATE_2			OFFSET_CONTEXT(21, 2)
#define CONT_ISA_COPY_1				OFFSET_CONTEXT(21, 3)


//	The following context groups belong to base MAPI functions.

#define CONT_BASE_LOGON_1			OFFSET_CONTEXT(22, 1)
#define CONT_BASE_LOGON_2			OFFSET_CONTEXT(22, 2)
#define CONT_BASE_LOGON_3			OFFSET_CONTEXT(22, 3)
#define CONT_BASE_LOGON_4			OFFSET_CONTEXT(22, 4)
#define CONT_BASE_LOGON_5			OFFSET_CONTEXT(22, 5)
#define CONT_BASE_LOGON_6			OFFSET_CONTEXT(22, 6)
#define CONT_BASE_LOGON_7			OFFSET_CONTEXT(22, 7)
#define CONT_BASE_LOGON_8			OFFSET_CONTEXT(22, 8)
#define CONT_BASE_LOGON_9			OFFSET_CONTEXT(22, 9)
#define CONT_BASE_LOGON_10			OFFSET_CONTEXT(22, 10)

//	The following context groups belong to MAPI Support functions.

#define CONT_SUPP_EXPANDRECIPS_1	OFFSET_CONTEXT(23, 1)
#define CONT_SUPP_EXPANDRECIPS_2	OFFSET_CONTEXT(23, 2)
#define CONT_SUPP_EXPANDRECIPS_3	OFFSET_CONTEXT(23, 3)
#define CONT_SUPP_EXPANDRECIPS_4	OFFSET_CONTEXT(23, 4)
#define CONT_SUPP_EXPANDRECIPS_5	OFFSET_CONTEXT(23, 5)
#define CONT_SUPP_EXPANDRECIPS_6	OFFSET_CONTEXT(23, 6)

#define CONT_SUPP_READRECEIPT_1		OFFSET_CONTEXT(24, 1)
#define CONT_SUPP_READRECEIPT_2		OFFSET_CONTEXT(24, 2)
#define CONT_SUPP_READRECEIPT_3		OFFSET_CONTEXT(24, 3)
#define CONT_SUPP_READRECEIPT_4		OFFSET_CONTEXT(24, 4)
#define CONT_SUPP_READRECEIPT_5		OFFSET_CONTEXT(24, 5)
#define CONT_SUPP_READRECEIPT_6		OFFSET_CONTEXT(24, 6)
#define CONT_SUPP_READRECEIPT_7		OFFSET_CONTEXT(24, 7)

#define CONT_SUPP_PREPARESUBMIT_1	OFFSET_CONTEXT(25, 1)

#define CONT_SUPP_SPOOLERNOTIFY_1	OFFSET_CONTEXT(26, 1)

#define CONT_SUPP_MODIFYPROFILE_1	OFFSET_CONTEXT(27, 1)
#define CONT_SUPP_MODIFYPROFILE_2	OFFSET_CONTEXT(27, 2)
#define CONT_SUPP_MODIFYPROFILE_3	OFFSET_CONTEXT(27, 3)
#define CONT_SUPP_MODIFYPROFILE_4	OFFSET_CONTEXT(27, 4)
#define CONT_SUPP_MODIFYPROFILE_5	OFFSET_CONTEXT(27, 5)
#define CONT_SUPP_MODIFYPROFILE_6	OFFSET_CONTEXT(27, 6)

#define CONT_SUPP_STORELOGOFFTRANSPORTS_1	OFFSET_CONTEXT(28, 1)
#define CONT_SUPP_STORELOGOFFTRANSPORTS_2	OFFSET_CONTEXT(28, 2)
#define CONT_SUPP_STORELOGOFFTRANSPORTS_3	OFFSET_CONTEXT(28, 3)

#define CONT_SUPP_OPENPROFILESECTION_1	OFFSET_CONTEXT(29, 1)
#define CONT_SUPP_OPENPROFILESECTION_2	OFFSET_CONTEXT(29, 2)

#define CONT_SUPP_MODIFYSTATUSROW_1		OFFSET_CONTEXT(30, 1)

#define CONT_SUPP_NEWUID_1				OFFSET_CONTEXT(31, 1)

#define CONT_SUPP_CREATEONEOFF_1		OFFSET_CONTEXT(32, 1)

#define CONT_SUPP_SETPROVIDERUID_1		OFFSET_CONTEXT(33, 1)

#define CONT_SUPP_GETSVCCONFIGSPTOBJ_1	OFFSET_CONTEXT(34, 1)

#define CONT_SUPP_SUBSCRIBE_1			OFFSET_CONTEXT(35, 1)

#define CONT_SUPP_UNSUBSCRIBE_1			OFFSET_CONTEXT(36, 1)

#define CONT_SUPP_NOTIFY_1				OFFSET_CONTEXT(37, 1)

// PAB contexts

#define CONT_PAB_RECIP_1				OFFSET_CONTEXT(38, 1)
#define CONT_PAB_RECIP_2				OFFSET_CONTEXT(38, 2)
#define CONT_PAB_RECIP_3				OFFSET_CONTEXT(38, 3)
#define CONT_PAB_RECIP_4				OFFSET_CONTEXT(38, 4)

#define CONT_PAB_DIR_1					OFFSET_CONTEXT(38, 5)
#define CONT_PAB_DIR_2					OFFSET_CONTEXT(38, 6)
#define CONT_PAB_DIR_3					OFFSET_CONTEXT(38, 7)
#define CONT_PAB_DIR_4					OFFSET_CONTEXT(38, 10)
#define CONT_PAB_DIR_5					OFFSET_CONTEXT(38, 11)

#define CONT_PAB_DL_1					OFFSET_CONTEXT(38, 8)

#define CONT_PAB_DB_1					OFFSET_CONTEXT(38, 9)

#define CONT_PAB_TOO_BIG_FOR_WIN16		OFFSET_CONTEXT(38, 12)

#define CONT_PAB_CORRUPT_RPC_ROW_MISSING_DISPLAY_NAME	OFFSET_CONTEXT(38, 20)


// The following contexts are meant to be only error contexts.  They
// should not be converted or used as Help file contexts

// NDB.2 Error contexts (ulContext) -------------------------------------------------

#if defined ( _NDB_H_ )

#define EC_NDB_MIN											0x10000000

#define EC_NDB_AMAP_AMAPALLOC								0x10010101
#define EC_NDB_AMAP_AMAPFREE								0x10010201
#define EC_NDB_AMAP_AMAPWRITE_1								0x10010301
#define EC_NDB_AMAP_AMAPWRITE_2								0x10010302
#define EC_NDB_AMAP_PMAPALLOC								0x10010401
#define EC_NDB_AMAP_PMAPWRITE								0x10010501
#define EC_NDB_AMAP_AMAPREBUILDBEGIN						0x10010601
#define EC_NDB_AMAP_AMAPREBUILDFINISH						0x10010701

#define EC_NDB_BBTREE_BBTADDREF								0x10020101
#define EC_NDB_BBTREE_BBTRELEASEFOREACH						0x10020201
#define EC_NDB_BBTREE_BBTFREEANDREMOVE						0x10020301

#define EC_NDB_BCACHE_BCREADFILE_1							0x10030101
#define EC_NDB_BCACHE_BCREADFILE_2							0x10030102
#define EC_NDB_BCACHE_BCWRITE								0x10030201
#define EC_NDB_BCACHE_BCWRITEFILE							0x10030301
#define EC_NDB_BCACHE_BCREALLOC								0x10030401
#define EC_NDB_BCACHE_BCGROW_1								0x10030501
#define EC_NDB_BCACHE_BCGROW_2								0x10030502
#define EC_NDB_BCACHE_BCRELEASEFOREACH						0x10030601
#define EC_NDB_BCACHE_BCRELEASESETRELEASED					0x10030701
#define EC_NDB_BCACHE_BCSETRELEASED							0x10030801
#define EC_NDB_BCACHE_BCSAVEFOREACH							0x10030901
#define EC_NDB_BCACHE_BCFLUSH								0x10030C01
#define EC_NDB_BCACHE_BCVALIDATE_1							0x10030D01
#define EC_NDB_BCACHE_BCVALIDATE_2							0x10030D02
#define EC_NDB_BCACHE_BCVALIDATE_3							0x10030D03
#define EC_NDB_BCACHE_BCVALIDATE_4							0x10030D04
#define EC_NDB_BCACHE_BCVALIDATE_5							0x10030D05
#define EC_NDB_BCACHE_BCVALIDATE_6							0x10030D06
#define EC_NDB_BCACHE_BCVALIDATE_7							0x10030D07
#define EC_NDB_BCACHE_BCVALIDATE_8							0x10030D08
#define EC_NDB_BCACHE_BCVALIDATE_9							0x10030D09
#define EC_NDB_BCACHE_BCVALIDATE_10							0x10030D0A
#define EC_NDB_BCACHE_BCVALIDATE_11							0x10030D0B
#define EC_NDB_BCACHE_BCVALIDATE_12							0x10030D0C
#define EC_NDB_BCACHE_BCVALIDATE_13							0x10030D0D
#define EC_NDB_BCACHE_BCVALIDATE_14							0x10030D0E
#define EC_NDB_BCACHE_BCVALIDATE_15							0x10030D0F
#define EC_NDB_BCACHE_BCSETHOLD								0x10030E01
#define EC_NDB_BCACHE_HVGROW								0x10030F01

#define EC_NDB_BTREE_BTLOOKUP								0x10040101
#define EC_NDB_BTREE_BTREMOVE								0x10040201
#define EC_NDB_BTREE_BTLOOKUPPATH							0x10040301

#define EC_NDB_DATABASE_NDB_OPENDATABASE_1					0x10050101
#define EC_NDB_DATABASE_NDB_OPENDATABASE_2					0x10050102
#define EC_NDB_DATABASE_NDB_OPENDATABASE_3					0x10050103
#define EC_NDB_DATABASE_OPENDATABASE_1						0x10050201
#define EC_NDB_DATABASE_OPENDATABASE_2						0x10050202
#define EC_NDB_DATABASE_OPENDATABASE_3						0x10050203
#define EC_NDB_DATABASE_OPENDATABASE_4						0x10050204
#define EC_NDB_DATABASE_NDB_OPENNODE						0x10050301
#define EC_NDB_DATABASE_DELETENODETRANSACT_1				0x10050401
#define EC_NDB_DATABASE_DELETENODETRANSACT_2				0x10050402
#define EC_NDB_DATABASE_QUERYNODE							0x10050501
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_1				0x10050601
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_2				0x10050602
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_3				0x10050603
#define EC_NDB_DATABASE_SETPARENTNIDTRANSACT_1				0x10050701
#define EC_NDB_DATABASE_GETCACHESIZES						0x10050801
#define EC_NDB_DATABASE_WAITFORMUTEX_1						0x10050901
#define EC_NDB_DATABASE_WAITFORMUTEX_2						0x10050902
#define EC_NDB_DATABASE_WAITFORMUTEX_3						0x10050903
#define EC_NDB_DATABASE_WAITFORMUTEX_4						0x10050904
#define EC_NDB_DATABASE_WAITFORMUTEX_5						0x10050805
#define EC_NDB_DATABASE_WAITFORMUTEX_6						0x10050806
#define EC_NDB_DATABASE_WAITFORMUTEX_7						0x10050807

#define EC_NDB_FILE_32_FILEOPEN								0x10060101
#define EC_NDB_FILE_32_FILEREAD_1							0x10060201
#define EC_NDB_FILE_32_FILEREAD_2							0x10060202
#define EC_NDB_FILE_32_FILEREAD_3							0x10060203
#define EC_NDB_FILE_32_FILEWRITE_1							0x10060301
#define EC_NDB_FILE_32_FILEWRITE_2							0x10060302
#define EC_NDB_FILE_32_FILEWRITE_3							0x10060303
#define EC_NDB_FILE_32_FILEGETEOF							0x10060401
#define EC_NDB_FILE_32_FILESETEOF_1							0x10060501
#define EC_NDB_FILE_32_FILESETEOF_2							0x10060502
#define EC_NDB_FILE_32_FILEFLUSH							0x10060601
#define EC_NDB_FILE_32_FILEDELETE							0x10060701
#define EC_NDB_FILE_32_FILELOCK								0x10060801
#define EC_NDB_FILE_16_FILEOPEN_1							0x10061101
#define EC_NDB_FILE_16_FILEOPEN_2							0x10061102
#define EC_NDB_FILE_16_FILEREAD_1							0x10061201
#define EC_NDB_FILE_16_FILEREAD_2							0x10061202
#define EC_NDB_FILE_16_FILEREAD_3							0x10061203
#define EC_NDB_FILE_16_FILEWRITE_1							0x10061301
#define EC_NDB_FILE_16_FILEWRITE_2							0x10061302
#define EC_NDB_FILE_16_FILEWRITE_3							0x10061303
#define EC_NDB_FILE_16_FILEGETEOF							0x10061401
#define EC_NDB_FILE_16_FILESETEOF_1							0x10061501
#define EC_NDB_FILE_16_FILESETEOF_2							0x10061502
#define EC_NDB_FILE_16_FILESETEOF_3							0x10061503
#define EC_NDB_FILE_16_FILESETEOF_4							0x10061504
#define EC_NDB_FILE_16_FILESETEOF_5							0x10061505
#define EC_NDB_FILE_16_FILESETEOF_6							0x10061506
#define EC_NDB_FILE_16_FILEFLUSH							0x10061601
#define EC_NDB_FILE_16_FILEDELETE							0x10061701
#define EC_NDB_FILE_16_FILELOCK								0x10061801

#define EC_NDB_IDLETASK_INITIDLETASK_1						0x10070101
#define EC_NDB_IDLETASK_INITIDLETASK_2						0x10070102

#define EC_NDB_LNTABLE_LNLOOKUP								0x10080101
#define EC_NDB_LNTABLE_LNGROW_1								0x10080201
#define EC_NDB_LNTABLE_LNGROW_2								0x10080202
#define EC_NDB_LNTABLE_LNREMOVE								0x10080301

#define EC_NDB_NBTREE_NBTLOOKUP								0x10090101
#define EC_NDB_NBTREE_NBTREMOVE								0x10090201

#define EC_NDB_NODE_CANSAVECHANGES_1						0x100A0101
#define EC_NDB_NODE_CANSAVECHANGES_2						0x100A0102
#define EC_NDB_NODE_CANSAVECHANGES_3						0x100A0103

#define EC_NDB_PCACHE_VALIDATE_1							0x100B0101
#define EC_NDB_PCACHE_VALIDATE_2							0x100B0102
#define EC_NDB_PCACHE_VALIDATE_3							0x100B0103
#define EC_NDB_PCACHE_VALIDATE_4							0x100B0104
#define EC_NDB_PCACHE_VALIDATE_5							0x100B0105
#define EC_NDB_PCACHE_VALIDATE_6							0x100B0106
#define EC_NDB_PCACHE_VALIDATE_7							0x100B0107
#define EC_NDB_PCACHE_LOOKUP_1								0x100B0201
#define EC_NDB_PCACHE_LOOKUP_2								0x100B0202
#define EC_NDB_PCACHE_LOOKUP_3								0x100B0203
#define EC_NDB_PCACHE_LOOKUP_4								0x100B0204
#define EC_NDB_PCACHE_READ									0x100B0301
#define EC_NDB_PCACHE_PCACQUIREPAGE							0x100B0401
#define EC_NDB_PCACHE_PCPURGEPAGE							0x100B0501
#define EC_NDB_PCACHE_PCGETPAGE								0x100B0601

#define EC_NDB_SBLOCK_SBLOOKUP								0x100C0101
#define EC_NDB_SBLOCK_SBINSERT								0x100C0201
#define EC_NDB_SBLOCK_SBUPDATE								0x100C0301
#define EC_NDB_SBLOCK_SBREMOVE_1							0x100C0401
#define EC_NDB_SBLOCK_SBREMOVE_2							0x100C0402
#define EC_NDB_SBLOCK_SBINSERTPATH							0x100C0501
#define EC_NDB_SBLOCK_SBFOREACH_1							0x100C0601
#define EC_NDB_SBLOCK_SBFOREACH_2							0x100C0602

#define EC_NDB_SHARED_INITSHAREDDATABASE_1					0x100D0101
#define EC_NDB_SHARED_INITSHAREDDATABASE_2					0x100D0102
#define EC_NDB_SHARED_INITSHAREDDATABASE_3					0x100D0103
#define EC_NDB_SHARED_INITSHAREDDATABASE_4					0x100D0104
#define EC_NDB_SHARED_INITSHAREDDATABASE_5					0x100D0105
#define EC_NDB_SHARED_INITSHAREDDATABASE_6					0x100D0106
#define EC_NDB_SHARED_INITSHAREDDATABASE_7					0x100D0107
#define EC_NDB_SHARED_OPENSHAREDDATABASE_1					0x100D0201
#define EC_NDB_SHARED_OPENSHAREDDATABASE_2					0x100D0202
#define EC_NDB_SHARED_OPENSHAREDDATABASE_3					0x100D0203
#define EC_NDB_SHARED_GRABFIRSTLOCK							0x100D0301
#define EC_NDB_SHARED_GRABFILELOCK							0x100D0401
#define EC_NDB_SHARED_GROWSHAREDDATABASE					0x100D0501
#define EC_NDB_SHARED_RECONNECTDATABASE_1					0x100D0601
#define EC_NDB_SHARED_RECONNECTDATABASE_2					0x100D0602
#define EC_NDB_SHARED_RECONNECTDATABASE_3					0x100D0603
#define EC_NDB_SHARED_RECONNECTDATABASE_4					0x100D0604

#define EC_NDB_UPDATE_READHEADER_1							0x100E0101
#define EC_NDB_UPDATE_READHEADER_2							0x100E0102
#define EC_NDB_UPDATE_READHEADER_3							0x100E0103
#define EC_NDB_UPDATE_COMMITHEADER_1						0x100E0201
#define EC_NDB_UPDATE_COMMITHEADER_2						0x100E0202

#define EC_NDB_XBLOCK_XBACCESS_1							0x100F0101
#define EC_NDB_XBLOCK_XBACCESS_2							0x100F0102
#define EC_NDB_XBLOCK_XBACCESS_3							0x100F0103
#define EC_NDB_XBLOCK_XBACCESS_4							0x100F0104
#define EC_NDB_XBLOCK_XBACCESS_5							0x100F0105
#define EC_NDB_XBLOCK_XBACCESS_6							0x100F0106
#define EC_NDB_XBLOCK_XBACCESS_7							0x100F0107
#define EC_NDB_XBLOCK_XBACCESS_8							0x100F0108
#define EC_NDB_XBLOCK_XBACCESS_9							0x100F0109
#define EC_NDB_XBLOCK_XBACCESS_10							0x100F010A
#define EC_NDB_XBLOCK_XBACCESS_11							0x100F010B
#define EC_NDB_XBLOCK_XBFOREACH_1							0x100F0201
#define EC_NDB_XBLOCK_XBFOREACH_2							0x100F0202
#define EC_NDB_XBLOCK_XBFOREACH_3							0x100F0203
#define EC_NDB_XBLOCK_XBFOREACH_4							0x100F0204
#define EC_NDB_XBLOCK_XBFOREACH_5							0x100F0205

#endif	// _NDB_H_

// LTP Error contexts (ulContext) -------------------------------------------------

#if defined ( _LTP_H_ )

#define EC_LTP_MIN											0x20000000

#define EC_LTP_BTH_A_SETROOTHID								0x20010101
#define EC_LTP_BTH_A_GETINDEXENTRY							0x20010201
#define EC_LTP_BTH_A_SETINDEXENTRY							0x20010301
#define EC_LTP_BTH_A_REMOVEROOT								0x20010401
#define EC_LTP_BTH_A_LOOKUPROOT								0x20010501
#define EC_LTP_BTH_A_LOOKUPLEAF								0x20010601
#define EC_LTP_BTH_BTHADVANCEPATH							0x20010701
#define EC_LTP_BTH_A_REKEY									0x20010801
#define EC_LTP_BTH_A_FOREACHROOT							0x20010901
#define EC_LTP_BTH_A_FOREACHLEAF							0x20010A01
#define EC_LTP_BTH_OPEN_1									0x20010B01
#define EC_LTP_BTH_OPEN_2									0x20010B02
#define EC_LTP_BTH_OPEN_3									0x20010B03
#define EC_LTP_BTH_LOOKUP									0x20010C01
#define EC_LTP_BTH_INSERT_1									0x20010D01
#define EC_LTP_BTH_INSERT_2									0x20010D02
#define EC_LTP_BTH_UPDATE									0x20010E01
#define EC_LTP_BTH_REMOVE									0x20010F01
#define EC_LTP_BTH_A_REMOVELEAF								0x20011001

#define EC_LTP_ES_SAVECHANGES								0x20020101
#define EC_LTP_ES_SETSIZE									0x20020201
#define EC_LTP_ES_READ										0x20020301
#define EC_LTP_ES_WRITE										0x20020401
#define EC_LTP_ES_MOVEDATA_1								0x20020501
#define EC_LTP_ES_MOVEDATA_2								0x20020502
#define EC_LTP_ES_COPYTO									0x20020601
#define EC_LTP_ES_ACCESS_1									0x20020701
#define EC_LTP_ES_ACCESS_2									0x20020702
#define EC_LTP_ES_RELOAD									0x20020801

#define EC_LTP_HEAP_ALLOCATE								0x20030101
#define EC_LTP_HEAP_A_ALLOCATE								0x20030201
#define EC_LTP_HEAP_REALLOCATE_1							0x20030301
#define EC_LTP_HEAP_REALLOCATE_2							0x20030302
#define EC_LTP_HEAP_A_REALLOCATE_1							0x20030401
#define EC_LTP_HEAP_A_REALLOCATE_2							0x20030402
#define EC_LTP_HEAP_FREE									0x20030501
#define EC_LTP_HEAP_A_FREE_1								0x20030601
#define EC_LTP_HEAP_A_FREE_2								0x20030602
#define EC_LTP_HEAP_ACCESS									0x20030701
#define EC_LTP_HEAP_A_ACCESS_1								0x20030801
#define EC_LTP_HEAP_A_ACCESS_2								0x20030802
#define EC_LTP_HEAP_OPEN_1									0x20030901
#define EC_LTP_HEAP_OPEN_2									0x20030902
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_1				0x20030A01
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_2				0x20030A02
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_3				0x20030A03
#define EC_LTP_HEAP_SCRESIZEALLOCATION_1					0x20030B01
#define EC_LTP_HEAP_SCRESIZEALLOCATION_2					0x20030B02
#define EC_LTP_HEAP_SCRESIZEALLOCATION_3					0x20030B03
#define EC_LTP_HEAP_SCACCESSPAGE							0x20030C01
#define EC_LTP_HEAP_SCSHRINKPAGEIFLAST						0x20030D01
#define EC_LTP_HEAP_A_RELOADLASTPAGECACHE					0x20030E01
#define EC_LTP_HEAP_SCMAKEACCESSCALLBACK					0x20030F01
#define EC_LTP_HEAP_ACCESSPAGE								0x20031001
#define EC_LTP_HEAP_ACCESSALLOCATION_1						0x20031101
#define EC_LTP_HEAP_ACCESSALLOCATION_2						0x20031102

#define EC_LTP_NAMEID_INTERNGUID_1							0x20040101
#define EC_LTP_NAMEID_INTERNGUID_2							0x20040102
#define EC_LTP_NAMEID_READFIXED								0x20040201
#define EC_LTP_NAMEID_APPENDENTRY_1							0x20040301
#define EC_LTP_NAMEID_APPENDENTRY_2							0x20040302
#define EC_LTP_NAMEID_COMPARESTRING_1						0x20040401
#define EC_LTP_NAMEID_COMPARESTRING_2						0x20040402
#define EC_LTP_NAMEID_COMPARESTRING_3						0x20040403
#define EC_LTP_NAMEID_READSTRING_1							0x20040501
#define EC_LTP_NAMEID_READSTRING_2							0x20040502
#define EC_LTP_NAMEID_INTERNNAME_1							0x20040601
#define EC_LTP_NAMEID_INTERNNAME_2							0x20040602
#define EC_LTP_NAMEID_INTERNNAME_3							0x20040603
#define EC_LTP_NAMEID_OPENCONTEXT							0x20040701
#define EC_LTP_NAMEID_GETNAMESFROMGUID						0x20040801
#define EC_LTP_NAMEID_GETIDSFROMNAMES						0x20040901

#define EC_LTP_PC_SCWRITEPROPENTRY							0x20050101
#define EC_LTP_PC_SCSAVECHANGESESPC							0x20050201
#define EC_LTP_PC_GETPROPINFO								0x20050301
#define EC_LTP_PC_OPENSTREAM_1								0x20050401
#define EC_LTP_PC_OPENSTREAM_2								0x20050402
#define EC_LTP_PC_OPENSTREAM_3								0x20050403
#define EC_LTP_PC_OPENSTREAM_4								0x20050404
#define EC_LTP_PC_OPENSTREAM_5								0x20050405

#define EC_LTP_PROP_A_ENCODEOBJECT							0x20060101
#define EC_LTP_PROP_SCCOPYOBJECT							0x20060201
#define EC_LTP_PROP_SCDECODESTRING							0x20060301
#define EC_LTP_PROP_SCDECODEMVCONSTANT						0x20060401
#define EC_LTP_PROP_SCDECODEMVGUID							0x20060501
#define EC_LTP_PROP_SCDECODEMVCONSTANTINST					0x20060601
#define EC_LTP_PROP_SCDECODEMVSTRINGINST_1					0x20060701
#define EC_LTP_PROP_SCDECODEMVSTRINGINST_2					0x20060702
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_1					0x20060801
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_2					0x20060802
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_3					0x20060803

#define EC_LTP_TC_SCREADPTCI_1								0x20070101
#define EC_LTP_TC_SCREADPTCI_2								0x20070102
#define EC_LTP_TC_SCINSERTCOLUMN_1							0x20070201
#define EC_LTP_TC_SCINSERTCOLUMN_2							0x20070202
#define EC_LTP_TC_OPEN										0x20070301
#define EC_LTP_TC_ADDROW									0x20070401
#define EC_LTP_TC_DELROWS									0x20070501
#define EC_LTP_TC_GETROWINFO								0x20070601
#define EC_LTP_TC_GETCELLINFO_1								0x20070701
#define EC_LTP_TC_GETCELLINFO_2								0x20070702
#define EC_LTP_TC_GETCELLINFO_3								0x20070703
#define EC_LTP_TC_GETROWPROPS								0x20070801
#define EC_LTP_TC_GETONEROWPROP_1							0x20070901
#define EC_LTP_TC_GETONEROWPROP_2							0x20070902
#define EC_LTP_TC_GETONEROWPROP_3							0x20070903
#define EC_LTP_TC_GETCOLUMNPROPS_1							0x20070A01
#define EC_LTP_TC_GETCOLUMNPROPS_2							0x20070A02
#define EC_LTP_TC_SETROWPROPS								0x20070B01
#define EC_LTP_TC_SETROWPROPSFROMPC							0x20070C01
#define EC_LTP_TC_DELROWPROPS								0x20070D01
#define EC_LTP_TC_SETROW_1									0x20070E01
#define EC_LTP_TC_COPYROW_1									0x20070F01

#define EC_LTP_TCV_RESTRICTROW								0x20080101
#define EC_LTP_TCV_SCRESTRICT								0x20080201
#define EC_LTP_TCV_RESTRICTGETVALREF2						0x20080301
#define EC_LTP_TCV_SCRESTRICTCONTENTSTREAM_1				0x20080401
#define EC_LTP_TCV_SCRESTRICTCONTENTSTREAM_2				0x20080402
#define EC_LTP_TCV_SCRESTRICTPROPERTYSTREAM					0x20080501
#define EC_LTP_TCV_SCRESTRICTCOMPARESTREAM_1				0x20080601
#define EC_LTP_TCV_SCRESTRICTCOMPARESTREAM_2				0x20080602
#define EC_LTP_TCV_RESTRICT									0x20080701
#define EC_LTP_TCV_SCPREPAREADDCOLUMN						0x20080801

#define EC_LTP_GMP_INDEXFROMGUID_1							0x20090101
#define EC_LTP_GMP_INDEXFROMGUID_2							0x20090102
#define EC_LTP_GMP_INDEXFROMGUID_3							0x20090103
#define EC_LTP_GMP_GUIDFROMINDEX_1							0x20090201
#define EC_LTP_GMP_GUIDFROMINDEX_2							0x20090202

#define EC_LTP_SMP_LOOKUP									0x200A0101
#define EC_LTP_SMP_UPDATE									0x200A0201
#define EC_LTP_SMP_REMOVE									0x200A0301

#endif	// _LTP_H_

// PST Error contexts (ulContext) -------------------------------------------------

#if defined ( _PST_H_ )

#define EC_PST_MIN											0x30000000

#define EC_PST_ATCH_SAVECHANGES_1							0x30010101
#define EC_PST_ATCH_SAVECHANGES_2							0x30010102
#define EC_PST_ATCH_SAVECHANGES_3							0x30010103

#define EC_PST_FLD_SCCREATEFOLDER							0x30020101
#define EC_PST_FLD_SCOPENFOLDERTABLE_1						0x30020201
#define EC_PST_FLD_SCOPENFOLDERTABLE_2						0x30020202
#define EC_PST_FLD_CREATEFOLDER_1							0x30020301
#define EC_PST_FLD_CREATEFOLDER_2							0x30020302
#define EC_PST_FLD_CREATEMESSAGE_1							0x30020401
#define EC_PST_FLD_CREATEMESSAGE_2							0x30020402
#define EC_PST_FLD_CREATEMESSAGE_3							0x30020403
#define EC_PST_FLD_COPYFOLDER_1								0x30020501
#define EC_PST_FLD_COPYFOLDER_2								0x30020502
#define EC_PST_FLD_COPYFOLDER_3								0x30020503
#define EC_PST_FLD_COPYFOLDER_4								0x30020504
#define EC_PST_FLD_COPYFOLDER_5								0x30020505
#define EC_PST_FLD_COPYFOLDER_6								0x30020506
#define EC_PST_FLD_COPYMESSAGES_1							0x30020601
#define EC_PST_FLD_COPYMESSAGES_2							0x30020602
#define EC_PST_FLD_COPYMESSAGES_3							0x30020603
#define EC_PST_FLD_COPYMESSAGES_4							0x30020604
#define EC_PST_FLD_DELETEMESSAGES_1							0x30020701
#define EC_PST_FLD_DELETEMESSAGES_2							0x30020702
#define EC_PST_FLD_DELETEMESSAGES_3							0x30020703
#define EC_PST_FLD_DELETEFOLDER_1							0x30020801
#define EC_PST_FLD_DELETEFOLDER_2							0x30020802
#define EC_PST_FLD_DELETEFOLDER_3							0x30020803
#define EC_PST_FLD_DELETEFOLDER_4							0x30020804
#define EC_PST_FLD_EMPTYFOLDER_1							0x30020901
#define EC_PST_FLD_EMPTYFOLDER_2							0x30020902
#define EC_PST_FLD_EMPTYFOLDER_3							0x30020903
#define EC_PST_FLD_SETREADFLAGS_1							0x30020A01
#define EC_PST_FLD_SETREADFLAGS_2							0x30020A02
#define EC_PST_FLD_SETMESSAGESTATUS_1						0x30020B01
#define EC_PST_FLD_SETMESSAGESTATUS_2						0x30020B02
#define EC_PST_FLD_SETMESSAGESTATUS_3						0x30020B03
#define EC_PST_FLD_SETSEARCHCRITERIA_1						0x30020C01
#define EC_PST_FLD_SETSEARCHCRITERIA_2						0x30020C02
#define EC_PST_FLD_GETSEARCHCRITERIA						0x30020D01
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_1					0x30020E01
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_2					0x30020E02
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_3					0x30020E03
#define EC_PST_FLD_SCOPENFOLDERPCTC							0x30020F01

#define EC_PST_FLDCOPY_SCCHECKFOLDERANCESTRY				0x30030101
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_1				0x30030201
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_2				0x30030202
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_3				0x30030203
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_4				0x30030204
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_5				0x30030205
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_6				0x30030206
#define EC_PST_FLDCOPY_SCMOVECOPYFOLDERPROPS_1				0x30030301
#define EC_PST_FLDCOPY_SCMOVECOPYFOLDERPROPS_2				0x30030302
#define EC_PST_FLDCOPY_SCMOVECOPYONEFOLDER_1				0x30030401
#define EC_PST_FLDCOPY_SCMOVECOPYONEFOLDER_2				0x30030402
#define EC_PST_FLDCOPY_SCDELETESUBFOLDERS					0x30030501
#define EC_PST_FLDCOPY_SCEMPTYFOLDER_1						0x30030601
#define EC_PST_FLDCOPY_SCEMPTYFOLDER_2						0x30030602
#define EC_PST_FLDCOPY_SCDELETEONEMESSAGE_1					0x30030701
#define EC_PST_FLDCOPY_SCDELETEONEMESSAGE_2					0x30030702
#define EC_PST_FLDCOPY_SCMOVECOPYALLFOLDERS_1				0x30030801
#define EC_PST_FLDCOPY_SCMOVECOPYALLFOLDERS_2				0x30030802
#define EC_PST_FLDCOPY_MOVECOPYONEMESSAGE_1					0x30030901
#define EC_PST_FLDCOPY_MOVECOPYONEMESSAGE_2					0x30030902
#define EC_PST_FLDCOPY_SCCHANGEREADFLAG						0x30030A01
#define EC_PST_FLDCOPY_SCDELETEFOLDEROBJECTS_1				0x30030B01
#define EC_PST_FLDCOPY_SCDELETEFOLDEROBJECTS_2				0x30030B02
#define EC_PST_FLDCOPY_SCPROCESSSOME_1						0x30030C01

#define EC_PST_MS_SCINITMS_1								0x30040101
#define EC_PST_MS_SCINITMS_2								0x30040102
#define EC_PST_MS_OPENENTRY_1								0x30040201
#define EC_PST_MS_OPENENTRY_2								0x30040202
#define EC_PST_MS_OPENENTRY_3								0x30040203
#define EC_PST_MS_OPENENTRY_4								0x30040204
#define EC_PST_MS_OPENENTRY_5								0x30040205
#define EC_PST_MS_OPENENTRY_6								0x30040206
#define EC_PST_MS_OPENENTRY_7								0x30040207
#define EC_PST_MS_COMPAREENTRYIDS							0x30040301
#define EC_PST_MS_ADVISE									0x30040401
#define EC_PST_MS_SETRECEIVEFOLDER_1						0x30040501
#define EC_PST_MS_SETRECEIVEFOLDER_2						0x30040502
#define EC_PST_MS_SETRECEIVEFOLDER_3						0x30040503
#define EC_PST_MS_SETRECEIVEFOLDER_4						0x30040504
#define EC_PST_MS_GETOUTGOINGQUEUE							0x30040601
#define EC_PST_MS_SETLOCKSTATE_1							0x30040701
#define EC_PST_MS_SETLOCKSTATE_2							0x30040702
#define EC_PST_MS_SETLOCKSTATE_3							0x30040703
#define EC_PST_MS_SETLOCKSTATE_4							0x30040704
#define EC_PST_MS_FINISHEDMSG_1								0x30040801
#define EC_PST_MS_FINISHEDMSG_2								0x30040802
#define EC_PST_MS_FINISHEDMSG_3								0x30040803
#define EC_PST_MS_ABORTSUBMIT_1								0x30040901
#define EC_PST_MS_ABORTSUBMIT_2								0x30040902
#define EC_PST_MS_ABORTSUBMIT_3								0x30040903
#define EC_PST_MS_NOTIFYNEWMAIL								0x30040A01

#define EC_PST_MSG_SCSAVETOPLEVELMSG_1						0x30050101
#define EC_PST_MSG_SCSAVETOPLEVELMSG_2						0x30050102
#define EC_PST_MSG_SCSAVETOPLEVELMSG_3						0x30050103
#define EC_PST_MSG_SCSAVETOPLEVELMSG_4						0x30050104
#define EC_PST_MSG_SCSAVETOPLEVELMSG_5						0x30050105
#define EC_PST_MSG_SAVECHANGES_1							0x30050201
#define EC_PST_MSG_SAVECHANGES_2							0x30050202
#define EC_PST_MSG_SAVECHANGES_3							0x30050203
#define EC_PST_MSG_OPENATTACH								0x30050301
#define EC_PST_MSG_CREATEATTACH_1							0x30050401
#define EC_PST_MSG_CREATEATTACH_2							0x30050402
#define EC_PST_MSG_DELETEATTACH								0x30050501
#define EC_PST_MSG_SCSUBMITMESSAGE_1						0x30050601
#define EC_PST_MSG_SCSUBMITMESSAGE_2						0x30050602
#define EC_PST_MSG_SCSUBMITMESSAGE_3						0x30050603
#define EC_PST_MSG_SCSUBMITMESSAGE_4						0x30050604
#define EC_PST_MSG_SUBMITMESSAGE_1							0x30050701
#define EC_PST_MSG_SUBMITMESSAGE_2							0x30050702
#define EC_PST_MSG_SUBMITMESSAGE_3							0x30050703
#define EC_PST_MSG_SETREADFLAG_1							0x30050801
#define EC_PST_MSG_SETREADFLAG_2							0x30050802
#define EC_PST_MSG_SCINITMSGOBJ								0x30050901
#define EC_PST_MSG_MODIFYRECIPIENTS							0x30050A01
#define EC_PST_MSG_SCSAVEMESSAGE_1							0x30050B01
#define EC_PST_MSG_SCSAVEMESSAGE_2							0x30050B02
#define EC_PST_MSG_SCSAVEMESSAGE_3							0x30050B03
#define EC_PST_MSG_SCSAVEMESSAGE_4							0x30050B04
#define EC_PST_MSG_SCSAVEMESSAGE_5							0x30050B05
#define EC_PST_MSG_SCSAVEMESSAGE_6							0x30050B06
#define EC_PST_MSG_SCSAVEMESSAGE_7							0x30050B07
#define EC_PST_MSG_SCSAVEMESSAGE_8							0x30050B08
#define EC_PST_MSG_SCCALLRTFSYNC							0x30050C01

#define EC_PST_MSL_LOGON_1									0x30060101
#define EC_PST_MSL_LOGON_2									0x30060102
#define EC_PST_MSL_SPOOLERLOGON_1							0x30060201
#define EC_PST_MSL_SPOOLERLOGON_2							0x30060202
#define EC_PST_MSL_SCLOGONHELPER							0x30060301
#define EC_PST_MSL_SCOPENSTORE_1							0x30060401
#define EC_PST_MSL_SCOPENSTORE_2							0x30060402
#define EC_PST_MSL_SCOPENSTORE_3							0x30060403
#define EC_PST_MSL_SCOPENSTORE_4							0x30060404
#define EC_PST_MSL_SCOPENSTORE_5							0x30060405
#define EC_PST_MSL_SCBROWSEFORFILE_1						0x30060501
#define EC_PST_MSL_SCCREATEORCONFIGURE_1					0x30060601
#define EC_PST_MSL_SCCREATEORCONFIGURE_2					0x30060602
#define EC_PST_MSL_SCSERVICECONFIGURE_1						0x30060701

#define EC_PST_PROPOBJ_GETPROPS_1							0x30070101
#define EC_PST_PROPOBJ_GETPROPS_2							0x30070102
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_1					0x30070201
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_2					0x30070202
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_3					0x30070203
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_4					0x30070204
#define EC_PST_PROPOBJ_SETPROPS								0x30070301
#define EC_PST_PROPOBJ_DELETEPROPSINTERNAL_1				0x30070401
#define EC_PST_PROPOBJ_DELETEPROPSINTERNAL_2				0x30070402
#define EC_PST_PROPOBJ_DELETEPROPS							0x30070501
#define EC_PST_PROPOBJ_COPYPROPS_1							0x30070601
#define EC_PST_PROPOBJ_COPYPROPS_2							0x30070602
#define EC_PST_PROPOBJ_COPYPROPS_3							0x30070603
#define EC_PST_PROPOBJ_GETIDSFROMNAMES_1					0x30070701
#define EC_PST_PROPOBJ_GETIDSFROMNAMES_2					0x30070702
#define EC_PST_PROPOBJ_OPENPROPERTY_1						0x30070801
#define EC_PST_PROPOBJ_OPENPROPERTY_2						0x30070802
#define EC_PST_PROPOBJ_OPENPROPERTY_3						0x30070803
#define EC_PST_PROPOBJ_OPENPROPERTY_4						0x30070804
#define EC_PST_PROPOBJ_OPENPROPERTY_5						0x30070805
#define EC_PST_PROPOBJ_OPENPROPERTY_6						0x30070806
#define EC_PST_PROPOBJ_OPENPROPERTY_7						0x30070807
#define EC_PST_PROPOBJ_SCDELSPECIALPROP						0x30070901
#define EC_PST_PROPOBJ_GETNAMESFROMIDS						0x30070A01

#define EC_PST_PSTDLG_SCGETPSTFILENAME_1					0x30080101
#define EC_PST_PSTDLG_SCGETPSTFILENAME_2					0x30080102
#define EC_PST_PSTDLG_SCGETPSTFILENAME_3					0x30080103
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_1				0x30080201
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_2				0x30080202
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_3				0x30080203
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_4				0x30080204
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_5				0x30080205
#define EC_PST_PSTDLG_FCHANGEPASSWORDDLG					0x30080301
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_1					0x30080401
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_2					0x30080402
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_3					0x30080403
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_4					0x30080404
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_5					0x30080405
#define EC_PST_PSTDLG_SCGETPASSWORD_1						0x30080501
#define EC_PST_PSTDLG_SCGETPASSWORD_2						0x30080502
#define EC_PST_PSTDLG_SCGETPASSWORD_3						0x30080503
#define EC_PST_PSTDLG_SCGETPASSWORD_4						0x30080504
#define EC_PST_PSTDLG_SCGETPASSWORD_5						0x30080505
#define EC_PST_PSTDLG_SCGETPASSWORD_6						0x30080506
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_1					0x30080601
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_2					0x30080602
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_3					0x30080603
#define EC_PST_PSTDLG_SCGETCREATEINFORMATIONEX				0x30081101
#define EC_PST_PSTDLG_SCGETPASSWORDEX						0x30081201
#define EC_PST_PSTDLG_SCGETOSTFILENAME_1					0x30081301

#define EC_PST_PSTUTIL_SCGETPARENTNIDIMMEDIATE				0x30090101
#define EC_PST_PSTUTIL_SCGETPARENTNID						0x30090201
#define EC_PST_PSTUTIL_SCSETPARENTNID						0x30090301
#define EC_PST_PSTUTIL_SCEXPECTONEPROP						0x30090401
#define EC_PST_PSTUTIL_MS_UPDATECOUNTERPROPS				0x30090501
#define EC_PST_PSTUTIL_CHANGEPSTPASSWORD					0x30090601
#define EC_PST_PSTUTIL_SCDECODEENTRYID_1					0x30090701
#define EC_PST_PSTUTIL_SCDECODEENTRYID_2					0x30090702

#define EC_PST_QUEUE_SCOPENQUEUENODE						0x300A0101
#define EC_PST_QUEUE_SUDQ_SCPEEK							0x300A0201

#define EC_PST_RFS_SCOPENRFS								0x300B0101
#define EC_PST_RFS_SCFINDROWOFMSGCLASS						0x300B0201

#define EC_PST_SCO_SCSETSEARCHCRITERIA_1					0x300C0101
#define EC_PST_SCO_SCSETSEARCHCRITERIA_2					0x300C0102
#define EC_PST_SCO_SCADDTODOMAIN							0x300C0201
#define EC_PST_SCO_SCDELETEFROMDOMAIN						0x300C0301
#define EC_PST_SCO_SCENUMDOMAIN_1							0x300C0401
#define EC_PST_SCO_SCENUMDOMAIN_2							0x300C0402
#define EC_PST_SCO_SCGETFLAGS								0x300C0501
#define EC_PST_SCO_SCGETREST_1								0x300C0601
#define EC_PST_SCO_SCGETREST_2								0x300C0602
#define EC_PST_SCO_SCGETREST_3								0x300C0603
#define EC_PST_SCO_SCGETDOMAIN_1							0x300C0701
#define EC_PST_SCO_SCGETDOMAIN_2							0x300C0702
#define EC_PST_SCO_SCGETDOMAIN_3							0x300C0703
#define EC_PST_SCO_SCRECALCDOMAIN							0x300C0801
#define EC_PST_SCO_SCWRITESUBFOLDERS						0x300C0901

#define EC_PST_SETTINGS_SCOPENSETTINGSPROP					0x300D0101
#define EC_PST_SETTINGS_DELETEPROPS							0x300D0201
#define EC_PST_SETTINGS_OPENPROPERTY_1						0x300D0301
#define EC_PST_SETTINGS_OPENPROPERTY_2						0x300D0302

#define EC_PST_SMO_SCOPENSMO_1								0x300E0101
#define EC_PST_SMO_SCOPENSMO_2								0x300E0102
#define EC_PST_SMO_SCOPENSAL								0x300E0201
#define EC_PST_SMO_SAL_SCDELETESTD							0x300E0301
#define EC_PST_SMO_SDO_SCREMOVE								0x300E0401
#define EC_PST_SMO_SDO_SCOPENNODE							0x300E0501

#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_1				0x300F0101
#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_2				0x300F0102
#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_3				0x300F0103
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_1				0x300F0201
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_2				0x300F0202
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_3				0x300F0203

#define EC_PST_STAT_SCOPENSTATUSENTRY						0x30100101
#define EC_PST_STAT_SCCHANGEPW								0x30100201

#define EC_PST_TBL_FINDROW_1								0x30110101
#define EC_PST_TBL_FINDROW_2								0x30110102
#define EC_PST_TBL_SEEKROW									0x30110201
#define EC_PST_TBL_SETCOLLAPSESTATE							0x30110301
#define EC_PST_TBL_SCFINDROWBYIKEY							0x30110401
#define EC_PST_TBL_EXPANDROW								0x30110501
#define EC_PST_TBL_COLLAPSEROW								0x30110601
#define EC_PST_TBL_FREEBOOKMARK_1							0x30110701
#define EC_PST_TBL_FREEBOOKMARK_2							0x30110702

#define EC_PST_TBLTSO_TRO_RESTRICT							0x30120101
#define EC_PST_TBLTSO_GETIUROWINDEXFROMPIKEY_1				0x30120201
#define EC_PST_TBLTSO_GETIUROWINDEXFROMPIKEY_2				0x30120202
#define EC_PST_TBLTSO_EXPANDTOIUROWINDEX_1					0x30120301
#define EC_PST_TBLTSO_EXPANDTOIUROWINDEX_2					0x30120302
#define EC_PST_TBLTSO_SCCOMPAREROW							0x30120401
#define EC_PST_TBLTSO_SCPREPARENEWTSO_1						0x30120501
#define EC_PST_TBLTSO_SCPREPARENEWTSO_2						0x30120502
#define EC_PST_TBLTSO_SCPREPARENEWTSO_3						0x30120503
#define EC_PST_TBLTSO_CATEGORIZE							0x30120601
#define EC_PST_TBLTSO_SCREBUILDCACHE						0x30120701

#define EC_PST_TRANSACT_SCOPENSUBLTP						0x30130101
#define EC_PST_TRANSACT_MS_BEGINUPDATE_1					0x30130201
#define EC_PST_TRANSACT_MS_BEGINUPDATE_2					0x30130202
#define EC_PST_TRANSACT_MS_BEGINUPDATE_3					0x30130203
#define EC_PST_TRANSACT_MS_BEGINUPDATE_4					0x30130204

#define EC_PST_OST_SCLRFLDCANCREATE							0x30140101
#define EC_PST_OST_SCLRFLDCANMOVECOPY						0x30140201
#define EC_PST_OST_SCLRFLDCANDELETE							0x30140301
#define EC_PST_OST_SCLRFLDFINDROW_1							0x30140401
#define EC_PST_OST_SCLRFLDFINDROW_2							0x30140402
#define EC_PST_OST_SCLRFLDCANMODIFY							0x30140501
#define EC_PST_OST_SCLRBEGUPHIERARCHY						0x30140601
#define EC_PST_OST_SCLRBEGUPFOLDER_1						0x30140701
#define EC_PST_OST_SCLRBEGUPFOLDER_2						0x30140702
#define EC_PST_OST_SCLRBEGUPFOLDER_3						0x30140703
#define EC_PST_OST_SCLRBEGUPCONTENTS_1						0x30140801
#define EC_PST_OST_SCLRBEGUPCONTENTS_2						0x30140802
#define EC_PST_OST_SCLRBEGUPTABLE_1							0x30140901
#define EC_PST_OST_SCLRBEGUPTABLE_2							0x30140902
#define EC_PST_OST_SCLRENDUPTABLE							0x30140A01
#define EC_PST_OST_SCLRBEGUPMESSAGE_1						0x30140B01
#define EC_PST_OST_SCLRBEGUPMESSAGE_2						0x30140B02
#define EC_PST_OST_SCLRBEGUPMESSAGEREAD_1					0x30140C01
#define EC_PST_OST_SCLRBEGUPMESSAGEREAD_2					0x30140C02
#define EC_PST_OST_SCLRBEGUPMESSAGEDEL_1					0x30140D01
#define EC_PST_OST_SCLRBEGUPMESSAGEDEL_2					0x30140D02
#define EC_PST_OST_SCLRENDUPMESSAGEDEL_1					0x30140E01
#define EC_PST_OST_SCLRENDUPMESSAGEDEL_2					0x30140E02
#define EC_PST_OST_SYNCBEG									0x30140F01
#define EC_PST_OST_SYNCEND									0x30141001
#define EC_PST_OST_SCLRSETMODIFIED_1						0x30141101
#define EC_PST_OST_SCLRSETMODIFIED_2						0x30141102
#define EC_PST_OST_SCLROPENSTREAM							0x30141201
#define EC_PST_OST_SRLRUPDFOLDERCKEY						0x30141301
#define EC_PST_OST_SCLRBEGDNTABLE							0x30141401
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_1					0x30141501
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_2					0x30141502
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_3					0x30141503
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_4					0x30141504
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_5					0x30141505
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_6					0x30141506
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_7					0x30141507
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_8					0x30141508
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_9					0x30141509
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_10					0x3014150A
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_11					0x3014150B
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_12					0x3014150C
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_13					0x3014150D
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_14					0x3014150E
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_15					0x3014150F
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_1					0x30141601
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_2					0x30141602
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_3					0x30141603
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_4					0x30141604
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_5					0x30141605
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_6					0x30141606
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_7					0x30141607
#define EC_PST_OST_SCLRPATCHHIERROW							0x30141701
#define EC_PST_OST_MSXSETFOLDERINFO_1						0x30141801
#define EC_PST_OST_MSXSETFOLDERINFO_2						0x30141802
#define EC_PST_OST_MSXSETFOLDERINFO_3						0x30141803
#define EC_PST_OST_MSXSETFOLDERINFO_4						0x30141804
#define EC_PST_OST_MSXSETFOLDERINFO_5						0x30141805
#define EC_PST_OST_MSXGETFOLDERINFO							0x30141901
#define EC_PST_OST_SCLRFLDUPDATE							0x30141A01
#define EC_PST_OST_SCLRFAVCREATE_1							0x30141B01
#define EC_PST_OST_SCLRFAVCREATE_2							0x30141B02
#define EC_PST_OST_SCLRFAVCREATE_3							0x30141B03
#define EC_PST_OST_SCLRFAVDELETE_1							0x30141C01
#define EC_PST_OST_SCLRFAVDELETE_2							0x30141C02
#define EC_PST_OST_SCLRFAVDELETE_3							0x30141C03
#define EC_PST_OST_SCLRFAVDELETE_4							0x30141C04
#define EC_PST_OST_SCLRBEGDNFORM_1							0x30141D01
#define EC_PST_OST_SCLRCONFLICTCHECK						0x30141E01
#define EC_PST_OST_SCLRFIXUPWINNER1							0x30141F01
#define EC_PST_OST_SCLRFIXUPWINNER2_1						0x30142001
#define EC_PST_OST_SCLRFIXUPWINNER2_2						0x30142002
#define EC_PST_OST_SCLRGETCHGINFO_1							0x30142101
#define EC_PST_OST_SCLRGETCHGINFO_2							0x30142102
#define EC_PST_OST_MSXGETFOLDERCKEY							0x30142201
#define EC_PST_OST_SCLROPMODREAD							0x30142301
#define EC_PST_OST_SCLROPPROCESS							0x30142401
#define EC_PST_OST_SCLRFLDCHECKREP_1						0x30142501
#define EC_PST_OST_SCLRFLDCHECKREP_2						0x30142502
#define EC_PST_OST_SCLRFLDCHECKREP_3						0x30142503

#define EC_PST_GENERIC										0x30FFFFFF

#endif // _PST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_imem.h ===
/*
 *	_IMEM.H
 *	
 *	Routines and macros to manage per-instance global variables
 *	for DLLs under both Win16 and Win32. Assumes that all of the
 *	DLL's per-instance global variables live in a single block of
 *	memory; functions are provided to install and retrieve the
 *	correct block of memory for the current instance.
 *	
 *	There are only two functions:
 *	
 *		PvGetInstanceGlobals	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobals	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *	
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 */

#ifndef _IMEM_H
#define _IMEM_H

#if defined (WIN32) && !defined (MAC)

/*
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 */


extern LPVOID pinstX;

#define PvGetInstanceGlobals()		pinstX
#define ScSetInstanceGlobals(_pv)	(pinstX = _pv, 0)


// hack to get around broken windows headers.
// winnt.h defines RtlMoveMemory as memmove which is in the C-runtime... which we are not linking to.
// We want the Kernel32 version.
#undef RtlMoveMemory

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );


#elif defined (WIN16)

/*
 *	The WIN16 implementation uses a fixed array of pointers and a
 *	matching fixed array of keys unique to the calling process.
 */


#define cInstMax	50

LPVOID		PvGetInstanceGlobals(void);
SCODE		ScSetInstanceGlobals(LPVOID pv);

#elif defined (MAC)

/*
 *	The MAC implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 */

LPVOID		PvGetInstanceGlobals(WORD dwDataSet);
SCODE		ScSetInstanceGlobals(LPVOID pv, WORD dwDataSet);

#else

#error I only do Windows and Mac!

#endif	/* WIN32, WIN16, Mac */

#ifdef _WIN64
void WabValidateClientheap();

#endif

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
#ifndef WIN16
MAPIFREEBUFFER MAPIFreeBuffer;
#endif

#endif	/* _IMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_huntype.h ===
/*
 * HUNTYPE.H - Hungarian typedefs internal header file
 *
 * Contains various common hungarian typedefs used throughout the MAPI
 * project.  If you need to include this file in your subsystem, #define
 * ___huntype_h_, then #include <mapi>
 */


//	Byte counts

typedef USHORT		 CB;		//	16-bit count of bytes
typedef ULONG		 LCB;		//	32-bit count of bytes
typedef CB			*PCB;
typedef LCB			*PLCB;

//	Character counts

typedef USHORT		CCH;
								//	Note: PCCH defined elsewise by WINNT.H


//	Index into byte array

typedef USHORT		 IB;
typedef ULONG		 LIB;
typedef IB			*PIB;
typedef LIB			*PLIB;


//	Pointers to other things...

typedef LPVOID		 PV;		//	pointer to void
typedef LPVOID *	 PPV;		//	pointer to pointer to void
typedef LPBYTE		 PB;		//	pointer to bytes
typedef ULONG		*PUL;		//	pointer to unsigned longs
typedef ULONG		 FID;		//  field identifier
typedef FID			*PFID;		//  pointer to a field identifier

//	Definitions that undoubtedly belong somewhere in some internal header
//	file other than this one, but are put here for the sake of simplicity.

typedef char		*SZ;		//	null terminated string

#define		fFalse		0
#define		fTrue		1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_idrgdrp.h ===
/****
*
*
*
* idrgdrp.h - drag 'n' drop for vcard files and other formats
*
*
*    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
****/

#ifndef _IDRGDRP_H
#define _IDRGDRP_H


struct _IWAB_DRAGDROP;
typedef struct _IWAB_DRAGDROP * LPIWABDRAGDROP;


/* IWAB_DROPTARGET ------------------------------------------------------ */
#define CBIWAB_DROPTARGET sizeof(IWAB_DROPTARGET)


#define IWAB_DROPTARGET_METHODS(IPURE)	                    \
	MAPIMETHOD(DragEnter)									\
		(THIS_	IDataObject * pDataObject,					\
				DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;		\
	MAPIMETHOD(DragOver)									\
		(THIS_	DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;		\
	MAPIMETHOD(DragLeave)									\
		(THIS)									IPURE;		\
	MAPIMETHOD(Drop)										\
		(THIS_	IDataObject * pDataObject,					\
				DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DropTarget
DECLARE_MAPI_INTERFACE_(IWAB_DropTarget, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DROPTARGET_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DROPTARGET

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DROPTARGET_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DROPTARGET_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPTARGET_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DROPTARGET_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPTARGET_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DROPTARGET_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DROPTARGET_METHODS(IMPL)
};


typedef struct _IWAB_DROPTARGET
{
    MAPIX_BASE_MEMBERS(IWAB_DROPTARGET)

	LPIWABDRAGDROP lpIWDD;

} IWABDROPTARGET, * LPIWABDROPTARGET;

/* ----------------------------------------------------------------------------------------------*/




/* IWAB_DROPSOURCE ------------------------------------------------------ */
#define CBIWAB_DROPSOURCE sizeof(IWAB_DROPSOURCE)


#define IWAB_DROPSOURCE_METHODS(IPURE)	                    \
	MAPIMETHOD(QueryContinueDrag)							\
		(THIS_	BOOL fEscapePressed,						\
                DWORD grfKeyState)				IPURE;		\
	MAPIMETHOD(GiveFeedback)								\
		(THIS_	DWORD dwEffect)					IPURE;	

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DropSource
DECLARE_MAPI_INTERFACE_(IWAB_DropSource, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DROPSOURCE_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DROPSOURCE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DROPSOURCE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DROPSOURCE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPSOURCE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DROPSOURCE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPSOURCE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DROPSOURCE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DROPSOURCE_METHODS(IMPL)
};


typedef struct _IWAB_DROPSOURCE
{
    MAPIX_BASE_MEMBERS(IWAB_DROPSOURCE)

	LPIWABDRAGDROP lpIWDD;

} IWABDROPSOURCE, * LPIWABDROPSOURCE;

/* ----------------------------------------------------------------------------------------------*/


/* IWAB_DRAGDROP ------------------------------------------------------ */
#define CBIWAB_DRAGDROP sizeof(IWAB_DRAGDROP)


#undef           INTERFACE
#define          INTERFACE      IWAB_DragDrop
DECLARE_MAPI_INTERFACE_(IWAB_DragDrop, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DRAGDROP

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DRAGDROP_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DRAGDROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DRAGDROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DRAGDROP_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
};


typedef struct _IWAB_DRAGDROP
{
    MAPIX_BASE_MEMBERS(IWAB_DRAGDROP)

	LPIWABDRAGDROP lpIWDD;

	LPIWABDROPTARGET lpIWABDropTarget;

	LPIWABDROPSOURCE lpIWABDropSource;

	LPDATAOBJECT m_pIDataObject;
	DWORD		m_dwEffect;
	CLIPFORMAT  m_cfAccept;
	BOOL		m_bIsCopyOperation; // if CTRL key is pressed
    DWORD       m_grfInitialKeyState;
    BOOL        m_bSource;
    BOOL        m_bOverTV;

    LPVOID      m_lpv; // data of parent window
} IWABDRAGDROP, * LPIWABDRAGDROP;

/* ----------------------------------------------------------------------------------------------*/


// Create the IDragDrop Data Object
HRESULT HrCreateIWABDragDrop(LPIWABDRAGDROP * lppIWABDragDrop);


/* ----------------------------------------------------------------------------------------------*/


/* IWAB_DATAOBJECT ------------------------------------------------------ */
#define CBIWAB_DATAOBJECT sizeof(IWAB_DATAOBJECT)

    
#define IWAB_DATAOBJECT_METHODS(IPURE)	                    \
	MAPIMETHOD(GetData)                                     \
		(THIS_	FORMATETC * pFormatetc,	                    \
                STGMEDIUM * pmedium)            IPURE;      \
	MAPIMETHOD(GetDataHere)                                 \
        (THIS_  FORMATETC * pFormatetc,	                    \
                STGMEDIUM * pmedium)            IPURE;      \
    MAPIMETHOD(QueryGetData)                                \
        (THIS_  FORMATETC * pFormatetc)         IPURE;      \
    MAPIMETHOD(GetCanonicalFormatEtc)                       \
        (THIS_  FORMATETC * pFormatetcIn,	                \
                FORMATETC * pFormatetcOut)      IPURE;      \
    MAPIMETHOD(SetData)                                     \
        (THIS_  FORMATETC * pFormatetc,                     \
                STGMEDIUM * pmedium,                        \
                BOOL fRelease)                  IPURE;      \
    MAPIMETHOD(EnumFormatEtc)                               \
        (THIS_  DWORD dwDirection,	                        \
                IEnumFORMATETC ** ppenumFormatetc)  IPURE;  \
    MAPIMETHOD(DAdvise)                                     \
        (THIS_  FORMATETC * pFormatetc,	                    \
                DWORD advf,	                                \
                IAdviseSink * pAdvSink,	                    \
                DWORD * pdwConnection)          IPURE;      \
    MAPIMETHOD(DUnadvise)                                   \
        (THIS_  DWORD dwConnection)             IPURE;      \
    MAPIMETHOD(EnumDAdvise)                                 \
        (THIS_  IEnumSTATDATA ** ppenumAdvise)  IPURE;      \

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DataObject
DECLARE_MAPI_INTERFACE_(IWAB_DataObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DATAOBJECT_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DATAOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DATAOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DATAOBJECT_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DATAOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DATAOBJECT_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DATAOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DATAOBJECT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DATAOBJECT_METHODS(IMPL)
};


typedef struct _IWAB_DATAOBJECT
{
    MAPIX_BASE_MEMBERS(IWAB_DATAOBJECT)

    LPADRBOOK m_lpAdrBook; 
    HWND m_hWndLV;

    BOOL m_bObjectIsGroup;   // TRUE when dragging a single object which is a group

    ULONG cbDatahDrop;
    const void *pDatahDrop;
    
    ULONG cbDataTextA;
    const void *pDataTextA;

    ULONG cbDataTextW;
    const void *pDataTextW;

    ULONG cbDataBuffer;
    const void *pDataBuffer;

    ULONG cbDataEID;
    const void *pDataEID;
    
    LPVOID m_lpv;
} IWABDATAOBJECT, * LPIWABDATAOBJECT;

/* ----------------------------------------------------------------------------------------------*/

// Creates the IDataObject that holds info about the dragged and dropped object
HRESULT HrCreateIWABDataObject(LPVOID lpv, LPADRBOOK lpAdrBook, HWND hWndLV, LPIWABDATAOBJECT * lppIWABDataObject, BOOL bGetDataNow, BOOL bIsGroup);




/* ----------------------------------------------------------------------------------------------*/


/* IWAB_ENUMFORMATETC ------------------------------------------------------ */
#define CBIWAB_ENUMFORMATETC sizeof(IWAB_ENUMFORMATETC)

    
#define IWAB_ENUMFORMATETC_METHODS(IPURE)	                \
	MAPIMETHOD(Next)                                        \
        (THIS_  ULONG celt,                                 \
                FORMATETC *rgelt,                           \
                ULONG *pceltFethed)         IPURE;          \
	MAPIMETHOD(Skip)                                        \
        (THIS_  ULONG celt)                 IPURE;          \
	MAPIMETHOD(Reset)                                       \
        (THIS)                              IPURE;          \
	MAPIMETHOD(Clone)                                       \
        (THIS_  IEnumFORMATETC ** ppenum)   IPURE;          \

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_EnumFORMATETC
DECLARE_MAPI_INTERFACE_(IWAB_EnumFORMATETC, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_ENUMFORMATETC_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_ENUMFORMATETC

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_ENUMFORMATETC_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_ENUMFORMATETC_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_ENUMFORMATETC_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_ENUMFORMATETC_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_ENUMFORMATETC_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_ENUMFORMATETC_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_ENUMFORMATETC_METHODS(IMPL)
};


typedef struct _IWAB_ENUMFORMATETC
{
    MAPIX_BASE_MEMBERS(IWAB_ENUMFORMATETC)

    UINT	     ifmt;
    UINT	     cfmt;
    FORMATETC	 afmt[1];
    
} IWABENUMFORMATETC, * LPIWABENUMFORMATETC;

/* ----------------------------------------------------------------------------------------------*/

HRESULT HrCreateIWABEnumFORMATETC(UINT cfmt, 
                                const FORMATETC afmt[], 
                                LPIWABENUMFORMATETC *ppenumFormatEtc);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_iab.h ===
/***********************************************************************
 *
 *  _IAB.H
 *
 *  Header file for code in IADRBOOK.C: Address Book object
 *
 *  Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//	structure used to contain information about the open hierarchy tables
//
typedef struct {
    ULONG ulConnection;
    LPMAPITABLE lpTable;
    LPMAPITABLE lpmtRestricted;
    LPIAB lpIAB;
    LPMAPIADVISESINK lpABAdviseSink;
    LPMAPICONTAINER lpContainer;
} TABLEINFO, *LPTABLEINFO;


#define SafeRelease(x)                                      \
    if (x)                                                  \
    {                                                       \
        ULONG uRef = (x)->lpVtbl->Release((x));             \
        DebugTrace(TEXT("**** SafeRelease: %s: Release refCount: %d\n"), TEXT(#x), uRef); \
        if(uRef==0) (x) = NULL;                             \
    }

// This following struct contains info about extensible actions in the UI
// Declared here because these actions are read from the registry and cached 
// on the IAddrBook object once per session
//
typedef struct _WABACTIONITEM
{
    GUID            guidContextMenu;    // GUID identifying the menu extension
    LPCONTEXTMENU   lpContextMenu;      // ICOntextMenu object provided by the extension
    LPWABEXTINIT    lpWABExtInit;       // IWABExtInit object provided by the extension
    int             nCmdIdFirst;        // First Menu Command ID for this extension
    int             nCmdIdLast;         // Last Menu Command ID for this extension
    struct _WABACTIONITEM * lpNext;
} WABACTIONITEM, FAR * LPWABACTIONITEM;


// Folders within the WAB are just special mailuser entries
// We cache information about all the WAB fodlers on the IAB Object
// so that we have handy access to the folders from the lpAdrBook object
//
// There are 2 types of folders:
//  User Folders
//  Regular folders
//
//  User folders correspond to the various identities... Each identity gets
//  one user folder which is non-shareable and appears at the top level of the
//  treeview in the WAB Main view. This folder is distinguished in that it has a
//  corresponding GUID identifying the identity it corresponds to.
//  User folders are not shareable.
//  Regular folders don't correspond to a particular Identity and are shareable.
//
// Folowing structure holds information about a particular folder
//
typedef struct _WABFOLDER
{
    LPTSTR  lpFolderName;   // String containing folder name
    LPTSTR  lpProfileID;    // <GUID> profile ID for the Identity that created the folder (if it's a User folder)
    BOOL    bShared;        // Whether the folder is shared or not
    BOOL    bOwned;         // Set to true if this folder "belongs" to an existing user folder
    SBinary sbEID;          // Entryif of this item
    LPTSTR  lpFolderOwner;  // String identifying the "owner" of this folder - used for reverting a folder to it's original creator if it is shared or unshared
    int     nMenuCmdID;     // when we load a list of folders, we will assign a menu id to them to make it easier to manipulate them in the Share Folders menu
    struct _WABFOLDERLIST * lpFolderList;
    struct _WABFOLDER * lpNext;
} WABFOLDER, FAR * LPWABFOLDER;

typedef struct _WABFOLDERLIST
{
    LPWABFOLDER lpFolder;
    struct _WABFOLDERLIST * lpNext;
} WABFOLDERLIST, FAR * LPWABFOLDERLIST;

#define WABUSERFOLDER   WABFOLDER
#define LPWABUSERFOLDER LPWABFOLDER

// This structure is used for doing prop sheet extensions
//  Information about property sheet extensions is loaded up the first time
//  user wants to see properties on a WAB contact. The info is then cached on the
//  IAB object
//
typedef struct _ExtDisplayDLLInfo
{
    GUID guidPropExt;       // GUID identifying the Property Sheet extension
    BOOL bMailUser;         // Whether this is property sheet extension for a MailUser or a DistList
    LPSHELLPROPSHEETEXT lpPropSheetExt; // IShellPropSheetExt object returned by extension
    LPWABEXTINIT lpWABExtInit;  // IWABExtInit object returned by extension
    struct _ExtDisplayDLLInfo * lpNext;
} EXTDLLINFO, * LPEXTDLLINFO;

/* IDentityChangeNotification
-  Identity Change Notification object for the Identity manager
-   This is cached on the IAB Object so that the IAB always has the 
-   knowledge of the latest current identity*/
typedef struct _WAB_IDENTITYCHANGENOTIFY * LPWABIDENTITYCHANGENOTIFY;

//
// IAB Object
//
typedef struct _IAB {
    MAPIX_BASE_MEMBERS(IAB)

    LPPROPDATA lpPropData;

    LONG lRowID;				 //  Status Row #

    LPIWOINT lpWABObject;       // Our parent WABObject

    //
    // Stores a handle to the open property store
    //
    LPPROPERTY_STORE lpPropertyStore;

    //  Default directory info
    LPENTRYID lpEntryIDDD;
    ULONG cbEntryIDDD;

    //  PAB directory info
    LPENTRYID lpEntryIDPAB;
    ULONG cbEntryIDPAB;

    BOOL fReloadSearchPath;

    // Cached Search Path containers
    LPSPropValue lpspvSearchPathCache;

    //  Merged hierarchy table
    LPTABLEDATA lpTableData;
    LPMAPITABLE lpmtHierarchy;

    //  Merged One Off Table
    LPTABLEDATA lpOOData;
    LPMAPITABLE lpmtOOT;

    // List of open hierarchy tables
    ULONG ulcTableInfo;
    LPTABLEINFO pargTableInfo;

    // List of open oneoff tables
    ULONG ulcOOTableInfo;
    LPTABLEINFO pargOOTableInfo;

    // List of IAB handled Advise "ulConnections"
    LPADVISELIST padviselistIAB;

    // WAB Version of notifications for this pointer
    LPADVISE_LIST pWABAdviseList;

    // Set TRUE if creation of IAB loaded LDAP client
    BOOL fLoadedLDAP;

    HWND        hWndNotify;     // hidden window that runs a notification spooler
    UINT_PTR    ulNotifyTimer;  // notification spooler timer
    LPWSTR      lpwszWABFilePath;// FCN file path
    HANDLE      hThreadNotify;
    HANDLE      hEventKillNotifyThread;

    FILETIME ftLast;

    // Stuff used with Context Extensions
    // This is a list of extensions cached on the IAB object
    LPWABACTIONITEM lpActionList;   // All the registered rt-click actions for this wab
    LPMAILUSER lpCntxtMailUser;

    // Browse window .. assuming there's only one per IAddrBook object ..
    HWND hWndBrowse;

    // Identity manager information cached on the IAB object
    LPWABIDENTITYCHANGENOTIFY lpWABIDCN;
    DWORD dwWABIDCN;
    IUserIdentityManager * lpUserIdentityManager;
    BOOL fCoInitUserIdentityManager;
    ULONG cIdentInit;

    // Information about the current identity
    TCHAR           szProfileName[CCH_IDENTITY_NAME_MAX_LENGTH];// Current identities name
    TCHAR           szProfileID[CCH_IDENTITY_NAME_MAX_LENGTH];  // Current identities GUID in string form
    LPWABUSERFOLDER lpWABUserFolders;       // Linked list of all user folders
    LPWABUSERFOLDER lpWABCurrentUserFolder; // The current Identities user folder
    LPWABFOLDER     lpWABFolders;           // Linked list of ALL WAB folders
    GUID            guidCurrentUser;        // GUID for the current Identity
    HKEY            hKeyCurrentUser;        // Special HKEY for the identity

    // Stuff for caching prop sheet extensions
    LPEXTDLLINFO lpPropExtDllList;
    int nPropExtDLLs;   //# of extension DLLs

    // Caling processes can pass in a GUID through WABOpen WAB_PARAM structure
    // that identifies the calling process. This GUID can later be used for
    // several app-specific things - e.g.
    // We use this guid to identify which property sheet and context menu
    // extensions belong to the calling app and then decide to only show those
    // extensions in that case. Could also use this guid to load the apps
    // specific printer extension.
    GUID guidPSExt; 
    
    // Outlook folder information
    struct _OlkContInfo *rgwabci;
    ULONG cwabci;

    // Flags that tell us the state of the WAB
    BOOL bProfilesEnabled;  // means the caller didn't pass in WAB_ENABLE_PROFILES 
                            // in WABOpen so we should treat the API as olde flavor
                            // but the UI should show folders etc

    BOOL bProfilesIdent;    // means the caller passed in WAB_ENABLE_PROFILES
                            // both UI and API should be identity aware, 
                            // but probably Identities are disabled

    BOOL bProfilesAPIEnabled; // means the caller passed in WAB_ENABLE_PROFILES
                            // so both UI and API should be identity aware
    
    BOOL bUseOEForSendMail; // set to true when client passes WAB_USE_OE_SENDMAIL 
                            // into WABOpen - when this flag is passed in we try to
                            // exclusively use OE for send-mail

    BOOL bSetOLKAllocators; // Boolean set if this object created inside and Outlook session, i.e.,
                            // the WAB is set to use the Outlook MAPI allocators.
	
	HANDLE	hMutexOlk; // used for keeping track of outlook notifications
	DWORD	dwOlkRefreshCount;
	DWORD	dwOlkFolderRefreshCount;

} IAB, *LPIAB;	


//
//  Private Prototypes
//

//
//  Entry point to create a new IAB object
//
HRESULT HrNewIAB(LPPROPERTY_STORE lpPropertyStore,
  LPWABOBJECT lpWABObject,
  LPVOID * lppIAB);

HRESULT MergeOOTables(LPIAB lpIAB,
  ULONG ulFlags);

HRESULT HrMergeTableRows(LPTABLEDATA lptadDst,
  LPMAPITABLE lpmtSrc,
  ULONG ulProviderNum);


#define MIN_CCH_LAST_ERROR	256
#define MAX_CCH_LAST_ERROR	2048

//	The Number of MAPI internal ONE-OFF entries in the AB OOTable.
#define IAB_INTERNAL_OOCNT	1

//	Max Hierarchy Entries per Provider
#define IAB_PROVIDER_HIERARCHY_MAX	0x0000ffff

// used with ptagaABSearchPath declared in abint.c


enum {
    iPATH = 0,
    iUPDATE
};

enum ivtANRCols {
    ivtACPR_ENTRYID = 0,
    ivtACPR_DISPLAY_NAME_A,
    ivtACPR_ADDRTYPE_A,
    ivtACPR_OBJECT_TYPE,
    ivtACPR_DISPLAY_TYPE,
    ivtACPR_EMAIL_ADDRESS_A,
    ivtACPR_SEARCH_KEY,
    ivtACPR_SEND_RICH_INFO,
    ivtACPR_TRANSMITABLE_DISPLAY_NAME_A,
    ivtACPR_7BIT_DISPLAY_NAME,
    cvtACMax
};

// Loads the WABs internally used name properties
HRESULT HrLoadPrivateWABProps(LPIAB lpIAB);

// Reads the custom column props from the registry
void ReadWABCustomColumnProps(LPIAB lpIAB);


// Functions defined in Notify.c
HRESULT HrAdvise(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulEventMask,
  LPMAPIADVISESINK lpAdvise,
  ULONG FAR * lpulConnection);

HRESULT HrUnadvise(LPIAB lpIAB, ULONG ulConnection);
// fires the nontifications
HRESULT HrWABNotify(LPIAB lpIAB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_layguid.h ===
/*
 *	_LAYGUID.H
 *
 *	Lays down actual, 16-byte GUIDs for use in an EXE or DLL.
 *	Should be included in only one module (a .C file) of said EXE or DLL.
 *	Before including, define the tags for all the GUIDs you
 *	plan to use, e.g.
 *
 *		#define USES_IID_IUnknown
 *		#define USES_IID_IStream
 *		#define USES_IID_IMAPIProp
 *		#include <_layguid.h>
 */



#ifdef USES_GUID_NULL
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#endif

#ifdef USES_IID_IUnknown
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
#endif

#ifdef USES_IID_IClassFactory
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
#endif

#ifdef USES_IID_IMalloc
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
#endif

#ifdef USES_IID_IMarshal
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);
#endif


/* RPC related interfaces */
#ifdef USES_IID_IRpcChannel
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
#endif

#ifdef USES_IID_IRpcStub
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
#endif

#ifdef USES_IID_IStubManager
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxy
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
#endif

#ifdef USES_IID_IProxyManager
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
#endif

#ifdef USES_IID_IPSFactory
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxyBuffer
DEFINE_GUID(IID_IRpcProxyBuffer, 0xD5F56A34, 0x593B, 0x101A, 0xB5, 0x69, 0x08, 0x00, 0x2B, 0x2D, 0xBF, 0x7A);
#endif

#ifdef USES_IID_IPSFactoryBuffer
DEFINE_GUID(IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcChannelBuffer
DEFINE_GUID(IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcStubBuffer
DEFINE_GUID(IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

/* storage related interfaces */
#ifdef USES_IID_ILockBytes
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
#endif

#ifdef USES_IID_IStorage
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
#endif

#ifdef USES_IID_IStream
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATSTG
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);
#endif


/* moniker related interfaces */
#ifdef USES_IID_IBindCtx
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
#endif

#ifdef USES_IID_IMoniker
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
#endif

#ifdef USES_IID_IRunningObjectTable
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
#endif

#ifdef USES_IID_IInternalMoniker
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);
#endif


/* storage related interfaces */
#ifdef USES_IID_IRootStorage
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved1
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved2
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved3
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);
#endif


/* concurrency releated interfaces */
#ifdef USES_IID_IMessageFilter
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);
#endif


/* CLSID of standard marshaler */
#ifdef USES_CLSID_StdMarshal
DEFINE_OLEGUID(CLSID_StdMarshal,		0x00000017L, 0, 0);
#endif


/* interface on server for getting info for std marshaler */
#ifdef USES_IID_IStdMarshalInfo
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);
#endif


/* NOTE: LSB 0x19 through 0xff are reserved for future use */

//	End of COGUID.H clone

//	Copied from OLEGUID.H

/* this file is the master definition of all public GUIDs specific to OLE
   and is included in ole2.h.

   NOTE: The second least significant byte of all of these GUIDs is 1.
*/


#ifdef USES_IID_IEnumUnknown
DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
#endif

#ifdef USES_IID_IEnumString
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
#endif

#ifdef USES_IID_IEnumMoniker
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
#endif

#ifdef USES_IID_IEnumFORMATETC
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
#endif

#ifdef USES_IID_IEnumOLEVERB
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATDATA
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);
#endif


#ifdef USES_IID_IEnumGeneric
DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
#endif

#ifdef USES_IID_IEnumHolder
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
#endif

#ifdef USES_IID_IEnumCallback
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);
#endif


#ifdef USES_IID_IPersistStream
DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
#endif

#ifdef USES_IID_IPersistStorage
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
#endif

#ifdef USES_IID_IPersistFile
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
#endif

#ifdef USES_IID_IPersist
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);
#endif


#ifdef USES_IID_IViewObject
DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
#endif

#ifdef USES_IID_IDataObject
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
#endif

#ifdef USES_IID_IAdviseSink
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
#endif

#ifdef USES_IID_IDataAdviseHolder
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
#endif

#ifdef USES_IID_IOleAdviseHolder
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);
#endif


#ifdef USES_IID_IOleObject
DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceObject
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
#endif

#ifdef USES_IID_IOleWindow
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceUIWindow
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceFrame
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceActiveObject
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);
#endif


#ifdef USES_IID_IOleClientSite
DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceSite
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);
#endif


#ifdef USES_IID_IParseDisplayName
DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
#endif

#ifdef USES_IID_IOleContainer
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
#endif

#ifdef USES_IID_IOleItemContainer
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);
#endif


#ifdef USES_IID_IOleLink
DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
#endif

#ifdef USES_IID_IOleCache
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
#endif

#ifdef USES_IID_IOleManager
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0);
#endif

#ifdef USES_IID_IOlePresObj
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);
#endif


#ifdef USES_IID_IDropSource
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
#endif

#ifdef USES_IID_IDropTarget
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
#endif


#ifdef USES_IID_IDebug
DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
#endif

#ifdef USES_IID_IDebugStream
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);
#endif



/* NOTE: LSB values 0x25 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
#ifdef USES_CLSID_StdOleLink
DEFINE_OLEGUID(CLSID_StdOleLink,			0x00000300, 0, 0);
#endif

#ifdef USES_CLSID_StaticMetafile
DEFINE_OLEGUID(CLSID_StaticMetafile,        0x00000315, 0, 0);
#endif

#ifdef USES_CLSID_StaticDib
DEFINE_OLEGUID(CLSID_StaticDib,             0x00000316, 0, 0);
#endif

//	End of OLEGUID.H clone
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_imemx.h ===
/*
 *	_IMEMX.H
 *	
 *	Routines and macros to manage per-instance global variables
 *	for DLLs under both Win16 and Win32.  Allows the per-instance globals
 *	for different functional areas of a DLL to reside in seperate memory blocks
 *  Functions are provided to install and retrieve the
 *	correct block of memory for the current instance/functional_area.
 *	
 *	There are only two functions:
 *	
 *		PvGetInstanceGlobalsEx	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobalsEx	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *	
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 */

#ifndef _IMEMX_H
#define _IMEMX_H

#if defined (WIN32) && !defined (MAC)

/*
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 */

#define DefineInstList(Name) VOID FAR *pinst_##Name = NULL
#define DeclareInstList(Name) extern VOID FAR *pinst_##Name;

#define PvGetInstanceGlobalsEx(Name)		pinst_##Name
#define ScSetInstanceGlobalsEx(_pv, Name)	(pinst_##Name = _pv, 0)

#elif defined (WIN16)

/*	InstList
 *
 *	Since more than one independently developed functional areas can be
 *	combined into a single DLL, the routines for finding instance data in
 *	WIN16 will take an LPInstList as a parameter.  A seperate InstList
 *	structure is kept for each functional area.
 *
 *	Each InstList has a fixed array of pointers (lprgLpvInstList) and a
 *	matching fixed array of keys (lprgInstKeyList) unique to the calling
 *	process.  The key for a given process (StackSegment) and the index of this
 *	key in lprgInstKeyList can be quickly obtained.  A pointer to the instance
 *	data is at the corresponding index of lprgLpvInstList.  Though the
 *  instance key (StackSegment) can be obtained quickly and is guaranteed (in
 *	WIN16) to be unique at any given moment, it is not guaranteed to be unique
 *	throughout the life of the DLL.  For this reason a "more" unique key may
 *	be useful at Instance Contruct/Destruct time.  lprgdwPidList is a list of
 *	keys corresponding to lprgInstKeyList which are guaranteed unique through
 *	the life of the DLL, but which are more time consuming to obtain.
 */
typedef struct _InstList
{
	WORD			cInstEntries;
	WORD			wCachedKey;
	LPVOID			lpvCachedInst;
	DWORD			dwInstFlags;
	WORD FAR *		lprgwInstKey;
	LPVOID FAR *	lprglpvInst;
	DWORD FAR *		lprgdwPID;
	HTASK FAR *		lprghTask;		// raid 31090: used to recycle instance slots
} InstList, FAR * LPInstList;

#define INST_ALLOCATED	1

/*
 *	
 */

#define cInstChunk	50

#define		DefineInstList(Name) \
InstList instList_##Name = { 0, 0, NULL, INST_ALLOCATED, NULL, NULL, NULL}

#define		DeclareInstList(Name) extern InstList instList_##Name

#define		PvGetInstanceGlobalsEx(Name) \
				PvGetInstanceGlobalsInt(&instList_##Name)

#define		ScSetInstanceGlobalsEx(pv, Name) \
				ScSetInstanceGlobalsInt(pv, &instList_##Name)

extern LPVOID		PvGetInstanceGlobalsInt(LPInstList lpInstListX);
extern SCODE		ScSetInstanceGlobalsInt(LPVOID pv, LPInstList lpInstListX);

#elif defined (MAC)

/*
 *	The MAC implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 */

#define				DeclareInstList(Name)
LPVOID FAR PASCAL	PvGetInstanceGlobalsMac(WORD dwDataSet);
SCODE FAR PASCAL	ScSetInstanceGlobalsMac(LPVOID pv, WORD dwDataSet);

#else

//$ REVIEW: DOS based pst will not compile without these
//	definitions
//
#define DeclareInstList(Name) extern VOID FAR *pinst_##Name;
#define PvGetInstanceGlobalsEx(Name)		pinst_##Name

#endif	/* WIN32, WIN16, Mac */

#endif	/* _IMEMX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_iprop.h ===
//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _IPDAT

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	IPDAT_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IPDAT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IPROPDATA_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IPDAT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IPROPDATA_METHODS(IMPL)			
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IPDAT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IPROPDATA_METHODS(IMPL)
};

/* Generic part of property linked lists.
 */
typedef struct _lstlnk {
	struct _lstlnk FAR *	lpNext;
	ULONG					ulKey;
} LSTLNK, FAR * LPLSTLNK;

typedef LPLSTLNK FAR * LPPLSTLNK;


/* Linked list of property values.
 */
typedef struct _lstspv {
	LSTLNK			lstlnk;
	LPSPropValue	lpPropVal;
	ULONG			ulAccess;
} LSTSPV, FAR * LPLSTSPV;
#define CBLSTSPV sizeof(LSTSPV)

/* Linked list of property ID to NAME mappings.
 */
typedef struct _lstspn {
	LSTLNK			lstlnk;
	LPMAPINAMEID	lpPropName;
} LSTSPN, FAR * LPLSTSPN;

typedef struct _IPDAT {
	IPDAT_Vtbl FAR *	lpVtbl;

	// Generic IMAPIUnknown portion
	UNKOBJ_MEMBERS;
	UNKINST		inst;

	//
	//  Says whether or not this object (as a whole) is modifiable
	//
	ULONG		ulObjAccess;

	// List of properties in this object
	LPLSTSPV	lpLstSPV;

	// Count of properties in this object
	ULONG 		ulCount;

	// List of property ID to NAME maps for this object
	LPLSTSPN	lpLstSPN;

	// Next ID to use when creating a new NAME to ID map
	ULONG		ulNextMapID;

} IPDAT, *LPIPDAT;	

#define CBIPDAT sizeof(IPDAT)




/* dimensionof determines the number of elements in "array".
 */

#ifdef WIN16
#ifndef dimensionof
#define	dimensionof(rg)			(sizeof(rg)/sizeof(*(rg)))
#endif // !dimensionof
#else  // WIN16
#define	dimensionof(rg)			(sizeof(rg)/sizeof(*(rg)))
#endif // WIN16

#define SET_PROP_TYPE(ultag, ultype)	(ultag) = ((ultag) & 0xffff0000) \
												  | (ultype)
#define MIN_NAMED_PROP_ID	0x8000
#define MAX_NAMED_PROP_ID	0xfffe



SCODE ScWCToAnsiMore(   LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                        LPWSTR lpszWC, LPSTR * lppszAnsi );
SCODE ScAnsiToWCMore(   LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                        LPSTR lpszAnsi, LPWSTR * lppszWC );

LPSTR ConvertWtoA(LPCWSTR lpszW);
LPWSTR ConvertAtoW(LPCSTR lpszA);

SCODE ScConvertAPropsToW(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropArray, ULONG ulcProps, ULONG ulStart);
SCODE ScConvertWPropsToA(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropArray, ULONG ulcProps, ULONG ulStart);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_itable.h ===
/*============================================================================
 *
 *	_ITABLE.H
 *
 *	Internal header file for MAPI 1.0 In-memory MAPI Table DLL
 *
 *	Copyright (C) 1993 and 1994 Microsoft Corporation
 *
 *
 *	Hungarian shorthand:
 *		To avoid excessively long identifier names, the following
 *		shorthand expressions are used:
 *
 *			LPSPropTagArray		lppta
 *			LPSRestriction		lpres
 *			LPSPropValue		lpprop
 *			LPSRow				lprow
 *			LPSRowSet			lprows
 *			LPSSortOrder		lpso
 *			LPSSortOrderSet		lpsos
 */

// $MAC - Fix up some naming conflicts

#ifdef MAC
#define FFindColumn				ITABLE_FFindColumn
#endif

typedef	struct _TAD FAR *		LPTAD;
typedef struct _VUE FAR *		LPVUE;

//	Global Constants
#define ROW_CHUNK_SIZE			50
#define COLUMN_CHUNK_SIZE		15

//	Max number of notifications to send in a batch
//
//	Raid: Horsefly/Exchange/36281
//	This was changed from 8 to 1 because code in itable.c which fills in
//	the batch cannot guarantee the correct order of the notifications in
//	it.  If this is ever changed, that bug will have to be revisited.
//
#define MAX_BATCHED_NOTIFS		1

//	For use in aligning data in buffers
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))

//	This structure is used to keep track of a private memory buffer which is
//	used with the private AllocateMore function ScBufAllocateMore().  This
//	allows for one MAPI memory allocation when the size of a property is known
//	and the author wishes to use PropCopyMore.  See ITABLE.C ScCopyTadRow()
//	for an example.
typedef struct _CMB
{
	ULONG	ulcb;
	LPVOID	lpv;
} 	CMB, * LPCMB;


#if	!defined(NO_VALIDATION)

#define VALIDATE_OBJ(lpobj,objtype,fn,lpVtbl)										\
	if ( BAD_STANDARD_OBJ(lpobj,objtype,fn,lpVtbl))										\
	{																		\
		DebugTrace(  TEXT("%s::%s() - Invalid parameter passed as %s object\n"),	\
					#objtype,												\
					#fn,													\
					#objtype );												\
		return ResultFromScode( MAPI_E_INVALID_PARAMETER );					\
	}

#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

// $MAC - Supprt for WLM 4.0
#ifndef VTABLE_FILL
#define VTABLE_FILL
#endif



#define	HrSetLastErrorIds(lpobj,sc,ids)				\
			UNKOBJ_HrSetLastError((LPUNKOBJ)(lpobj),	\
								 (sc),				\
								 (ids))



#ifdef	WIN32
#define	LockObj(lpobj)		UNKOBJ_Lock((LPUNKOBJ)(lpobj))
__inline VOID
UNKOBJ_Lock( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

#define UnlockObj(lpobj)	UNKOBJ_Unlock((LPUNKOBJ)(lpobj))
__inline VOID
UNKOBJ_Unlock( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}
#else
#define	LockObj(lpobj)
#define	UnlockObj(lpobj)
#endif


// Memory Management Macros for code readability

#define	ScAllocateBuffer(lpobj,ulcb,lppv)				\
			UNKOBJ_ScAllocate((LPUNKOBJ)(lpobj),	\
							  (ulcb),				\
							  (LPVOID FAR *)(lppv))


#define	ScAllocateMore(lpobj,ulcb,lpv,lppv)			\
			UNKOBJ_ScAllocateMore((LPUNKOBJ)(lpobj),	\
								  (ulcb),				\
								  (lpv),				\
								  (LPVOID FAR *)(lppv))

#define ScFreeBuffer(lpobj,lpv)					\
			UNKOBJ_Free((LPUNKOBJ)(lpobj), (lpv))

#define	ScCOAllocate(lpunkobj,ulcb,lplpv)		\
			UNKOBJ_ScCOAllocate((LPUNKOBJ)(lpunkobj),(ulcb),(lplpv))


#define	ScCOReallocate(lpunkobj,ulcb,lplpv)		\
			UNKOBJ_ScCOReallocate((LPUNKOBJ)(lpunkobj),(ulcb),(lplpv))


#define	COFree(lpunkobj,lpv)		\
			UNKOBJ_COFree((LPUNKOBJ)(lpunkobj),(lpv))


#define	MAPIFreeRows(lpobj,lprows)				\
			UNKOBJ_FreeRows((LPUNKOBJ)(lpobj),(lprows))




/*============================================================================
 *	TAD (table data class)
 *
 *		Implementes in-memory table data object.
 */

#undef	INTERFACE
#define	INTERFACE	struct _TAD
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,TAD_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_ITABLEDATA_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,TAD_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_ITABLEDATA_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(TAD_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_ITABLEDATA_METHODS(IMPL)
};

typedef struct _TAD
{
	TAD_Vtbl FAR *		lpVtbl;
	UNKOBJ_MEMBERS;

	UNKINST				inst;

	LPVUE				lpvueList;

	ULONG				ulTableType;
	ULONG				ulPropTagIndexCol;

	ULONG				ulcColsMac;
	LPSPropTagArray		lpptaCols;			// Initial view col set (CO)

	ULONG				ulcRowsAdd;
	ULONG				ulcRowMacAdd;
	LPSRow *			parglprowAdd;		// Unsorted Row Set (CO)

	ULONG				ulcRowsIndex;
	ULONG				ulcRowMacIndex;
	LPSRow * 			parglprowIndex;		// Row Set Sorted by Index (CO)

   LPVOID              lpvDataSource;   // used to store container specific data
   ULONG               cbDataSource;    // bytes in lpvDataSource to copy to new allocation.
                                        // If non-zero, CreateView should LocalAlloc this size
                                        // and copy data from lpvDataSource into it.  Release
                                        // should LocalFree.

   // With multiple containers, it becomes necessary to figure
   // out which container the table represents. We cache the containers
   // EID in the table for easy access. This is a pointer .. no need to free
   LPSBinary            pbinContEID;

   // When calling get ContentsTable, we may sometimes want a list of
   // contents from ALL the folders/containers for a particular profile and
   // return those contents as a single contentstable. Following flag caches
   // this setting so we collate contents of all folders. Works only if the
   // container being opened was the PAB container and if bProfilesAPIEnabled
   // (ie profiles were invoked explicitly)
   BOOL                 bAllProfileContents;

   // For PAB containers where profilesAPIEnabled=FALSE, GetContentsTable
   // typically means return contents of ALL the WAB since user hasn;t asked for
   // profiles. In this case we may want to have the option of opening only
   // a particular folder and getting only the conetnts of that folder .. so we
   // need a flag to cache this inverse option.
    BOOL                 bContainerContentsOnly;

    // When calling GetContentsTable, the caller can specify MAPI_UNICODE
    // for unicode tables.. we cache that flag in case we need to refill the table
    // at some later point ..
    BOOL                bMAPIUnicodeTable;
} TAD;

SCODE
ScCopyTadRowSet(
	LPTAD			lptad,
	LPSRowSet		lprowsetIn,
	ULONG *			pcNewTags,
	ULONG *			pcRows,
    LPSRow * *		pparglprowUnsortedCopy,
	LPSRow * *		pparglprowSortedCopy );

SCODE
ScCopyTadRow( LPTAD			lptad,
			  LPSRow		lprow,
			  ULONG *		pTagsAdded,
			  LPSRow FAR *	lplprowCopy );

VOID
UpdateViews( LPTAD		lptad,
			 ULONG		cRowsToRemove,
			 LPSRow *	parglprowToRemove,
			 ULONG		cRowsToAdd,
			 LPSRow *	parglprowToAddUnsorted,
			 LPSRow *	parglprowToAddSorted );

VOID
FixupView(
	LPVUE		lpvue,
	ULONG		cRowsToRemove,
	LPSRow *	parglprowToRemove,
	ULONG		cRowsToAdd,
	LPSRow *	parglprowToAddUnsorted,
	LPSRow *	parglprowToAddSorted );

SCODE
ScReplaceRows(
	LPTAD		lptad,
	ULONG		cRowsNew,
	LPSRow *	parglprowNew,
	ULONG *		pcRowsOld,
	LPSRow * *	pparglprowOld );

SCODE
ScFindRow( LPTAD		lptad,
		   LPSPropValue	lpprop,
		   LPSRow * *	pplprow );
SCODE
ScAddRow( LPUNKOBJ			lpunkobj,
		  LPSSortOrderSet	lpsos,
		  LPSRow			lprow,
		  ULONG				uliRow,
		  ULONG *			pulcRows,
		  ULONG *			pulcRowsMac,
		  LPSRow **			pparglprows,
		  LPSRow **			pplprow );





/*============================================================================
 *	VUE (table view class)
 */

#undef	INTERFACE
#define	INTERFACE	struct _VUE
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,VUE_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,VUE_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(VUE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPITABLE_METHODS(IMPL)
};

/*	BOOKMARK status
 *
 *	dwfBKSFree		is used for a bookmark that is NOT valid and
 *					is available for use
 *	dwfBKSValid		is set for any used bookmark.
 *	dwfChanged		is used with dwfBKSValid to indicate that the marked row
 *					has moved since the last query which in involved this
 *					bookmark
 *	dwfBKSMoving	is used with dwfBKSValid to indicate that the marked row is
 *					in the process of being moved relative to other rows.
 *	dwfBKSStale		is used with dwfBKSValid to indicate the given bookmark
 *					no longer marks a row but has not been Freed
 *	dwfBKSMask		is the set of all valid bookmark status
 *	
 */	
#define dwfBKSFree		((DWORD) 0x00000000)
#define	dwfBKSValid		((DWORD) 0x00000001)
#define dwfBKSChanged	((DWORD) 0x00000002)
#define dwfBKSMoving	((DWORD) 0x00000004)
#define	dwfBKSStale		((DWORD) 0x00000008)
#define	dwfBKSMask		(~(dwfBKSValid|dwfBKSChanged|dwfBKSMoving|dwfBKSStale))

#define	FBadBookmark(lpvue,bk)							\
		((bk) >= cBookmarksMax ||						\
		 ((lpvue)->rgbk[(bk)].dwfBKS == dwfBKSFree) ||	\
		 ((lpvue)->rgbk[(bk)].dwfBKS & dwfBKSMask))		\

typedef struct
{
	DWORD	dwfBKS;			// Bookmark status
	union
	{
		ULONG	uliRow;		// dwfBKSValid || dwfBKSChanged
		LPSRow	lprow;		// dwfBKSMoving
	};
} BK, * PBK;


// There is a maximum of 42 client defined bookmarks for each VUE.  This
// seems adequate for an in-memory table.
// Bookmarks are kept as an array of 45 where the first three are
// the MAPI predefined bookmarks.

#define cBookmarksMax		45	// Max. # of bookmarks including reserved ones
#define	cBookmarksReserved	3	// # of reserved bookmarks (begin, cur, end)

#define	BOOKMARK_MEMBERS				\
	struct								\
	{									\
		union							\
		{								\
			struct						\
			{							\
				BK	bkBeginning;		\
				BK	bkCurrent;			\
				BK	bkEnd;				\
			};							\
			BK	rgbk[cBookmarksMax];	\
		};								\
	}									\

typedef BOOKMARK_MEMBERS UBK, * PUBK;

typedef struct _VUE
{
	VUE_Vtbl FAR *		lpVtbl;
	UNKOBJ_MEMBERS;

	LPVUE				lpvueNext;
	LPTAD				lptadParent;

	LPSPropTagArray		lpptaCols;		// Column set (MAPI)
	LPSRestriction		lpres;			// Restriction (MAPI)
	LPSSortOrderSet		lpsos;			// Sort order set (MAPI)

	CALLERRELEASE FAR *	lpfReleaseCallback;
	ULONG				ulReleaseData;

	ULONG				ulcRowMac;	// Space available for rows
	LPSRow *			parglprows;	// Sorted Row Set

	BOOKMARK_MEMBERS;

	LPADVISELIST		lpAdviseList;
	ULONG				ulcAdvise;
	MAPIUID				mapiuidNotif;

   LPVOID              lpvDataSource;   // used to store container specific data
   ULONG               cbDataSource;    // bytes in lpvDataSource to copy to new allocation.
                                        // If non-zero, CreateView should LocalAlloc this size
                                        // and copy data from lpvDataSource into it.  Release
                                        // should LocalFree.

   BOOL                 bMAPIUnicodeTable; //tracks whether parent table needs UNICODE data or not

} VUE;

typedef struct _VUENOTIFKEY
{
	ULONG		ulcb;
	MAPIUID		mapiuid;

} VUENOTIFKEY;

BOOL
FBookMarkStale( LPVUE lpvue,
				BOOKMARK bk);

SCODE
ScLoadRows( ULONG			ulcRowsSrc,
			LPSRow *		rglprowsSrc,
			LPVUE			lpvue,
			LPSRestriction	lpres,
			LPSSortOrderSet	lpsos );

SCODE
ScDeleteAllRows( LPTAD		lptad);

SCODE
ScMaybeAddRow( LPVUE			lpvue,
			   LPSRestriction	lpres,
			   LPSSortOrderSet	lpsos,
			   LPSRow			lprow,
			   ULONG			uliRow,
			   ULONG *			pulcRows,
			   ULONG *			pulcRowMac,
			   LPSRow **		pparglprows,
			   LPSRow **		pplprow );

SCODE
ScCopyVueRow( LPVUE				lpvue,
			  LPSPropTagArray	lpptaCols,
			  LPSRow			lprowSrc,
			  LPSRow			lprowDst );




/*============================================================================
 *	Utilities
 */

SCODE
ScDupRestriction( LPUNKOBJ				lpunkobj,
				  LPSRestriction		lpres,
				  LPSRestriction FAR *	lplpresCopy );

SCODE
ScDupRestrictionMore( LPUNKOBJ			lpunkobj,
					  LPSRestriction	lpresSrc,
					  LPVOID			lpvLink,
					  LPSRestriction	lpresDst );

SCODE
ScSatisfiesRestriction( LPSRow			lprow,
						LPSRestriction	lpres,
						ULONG *			pfSatisfies );
SCODE
ScDupRgbEx( LPUNKOBJ		lpunkobj,
			ULONG			ulcb,
			LPBYTE			lpb,
			ULONG			ulcbExtra,
			LPBYTE FAR *	lplpbCopy );

LPSRow *
PlprowCollateRow( ULONG				ulcRows,
				  LPSRow *			rglprows,
				  LPSSortOrderSet	lpsos,
				  BOOL				fAfterExisting,
				  LPSRow			lprow );

LPSRow *
PlprowByLprow( ULONG	ulcRows,
			   LPSRow *	rglprows,
			   LPSRow	lprow );

LPSPropValue __fastcall
LpSPropValueFindColumn( LPSRow	lprow,
						ULONG	ulPropTagColumn );

STDMETHODIMP_(SCODE)
ScBufAllocateMore( ULONG		ulcb,
				   LPCMB		lpcmb,
				   LPVOID FAR *	lplpv );

ULONG
UlcbPropToCopy( LPSPropValue lpprop );



#ifndef WIN16 // WIN16 C (not C++) doesn't support INLINE functions.
              // Functions are defined in ITABLE.C.
/*============================================================================
 -	FFindColumn()
 -
 *		Checks a prop tag array to see if a given prop tag exists.
 *
 *		NOTE!  The prop tag must match completely (even type).
 *
 *
 *	Parameters:
 *		lpptaCols	in		Prop tag array to check
 *		ulPropTag	in		Prop tag to check for.
 *
 *	Returns:
 *		TRUE if ulPropTag is in lpptaCols
 *		FALSE if ulPropTag is not in lpptaCols
 */

__inline BOOL
FFindColumn(	LPSPropTagArray	lpptaCols,
		 		ULONG			ulPropTag )
{
	UNALIGNED ULONG *	pulPropTag;


	pulPropTag = lpptaCols->aulPropTag + lpptaCols->cValues;
	while ( --pulPropTag >= lpptaCols->aulPropTag )
		if ( *pulPropTag == ulPropTag )
			return TRUE;

	return FALSE;
}



/*============================================================================
 -	ScFindRow()
 -
 *		Finds the first row in the table data whose index column property
 *		value is equal to that of the specified property and returns the
 *		location of that row in the table data, or, if no such row exists,
 *		the end of the table data.
 *
 *	Parameters:
 *		lptad		in		TAD in which to find row
 *		lpprop		in		Index property to match
 *		puliRow		out		Pointer to location of found row
 *
 *	Error returns:
 *		MAPI_E_INVALID_PARAMETER	If proptag of property isn't the TAD's
 *										index column's proptag.
 *		MAPI_E_NOT_FOUND			If no matching row is found (*pplprow
 *										is set to lptad->parglprows +
 *										lptad->cRows in this case).
 */

__inline SCODE
ScFindRow(
	LPTAD			lptad,
	LPSPropValue	lpprop,
	LPSRow * *		pplprow)
{
	SCODE			sc = S_OK;
	SRow			row = {0, 1, lpprop};
	SizedSSortOrderSet(1, sosIndex) = { 1, 0, 0 };

	if (lpprop->ulPropTag != lptad->ulPropTagIndexCol)
	{
		sc = MAPI_E_INVALID_PARAMETER;
		goto ret;
	}

	Assert(!IsBadWritePtr(pplprow, sizeof(*pplprow)));

	//	Build a sort order set for the Index Column
	sosIndex.aSort[0].ulPropTag = lptad->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	*pplprow = PlprowCollateRow(lptad->ulcRowsIndex,
							  lptad->parglprowIndex,
							  (LPSSortOrderSet) &sosIndex,
							  FALSE,
							  &row);

	//	Find the row in the Index Sorted Row Set
	if (   !lptad->ulcRowsIndex
		|| (*pplprow >= (lptad->parglprowIndex + lptad->ulcRowsIndex))
		|| LPropCompareProp( lpprop, (**pplprow)->lpProps))
	{
		sc = MAPI_E_NOT_FOUND;
	}

ret:
	return sc;
}
#else  // !WIN16
BOOL FFindColumn( LPSPropTagArray lpptaCols, ULONG ulPropTag );
SCODE ScFindRow( LPTAD lptad, LPSPropValue lpprop, LPSRow * * pplprow);
#endif // !WIN16


//	This macro is used on a ULONG or INT that is to be used as denominator
//	If ul is non-zero it is returned unchanged.  If ul is zero then a 1 is
//	returned.
#define	UlDenominator(ul)	((ul) | !(ul))

BOOL
FRowContainsProp(LPSRow			lprow,
				 ULONG			cValues,
				 LPSPropValue	lpsv);

STDAPI_(SCODE)
CreateTableData(LPCIID lpiid,
  ALLOCATEBUFFER FAR *  lpfAllocateBuffer,
  ALLOCATEMORE FAR *    lpfAllocateMore,
  FREEBUFFER FAR *      lpfFreeBuffer,
  LPVOID                lpvReserved,
  ULONG                 ulTableType,
  ULONG                 ulPropTagIndexCol,
  LPSPropTagArray       lpptaCols,
  LPVOID                lpvDataSource,
  ULONG                 cbDataSource,
  LPSBinary             pbinContEID,
  ULONG                 ulFlags,
  LPTABLEDATA FAR *     lplptad);

HRESULT HrVUERestrict(  LPVUE   lpvue,
                        LPSRestriction lpres,
                        ULONG   ulFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_mailusr.h ===
#ifndef _MAILUSER_H_
#define _MAILUSER_H_


#undef	INTERFACE
#define INTERFACE	struct _MailUser

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, MailUser_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, MailUser_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(MailUser_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};


//	Keep the base members common across all the MAILUSER, CONTAINER, DISTLIST objects
// such that code reuse is leveraged.
//
#define MAILUSER_BASE_MEMBERS(_type)											 \
    MAPIX_BASE_MEMBERS(_type)                                                   \
                                                                                \
    LPPROPDATA          lpPropData;                                             \
    LPENTRYID           lpEntryID;                                              \
    LPIAB               lpIAB;                                                  \
    ULONG               ulObjAccess;                                            \
    ULONG               ulCreateFlags;                                          \
    LPSBinary           pmbinOlk;                                               \
    LPVOID              lpv;

typedef struct _MailUser {
    MAILUSER_BASE_MEMBERS(MailUser)
} MailUser, FAR * LPMailUser;	


HRESULT HrSetMAILUSERAccess(LPMAILUSER lpMAILUSER, ULONG ulFlags);
HRESULT HrNewMAILUSER(LPIAB lpIAB, LPSBinary pmbinOlk, ULONG ulType, ULONG ulFlags, LPVOID * lppMAILUSER);
BOOL FixDisplayName(    LPTSTR lpFirstName,
                        LPTSTR lpMiddleName,
                        LPTSTR lpLastName,
                        LPTSTR lpCompanyName,
                        LPTSTR lpNickName,
                        LPTSTR * lppDisplayName,
                        LPVOID lpvRoot);
// Parses a display name into first and last ...
BOOL ParseDisplayName(  LPTSTR lpDisplayName,
                        LPTSTR * lppFirstName,
                        LPTSTR * lppLastName,
                        LPVOID lpvRoot,
                        LPVOID * lppLocalFree);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_memcpy.h ===
/*
 *	MemCopy()
 *
 *	A much safer version of memcpy that checks the value of the byte
 *	count before calling the memcpy() function.  This macro is only built
 *	into the 16 bit non-debug builds.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#if defined(WIN16) && !defined(DEBUG)
#define MemCopy(_dst,_src,_cb)		do									\
									{									\
										size_t __cb = (size_t)(_cb);	\
										if (__cb)						\
											memcpy(_dst,_src,__cb);		\
									} while (FALSE)
#else
#define MemCopy(_dst,_src,_cb)	memcpy(_dst,_src,(size_t)(_cb))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_mapiprv.h ===
/*
 *	_MAPIPRV.H
 *
 *	MAPIX subsystem-wide definitions
 */

#ifdef __cplusplus
extern "C" {
#endif


#ifdef OLD_STUFF
#if defined(WIN32) && !defined(MAC) && !defined (COINITEX_DEFINED) && !defined(NT_BUILD)

// COM initialization flags; passed to CoInitializeEx.
// Doc'ed by OLE but not in their header. Not on Windows 95 yet.

typedef enum tagCOINIT
{
  COINIT_MULTITHREADED = 0,      // OLE calls objects on any thread.
  COINIT_SINGLETHREADED = 1,        // OLE calls objects on single thread.
  COINIT_APARTMENTTHREADED = 2        //$ MAIL: OLE apartment model.
} COINIT;

STDAPI  CoInitializeEx(LPMALLOC pMalloc, ULONG);

#endif	/**/
#endif



#ifndef MAC
typedef struct ProcessSerialNumber	{
	unsigned long			highLongOfPSN;
	unsigned long			lowLongOfPSN;
} ProcessSerialNumber;
#endif

#define	PSN							ProcessSerialNumber

/*
 *	IsEqualIID
 *
 *	This redefinition removes a dependency on compobj.dll.
 *	//$ It uses a byte-order-insensitive comparison on data that is
 *	//$ inherently byte-order-sensitive. If we ever wind up
 *	//$ remoting MAPI interfaces directly, it will break.
 */

#undef  IsEqualIID
#define IsEqualIID(i1,i2) IsEqualMAPIUID((i1), (i2))


#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(TCHAR))
#endif

// explicit implementation of CharSizeOf
#define CharSizeOf_A(x)	(sizeof(x) / sizeof(CHAR))
#define CharSizeOf_W(x)	(sizeof(x) / sizeof(WCHAR))



/*
 *	Shared memory header structure. This is the only thing that must
 *	appear at a fixed offset in the shared memory block; anything else
 *	can move.
 *
 *	//$ the shared profile name is for a temporary implementation of
 *	//$ piggyback logon
 */


#define ghnameMAPIX		((GHNAME)0x4d417049)	// Name of Global Heap
#define cbGHInitial		((DWORD) 0x00002000)	// Initial size of Global Heap
#define cKeyIncr   		0x10					// # of notif key slots to allocate

typedef struct
{
	ULONG	cRef;
	GHID	ghidSharedProfile;		// for fake piggyback logon
	UINT	cRefHack;

									// Spooler stuff
#if defined(WIN32) && !defined(MAC)
	DWORD	dwSpoolerPid;			// spooler's process handle
#elif defined(MAC)
	PSN		psnSpooler;				// spooler's process serial number
#else
	HTASK	htaskSpooler;			// spooler's task handle
#endif
	HWND	hwndSpooler;			// spooler's window handle
	UINT	cRefSpooler;			// maintained but not used
	UINT	uSpooler;				// spooler status
	DWORD	dwSecurePid;			// security pid
	LONG	lSecureId;				// security id

									// Subsystem stuff
	GHID	ghidTaskList;			// linked list of active MAPI callers
	GHID	ghidProfList;			// linked list of profile info

									// Notification stuff
	USHORT	cKeyMac;				// count of registered keys
	USHORT	cKeyMax;				// size of key offset array
	GHID	ghidKeyList;			// list of registered keys
									// (array of offsets)
	ULONG	ulConnectStub;			// stub spooler registration

	GHID	ghidOptionList;			// Transport registration stuff
									// Linked-list of per message & per
									// recipient options registered by XPs

	GHID	ghidUIMutexList;		// Linked list of UI mutexes

	GHID	ghididmp;				// Offset of session/identity mapping
	ULONG	cidmp;					// Count of mappings
	ULONG	cidmpMax;				// Available mappings

	GHID	ghidMsgCacheCtl; 		// Simple MAPI MsgID cache control struct
	
} SHDR, FAR *LPSHDR;


/*
 *	STAG
 *	
 *	Sesstion tag -- tags a session with the processes that have logged
 *	into the profile represented by the session
 */

typedef struct _STAG
{
	union
	{
		DWORD	pid;
		HTASK	htask;
		PSN		psn;
	};
	
} STAG, FAR * LPSTAG;

/*
 *	SPROF
 *
 *	Shared profile session information.
 */

typedef struct
{
	ULONG	cRef;					// Number of sessions active
	GHID	ghidProfNext;			// Next item in chain

									// Profile / session flags
	USHORT	fSpoolerInitDone : 1;	// TRUE <=> all XPs are loaded
	USHORT	fSharedSession	 : 1;	// TRUE <=> shared session is on this profile
	USHORT	fDeletePending	 : 1;	// TRUE <=> delete profile when zero refcount
	USHORT	fCleanedProfile	 : 1;	// TRUE <=> already removed temp sections
	USHORT	wPad;

	GHID	ghidPBdata;				// secret stuff for piggyback logon

	ULONG	cRowMax;				// count of status rows
	GHID	ghidRowList;			// array of offsets to shared row data

	CHAR	rgchName[cchProfileNameMax+1];

	USHORT	cstagMac;				// count of stags
	USHORT	cstagMax;				// space available for stags
	GHID	ghidstag;				// array of stags held by the session

} SPROF, FAR *LPSPROF;


#ifdef MAC
typedef LRESULT (STDAPICALLTYPE NOTIFYPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct _tagNOTIFY {
	NOTIFYPROC	*wndProc;
	PSN			psn;
} NOTIFY, *LPNOTIFY;
#endif

/*
 *	STASK
 *
 *	Keeps track of outstanding notifications for a particular
 *	process. The notification parameters live in shared memory, and
 *	are hung on a chain from this structure.
 *
 *	The flag 'fSignalled' is set when a message is posted to the
 *	target task's notification window, and cleared when its
 *	notification queue is emptied. So at most one message at a
 *	time is outstanding to a given task.
 *
 *	There is also some auxiliary info like the task's module name,
 *	for use in debugging.
 */

#define	MAPI_TASK_SERVICE	0x0001	// task was started as a service
#define	MAPI_TASK_SPOOLER	0x0002	// MAPI spooler
#define	MAPI_TASK_PENDING	0x0004	// spooler not up yet
//#define MAPI_TASK_SIGNALLED	0x0008

typedef struct
{
	GHID		ghidTaskNext;		//	link to next STASK in chain

									//	Task ID info
#ifndef MAC
	HWND		hwndNotify;			//	notification window handle
#else
	LPNOTIFY	hwndNotify;			// Not an hwnd at all!
#endif
	CHAR		szModName[16];		//	module name of running process (ansi only)
#ifdef NT
	DWORD		dwPID;				//	If process was started as a service this will contain PID		
#endif
	UINT		uFlags;				//  Information about task, ie, it's a service
	BOOL		fSignalled;			//	TRUE <=> message in queue
	UINT		cparmsMac;			//	# of notifications (SPARMS)
	UINT		cparmsMax;			//	# of notification slots allocated
	GHID		ghidparms;			//	offset to list of SPARMS

	
} STASK, FAR *LPSTASK;




/*
 *	LIBINFO
 *
 *	Used to keep track of DLLs loaded. Stores the name of the Dll and
 *	associated handle.
 */

typedef struct
{
	LPSTR		szDllName;			//	Name of provider Dll (ANSI only)
	HINSTANCE	hInstDll;			//	Handle to the loaded Dll
} LIBINFO, FAR *LPLIBINFO;


/*
 *
 *	Access to proxy and stub internals is restricted to the remoting code only.
 *	The rest should only access the IUnknown.
 *
 */
typedef LPUNKNOWN LPPROXY;
typedef LPUNKNOWN LPSTUB;

/*
 *	Instance global data for mapix.dll -- that is, information
 *	associated with a particular process.
 */

typedef struct
{
	BOOL			fTriedDlg;		// TRUE <=> tried to load dialog DLL
	HINSTANCE		hinstDlg;		// dialogs DLL instance handle
#ifdef OLD_STUFF
	MAPIDLG_ScInitMapidlg *pfnInitDlg;	// dialog fn proc address
	JT_MAPIDLG		jtDlg;			// dialog functions jump table

	LPSESSOBJ		psessobj;		// chain of session objects
	LPIPA			pipa;			// chain of ProfAdmin objects
	HINSTANCE		hinstProfile;	// profile DLL instance handle
	LPPRPROVIDER	lpPRProvider;	// -> profile provider object
#endif

#if 0	//$	Not needed with the new deferred provider unloading at deinit time
		
	HINSTANCE		hLibrary;		// latest library to be released

#else	//$	Deferred provider unloading support

	UINT			cLibraries;		// number of providers loaded
	LPLIBINFO 		lpLibInfo;		// array of info on loaded providers

#endif

//$New SMem stuff
	HGH				hghShared;		// handle to the global heap
	GHID			ghidshdr;		// offset of shared header struct (the Root)
//$New SMem stuff

//$Old SMem stuff
//	PSMEM			psmem;			// shared memory block
//	LPSMALLOC		psmalloc;		// shared heap manager
//	UINT			ibshdr;			// offset of shared header struct
//$Old SMem stuff

	ULONG			ulXPStatus;		// catches transport status row notifs
#ifndef MAC
	HWND			hwndNotify;		// multi-process notification info
#else
	LPNOTIFY		hwndNotify;		// Not an hwnd at all!
#endif
#ifdef OLD_STUFF
	LPADVISELIST	padviselist;	// open notifs on session
#endif

#if defined(WIN32) && !defined(MAC)
	HANDLE			htNotify;		// thread handle of notification thread
	DWORD			tidNotify;		// thread ID of notification thread
	HANDLE			heventNotify;	// event handle for thread sync
 	SCODE			scInitNotify;	// for use during startup only
#endif

#ifdef OLD_STUFF
    HMODULE			hmodWmsfr;		// form registry lib handle
    LPFNMAPIREGCREATE pfnCreateObject; // form registry init function
	LPMESSAGEFILTER	pMsgFilter;		// IMessage Filter interface
	LPUNKNOWN		pUnkPSFactory;	// Proxy Stub Factory's IUnknown
	LPPROXY			pProxyListHead;	// First of a chain of active proxy objects
	LPSTUB			pStubListHead;	// First of a chain of active stub objects
#endif

#if defined(WOW)
	LPVOID			pvConnection1632; // The 16 to 32 bit connection
#endif

#if defined(WIN16) && !defined(WOW)
	HWND			hwndMarshal;	// Window to defer release on an unmarshalled
									// interface to workaround 16bit CoMarshalInterface
									// bug - see SqlGuest:Exchange #14416.
#endif

	LPVOID			psvctbl;		// Spooler's service scheduler

	LPVOID			pvSentinel;		// Variables ABOVE this point are zeroed
									// at the last MAPIUninitialize; those
									// BELOW this point are not.

	int				cRef;			// reference count for this instance

	LPMALLOC		pmallocOrig;	// allocator from OLE - CoGetMalloc()
	HLH				hlhProvider;	// heap for Provider MAPIAllocateBuffer/More
	HLH				hlhInternal;	// heap for internal allocations
	ULONG			ulInitFlags;	// MAPIInitialize Flags for notification
									// support

	HMODULE			hmod;			// module handle of running process
	CHAR			szModName[16];	// module name of running process (ansi only)
#ifdef	WIN16
	HINSTANCE		hinstApp;		// calling app's instance handle
#endif	

#ifdef	WIN32
	HANDLE			heSecure;		// spooler blocking mutex
#endif
	
	CRITICAL_SECTION cs;			// critical section data
} INST, FAR *LPINST;



//
//  Generic internal entry ID structure
//
#pragma warning (disable: 4200)

typedef struct _MAPIEID {
	BYTE	abFlags[4];
	MAPIUID	mapiuid;
	UNALIGNED BYTE	bData[];
} MAPI_ENTRYID;

typedef UNALIGNED MAPI_ENTRYID *LPMAPI_ENTRYID;


extern HINSTANCE hinstMapiX;
extern HINSTANCE hinstMapiXWAB;

extern BOOL fGlobalCSValid;

extern BOOL bDNisByLN;
extern TCHAR szResourceDNByLN[32];
extern TCHAR szResourceDNByCommaLN[32];
extern TCHAR szResourceDNByFN[32];
extern BOOL bPrintingOn;
extern HANDLE ghEventOlkRefreshContacts;
extern HANDLE ghEventOlkRefreshFolders;

#ifdef OLD_STUFF
#pragma warning (default: 4200)

//	Hack structure for shared session
typedef struct
{
	UINT	cb;			//	all-inclusive
	UINT	cbsd;
	BYTE	ab[1];
} SESSHACK, FAR *LPSESSHACK;

//	Globally defined notification keys

extern struct _NOTIFKEY_notifkeyXPStatus notifkeyXPStatus;
extern struct _NOTIFKEY_notifkeyOlaf notifkeyOlaf;

//	Globally defined UIDs

extern MAPIUID muidProviderSection;
extern MAPIUID muidStoreWrap;
extern MAPIUID muidStatusWrap;
extern MAPIUID muidOOP;

#if defined(WIN32) && !defined(MAC)
#ifndef DATA1_BEGIN
#include "mapiperf.h"
#endif
#pragma DATA1_BEGIN
extern CRITICAL_SECTION csMapiInit;
extern CRITICAL_SECTION csHeap;
extern CRITICAL_SECTION csMapiSearchPath;
extern BOOL fGlobalCSValid;
#pragma DATA_END
#endif

//	Notification engine

SCODE			ScInitNotify( LPINST pinst );

void			DeinitNotify(void);
STDMETHODIMP	HrSubscribe(LPADVISELIST FAR *lppAdviseList,
						LPNOTIFKEY lpKey,
						ULONG ulEventMask,
						LPMAPIADVISESINK lpAdvise,
						ULONG ulFlags,
						ULONG FAR *lpulConnection);
STDMETHODIMP	HrUnsubscribe(LPADVISELIST FAR *lppAdviseList,
						ULONG ulConnection);
STDMETHODIMP	HrNotify(LPNOTIFKEY lpKey,
						ULONG cNotification,
						LPNOTIFICATION lpNotifications,
						ULONG * lpulFlags);

//	Instantiate an IMsgServiceAdmin interface

SCODE			ScNewServiceAdmin(LPMAPIPROF pprofile,
						LPVOID lpParentObj,
						LPSESSOBJ psessobj,
						LPTSTR lpszProfileName,
						ULONG ulFlags,
						LPSERVICEADMIN FAR *lppServiceAdmin);

// Instantiate an IProviderAdmin interface

SCODE			ScNewProviderAdmin(LPMAPIPROF pprofile,
						LPVOID lpParentObj,
						LPTSTR lpszProfileName,
						ULONG ulFlags,
						LPMAPIUID lpUID,
						BOOL fService,
						LPPROVIDERADMIN FAR *lppProviderAdmin);

//	Find (and optionally make) an SPROF list entry for a profile

LPSPROF PsprofFindCreate(HGH hgh, GHID ghidshdr, LPSTR szProfile,
		BOOL fCreate);

//	Decrement the global refcounts for a session
SCODE	ScDerefSessionGlobals(LPTSTR lpszProfileName);
SCODE	ScDerefProcessSessionGlobals(LPTSTR lpszProfileName
#if defined(WIN32) && !defined(MAC)
	, DWORD pid
#elif defined(MAC)
	, PSN *ppsn
#elif defined(WIN16)
	, HTASK htask
#endif
	, ULONG ulFlags
	);

//	Validate the spooler globals
//		S_OK				The spooler is up and running
//		S_FALSE				No spooler is running
//		MAPI_E_CALL_FAILED	The spooler has died

SCODE			ScSpoolerStatus(LPINST pinst, LPSHDR pshdr);
void			StopSpooler(LPSHDR pshdr);		//	NOT USED by design

//	Overall subsystem startup-shutdown routines

SCODE			ScInitMapiX(ULONG ulFlags, LPBYTE lpbSecurity);
void			DeinitMapiX(void);
SCODE			ScInitCompobj(LPINST FAR *ppinst, DWORD dwPid);
void			DeinitCompobj(LPINST pinst);
void			DestroyMapidlg(LPINST pinst);
void			CloseMapidlg(void);
SCODE			ScGetDlgFunction(UINT ibFunction, FARPROC FAR *lppfn,
						BOOL *pfDidInit);
#ifdef	WIN16
HINSTANCE		HinstApplication(void);
#endif	
LPMALLOC		PMallocOrig(void);
HLH				HlhInternal(void);
void			CleanupSession(LPSESSOBJ psessobj, BOOL fToldSpooler);
void			LogoffSpooler(LPSESSOBJ psessobj, ULONG ulReserved);

//	Get information about an entry ID

HRESULT			HrGetEIDType(LPSESSOBJ psessobj,
						ULONG cbeid,
						LPENTRYID peid,
						ULONG FAR *pulType,
						LPUNKNOWN FAR *ppunk);

//	Get information about a pair of entry IDs

HRESULT			HrGetEIDPairType(LPSESSOBJ psessobj,
						ULONG cbeid1,
						LPENTRYID peid1,
   						ULONG cbeid2,
   						LPENTRYID peid2,
						ULONG FAR *pulType,
						LPUNKNOWN FAR *ppunk);

//	Critical section for instance globals

STDAPI_(SCODE)	ScGetInst(LPINST FAR *ppinst);
STDAPI_(void)	ReleaseInst(LPINST FAR *ppinst);

//	Profile section access checks

typedef enum
{
	profaccClient = 0,
	profaccProvider,
	profaccService
} PROFACC;

HRESULT			HrCheckProfileAccess(PROFACC profacc,
						LPMAPIUID lpuid,
						LPMAPIUID lpuidParent,
						LPMAPIPROF pprofile);

#endif      // OLD_STUFF
#ifdef	__cplusplus
}		//	extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_notify.h ===
/*
 *      _NOTIFY.H
 *
 *      WAB Notification Engine Headers
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 */

#define MAX_NOTIFICATION_SPACE 0x10000  // maximum size of shared memory
#define WAB_W_NO_ADVISE (MAKE_MAPI_S(0x1002))

// Notification node structure for Global Notification List
typedef struct _NOTIFICATION_NODE {
   ULONG ulIdentifier;                  // unique identifier for this notification
   ULONG ulCount;                       // number of advise processes that have seen it
   NOTIFICATION Notification;           // notification structure
   struct _NOTIFICATION_NODE * lpNext;  // Pointer to next node
   ULONG cbData;                        // size of data in bytes
   BYTE Data[];                         // additional data for this node
} NOTIFICATION_NODE, * LPNOTIFICATION_NODE;

// Notification list structure for Global Notification List
typedef struct _NOTICATION_LIST {
    ULONG cAdvises;                     // Number of advise processes
    ULONG cEntries;                     // Number of entries in the list
    ULONG ulNextIdentifier;             // next notification identifer
    LPNOTIFICATION_NODE lpNode;         // First node in list or NULL if empty
} NOTIFICATION_LIST, *LPNOTIFICATION_LIST;

// Advise node structure for Local Advise List
typedef struct _ADVISE_NODE {
    ULONG ulConnection;                 // connection identifier
    ULONG ulEventMask;                  // mask of event types
    LPMAPIADVISESINK lpAdviseSink;      // AdviseSink object to be called on notification
    struct _ADVISE_NODE * lpNext;       // next node in AdviseList
    struct _ADVISE_NODE * lpPrev;       // next node in AdviseList
    ULONG cbEntryID;                    // size of lpEntryID
    BYTE EntryID[];                     // EntryID of object to advise on
} ADVISE_NODE, *LPADVISE_NODE;

// Advise list structure for Local Advise List
typedef struct _ADVISE_LIST {
    ULONG cAdvises;                     // Number of nodes in the list
    LPADVISE_NODE lpNode;
} ADVISE_LIST, *LPADVISE_LIST;

HRESULT HrFireNotification(LPNOTIFICATION lpNotification);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_ldapcnt.h ===
/***********************************************************************
 *
 *  _LDAPCNT.H
 *
 *  Header file for code in LDAPCONT.C
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer for LDAP object.  (i.e. IAB::OpenEntry() with an
 *  lpEntryID of NULL).
 */

#undef	INTERFACE
#define INTERFACE	struct _LDAPCONT

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, LDAPCONT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, LDAPCONT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(LDAPCONT_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _LDAPCONT {
    MAILUSER_BASE_MEMBERS(LDAPCONT)
    ULONG ulType;
} LDAPCONT, *LPLDAPCONT;

#define CBLDAP	sizeof(LDAPCONT)

#define LDAPCONT_cInterfaces 3

/*============================================================================
 *	LDAPVUE (table view class) functions
 *
 *  Function prototypes for functions to override in the LDAPVUE vtable.
 */

STDMETHODIMP
LDAPVUE_FindRow(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	BOOKMARK		bkOrigin,
	ULONG			ulFlags );

STDMETHODIMP
LDAPVUE_Restrict(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	ULONG			ulFlags );


// Definitions
#define LDAP_AUTH_METHOD_ANONYMOUS  LDAP_AUTH_ANONYMOUS     // Anonymous binding
#define LDAP_AUTH_METHOD_SIMPLE     LDAP_AUTH_PASSWORD      // LDAP_AUTH_SIMPLE binding
#define LDAP_AUTH_METHOD_SICILY     LDAP_AUTH_MEMBER_SYSTEM // Use Sicily (challenge-response) authentication

#define LDAP_USERNAME_LEN           256 // Maximum length for username/DN
#define LDAP_PASSWORD_LEN           256 // Maximum length for password
#define LDAP_ERROR                  0xffffffff  // Generic LDAP error code.
#define COUNTRY_STR_LEN             2   // Size of country string for ldap_search base
#define LDAP_SEARCH_SIZE_LIMIT      100 // Maximum number of entries to return from a search
#define LDAP_SEARCH_TIME_LIMIT      60  // Maximum number of seconds for server to spend on a search
#define LDAP_SEARCH_TIMER_ID        1   // ID of timer used for asynch LDAP searches
#define LDAP_BIND_TIMER_ID          2   // ID of timer used for asynch LDAP bind
#define LDAP_SEARCH_TIMER_DELAY     100 // Number of milliseconds to wait between polls for asynch LDAP searches
#define SEARCH_CANCEL_DIALOG_DELAY  2000// Number of milliseconds to wait before displaying cancel dialog
#define MAX_ULONG                   0xffffffff

#define LDAP_DEFAULT_PORT           389

// structure for getting proc addresses of api functions
typedef struct _APIFCN
{
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;

// structure to hold MAPI property to LDAP attibute mapping
typedef struct _ATTRMAP
{
  ULONG   ulPropTag;  // MAPI property tag
  const TCHAR * pszAttr;    // LDAP attribute name
} ATTRMAP;

// structure to hold LDAP server parameters
// as read in from the registry through the account manager
//
typedef struct _LDAPSERVERPARAMS
{
  DWORD   dwSearchSizeLimit;
  DWORD   dwSearchTimeLimit;
  DWORD   dwAuthMethod;
  LPTSTR  lpszUserName;
  LPTSTR  lpszPassword;
  LPTSTR  lpszURL;          // URL for server information
  LPTSTR  lpszLogoPath;     // path to the logo bitmap for this server
  BOOL    fResolve;         // Resolve against this server if TRUE
  LPTSTR  lpszBase;         // Search Base
  LPTSTR  lpszName;         // Actual server name or IP address
  DWORD   dwID;             // Unique server ID (order specifier)
  DWORD   dwPort;           // Port to connect to - 389 is default but this could be different
  DWORD   dwUseBindDN;
  DWORD   dwUseSSL;
  DWORD   dwPagedResult;
  LPTSTR  lpszAdvancedSearchAttr;     // List of searchable attributes for advanced searching
  DWORD   dwIsNTDS;                   // used to determine if this is an NTDS or not ..  
  IF_WIN32(BOOL    fSimpleSearch;)    // If specified, we use a very very simple filter ...
  IF_WIN16(DWORD   fSimpleSearch;)    // BOOL is defined as DWORD
                                      // in WIN32 while it is UINT in WIN16.
} LDAPSERVERPARAMS, FAR* LPLDAPSERVERPARAMS;

  BOOL              fUseSynchronousSearch;

#define LSP_ShowAnim                0x00000001
#define LSP_ResolveMultiple         0x00000002
#define LSP_UseSynchronousBind      0x00000004
#define LSP_InitDll                 0x00000008
#define LSP_AbandonSearch           0x00000010
#define LSP_SimpleSearch            0x00000020
#define LSP_UseSynchronousSearch    0x00000040
#define LSP_PagedResults            0x00000080
#define LSP_NoPagedResults          0x00000100
#define LSP_IsNTDS                  0x00000200
#define LSP_IsNotNTDS               0x00000400

// structure to pass data back from IDD_DIALOG_LDAPCANCEL handler
typedef struct _LDAPSEARCHPARAMS
{
  ULONG             ulTimeout;
  ULONG             ulTimeElapsed;
  ULONG             ulMsgID;
  ULONG             ulResult;
  ULONG             ulError;
  LDAP**            ppLDAP;
  LPTSTR             szBase;
  ULONG             ulScope;
  LPTSTR             szFilter;
  LPTSTR             szNTFilter;
  LPTSTR*            ppszAttrs;
  ULONG             ulAttrsonly;
  LDAPMessage**     lplpResult;
  LPTSTR            lpszServer;
  ULONG             ulEntryIndex;
  UINT              unTimerID;
  LPADRLIST         lpAdrList;
  LPFlagList        lpFlagList;
  HWND              hDlgCancel;
  ULONG             ulFlags;
  ULONG             ulLDAPValue;
  LPTSTR            lpszBindDN;
  DWORD             dwAuthType;
  struct berval *   pCookie;
  BOOL              bUnicode;
} LDAPSEARCHPARAMS, * PLDAPSEARCHPARAMS;


typedef struct _SERVER_NAME {
    LPTSTR lpszName;
    DWORD dwOrder;
    /*UNALIGNED */struct _SERVER_NAME * lpNext;
} SERVER_NAME, *LPSERVER_NAME;


// Creates an LDAP URL by deconstructing the LDAP entryid and using information from
// it to fill in gaps in the URL
void CreateLDAPURLFromEntryID(ULONG cbEntryID, LPENTRYID lpEntryID, LPTSTR * lppBuf, BOOL * lpbIsNTDSEntry);


// LDAP function typedefs

// ldap_open
typedef LDAP* (__cdecl LDAPOPEN)( LPTSTR HostName, ULONG PortNumber );
typedef LDAPOPEN FAR *LPLDAPOPEN;

//ldap_connect
typedef ULONG (__cdecl LDAPCONNECT)( LDAP *ld, LDAP_TIMEVAL *timeout);
typedef LDAPCONNECT FAR *LPLDAPCONNECT;

//ldap_init
typedef LDAP* (__cdecl LDAPINIT)( LPTSTR HostName, ULONG PortNumber );
typedef LDAPINIT FAR *LPLDAPINIT;

// ldap_sslinit
typedef LDAP* (__cdecl LDAPSSLINIT)( LPTSTR HostName, ULONG PortNumber , int Secure);
typedef LDAPSSLINIT FAR *LPLDAPSSLINIT;

// ldap_set_option
typedef ULONG (__cdecl LDAPSETOPTION)( LDAP *ld, int option, void *invalue );
typedef LDAPSETOPTION FAR *LPLDAPSETOPTION;

// ldap_bind_s
typedef ULONG (__cdecl LDAPBINDS)(LDAP *ld, LPTSTR dn, LPTSTR cred, ULONG method);
typedef LDAPBINDS FAR *LPLDAPBINDS;

// ldap_bind
typedef ULONG (__cdecl LDAPBIND)( LDAP *ld, LPTSTR dn, LPTSTR cred, ULONG method );
typedef LDAPBIND FAR *LPLDAPBIND;

//ldap_unbind
typedef ULONG (__cdecl LDAPUNBIND)(LDAP* ld);
typedef LDAPUNBIND FAR *LPLDAPUNBIND;

// ldap_search
typedef ULONG (__cdecl LDAPSEARCH)(
        LDAP    *ld,
        LPTSTR   base,
        ULONG   scope,
        LPTSTR   filter,
        LPTSTR   attrs[],
        ULONG   attrsonly
    );
typedef LDAPSEARCH FAR *LPLDAPSEARCH;

// ldap_search_s
typedef ULONG (__cdecl LDAPSEARCHS)(
        LDAP            *ld,
        LPTSTR           base,
        ULONG           scope,
        LPTSTR           filter,
        LPTSTR           attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );
typedef LDAPSEARCHS FAR *LPLDAPSEARCHS;

// ldap_search_st
typedef ULONG (__cdecl LDAPSEARCHST)(
        LDAP            *ld,
        LPTSTR           base,
        ULONG           scope,
        LPTSTR           filter,
        LPTSTR           attrs[],
        ULONG           attrsonly,
        struct l_timeval  *timeout,
        LDAPMessage     **res
    );
typedef LDAPSEARCHST FAR *LPLDAPSEARCHST;

// ldap_abandon
typedef ULONG (__cdecl LDAPABANDON)( LDAP *ld, ULONG msgid );
typedef LDAPABANDON FAR *LPLDAPABANDON;

// ldap_result
typedef ULONG (__cdecl LDAPRESULT)(
        LDAP            *ld,
        ULONG           msgid,
        ULONG           all,
        struct l_timeval  *timeout,
        LDAPMessage     **res
    );
typedef LDAPRESULT FAR *LPLDAPRESULT;

// ldap_result2error
typedef ULONG (__cdecl LDAPRESULT2ERROR)(
        LDAP            *ld,
        LDAPMessage     *res,
        ULONG           freeit      // boolean.. free the message?
    );
typedef LDAPRESULT2ERROR FAR *LPLDAPRESULT2ERROR;

// ldap_msgfree
typedef ULONG (__cdecl LDAPMSGFREE)(LDAPMessage *res);
typedef LDAPMSGFREE FAR *LPLDAPMSGFREE;

// ldap_first_entry
typedef LDAPMessage* (__cdecl LDAPFIRSTENTRY)(LDAP *ld, LDAPMessage *res);
typedef LDAPFIRSTENTRY FAR *LPLDAPFIRSTENTRY;

// ldap_next_entry
typedef LDAPMessage* (__cdecl LDAPNEXTENTRY)(LDAP *ld, LDAPMessage *entry);
typedef LDAPNEXTENTRY FAR *LPLDAPNEXTENTRY;

// ldap_count_entries
typedef ULONG (__cdecl LDAPCOUNTENTRIES)(LDAP *ld, LDAPMessage *res);
typedef LDAPCOUNTENTRIES FAR *LPLDAPCOUNTENTRIES;

// ldap_first_attribute
typedef LPTSTR (__cdecl LDAPFIRSTATTR)(
        LDAP            *ld,
        LDAPMessage     *entry,
        BerElement      **ptr
    );
typedef LDAPFIRSTATTR FAR *LPLDAPFIRSTATTR;

// ldap_next_attribute
typedef LPTSTR (__cdecl LDAPNEXTATTR)(
        LDAP            *ld,
        LDAPMessage     *entry,
        BerElement      *ptr
    );
typedef LDAPNEXTATTR FAR *LPLDAPNEXTATTR;

// ldap_get_values
typedef LPTSTR* (__cdecl LDAPGETVALUES)(
        LDAP            *ld,
        LDAPMessage     *entry,
        LPTSTR           attr
    );
typedef LDAPGETVALUES FAR *LPLDAPGETVALUES;

// ldap_get_values_len
typedef struct berval** (__cdecl LDAPGETVALUESLEN)(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    LPTSTR           attr
    );
typedef LDAPGETVALUESLEN FAR *LPLDAPGETVALUESLEN;

// ldap_count_values
typedef ULONG (__cdecl LDAPCOUNTVALUES)(LPTSTR *vals);
typedef LDAPCOUNTVALUES FAR *LPLDAPCOUNTVALUES;

// ldap_count_values_len
typedef ULONG (__cdecl LDAPCOUNTVALUESLEN)(struct berval **vals);
typedef LDAPCOUNTVALUESLEN FAR *LPLDAPCOUNTVALUESLEN;

// ldap_value_free
typedef ULONG (__cdecl LDAPVALUEFREE)(LPTSTR *vals);
typedef LDAPVALUEFREE FAR *LPLDAPVALUEFREE;

// ldap_value_free_len
typedef ULONG (__cdecl LDAPVALUEFREELEN)(struct berval **vals);
typedef LDAPVALUEFREELEN FAR *LPLDAPVALUEFREELEN;

// ldap_get_dn
typedef LPTSTR (__cdecl LDAPGETDN)(LDAP *ld, LDAPMessage *entry);
typedef LDAPGETDN FAR *LPLDAPGETDN;

// ldap_memfree
typedef VOID (__cdecl LDAPMEMFREE)(LPTSTR  Block);
typedef LDAPMEMFREE FAR *LPLDAPMEMFREE;

// ldap_err2string
typedef LPTSTR (__cdecl LDAPERR2STRING)(ULONG err);
typedef LDAPERR2STRING FAR *LPLDAPERR2STRING;

//ldap_create_page_control
typedef ULONG (__cdecl LDAPCREATEPAGECONTROL)(
                LDAP * pExternalHandle, 
                ULONG PageSize, 
                struct berval *Cookie, 
                UCHAR IsCritical, 
                PLDAPControlA *Control);
typedef LDAPCREATEPAGECONTROL FAR *LPLDAPCREATEPAGECONTROL;

//ldap_search_ext_s
typedef ULONG (__cdecl LDAPSEARCHEXT_S)(
                LDAP *ld,
                LPTSTR base,
                ULONG scope,
                LPTSTR filter,
                LPTSTR attrs[],
                ULONG attrsonly,
                PLDAPControlA *ServerControls,
                PLDAPControlA *ClientControls,
                struct l_timeval *timeout,
                ULONG SizeLimit,
                LDAPMessage **res);
typedef LDAPSEARCHEXT_S FAR * LPLDAPSEARCHEXT_S;

typedef ULONG (__cdecl LDAPSEARCHEXT)(
                LDAP *ld,
                LPTSTR base,
                ULONG scope,
                LPTSTR filter,
                LPTSTR attrs[],
                ULONG attrsonly,
                PLDAPControlA *ServerControls,
                PLDAPControlA *ClientControls,
                ULONG TimeLimit,
                ULONG SizeLimit,
                ULONG *MessageNumber);
typedef LDAPSEARCHEXT FAR * LPLDAPSEARCHEXT;

//ldap_parse_result
typedef ULONG (__cdecl LDAPPARSERESULT)(
                LDAP *Connection,
                LDAPMessage *ResultMessage,
                ULONG *ReturnCode OPTIONAL, 
                PWCHAR *MatchedDNs OPTIONAL, 
                PWCHAR *ErrorMessage OPTIONAL, 
                PWCHAR **Referrals OPTIONAL, 
                PLDAPControl **ServerControls OPTIONAL,
                BOOLEAN Freeit);
typedef LDAPPARSERESULT FAR *LPLDAPPARSERESULT;

//ldap_parse_page_control
typedef ULONG (__cdecl LDAPPARSEPAGECONTROL)(
                PLDAP ExternalHandle,
                PLDAPControlA *ServerControls,
                ULONG *TotalCount,
                struct berval **Cookie     // Use ber_bvfree to free
                );
typedef LDAPPARSEPAGECONTROL FAR * LPLDAPPARSEPAGECONTROL;

typedef ULONG (__cdecl LDAPCONTROLFREE)(
                LDAPControl *Control);
typedef LDAPCONTROLFREE FAR * LPLDAPCONTROLFREE;

typedef ULONG (__cdecl LDAPCONTROLSFREE)(
                LDAPControl **Control);
typedef LDAPCONTROLSFREE FAR * LPLDAPCONTROLSFREE;

 



// Public functions in ldapcont.c
BOOL InitLDAPClientLib(void);
ULONG DeinitLDAPClientLib(void);

HRESULT LDAPResolveName(LPADRBOOK lpAddrBook,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList,
  LPAMBIGUOUS_TABLES lpAmbiguousTables,
  ULONG ulFlags);

HRESULT LDAP_OpenMAILUSER(LPIAB lpIAB,
                          ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk);
BOOL    GetLDAPServerParams(LPTSTR lpszServer, LPLDAPSERVERPARAMS lspParams);
HRESULT SetLDAPServerParams(LPTSTR lpszServer, LPLDAPSERVERPARAMS lspParams);
void    FreeLDAPServerParams(LDAPSERVERPARAMS Params);
DWORD   GetLDAPNextServerID(DWORD dwSet);
BOOL    GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);
void UninitAccountManager(void);
HRESULT InitAccountManager(LPIAB lpIAB, IImnAccountManager2 ** lppAccountManager, GUID * pguidUser);
HRESULT AddToServerList(UNALIGNED LPSERVER_NAME * lppServerNames, LPTSTR szBuf, DWORD dwOrder);
HRESULT EnumerateLDAPtoServerList(IImnAccountManager2 * lpAccountManager,
  LPSERVER_NAME * lppServerNames, LPULONG lpcServers);

extern const LPTSTR szAllLDAPServersValueName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_profile.h ===
/*
 * _Profile.h - Stuff dealing with WAB Profile Handling
 *
 */


HRESULT HrGetWABProfiles(LPIAB lpIAB); 
void FreeWABFoldersList(LPIAB lpIAB);
BOOL bIsProfileMember(LPIAB lpIAB, LPSBinary lpsb, LPWABFOLDER lpWABFolder, LPWABUSERFOLDER lpUserFolder);
LPWABFOLDER FindWABFolder(LPIAB lpIAB, LPSBinary lpsb, LPTSTR lpName, LPTSTR lpProfileID);
void FreeProfileContainerInfo(LPIAB lpIAB);

#define FOLDER_UPDATE_NAME  0x00000001
#define FOLDER_UPDATE_SHARE 0x00000002
HRESULT HrUpdateFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, ULONG ulFlags, BOOL bShared, LPTSTR lpsz);

HRESULT HrAddRemoveFolderFromUserFolder(LPIAB lpIAB, LPWABFOLDER lpUserFolder, LPSBinary lpsbEID, LPTSTR lpName, BOOL bRefreshProfiles);
HRESULT HrCreateNewFolder(LPIAB lpIAB, LPTSTR lpName, LPTSTR lpProfileID, BOOL bUserFolder, LPWABFOLDER lpParentFolder, BOOL bShared, LPSBinary lpsbNew);


BOOL bDoesThisWABHaveAnyUsers(LPIAB lpIAB);
BOOL bIsThereACurrentUser(LPIAB lpIAB);
BOOL bAreWABAPIProfileAware(LPIAB lpIAB);
BOOL bIsWABSessionProfileAware(LPIAB lpIAB);


HRESULT HrGetUserProfileID(LPGUID lpUserGuid, LPTSTR szProfileID, ULONG cbProfileID);
HRESULT HrGetIdentityName(LPIAB lpIAB, LPTSTR lpID, LPTSTR szUserName);
HRESULT HrLogonAndGetCurrentUserProfile(HWND hWndParent, LPIAB lpIAB, BOOL bForceUI, BOOL bSwitchUser);
void UninitUserIdentityManager(LPIAB lpIAB);

#define DEFAULT_ID_HKEY         0x00000001
#define DEFAULT_ID_PROFILEID    0x00000002
#define DEFAULT_ID_NAME         0x00000004
HRESULT HrGetDefaultIdentityInfo(LPIAB lpIAB, ULONG ulFlags, HKEY * lphKey, LPTSTR lpProfileID, LPTSTR lpName);






/*--------------------------------------------------------------------------*/
/* Interface used for registering and issuing notification callbacks for identities */
#define WAB_IDENTITYCHANGENOTIFY_METHODS(IPURE)                         \
    MAPIMETHOD_(HRESULT, QuerySwitchIdentities)                         \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, SwitchIdentities)                              \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, IdentityInformationChanged)                    \
                (THIS_  DWORD dwType)                           IPURE;  
/*
#undef       INTERFACE
#define      INTERFACE  WAB_IdentityChangeNotify
DECLARE_MAPI_INTERFACE_(WAB_IdentityChangeNotify, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    WAB_IDENTITYCHANGENOTIFY_METHODS(PURE)
};

*/
#undef  INTERFACE
#define INTERFACE       struct _WAB_IDENTITYCHANGENOTIFY

#undef  METHOD_PREFIX
#define METHOD_PREFIX   WAB_IDENTITYCHANGENOTIFY_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, WAB_IDENTITYCHANGENOTIFY_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, WAB_IDENTITYCHANGENOTIFY_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WAB_IDENTITYCHANGENOTIFY_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
};

typedef struct _WAB_IDENTITYCHANGENOTIFY
{
    MAPIX_BASE_MEMBERS(WAB_IDENTITYCHANGENOTIFY)

    LPIAB lpIAB;
} WABIDENTITYCHANGENOTIFY, * LPWABIDENTITYCHANGENOTIFY;

HRESULT HrCreateIdentityChangeNotifyObject(LPIAB lpIAB, LPWABIDENTITYCHANGENOTIFY * lppWABIDCN);


HRESULT HrRegisterUnregisterForIDNotifications( LPIAB lpIAB, BOOL bRegister);

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_printex.h ===
/*-------------------------------------------------------------------

  _printEx.h

  
    HACK!


    We need to add support for NT5 PrintDlgEx function but turns out
    that the corresponding headers are included for WinVER = 0x0500 ..
    but since WAB is being built with 0x0400, we can't include the
    headers directly - so we have included a copy of the PrintDlgEx

    At some point of time we should remove this copy and just use
    commdlg.h
    
      Created: 9/25/98 - Vikramm
--------------------------------------------------------------------*/

#ifdef STDMETHOD

#if(WINVER < 0x0500)
/*

//-------------------------------------------------------------------------
//
//  IPrintDialogCallback Interface
//
//  IPrintDialogCallback::InitDone()
//    This function is called by PrintDlgEx when the system has finished
//    initializing the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::SelectionChange()
//    This function is called by PrintDlgEx when a selection change occurs
//    in the list view that displays the currently installed printers.
//    This function should return S_OK if it has processed the action or
//    S_FALSE to let PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::HandleMessage(hDlg, uMsg, wParam, lParam, pResult)
//    This function is called by PrintDlgEx when a message is sent to the
//    child window of the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IObjectWithSite::SetSite(punkSite)
//    IPrintDialogCallback usually paired with IObjectWithSite.
//    Provides the IUnknown pointer of the site to QI for the
//    IPrintDialogServices interface.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IPrintDialogCallback

DECLARE_INTERFACE_(IPrintDialogCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS) PURE;
    STDMETHOD(SelectionChange) (THIS) PURE;
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult) PURE;
};


*/

//
//  Page Range structure for PrintDlgEx.
//
typedef struct tagPRINTPAGERANGE {
   DWORD  nFromPage;
   DWORD  nToPage;
} PRINTPAGERANGE, *LPPRINTPAGERANGE;

#define START_PAGE_GENERAL             0xffffffff

//
//  PrintDlgEx structure.
//
typedef struct tagPDEXA {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCSTR                lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXA, *LPPRINTDLGEXA;
//
//  PrintDlgEx structure.
//
typedef struct tagPDEXW {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCWSTR               lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXW, *LPPRINTDLGEXW;
#ifdef UNICODE
typedef PRINTDLGEXW PRINTDLGEX;
typedef LPPRINTDLGEXW LPPRINTDLGEX;
#else
typedef PRINTDLGEXA PRINTDLGEX;
typedef LPPRINTDLGEXA LPPRINTDLGEX;
#endif // UNICODE

HRESULT  APIENTRY  PrintDlgExA(LPPRINTDLGEXA);
HRESULT  APIENTRY  PrintDlgExW(LPPRINTDLGEXW);
#ifdef UNICODE
#define PrintDlgEx  PrintDlgExW
#else
#define PrintDlgEx  PrintDlgExA
#endif // !UNICODE

/*--------------------------------------------------------------------------*/

DEFINE_GUID(IID_IPrintDialogCallback, 0x5852a2c3, 0x6530, 0x11d1, 0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);

/*--------------------------------------------------------------------------*/
#endif	// (WINVER < 0x0500)


#define WAB_PRINTDIALOGCALLBACK_METHODS(IPURE)                          \
    MAPIMETHOD_(HRESULT, InitDone)                                      \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, SelectionChange)                               \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, HandleMessage)                                 \
                (THIS_  HWND hDlg, UINT uMsg, WPARAM wParam,            \
                        LPARAM lParam, LRESULT *pResult)        IPURE;
#undef  INTERFACE
#define INTERFACE       struct _WAB_PRINTDIALOGCALLBACK

#undef  METHOD_PREFIX
#define METHOD_PREFIX   WAB_PRINTDIALOGCALLBACK_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, WAB_PRINTDIALOGCALLBACK_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, WAB_PRINTDIALOGCALLBACK_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WAB_PRINTDIALOGCALLBACK_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
};

typedef struct _WAB_PRINTDIALOGCALLBACK
{
    MAPIX_BASE_MEMBERS(WAB_PRINTDIALOGCALLBACK)

    LPIAB lpIAB;

    DWORD dwSelectedStyle; 

} WABPRINTDIALOGCALLBACK, * LPWABPRINTDIALOGCALLBACK;

HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_mapiu.h ===
/*
 *	_ M A P I U . H
 *	
 *	Non-public MACROs and FUNCTIONs which may be used by MAPI
 *
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *	Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */
#ifndef	_MAPIU_H
#define	_MAPIU_H

#ifdef __cplusplus
extern "C" {
#endif

extern CRITICAL_SECTION csUnkobjInit;


/* Macros provided by MAPIU
 */
#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(TCHAR))
#endif

//	Alignment

#define AlignN(n, x)		(((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define Align2(x)			AlignN(1,(x))
#define Align4(x)			AlignN(2,(x))
#define Align8(x)			AlignN(3,(x))

#if defined (_AMD64_) || defined (_IA64_)
#define	AlignNatural(cb)			Align8(cb)
#elif defined (WIN32)
#define	AlignNatural(cb)			Align4(cb)
#else // defined (WIN16)
#define	AlignNatural(cb)			Align2(cb)
#endif

#define FIsAligned(p)				(AlignNatural((ULONG_PTR)((LPVOID)p)) == (ULONG_PTR)((LPVOID)p))
#define FIsAlignedCb(cb)			(AlignNatural((ULONG_PTR)(cb)) == (ULONG_PTR)(cb))

/* Prototypes for private math functions
 */
STDAPI_(DWORD)
DwDivFtDw( FILETIME ftDividend, DWORD dwDivisor);

VOID
VSzFromIDS(ULONG ulIDS, UINT uncchBuffer, LPWSTR lpszBuffer, ULONG ulFlags);

/* Prototype for LoadString wrapper
 * Utility to allocate memory and loadstring and string IDS, ANSI/UNICODE.
 */

#define MAX_CCH_IDS		256
SCODE ScStringFromIDS( LPALLOCATEBUFFER lpMapiAllocBuffer, ULONG ulFlags, UINT ids,
		LPTSTR * lppszIDS );

/* Prototypes for Message and Dialog Box utilities.
 */
SCODE
ScMessageBoxIDS( ULONG	ulUIParam,
				 UINT	idsCaption,
				 UINT	idsMessage,
				 UINT	uMBType);

/* Prototypes for MAPI status utilities.
 */
BOOL
FProfileLoggedOn( LPSTR	szProfileName);

/* Prototypes for functions used to validate complex parameters.
 */

#ifndef __cplusplus
#define	FBadIfacePtr(param, iface)					\
		(	IsBadReadPtr((param), sizeof(iface)) 	\
		 ||	IsBadReadPtr((param)->lpVtbl, sizeof(iface##Vtbl)))
#else
#define FBadIfacePtr(param, iface)	(FALSE)
#endif

/*
 *	FBadDelPTA
 *
 *	Returns TRUE if the given Prop Tag Array is readable and contains only
 *	prop tags which are valid for a DeleteProps (or related) call.
 */
STDAPI_(BOOL)
FBadDelPTA(LPSPropTagArray lpPropTagArray);


#ifndef WIN16 // WIN16 C compiler doesn't support INLINE functions.
/*
 *	IListedPropID
 *
 *  Purpose
 *		If a tag with ID == PROP_ID(ulPropTag) is listed in lptaga then
 *		the index of tag is returned.  If the tag is not in lptaga then
 *		-1 is returned.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline LONG_PTR
IListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return -1;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return (lpulPTag - lptaga->aulPropTag);
		}
	}

	return -1;
}

/*
 *	FListedPropID
 *
 *  Purpose
 *		Determine if a tag with ID == PROP_ID(ulPropTag) is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline BOOL
FListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}

/*
 *	FListedPropTAG
 *
 *  Purpose
 *		Determine if a the given ulPropTag is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline BOOL
FListedPropTAG( ULONG			ulPropTag,
				LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Compare the entire prop tag to be sure both ID and TYPE match
	 */
	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	AddProblem
 *
 *  Purpose
 *		Adds a problem to the next available entry of a pre-allocated problem
 *		array.
 *		The pre-allocated problem array must be big enough to have another
 *		problem added.  The caller is responsible for making sure this is
 *		true.
 *
 *	Arguments
 *		lpProblems	Pointer to pre-allocated probelem array.
 *		ulIndex		Index into prop tag/value array of the problem property.
 *		ulPropTag	Prop tag of property which had the problem.
 *		scode		Error code to list for the property.
 *
 *	Returns		TRUE or FALSE
 */
_inline VOID
AddProblem( LPSPropProblemArray	lpProblems,
			ULONG				ulIndex,
			ULONG				ulPropTag,
			SCODE				scode)
{
	if (lpProblems)
	{
		Assert( !IsBadWritePtr( lpProblems->aProblem + lpProblems->cProblem
			  , sizeof(SPropProblem)));
		lpProblems->aProblem[lpProblems->cProblem].ulIndex = ulIndex;
		lpProblems->aProblem[lpProblems->cProblem].ulPropTag = ulPropTag;
		lpProblems->aProblem[lpProblems->cProblem].scode = scode;
		lpProblems->cProblem++;
	}
}

__inline BOOL
FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude)
{
	/* Check the obvious (no exclusions).
	 */
	if (!ciidExclude || !rgiidExclude)
	{
		return FALSE;
	}

	/* Check each iid in the list of exclusions.
	 */
	for (; ciidExclude; rgiidExclude++, ciidExclude--)
	{
//		if (IsEqualGUID( lpiidToCheck, rgiidExclude))
		if (!memcmp( lpiidToCheck, rgiidExclude, sizeof(MAPIUID)))
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	Error/Warning Alert Message Boxes
 */
int			AlertIdsCtx( HWND hwnd,
						 HINSTANCE hinst,
						 UINT idsMsg,
						 LPSTR szComponent,
						 ULONG ulContext,
						 ULONG ulLow,
						 UINT fuStyle);

__inline int
AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle)
{
	return AlertIdsCtx(hwnd, hinst, idsMsg, NULL, 0, 0, fuStyle);
}

int			AlertSzCtx( HWND hwnd,
						LPSTR szMsg,
						LPSTR szComponent,
						ULONG ulContext,
						ULONG ulLow,
						UINT fuStyle);

__inline int
AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle)
{
	return AlertSzCtx(hwnd, szMsg, NULL, 0, 0, fuStyle);
}
#else  // !WIN16
LONG IListedPropID( ULONG ulPropTag, LPSPropTagArray lptaga);
BOOL FListedPropID( ULONG ulPropTag, LPSPropTagArray lptaga);
BOOL FListedPropTAG( ULONG ulPropTag, LPSPropTagArray lptaga);
VOID AddProblem( LPSPropProblemArray lpProblems, ULONG ulIndex, ULONG ulPropTag, SCODE scode);
BOOL FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude);
int AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle);
int AlertSzCtx( HWND hwnd, LPSTR szMsg, LPSTR szComponent, ULONG ulContext, ULONG ulLow, UINT fuStyle);
int AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle);
#endif // !WIN16




/*  Encoding and decoding strings */
STDAPI_(void)			EncodeID(LPBYTE lpb, ULONG cb, LPTSTR lpsz);
STDAPI_(BOOL)			FDecodeID(LPTSTR lpsz, LPBYTE lpb, ULONG FAR *lpcb);
STDAPI_(ULONG)			CchOfEncoding(ULONG cb);
STDAPI_(ULONG)			CbOfEncoded(LPTSTR lpsz);
STDAPI_(int)			CchEncodedLine(int cb);


/*  Idle engine routines */

#ifdef	DEBUG

/*
 *	DumpIdleTable
 *
 *		Used for debugging only.  Writes information in the PGD(hftgIdle)
 *		table to COM1.
 */

STDAPI_(void)
DumpIdleTable (void);

#endif
/*
 *	FDoNextIdleTask
 *
 *		Dispatches the first eligible idle function, according to
 *		its simple scheduling algorithm.
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *lpv1, const void FAR *lpv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

FNSGNCMP				SgnCmpPadrentryByType;

BOOL FRKFindSubpb(LPBYTE pbTarget, ULONG cbTarget, LPBYTE pbPattern, ULONG cbPattern);
BOOL FRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);
LPSTR LpszRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);

STDAPI_(void)			ShellSort(LPVOID lpv, UINT cv,			/* qsort */
						LPVOID lpvT, UINT cb, PFNSGNCMP fpCmp);


/*  Advise list maintainence utilities  */
/*
 *	Structure and functions for maintaining a list of advise sinks,
 *	together with the keys used to release them.
 */

typedef struct
{
	LPMAPIADVISESINK	lpAdvise;
	ULONG				ulConnection;
	ULONG				ulType;
	LPUNKNOWN			lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
	ULONG				cItemsMac;
	ULONG				cItemsMax;
	#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION FAR * lpcs;
	#endif
	ADVISEITEM			rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
	(offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
	(offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))

STDAPI_(SCODE)
ScAddAdviseList(	LPVOID lpvReserved,
					LPADVISELIST FAR *lppList,
					LPMAPIADVISESINK lpAdvise,
					ULONG ulConnection,
					ULONG ulType,
					LPUNKNOWN lpParent);

STDAPI_(SCODE)
ScDelAdviseList(	LPADVISELIST lpList,
					ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(	LPADVISELIST lpList,
					ULONG ulConnection,
					LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(	LPADVISELIST FAR *lppList);

// prototype for routine that detects whether calling apps is
// an interactive EXE or a service.

#if defined( _WINNT )
BOOL WINAPI IsServiceAnExe( VOID );
#endif

// prototype for internal routine that computes the size required
// to hold a given propval array based on specified alignment

SCODE ScCountPropsEx( int cprop,
                      LPSPropValue rgprop,
                      ULONG ulAlign,
                      ULONG FAR *pcb );

/*  Option data handling routines */
#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

#endif	/* MAPISPI_H */


#ifdef __cplusplus
}
#endif


#endif	// _MAPIU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_vcard.h ===
/*
 *	_VCard.H - VCard definitions
 *
 *
 *	
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *	
 */
#define VCARD   TRUE        // comment out to disable vCard support

#ifdef VCARD
typedef ULONG (VCARD_READ)(HANDLE hVCard, LPVOID lpBuffer, ULONG uBytes, LPULONG ulBytesRead);
typedef VCARD_READ FAR *LPVCARD_READ;

typedef ULONG (VCARD_WRITE)(HANDLE hVCard, LPVOID lpBuffer, ULONG uBytes, LPULONG ulBytesWritten);
typedef VCARD_WRITE FAR *LPVCARD_WRITE;

HRESULT FileReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead);
HRESULT BufferReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead);
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten);
HRESULT ReadVCard(HANDLE hVCard, VCARD_READ ReadFn, LPMAILUSER lpMailUser);
HRESULT WriteVCard(HANDLE hVCard, VCARD_WRITE WriteFn, LPMAILUSER lpMailUser);

BOOL VCardGetBuffer(LPTSTR lpszFileName, LPSTR lpszBuf, LPSTR * lppBuf);
BOOL VCardGetNextBuffer(LPSTR lpBuf, LPSTR * lppVCard, LPSTR * lppNext);

#define WAB_W_END_OF_DATA           (MAKE_MAPI_S(0x1001))
#define WAB_E_VCARD_NOT_ASCII       (MAKE_MAPI_E(0x1002))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_wabobj.h ===
//
// _WABOBJ.H
//
// Internal interface for IWABOBJECT
//
//

#include <mpswab.h>

//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _IWOINT

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	IWOINT_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IWOINT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IWOINT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWOINT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IWABOBJECT_METHODS(IMPL)
};


#ifdef OLD_STUFF
/* Generic part of property linked lists.
 */
typedef struct _lstlnk {
	struct _lstlnk FAR *	lpNext;
	ULONG					ulKey;
} LSTLNK, FAR * LPLSTLNK;

typedef LPLSTLNK FAR * LPPLSTLNK;


/* Linked list of property values.
 */
typedef struct _lstspv {
	LSTLNK			lstlnk;
	LPSPropValue	lpPropVal;
	ULONG			ulAccess;
} LSTSPV, FAR * LPLSTSPV;
#define CBLSTSPV sizeof(LSTSPV)

/* Linked list of property ID to NAME mappings.
 */
typedef struct _lstspn {
	LSTLNK			lstlnk;
	LPMAPINAMEID	lpPropName;
} LSTSPN, FAR * LPLSTSPN;
#endif


typedef struct _IWOINT {
	IWOINT_Vtbl FAR *	lpVtbl;

	// Generic IMAPIUnknown portion
	UNKOBJ_MEMBERS;
	UNKINST		inst;

	//
	//  Says whether or not this object (as a whole) is modifiable
	//
	ULONG		ulObjAccess;

    //
    // Structure which stores a handle and a refcount of the open property store
    //
    LPPROPERTY_STORE lpPropertyStore;

    // Stores a handle to the outlook-wab library module
    LPOUTLOOK_STORE lpOutlookStore;

    // Boolean set if this object created inside and Outlook session, i.e., the
    // WAB is set to use the Outlook MAPI allocators.
    BOOL bSetOLKAllocators;

} IWOINT, *LPIWOINT;	

#define CBIWOINT sizeof(IWOINT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_runt.h ===
/*
 *	_RUNT.H
 *	
 *	DLL central for the MAPI utilities.
 */

#ifndef _RUNT_H_
#define _RUNT_H_

#ifdef	__cplusplus
extern "C" {
#endif

// Per-process instance data for utilities functions

DeclareInstList(lpInstUtil);

#define INSTUTIL_SIG_BEG		0x54534E49	// 'INST'
#define INSTUTIL_SIG_END		0x4C495455	// 'UTIL'

typedef struct
{
#ifdef WIN16
	DWORD		dwBeg;			// INSTUTIL_SIG_BEG
	WORD		wSS;			// Stack segment of current task
	HTASK		hTask;			// HTASK of current task
#endif

	UINT		cRef;

								// General stuff
	HLH			hlhClient;		// Heap for allocations

								// Idle engine stuff
	ULONG		cRefIdle;	  	/* reference count */
	LPMALLOC	lpMalloc;	  	/* memory allocator */
	HINSTANCE	hInst;			/* */
	HWND		hwnd;		  	/* handle of hidden window */
	int			iftgMax;	  	/* size of idle routine registry */
	int			iftgMac;	  	/* number of registered idle routines */
#if !(defined(WIN32) && !defined(MAC))
	UINT		uiWakeupTimer; 	/* Timer to wake up & run idle routines */
#endif

#ifdef OLD_STUFF
	PFTG		pftgIdleTable;	/* ptr to table of registered routines */
#endif
	int			iftgCur;	  	/* Index in pftgIdleTable of currently */
								/* running ftgCur routine or recently run */
	USHORT		schCurrent;		/* current idle routine state from last */
								/* FDoNextIdleTask() call */
	BOOL		fIdleExit;		/* flag set TRUE if idle routines are */
								/* being called from IdleExit */

#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION	cs;		/* gate to keep multiple threads from */
								/* accessing global data at the same time */
	BOOL		fSignalled;		/* Only do this when we need to */
	HANDLE		hTimerReset;	/* Used to signal timer reset */
	HANDLE		hTimerThread;	/* Timer thread handle */
	DWORD		dwTimerThread;	/* Timer thread ID */
	DWORD		dwTimerTimeout;	/* Current timeout value */
	BOOL		fExit;			/* if TRUE, timer thread should exit */
#endif

#ifdef WIN16
	LPVOID		pvBeg;			// Pointer back to beginning of pinst
	DWORD		dwEnd;			// INSTUTIL_SIG_END
#endif

} INSTUTIL, FAR *LPINSTUTIL;




#define MAPIMDB_VERSION	((BYTE) 0x00)
#define MAPIMDB_NORMAL	((BYTE) 0x00)	// Normal wrapped store EntryID
#define MAPIMDB_SECTION	((BYTE) 0x01)	// Known section, but no EntryID

#define MUIDSTOREWRAP {		\
	0x38, 0xa1, 0xbb, 0x10,	\
	0x05, 0xe5, 0x10, 0x1a,	\
	0xa1, 0xbb, 0x08, 0x00,	\
	0x2b, 0x2a, 0x56, 0xc2 }

typedef struct _MAPIMDBEID {
	BYTE	abFlags[4];
	MAPIUID	mapiuid;
	BYTE	bVersion;
	BYTE	bFlagInt;
	BYTE	bData[MAPI_DIM];
} MAPIMDB_ENTRYID, *LPMAPIMDB_ENTRYID;

#define CbNewMAPIMDB_ENTRYID(_cb)	\
	(offsetof(MAPIMDB_ENTRYID,bData) + (_cb))
#define CbMAPIMDB_ENTRYID(_cb)		\
	(offsetof(MAPIMDB_ENTRYID,bData) + (_cb))
#define SizedMAPIMDB_ENTRYID(_cb, _name) \
	struct _MAPIMDB_ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	MAPIUID	mapiuid;	\
	BYTE	bVersion;	\
	BYTE	bFlagInt;	\
	BYTE	bData[_cb];	\
} _name

// This macro computes the length of the MAPI header on a store entryid.
// The provider-specific data starts on a 4-byte boundary following the
// DLL Name. The cb parameter is the length of the DLL name in bytes (counting
// the NULL terminator).
#define CB_MDB_EID_HEADER(cb)	((CbNewMAPIMDB_ENTRYID(cb) + 3) & ~3)

// Internal function that gets a new UID
STDAPI_(SCODE)			ScGenerateMuid(LPMAPIUID lpMuid);



// Internal function that gets the utilities heap
HLH						HlhUtilities(VOID);

// Critical section for serializing heap access
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csHeap;
#endif
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csMapiInit;
#endif
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csMapiSearchPath;
#endif


// Access the DLL instance handle

LRESULT STDAPICALLTYPE
DrainFilteredNotifQueue(BOOL fSync, ULONG ibParms, LPNOTIFKEY pskeyFilter);


//$ used by ITable
LPADVISELIST lpAdviseList;
LPNOTIFKEY lpNotifKey;
LPMAPIADVISESINK lpMAPIAdviseSink;
LPNOTIFICATION lpNotification;


STDMETHODIMP			HrSubscribe(LPADVISELIST FAR *lppAdviseList, LPNOTIFKEY lpKey,
						ULONG ulEventMask, LPMAPIADVISESINK lpAdvise, ULONG ulFlags,
						ULONG FAR *lpulConnection);
STDMETHODIMP			HrUnsubscribe(LPADVISELIST FAR *lppAdviseList, ULONG ulConnection);
STDMETHODIMP			HrNotify(LPNOTIFKEY lpKey, ULONG cNotification,
						LPNOTIFICATION lpNotifications, ULONG * lpulFlags);

#ifndef PSTRCVR
#endif //PSTRCVR



//$	END

#ifdef	__cplusplus
}
#endif

#endif	//	_RUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_wabapi.h ===
/***********************************************************************
 *
 * _WABAPI.H
 *
 * Internal headers for the WABAPI
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 04.16.96     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifndef ___WABAPI_H
#define ___WABAPI_H

typedef struct _PROPERTY_STORE {
    HANDLE hPropertyStore;
    ULONG ulRefCount;
    BOOL bProfileAPIs;
    BOOL bIsWABOpenExSession; // Bug - Outlook passes IADRBook.c to multiple threads without all the threads calling
                              // WABOpenEx - as a result secondary threads dont know its an outlook session and
                              // try to access the .WAB which crashes badly. This flag is a hack way to pass the
                              // info between the two threads
	struct _OlkContInfo *rgolkci; // Outlook container info
	ULONG colkci;
    // information for WAB containers...
} PROPERTY_STORE, *LPPROPERTY_STORE;

typedef struct _OUTLOOK_STORE {
    HMODULE hOutlookStore;
    ULONG ulRefCount;
} OUTLOOK_STORE, *LPOUTLOOK_STORE;

ULONG ReleasePropertyStore(LPPROPERTY_STORE lpPropertyStore);
SCODE OpenAddRefPropertyStore(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore);

ULONG ReleaseOutlookStore(HANDLE hPropertyStore, LPOUTLOOK_STORE lpOutlookStore);
SCODE OpenAddRefOutlookStore(LPOUTLOOK_STORE lpOutlookStore);

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_wrap.h ===
//	Keep the base members common across all the MAPIX objects such that
//	code reuse is leveraged.  AddRef(), Release() and GetLastError() assume
//	that the BASE members are the first set of members in the object
//
#define MAPIX_BASE_MEMBERS(_type)												\
	_type##_Vtbl *		lpVtbl;				/* object method table	*/			\
																				\
	ULONG				cIID;				/* count of interfaces supported */	\
	LPIID *				rglpIID;			/* array of &interfaces supported */\
	ULONG				lcInit;				/* refcount */						\
	CRITICAL_SECTION	cs;					/* critical section memory */		\
																				\
	HRESULT				hLastError;			/* for MAPI_GetLastError */			\
	UINT				idsLastError;		/* for MAPI_GetLastError */			\
	LPTSTR				lpszComponent;		/* for MAPI_GetLastError */			\
	ULONG				ulContext;			/* for MAPI_GetLastError */			\
	ULONG				ulLowLevelError;	/* for MAPI_GetLastError */			\
	ULONG				ulErrorFlags;		/* for MAPI_GetLastError */			\
	LPMAPIERROR			lpMAPIError;		/* for MAPI_GetLastError */			\


//
//  Function prototypes
//
//  Those not mentioned use IAB_methods


#undef	INTERFACE
#define INTERFACE	struct _WRAP

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WRAP_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _WRAP {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;

} WRAP, *LPWRAP;
#define CBWRAP sizeof(WRAP)





//
//  One-Off from object from an entryid
//
typedef struct _OOP {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;
	ULONG fUnicodeEID;
	
} OOP, *LPOOP;
#define CBOOP sizeof(OOP)

//
//  Entry point to create a new OOP MAPIProp object from a OO entryid
//

HRESULT NewOOP ( LPENTRYID lpEntryID,
				 ULONG cbEntryID,
				 LPCIID lpInterface,
				 ULONG ulOpenFlags,
				 LPVOID lpIAB,
				 ULONG *lpulObjType,
				 LPVOID *lppOOP,
				 UINT *lpidsError );


HRESULT NewOOPUI ( LPENTRYID lpEntryID,
				 ULONG cbEntryID,
				 LPCIID lpInterface,
				 ULONG ulOpenFlags,
				 LPIAB lpIAB,
				 ULONG *lpulObjType,
				 LPVOID *lppOOP,
				 UINT *lpidsError );


//
//  Entry point to programmatically create a new OO entry from a
//  foreign template...
//
//  The end result is a OO entryid (no attatched details, yet...)
//
typedef struct _OOE {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;
	ULONG fUnicodeEID;

	//
	//  New stuff
	//
	LPMAPIPROP lpPropTID;
	
} OOE, *LPOOE;
#define CBOOE sizeof(OOE)

HRESULT HrCreateNewOOEntry(	LPVOID lpROOT,
							ULONG cbEntryID,
							LPENTRYID lpEntryID,
							ULONG ulCreateFlags,
							LPMAPIPROP FAR * lppMAPIPropEntry );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\btnbar.c ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     BtnBar.cpp
//
//  PURPOSE:    Implements a generic button bar.
//

#include "_apipch.h"

#define idtTrack 101
#define idcFolderList 102
#define HOTTRACK_TIMER 100
#define ID_HWNDBAR 2020

extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;

//#define DEAD

void CBB_ConfigureRects(HWND hwnd);
void CBB_DoHotTracking(HWND hwnd);
void CBB_EndHotTracking(HWND hwnd);
int CBB_HitTest(int x, int y);
void CBB_SetSelBtn(int iSel,HWND hwnd);


//
//  FUNCTION:   CButtonBar::~CButtonBar()
//
//  PURPOSE:    Cleans up the resources we allocated during the life of the
//              object.
//
void CBB_Cleanup(void)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Free the GDI resources.
    ImageList_Destroy(m_himlButtons);
    DeleteObject(m_hpalBkgnd);
    DeleteObject(m_hfButton);
    DeleteObject(m_hbmpBkgnd);

    // Free the button array.
    LocalFreeAndNull((LPVOID *)&m_rgButtons);

    // NOTE - this is a comment from the original athena source code
    //$REVIEW - we can't do this here, because it screws up
    //          when we have multiple instances of the CButtonBar
    //          with overlapping creates and destroys.  we should
    //          probably unregister somewhere, but it isn't strictly
    //          necessary. (EricAn)
    // Unregister our window class.
    // UnregisterClass(c_szButtonBar, m_hInstance);

    return;
}


//
//  FUNCTION:   CButtonBar::Create()
//
//  PURPOSE:    Initializes the button bar and creates the button bar window.
//
//  PARAMETERS:
//      hwndParent - Handle of the window that will be the button bar parent.
//      idHwnd     - Child window ID for the button bar.
//      idButtons  - ID of the button icons bitmap.
//      idHorzBackground - ID of the horizontal background bitmap.
//      idVertBackground - ID of the vertical background bitmap.
//      pBtnCreateParams - Pointer to the array of BTNCREATEPARAMS used to create the buttons.
//      cParams    - Number of buttons in pBtnCreateParams.
//      uSide      - Side of the parent window the bar should initially attach to.
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//
HWND CBB_Create(HWND hwndParent, UINT idButtons,
                        UINT idHorzBackground,
                        PBTNCREATEPARAMS pBtnCreateParams, UINT cParams)
    {

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    int i;
    WNDCLASS wc;
    BITMAP bm;
    RECT rc;
    POINT ptL, ptR;
    ICONMETRICS im;
    HWND hwnd = NULL;


    wc.style         = CS_DBLCLKS;              // Bug #15450
    wc.lpfnWndProc   = CBB_ButtonBarProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = hinstMapiX;
    wc.hIcon         = 0;
    wc.hCursor       = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName  = 0;
    wc.lpszClassName = c_szButtonBar;

    RegisterClass(&wc);

    m_rgButtons = NULL;
    m_himlButtons = 0;
    m_hbmpBkgnd = 0;
    m_hpalBkgnd = 0;
    m_hfButton = 0;
    m_cButtons = 0;
    m_iSelect = -1;
    m_iOldSelect = -1;

    // This is the information we'll need later to to draw the button bar etc.
    // Stash it away for now.
    m_cButtons = cParams;

    m_rgButtons = LocalAlloc(LMEM_ZEROINIT, sizeof(BUTTON) * m_cButtons);
    if (!m_rgButtons) return FALSE;

    for (i = 0; i < m_cButtons; i++)
        {
        m_rgButtons[i].id = pBtnCreateParams[i].id;
        m_rgButtons[i].iIcon = pBtnCreateParams[i].iIcon;

        LoadString(hinstMapiX, pBtnCreateParams[i].idsLabel,
                   m_rgButtons[i].szTitle, sizeof(m_rgButtons[i].szTitle));
        }

    // Load the bitmaps we'll need for drawing.
    m_himlButtons = gpfnImageList_LoadImage(hinstMapiX, MAKEINTRESOURCE(idButtons),
                                        c_cxButtons, 0, c_crMask, IMAGE_BITMAP,
                                        0); //LR_LOADMAP3DCOLORS);
    if (!m_himlButtons)
        return (FALSE);

    // Get the width of the bitmap we're going to use as the background so we
    // know how wide to make the window.
    if (!LoadBitmapAndPalette(idHorzBackground, &m_hbmpBkgnd, &m_hpalBkgnd))
        return (FALSE);

    if (!GetObject(m_hbmpBkgnd, sizeof(BITMAP), (LPVOID) &bm))
        return (FALSE);

    GetClientRect(hwndParent, &rc);

    // Get the font we're going to use for the buttons
    im.cbSize = sizeof(ICONMETRICS);
    SystemParametersInfo(SPI_GETICONMETRICS, 0, (LPVOID) &im, 0);
    m_hfButton = CreateFontIndirect(&(im.lfFont));
    if (!m_hfButton)
        return (FALSE);

    ptL.x = ptL.y=0;
    ptR.x = rc.right;
    ptR.y = bm.bmHeight;

    hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
                        c_szButtonBar,
                        c_szButtonBar,
                        WS_CLIPSIBLINGS |
                        WS_VISIBLE |
                        WS_CHILD,
                        ptL.x,
                        ptL.y,
                        ptR.x,
                        ptR.y,
                        hwndParent,
                        (HMENU) ID_HWNDBAR,
                        hinstMapiX,
                        NULL);

    CBB_ConfigureRects(hwnd);

    return (hwnd);
    }


//
//  FUNCTION:   CButtonBar::ButtonBarProc()
//
//  PURPOSE:    Message handler for the button bar window.
//
LRESULT CALLBACK CBB_ButtonBarProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                           LPARAM lParam)
    {

    switch (uMsg)
        {
        case WM_NCCREATE:
            SetWindowLong(hwnd, 0, (LONG) ((LPCREATESTRUCT) lParam)->lpCreateParams);
            return (TRUE);
/***
        case WM_CREATE:
            return 0;
            break;

        case WM_SIZE:
            return 0;
            break;

        case WM_LBUTTONDOWN:
            return 0;
            break;

        case WM_COMMAND:
            return 0;
            break;

/***/
        case WM_PAINT:
            CBB_OnPaint(hwnd);
            return 0;
            break;

        case WM_MOUSEMOVE:
            CBB_OnMouseMove(hwnd, LOWORD(lParam), HIWORD(lParam), wParam);
            return 0;
            break;

        case WM_LBUTTONUP:
            CBB_OnLButtonUp(hwnd, LOWORD(lParam), HIWORD(lParam), wParam);
            return 0;
            break;

        case WM_TIMER:
            CBB_OnTimer(hwnd, wParam);
            return 0;
            break;

        case WM_MOUSEACTIVATE:
            CBB_OnMouseActivate(hwnd, (HWND) wParam, (INT) LOWORD(lParam), (UINT) HIWORD(lParam));
            return 0;
            break;

        case WM_PALETTECHANGED:
            if ((HWND) wParam != hwnd)
                {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                HDC hdc = GetDC(hwnd);
                HPALETTE hPalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
                RealizePalette(hdc);
                InvalidateRect(hwnd, NULL, TRUE);
                SelectPalette(hdc, hPalOld, TRUE);
                ReleaseDC(hwnd, hdc);
                }
            return 0;
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


void CBB_OnPaint(HWND hwnd)
    {
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    HDC hdc;
    PAINTSTRUCT ps;
    BITMAP bm;
    HDC hdcMem;
    HBITMAP hbmMemOld, hbmMem;
    HPALETTE hpalOld;
    RECT rc;
    HFONT hf;
    COLORREF clrText, clrBk;

    int cxIndent = 3;
    int cyIndent = 3;
    int nTop = 0;
    int nLeft = 0;
    int nButton = 0;
    int i=0;

    if(!hwnd) goto out;

    // Get the size of the background bitmap
    GetObject(m_hbmpBkgnd, sizeof(BITMAP), (LPVOID) &bm);
    GetClientRect(hwnd, &rc);

    hdc = BeginPaint(hwnd, &ps);
    hdcMem = CreateCompatibleDC(hdc);

    // If we are displaying the buttons ...
        {
        // Draw the background bitmaps first.
        hpalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
        RealizePalette(hdc);

        hbmMemOld = (HBITMAP) SelectObject(hdcMem, (HGDIOBJ) m_hbmpBkgnd);

        // If the window is taller or wider than a single bitmap, we may have
        // to loop and put a couple out there.
            while (nLeft < rc.right)
                {
                BitBlt(hdc, nLeft, nTop, bm.bmWidth, bm.bmHeight, hdcMem, 0,
                       0, SRCCOPY);
                nLeft += bm.bmWidth;
                }

        // Now draw the buttons
        nTop = 0;

        hf = (HFONT) SelectObject(hdc, m_hfButton);
        SetBkMode(hdc, TRANSPARENT);

        while (nButton < m_cButtons)
            {
            if (RectVisible(hdc, &(m_rgButtons[nButton].rcBound)))
                {
                ImageList_Draw(m_himlButtons, m_rgButtons[nButton].iIcon, hdc,
                               m_rgButtons[nButton].rcIcon.left, m_rgButtons[nButton].rcIcon.top,
                               ILD_TRANSPARENT);

                // Draw the title of the button that the mouse is over with a
                // different color.
                if (nButton == m_iSelect)
                {
                    clrBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                }
                else
                {
                    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
                    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
                }

                SetTextAlign(hdc, TA_TOP /* | TA_CENTER */);


                if (nButton == m_iSelect)
                {
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    ExtTextOut( hdc,
                                (m_rgButtons[nButton].rcTitle.right - m_rgButtons[nButton].rcTitle.left) / 2 + m_rgButtons[nButton].rcTitle.left,
                                m_rgButtons[nButton].rcTitle.top,
                                ETO_OPAQUE | ETO_CLIPPED,
                                &(m_rgButtons[nButton].rcTitle),
                                m_rgButtons[nButton].szTitle,
                                lstrlen(m_rgButtons[nButton].szTitle),
                                NULL);
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    DrawText(hdc, m_rgButtons[nButton].szTitle, lstrlen(m_rgButtons[nButton].szTitle),
                             &m_rgButtons[nButton].rcTitle, DT_CENTER | DT_WORDBREAK);
                }
                else
                {
                    DrawText(hdc, m_rgButtons[nButton].szTitle, lstrlen(m_rgButtons[nButton].szTitle),
                             &m_rgButtons[nButton].rcTitle, DT_CENTER | DT_WORDBREAK);
                }

                if (nButton == m_iSelect)
                    {
                    SetBkColor(hdc,clrBk);
                    SetTextColor(hdc, clrText);
                    }
                }
            nButton++;
            }

        SelectObject(hdc, m_hfButton);

        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        SelectObject(hdcMem, hbmMemOld);
        }

    DeleteObject(hbmMem);
    DeleteDC(hdcMem);
    EndPaint(hwnd, &ps);

out:
    return;
    }



//
//  FUNCTION:   CButtonBar::OnLButtonUp()
//
//  PURPOSE:    If we are dragging the button bar around, then the user has
//              released the bar and we can clean up.  If the user wasn't
//              dragging, then they have clicked on a button and we send the
//              appropriate command message to the parent window.
//
void CBB_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    int iSel = 0;

    if (-1 != (iSel = CBB_HitTest(x, y)))
    {
        // Move command handling from LButtonUp to LButtonDown to avoid
        // duplicate messages being sent from double clicks - Nash Bug #15450
        if (0 <= iSel)
        {
            SendMessage(GetParent(hwnd), WM_COMMAND, m_rgButtons[iSel].id, (LPARAM) hwnd);
            CBB_SetSelBtn(-1,hwnd);
        }
    }

    return;
}


//
//  FUNCTION:   CButtonBar::OnMouseMove()
//
//  PURPOSE:    If the user is dragging the bar around, we need to determine
//              which side of the parent window the mouse is closest to and
//              move the button bar to that edge.
//
//              If the user is not dragging, then we need to decide if the
//              mouse is over a button and if so highlight the text.
//
void CBB_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
    int iSel;
    POINT ptScreen = {x, y};


    // If we're not dragging the bar around, the just update the button
    // selection.
    iSel = CBB_HitTest(x, y);
    CBB_SetSelBtn(iSel,hwnd);
    if (iSel != -1)
        SetCursor(LoadCursor(hinstMapiX, MAKEINTRESOURCE(idcurPointedHand)));
    else
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    CBB_DoHotTracking(hwnd);
    return;
   }




int CBB_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
    {
        return (MA_ACTIVATE);
    }



//
//  FUNCTION:   CButtonBar::ConfigureRects()
//
//  PURPOSE:    Calculates the rectangles that are necessary for displaying
//              the button bar based on the side of the parent window the
//              bar is currently attached to.
//
void CBB_ConfigureRects(HWND hwnd)
    {
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Need to gather some font information first.  We need the height of the
    // folder title font all the time and we need the width of the longest
    // button title if we're displayed horizontally.

    HDC        hdc;
    int        i;
    int        cxMaxTitle;
    SIZE       sizeString;
    SIZE       sizeRect;
    int cyIconTitle;
    int cxCenter;
    int cyCenter;
    TEXTMETRIC tmTitle;

    hdc = GetDC(hwnd);

    SelectObject(hdc, m_hfButton);
    GetTextMetrics(hdc, &tmTitle);

    // Button text width
        cxMaxTitle = 0;
        for (i = 0; i < m_cButtons; i++)
            {
            GetTextExtentPoint32(hdc, m_rgButtons[i].szTitle,
                                 lstrlen(m_rgButtons[i].szTitle),
                                 &sizeString);
            if (sizeString.cx > cxMaxTitle)
                cxMaxTitle = sizeString.cx;
            }

        // Add a little buffer here just to make it look nice.
        cxMaxTitle += 10;

    ReleaseDC(hwnd, hdc);

    // Now calculate the button rectangles.  Each button will have three rects
    // associated with it.  The first rectangle is the overall bounding rect
    // which contains the image and title.  The next rectangle is the rect for
    // the image which is centered horizontally within the bounding rect and
    // vertically when combined with the title.  The final rect is the title.

    // Calculate the initial bounding rectangle based on whether or not we're
    // horizontal or vertical.  sizeRect is the dimensions of each button's
    // bounding rectangle.

        {
        RECT rcBound,rcWnd;
        int cyButton=0,cxButton=0;

        ImageList_GetIconSize(m_himlButtons, &cxButton, &cyButton);

        GetClientRect(hwnd,&rcWnd);
        sizeRect.cx = cxMaxTitle;
        sizeRect.cy = rcWnd.bottom - rcWnd.top;
        SetRect(&rcBound, 0, 0, sizeRect.cx, sizeRect.cy);

        // Also calculate the offsets needed to center the image and text within
        // the bound.
        cyIconTitle = tmTitle.tmHeight + cyButton;
        cxCenter = ((rcBound.right - rcBound.left) - cxButton) / 2;
        cyCenter = ((rcBound.bottom - rcBound.top) - cyIconTitle) / 2;

        // Now loop through all the buttons
        for (i = 0; i < m_cButtons; i++)
            {
            m_rgButtons[i].rcBound = rcBound;

            // Center the image horizontally within the bounding rect.
            m_rgButtons[i].rcIcon.left = m_rgButtons[i].rcBound.left + cxCenter;
            m_rgButtons[i].rcIcon.top = m_rgButtons[i].rcBound.top + cyCenter;
            m_rgButtons[i].rcIcon.right = m_rgButtons[i].rcIcon.left + cxButton;
            m_rgButtons[i].rcIcon.bottom = m_rgButtons[i].rcIcon.top + cyButton;

            // And the button title below the image
            m_rgButtons[i].rcTitle.left = m_rgButtons[i].rcBound.left + 1;
            m_rgButtons[i].rcTitle.top = m_rgButtons[i].rcIcon.bottom;
            m_rgButtons[i].rcTitle.right = m_rgButtons[i].rcBound.right - 1;
            m_rgButtons[i].rcTitle.bottom = m_rgButtons[i].rcTitle.top + (tmTitle.tmHeight);// * 2);

            // Offset the rcBound to the next button.
                OffsetRect(&rcBound, sizeRect.cx, 0);
            }
        }
    }




//
//  FUNCTION:   CButtonBar::OnTimer()
//
//  PURPOSE:    When the timer fires we check to see if the mouse is still
//              over the button bar window.  If not we remove the selection
//              from the active button.
//
void CBB_OnTimer(HWND hwnd, UINT id)
    {
    POINT pt;
    GetCursorPos(&pt);
    if (hwnd != WindowFromPoint(pt))
    {
        CBB_SetSelBtn(-1,hwnd);
    }

    CBB_EndHotTracking(hwnd);
    }


//
//  FUNCTION:   CButtonBar::DoHotTracking()
//
//  PURPOSE:    Starts a timer that allows the button bar to track the mouse
//              in case it leaves the button bar window.
//
void CBB_DoHotTracking(HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    CBB_EndHotTracking(hwnd);
    m_fHotTrackTimer = SetTimer(hwnd, idtTrack, HOTTRACK_TIMER, NULL);
}


//
//  FUNCTION:   CButtonBar::EndHotTracking()
//
//  PURPOSE:    If the timer was set to track the mouse, we kill it and reset
//              our state.
//
void CBB_EndHotTracking(HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if (m_fHotTrackTimer)
    {
        KillTimer(hwnd, idtTrack);
        m_fHotTrackTimer = FALSE;
    }
}


//
//  FUNCTION:   CButtonBar::HitTest()
//
//  PURPOSE:    Returns the button number that the passed in position is
//              over.  If the mouse is over the menu button, it returns
//              -2.  Otherwise, if the mouse is not over a button the function
//              returns -1.
//
//  PARAMETERS:
//      x, y - Position in client coordinates to check.
//
int CBB_HitTest(int x, int y)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    POINT pt = {x, y};
    int i;

    // Walk through the different buttons and determine if the point is
    // within either their image or title.
    for (i = 0; i < m_cButtons; i++)
        {
        if (PtInRect(&m_rgButtons[i].rcBound, pt))
/*            PtInRect(&m_rgButtons[i].rcIcon, pt) ||
            PtInRect(&m_rgButtons[i].rcTitle, pt)) */
            {
            return (i);
            }
        }

   // If we're not over a button then return a default value.
    return (-1);
}




//
//  FUNCTION:   CButtonBar::CBB_SetSelBtn()
//
//  PURPOSE:    Changes the button selection to the specified button.
//
void CBB_SetSelBtn(int iSel,HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if (m_iSelect != iSel)
    {
        HDC hdc = GetDC(hwnd);

        // Remove the old selection
        if (m_iSelect >= 0)
            InvalidateRect(hwnd, &m_rgButtons[m_iSelect].rcTitle, FALSE);

        // Add the new selection
        if (iSel >= 0)
            InvalidateRect(hwnd, &m_rgButtons[iSel].rcTitle, FALSE);

        m_iOldSelect = m_iSelect;

//        if (m_iOldSelect >= 0)
//            DrawFocusRect(hdc, &m_rgButtons[m_iOldSelect].rcBound);

        m_iSelect = iSel;

//        if (m_iSelect >= 0)
//            DrawFocusRect(hdc, &m_rgButtons[m_iSelect].rcBound);

        ReleaseDC(hwnd, hdc);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\_wabtags.h ===
/*
 *  _WABTAGS.H
 *
 *  Internal Property tag definitions
 *
 *  The following ranges should be used for all internal property IDs.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  6600    67FF    Provider-defined internal non-transmittable property
 *
 *  Copyright 1996 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(_WABTAGS_H)
#define _WABTAGS_H


#define WAB_INTERNAL_BASE   0x6600

// Internal representation of a Distribution List.  Multi-valued binary contains
// ENTRYID's of each entry in the distribution list.
#define PR_WAB_DL_ENTRIES                   PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 0)
#define PR_WAB_PROFILE_ENTRIES              PR_WAB_DL_ENTRIES // Use same prop for Profile Entries
#define PR_WAB_FOLDER_ENTRIES               PR_WAB_DL_ENTRIES // Use same prop for Folder Entries

#define PR_WAB_LDAP_SERVER                  PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG                 PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)
// internal only 2nd email address.  Used for parsing LDAP -> WAB mailuser
#define PR_WAB_2ND_EMAIL_ADDR               PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 3)
#define PR_WAB_SECONDARY_EMAIL_ADDRESSES    PROP_TAG(PT_MV_TSTRING, WAB_INTERNAL_BASE + 4)
#define PR_WAB_TEMP_CERT_HASH               PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 5)
// internal properties for temporarily storing the labeledURI value of a returned LDAP contact
#define PR_WAB_LDAP_LABELEDURI              PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 6)

// Internal entry that will tag a given contact as the ME object. There can only be
// one ME per WAB .. we only need to check the existence of the property, the value doesnt
// matter
#define PR_WAB_THISISME                     PROP_TAG(PT_LONG,       WAB_INTERNAL_BASE + 7)

/******* Above properties can be persisted in the data store ****?
/******* The properties below should not end up in the data store since
        older and newer version of Outlook cannot handle them.
        The properties below are used for in-memory manipulation only
        and are NULLed out prior to saving ****/

// Internal binary prop that temporarily stores any certificate returned from LDAP ...
// We cache the raw LDAP cert until such time as the user does an OpenEntry on the LDAP entry
// If the user never calls OpenEntry, then we dont need to convert the raw cert to a MAPI cert
// PR_WAB_LDAP_RAWCERT handles userCertificate;binary
// PR_WAB_LDAP_RAWCERTSMIME handles userSMIMECertificate;binary
//
#define PR_WAB_LDAP_RAWCERT                 PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 8)
#define PR_WAB_LDAP_RAWCERTSMIME            PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 9)

// For storing and displaying the Manager and Direct Reports details for LDAP searches on exchange servers
// These entries will store the details in the form of LDAP URLS ...
#define PR_WAB_MANAGER                      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 10)
#define PR_WAB_REPORTS                      PROP_TAG(PT_MV_TSTRING, WAB_INTERNAL_BASE + 11)

// The PR_WAB_FOLDER_PARENT prop is used to store the entryid of the parent of an object .. 
// This property was originally predefined here but this may have been a bad idea since Outlook can't
// store this property .. hence the PR_WAB_FOLDER_PARENT property is turned into a named property
// so there aren't any problems with outlook. Meanwhile don't use this value WAB_INTERNAL_BASE+12
// since there may be .wabs around which have this value in them ..
#define PR_WAB_FOLDER_PARENT_OLDPROP        PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 12)

// Note Outlook store can't save anything beyond WAB_INTERNAL_BASE + 7 
//(it's hardcoded to understand the first 8 but can't save beyong that)
// Therefore any other internal WAB props must be only in the .wab file 
//or not saved at all.
// Outlook used named properties for ALL the contact data it stores.
//
// If you need to extend the WAB property set for internal only properties,
// use named properties and add them in globals.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\ui_modfy.c ===
/*--------------------------------------------------------------
*
*
*   ui_modfy.c - contains stuff for showing the LDAP Directory
*                   modification dialog ..
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"


extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;


//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
    IImnAccountManager * lpAccountManager;

    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

out:
    return hr;
}



/**

//$$///////////////////////////////////////////////////////////////////////////////
//
// ReadLDAPServerKey - Reads any Server names stored in the given registry key..
//
//  The server names are stored in the registry as multiple strings seperated with
//      a '\0' with 2 '\0' at the end
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ReadLDAPServerKey(HWND hWndLV, LPTSTR szValueName)
{
    BOOL bRet = FALSE;
    IImnAccountManager * lpAccountManager = NULL;
    LPSERVER_NAME lpServerNames = NULL, lpNextServer;


    // Enumerate the LDAP accounts
    if (InitAccountManager(&lpAccountManager)) {
        goto exit;
    }

    if (EnumerateLDAPtoServerList(lpAccountManager, &lpServerNames, NULL)) {
        goto exit;
    }


    // Add the accounts to the list box in order.
    lpNextServer = lpServerNames;
    while (lpNextServer) {
        LPSERVER_NAME lpPreviousServer = lpNextServer;

        LDAPListAddItem(hWndLV, lpNextServer->lpszName);
        lpNextServer = lpNextServer->lpNext;

        LocalFreeAndNull(&lpPreviousServer->lpszName);
        LocalFreeAndNull(&lpPreviousServer);
    }

    bRet = TRUE;

exit:
    return(bRet);
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// WriteLDAPServerKey - Saves Edited names to the Registry key
//
/////////////////////////////////////////////////////////////////////////////////
void WriteLDAPServerKey(HWND hWndLV, LPTSTR szValueName)
{
    ULONG cbLDAPServers = 0;
    ULONG cbExists = 0;
    ULONG i=0;
    TCHAR szBuf[MAX_UI_STR + 1];
    HRESULT   hResult = hrSuccess;
    IImnAccountManager * lpAccountManager = NULL;


    // Enumerate the LDAP accounts
    if (hResult = InitAccountManager(&lpAccountManager)) {
        goto exit;
    }

    cbLDAPServers = ListView_GetItemCount(hWndLV);

    cbExists = 0;

    for (i = 0; i < cbLDAPServers; i++) {
        szBuf[0]='\0';
        ListView_GetItemText(hWndLV, i, 0, szBuf, sizeof(szBuf));

        SetLDAPServerOrder(lpAccountManager, szBuf, i + 1);
    }

    // We've set them all, reset the next ServerID:
    GetLDAPNextServerID(i);
exit:

    return;
}


**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\coguid.c ===
/*
coguid.cpp - self contained GUID allocator module

	Bob Atkinson (BobAtk@microsoft.com) June 1993
	Modified for temporary use by billm April 1994

This file contains all that is necessary to generate GUIDs with high
frequency and robustness without a network card on WIN32.
We allocate a pseudo-random node id based
on machine state.

There is only one public API in this file: HrCreateGuidNoNet().

The following are relevant reference documents:

   		Project 802: Local and Metropolitan Area Network Standard
   		Draft Standard P802.1A/D10 1 April 1990
   		Prepared by the IEEE 802.1
		(Describes IEEE address allocation)

		DEC / HP
		Network Computing Architecture
		Remote Procedure Call RunTime Extensions Specification
		Version OSF TX1.0.11   Steven Miller  July 23, 1992
		(Chapter 10 describes UUID allocation)

A word about "GUID" vs "UUID" vs ... In fact, they're all the SAME THING.
Meaning that, once allocated, they're all interoperable / comparable / etc.
The standard describes a memory layout for a 16-byte structure (long, word,
word, array of bytes) which gets around byte order issues. It then goes on
to describe three different "variants" of allocation algorithm for these 16
byte structures; each variant is encoded by certain high order bits in the
"clockSeqHiAndReserved" byte.
	Variant 0 is (I believe) the historical Apollo allocation algorithm.
	Variant 1 is what is implemented here.
	Variant 2 is created according to the "Microsoft GUID specification."
Careful: Despite the name here being HrCreateGuidNoNet() we are NOT allocating
according to Variant 2; we are using Variant 1. Variant 2 works by having
a range of the bits be a (MS allocated, for now) authority identifier, and
the remaining bits be whatever that authority wants. Variant 1, by
contrast, has a precise standard for how all the bits are allocated. But
as the resulting 16 bytes are in fact all mutually compatible, this
confusion in terminology is of no actual consequence.

Variant 1 is allocated as follows. First, Variant 1 allocates four bits
as a "version" field. Here we implement according to version 1; version 2
is defined for "UUIDs genereated for OSF DCE Security purposes, conformant
to this specification, but substuting a Unix id value for the timeLow
value." I know of no other legal versions that have been allocated.

The other fields of Variant 1 are as follows. The high 6 bytes are the
IEEE allocated node id on which the allocator is running. The low eight
bytes are the current "time": we are to take the current time as
avialable to the precision of milliseconds and multiply by 10,000, thus
giving a logical precision of 100 ns. Within these lower bits, we are to
sequentially increment a count as we allocate guids. Thus, the maximum rate
at which we can allocate is indeed 1 GUID / 100 ns. The remaining two bytes
are used for a "clock sequence". The intent of the clock sequence is to
provide some protection against the real clock going backwards in time.
We initially randomly allocate the clock sequence, and then increment it
each time we detect the clock going backwards (the last time used and the
current clock sequence are stored in the registry).

Presently (93.06.11) this implementation contains byte-order sensitivities,
particularly in the 64-bit arithmetic helper routines below. This
implementation is also not suitable for use on a premptive system.

This function is only called when UuidCreate() fails.
*/

#include "_apipch.h"


#ifndef STATIC
#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif
#endif

#ifdef WIN32

#define INTERNAL                  STATIC HRESULT __stdcall
#define INTERNAL_(type)           STATIC type __stdcall

//==============================================================
// Start of 64 bit arithmetic utility class
//==============================================================

INTERNAL_(BOOL)
FLessThanOrEqualFTs(FILETIME ft1, FILETIME ft2)
{
	if (ft1.dwHighDateTime < ft2.dwHighDateTime)
		return TRUE;
	else if (ft1.dwHighDateTime == ft2.dwHighDateTime)
		return ft1.dwLowDateTime <= ft2.dwLowDateTime;
	else
		return FALSE;
}	
	
INTERNAL_(FILETIME)
FtAddUShort(FILETIME ft1, USHORT ush)
{
	FILETIME	ft;

	ft.dwLowDateTime = ft1.dwLowDateTime + ush;
	ft.dwHighDateTime = ft1.dwHighDateTime +
		((ft.dwLowDateTime < ft1.dwLowDateTime ||
			ft.dwLowDateTime < ush) ?
				1L : 0L);

	return ft;
}

//==============================================================
// End of 64 bit arithmetic utility
//==============================================================

#pragma pack(1)
struct _NODEID // machine identifier
	{
	union {
		BYTE	rgb[6];
		WORD	rgw[3];
		};
	};
#pragma pack()
	
typedef struct _NODEID	NODEID;
typedef USHORT			CLKSEQ;
typedef CLKSEQ FAR *	PCLKSEQ;
#define	clkseqNil		((CLKSEQ)-1)

struct _UDBK		// data from which a block of UUIDs can be generated
	{
	DWORD 				timeLowNext;	// lower bound of block of time values
    DWORD				timeLowLast;	// upper bound of block of time values
    DWORD				timeHigh;		// high dword of timeLowXXXX
	CLKSEQ				clkseq;			// the clock sequence
	NODEID				nodeid;			
    };

typedef struct _UDBK	UDBK;


INTERNAL_(BOOL)		FLessThanOrEqualFTs(FILETIME ft1, FILETIME ft2);
INTERNAL_(FILETIME) FtAddUShort(FILETIME ft1, USHORT ush);
INTERNAL			GetPseudoRandomNodeId(NODEID*);
INTERNAL_(void)		GetCurrentTimeULong64(FILETIME *);
INTERNAL			GetNextBlockOTime(PCLKSEQ pClockSeq, FILETIME *pftCur);
INTERNAL			ReadRegistry (PCLKSEQ pClockSeqPrev, FILETIME *pftPrev);
INTERNAL			InitRegistry (PCLKSEQ pClockSeqPrev, FILETIME *pftPrev);
INTERNAL			WriteRegistry(CLKSEQ, CLKSEQ, const FILETIME);
INTERNAL_(LONG)		CountFilesInDirectory(LPCSTR szDirPath);
INTERNAL_(void) 	FromHexString(LPCSTR sz, LPVOID rgb, USHORT cb);
INTERNAL_(void)		ToHexString(LPVOID rgb, USHORT cb, LPSTR sz);
INTERNAL_(WORD)		Cyc(WORD w);
INTERNAL_(void)		ShiftNodeid(NODEID FAR* pnodeid);
#ifdef MAC
OSErr	__pascal  GetDirName(short vRefNum, long ulDirID, StringPtr name);
int		MacCountFiles(StringPtr pathName, short vRefNum, long parID);
#endif

// We amortize the overhead cost of allocating UUIDs by returning them in
// time-grouped blocks to the actual CoCreateGUID routine. This two-level
// grouping is largely historical, having been derived from the original
// NT UuidCreate() routine, but has been retained here with the thought that
// the efficiencies gained will be needed in future premptive system (Windows 95).

static const ULONG	cuuidBuffer    = 1000;	// how many uuids to get per registry hit.
static const ULONG	cuuidReturnMax = 100;	// how many max to return on each GetUDBK.

static const DWORD	dwMax = 0xFFFFFFFF;		// largest legal DWORD

//================================================================================
// Start of meat of implementation
//================================================================================

INTERNAL GetUDBK(UDBK *pudbk)
// Init the given UDBK so that a bunch of UUIDs can be generated therefrom. This
// routine hits the system registry and the disk, and so is somewhat slow. But we
// amortize the cost over the block of UUIDs that are returned.
{
	HRESULT		hr;
	ULONG		cuuidReturn;
	ULONG		cuuidLeftInBuffer;
	FILETIME	ftCur;
	
	// These next block of variables in effect comprise the internal state of
	// the UUID generator. Notice that this works only in a shared-data space
	// DLL world, such as Win3.1. In non-shared environments, this will
	// need to be done differently, perhaps by putting this all in a server process.
	// In a premptively scheduled system, this function is all a critical section.
	static DWORD  timeLowFirst	= 0;
	static DWORD  timeLowLast	= 0;
	static CLKSEQ clkseq;
	static DWORD  timeHigh;
	static NODEID nodeid        = { 0, 0, 0, 0, 0, 0 };
	
	cuuidLeftInBuffer = timeLowLast - timeLowFirst;
	if (cuuidLeftInBuffer == 0) {
		// Our buffer of uuid space is empty, or this is the first time in to this routine.
		// Get another block of time from which we can generate UUIDs.
		hr = GetNextBlockOTime(&clkseq, &ftCur);
		if (hr != NOERROR) return hr;
		
		if (nodeid.rgw[0] == 0 && nodeid.rgw[1] == 0 && nodeid.rgw[2] == 0) {
			hr = GetPseudoRandomNodeId(&nodeid);
			if (hr != NOERROR) return hr;
		}	
		
		timeHigh = ftCur.dwHighDateTime;
		// Set the buffer bottom. Return few enough so that we don't wrap the low dw.
		timeLowFirst = ftCur.dwLowDateTime;
		timeLowLast  = (timeLowFirst > (dwMax - cuuidBuffer)) ? dwMax : timeLowFirst + cuuidBuffer;
		cuuidLeftInBuffer = timeLowLast - timeLowFirst;
	}
	cuuidReturn = (cuuidLeftInBuffer < cuuidReturnMax) ? cuuidLeftInBuffer : cuuidReturnMax;
	
	// Set the output values and bump the usage count
	pudbk->timeLowNext = timeLowFirst;
	timeLowFirst 	  += cuuidReturn;
	pudbk->timeLowLast = timeLowFirst;
	pudbk->timeHigh    = timeHigh;
	pudbk->clkseq	   = clkseq;
	pudbk->nodeid	   = nodeid;
	return NOERROR;
}

INTERNAL_(void) GetCurrentTimeUlong64(FILETIME *pft)
// Return the current time (# of 100 nanoseconds intervals since 1/1/1601).
// Make sure that we never return the same time twice by high-frequency calls
// to this function.
//
{
	static FILETIME	 ftPrev = {0};
	SYSTEMTIME syst;

	GetSystemTime(&syst);
	if (!SystemTimeToFileTime(&syst, pft))
	{
		TrapSz1("Error %08lX calling SystemTimeToFileTime", GetLastError());
		pft->dwLowDateTime = 0;
		pft->dwHighDateTime =0;
	}

	if (memcmp(pft, &ftPrev, sizeof(FILETIME)) == 0)
		*pft = FtAddUShort(*pft, 1);

	memcpy(&ftPrev, pft, sizeof(FILETIME));
}	

INTERNAL GetNextBlockOTime(PCLKSEQ pclkseq, FILETIME *pft)
// Updates, and potentially create, the registry entries that maintain
// the block of time values for UUIDs that we've created. The algorithm
// is basically:
// If the registry entries don't exist, then create them. Use
//		a random number for the clock sequence.
// If the entries do exist, the dig out of them the previous
//		clock sequence and previous time allocated. If the previous time
//		is greater than the current time then bump (and store) the
//		clock sequence.
{
	FILETIME	ftRegistry;
	HRESULT	hr;
	CLKSEQ	clkseqPrev;

	GetCurrentTimeUlong64(pft);
	hr = ReadRegistry(pclkseq, &ftRegistry);
	if (hr != NOERROR)
		return InitRegistry(pclkseq, pft);

	// If the clock's gone backwards, bump the clock seq. The clock
	// seq is only 14 bits significant; don't use more.
	clkseqPrev = *pclkseq;
	if (FLessThanOrEqualFTs(*pft, ftRegistry)) {
		clkseqPrev = clkseqNil;
		*pclkseq += 1;
		if (*pclkseq == 16384)	// 2^14
			*pclkseq = 0;
	}
	return WriteRegistry(*pclkseq, clkseqPrev, *pft);
}

// Use a private ini file for now. This will go away when CoCreateGuid
// is available on NT and Windows 95.
static const char szDataKey[]	= "CoCreateGuid";
static const char szClkSeq[]    = "PreviousClockSequence";	// same as UUIDGEN.EXE
static const char szTime[]		= "PreviousTimeAllocated";	// same as UUIDGEN.EXE
static const char szNodeId[]	= "NodeId";

static const char szBlank[]		   = "";	// used for default GetPrivateProfileString values
static const char szProfileFile[]  = "mapiuid.ini";

#define CCHHEXBUFFERMAX	32

INTERNAL ReadRegistry(PCLKSEQ pclkseq, FILETIME *pft)
// Read the previous values of the clock sequence and the time from
// the registry, if they are there. If they are not, then return
// an error.
{
	SCODE sc = S_OK;
	LONG cch = 0;
	char szHexBuffer[CCHHEXBUFFERMAX];

    // use our private ini file
	cch = CCHHEXBUFFERMAX;
	cch = GetPrivateProfileString(szDataKey, szClkSeq, szBlank,
					szHexBuffer, (int)cch, szProfileFile);
	if (cch == 0 || cch >= CCHHEXBUFFERMAX) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}		
	FromHexString(szHexBuffer, pclkseq, sizeof(CLKSEQ));

	cch = CCHHEXBUFFERMAX;
	cch = GetPrivateProfileString(szDataKey, szTime, szBlank,
					szHexBuffer, (int)cch, szProfileFile);
	if (cch == 0 || cch >= CCHHEXBUFFERMAX) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}
	FromHexString(szHexBuffer, pft, sizeof(FILETIME));
	// Fall through to ErrRet	
ErrRet:
	return ResultFromScode(sc);
}

INTERNAL InitRegistry(PCLKSEQ pclkseq, FILETIME *pft)
// Invent a new clock sequence using a pseudo random number. Then
// write the clock sequence and the current time to the registry.
{
	LONG cfile;
#ifdef MAC
	short	vRefNum;
	long	ulDirID;
	Str32	stDirName;

	FindFolder((short)kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder,
		&vRefNum, &ulDirID);
	GetDirName(vRefNum, ulDirID, stDirName);
	cfile = MacCountFiles(stDirName, vRefNum, ulDirID);
#else
	const int cchWindowsDir = 145;	// 144 is recommended size according to SDK
	LPSTR szWindowsDir = NULL;

	if (	FAILED(MAPIAllocateBuffer(cchWindowsDir, (LPVOID *) &szWindowsDir))
		||	GetWindowsDirectory(szWindowsDir, cchWindowsDir) == 0)
		goto ErrRet;
	// For the clock sequence, we use the number of files in the current
	// windows directory, on the theory that that this is highly sensitive
	// to the exact set of applications that have been installed on this
	// particular machine.
	cfile = CountFilesInDirectory(szWindowsDir);
	if (cfile == -1)
		goto ErrRet;
	MAPIFreeBuffer(szWindowsDir);
	szWindowsDir = NULL;
	goto NormRet;

ErrRet:
	MAPIFreeBuffer(szWindowsDir);
	return ResultFromScode(MAPI_E_CALL_FAILED);

NormRet:
#endif	// MAC
	*pclkseq  = (CLKSEQ)Cyc((WORD)cfile);
	// Also use ms since boot so as to get a more time-varying value
	*pclkseq ^= (CLKSEQ)Cyc((WORD)GetTickCount());
	*pclkseq &= 16384-1; // only allow 14 bits of significance in clock seq
	GetCurrentTimeUlong64(pft);
	return WriteRegistry(*pclkseq, clkseqNil, *pft);
}

INTERNAL WriteRegistry(CLKSEQ clkseq, CLKSEQ clkseqPrev, const FILETIME ft)
// Write the clock sequence and time into the registry so that we can
// retrieve it later on a subsequent reboot. clkseqPrev is passed so that
// we can avoid writing the clock sequence if in fact we know it to be
// currently valid. This was measured as important for performance.
{
	SCODE sc = S_OK;
	char szHexBuffer[CCHHEXBUFFERMAX];
	
	if (clkseq != clkseqPrev) { // don't write if clock sequence same (often is)

		ToHexString((LPVOID)&clkseq, sizeof(CLKSEQ), szHexBuffer);

		if (!WritePrivateProfileString(szDataKey, szClkSeq, szHexBuffer, szProfileFile)) {
			sc = MAPI_E_DISK_ERROR;
			goto ErrRet;
		}
	}			

	ToHexString((LPVOID)&ft, sizeof(FILETIME), szHexBuffer);		
	if (!WritePrivateProfileString(szDataKey, szTime, szHexBuffer, szProfileFile)) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}

ErrRet:
	WritePrivateProfileString(NULL,NULL,NULL,szProfileFile); // flush the ini cache
	return ResultFromScode(sc);
}

#ifdef MAC
#define	GET_DIR_INFO				-1

int	MacCountFiles(StringPtr pathName, short vRefNum, long parID)
// Return the number of files in the specified Mac directory.
{
	CInfoPBRec paramBlk;

	paramBlk.hFileInfo.ioNamePtr = pathName;	// Pascal string
	paramBlk.hFileInfo.ioVRefNum = vRefNum;
	// not necessary for full pathname
	paramBlk.hFileInfo.ioDirID = paramBlk.dirInfo.ioDrParID = parID;
	paramBlk.hFileInfo.ioFDirIndex = GET_DIR_INFO;
	PBGetCatInfoSync(&paramBlk);
	return(((DirInfo *) &paramBlk)->ioDrNmFls);
}
#endif

INTERNAL_(LONG) CountFilesInDirectory(LPCSTR szDirPath)
// Return the number of files in this directory. The path may or may not
// currently end with a slash.
{
	int cfile = 0;
#ifndef MAC
	LPCSTR szStar = "*.*";
	char  chLast = szDirPath[lstrlen(szDirPath)-1];
	LPSTR szPath;
	WIN32_FIND_DATA ffd;
	HANDLE hFile;

	if (FAILED(MAPIAllocateBuffer(lstrlen(szDirPath) +1 +lstrlen(szStar) +1,
			(LPVOID *) &szPath)))
		return -1;

	lstrcpy(szPath, szDirPath);

/***
#ifdef DBCS
	chLast = *(SzGPrev(szDirPath, szDirPath+lstrlen(szDirPath)));
#endif
***/
    // Get the last character in above szDirPath
    {
        LPCSTR lp = szDirPath;
        while(*lp)
        {
            chLast = *lp;
            lp = CharNext(lp);
        }
    }

    if (!(chLast == '\\' || chLast == '/'))
		lstrcat(szPath, "\\");
	lstrcat(szPath, szStar);
	
	ffd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

	hFile = FindFirstFile(szPath, &ffd);
	if (hFile != INVALID_HANDLE_VALUE)
		{
		cfile++;
		while (FindNextFile(hFile, &ffd))
			cfile++;
		FindClose(hFile);
		}

    MAPIFreeBuffer(szPath);
#else
	FSSpec pfss;

	if (UnwrapFile(szDirPath, &pfss))
		cfile = MacCountFiles(pfss.name, pfss.vRefNum, pfss.parID);
	else
		cfile = Random();
#endif
	return cfile;
}

#pragma warning (disable:4616) // warning number out of range
#pragma warning	(disable:4704) // in-line assembler precludes global optimizations

INTERNAL_(void) ShiftNodeid(NODEID FAR* pnodeid)
// Shift the nodeid so as to get a randomizing effect
{
	// Rotate the whole NODEID left one bit. NODEIDs are 6 bytes long.
#if !defined(M_I8086) && !defined(M_I286) && !defined(M_I386) && !defined(_M_IX86)
	BYTE bTmp;
	BYTE bOld=0;

/* Compilers complain about conversions here. Pragma the warning off. */
#pragma warning(disable:4244)	// possible data loss in conversion

	bTmp = pnodeid->rgb[5];
	pnodeid->rgb[5] = (pnodeid->rgb[5] << 1) + bOld;
	bOld = (bTmp & 0x80);	

	bTmp = pnodeid->rgb[4];
	pnodeid->rgb[4] = (pnodeid->rgb[4] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[3];
	pnodeid->rgb[3] = (pnodeid->rgb[3] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[2];
	pnodeid->rgb[2] = (pnodeid->rgb[2] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[1];
	pnodeid->rgb[1] = (pnodeid->rgb[1] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[0];
	pnodeid->rgb[0] = (pnodeid->rgb[0] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	pnodeid->rgb[5] = pnodeid->rgb[5] + bOld;
#pragma warning(default:4244)

#else
	_asm {
		mov	ebx, pnodeid
		sal	WORD PTR [ebx], 1	// low order bit now zero
		rcl	WORD PTR [ebx+2], 1		
		rcl	WORD PTR [ebx+4], 1
		// Now put bit that fell off end into low order bit
		adc	WORD PTR [ebx],0	// add carry bit back in
	}
#endif
}
	
INTERNAL_(WORD) Cyc(WORD w)
// Randomizing function used to distribute random state values uniformly
// in 0..65535 before use.
{
	// // // Use one iteration of the library random number generator.
	// // srand(w);
	// // return rand();
	//
	// The following is what this would actually do, taken from the library
	// source. It really isn't very good.
	// return (WORD)(  ((((long)w) * 214013L + 2531011L) >> 16) & 0x7fff );
	
	// Really what we do: use the random number generator presented in
	// CACM Oct 1988 Vol 31 Number 10 p 1195, slightly optimized since
	// we are only interested in 16bit input/seed values.
	
	const LONG a = 16807L;
	const LONG m = 2147483647L;	// 2^31 -1. Is prime.
	const LONG q = 127773L;		// m div a
	const LONG r = 2386L;		// m mod a
		
	LONG seed = (LONG)w + 1L;	// +1 so as to avoid problems with zero
	// LONG hi   = seed / q;	// seed div q. Here always zero, since seed < q.
	// LONG lo	 = seed % q;	// seed mod q. Here always seed.
	LONG test = a*seed;			// a * lo - r * hi
	if (test > 0)
		seed = test;
	else
		seed = test + m;
		
	// In a true random number generator, what we do now is scale the bits
	// to return a floating point number in the range 0..1. However, we have
	// no need here for that degree of quality of number sequence, and we
	// wish to avoid the floating point calculations. Therefore we simply xor
	// the words together.
	
	// // p1193, top right column: seed is in the range 1..m-1, inclusive
	// return (double)seed / m;			// what the text recommends
	// return (double)(seed-1) / (m-1);	// variation: allows zero as legal value
	return (WORD) (LOWORD(seed) ^ HIWORD(seed)); // use all the bits
}	

INTERNAL GenerateNewNodeId(NODEID* pnodeid)
// Can't get from net. Generate one. We do this by using
// various statistics files in certain key directories on
// the machine.
{	
	// REVIEW: Consider not bothering to init the NODEID, thus getting
	// random state from RAM?
#ifndef MAC
	// Not including this should help make up for some of the (here)
	// randomizing funcitons the MAC doesn't support.
	memset(pnodeid, 0, sizeof(*pnodeid));
	
	{ // BLOCK
		// First, merge in random state generated from the file system
		DWORD dwSectPerClust;
		DWORD dwBytesPerSect;
		DWORD dwFreeClust;
		DWORD dwClusters;

		(void) GetDiskFreeSpace(NULL, &dwSectPerClust, &dwBytesPerSect,
            &dwFreeClust, &dwClusters);

		pnodeid->rgw[0] ^= Cyc(LOWORD(dwBytesPerSect));
		pnodeid->rgw[1] ^= Cyc(HIWORD(dwBytesPerSect));
		pnodeid->rgw[2] ^= Cyc(HIWORD(dwClusters));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(dwFreeClust));
		pnodeid->rgw[1] ^= Cyc(HIWORD(dwFreeClust));
		pnodeid->rgw[2] ^= Cyc(LOWORD(dwClusters));
	} // BLOCK
#else
	{ // BLOCK
		ParamBlockRec paramBlk = {0};

		paramBlk.volumeParam.ioVolIndex = 1;
		PBGetVInfoSync(&paramBlk);
		pnodeid->rgw[0] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVAlBlkSiz));
		pnodeid->rgw[1] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVAlBlkSiz));
		pnodeid->rgw[2] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVNmAlBlks));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVFrBlk));
		pnodeid->rgw[1] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVFrBlk));
		pnodeid->rgw[2] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVNmAlBlks));
	} // BLOCK
#endif
	{ // BLOCK
		// Next, mix in other stuff.
		// As we generate and *store* the nodeid, using the time should not
		// cause corellation problems with the fact that the time is also
		// used as part of the fundamental uuid generation algorithm.
		MEMORYSTATUS ms;
		FILETIME ft;
		DWORD dw;
		POINT pt;
#ifndef MAC
		LPVOID lpv;
#else
		PSN	psn;
		DWORD dwFeature;
		
		Gestalt(gestaltOSAttr, &dwFeature);
		if (BitTst(&dwFeature, 31 - gestaltTempMemSupport))
		{
		// If temporary memory is available.
			ms.dwAvailPhys = (DWORD) TempFreeMem();
			ms.dwAvailVirtual = (DWORD) TempMaxMem(&ms.dwAvailVirtual);
			ms.dwAvailPageFile = (DWORD) TempTopMem();
		}
		else
		{
		// If temporary memory is not available.
			ms.dwAvailPhys = (DWORD) TickCount();
			GetDateTime(&ms.dwAvailVirtual);
		}
#endif
#ifndef MAC
		ms.dwLength = sizeof(MEMORYSTATUS);
		GlobalMemoryStatus(&ms);
#endif

		ShiftNodeid(pnodeid);
		GetCurrentTimeUlong64(&ft);
		pnodeid->rgw[0] ^= Cyc(HIWORD(ft.dwHighDateTime)); // Use hi-order six bytes as time is *10000
		pnodeid->rgw[1] ^= Cyc(LOWORD(ft.dwHighDateTime));
		pnodeid->rgw[2] ^= Cyc(HIWORD(ft.dwLowDateTime));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(ms.dwAvailPhys));
		pnodeid->rgw[1] ^= Cyc(LOWORD(ms.dwAvailVirtual));
		pnodeid->rgw[2] ^= Cyc(LOWORD(ms.dwAvailPageFile));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(HIWORD(ms.dwAvailPhys));
		pnodeid->rgw[1] ^= Cyc(HIWORD(ms.dwAvailVirtual));
		pnodeid->rgw[2] ^= Cyc(HIWORD(ms.dwAvailPageFile));
		
        ShiftNodeid(pnodeid);
		dw = GetTickCount();		
		pnodeid->rgw[0] ^= Cyc(HIWORD(dw));         	// Time (ms) since boot
		pnodeid->rgw[1] ^= Cyc(LOWORD(dw));
#ifndef MAC
		pnodeid->rgw[2] ^= Cyc(LOWORD(CountClipboardFormats()));// Number of items on the clipboard
#endif
		
		GetCursorPos(&pt);								// Cursor Position
        ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc((WORD)(pt.x));
		pnodeid->rgw[1] ^= Cyc((WORD)(pt.y));
#ifdef MAC
		MacGetCurrentProcess(&psn);
		pnodeid->rgw[2] ^= Cyc(LOWORD(psn.lowLongOfPSN));
#else
		pnodeid->rgw[2] ^= Cyc(LOWORD((DWORD)GetCurrentThread())); // Current thread we're running in
#endif
		ShiftNodeid(pnodeid);
#ifdef MAC
		pnodeid->rgw[0] ^= Cyc(HIWORD(psn.lowLongOfPSN));
		pnodeid->rgw[1] ^= Cyc(LOWORD(psn.highLongOfPSN));
#else
		pnodeid->rgw[0] ^= Cyc(HIWORD(GetCurrentThread()));
		pnodeid->rgw[1] ^= Cyc((WORD)GetOEMCP());	// sensitive to different countries		
#endif
		pnodeid->rgw[2] ^= Cyc((WORD)GetSystemMetrics(SM_SWAPBUTTON)); // different for lefties vs righties
		
		ShiftNodeid(pnodeid);
#ifndef MAC		
		lpv = GetEnvironmentStrings();
		pnodeid->rgw[0] ^= Cyc(HIWORD((DWORD)lpv));
		pnodeid->rgw[1] ^= Cyc(LOWORD((DWORD)lpv));
#endif
		pnodeid->rgw[2] ^= Cyc(HIWORD(GetCursor()));
		
		ShiftNodeid(pnodeid);
#ifdef MAC
		GetCursorPos(&pt);
#else	
		GetCaretPos(&pt);
#endif	
		pnodeid->rgw[0] ^= Cyc((WORD)(pt.x));
		pnodeid->rgw[1] ^= Cyc((WORD)(pt.y));
		pnodeid->rgw[2] ^= Cyc(LOWORD((DWORD)GetCursor()));

		ShiftNodeid(pnodeid);		
		pnodeid->rgw[0] ^= Cyc((WORD)(DWORD)GetDesktopWindow());
		pnodeid->rgw[1] ^= Cyc((WORD)(DWORD)GetActiveWindow());
#ifndef MAC
		pnodeid->rgw[2] ^= Cyc((WORD)(DWORD)GetModuleHandle("OLE32"));
#endif
		
    } // BLOCK

    /* The following exerpts are taken from

    		Project 802: Local and Metropolitan Area Network Standard
    		Draft Standard P802.1A/D10 1 April 1990
    		Prepared by the IEEE 802.1
    		
       and is available in MS technical library. The key point about this is the
       second LSB in the first byte of a real IEEE address is always zero.

       Page 18:
       "5. Universal Addresses and Protocol Identifiers

       The IEEE makes it possible for organizations to employ unique individual
       LAN MAC addresses, group addresses, and protocol identifiers. It does so by
       assigning organizationally unique identifiers, which are 24 bits in length.
       [...] Though the organizationally unique identifiers are 24 bits in length,
       their true address space is 22 bits. The first bit can be set to 1 or 0
       depending on the application. The second bit for all assignments is zero.
       The remaining 22 bits [...] result in 2**22 (approximately
       4 million identifiers.

       [...] The multicast bit is the least significant bit of the first octet, A.


       [...] 5.1 Organizationally Unique Identifier

       [...] The organizationally unique identifier is 24 bits in length and its
       bit pattern is shown below. Organizationally unique identifiers are
       assigned as 24 bit values with both values (0,1) being assigned to the
       first bit and the second bit being set to 0 indicates that the assignment
       is universal. Organizationally unique identifiers with the second bit set
       to 1 are locally assigned and have no relationship to the IEEE-assigned
       values (as described herein).

       The organizationally unique identifier is defined to be:

       	1st bit                24th bit
       	  |                       |
       	  a  b  c  d  e  .......  x  y
          |  |
          |  Always set to zero
          Bit can be set to 0 or 1 depending on application [application here is
          noting at all to do with what we, MS, call an application]

       [...] 5.2 48-Bit Universal LAN Mac Addresses
       [...] A 48 bit universal address consists of two parts. The first 24 bits
       correspond to the organizationally unique identifier as assigned by the
       IEEE except that the assignee may set the first bit to 1 for group
       addresses or set it to 0 for individual addresses. The second part,
       comprising the remaining 24 bits, is administered locally by the assignee.
       [...]
	
         octet:
             0          1          2          3          4          5
         0011 0101  0111 1011  0001 0010  0000 0000  0000 0000  0000 0001
         |
         First bit transmitted on the LAN medium. (Also the Individual/Group
         Address Bit.) The hexadecimal representation is: AC-DE-48-00-00-80
		 						
       The Individual/Group (I/G) Address Bit (1st bit of octet 0) is used to
       identify the destination address either as an individual or as a group
       address. If the Individual/Group Address Bit is 0, it indicates that
       the address field contains an individual address. If this bit is 1, the
       address field contains a group address that identifies one or more (or
       all) stations connected to the LAN. The all-stations broadcast address
       is a special, pre-defined group address of all 1's.

       The Universally or Locally Administered Address Bit (2nd bit of octet 0)
       is the bit directly following the I/G bit. This bit indicates whether
       the address has been assigned by a local or universal administrator.
       Universally administered addresses have this bit set to 0. If this bit
       is set to 1, the entire address (i.e.: 48 bits) has been locally administered."

	*/
	pnodeid->rgb[0] |= 2;	// Ensure that this is a locally administered address
	pnodeid->rgb[0] &= ~1;	// For future expandability: ensure one bit is
							// always zero.

	return NOERROR;	
}	

INTERNAL GetPseudoRandomNodeId(NODEID* pnodeid)
// Use the same nodeid we did last time if it's there; otherwise,
// make a new one.
{
	HRESULT hr = NOERROR;
	char szHexBuffer[CCHHEXBUFFERMAX];
	LONG cch = CCHHEXBUFFERMAX;
	
	// See if we already have a nodeid registered
	cch = GetPrivateProfileString(szDataKey, szNodeId, szBlank,
									szHexBuffer, (int)cch, szProfileFile);
	if (cch != 0 && cch < CCHHEXBUFFERMAX) {
		FromHexString(szHexBuffer, pnodeid, sizeof(*pnodeid));
		
	} else {
	// If we don't presently have a nodeid registered, make one, then register it
		hr = GenerateNewNodeId(pnodeid);
		if (hr != NOERROR) goto Exit;
		
		ToHexString(pnodeid, sizeof(*pnodeid), szHexBuffer);
		
		if (WritePrivateProfileString(szDataKey, szNodeId, szHexBuffer,szProfileFile)) {
			WritePrivateProfileString(NULL,NULL,NULL,szProfileFile); // flush ini cache		
		} else {
			hr = ResultFromScode(REGDB_E_WRITEREGDB);
			goto Exit;
			}
	}
				
Exit:
	return hr;
}

//========================================================================	
INTERNAL_(unsigned char) ToUpper(unsigned char ch)
{
	if (ch >= 'a' && ch <= 'z')
		return (unsigned char)(ch - 'a' + 'A');
	else
		return ch;
}

INTERNAL_(BYTE) FromHex(unsigned char ch)
{
	BYTE b = (BYTE) (ToUpper(ch) - '0');
	if (b > 9)
		b -= 'A' -'9' -1;
	return b;
}

INTERNAL_(void) FromHexString(LPCSTR sz, LPVOID pv, USHORT cb)
// Set the value of this array of bytes from the given hex string
{
	BYTE FAR *rgb = (BYTE FAR*)pv;
	const char FAR *pch = sz;

	memset(rgb, 0, cb);

	if ((lstrlen(pch) & 1) != 0)
	    rgb[0] = FromHex(*pch++);			// Odd length; do the leading nibble separately
	while (*pch != '\0') {
		BYTE b = FromHex(*pch++);			// get next nibble
		b = (BYTE)((b<<4) | FromHex(*pch++)); 		// and the next
		MoveMemory(&rgb[1], &rgb[0], cb-1);	// shift us over one byte		
		rgb[0] = b;
	}
}
	
INTERNAL_(unsigned char) ToHex(BYTE b)
{
	b &= 0x0f;
	if (b > 9)
		return (BYTE)(b -10 + 'A');
	else
		return (BYTE)(b -0  + '0');
}	
	
INTERNAL_(void) ToHexString(LPVOID pv, USHORT cb, LPSTR sz)
// sz must be at least 2*cb +1 characters long
{
	const BYTE FAR *rgb = (const BYTE FAR *)pv;
	const int ibLast = cb-1;
	int ib;

	for (ib = ibLast; ib >= 0; ib--) {
		sz[(ibLast-ib)*2] 	 = ToHex((BYTE)(rgb[ib]>>4));
		sz[(ibLast-ib)*2+1]  = ToHex(rgb[ib]);
	}
	sz[(ibLast+1)*2] = '\0';
}
                                       	

//========================================================================

// NOTE: As much as it might appear, this structure definition is NOT byte
// order sensitive. That is, the structure definition and the field
// manipulations that we use are in fact correct on both little and big	
// endian machines.

#pragma pack(1)	
struct _INTERNALUUID
	{
	ULONG		timeLow;
	USHORT		timeMid;
	USHORT		timeHighAndVersion;
	BYTE		clkseqHighAndReserved;
	BYTE		clkseqLow;
	BYTE		nodeid[6];
	};
#pragma pack()

typedef struct _INTERNALUUID	INTERNALUUID;
	
enum {
// Constants used below for manipulating fields in the UUID
	uuidReserved 		= 0x80,		// we are a variant 1 UUID
	uuidVersion			= 0x1000,   // version 1 (high nibble significant)
	};	

//=================================================================

STDAPI HrCreateGuidNoNet(GUID FAR *pguid)
// This is the only public function in this file.
// Return a newly allocated GUID.
	{
	static UDBK udbk;	// We rely on static initialization to zero
	HRESULT hr;
	INTERNALUUID FAR* puuid = (INTERNALUUID FAR *)pguid;
	if (udbk.timeLowNext == udbk.timeLowLast)
		{
		if ((hr = GetUDBK(&udbk)) != NOERROR)
			return hr;
		}
 		
	puuid->timeLow =  udbk.timeLowNext++;
	puuid->timeMid = (USHORT)(udbk.timeHigh & 0xffff);
	puuid->timeHighAndVersion =
		(USHORT) (((USHORT)((udbk.timeHigh >> 16) & 0x0fff))
					| ((USHORT) uuidVersion));
	puuid->clkseqHighAndReserved =
		(BYTE)((BYTE) ((udbk.clkseq >> 8) & 0x3f)
			| (BYTE) uuidReserved);
	puuid->clkseqLow = (BYTE)(udbk.clkseq & 0xff);
	memcpy(&puuid->nodeid[0], &udbk.nodeid.rgb[0], sizeof(NODEID));
	
	return hrSuccess;
	}

#endif /* WIN32 only */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\oldstuff.c ===
// This file contains dead code we dont use in the WAB but which we dont want
// to lose as it may be useful someday ...
//

#ifdef IMPORT_WAB
/***************************************************************************

    Name      : HrImportWABFile

    Purpose   : Merges an external WAB file with the current on

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpIAB)
{
    HRESULT hResult = hrSuccess;
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(idsWABImportString, TEXT("*.WAB"));
    TCHAR szFileName[MAX_PATH + 1] = "";

    HANDLE hPropertyStore = NULL;

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = TEXT("Select WAB File to Import");
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "wab";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetOpenFileName(&ofn))
    {
        ULONG ulEIDCount = 0;
        LPDWORD lpdwEntryIDs = NULL;
        ULONG i;
        SPropertyRestriction PropRes = {0};
        HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        TCHAR szBuf[MAX_UI_STR];


        hResult = OpenPropertyStore(
                            szFileName,
                            AB_OPEN_EXISTING,
                            hWnd,
                            &hPropertyStore);

        if(HR_FAILED(hResult) || (!hPropertyStore))
        {
            ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto out;
        }

        PropRes.ulPropTag = PR_DISPLAY_NAME;
        PropRes.relop = RELOP_EQ;
        PropRes.lpProp = NULL;

        hResult = FindRecords(
                            hPropertyStore,
                            AB_MATCH_PROP_ONLY,
                            TRUE,
                            &PropRes,
                            &ulEIDCount,
                            &lpdwEntryIDs);


        if(HR_FAILED(hResult))
        {
            LocalFreeAndNull(&lpdwEntryIDs);
            goto out;
        }

        if (ulEIDCount > 0)
        {

            for(i=0;i<ulEIDCount;i++)
            {
                SBinary sb = {0};
                LPSPropValue lpPropArray = NULL;
                ULONG ulcValues = 0;
                ULONG cbEntryID = 0;
                LPENTRYID lpEntryID = NULL;
                ULONG j;
                LPTSTR lpszName;

                sb.cb = SIZEOF_WAB_ENTRYID;
                sb.lpb = (LPBYTE) &(lpdwEntryIDs[i]);

                hResult = ReadRecord(
                        hPropertyStore,
                        &sb,
                        0,
                        &ulcValues,
                        &lpPropArray);

                if(HR_FAILED(hResult))
                {
                    if(lpPropArray)
                        LocalFreePropArray(ulcValues,&lpPropArray);
                    continue;
                }

                // can't import dist lists yet - they will be imported in a second pass
                for(j=0;j<ulcValues;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_OBJECT_TYPE)
                    {
                        if(lpPropArray[j].Value.l != MAPI_MAILUSER)
                            goto endloop;
                    }
                    if(lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
                    {
                        lpszName = lpPropArray[j].Value.LPSZ;
                    }
                }

                // reset entryid
                for(j=0;j<ulcValues;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_ENTRYID)
                    {
                        lpPropArray[j].Value.bin.cb = 0;
                        LocalFreeAndNull(&lpPropArray[j].Value.bin.lpb);
                        break;
                    }
                }

                //Status bar messages out here
                // This is temp - TBD
                // Modify to use resource and Format Message
                wsprintf(szBuf,"Importing %s. Entry: '%s'.",szFileName,lpszName);
                StatusBarMessage(szBuf);

                hResult = HrCreateNewEntry(
                            lpIAB,
                            hWnd,
                            MAPI_MAILUSER,
                            CREATE_CHECK_DUP_STRICT,
                            FALSE,
                            ulcValues,
                            lpPropArray,
                            &cbEntryID,
                            &lpEntryID );


endloop:
                if(lpPropArray)
                    LocalFreePropArray(ulcValues,&lpPropArray);

                if(lpEntryID)
                    MAPIFreeBuffer(lpEntryID);

            } //for loop


        } // if

out:
        if(hPropertyStore)
            ClosePropertyStore(hPropertyStore,AB_DONT_BACKUP);

        LocalFreeAndNull(&lpdwEntryIDs);

        SetCursor(hOldCur);
    }

    LocalFreeAndNull(&lpFilter);
    LocalFreeAndNull((LPVOID *)&(ofn.lpstrTitle));

    StatusBarMessage(szEmpty);

    return(hResult);

}
#endif

#ifdef OLD_STUFF
//$$//////////////////////////////////////////////////////////////////////
//	HrSendMailToContact
//
//	Retrieves the contacts email address and shell executes a "mailto:"
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
static const SizedSPropTagArray(1, ptaEmailAddress)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};
HRESULT HrSendMailToContact(HWND hWndLV, LPADRBOOK lpIAB)
{
	HRESULT hr = E_FAIL;
	int iItemIndex = ListView_GetSelectedCount(hWndLV);
	HWND hWndParent = GetParent(hWndLV);
    TCHAR szBuf[MAX_UI_STR];
    LPSPropValue lpspv = NULL;
    IF_WIN16(static const char cszMailClient[]  = "MSIMN.EXE";)

	// Open props if only 1 item is selected
	if (iItemIndex == 1)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		if (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem;
			LV_ITEM LVItem;

			LVItem.mask = LVIF_PARAM;
            LVItem.iItem = iItemIndex;
            LVItem.iSubItem = 0;
            LVItem.lParam = 0;

			// Get item lParam LPRECIPIENT_INFO structure
            if (ListView_GetItem(hWndLV,&LVItem))
			{
				lpItem = ((LPRECIPIENT_INFO) LVItem.lParam);
                if(lpItem->szEmailAddress && lstrlen(lpItem->szEmailAddress))
                {
                    LPTSTR lpszMailTo = NULL;
                    LPTSTR lpszEmail = NULL;
                    ULONG cValues;
                    LoadString(hinstMapiX, idsSendMailTo, szBuf, sizeof(szBuf));

                    // Open the entry and read the email address.
                    // NOTE: We can't just take the address out of the listbox
                    // because it may be truncated!
                    if (HR_FAILED(hr = HrGetPropArray(lpIAB,
                      (LPSPropTagArray)&ptaEmailAddress,
                      lpItem->cbEntryID,
                      lpItem->lpEntryID,
                      &cValues,
                      &lpspv))) {
                        goto out;
                    }

                    lpszEmail = lpspv[0].Value.LPSZ;

                    if (FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szBuf,
                                        0,                    // stringid
                                        0,                    // dwLanguageId
                                        (LPTSTR)&lpszMailTo,     // output buffer
                                        0,                    //MAX_UI_STR
                                        (va_list *)&lpszEmail))
                    {
#ifndef WIN16
                        ShellExecute(hWndParent, "open", lpszMailTo, NULL, NULL, SW_SHOWNORMAL);
                        LocalFreeAndNull(&lpszMailTo);
#else
                        ShellExecute(hWndParent, NULL, cszMailClient, lpszMailTo, NULL, SW_SHOWNORMAL);
                        FormatMessageFreeMem(lpszMailTo);
#endif
                        hr = S_OK;
                        goto out;
                    }

				}
                else
                {
                    // the item has no email
                    ShowMessageBox(GetParent(hWndLV), idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
                }
			}

		}
	}
	else
    {
        if (iItemIndex <= 0)
		{
			// nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
		}
		else
		{
			//multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
		}
    }


out:
    FreeBufferAndNull(&lpspv);

	return hr;

}
#endif

#ifdef CERT_PROPS
IDD_DIALOG_CERT_GENERAL DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,20,20
    LTEXT           "John Smith <jsmith@generic.com>",
                    IDC_CERT_GENERAL_LABEL_CERTFORDATA,56,12,149,8
    LTEXT           "Serial Number:",IDC_CERT_GENERAL_LABEL_SERIALNUM,7,45,
                    47,8
    LTEXT           "12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  ",
                    IDC_CERT_GENERAL_LABEL_SERIALNUMDATA,56,45,149,26
    LTEXT           "Valid From:",IDC_CERT_GENERAL_LABEL_VALIDFROM,7,30,36,8
    LTEXT           "September 19, 1996 to September 18, 1997",
                    IDC_CERT_GENERAL_LABEL_VALIDFROMDATA,56,30,139,8
    GROUPBOX        "Issued By:",IDC_CERT_GENERAL_FRAME_ISSUED,7,71,198,32
    LTEXT           "Verisign, Inc.",IDC_CERT_GENERAL_LABEL_ISSUER,38,86,158,
                    8
    GROUPBOX        "Status:",IDC_CERT_GENERAL_FRAME_STATUS,7,107,198,74
    ICON            IDI_ICON_CHECK,IDC_CERT_GENERAL_ICON_CHECK,13,116,20,20
    ICON            IDI_ICON_UNCHECK,IDC_CERT_GENERAL_ICON_UNCHECK,13,116,20,
                    20
    LTEXT           "This ID is valid.",IDC_CERT_GENERAL_STATIC_STATUS,38,
                    120,150,10
    LTEXT           "Revoked:",IDC_CERT_GENERAL_LABEL_REVOKED,40,135,32,8
    LTEXT           "No.",IDC_CERT_GENERAL_LABEL_REVOKEDDATA,81,135,12,8
    LTEXT           "Expired:",IDC_CERT_GENERAL_LABEL_EXPIRED,40,149,26,8
    LTEXT           "No.",IDC_CERT_GENERAL_LABEL_EXPIREDDATA,81,149,12,8
    LTEXT           "&Trusted:",IDC_CERT_GENERAL_LABEL_TRUST,39,163,27,8
    COMBOBOX        IDC_CERT_GENERAL_COMBO_TRUST,109,161,89,43,
                    CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Yes.",IDC_CERT_GENERAL_LABEL_TRUSTEDDATA,81,163,18,8
END

IDD_DIALOG_CERT_TRUST DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "View the Chain of Trust for this digital ID here. ",
                    IDC_CERT_TRUST_LABEL_EXPLAIN,36,12,169,8
    GROUPBOX        "&Chain of Trust:",IDC_CERT_TRUST_FRAME_CHAIN,7,30,198,
                    151
#ifndef WIN16
    CONTROL         "Tree1",IDC_CERT_TRUST_TREE_CHAIN,"SysTreeView32",
                    TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP,14,46,
                    184,127,WS_EX_CLIENTEDGE
#else
    CONTROL         "Tree1",IDC_CERT_TRUST_TREE_CHAIN,"IE_SysTreeView",
                    TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP,14,46,
                    184,127
#endif // !WIN16
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,18,20
END

IDD_DIALOG_CERT_ADVANCED DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "View additional properties for this digital ID here.",
                    IDC_CERT_ADVANCED_LABEL_EXPLAIN,36,12,169,11
    LTEXT           "&Field:",IDC_CERT_ADVANCED_LABEL_FIELD,7,39,28,8
#ifndef WIN16
    CONTROL         "List1",IDC_CERT_ADVANCED_LIST_FIELD,"SysListView32",
                    LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_AUTOARRANGE | LVS_NOCOLUMNHEADER | LVS_NOSORTHEADER |
                    WS_BORDER | WS_TABSTOP,7,49,69,121,WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_CERT_ADVANCED_LIST_FIELD,"IE_SysListView",
                    LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_AUTOARRANGE | LVS_NOCOLUMNHEADER | LVS_NOSORTHEADER |
                    WS_BORDER | WS_TABSTOP,7,49,69,121
#endif // !WIN16
    LTEXT           "Details:",IDC_CERT_ADVANCED_LABEL_DETAILS,77,39,28,8
#ifndef WIN16
    EDITTEXT        IDC_CERT_ADVANCED_EDIT_DETAILS,78,49,127,121,
                    ES_MULTILINE | ES_READONLY | WS_VSCROLL,WS_EX_CLIENTEDGE
#else
    EDITTEXT        IDC_CERT_ADVANCED_EDIT_DETAILS,78,49,127,121,
                    ES_MULTILINE | ES_READONLY | WS_VSCROLL
#endif // !WIN16
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,20,20
END
#endif //OLD_STUFF


//#define IDC_CERT_GENERAL_LABEL_TRUSTEDDATA 2225
/*
#define IDC_CERT_GENERAL_FRAME_STATUS       2208
#define IDC_CERT_GENERAL_ICON               2209
#define IDC_CERT_GENERAL_FRAME_ISSUED       2210
#define IDC_CERT_GENERAL_LABEL_CERTFOR      2211
#define IDC_CERT_GENERAL_LABEL_SERIALNUM    2212
#define IDC_CERT_GENERAL_LABEL_VALIDFROM    2213
#define IDC_CERT_GENERAL_LABEL_CERTFORDATA  2214
#define IDC_CERT_GENERAL_LABEL_SERIALNUMDATA 2215
#define IDC_CERT_GENERAL_LABEL_VALIDFROMDATA 2216
#define IDC_CERT_GENERAL_BUTTON_OPEN        2217
#define IDC_CERT_GENERAL_LABEL_ISSUER       2218
#define IDC_CERT_GENERAL_STATIC_STATUS      2219
#define IDC_CERT_GENERAL_LABEL_EXPIRED      2220
#define IDC_CERT_GENERAL_LABEL_REVOKED      2221
#define IDC_CERT_GENERAL_LABEL_EXPIREDDATA  2222
#define IDC_CERT_GENERAL_ICON_CHECK         2223
#define IDC_CERT_GENERAL_LABEL_REVOKEDDATA  2227
#define IDC_CERT_GENERAL_LABEL_TRUST        2228
#define IDC_CERT_GENERAL_COMBO_TRUST        2229
#define IDC_CERT_GENERAL_ICON_UNCHECK       2230

#define IDC_CERT_TRUST_FRAME_CHAIN      2231
#define IDC_CERT_TRUST_TREE_CHAIN       2232
#define IDC_CERT_TRUST_LABEL_EXPLAIN    2233

#define IDC_CERT_ADVANCED_LABEL_EXPLAIN 2234
#define IDC_CERT_ADVANCED_LIST_FIELD    2235
#define IDC_CERT_ADVANCED_EDIT_DETAILS  2236
#define IDC_CERT_ADVANCED_LABEL_FIELD   2237
#define IDC_CERT_ADVANCED_LABEL_DETAILS 2238
*/
//#define IDD_DIALOG_CERT_GENERAL         120
//#define IDD_DIALOG_CERT_TRUST           121
//#define IDD_DIALOG_CERT_ADVANCED        122


#endif // CERT_PROPS

// LDAP_PROPS
#ifdef OLD_STUFF
IDD_DIALOG_LDAP_ADD DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "Add, remove, and modify Internet directory services here. You will be able to search these directory services and check names against them.",
                    IDC_LDAP_ADD_STATIC_CAPTION,7,7,198,24
#ifndef WIN16
    CONTROL         "",IDC_LDAP_ADD_STATIC_ETCHED2,"Static",SS_ETCHEDHORZ,7,
                    36,198,1
#endif // !WIN16
    GROUPBOX        "Directory services:",IDC_LDAP_ADD_STATIC_LABELLIST1,7,
                    43,198,138
    PUSHBUTTON      "&Add",IDC_LDAP_ADD_BUTTON_ADD,16,61,48,14
    PUSHBUTTON      "Remo&ve",IDC_LDAP_ADD_BUTTON_DELETE,16,80,48,14
    PUSHBUTTON      "P&roperties",IDC_LDAP_ADD_BUTTON_PROPERTIES,16,99,48,14
#ifndef WIN16
    CONTROL         "List1",IDC_LDAP_ADD_LIST_ALL,"SysListView32",LVS_LIST |
                    LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,72,60,125,108,
                    WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_LDAP_ADD_LIST_ALL,"IE_SysListView",LVS_LIST |
                    LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,72,60,125,108
#endif // !WIN16
END


IDD_DIALOG_LDAP_PROPERTIES DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "&Friendly Name:",IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY,7,
                    29,60,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY,80,27,125,14,
                    ES_AUTOHSCROLL
    LTEXT           "&Directory Server:",IDC_LDAP_PROPS_STATIC_NAME,7,46,65,
                    8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NAME,80,43,125,14,ES_AUTOHSCROLL
    GROUPBOX        "&Authentication Type:",IDC_LDAP_PROPS_FRAME,7,64,198,
                    100,WS_GROUP
    CONTROL         "A&nonymous",IDC_LDAP_PROPS_RADIO_ANON,"Button",
                    BS_AUTORADIOBUTTON | WS_TABSTOP,17,77,125,10
    CONTROL         "&Secure Password (requires server support)",
                    IDC_LDAP_PROPS_RADIO_SICILY,"Button",BS_AUTORADIOBUTTON,
                    17,88,181,10
    CONTROL         "Pass&word",IDC_LDAP_PROPS_RADIO_USERPASS,"Button",
                    BS_AUTORADIOBUTTON,17,99,125,10
    LTEXT           "&User Name:",IDC_LDAP_PROPS_STATIC_USERNAME,17,116,40,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_USERNAME,80,112,118,14,
                    ES_AUTOHSCROLL
    LTEXT           "&Password:",IDC_LDAP_PROPS_STATIC_PASSWORD,17,131,40,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_PASSWORD,80,128,118,14,ES_PASSWORD |
                    ES_AUTOHSCROLL
    LTEXT           "&Confirm Password:",IDC_LDAP_PROPS_STATIC_PASSWORD2,17,
                    146,62,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,80,144,118,14,
                    ES_PASSWORD | ES_AUTOHSCROLL
    CONTROL         "Chec&k names against this server when sending mail.",
                    IDC_LDAP_PROPS_CHECK_NAMES,"Button",BS_AUTOCHECKBOX |
                    WS_TABSTOP,7,171,181,10
    LTEXT           "Add or modify information about an LDAP directory service.",
                    IDC_LDAP_PROPS_STATIC_CAPTION,7,7,198,10
#ifndef WIN16
    CONTROL         "",IDC_LDAP_PROPS_STATIC_ETCHED2,"Static",SS_ETCHEDHORZ,
                    8,21,197,1
#endif // !WIN16
END

IDD_DIALOG_LDAP_PROPERTIES_ADVANCED DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    GROUPBOX        "Search Parameters:",IDC_LDAP_PROPS_FRAME2,7,7,198,71
    LTEXT           "&Search time-out (in seconds):",
                    IDC_LDAP_PROPS_STATIC_SEARCH,16,28,132,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_SEARCH,162,26,35,14,ES_AUTOHSCROLL |
                    ES_NUMBER
    LTEXT           "&Maximum number of entries to return:",
                    IDC_LDAP_PROPS_STATIC_NUMRESULTS,15,53,137,9
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NUMRESULTS,162,50,35,14,
                    ES_AUTOHSCROLL | ES_NUMBER
    GROUPBOX        "Search &Base for this directory service",
                    IDC_LDAP_PROPS_FRAME_ROOT,7,88,198,43
    EDITTEXT        IDC_LDAP_PROPS_EDIT_ROOT,15,106,182,14,ES_AUTOHSCROLL
END

#define IDC_LDAP_SEARCH_BUTTON_REMOVE   6470
#define IDC_LDAP_SEARCH_LIST_SELECTED   6471
#define IDC_LDAP_SEARCH_BUTTON_UP       6472
#define IDC_LDAP_SEARCH_BUTTON_DOWN     6473
#define IDC_LDAP_SEARCH_STATIC_COUNTRY  6474
#define IDC_LDAP_SEARCH_COMBO_COUNTRY   6475
#define IDC_LDAP_SEARCH_STATIC_ETCHED2  6476
#define IDC_LDAP_SEARCH_STATIC_LABELLIST2 6477
#define IDC_LDAP_SEARCH_FRAME           6478
#define IDC_LDAP_SEARCH_STATIC_CAPTION  6479
#define IDC_LDAP_SEARCH_STATIC_LABELLIST1 6480
#define IDC_LDAP_SEARCH_LIST_DS         6481
#define IDC_LDAP_SEARCH_BUTTON_SELECT   6482

#define IDC_LDAP_ADD_BUTTON_ADD         5579
#define IDC_LDAP_ADD_BUTTON_DELETE      5580
#define IDC_LDAP_ADD_STATIC_CAPTION     5581
#define IDC_LDAP_ADD_BUTTON_PROPERTIES  5582
#define IDC_LDAP_ADD_STATIC_LABELLIST1  5583
#define IDC_LDAP_ADD_STATIC_ETCHED2     5584
#define IDC_LDAP_ADD_LIST_ALL           5585

#define IDC_LDAP_PROPS_STATIC_PASSWORD  5586
#define IDC_LDAP_PROPS_EDIT_CONNECTION  5587
#define IDC_LDAP_PROPS_EDIT_SEARCH      5588
#define IDC_LDAP_PROPS_EDIT_NAME        5589
#define IDC_LDAP_PROPS_EDIT_NUMRESULTS  5590
#define IDC_LDAP_PROPS_FRAME            5591
#define IDC_LDAP_PROPS_FRAME2           5592
#define IDC_LDAP_PROPS_STATIC_CONNECTION 5593
#define IDC_LDAP_PROPS_STATIC_SEARCH    5594
#define IDC_LDAP_PROPS_STATIC_NUMRESULTS 5595
#define IDC_LDAP_PROPS_EDIT_USERNAME    5596
#define IDC_LDAP_PROPS_EDIT_PASSWORD    5597
#define IDC_LDAP_PROPS_STATIC_NAME      5598
#define IDC_LDAP_PROPS_RADIO_ANON       5599
#define IDC_LDAP_PROPS_RADIO_SICILY     5600
#define IDC_LDAP_PROPS_RADIO_USERPASS   5601
#define IDC_LDAP_PROPS_STATIC_USERNAME  5602
#define IDC_LDAP_PROPS_FRAME_NUMRESULTS 5603
#define IDC_LDAP_PROPS_STATIC_PASSWORD2 5604
#define IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD 5605
#define IDC_LDAP_PROPS_CHECK_NAMES      5606
#define IDC_LDAP_PROPS_EDIT_ROOT        5608
#define IDD_DIALOG_LDAP_PROPERTIES_ADVANCED 5609
#define IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY 5610
#define IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY 5611
#define IDC_LDAP_PROPS_FRAME_ROOT       5612
#define IDC_LDAP_PROPS_RADIO_DEFAULTBASE 5613
#define IDC_LDAP_PROPS_RADIO_OTHERBASE  5614

#define IDD_DIALOG_LDAP_PROPERTIES      5540
#define IDD_DIALOG_LDAP_SEARCH          5541
#define IDD_DIALOG_LDAP_ADD             5542

#define IDC_LDAP_PROPS_STATIC_CAPTION   65
#define IDC_LDAP_PROPS_STATIC_ETCHED2   66

IDD_DIALOG_LDAP_SEARCH DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "If you have chosen to check names against one or more directory services, the directory services will be accessed in the order shown in the list below. Use the up and down buttons to change this order.",
                    IDC_LDAP_SEARCH_STATIC_CAPTION,16,21,181,35
    GROUPBOX        "&Change check names order:",IDC_LDAP_SEARCH_FRAME,7,6,
                    198,162
#ifndef WIN16
    CONTROL         "List1",IDC_LDAP_SEARCH_LIST_SELECTED,"SysListView32",
                    LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,16,69,124,77,
                    WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_LDAP_SEARCH_LIST_SELECTED,"IE_SysListView",
                    LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,16,69,124,77
#endif // !WIN16
    PUSHBUTTON      "&Up",IDC_LDAP_SEARCH_BUTTON_UP,148,115,49,14
    PUSHBUTTON      "&Down",IDC_LDAP_SEARCH_BUTTON_DOWN,148,132,49,14
END

#endif // OLD_STUFF


// LDAP_PROPERTIES
#ifdef OLD_LDAP_UI

extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;


enum _Propsheets
{
    propMain=0,
    propOptions,
    propMAX
};

enum _ReturnValues
{
    DS_CANCEL=0,
    DS_OK,
    DS_ERROR
};


// Whenever we add a new server, we put it in a linked list so we'll be able to
// regress if the user hits cancel after adding a couple of entries
typedef struct _NewServer
{
    TCHAR szName[MAX_UI_STR];
    struct _NewServer * lpNext;
} NEW_SERVER, *LPNEW_SERVER;



// Params passed to the property sheets
typedef struct _DSUILV
{
    HWND hWndMainLV;
    HWND hWndResolveOrderLV;
    int nRetVal;
    LPNEW_SERVER lpNewServerList; // if servers added and we hit cancel, we use this list to remove newly added servers
    LPNEW_SERVER lpOldServerList; // if servers modified and we hit ok, we use this list to remove old servers
} DSUILV, * LPDSUILV;


#define hlvM (lpdsuiLV->hWndMainLV)
#define hlvR (lpdsuiLV->hWndResolveOrderLV)



/*
* Prototypes
*/
HRESULT HrInitLDAPListView(HWND hWndLV);

void LDAPListAddItem(HWND hWndLV, LPTSTR lpszItemText);

BOOL ReadLDAPServers(HWND hWndLV, LPTSTR szValueName);

void DeleteLDAPServers(HWND hDlg);

void ProcessOKMessage(HWND hDlg, LPDSUILV lpdsuiLV, int nPropSheet);

void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp);

BOOL SetDSUI(HWND hDlg,int nPropSheet, LPDSUILV lpdsuiLV);

BOOL FillDSUI(HWND hDlg,int nPropSheet, LPDSUILV lpdsuiLV);

int CreateDSPropSheets(HWND hwndOwner, LPDSUILV lpdsuiLV);

BOOL APIENTRY_16 fnDSMainProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);

BOOL APIENTRY_16 fnDSOptionsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);

void SetUpDownButtons(HWND hDlg, HWND hWndLV);

BOOL SynchronizeLVContentsForward(HWND hDlg, LPDSUILV lpdsuiLV);

BOOL SynchronizeLVContentsBackward(HWND hDlg, LPDSUILV lpdsuiLV);

void ShowDSProps(HWND hDlg, BOOL bAddNew, LPDSUILV lpdsuiLV);

BOOL ReadLDAPServerKey(HWND hWndLV, LPTSTR szValueName);

void WriteLDAPServerKey(HWND hWndLV, LPTSTR szValueName);


// Help IDs
static DWORD rgDsMainHelpIDs[] =
{
    IDC_LDAP_ADD_STATIC_LABELLIST1, IDH_WABLDAP_DIR_SER_LIST,
    IDC_LDAP_ADD_LIST_ALL,          IDH_WABLDAP_DIR_SER_LIST,
    IDC_LDAP_ADD_BUTTON_ADD,        IDH_WABLDAP_GEN_ADD,
    IDC_LDAP_ADD_BUTTON_DELETE,     IDH_WABLDAP_GEN_REMOVE,
    IDC_LDAP_ADD_BUTTON_PROPERTIES, IDH_WABLDAP_GEN_PROPERTIES,
    0,0
};

static DWORD rgDsOptHelpIDs[] =
{
    IDC_LDAP_SEARCH_STATIC_LABELLIST2,  IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST,
    IDC_LDAP_SEARCH_LIST_SELECTED,      IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST,
    IDC_LDAP_SEARCH_BUTTON_UP,          IDH_WABLDAP_OPT_UP,
    IDC_LDAP_SEARCH_BUTTON_DOWN,        IDH_WABLDAP_OPT_DOWN,
    0,0
};

//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
#ifdef OLD_LDAP_UI
    DSUILV dsuiLV = {0};
#endif // OLD_LDAP_UI
    IImnAccountManager * lpAccountManager;

#ifdef OLD_LDAP_UI
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }
#endif // OLD_LDAP_UI

    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

#ifdef OLD_LDAP_UI
    dsuiLV.nRetVal = DS_ERROR;
    dsuiLV.lpNewServerList = NULL;
    dsuiLV.lpOldServerList = NULL;

    // show dialog
    if(-1 == CreateDSPropSheets(hWndParent,&dsuiLV))
    {
        DebugPrintError(("Directory Service dialog failed\n"));
        hr = E_FAIL;
        goto out;
    }

    // Free any allocated memory
    while(dsuiLV.lpNewServerList)
    {
        LPNEW_SERVER lpTemp = dsuiLV.lpNewServerList;
        dsuiLV.lpNewServerList = lpTemp->lpNext;
        if(dsuiLV.nRetVal == DS_CANCEL)
            SetLDAPServerParams(lpTemp->szName, NULL);
        LocalFree(lpTemp);
    }

    // Free any allocated memory
    while(dsuiLV.lpOldServerList)
    {
        LPNEW_SERVER lpTemp = dsuiLV.lpOldServerList;
        dsuiLV.lpOldServerList = lpTemp->lpNext;
        if(dsuiLV.nRetVal == DS_OK)
            SetLDAPServerParams(lpTemp->szName, NULL);
        LocalFree(lpTemp);
    }


    switch(dsuiLV.nRetVal)
    {
    case DS_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case DS_OK:
        hr = S_OK;
        break;
    case DS_ERROR:
        hr = E_FAIL;
        break;
    }
#endif // OLD_LDAP_UI

out:
    return hr;
}

#ifdef OLD_LDAP_UI

#define m_lpDSUILV              ((LPDSUILV) pps->lParam)
#define m_hWndMainLV            (m_lpDSUILV->hWndMainLV)
#define m_hWndResolveOrderLV    (m_lpDSUILV->hWndResolveOrderLV)
#define m_nRetVal               (m_lpDSUILV->nRetVal)

/*//$$***********************************************************************
*    FUNCTION: fnDSMainProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSMainProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        // Save the lparam for later use
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        // Setup the UI
        SetDSUI(hDlg,propMain,m_lpDSUILV);

        // Fill in the UI
        FillDSUI(hDlg,propMain,m_lpDSUILV);
        return TRUE;

    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsMainHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsMainHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_LDAP_ADD_BUTTON_DELETE:
            DeleteLDAPServers(hDlg);
            break;

        case IDC_LDAP_ADD_BUTTON_ADD:
            ShowDSProps(hDlg, TRUE, m_lpDSUILV);
            break;

        case IDC_LDAP_ADD_BUTTON_PROPERTIES:
            ShowDSProps(hDlg, FALSE, m_lpDSUILV);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            SynchronizeLVContentsBackward(hDlg, m_lpDSUILV);
            break;

        case PSN_APPLY:         //ok
            ProcessOKMessage(hDlg,m_lpDSUILV,propMain);
            m_nRetVal = DS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            m_nRetVal = DS_CANCEL;
            break;
        }

		switch((int) wParam)
		{
		case IDC_LDAP_ADD_LIST_ALL:
            switch(((NM_LISTVIEW *)lParam)->hdr.code)
	        {
	        case LVN_KEYDOWN:
                switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                {
                case VK_DELETE:
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_LDAP_ADD_BUTTON_DELETE, 0);
                    return 0;
                    break;
                }
                break;

            case NM_DBLCLK:
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_LDAP_ADD_BUTTON_PROPERTIES, 0);
                return 0;
                break;
            }
			break;
		}

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnDSOptionsProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSOptionsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        SetDSUI(hDlg,propOptions,m_lpDSUILV);
        FillDSUI(hDlg,propOptions,m_lpDSUILV);
        return TRUE;

    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsOptHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsOptHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_LDAP_SEARCH_BUTTON_UP:
            MoveLDAPItemUpDown(hDlg, TRUE);
            break;

        case IDC_LDAP_SEARCH_BUTTON_DOWN:
            MoveLDAPItemUpDown(hDlg, FALSE);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            SynchronizeLVContentsForward(hDlg, m_lpDSUILV);
            break;

        case PSN_APPLY:         //ok
            ProcessOKMessage(hDlg,m_lpDSUILV,propOptions);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
//            lpLSP->nRetVal = DL_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}



/*//$$***************************************************************************
*    FUNCTION: CreateDSPropSheets(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
int CreateDSPropSheets( HWND hwndOwner, LPDSUILV lpdsuiLV )
{
    PROPSHEETPAGE psp[propMAX];
    PROPSHEETHEADER psh;
    TCHAR szBuf[propMAX][MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    psp[propMain].dwSize = sizeof(PROPSHEETPAGE);
    psp[propMain].dwFlags = PSP_USETITLE;
    psp[propMain].hInstance = hinstMapiX;
    psp[propMain].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_ADD);
    psp[propMain].pszIcon = NULL;
    psp[propMain].pfnDlgProc = (DLGPROC) fnDSMainProc;
    LoadString(hinstMapiX, idsGeneral, szBuf[propMain], sizeof(szBuf[propMain]));
    psp[propMain].pszTitle = szBuf[propMain];
    psp[propMain].lParam = (LPARAM) lpdsuiLV;

    psp[propOptions].dwSize = sizeof(PROPSHEETPAGE);
    psp[propOptions].dwFlags = PSP_USETITLE;
    psp[propOptions].hInstance = hinstMapiX;
    psp[propOptions].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_SEARCH);
    psp[propOptions].pszIcon = NULL;
    psp[propOptions].pfnDlgProc = (DLGPROC) fnDSOptionsProc;
    LoadString(hinstMapiX, idsOptions, szBuf[propOptions], sizeof(szBuf[propMain]));
    psp[propOptions].pszTitle = szBuf[propOptions];
    psp[propOptions].lParam = (LPARAM) lpdsuiLV;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, idsDirectoryServices, szBuf2, sizeof(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propMain;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// SetDSUI - Sets the prop sheet UI
//
//  hDlg        - Parent HWND
//  nPropSheet  - Identifies the prop sheet being set
//  lpdsuiLV    - Dialog param info
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetDSUI(HWND hDlg,int nPropSheet,LPDSUILV lpdsuiLV)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propMain:
        lpdsuiLV->hWndMainLV = GetDlgItem(hDlg, IDC_LDAP_ADD_LIST_ALL);
        // Initialize the list view that displays the list of LDAP servers
        HrInitLDAPListView(lpdsuiLV->hWndMainLV);
        break;
    case propOptions:
        lpdsuiLV->hWndResolveOrderLV = GetDlgItem(hDlg, IDC_LDAP_SEARCH_LIST_SELECTED);
        // Initialize the list view that displays the list of LDAP servers
        HrInitLDAPListView(lpdsuiLV->hWndResolveOrderLV);
        break;
    }

    return TRUE;
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// FillDSUI - Fills in the UI fields with the given data
//
//  hDlg        - HWND of parent
//  nPropSheet  - identifies prop sheet being modified
//  lpdsuiLV    - lParam from dialog
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillDSUI(HWND hDlg,int nPropSheet,LPDSUILV lpdsuiLV)
{
    HWND hWndLV = NULL;

    switch(nPropSheet)
    {
    case propMain:
        hWndLV = GetDlgItem(hDlg, IDC_LDAP_ADD_LIST_ALL);

        // Read all the registered LDAP servers from the registry into
        // this list view
        ReadLDAPServerKey(hWndLV, szAllLDAPServersValueName);

        if(ListView_GetItemCount(hWndLV) <= 0)
        {
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),FALSE);
            EnableWindow(hWndLV,FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),TRUE);
            EnableWindow(hWndLV,TRUE);
        }

        SetFocus(GetNextDlgTabItem(hDlg, GetDlgItem(hDlg, IDC_LDAP_ADD_STATIC_CAPTION), FALSE));

        break;


    case propOptions:
        break;
    }

    return TRUE;
}
#endif

#ifdef OLD_LDAP_UI
//$$///////////////////////////////////////////////////////////////////////////////
//
// DeleteLDAPServers - Deletes LDAP server entries form the Directory Services list
//
//  hDlg - HWND of dialog
//
/////////////////////////////////////////////////////////////////////////////////
void DeleteLDAPServers(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg,IDC_LDAP_ADD_LIST_ALL);
    TCHAR szBuf[MAX_UI_STR];

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    if(ListView_GetSelectedCount(hWndLV) > 0)
    {
        int iItemIndex = 0;

        if(IDYES == ShowMessageBox(hDlg, idsQuestionServerDeletion, MB_ICONEXCLAMATION  | MB_YESNO))
        {
            while(ListView_GetSelectedCount(hWndLV) > 0)
            {
                iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                szBuf[0]='\0';
                ListView_GetItemText(hWndLV,iItemIndex,0,szBuf,sizeof(szBuf));

                // Delete the registry key corerspnding to this entry
                if(lstrlen(szBuf))
                    SetLDAPServerParams(szBuf,NULL);

                // Delete the item from the list view
                ListView_DeleteItem(hWndLV, iItemIndex);
            }
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
        }

        if(ListView_GetItemCount(hWndLV) <= 0)
        {
            // no entries left
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),FALSE);
            EnableWindow(hWndLV,FALSE);
            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
            SetFocus(GetDlgItem(GetParent(hDlg),IDOK));
        }
        else
        {
            // some entries left - select the one closest to the last deleted ...
            if(ListView_GetSelectedCount(hWndLV) <= 0)
            {
                if(iItemIndex >= ListView_GetItemCount(hWndLV))
                    iItemIndex--;
                LVSelectItem(hWndLV, iItemIndex);
            }
        }
    }
    else
        ShowMessageBox(hDlg, idsSelectServersToDelete, MB_ICONEXCLAMATION | MB_OK);

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return;
}








//$$///////////////////////////////////////////////////////////////////////////////
//
// ProcessOKMessage - Processes the OK button being clicked
//
/////////////////////////////////////////////////////////////////////////////////
void ProcessOKMessage(HWND hDlg, LPDSUILV lpdsuiLV, int nPropSheet)
{

    TCHAR szBuf[MAX_UI_STR];

    switch(nPropSheet)
    {
    case propMain:
        SynchronizeLVContentsBackward(hDlg, lpdsuiLV);
        WriteLDAPServerKey(hlvM, szAllLDAPServersValueName);
        break;

    case propOptions:
        break;
    }


    return;
}



//$$////////////////////////////////////////////////////////////////////
//
// MoveLDAPitemUpDown - moves a selected item up or down in the list
//
////////////////////////////////////////////////////////////////////////
void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_LDAP_SEARCH_LIST_SELECTED);
    int iItemIndex = ListView_GetSelectedCount(hWndLV);
    int iListCount = ListView_GetItemCount(hWndLV);

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    if( iItemIndex != 1)
    {
        ShowMessageBox(hDlg,idsSelectOneMoveUpDown,MB_ICONEXCLAMATION | MB_OK);
    }
    else
    {
        TCHAR szBufItem[MAX_UI_STR];
        TCHAR szBufOtherItem[MAX_UI_STR];
        int iMoveToIndex = 0;

        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

        // Can't move beyond the first or last item
        if( ((iItemIndex == 0) && bMoveUp) ||
            ((iItemIndex == (iListCount-1)) && !bMoveUp) )
            goto out;

        iMoveToIndex = (bMoveUp) ? (iItemIndex - 1):(iItemIndex+1);

        // Basically since these list view items have no parameters of interest
        // other than the text, we can swap the text (looks cleaner)

        // Get the selected item text
        ListView_GetItemText(hWndLV, iItemIndex, 0, szBufItem, sizeof(szBufItem));
        ListView_GetItemText(hWndLV, iMoveToIndex, 0, szBufOtherItem, sizeof(szBufOtherItem));

        ListView_SetItemText(hWndLV, iMoveToIndex, 0, szBufItem);
        ListView_SetItemText(hWndLV, iItemIndex, 0, szBufOtherItem);
        LVSelectItem(hWndLV, iMoveToIndex);

        SetUpDownButtons(hDlg, hWndLV);

    }

out:
    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// SetUpDownButtons - Enables/Disables up and down buttons
//
////////////////////////////////////////////////////////////////////////////////////////
void SetUpDownButtons(HWND hDlg, HWND hWndLV)
{

    int iItemCount = ListView_GetItemCount(hWndLV);
    int iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    HWND hWndUp = GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_UP);
    HWND hWndDown = GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_DOWN);

    DebugPrintTrace(("--SetUpDownButtons--\n"));


    if(iItemCount <= 0)
    {
        EnableWindow(hWndUp, FALSE);
        EnableWindow(hWndDown, FALSE);
        SetFocus(GetDlgItem(GetParent(hDlg),IDOK));
    }
    else
    {
        EnableWindow(hWndUp, TRUE);
        EnableWindow(hWndDown, TRUE);
    }

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// SynchronizeLVContentsForward - this funciton attempts to synhronize the
//          List view contents between the various ListViews when going from main pane
//          to Options pane
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SynchronizeLVContentsForward(HWND hDlg, LPDSUILV lpdsuiLV)
{
    BOOL bRet = FALSE;

    int iItemIndex=0;


    // Basically we just want to enter all the entries with check names against them in
    // this list view

    SendMessage(hlvR, WM_SETREDRAW, (WPARAM) FALSE, 0);

    ListView_DeleteAllItems(hlvR);

    //
    // if there are no items in the original, wipe out and leave
    //
    if(ListView_GetItemCount(hlvM) <= 0)
    {
        EnableWindow(hlvR, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_DOWN), FALSE);
        bRet = TRUE;
        goto out;
    }
    else
    {
        // Look at all the items in the original one by one and if they have
        // the check names flag, enter them into hlvR
        int i,nIndex,nTotal;
        TCHAR szBuf[MAX_PATH];

        EnableWindow(hlvR, TRUE);
        for(i = 0; i < ListView_GetItemCount(hlvM); i++)
        {
            ListView_GetItemText(hlvM, i, 0, szBuf, sizeof(szBuf));
            if(lstrlen(szBuf))
            {
                LDAPSERVERPARAMS ldsp = {0};
                GetLDAPServerParams(szBuf, &(ldsp));

                if(ldsp.fResolve)
                {
                    // This is selected for resolving so we should add it to
                    // the selected items list
                    LDAPListAddItem(hlvR, szBuf);
                }

                FreeLDAPServerParams(ldsp);
            }
        }

    }


    LVSelectItem(hlvR, 0);

    SetUpDownButtons(hDlg, hlvR);

    bRet = TRUE;

out:

    SendMessage(hlvR, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return bRet;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  ShowDSProps(HWND hDlg, BOOL bAddNew);
//
//  Displays properties of a Directory Service or creates and adds a new one
//
////////////////////////////////////////////////////////////////////////////////////
void ShowDSProps(HWND hDlg, BOOL bAddNew, LPDSUILV lpdsuiLV)
{
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szOldName[MAX_UI_STR];
    int iItemIndex;

    HWND hWndLV = GetDlgItem(hDlg,IDC_LDAP_ADD_LIST_ALL);

    if(bAddNew)
    {
        szBuf[0]='\0';
    }
    else
    {
        int iItemCount = ListView_GetSelectedCount(hWndLV);

        if (iItemCount > 1)
        {
            ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_ACTION, MB_ICONINFORMATION | MB_OK);
            goto out;
        }
        else if(iItemCount == 0)
        {
            ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONINFORMATION | MB_OK);
            goto out;
        }

        // by now we should only have 1 selection

        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iItemIndex == -1)
            goto out;

        ListView_GetItemText(hWndLV, iItemIndex, 0, szBuf, sizeof(szBuf));

        if(!lstrlen(szBuf))
            goto out;

    }

    // Save the old name just in case we need it ... (eg. user modifies the name in the props)
    lstrcpy(szOldName,szBuf);

    if(!HR_FAILED(HrShowDSProps(hDlg,szBuf,bAddNew)))
    {
        if(bAddNew)
        {
            // Add this new string to the main list box
            if(lstrlen(szBuf))
                LDAPListAddItem(hWndLV, szBuf);

            // At this point of time, the new entry has been saved in the
            // registry. If the user now hits cancel, we want to remove
            // the newly entered entry from the registry so that it doesnt
            // show up later. To do this, we store a list of all newly added
            // names.
            {
                LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                if(lpTemp)
                {
                    lpTemp->lpNext = lpdsuiLV->lpNewServerList;
                    lstrcpy(lpTemp->szName, szBuf);
                    lpdsuiLV->lpNewServerList = lpTemp;
                }
            }
        }
        else
        {
            if(lstrcmpi(szOldName, szBuf))
            {
                // update the old name in the list ...
                ListView_SetItemText(hWndLV, iItemIndex, 0, szBuf);

                // At this point of time, the old entry name has been modified and we
                // have two keys in the registry - the old one and the new one
                // If the user hits cancel we want to remove the new entries
                // If the user hits ok, we want to remove the old entries
                {
                    LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                    if(lpTemp)
                    {
                        lpTemp->lpNext = lpdsuiLV->lpOldServerList;
                        lstrcpy(lpTemp->szName, szOldName);
                        lpdsuiLV->lpOldServerList = lpTemp;
                    }
                }
                //
                // Again, we also want the new name of the entry so that if the user
                // hits cancel, we can revert back to the old name.
                //
                {
                    LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                    if(lpTemp)
                    {
                        lpTemp->lpNext = lpdsuiLV->lpNewServerList;
                        lstrcpy(lpTemp->szName, szBuf);
                        lpdsuiLV->lpNewServerList = lpTemp;
                    }
                }
            }
        }
    }

    if(ListView_GetItemCount(hWndLV) > 0)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),TRUE);
        EnableWindow(hWndLV,TRUE);
        SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
    }

out:
    return;

}
#endif
#ifdef OLD_LDAP_UI
//$$////////////////////////////////////////////////////////////////////////////////
//
// SynchronizeLVContentsBackward(LPDSUILV lpdsuiLV) - this funciton attempts to synhronize the
//          List view contents between the various ListViews when going from Options pane
//          to main pane - basically what we want to do is to preserve the order of the
//          resolveNames list views ... when modifications have been made in the resolvenames
//          list view, we change the order of the main list view to reflect that change
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SynchronizeLVContentsBackward(HWND hDlg, LPDSUILV lpdsuiLV)
{
    BOOL bRet = FALSE;
    int i=0,iItemIndex=0;
    TCHAR szBuf[MAX_PATH];


    if(!hlvR)
    {
        // Didnt go to the options pane
        // Leave things as they are
        bRet = TRUE;
        goto out;
    }

    //
    // Easy way to do this ...
    // Delete all the entries in hlvM that occur in hlvR and then add hlvR items one by one
    //

    SendMessage(hlvM, WM_SETREDRAW, (WPARAM) FALSE, 0);

    for(i = 0; i < ListView_GetItemCount(hlvR); i++)
    {
        ListView_GetItemText(hlvR, i, 0, szBuf, sizeof(szBuf));
        if(lstrlen(szBuf))
        {
            LV_FINDINFO lvfi = {0};
            int iItemIndex;
            lvfi.flags = LVFI_STRING;
            lvfi.psz = szBuf;

            iItemIndex = ListView_FindItem(hlvM, -1, &lvfi);
            if(iItemIndex != -1)
            {
                ListView_DeleteItem(hlvM, iItemIndex);
            }
        }
    }

    for(i = 0; i < ListView_GetItemCount(hlvR); i++)
    {
        ListView_GetItemText(hlvR, i, 0, szBuf, sizeof(szBuf));
        if(lstrlen(szBuf))
        {
            LDAPListAddItem(hlvM, szBuf);
        }
    }

    LVSelectItem(hlvM, 0);

    bRet = TRUE;

out:

    SendMessage(hlvM, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return(bRet);

}
#endif // OLD_LDAP_UI


//$$///////////////////////////////////////////////////////////////////////////////
//
// LDAPListAddItem - adds an item to the LDAP list view controls
//
//  hWndLV  - HWND of List View
//  lpszItemText - Name of item to add to list view
//
/////////////////////////////////////////////////////////////////////////////////
void LDAPListAddItem(HWND hWndLV, LPTSTR lpszItemText)
{
    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.pszText = lpszItemText;
    lvi.iImage = imageDirectoryServer;
        lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;

    ListView_InsertItem(hWndLV, &lvi);

    LVSelectItem(hWndLV, lvi.iItem);

    return;

}


/*************************************************************************
//$$
//  HrInitLDAPListView - Initializes the two list views on this dialog
//          so they look nice
//
//  hWndLV - handle of list view
//
**************************************************************************/
HRESULT HrInitLDAPListView(HWND hWndLV)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
	HIMAGELIST hSmall=NULL;

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(dwLVStyle & LVS_EDITLABELS)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS));

    hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

	lvC.cx = 250; //<TBD> - change this hardcoding
	lvC.pszText = NULL;

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(("ListView_InsertColumn Failed\n"));
		hr = E_FAIL;
		goto out;
	}


out:	

	return hr;
}


#endif // OLD_LDAP_UI



#ifdef URL_CHAR_ESCAPING
// URLs are filled with escape characters, we need to replace these
// with regular characters ...
//
static const TCHAR szEsc1[]="%20";
static const TCHAR szEsc2[]="%3C";
static const TCHAR szEsc3[]="%3E";
static const TCHAR szEsc4[]="%23";
static const TCHAR szEsc5[]="%25";
static const TCHAR szEsc6[]="%7B";
static const TCHAR szEsc7[]="%7D";
static const TCHAR szEsc8[]="%7C";
static const TCHAR szEsc9[]="%74";
static const TCHAR szEsc10[]="%5E";
static const TCHAR szEsc11[]="%7E";
static const TCHAR szEsc12[]="%5B";
static const TCHAR szEsc13[]="%5D";
static const TCHAR szEsc14[]="%60";

#define MAX_ESC_CHAR 14

const TCHAR * szEsc[] =
{   szEsc1,     szEsc2,     szEsc3,
    szEsc4,     szEsc5,     szEsc6,
    szEsc7,     szEsc8,     szEsc9,
    szEsc10,    szEsc11,    szEsc12,
    szEsc13,    szEsc14  
};


const char cEscChar[] =
{
    ' ',        '<',        '>',
    '#',        '%',        '{',
    '}',        '|',        '\\',
    '^',        '~',        '[',
    ']',        '`'  
};


/*
-
-  ReplaceURLIllegalChars
-
*  Replaces illegal chars in a URL with escaped strings as per some RFC
*  Makes a copy of the input string and then copies it back onto the input string
*  Assumes that input string was big enough to handle all replacements
*/
void ReplaceURLIllegalChars(LPTSTR lpURL)
{
    LPTSTR lpTemp = NULL,lp=NULL, lp1=NULL;
    int i = 0;
    if(!lpURL)
        return;
    if(!(lpTemp = LocalAlloc(LMEM_ZEROINIT, 2*lstrlen(lpURL)+1)))
        return;
    lstrcpy(lpTemp, lpURL);
    lp = lpURL;
    lp1 = lpTemp;
    while(lp && *lp)
    {
        for(i=0;i<MAX_ESC_CHAR;i++)
        {
            if(*lp == cEscChar[i])
            {
                lstrcpy(lp1, szEsc[i]);
                lp1 += lstrlen(szEsc[i])-1;
                lstrcat(lp1, CharNext(lp));
                break;
            }
        }
        lp=CharNext(lp);
        lp1=CharNext(lp1);
    }
    lstrcpy(lpURL, lpTemp);
    LocalFreeAndNull(&lpTemp);
}


/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare
                bCmpI - compare insensitive if TRUE, sensitive if false

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N, BOOL bCmpI) {
    int Result = 0;

    if (szString1 && szString2) {

        if(bCmpI)
        {
            szString1 = CharUpper(szString1);
            szString2 = CharUpper(szString2);
        }

        while (*szString1 && *szString2 && N)
        {
            N--;

            if (*szString1 != *szString2)
            {
                Result = 1;
                break;
            }

            szString1=CharNext(szString1);
            szString2=CharNext(szString2);
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    return(Result);
}

/************
//Fragment---

    // Make a copy of our URL
    lpsz = LocalAlloc(LMEM_ZEROINIT, lstrlen(szLDAPUrl)+1);
    if(!lpsz)
        goto exit;

    lstrcpy(lpsz, szLDAPUrl);

    // Since this is most likely a URL on an HTML page, we need to translate its escape
    // characters to proper characters .. e.g. %20 becomes ' ' ..
    {
        lpszTmp = lpsz;
        while(*lpszTmp)
        {
            if(*lpszTmp == '%')
            {
                int i;
                for(i=0;i<MAX_ESC_CHAR;i++)
                {
                    if(!StrICmpN(lpszTmp, (LPTSTR) szEsc[i], lstrlen(szEsc[i]), FALSE))
                    {
                        *lpszTmp = cEscChar[i];
                        lstrcpy(lpszTmp+1, lpszTmp+3);
                        break;
                    }
                }
            }
            lpszTmp = CharNext(lpszTmp);
        }
    }

/*************/
#endif

#ifdef MIGRATELDAPACCTS
static const LPTSTR lpRegNewServer = TEXT("Software\\Microsoft\\WAB\\Server Properties");
static const LPTSTR lpNewServer = TEXT("NewServers");

//*******************************************************************
//
//  FUNCTION:   bNewServersAvailable
//
//  PURPOSE:    Checks if there are new servers to migrate
//
//  RETURNS:    BOOL
//
//  COMMENTS:   If new servers exist, resets the reg setting
//
//*******************************************************************
BOOL bNewServersAvailable()
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpRegNewServer, 0, KEY_ALL_ACCESS, &hKey))
    {
        TCHAR szVal[16];
        ULONG cbVal = 16;
        DWORD dwType = 0;
        if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpNewServer, NULL, &dwType, (LPBYTE) szVal, &cbVal))
        {
            if(!lstrcmpi(szVal, "1"))
            {
                bRet = TRUE;
                // Reset the FLAG
                RegDeleteValue(hKey, lpNewServer);
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bRet;
}


        if(bNewServersAvailable())
        {
            // Migrate the settings from the old WAB installation
            MigrateOldLDAPAccounts(g_lpAccountManager, TRUE);
            // Migrate the settings from the new Setup
            // MigrateOldLDAPAccounts(g_lpAccountManager, FALSE);
        }




//*******************************************************************
//
//  FUNCTION:   MigrateOldLDAPServer
//
//  PURPOSE:    Read in old WAB 3.0 LDAP account information, write
//              it to the account manager and delete the old one.
//
//  PARAMETERS: lpAccountManager -> initialized account manager object.
//              hKeyServers = handle of old WAB/servers key
//              lpszServer = name of server to migrate
//
//  RETURNS:    none
//
//*******************************************************************
void MigrateOldLDAPServer(IImnAccountManager * lpAccountManager,
  HKEY hKeyServers, LPTSTR lpszServer) {
    LDAPSERVERPARAMS spParams = {0};
    DWORD dwErr, dwType, dwValue, dwSize;
    HKEY hKey = NULL;
    TCHAR szTemp[1];
    LPBYTE lpbPassword = NULL;


    // Set defaults for each value
    spParams.dwSearchSizeLimit = LDAP_SEARCH_SIZE_LIMIT;
    spParams.dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
    spParams.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
    spParams.lpszUserName = NULL;
    spParams.lpszPassword = NULL;
    spParams.lpszURL = NULL;
    spParams.lpszBase = NULL;
    spParams.lpszName = NULL;
    spParams.lpszLogoPath = NULL;
    spParams.fResolve = FALSE;
    spParams.dwID = 0xFFFFFFFF;     // default to end
    spParams.dwPort = LDAP_DEFAULT_PORT;
    spParams.dwUseBindDN = 0;
    spParams.fSimpleSearch = FALSE;

    // Open the key for this LDAP server
    if (dwErr = RegOpenKeyEx(hKeyServers,
      lpszServer,
      0,
      KEY_READ,
      &hKey)) {
        DebugTrace("Migrate couldn't open server key %s -> %u\n", lpszServer, dwErr);
        return;
    }

    // Read server ID
    dwErr = RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPServerID,
      &dwValue);
    if ((! dwErr) && dwValue) {
        spParams.dwID = dwValue;
    } else {
        spParams.dwID = GetLDAPNextServerID(0);
    }

    // Read server search size limit
    dwErr = RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSearchSizeLimit,
      &dwValue);
    if ((! dwErr) && dwValue) {
        spParams.dwSearchSizeLimit = dwValue;
    }

    // Read server search time limit
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSearchTimeLimit,
      &dwValue)) {
        spParams.dwSearchTimeLimit = dwValue;
    }

    // Read the authentication type
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPAuthMethod,
      &dwValue)) {
        spParams.dwAuthMethod = dwValue;
    }

    // Read username and password if auth type is LDAP_AUTH_METHOD_SIMPLE
    if (LDAP_AUTH_METHOD_SIMPLE == spParams.dwAuthMethod) {
        // Read the user name
// BUGBUG: Should make a function out of this section for improved code size and readability!

        dwSize = 1;         // Expect ERROR_MORE_DATA
        if (RegQueryValueEx(hKey,
          (LPTSTR)szLDAPAuthUserName,
          NULL,
          &dwType,
          szTemp,
          &dwSize) == ERROR_MORE_DATA) {
            // Allocate space for the string
            if (spParams.lpszUserName = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
                // Try again with sufficient buffer
                RegQueryValueEx(hKey,
                  (LPTSTR)szLDAPAuthUserName,
                  NULL,
                  &dwType,
                  spParams.lpszUserName,
                  &dwSize);
            }
        }
// BUGBUG: END

        // Read the password
        dwSize = 1;         // Expect ERROR_MORE_DATA
        if (RegQueryValueEx(hKey,
          (LPTSTR)szLDAPAuthPassword,
          NULL,
          &dwType,
          szTemp,
          &dwSize) == ERROR_MORE_DATA) {
            // Allocate space for the string
            if (lpbPassword = (LPBYTE)LocalAlloc(LPTR, dwSize + 1)) {
                // Try again with sufficient buffer
                if (! (dwErr = RegQueryValueEx(hKey,
                  (LPTSTR)szLDAPAuthPassword,
                  NULL,
                  &dwType,
                  lpbPassword,
                  &dwSize))) {
                    // Decrypt the password
                    EncryptDecryptText(lpbPassword, dwSize);
                    lpbPassword[dwSize] = '\0';
                    spParams.lpszPassword = (LPTSTR)lpbPassword;
                }
            }
        }

        // If user name is missing, use anonymous authentication.
        if (NULL == spParams.lpszUserName) {
            spParams.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
        }
    }

    // Read Resolve flag
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPResolveFlag,
      &dwValue)) {
        spParams.fResolve = (BOOL)dwValue;
    }

    // Read the Search Base
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPSearchBase,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszBase = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPSearchBase,
              NULL,
              &dwType,
              spParams.lpszBase,
              &dwSize);
        }
    }

    // Read the Server Name
    dwSize = 1;           // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerName,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszName = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerName,
              NULL,
              &dwType,
              spParams.lpszName,
              &dwSize);
        }
    } else {
        // use the given friendly name as the server name (this is for compatibility with when
        // we didnt have friendly names ...
        if (spParams.lpszName = (LPTSTR)LocalAlloc(LPTR, lstrlen(lpszServer) + 1)) {
            lstrcpy(spParams.lpszName, lpszServer);
        }
    }


    // Read the Server Info URL
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerInfoURL,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszURL = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerInfoURL,
              NULL,
              &dwType,
              spParams.lpszURL,
              &dwSize);
        }
    }


     
    // Read the Advanced Search Attributes
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPAdvancedSearchAttr,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszAdvancedSearchAttr = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPAdvancedSearchAttr,
              NULL,
              &dwType,
              spParams.lpszAdvancedSearchAttr,
              &dwSize);
        }
    }

    

// Read the Server logo path
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerLogoPath,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszLogoPath = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerLogoPath,
              NULL,
              &dwType,
              spParams.lpszLogoPath,
              &dwSize);
        }
    }

    // Read the LDAP port
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPPort,
      &dwValue)) {
        spParams.dwPort = dwValue;
    }


    // Read the use Bind DN setting
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPUseBindDN,
      &dwValue)) {
        spParams.dwUseBindDN = dwValue;
    }


    // Read the Simple Search setting
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSimpleSearch,
      &dwValue)) {
        spParams.fSimpleSearch = (dwValue ? TRUE : FALSE);
    }


    RegCloseKey(hKey);


    // Write it to the account manager
    SetLDAPServerParams(
      lpszServer,
      &spParams);


    // Delete the key
    // BUGBUG: Won't work if key has sub-keys! (It shouldn't)

    // IE4 - dont delete this setting as it is in HKLM
    // RegDeleteKey(hKeyServers, lpszServer);
}


//*******************************************************************
//
//  FUNCTION:   MigrateOldLDAPAccounts
//
//  PURPOSE:    Read in old WAB 3.0 LDAP account information, write
//              it to the account manager and delete it from the
//              registry.
//
//  PARAMETERS: lpAccountManager -> initialized account manager object.
//              bMigrateOldWAB   -> if TRUE migrates old wab settings from
//                              a v1 installation. if FALSE, migrates new
//                              accounts from HKLM setup during setup
//  RETURNS:    none
//
//*******************************************************************
void MigrateOldLDAPAccounts(IImnAccountManager * lpAccountManager,
                            BOOL bMigrateOldWAB)
{
    BOOL      bRet = FALSE;
    HKEY      hKeyWAB = NULL;
    HKEY      hKeyServers = NULL;
    DWORD     dwErr;
    DWORD     dwType;
    DWORD     dwSize;
    TCHAR     szBuffer[512];
    ULONG     cbBuffer;
    DWORD     dwValue = 0;
    ULONG     ulSize;
    TCHAR     szTemp[1];
    LPBYTE    lpbPassword;
    DWORD     cMigrated = 0;
    LPTSTR    szLDAPServers = NULL;
    HRESULT   hResult = hrSuccess;
    DWORD     dwIndex = 0;

    // How many rows to migrate?
    if (! (dwErr = RegOpenKeyEx((bMigrateOldWAB ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE),
      szWABKey,
      0,
      KEY_ALL_ACCESS,
      &hKeyWAB))) {

        if (! RegOpenKeyEx(hKeyWAB,
          szLDAPServerPropsKey,
          0,
          KEY_ALL_ACCESS,
          &hKeyServers)) {
            // There is a Servers key

            // First, read in any servers which are "ordered"
            ulSize = 1;         // Expect ERROR_MORE_DATA
            if (dwErr = RegQueryValueEx(hKeyWAB,
              (LPTSTR)szAllLDAPServersValueName,
              NULL,
              &dwType,
              szTemp,
              &ulSize)) {
                if (dwErr == ERROR_MORE_DATA) {
                    if (szLDAPServers = LocalAlloc(LPTR, ulSize)) {
                        szLDAPServers[0] = '\0';    // init to empty string

                        // Try again with sufficient buffer
                        if (! RegQueryValueEx(hKeyWAB,
                          szAllLDAPServersValueName,
                          NULL,
                          &dwType,
                          szLDAPServers,
                          &ulSize)) {
                            DebugTrace("Found LDAP server registry key\n");

#ifdef OLD_STUFF
                                switch (dwType) {
                                case REG_BINARY:
                                // Some thing (probably setup) has given us binary data.
                                case REG_MULTI_SZ:
                                    break;

                                default:
                                    // Ignore it
                                    DebugTrace("Bad value of %s in registry\n", szAllLDAPServersValueName);
                                    Assert(FALSE);
                                    break;
                            }
#endif // OLD_STUFF
                        }

                        while (szLDAPServers && *szLDAPServers) {
                            MigrateOldLDAPServer(lpAccountManager, hKeyServers, szLDAPServers);
                            cMigrated++;

                            // move to next server in double null terminated string.
                            szLDAPServers += (lstrlen(szLDAPServers) + 1);
                        }

                        LocalFreeAndNull(&szLDAPServers);

                        // Get rid of the ordered servers key
                        // BUG - Dont delete v1 info
                        // RegDeleteValue(hKeyWAB, szAllLDAPServersValueName);
                    }
                }
                dwErr = 0;
            }

            dwIndex = 0;

            // Then read in any extra servers
            while (dwErr == 0) {
                cbBuffer = sizeof(szBuffer);
                if (dwErr = RegEnumKeyEx(hKeyServers,
                  dwIndex,
                  szBuffer,     // put server name here
                  &cbBuffer,
                  NULL,
                  NULL,
                  0,
                  NULL)) {
                    break;      // done
                }

                // Got a name, migrate it
                MigrateOldLDAPServer(lpAccountManager, hKeyServers, szBuffer);

                cMigrated++;
                dwIndex++;
            }

            if (cMigrated) {
                DebugTrace("Migrated %u LDAP server names from registry\n", cMigrated);
            }
            RegCloseKey(hKeyServers);
        }

        RegCloseKey(hKeyWAB);
    }
}


const LPTSTR szLDAPServersValueName     = "LDAP Servers";
const LPTSTR szLDAPServerName           = "Server Name";
const LPTSTR szLDAPServerInfoURL        = "Server Information URL";
const LPTSTR szLDAPSearchBase           = "Search Base";
const LPTSTR szLDAPServerPropsKey       = "Server Properties";
const LPTSTR szLDAPSearchSizeLimit      = "Search Size Limit";
const LPTSTR szLDAPSearchTimeLimit      = "Search Time Limit";
const LPTSTR szLDAPServerLogoPath       = "Logo";
const LPTSTR szLDAPClientSearchTimeout  = "Client Search Timeout";
const LPTSTR szLDAPDefaultAuthMethod    = "Default Authentication Method";
const LPTSTR szLDAPAuthMethod           = "Authentication Method";
const LPTSTR szLDAPAuthUserName         = "User Name";
const LPTSTR szLDAPAuthPassword         = "Password";
const LPTSTR szLDAPResolveFlag          = "Resolve";
const LPTSTR szLDAPServerID             = "ServerID";
const LPTSTR szLDAPNextAvailableServerID = "Server ID";
const LPTSTR szLDAPPort                 = "Port";
const LPTSTR szLDAPUseBindDN            = "Bind DN";
const LPTSTR szLDAPSimpleSearch         = "Simple Search";
const LPTSTR szLDAPAdvancedSearchAttr   = "Advanced Search Attributes";

extern const LPTSTR szLDAPServersValueName;
extern const LPTSTR szLDAPServerPropsKey;
extern const LPTSTR szLDAPSearchSizeLimit;
extern const LPTSTR szLDAPSearchTimeLimit;
extern const LPTSTR szLDAPClientSearchTimeout;
extern const LPTSTR szLDAPDefaultAuthMethod;
extern const LPTSTR szLDAPAuthMethod;
extern const LPTSTR szLDAPAuthUserName;
extern const LPTSTR szLDAPAuthPassword;
extern const LPTSTR szLDAPResolveFlag;
extern const LPTSTR szLDAPServerName;
extern const LPTSTR szLDAPServerInfoURL;
extern const LPTSTR szLDAPServerLogoPath;
extern const LPTSTR szLDAPSearchBase;
extern const LPTSTR szLDAPNextAvailableServerID;
extern const LPTSTR szLDAPServerID;
extern const LPTSTR szLDAPPort;
extern const LPTSTR szLDAPUseBindDN;
extern const LPTSTR szLDAPSimpleSearch;
extern const LPTSTR szLDAPAdvancedSearchAttr;


#endif

#ifdef mutil_c
#ifdef OLD_STUFF
/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> %s\n", *lppunk, SzDecodeScode(GetScode(hResult)));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : MergeProblemArrays

    Purpose   : Merge a problem array into another

    Parameters: lpPaDest -> destination problem array
                lpPaSource -> source problem array
                cDestMax = total number of problem slots in lpPaDest.  This
                  includes those in use (lpPaDest->cProblem) and those not
                  yet in use.

    Returns   : none

    Comment   :

***************************************************************************/
void MergeProblemArrays(LPSPropProblemArray lpPaDest,
  LPSPropProblemArray lpPaSource, ULONG cDestMax) {
    ULONG i, j;
    ULONG cDest;
    ULONG cDestRemaining;

    cDest = lpPaDest->cProblem;
    cDestRemaining = cDestMax - cDest;

    // Loop through the source problems, copying the non-duplicates into dest
    for (i = 0; i < lpPaSource->cProblem; i++) {
        // Search the Dest problem array for the same property
        for (j = 0; j < cDest; j++) {
            // should just compare PROP_IDs here, since we may be overwriting
            // some of the proptypes with PT_NULL elsewhere.
            if (PROP_ID(lpPaSource->aProblem[i].ulPropTag) == PROP_ID(lpPaDest->aProblem[j].ulPropTag)) {
                break;  // Found a match, don't copy this one.  Move along.
            }
        }

        if (j == lpPaDest->cProblem) {
            Assert(cDestRemaining);
            if (cDestRemaining) {
                // No matches, copy this problem from Source to Dest
                lpPaDest->aProblem[lpPaDest->cProblem++] = lpPaSource->aProblem[i];
                cDestRemaining--;
            } else {
                DebugTrace("MergeProblemArrays ran out of problem slots!\n");
            }
        }
    }
}


/***************************************************************************

    Name      : MapObjectNamedProps

    Purpose   : Map the named properties WAB cares about into the object.

    Parameters: lpmp -> IMAPIProp object
                lppPropTags -> returned array of property tags.  Note: Must
                be MAPIFreeBuffer'd by caller.

    Returns   : none

    Comment   : What a pain in the butt!
                We could conceivably improve performance here by caching the
                returned table and comparing the object's PR_MAPPING_SIGNATURE
                against the cache.

***************************************************************************/
HRESULT MapObjectNamedProps(LPMAPIPROP lpmp, LPSPropTagArray * lppPropTags) {
    static GUID guidWABProps = { /* efa29030-364e-11cf-a49b-00aa0047faa4 */
        0xefa29030,
        0x364e,
        0x11cf,
        {0xa4, 0x9b, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
    };

    ULONG i;
    LPMAPINAMEID lppmnid[eMaxNameIDs] = {NULL};
    MAPINAMEID rgmnid[eMaxNameIDs] = {0};
    HRESULT hResult = hrSuccess;


    // Loop through each property, setting up the NAME ID structures
    for (i = 0; i < eMaxNameIDs; i++) {

        rgmnid[i].lpguid = &guidWABProps;
        rgmnid[i].ulKind = MNID_STRING;             // Unicode String
        rgmnid[i].Kind.lpwstrName = rgPropNames[i];

        lppmnid[i] = &rgmnid[i];
    }

    if (hResult = lpmp->lpVtbl->GetIDsFromNames(lpmp,
      eMaxNameIDs,      // how many?
      lppmnid,
      MAPI_CREATE,      // create them if they don't already exist
      lppPropTags)) {
        if (HR_FAILED(hResult)) {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
            goto exit;
        } else {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
        }
    }

    Assert((*lppPropTags)->cValues == eMaxNameIDs);

    DebugTrace("PropTag\t\tType\tProp Name\n");
    // Loop through the property tags, filling in their property types.
    for (i = 0; i < eMaxNameIDs; i++) {
        (*lppPropTags)->aulPropTag[i] = CHANGE_PROP_TYPE((*lppPropTags)->aulPropTag[i],
          PROP_TYPE(rgulNamedPropTags[i]));
#ifdef DEBUG
        {
            TCHAR szBuffer[257];

            WideCharToMultiByte(CP_ACP, 0, rgPropNames[i], -1, szBuffer, 257, NULL, NULL);

            DebugTrace("%08x\t%s\t%s\n", (*lppPropTags)->aulPropTag[i],
              PropTypeString(PROP_TYPE((*lppPropTags)->aulPropTag[i])), szBuffer);
        }
#endif

    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : PreparePropTagArray

    Purpose   : Prepare a prop tag array by replacing placeholder props tags
                with their named property tags.

    Parameters: ptaStatic = static property tag array (input)
                pptaReturn -> returned prop tag array (output)
                pptaNamedProps -> returned array of named property tags
                    Three possibilities here:
                       + NULL pointer: no input PTA or output named
                           props PTA is returned.  This is less efficient since
                           it must call MAPI to get the named props array.
                       + good pointer to NULL pointer:  no input PTA, but
                           will return a good PTA of named props which can
                           be used in later calls on this object for faster
                           operation.
                       + good pointer to good pointer.  Use the input PTA instead
                           of calling MAPI to map props.  Returned contents must
                           be freed with MAPIFreeBuffer.
                lpObject = object that the properties apply to.  Required if
                    no input *pptaNamedProps is supplied, otherwise, NULL.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT PreparePropTagArray(LPSPropTagArray ptaStatic, LPSPropTagArray * pptaReturn,
  LPSPropTagArray * pptaNamedProps, LPMAPIPROP lpObject) {
    HRESULT hResult = hrSuccess;
    ULONG cbpta;
    LPSPropTagArray ptaTemp = NULL;
    LPSPropTagArray ptaNamedProps;
    ULONG i;

    if (pptaNamedProps) {
        // input Named Props PTA
        ptaNamedProps = *pptaNamedProps;
    } else {
        ptaNamedProps = NULL;
    }

    if (! ptaNamedProps) {
        if (! lpObject) {
            DebugTrace("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n");
            hResult = ResultFromScode(E_INVALIDARG);
            goto exit;
        }

        // Map the property names into the object
        if (hResult = MapObjectNamedProps(lpObject, &ptaTemp)) {
            DebugTrace("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n");
            goto exit;
        }
    }

    if (pptaReturn) {
        // Allocate a return pta
        cbpta = sizeof(SPropTagArray) + ptaStatic->cValues * sizeof(ULONG);
        if ((*pptaReturn = WABAlloc(cbpta)) == NULL) {
            DebugTrace("PreparePropTagArray WABAlloc(%u) failed\n", cbpta);
            hResult = ResultFromScode(E_OUTOFMEMORY);
            goto exit;
        }

        (*pptaReturn)->cValues = ptaStatic->cValues;

        // Walk through the ptaStatic looking for named property placeholders.
        for (i = 0; i < ptaStatic->cValues; i++) {
            if (IS_PLACEHOLDER(ptaStatic->aulPropTag[i])) {
                // Found a placeholder.  Turn it into a true property tag
                Assert(PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i]) < ptaNamedProps->cValues);
                (*pptaReturn)->aulPropTag[i] =
                   ptaNamedProps->aulPropTag[PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i])];
            } else {
                (*pptaReturn)->aulPropTag[i] = ptaStatic->aulPropTag[i];
            }
        }
    }

exit:
    if (hResult || ! pptaNamedProps) {
        FreeBufferAndNull(&ptaTemp);
    } else {
        // Client is responsible for freeing this.
        *pptaNamedProps = ptaNamedProps;
    }

    return(hResult);
}


/***************************************************************************

    Name      : OpenCreateProperty

    Purpose   : Open an interface on a property or create if non-existent.

    Parameters: lpmp -> IMAPIProp object to open prop on
                ulPropTag = property tag to open
                lpciid -> interface identifier
                ulInterfaceOptions = interface specific flags
                ulFlags = MAPI_MODIFY?
                lppunk -> return the object here

    Returns   : HRESULT

    Comment   : Caller is responsible for Release'ing the returned object.

***************************************************************************/
HRESULT OpenCreateProperty(LPMAPIPROP lpmp,
  ULONG ulPropTag,
  LPCIID lpciid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppunk) {

    HRESULT hResult;

    if (hResult = lpmp->lpVtbl->OpenProperty(
      lpmp,
      ulPropTag,
      lpciid,
      ulInterfaceOptions,
      ulFlags,
      (LPUNKNOWN *)lppunk)) {
        DebugTrace("OpenCreateProperty:OpenProperty(%s)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult)));
        // property doesn't exist... try to create it
        if (hResult = lpmp->lpVtbl->OpenProperty(
          lpmp,
          ulPropTag,
          lpciid,
          ulInterfaceOptions,
          MAPI_CREATE | ulFlags,
          (LPUNKNOWN *)lppunk)) {
            DebugTrace("OpenCreateProperty:OpenProperty(%s, MAPI_CREATE)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult)));
        }
    }

    return(hResult);
}
#endif // OLD_STUFF
#endif // mutil_c

#ifdef rk_c



#ifdef OLD_STUFF
//#ifdef OLDSTUFF_DBCS
#define chVoiced		0xde	//Japanese specific
#define	chVoiceless		0xdf	//Japanese specific
#define chDbcsVoiced	0x814a	//Japanese specific
#define	chDbcsVoiceless	0x814b	//Japanese specific
#define LangJPN			0x0411
/* =========================================================
*  ulcbStrCount()
*
*  Count the byte from szSource and ulChrLen
*
*    usChrLen : Char Count not bytes count
*/
ULONG
ulcbStrCount (LPTSTR szSource , ULONG ulChrLen, LANGID langID)
{
	ULONG	ulb = 0;
	ULONG	ulch = ulChrLen;
	LPTSTR	sz = szSource;

	while(ulch && *sz)
	{
		if (IsDBCSLeadByte(*sz))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiceless)))
				ulch--;
			sz += 2;
			ulb += 2;
		}
		else
		{
			if (langID != LangJPN ||
				((*sz != chVoiced) && (*sz != chVoiceless)))
				ulch--;
			sz++;
			ulb++;
		}
		
	}
	return ulb;
}

/* ========================================================
	ulchStrCount

	Count the Charctor from szSource and ulBLen

	ulBLen is bytes counts
*/
ULONG
ulchStrCount (LPTSTR szSource, ULONG ulBLen, LANGID langID)
{
	ULONG 	ulb = ulBLen;
	ULONG	ulch = 0;
	LPTSTR	sz = szSource;

	while(ulb && *sz)
	{
		if (IsDBCSLeadByte(*sz))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiceless)))
				ulch++;
			sz += 2;
			ulb -= 2;
		}
		else
		{
			if (langID != LangJPN ||
				((*sz != chVoiced) && (*sz != chVoiceless)))
				ulch++;
			sz++;
			ulb--;
		}
	}
	return ulch;
}


/* =========================================================
*  ulcbEndCount()
*
*  Count the byte from szSource and ulChrLen
*
*    usChrLen : Char Count not bytes count
*/
ULONG
ulcbEndCount(LPSTR szTarget, ULONG cbTarget, ULONG cchPattern, LANGID langID)
{
	LPBYTE	szStart;
	ULONG	cbEndTarget = 0;

	if (cbTarget < cchPattern)
		return 0;

	// This is to get the reasonable starting pointer of the string,
	// so we can imporve the performance in the SzGPrev().
	while(cbTarget > (cchPattern * 2))
	{
		if (IsDBCSLeadByte(*szTarget))
		{
			cbTarget -= 2;
			szTarget += 2;
		}
		else
		{
			cbTarget --;
			szTarget ++;
		}
	}
	
	szStart	= szTarget;
	szTarget= szTarget + cbTarget;

	while (cchPattern > 0)
	{
		const LPBYTE	szTargetOrg =  szTarget;
		szTarget = SzGPrev(szStart, szTarget);

		if(szTarget + 2 == szTargetOrg)	// same as if (IsDBCSLeadByte(szTarget))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)szTarget != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)szTarget != (WORD)chDbcsVoiceless)))
				cchPattern --;
			cbEndTarget++;
		}
		else if (*szTarget != chVoiced && *szTarget != chVoiceless)
		{
			cchPattern --;
		}
		cbEndTarget++;
	}
	return cbEndTarget;
}
//#endif	// DBCS
#endif //OLD_STUFF

#ifdef OLD_STUFF
#if		defined(WIN16)
#pragma	warning(disable:4505)	/* unreferenced local fuction removed */
#elif	defined(WIN32)
#pragma warning(disable:4514)	/* unreferenced inline function removed */
#endif // OLD_STUFF
#endif

#endif //rk_c

#ifdef _runt_h

#ifdef OLD_STUFF
// CRC-32 implementation (yet another)
ULONG		UlCrc(UINT cb, LPBYTE pb);
#endif

#endif

#ifdef _runt_c
#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindCh(LPCTSTR sz, USHORT ch)
{
	AssertSz(!IsBadStringPtr(sz, INFINITE), "SzFindCh: sz fails address check");

#ifdef OLDSTUFF_DBCS
	return SzGFindCh(sz, ch);
#else
	for (;;)
	{
		if (FIsNextCh(sz, ch))
			return (LPTSTR) sz;
		else if (!*sz)
			return NULL;
		else
			sz = TCharNext(sz);
	}
#endif
}
#endif // OLD_STUFF

#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindLastCh(LPCTSTR sz, USHORT ch)
{
	LPTSTR	szLast = NULL;
	LPTSTR	szNext = (LPTSTR) sz;

	AssertSz(!IsBadStringPtr(sz, INFINITE), "SzFindLastCh: sz fails address check");

#ifdef OLDSTUFF_DBCS
	szNext = sz + CbGSzLen(sz) - 2;
	return SzGFindBackCh(sz, szNext, ch);
#else
	do {
		if (szNext = SzFindCh(szNext, ch)) {
			szLast = szNext;
			szNext = TCharNext(szNext);
		}
	} while (szNext);

	return szLast;
#endif
}
#endif //OLD_STUFF

#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindSz(LPCTSTR sz, LPCTSTR szKey)
{
	AssertSz(!IsBadStringPtr(sz, 0xFFFF), "SzFindSz: sz fails address check");
	AssertSz(!IsBadStringPtr(szKey, 0xFFFF),  "SzFindSz: szKey fails address check");

#ifdef OLDSTUFF_DBCS
	return (LPTSTR)LpszRKFindSubpsz ((LPSTR)sz,
								CchGSzLen(sz),
								(LPSTR)szKey,
								CchGSzLen(szKey),
								0);
#else
	return (LPTSTR)LpszRKFindSubpsz ((LPSTR)sz,
								lstrlen(sz),
								(LPSTR)szKey,
								lstrlen(szKey),
								0);
#endif
}
#endif // OLD_STUFF

#endif _runt_c

#ifdef structs_h
#ifdef OLD_STUFF
/************************ IABProvider ***********************************/

typedef struct _tagIABProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IABProvider_Shutdown_Params, FAR * LPIABProvider_Shutdown_Params;

typedef struct _tagIABProvider_Logon_Params
{
        		LPVOID						This;
        		LPMAPISUP                   lpMAPISup;
                ULONG                       ulUIParam;
                LPTSTR                      lpszProfileName;
                ULONG                       ulFlags;
				ULONG FAR *					lpulpcbSecurity;
				LPBYTE FAR *				lppbSecurity;
                LPMAPIERROR FAR *			lppMapiError;
                LPABLOGON FAR *             lppABLogon;
} IABProvider_Logon_Params, FAR * LPIABProvider_Logon_Params;


/************************* IABLogon *************************************/

typedef struct _tagIABLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IABLogon_GetLastError_Params, FAR * LPIABLogon_GetLastError_Params;

typedef struct _tagIABLogon_Logoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IABLogon_Logoff_Params, FAR * LPIABLogon_Logoff_Params;

typedef struct _tagIABLogon_OpenEntry_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IABLogon_OpenEntry_Params, FAR * LPIABLogon_OpenEntry_Params;

typedef struct _tagIABLogon_CompareEntryIDs_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID1;
                LPENTRYID                   lpEntryID1;
                ULONG                       cbEntryID2;
                LPENTRYID                   lpEntryID2;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulResult;
} IABLogon_CompareEntryIDs_Params, FAR * LPIABLogon_CompareEntryIDs_Params;

typedef struct _tagIABLogon_Advise_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                ULONG                       ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IABLogon_Advise_Params, FAR * LPIABLogon_Advise_Params;

typedef struct _tagIABLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IABLogon_Unadvise_Params, FAR * LPIABLogon_Unadvise_Params;


typedef struct _tagIABLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IABLogon_OpenStatusEntry_Params, FAR * LPIABLogon_OpenStatusEntry_Params;

typedef struct _tagIABLogon_OpenTemplateID_Params
{
        		LPVOID						This;
        		ULONG                       cbTemplateID;
                LPENTRYID                   lpTemplateID;
                ULONG                       ulTemplateFlags;
                LPMAPIPROP                  lpMAPIPropData;
                LPIID                       lpInterface;
                LPMAPIPROP FAR *            lppMAPIPropNew;
                LPMAPIPROP                  lpMAPIPropSibling;
} IABLogon_OpenTemplateID_Params, FAR * LPIABLogon_OpenTemplateID_Params;

typedef struct _tagIABLogon_GetOneOffTable_Params
{
        		LPVOID						This;
				ULONG						ulFlags;
        		LPMAPITABLE FAR *           lppTable;
} IABLogon_GetOneOffTable_Params, FAR * LPIABLogon_GetOneOffTable_Params;

typedef struct _tagIABLogon_PrepareRecips_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPSPropTagArray				lpPropTagArray;
				LPADRLIST					lpRecipList;
} IABLogon_PrepareRecips_Params, FAR * LPIABLogon_PrepareRecips_Params;


/*********************** IXPProvider ************************************/

typedef struct _tagIXPProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IXPProvider_Shutdown_Params, FAR * LPIXPProvider_Shutdown_Params;

typedef struct _tagIXPProvider_TransportLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG FAR *					lpulFlags;
                LPMAPIERROR FAR *			lppMapiError;
				LPXPLOGON FAR *				lppXPLogon;
} IXPProvider_TransportLogon_Params, FAR * LPIXPProvider_TransportLogon_Params;


/************************ IXPLogon **************************************/

typedef struct _tagIXPLogon_AddressTypes_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcAdrType;
				LPTSTR FAR * FAR *			lpppAdrTypeArray;
				ULONG FAR *					lpcMAPIUID;
				LPMAPIUID FAR * FAR *		lpppUIDArray;
} IXPLogon_AddressTypes_Params, FAR * LPIXPLogon_AddressTypes_Params;

typedef struct _tagIXPLogon_RegisterOptions_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcOptions;
				LPOPTIONDATA FAR *			lppOptions;
} IXPLogon_RegisterOptions_Params, FAR * LPIXPLogon_RegisterOptions_Params;

typedef struct _tagIXPLogon_TransportNotify_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				LPVOID FAR *				lppvData;
} IXPLogon_TransportNotify_Params, FAR * LPIXPLogon_TransportNotify_Params;

typedef struct _tagIXPLogon_Idle_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_Idle_Params, FAR * LPIXPLogon_Idle_Params;

typedef struct _tagIXPLogon_TransportLogoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_TransportLogoff_Params, FAR * LPIXPLogon_TransportLogoff_Params;

typedef struct _tagIXPLogon_SubmitMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
				ULONG FAR *					lpulReturnParm;
} IXPLogon_SubmitMessage_Params, FAR * LPIXPLogon_SubmitMessage_Params;

typedef struct _tagIXPLogon_EndMessage_Params
{
				LPVOID						This;
				ULONG						ulMsgRef;
				ULONG FAR *					lpulFlags;
} IXPLogon_EndMessage_Params, FAR * LPIXPLogon_EndMessage_Params;

typedef struct _tagIXPLogon_Poll_Params
{
				LPVOID						This;
				ULONG FAR *					lpulIncoming;
} IXPLogon_Poll_Params, FAR * LPIXPLogon_Poll_Params;

typedef struct _tagIXPLogon_StartMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
} IXPLogon_StartMessage_Params, FAR * LPIXPLogon_StartMessage_Params;

typedef struct _tagIXPLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IXPLogon_OpenStatusEntry_Params, FAR * LPIXPLogon_OpenStatusEntry_Params;

typedef struct _tagIXPLogon_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IXPLogon_ValidateState_Params, FAR * LPIXPLogon_ValidateState_Params;

typedef struct _tagIXPLogon_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IXPLogon_FlushQueues_Params, FAR * LPIXPLogon_FlushQueues_Params;


/*********************** IMSProvider ************************************/

typedef struct _tagIMSProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSProvider_Shutdown_Params, FAR * LPIMSProvider_Shutdown_Params;
		
typedef struct _tagIMSProvider_Logon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG FAR *					lpcbSpoolSecurity;
				LPBYTE FAR *				lppbSpoolSecurity;
                LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_Logon_Params, FAR * LPIMSProvider_Logon_Params;
				
typedef struct _tagIMSProvider_SpoolerLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG						cbSpoolSecurity;
				LPBYTE						lpbSpoolSecurity;
				LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_SpoolerLogon_Params, FAR * LPIMSProvider_SpoolerLogon_Params;
				
typedef struct _tagIMSProvider_CompareStoreIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSProvider_CompareStoreIDs_Params, FAR * LPIMSProvider_CompareStoreIDs_Params;


/*************************** IMSLogon **********************************/

typedef struct _tagIMSLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMSLogon_GetLastError_Params, FAR * LPIMSLogon_GetLastError_Params;

typedef struct _tagIMSLogon_Logoff_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSLogon_Logoff_Params, FAR * LPIMSLogon_Logoff_Params;

typedef struct _tagIMSLogon_OpenEntry_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMSLogon_OpenEntry_Params, FAR * LPIMSLogon_OpenEntry_Params;

typedef struct _tagIMSLogon_CompareEntryIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSLogon_CompareEntryIDs_Params, FAR * LPIMSLogon_CompareEntryIDs_Params;

typedef struct _tagIMSLogon_Advise_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMSLogon_Advise_Params, FAR * LPIMSLogon_Advise_Params;

typedef struct _tagIMSLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IMSLogon_Unadvise_Params, FAR * LPIMSLogon_Unadvise_Params;

typedef struct _tagIMSLogon_OpenStatusEntry_Params
{
				LPVOID						This;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPVOID FAR *				lppEntry;
} IMSLogon_OpenStatusEntry_Params, FAR * LPIMSLogon_OpenStatusEntry_Params;


/*************************** IMAPIControl ******************************/

typedef struct _tagIMAPIControl_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIControl_GetLastError_Params, FAR * LPIMAPIControl_GetLastError_Params;
				
				
typedef struct _tagIMAPIControl_Activate_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG						ulUIParam;
} IMAPIControl_Activate_Params, FAR * LPIMAPIControl_Activate_Params;
				
				
typedef struct _tagIMAPIControl_GetState_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG FAR *					lpulState;
} IMAPIControl_GetState_Params, FAR * LPIMAPIControl_GetState_Params;

#endif
#endif //structs_h


#ifdef wabval_h
#ifdef OLD_STUFF

/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
			 CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
			 ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
			 CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
			 CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
			 ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
			 UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
			 CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
			 ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
			 UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
			 CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
			 CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
			 ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
			 CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
			 CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )

#endif

#endif //wabval



#ifdef WAB_PROFILES
#ifdef OLD_STUFF
/*
-   HrCreateNewProfileItem
-
*   Creates a new Profile Item and adds the default shared profile to this item
*
*/
HRESULT HrCreateNewProfileItem(LPWABPROFILEITEM * lppItem, LPTSTR lpszProfileID)
{
    HRESULT hr = E_FAIL;
    SCODE sc;
    LPWABPROFILEITEM lpProfile = LocalAlloc(LMEM_ZEROINIT, sizeof(WABPROFILEITEM));

    if(!lppItem)
        goto out;

    if(!lpProfile)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpProfile->lpszProfileID = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpszProfileID)+1);
    if(!lpProfile->lpszProfileID)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lstrcpy(lpProfile->lpszProfileID, lpszProfileID);
    //lpProfile->dwProfileID = dwEntryID;
    sc = MAPIAllocateBuffer(sizeof(SPropValue), &(lpProfile->lpspvFolders));
    if(sc)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpProfile->lpspvFolders[0].ulPropTag = PR_WAB_FOLDER_ENTRIES;
    lpProfile->lpspvFolders[0].Value.MVbin.cValues = 0;
    lpProfile->lpspvFolders[0].Value.MVbin.lpbin = NULL;

    // The folder item corresponding to the Shared folder is a 
    // virtual item with NULL entryid .. so add this virtual item to
    // the primary profile
    //
    AddPropToMVPBin(lpProfile->lpspvFolders, 0,
                     (LPVOID) NULL, 0, TRUE);

    *lppItem = lpProfile;

    hr = S_OK;
out:
    if(HR_FAILED(hr) && lpProfile)
        LocalFree(lpProfile);

    return hr;
 }

/*
-   HrLoadPrimaryWABProfile
-
-
*   Creates a primary profile which points to all existing folders in the
*   store - this profile is used when no profile ID is supplied so that the
*   UI can see everything
*   
*/
HRESULT HrLoadPrimaryWABProfile(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes = {0};
	SPropValue sp = {0};
    ULONG ulCount = 0;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG i = 0;
    LPWABPROFILEITEM lpProfile = NULL;

    // Now we will search the WAB for all objects of PR_OBJECT_TYPE = MAPI_ABCONT
    //

	sp.ulPropTag = PR_OBJECT_TYPE;
	sp.Value.l = MAPI_ABCONT;

    PropRes.ulPropTag = PR_OBJECT_TYPE;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = &sp;

    hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						NULL, 0,
                        TRUE,
                        &PropRes, &ulCount, &rgsbEntryIDs);

    if (HR_FAILED(hr))
        goto out;

    // we'll always create a default item, whether it has anything in it or not ..
    hr = HrCreateNewProfileItem(&lpProfile, szEmpty);
    if(HR_FAILED(hr) || !lpProfile)
        goto out;

    //if(ulCount && rgsbEntryIDs)
    {
        for(i=0;i<ulCount;i++)
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;

            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                            rgsbEntryIDs[i].lpb, NULL, NULL,
                                            rgsbEntryIDs[i].cb, 0,
                                            NULL, &cb, &lpb)))
            {
                // Add the entryids to this prop - ignore errors
                AddPropToMVPBin(lpProfile->lpspvFolders, 0, (LPVOID) lpb, cb, TRUE);
#ifdef DEBUG 
//////////////
                {
                    LPTSTR lp = NULL;
                    SBinary sb;
                    sb.cb = cb;sb.lpb = (LPBYTE)lpb;
                    HrGetProfileFolderName(lpIAB, &sb, &lp);
                    if(lp)
                    {
                        DebugTrace("Found Folder: %s\n",lp);
                        LocalFree(lp);
                    }
                }
//////////////
#endif 
                MAPIFreeBuffer(lpb);
            }
        }

        lpProfile->lpNext = lpIAB->lpProfilesList;
        lpIAB->lpProfilesList = lpProfile;
    }

    hr = S_OK;
out:
    if(ulCount && rgsbEntryIDs)
    {
        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                    ulCount,
                    rgsbEntryIDs);
    }
    return hr;
}



static const char szProfileKey[] = "Software\\Microsoft\\WAB\\WAB4\\Profiles";

/*
-   HrLoadSecondaryWABProfiles
-
-
*   Creates secondary profiles which are based on profiles actually saved in the registry
*   
*/
HRESULT HrLoadSecondaryWABProfiles(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    ULONG ulCount = 0, i = 0;
    LPWABPROFILEITEM lpProfile = NULL;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, szProfileKey, 0, KEY_READ, &hKey))
    {
        hr = S_OK; // ignore this error
        goto out;
    }

    {
        TCHAR szValName[MAX_PATH];
        DWORD dwValIndex = 0, dwValSize = sizeof(szValName), dwType = 0;

        *szValName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwValIndex, 
                                            szValName, &dwValSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The value names under this entry are the profiles IDs and the
            // Value data is the raw folder data we care about
            //
            if(dwType == REG_BINARY && lstrlen(szValName))
            {
                //Read in the Value
                if(ERROR_SUCCESS == RegQueryValueEx(hKey, szValName, 0, &dwType, 
                                                    NULL, &dwValSize))
                {
                    LPTSTR lpsz = LocalAlloc(LMEM_ZEROINIT, dwValSize);
                    if(lpsz)
                    {
                        if(ERROR_SUCCESS == RegQueryValueEx(hKey, szValName, 0, &dwType, 
                                                            (LPBYTE) lpsz, &dwValSize))
                        {
                            LPSPropValue lpProp = NULL;
                            ULONG ulCount = 0;

                            hr = HrGetPropArrayFromBuffer(lpsz, dwValSize, 1, 0, &lpProp); 
                            if(!HR_FAILED(hr) && lpProp && lpProp->ulPropTag == PR_WAB_FOLDER_ENTRIES)
                            {
                                hr = HrCreateNewProfileItem(&lpProfile, szValName);
                                if(HR_FAILED(hr) || !lpProfile)
                                    goto out;

                                for(i=0;i<lpProp->Value.MVbin.cValues;i++)
                                {
                                    if(lpProp->Value.MVbin.lpbin[i].lpb && lpProp->Value.MVbin.lpbin[i].cb)
                                    {
                                        LPSPropValue lpPropArray = NULL;
                                        ULONG ulcValues = 0;
                                        // Verify that this folder actually physically exists - it might have been deleted
                                        if(!HR_FAILED(ReadRecord(   lpIAB->lpPropertyStore->hPropertyStore, 
                                                                    &(lpProp->Value.MVbin.lpbin[i]),
                                                                    0, &ulcValues, &lpPropArray)))
                                        {
                                            // Add the entryids to this prop - ignore errors
                                            // Dont add the default shared folder as thats alreadybeen added
                                            ULONG cb = lpProp->Value.MVbin.lpbin[i].cb;
                                            LPENTRYID lpb = (LPENTRYID) lpProp->Value.MVbin.lpbin[i].lpb;

                                            if(WAB_CONTAINER != IsWABEntryID(cb,lpb,NULL,NULL,NULL,NULL,NULL))
                                            {
                                                CreateWABEntryID( WAB_CONTAINER,lpProp->Value.MVbin.lpbin[i].lpb, NULL, NULL,
                                                                                lpProp->Value.MVbin.lpbin[i].cb, 0,
                                                                                NULL, &cb, &lpb);
                                            }
                                            // Add the entryids to this prop - ignore errors
                                            AddPropToMVPBin(lpProfile->lpspvFolders, 0, (LPVOID) lpb, cb, TRUE);
                                            if(lpProp->Value.MVbin.lpbin[i].lpb != (LPBYTE)lpb )
                                                MAPIFreeBuffer(lpb);
                                        }
                                        LocalFreePropArray(NULL, ulcValues, &lpPropArray);
                                    }
                                }
                                lpProfile->lpNext = lpIAB->lpProfilesList;
                                lpIAB->lpProfilesList = lpProfile;
                            }
                            LocalFreePropArray(NULL, 1, &lpProp);
                        }
                        LocalFree(lpsz);
                    }
                }
            }

            dwValIndex++;
            *szValName = '\0';
            dwValSize = sizeof(szValName);
        }
    }

    hr = S_OK;
out:

    if(hKey)
        RegCloseKey(hKey);

    return hr;
}


/*
- SetCurrentProfile - scans list and updates pointer
-
*
*/
void SetCurrentProfile(LPIAB lpIAB, LPTSTR lpszProfileID)
{
    LPWABPROFILEITEM lpTemp = lpIAB->lpProfilesList;
    while(lpTemp)
    {
        if(!lstrcmpi(lpTemp->lpszProfileID, lpszProfileID))
        {
            lpIAB->lpCurrentProfile = lpTemp;
            lpIAB->lpszProfileID = lpTemp->lpszProfileID;
            break;
        }
        lpTemp = lpTemp->lpNext;
    }
}

/*
-   HrSaveProfileItem
-
-
*   Persists a profile item to the registry
*   Format for the data is:
*   under HKCU\Software\Microsoft\WAB\Profiles create a new binary value
*   corresponding to the profile ID and set the binary value data to
*   a flat buffer corresponding to the PR_WAB_FOLDER_ENTRIES property
*/
HRESULT HrSaveProfileItem(LPWABPROFILEITEM lpNew)
{
    ULONG cbBuf = 0;
    LPTSTR lpBuf = NULL;
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;

    if(lpNew->lpszProfileID && !(lpNew->lpszProfileID))    // This item is never cached - only created dynamically
        return S_OK;

    hr = HrGetBufferFromPropArray(  1, lpNew->lpspvFolders,
                                    &cbBuf, &lpBuf);
    if(HR_FAILED(hr))
        goto out;

    if(cbBuf && lpBuf)
    {
        TCHAR szValName[MAX_PATH];
        lstrcpy(szValName, lpNew->lpszProfileID);
        //wsprintf(szValName, "%d", lpNew->dwProfileID);

        if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, szProfileKey,
                                            0, NULL, REG_OPTION_NON_VOLATILE, 
                                            KEY_ALL_ACCESS, NULL, 
                                            &hKey, NULL))
        {
            RegSetValueEx(  hKey, szValName,
                            0, REG_BINARY,
                            (LPBYTE) lpBuf, cbBuf );
        }
        LocalFree(lpBuf);
    }

out:
    if(hKey)
        RegCloseKey(hKey);
    return hr;
}


/*
-   HrCreateNewWABProfile
-
-
*   Creates a new profile based on the supplied profile ID
*   The profile has the default folder-id for the shared folder
*   set on it.
*   Also tags the new profile to the current folder list
*/
HRESULT HrCreateNewWABProfile(LPIAB lpIAB, LPTSTR lpszProfileID )
{
    HRESULT hr = E_FAIL;
    LPWABPROFILEITEM lpNew = NULL;

    hr = HrCreateNewProfileItem(&lpNew, lpszProfileID);
    if(HR_FAILED(hr) || !lpNew)
        goto out;

    // Persist this new item to the registry
    HrSaveProfileItem(lpNew);

    // Add it to the main list
    lpNew->lpNext = lpIAB->lpProfilesList;
    lpIAB->lpProfilesList = lpNew;

    hr = S_OK;
out:

    if(HR_FAILED(hr) && lpNew)
    {
        MAPIFreeBuffer(lpNew->lpspvFolders);
        LocalFree(lpNew);
    }

    return hr;

}



/*
-   FreeWABProfilesList
-
-
*   Clears up existing Profile info from the IAB object
*/
void FreeWABProfilesList(LPIAB lpIAB)
{
    LPWABPROFILEITEM lpTemp = lpIAB->lpProfilesList;
    while(lpTemp)
    {
        lpIAB->lpProfilesList  = lpTemp->lpNext;
        MAPIFreeBuffer(lpTemp->lpspvFolders);
        if(lpTemp->lpszProfileID)
            LocalFree(lpTemp->lpszProfileID);
        LocalFree(lpTemp);
        lpTemp = lpIAB->lpProfilesList;
    }
    lpIAB->lpProfilesList = NULL;
    lpIAB->lpCurrentProfile = NULL;
    lpIAB->lpszProfileID = NULL;
}



#endif //OLD_STUFF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\uidsprop.c ===
/**********************************************************************************
*
*
*   UI_DPROP.C - contains functions for the Directory Service Property dialog
*
*
*
**********************************************************************************/

#include "_apipch.h"


#ifdef OLD_LDAP_UI
extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;


// Params passed to dialog box
typedef struct _tagLSP
{
    LPTSTR lpszName;
    LDAPSERVERPARAMS ldapsp;
    int nRetVal;
    BOOL bAddNew;
} LSP, * LPLSP;


// Return codes from Dialog Box
enum _DSPROPS
{
    DSPROP_ERROR=0,
    DSPROP_OK,
    DSPROP_CANCEL
};

/*
* Prototypes
*/
int CreateDSPropertySheet( HWND hwndOwner, LPLSP lpLsp);
BOOL APIENTRY_16 fnDSPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);
BOOL APIENTRY_16 fnDSAdvancedPropsProc(HWND hDlg,UINT message,UINT  wParam,LPARAM lParam);

BOOL FillDSPropsUI( HWND hDlg,
                    int nPropSheet,
                    LPLSP lpLsp);

BOOL GetDSPropsFromUI(  HWND hDlg,
                        int nPropSheet,
                        LPLSP lpLsp);

BOOL SetDSPropsUI(HWND hDlg,
                  int nPropSheet);


// List of property sheets in this UI
enum _DSProps
{
    propDSProp=0,
    propDSPropAdvanced,
    propDSMax
};


#define EDIT_LEN   MAX_UI_STR-16

/*
* Help IDs
*/
static DWORD rgDsPropsHelpIDs[] =
{
    IDC_LDAP_PROPS_FRAME,               IDH_WAB_COMM_GROUPBOX,
    IDC_LDAP_PROPS_FRAME2,              IDH_WAB_COMM_GROUPBOX,
    //IDC_LDAP_PROPS_STATIC_CAPTION,
    IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY,IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME,
    IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY,  IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME,
    IDC_LDAP_PROPS_RADIO_SICILY,        IDH_WABLDAP_DIRSSERV_AUTH_SICILY,
    IDC_LDAP_PROPS_CHECK_NAMES,         IDH_WABLDAP_DIRSSERV_CHECK_AGAINST,
    IDC_LDAP_PROPS_STATIC_NAME,         IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_EDIT_NAME,           IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_RADIO_ANON,          IDH_WABLDAP_DIRSSERV_AUTH_ANON,
    IDC_LDAP_PROPS_RADIO_USERPASS,      IDH_WABLDAP_DIRSSERV_AUTH_PASS,
    IDC_LDAP_PROPS_STATIC_USERNAME,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_EDIT_USERNAME,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_STATIC_PASSWORD,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_EDIT_PASSWORD,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_STATIC_PASSWORD2,    IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_FRAME_ROOT,          IDH_LDAP_SEARCH_BASE,
    IDC_LDAP_PROPS_EDIT_ROOT,           IDH_LDAP_SEARCH_BASE,
    IDC_LDAP_PROPS_STATIC_SEARCH,       IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_SEARCH,         IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_STATIC_NUMRESULTS,   IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_EDIT_NUMRESULTS,     IDH_WABLDAP_SEARCH_LIMIT,
    0,0
};


#endif // OLD_LDAP_UI


///////////////////////////////////////////////////////////////////
//
//  HrShowDSProps - shows Directory Service properties UI
//
//  hWndParent - hWnd of Parent
//  lpszName - pointer to a buffer ... also contains name of LDAP
//      server to view prperties on - this name can be modified so
//      lpszName should point to a big enough buffer
//  bAddNew - TRUE if this is a new entry, false if this is props
///////////////////////////////////////////////////////////////////
HRESULT HrShowDSProps(HWND      hWndParent,
                      LPTSTR    lpszName,
                      BOOL      bAddNew)
{

    HRESULT hr = hrSuccess;
    IImnAccountManager * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;

    // init account manager
    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    // find this account
    if (hr = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      lpszName,
      &lpAccount)) {
        DebugTrace("FindAccount(%s) -> %x\n", lpszName, GetScode(hr));
        goto out;
    }

    // show properties
    if (hr = lpAccount->lpVtbl->ShowProperties(lpAccount,
      hWndParent,
      0)) {
        DebugTrace("ShowProperties(%s) -> %x\n", lpszName, GetScode(hr));
        goto out;
    }

    {
        TCHAR szBuf[MAX_UI_STR];
        // Get the friendly name (== account name if this changed)
        if (! (HR_FAILED(hr = lpAccount->lpVtbl->GetPropSz(lpAccount,
                                                                AP_ACCOUNT_NAME,
                                                                szBuf,
                                                                sizeof(szBuf))))) 
        {
            lstrcpy(lpszName, szBuf);
        }
    }

#ifdef OLD_LDAP_UI
    SCODE sc = SUCCESS_SUCCESS;
    TCHAR szOldName[MAX_UI_STR];

    ULONG i = 0, j = 0;

    LSP lsp = {0};

    DebugPrintTrace(("----------\nHrShowDSProps Entry\n"));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    lsp.lpszName = lpszName;
    lsp.nRetVal = DSPROP_ERROR;
    lsp.bAddNew = bAddNew;


    // Store the old name in case it changes later on ...
    szOldName[0]='\0';
    if (! bAddNew) {
        lstrcpy(szOldName, lpszName);
    }

    // Get the details of this DS from the registry
    if (lpszName && *lpszName) {
        if (hr = GetLDAPServerParams(lpszName, &(lsp.ldapsp))) {
            DebugTrace("No Account Manager\n");
            ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
            goto out;
        }
    } else {
        // Fill in the default values for the props here:
        lsp.ldapsp.dwSearchSizeLimit = LDAP_SEARCH_SIZE_LIMIT;
        lsp.ldapsp.dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
        lsp.ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
        lsp.ldapsp.lpszUserName = NULL;
        lsp.ldapsp.lpszPassword = NULL;
        lsp.ldapsp.lpszURL = NULL;
        lsp.ldapsp.fResolve = FALSE;
        lsp.ldapsp.lpszBase = NULL;
        lsp.ldapsp.lpszName = NULL;
    }

retry:
    // PropSheets
    if (CreateDSPropertySheet(hWndParent,&lsp) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }


    switch(lsp.nRetVal)
    {
    case DSPROP_OK:
        if(lstrlen(lsp.lpszName))
        {
            // If this was an old entry that changed, remove the old entry from the
            // registry and rewrite this again ...
            // if(!bAddNew &&
            //   (lstrcmpi(szOldName, lsp.lpszName)))
            //    SetLDAPServerParams(szOldName, NULL);
            //
            // On second thoughts, we will let the calling function handle the old new thing
            // because the calling function should be able to recover from a User Cancel ...

            if (GetScode(SetLDAPServerParams(lpszName, &(lsp.ldapsp))) == MAPI_E_COLLISION) {
                // Name collision with existing account.
                DebugTrace("Collision in LDAP server names\n");
                ShowMessageBoxParam(hWndParent, IDE_SERVER_NAME_COLLISION, MB_ICONERROR, lsp.lpszName);
                goto retry;
            }
        }
        hr = S_OK;
        break;
    case DSPROP_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case DSPROP_ERROR:
        hr = E_FAIL;
        break;
    }

out:

    FreeLDAPServerParams(lsp.ldapsp);
#endif // OLD_LDAP_UI

out:

    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }


//  Don't release the account manager.  It will be done when the IAdrBook is released.
//    if (lpAccountManager) {
//        lpAccountManager->lpVtbl->Release(lpAccountManager);
//    }

    return hr;
}


#ifdef OLD_LDAP_UI
/****************************************************************************
*    FUNCTION: CreateDSPropertySheet(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
int CreateDSPropertySheet( HWND hwndOwner,
                           LPLSP lpLsp)
{
    PROPSHEETPAGE psp[propDSMax];
    PROPSHEETHEADER psh;
    TCHAR szBuf[propDSMax][MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    psp[propDSProp].dwSize = sizeof(PROPSHEETPAGE);
    psp[propDSProp].dwFlags = PSP_USETITLE;
    psp[propDSProp].hInstance = hinstMapiX;
    psp[propDSProp].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_PROPERTIES);
    psp[propDSProp].pszIcon = NULL;
    psp[propDSProp].pfnDlgProc = (DLGPROC) fnDSPropsProc;
    LoadString(hinstMapiX, idsCertGeneralTitle, szBuf[propDSProp], sizeof(szBuf[propDSProp]));
    psp[propDSProp].pszTitle = szBuf[propDSProp];
    psp[propDSProp].lParam = (LPARAM) lpLsp;

    psp[propDSPropAdvanced].dwSize = sizeof(PROPSHEETPAGE);
    psp[propDSPropAdvanced].dwFlags = PSP_USETITLE;
    psp[propDSPropAdvanced].hInstance = hinstMapiX;
    psp[propDSPropAdvanced].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_PROPERTIES_ADVANCED);
    psp[propDSPropAdvanced].pszIcon = NULL;
    psp[propDSPropAdvanced].pfnDlgProc = (DLGPROC) fnDSAdvancedPropsProc;
    LoadString(hinstMapiX, idsCertAdvancedTitle, szBuf[propDSPropAdvanced], sizeof(szBuf[propDSPropAdvanced]));
    psp[propDSPropAdvanced].pszTitle = szBuf[propDSPropAdvanced];
    psp[propDSPropAdvanced].lParam = (LPARAM) lpLsp;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, sizeof(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propDSProp;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


/****************************************************************************
*    FUNCTION: SetDSPropsUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
*   hDlg - Dialog
*   nPropSheet - property sheet
*
****************************************************************************/
BOOL SetDSPropsUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propDSProp:
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        break;
    case propDSPropAdvanced:
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_SEARCH),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NUMRESULTS),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_ROOT),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        break;
    }

    return TRUE;
}


/****************************************************************************
*    FUNCTION: FillDSPropsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillDSPropsUI(HWND hDlg, int nPropSheet, LPLSP lpLsp)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    int id;

    switch(nPropSheet)
    {
    case propDSProp:
        {
            // Set the authentication method UI
            switch(lpLsp->ldapsp.dwAuthMethod)
            {
            case LDAP_AUTH_METHOD_ANONYMOUS:
                id = IDC_LDAP_PROPS_RADIO_ANON;
                break;
            case LDAP_AUTH_METHOD_SIMPLE:
                id = IDC_LDAP_PROPS_RADIO_USERPASS;
                break;
            case LDAP_AUTH_METHOD_SICILY:
                id = IDC_LDAP_PROPS_RADIO_SICILY;
                break;
            }

            if( (id == IDC_LDAP_PROPS_RADIO_ANON) ||
                (id == IDC_LDAP_PROPS_RADIO_SICILY) )
            {
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),FALSE);
            }
            //
            // Club the radio buttons togethor ...
            CheckRadioButton(   hDlg,
                                IDC_LDAP_PROPS_RADIO_ANON,
                                IDC_LDAP_PROPS_RADIO_USERPASS,
                                id);

            // Fill in other details
            if(lstrlen(lpLsp->lpszName))
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, lpLsp->lpszName);
                SetWindowPropertiesTitle(GetParent(hDlg), lpLsp->lpszName);
            }

            if(lpLsp->ldapsp.lpszName)
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, lpLsp->ldapsp.lpszName);

            if(lpLsp->ldapsp.lpszUserName)
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_USERNAME, lpLsp->ldapsp.lpszUserName);

            if(lpLsp->ldapsp.lpszPassword)
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, lpLsp->ldapsp.lpszPassword);
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, lpLsp->ldapsp.lpszPassword);
            }

            id = (lpLsp->ldapsp.fResolve) ? BST_CHECKED : BST_UNCHECKED;
            CheckDlgButton(hDlg, IDC_LDAP_PROPS_CHECK_NAMES, id);

        }
        break;


    case propDSPropAdvanced:
        {
            SetDlgItemInt(  hDlg,
                            IDC_LDAP_PROPS_EDIT_SEARCH,
                            lpLsp->ldapsp.dwSearchTimeLimit,
                            FALSE);
            SetDlgItemInt(  hDlg,
                            IDC_LDAP_PROPS_EDIT_NUMRESULTS,
                            lpLsp->ldapsp.dwSearchSizeLimit,
                            FALSE);

            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_ROOT),TRUE);

            if(lpLsp->ldapsp.lpszBase)
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, lpLsp->ldapsp.lpszBase);
            }
            else
            {
                LPTSTR lpszBase = TEXT("c=%s"); //Hopefully this string doesnt need localization
                TCHAR szBuf[32], szCode[4];
                ReadRegistryLDAPDefaultCountry(NULL, szCode);
                wsprintf(szBuf, lpszBase, szCode);
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, szBuf);
            }
        }
        break;
    }



    bRet = TRUE;

    return bRet;
}




////////////////////////////////////////////////////////////////////////////////
//
//  GetDSPropsFromUI - reads the UI for its parameters and verifies that
//  all required fields are set. Params are stored back in the lpLsp struct
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetDSPropsFromUI(HWND hDlg, int nPropSheet, LPLSP lpLsp)
{
    BOOL bRet = FALSE;
    LDAPSERVERPARAMS  Params={0};

    TCHAR szBuf[2 * EDIT_LEN];

    switch(nPropSheet)
    {
    case propDSProp:
        {
            //
            // First check the required property (which is the Name and Friendly Name)
            //
            BOOL bName = FALSE, bFName = FALSE;
            DWORD dwID = 0;
            BOOL bExists = FALSE;

            szBuf[0]='\0'; //reset
            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
                bFName = TRUE;

            // We want the friendly names to be unique .. hence check if this friendly name
            // already exists or not ...
            bExists = GetLDAPServerParams(szBuf, &Params);

            if((bExists && lpLsp->bAddNew) ||
                (bExists && !lpLsp->bAddNew && (Params.dwID != lpLsp->ldapsp.dwID)))
            {
                // We are adding a new entry, but we found that another entry exists with the
                // same name or we are editing an existing entry and then found that another
                // entry exists whose ID does not match this entries ID.

                // Warn them that they must add a unique friendly name
                ShowMessageBoxParam(hDlg, idsEnterUniqueLDAPName, MB_ICONEXCLAMATION | MB_OK, szBuf);
                goto out;
            }

            szBuf[0]='\0'; //
            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
                bName = TRUE;

            if(!bName || !bFName)
            {
                ShowMessageBox(hDlg, idsEnterLDAPServerName, MB_ICONEXCLAMATION | MB_OK);
                goto out;
            }

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            LocalFreeAndNull(&lpLsp->ldapsp.lpszName);
            lpLsp->ldapsp.lpszName = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
            if(lpLsp->ldapsp.lpszName)
                lstrcpy(lpLsp->ldapsp.lpszName, szBuf);

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            lstrcpy(lpLsp->lpszName, szBuf);

            //
            // check the selected authentication type
            //
            if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_ANON) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
            else if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_USERPASS) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_SIMPLE;
            else if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_SICILY) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_SICILY;


            LocalFreeAndNull(&lpLsp->ldapsp.lpszUserName);
            LocalFreeAndNull(&lpLsp->ldapsp.lpszPassword);

            //
            // Get the user name password, if applicable
            //
            if(lpLsp->ldapsp.dwAuthMethod == LDAP_AUTH_METHOD_SIMPLE)
            {
                TCHAR szBuf2[MAX_UI_STR*2];

                //
                // Verify that the entered password matches the confirmed password
                //
                szBuf[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, szBuf, sizeof(szBuf));
                szBuf2[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, szBuf2, sizeof(szBuf2));
                TrimSpaces(szBuf);
                TrimSpaces(szBuf2);

                if(lstrcmp(szBuf,szBuf2))
                {
                    ShowMessageBox(hDlg, idsConfirmPassword, MB_ICONEXCLAMATION | MB_OK);
                    SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, szEmpty);
                    SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, szEmpty);
                    goto out;
                }

                // otherwise keep this password ...
                lpLsp->ldapsp.lpszPassword = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                if(!(lpLsp->ldapsp.lpszPassword))
                {
                    DebugPrintError(("LocalAlloc failed to allocate memory\n"));
                    goto out;
                }
                lstrcpy(lpLsp->ldapsp.lpszPassword,szBuf);

                szBuf[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_USERNAME, szBuf, sizeof(szBuf));
                TrimSpaces(szBuf);
                if(lstrlen(szBuf))
                {
                    lpLsp->ldapsp.lpszUserName = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                    if(!(lpLsp->ldapsp.lpszUserName))
                    {
                        DebugPrintError(("LocalAlloc failed to allocate memory\n"));
                        goto out;
                    }
                    lstrcpy(lpLsp->ldapsp.lpszUserName,szBuf);
                }
            }

            if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_CHECK_NAMES) == BST_CHECKED)
                lpLsp->ldapsp.fResolve = TRUE;
            else
                lpLsp->ldapsp.fResolve = FALSE;

            if(lpLsp->bAddNew)
                lpLsp->ldapsp.dwID = GetLDAPNextServerID(0);

        }
        break;
    case propDSPropAdvanced:
        {
            lpLsp->ldapsp.dwSearchTimeLimit = GetDlgItemInt(
                                                hDlg,
                                                IDC_LDAP_PROPS_EDIT_SEARCH,
                                                NULL,
                                                FALSE);

            lpLsp->ldapsp.dwSearchSizeLimit = GetDlgItemInt(
                                                hDlg,
                                                IDC_LDAP_PROPS_EDIT_NUMRESULTS,
                                                NULL,
                                                FALSE);

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
            {
                LocalFreeAndNull(&lpLsp->ldapsp.lpszBase);
                lpLsp->ldapsp.lpszBase = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                if(lpLsp->ldapsp.lpszBase)
                    lstrcpy(lpLsp->ldapsp.lpszBase, szBuf);
            }
        }
        break;
    }

    bRet = TRUE;

out:
    FreeLDAPServerParams(Params);
    return bRet;
}



#define lpLSP ((LPLSP) pps->lParam)



/*//$$***********************************************************************
*    FUNCTION: fnDSPropsProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDSPropsUI(hDlg, propDSProp);
        FillDSPropsUI(hDlg, propDSProp, lpLSP);
        return TRUE;


    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY:
                {
                    // Update the dialog title with the friendly name
                    TCHAR szBuf[MAX_UI_STR];
                    GetWindowText((HWND) lParam,szBuf,sizeof(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                }
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_LDAP_PROPS_RADIO_ANON:
        case IDC_LDAP_PROPS_RADIO_USERPASS:
        case IDC_LDAP_PROPS_RADIO_SICILY:
                CheckRadioButton(   hDlg,
                        IDC_LDAP_PROPS_RADIO_ANON,
                        IDC_LDAP_PROPS_RADIO_USERPASS,
                        LOWORD(wParam));
                {
                    int id = LOWORD(wParam);
                    if( (id == IDC_LDAP_PROPS_RADIO_ANON) ||
                        (id == IDC_LDAP_PROPS_RADIO_SICILY) )
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),FALSE);
                    }
                    else if (id = IDC_LDAP_PROPS_RADIO_USERPASS)
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),TRUE);
                    }
                }
                break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetDSPropsFromUI(hDlg, propDSProp, lpLSP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            lpLSP->nRetVal = DSPROP_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            lpLSP->nRetVal = DSPROP_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnDSAdvancedPropsProc
*
*    PURPOSE:  Window proc for advanced property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSAdvancedPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDSPropsUI(hDlg, propDSPropAdvanced);
        FillDSPropsUI(hDlg, propDSPropAdvanced, lpLSP);
        return TRUE;


    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetDSPropsFromUI(hDlg, propDSPropAdvanced, lpLSP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            lpLSP->nRetVal = DSPROP_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            lpLSP->nRetVal = DSPROP_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}

#endif // OLD_LDAP_UI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\ui_cert.c ===
/**********************************************************************************
*
*
*   UI_CERT.C - contains functions for displaying certificates
*
*   **************THIS IS DEAD CODE***************************
*
**********************************************************************************/

#include "_apipch.h"

#ifdef OLD_STUFF

extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;
extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;

enum _CERTS
{
    CERT_ERROR=0,
    CERT_OK,
    CERT_CANCEL
};

enum _CertPropSheets
{
    propCertGeneral=0,
    propCertTrust,
    propCertAdvanced,
    propCertMAX
};

typedef struct _CertParam
{
    LPCERT_DISPLAY_PROPS lpCDP;
    int nRetVal;
} CERT_PARAM, * LPCERT_PARAM;


int CreateCertPropertySheet( HWND hwndOwner, LPCERT_PARAM lpcp);

BOOL APIENTRY_16 fnCertGeneralProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);
BOOL APIENTRY_16 fnCertTrustProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam);
BOOL APIENTRY_16 fnCertAdvancedProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam);

BOOL FillCertPropsUI( HWND hDlg,
                    int nPropSheet,
                    LPCERT_PARAM lpcp);

BOOL GetCertPropsFromUI(HWND hDlg, LPCERT_PARAM lpcp);

BOOL SetCertPropsUI(HWND hDlg, int nPropSheet);


#define EDIT_LEN   MAX_UI_STR

/***
static DWORD rgCertPropsHelpIDs[] =
{
    IDC_LDAP_PROPS_STATIC_NAME,         IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_EDIT_NAME,           IDH_WABLDAP_DIRSSERV_NAME,
    //IDC_LDAP_PROPS_FRAME,
    IDC_LDAP_PROPS_RADIO_ANON,          IDH_WABLDAP_DIRSSERV_AUTH_ANON,
    IDC_LDAP_PROPS_RADIO_USERPASS,      IDH_WABLDAP_DIRSSERV_AUTH_PASS,
    IDC_LDAP_PROPS_STATIC_USERNAME,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_EDIT_USERNAME,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_STATIC_PASSWORD,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_EDIT_PASSWORD,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_STATIC_PASSWORD2,    IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    //IDC_LDAP_PROPS_FRAME2,
    IDC_LDAP_PROPS_STATIC_CONNECTION,   IDH_WABLDAP_CONNECT_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_CONNECTION,     IDH_WABLDAP_CONNECT_TIMEOUT,
    IDC_LDAP_PROPS_STATIC_SEARCH,       IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_SEARCH,         IDH_WABLDAP_SEARCH_TIMEOUT,
    //IDC_LDAP_PROPS_FRAME_NUMRESULTS,    IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_STATIC_NUMRESULTS,   IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_EDIT_NUMRESULTS,     IDH_WABLDAP_SEARCH_LIMIT,
    0,0
};
/***/


///////////////////////////////////////////////////////////////////
//
//  HrShowCertProps - shows properties on a certificate
//
//  hWndParent - hWnd of Parent
//  lpCDP - pointer to a certificate info
//
///////////////////////////////////////////////////////////////////
HRESULT HrShowCertProps(HWND   hWndParent,
                        LPCERT_DISPLAY_PROPS lpCDP)
{

    HRESULT hr = E_FAIL;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i = 0, j = 0;
    CERT_PARAM cp;

    DebugPrintTrace(("----------\nHrShowCertProps Entry\n"));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    // <TBD> - error check lpCDP
    cp.lpCDP = lpCDP;
    cp.nRetVal = CERT_ERROR;

    if (CreateCertPropertySheet(hWndParent, &cp) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }

    switch(cp.nRetVal)
    {
    case CERT_OK:
        hr = S_OK;
        break;
    case CERT_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case CERT_ERROR:
        hr = E_FAIL;
        break;
    }

out:

    return hr;
}


/****************************************************************************
*    FUNCTION: CreateCertPropertySheet(HWND)
*
*    PURPOSE:  Creates the Cert property sheet
*
****************************************************************************/
int CreateCertPropertySheet(HWND hwndOwner, LPCERT_PARAM lpcp)
{
    PROPSHEETPAGE psp[propCertMAX];
    PROPSHEETHEADER psh;
    TCHAR szTitle[propCertMAX][MAX_UI_STR];
    TCHAR szCaption[MAX_UI_STR];

    // General
    psp[propCertGeneral].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertGeneral].dwFlags = PSP_USETITLE;
    psp[propCertGeneral].hInstance = hinstMapiX;
    psp[propCertGeneral].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_GENERAL);
    psp[propCertGeneral].pszIcon = NULL;
    psp[propCertGeneral].pfnDlgProc = (DLGPROC) fnCertGeneralProc;
    LoadString(hinstMapiX, idsCertGeneralTitle, szTitle[propCertGeneral], sizeof(szTitle[propCertGeneral]));
    psp[propCertGeneral].pszTitle = szTitle[propCertGeneral];
    psp[propCertGeneral].lParam = (LPARAM) lpcp;

    // Trust
    psp[propCertTrust].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertTrust].dwFlags = PSP_USETITLE;
    psp[propCertTrust].hInstance = hinstMapiX;
    psp[propCertTrust].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_TRUST);
    psp[propCertTrust].pszIcon = NULL;
    psp[propCertTrust].pfnDlgProc = (DLGPROC) fnCertTrustProc;
    LoadString(hinstMapiX, idsCertTrustTitle, szTitle[propCertTrust], sizeof(szTitle[propCertTrust]));
    psp[propCertTrust].pszTitle = szTitle[propCertTrust];
    psp[propCertTrust].lParam = (LPARAM) lpcp;

    // Advanced
    psp[propCertAdvanced].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertAdvanced].dwFlags = PSP_USETITLE;
    psp[propCertAdvanced].hInstance = hinstMapiX;
    psp[propCertAdvanced].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_ADVANCED);
    psp[propCertAdvanced].pszIcon = NULL;
    psp[propCertAdvanced].pfnDlgProc = (DLGPROC) fnCertAdvancedProc;
    LoadString(hinstMapiX, idsCertAdvancedTitle, szTitle[propCertAdvanced], sizeof(szTitle[propCertAdvanced]));
    psp[propCertAdvanced].pszTitle = szTitle[propCertAdvanced];
    psp[propCertAdvanced].lParam = (LPARAM) lpcp;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, idsCertPropertyTitleCaption, szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propCertGeneral;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


/****************************************************************************
*    FUNCTION: SetCertPropsUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
****************************************************************************/
BOOL SetCertPropsUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propCertGeneral:
        break;


    case propCertTrust:
        {
            HWND hWndTree = GetDlgItem(hDlg, IDC_CERT_TRUST_TREE_CHAIN);
            HIMAGELIST hImg = gpfnImageList_LoadImage(
                                            hinstMapiX, 	
                                            MAKEINTRESOURCE(IDB_CERT),
                                            32,
                                            0,
                                            RGB_TRANSPARENT,
                                            IMAGE_BITMAP, 	
                                            0);

	        // Associate the image lists with the list view control.
	        TreeView_SetImageList (hWndTree, hImg, TVSIL_NORMAL);

        }
        break;


    case propCertAdvanced:
        {
            LV_COLUMN lvC;               // list view column structure
	        RECT rc;
            HWND hWndLV = GetDlgItem(hDlg, IDC_CERT_ADVANCED_LIST_FIELD);

            ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);
	        GetWindowRect(hWndLV,&rc);
	        lvC.mask = LVCF_FMT | LVCF_WIDTH;
            lvC.fmt = LVCFMT_LEFT;   // left-align column
	        lvC.cx = rc.right - rc.left - 20; //TBD
	        lvC.pszText = NULL;
            lvC.iSubItem = 0;
            ListView_InsertColumn (hWndLV, 0, &lvC);
        }
        break;
    }

    return TRUE;
}


enum _TrustString
{
    indexTrusted=0,
    indexNotTrusted,
    //N TODO: CHAINS
    //indexChainTrusted
};




/****************************************************************************
*    FUNCTION: UpdateValidInvalidStatus(HWND, lpCDP)
*
*    PURPOSE:  Fills in the trust/valididyt related items on the property sheet
*
****************************************************************************/
void UpdateValidInvalidStatus(HWND hDlg, LPCERT_PARAM lpcp)
{
    TCHAR szBuf[MAX_UI_STR];

    // Set the status info
    if(lpcp->lpCDP->bIsExpired || lpcp->lpCDP->bIsRevoked || !lpcp->lpCDP->bIsTrusted)
    {
        LoadString(hinstMapiX, idsCertInvalid, szBuf, sizeof(szBuf));
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_UNCHECK), SW_SHOWNORMAL);
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_CHECK), SW_HIDE);
    }
    else
    {
        LoadString(hinstMapiX, idsCertValid, szBuf, sizeof(szBuf));
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_CHECK), SW_SHOWNORMAL);
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_UNCHECK), SW_HIDE);
    }
    SetDlgItemText(hDlg, IDC_CERT_GENERAL_STATIC_STATUS, szBuf);


    LoadString(hinstMapiX, idsNo, szBuf, sizeof(szBuf));
    if(!lpcp->lpCDP->bIsExpired)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_EXPIREDDATA, szBuf);
    if(!lpcp->lpCDP->bIsRevoked)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_REVOKEDDATA, szBuf);
    if(!lpcp->lpCDP->bIsTrusted)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_TRUSTEDDATA, szBuf);


    LoadString(hinstMapiX, idsYes, szBuf, sizeof(szBuf));
    if(lpcp->lpCDP->bIsExpired)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_EXPIREDDATA, szBuf);
    if(lpcp->lpCDP->bIsRevoked)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_REVOKEDDATA, szBuf);
    if(lpcp->lpCDP->bIsTrusted)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_TRUSTEDDATA, szBuf);

    return;
}



/****************************************************************************
*    FUNCTION: FillCertPropsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillCertPropsUI(HWND hDlg,int nPropSheet, LPCERT_PARAM lpcp)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];

    switch(nPropSheet)
    {
    case propCertGeneral:
        {
            // Fill the combo with the trust strings
            HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
            DWORD dwTrust = lpcp->lpCDP->dwTrust;
            //N TODO: CHAINS
            for(i=idsCertTrustedByMe;i<=idsCertNotTrustedByMe;i++)
            {
                LoadString(hinstMapiX, i, szBuf, sizeof(szBuf));
                SendMessage(hWndCombo,CB_ADDSTRING, (WPARAM) i-idsCertTrustedByMe, (LPARAM) szBuf);
            }

            if(dwTrust & WAB_TRUSTED)
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexTrusted, 0);
            else if(dwTrust & WAB_NOTTRUSTED)
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexNotTrusted, 0);
            if(dwTrust & WAB_CHAINTRUSTED)
                //N TODO: CHAINS
                //SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexChainTrusted, 0);
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexNotTrusted, 0);

            // Fill in the misc strings
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_CERTFORDATA, lpcp->lpCDP->lpszSubjectName);
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_SERIALNUMDATA, lpcp->lpCDP->lpszSerialNumber);
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_VALIDFROMDATA, lpcp->lpCDP->lpszValidFromTo);

            // if an issuer exists, use it
            if(lpcp->lpCDP->lpszIssuerName)
                SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_ISSUER, lpcp->lpCDP->lpszIssuerName);
            else
            {
                // unknown or self issued
                LoadString(hinstMapiX, idsUnknown, szBuf, sizeof(szBuf));
                SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_ISSUER, szBuf);
            }

            //V Remove for now
            //
            // Disable the button if we dont have an issuer
            // if(!lpcp->lpCDP->lpIssuer)
            //    EnableWindow(GetDlgItem(hDlg, IDC_CERT_GENERAL_BUTTON_OPEN), FALSE);


            UpdateValidInvalidStatus(hDlg, lpcp);

        }
        break;

    case propCertTrust:
        {
            HWND hWndTree = GetDlgItem(hDlg, IDC_CERT_TRUST_TREE_CHAIN);
            HTREEITEM hItem = NULL;
            LPCERT_DISPLAY_PROPS  lpTemp = NULL, lpFirst = NULL, lpLast = NULL;
            LPCERT_DISPLAY_PROPS  lpList[2];
            int i;
            // Bug 18602
            // Add only the first and last items

            // Walk to the end of the linked list
            lpFirst = lpTemp = lpcp->lpCDP;

            while (lpTemp->lpIssuer)
            {
                lpTemp = lpTemp->lpIssuer;
                lpLast = lpTemp;
            }


            // Hack!
            lpList[0] = lpLast;
            lpList[1] = lpFirst;
            
            for(i=0;i<2;i++)
            {
                lpTemp = lpList[i];
                if(lpTemp)
                {
/*
#ifndef OLD_STUFF
    // Now walk back up the list, adding the nodes to the tree.
    while (lpTemp)
    {
#endif        
*/
                    HTREEITEM hItemTemp;
                    TV_ITEM tvI;
                    TV_INSERTSTRUCT tvIns;

                    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                    tvI.pszText = lpTemp->lpszSubjectName;
                    tvI.cchTextMax = lstrlen(tvI.pszText);
                    tvI.iImage = tvI.iSelectedImage = 0;

                    tvIns.item = tvI;
                    tvIns.hInsertAfter = (HTREEITEM) TVI_FIRST;
                    tvIns.hParent = hItem;

                    hItemTemp = TreeView_InsertItem(hWndTree, &tvIns);

                    if(hItem)
                        TreeView_Expand(hWndTree, hItem, TVE_EXPAND);

                    hItem = hItemTemp;

                } //if lpList[i] ..

            } //end for  

/*                
#ifndef OLD_STUFF
                    // We don't want to walk back up past the node for the current cert
                    if (lpTemp == lpcp->lpCDP)
                    {
                      lpTemp = NULL;
                    }
                    else
                    {
                      lpTemp = lpTemp->lpPrev;
                    }
                }
#endif
*/
        } // end case
        break;


    case propCertAdvanced:
        if(lpcp->lpCDP->nFieldCount)
        {
            int i;
            HWND hWndLV = GetDlgItem(hDlg, IDC_CERT_ADVANCED_LIST_FIELD);

            for(i=0;i<lpcp->lpCDP->nFieldCount;i++)
            {
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    lvi.pszText = lpcp->lpCDP->lppszFieldCount[i];
                    lvi.iItem = ListView_GetItemCount(hWndLV);
                    lvi.iSubItem = 0;
                    lvi.lParam = (LPARAM) lpcp->lpCDP->lppszDetails[i];

                    ListView_InsertItem(hWndLV, &lvi);
            }

            SetDlgItemText( hDlg,
                            IDC_CERT_ADVANCED_EDIT_DETAILS,
                            lpcp->lpCDP->lppszDetails[0]);

            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);
        }
        break;
    }

    bRet = TRUE;

    return bRet;
}




////////////////////////////////////////////////////////////////////////////////
//
//  GetDL from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetCertPropsFromUI(HWND hDlg, LPCERT_PARAM lpcp)
{
    BOOL bRet = FALSE;

    // The cert UI is readonly except for trust information ..
    // So just get the trust information
    HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
    int nRet = SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

    switch(nRet)
    {
    case indexTrusted:
        lpcp->lpCDP->dwTrust = WAB_TRUSTED;
        break;
    case indexNotTrusted:
        lpcp->lpCDP->dwTrust = WAB_NOTTRUSTED;
        break;
    //N TODO: CHAINS
    //case indexChainTrusted:
    //    lpcp->lpCDP->dwTrust = WAB_CHAINTRUSTED;
    //    break;
    }

    bRet = TRUE;

//out:
    return bRet;
}



#define _lpCP    ((LPCERT_PARAM) pps->lParam)

/*//$$***********************************************************************
*    FUNCTION: fnCertGeneralProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertGeneralProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertGeneral);
        FillCertPropsUI(hDlg,propCertGeneral,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        //V Remove for now
        //
        //case IDC_CERT_GENERAL_BUTTON_OPEN:
        //    {
        //        HrShowCertProps(hDlg, _lpCP->lpCDP->lpIssuer);
        //    }
        //    break;
        }
        switch(GET_WM_COMMAND_CMD(wParam, lParam)) //check the notification code
        {
            case CBN_SELENDOK:
                switch(LOWORD(wParam))
                {
                    case IDC_CERT_GENERAL_COMBO_TRUST:
                        {
                            // The selection could have changed ... so figure out if it has or not
                            // If it has changed, update the UI accordingly ...
                            HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
                            DWORD dwTrust = 0;
                            int nRet = SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

                            switch(nRet)
                            {
                            case indexTrusted:
                                dwTrust = WAB_TRUSTED;
                                break;
                            case indexNotTrusted:
                            default:
                                dwTrust = WAB_NOTTRUSTED;
                                break;
                            //N TODO: CHAINS
                            //case indexChainTrusted:
                            //    dwTrust = WAB_CHAINTRUSTED;
                            //    break;
                            }

                            if (_lpCP->lpCDP->dwTrust != dwTrust)
                            {
                                _lpCP->lpCDP->dwTrust = dwTrust;

                                if (dwTrust & WAB_TRUSTED) 
                                    _lpCP->lpCDP->bIsTrusted = TRUE;
                                else if (dwTrust & WAB_NOTTRUSTED)
                                    _lpCP->lpCDP->bIsTrusted = FALSE;
                                //N TODO: CHAINS
                                //else if (dwTrust & WAB_CHAINTRUSTED)
                                //    _lpCP->lpCDP->bIsTrusted = FALSE; //VerifyTrustBasedOnChainOfTrust(NULL, _lpCP->lpCDP);

                                UpdateValidInvalidStatus(hDlg, _lpCP);
                            }
                        }
                        break;
                }
                break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetCertPropsFromUI(hDlg, _lpCP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnCertTrustProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertTrustProc(HWND hDlg,UINT message,UINT  wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertTrust);
        FillCertPropsUI(hDlg,propCertTrust,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            // read-only prop sheet - no info to retrieve ...
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;

        }
        return TRUE;
        break;

    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnCertAdvancedProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertAdvancedProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertAdvanced);
        FillCertPropsUI(hDlg,propCertAdvanced,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;

        case LVN_ITEMCHANGED:
        case NM_SETFOCUS:
        case NM_CLICK:
        case NM_RCLICK:
            switch(wParam)
            {
            case IDC_CERT_ADVANCED_LIST_FIELD:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    HWND hWndLV = pNm->hdr.hwndFrom;
                    LV_ITEM lvi = {0};
                    LPTSTR lpsz;

                    lvi.mask = LVIF_PARAM;
                    lvi.iSubItem = 0;
                    lvi.iItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

                    if(ListView_GetItem(hWndLV, &lvi))
                    {
                        lpsz = (LPTSTR) lvi.lParam;
                        SetDlgItemText(hDlg, IDC_CERT_ADVANCED_EDIT_DETAILS, lpsz);
                    }
                }
                break;
            }
            break;
        }
        return TRUE;
        break;

    }

    return bRet;

}


#endif //OLD_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabexe\certprop.c ===
/*-----------------------------------------
//
// CertProp.C -- Displays Certificate File
//               Properties and Allows
///              Add Cert to WAB
//
//-----------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "..\wab32res\resrc2.h"
#include <wincrypt.h>
#include <cryptdlg.h>
#include <cryptui.h>
#include "wabexe.h"

const UCHAR cszOID_PKIX_KP_EMAIL_PROTECTION[] = szOID_PKIX_KP_EMAIL_PROTECTION;
const UCHAR szRoot[] = "ROOT";
const UCHAR szCA[] = "CA";
const UCHAR szAB[] = "AddressBook";

#define iAddToWAB   0

// Test for PT_ERROR property tag
// #define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))
#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        Assert(VAR_##fn != NULL); \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }

#define GET_PROC_ADDR_FLAG(h, fn, pflag) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        *pflag = (VAR_##fn != NULL);

#undef LOADER_FUNCTION
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           if (!DemandLoad##dll()) return err;          \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#ifdef DEBUG
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription);
#endif

// *****************************************************************************************
// CRYPTDLG.DLL
// *****************************************************************************************
BOOL DemandLoadCryptDlg(void);
static HMODULE s_hCryptDlg = 0;

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

// *****************************************************************************************
// CRYPT32.DLL
// *****************************************************************************************
BOOL DemandLoadCrypt32(void);
static HMODULE s_hCrypt32 = 0;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol),
    NULL, Crypt32)
#define CertOpenSystemStoreA VAR_CertOpenSystemStoreA

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    FALSE, Crypt32)
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    0, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded, DWORD cbEncoded, DWORD dwFlags,
      void * pvStructInfo, DWORD * pcbStructInfo),
    (dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
      pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT * ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore


LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

// *****************************************************************************************
// ADVAPI.DLL
// *****************************************************************************************
BOOL DemandLoadAdvApi32(void);
static HMODULE s_hAdvApi = 0;


LOADER_FUNCTION(BOOL, CryptAcquireContextA,
    (HCRYPTPROV * phProv, LPCTSTR pszContainer, LPCTSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextA VAR_CryptAcquireContextA

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext


// *****************************************************************************************
// Various Structures and typdefs
// *****************************************************************************************
typedef BLOB THUMBBLOB;

// This struct and tags will be published by the exchange group -- this is temporary.
#define NUM_CERT_TAGS       2
#define CERT_TAG_DEFAULT    0x20
#define CERT_TAG_THUMBPRINT 0x22
// SIZE_CERTTAGS is the size of the structure excluding the byte array.
#define SIZE_CERTTAGS       (2 * sizeof(WORD))

//N warnings, should probably just remove the []
#pragma warning (disable:4200)
typedef struct _CertTag
{
  WORD  tag;
  WORD  cbData;
  BYTE  rgbData[];
} CERTTAGS, FAR * LPCERTTAGS;
#pragma warning (default:4200)


#define LPARAM_SENTRY  0x424A4800
typedef struct _AB_DIALOG_PANE_PARAMS {
    DWORD dwSentry;                 // Must be set to value of LPARAM_SENTRY
    LPWABOBJECT lpWABObject;
    LPADRBOOK lpAdrBook;
    PCERT_CONTEXT * rgCertContext;  // array of cert context pointers
    ULONG cCertContexts;            // how many cert in rgCertContext
    ULONG iLeafCert;                // index in array of the leaf cert
    LPTSTR lpDisplayName;
    LPTSTR lpEmailAddress;
    HCRYPTPROV hCryptProv;
} AB_DIALOG_PANE_PARAMS, *LPAB_DIALOG_PANE_PARAMS;


static BOOL s_fCertViewPropertiesCryptUIA = FALSE;
BOOL DemandLoadCryptDlg(void) {
    BOOL fRet = TRUE;

    if (0 == s_hCryptDlg) {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");

        if (0 == s_hCryptDlg) {
            DebugTrace("LoadLibrary of CRYPTDLG.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
        }
    }
    return(fRet);
}


BOOL CryptUIAvailable(void) {
    DemandLoadCryptDlg();
    return(s_fCertViewPropertiesCryptUIA);
}


BOOL DemandLoadCrypt32(void) {
    BOOL fRet = TRUE;

    if (0 == s_hCrypt32) {
        s_hCrypt32 = LoadLibrary("CRYPT32.DLL");

        if (0 == s_hCrypt32) {
            DebugTrace("LoadLibrary of CRYPT32.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hCrypt32, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt32, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt32, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt32, CertOpenSystemStoreA)
            GET_PROC_ADDR(s_hCrypt32, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt32, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt32, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt32, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt32, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt32, CertRDNValueToStrA)
            GET_PROC_ADDR(s_hCrypt32, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt32, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt32, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt32, CertAddEncodedCertificateToStore)
        }
    }
    return(fRet);
}

BOOL DemandLoadAdvApi32(void) {
    BOOL fRet = TRUE;

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");

        if (0 == s_hAdvApi) {
            DebugTrace("LoadLibrary of ADVAPI32.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextA)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
        }
    }
    return(fRet);
}


/***************************************************************************

    Name      : IsThumbprintInMVPBin

    Purpose   : Check the PR_USER_X509_CERTIFICATE prop for this vsthumbprint

    Parameters: spv = prop value structure of PR_USER_X509_CERTIFICATE
                lpThumbprint -> THUMBBLOB structure to find

    Returns   : TRUE if found

    Comment   :

***************************************************************************/
BOOL IsThumbprintInMVPBin(SPropValue spv, THUMBBLOB * lpThumbprint) {
    ULONG cValues, i;
    LPSBinary lpsb = NULL;
    LPCERTTAGS lpCurrentTag;
    LPBYTE lpbTagEnd;


    if (! PROP_ERROR((spv))) {
        lpsb = spv.Value.MVbin.lpbin;
        cValues = spv.Value.MVbin.cValues;

        // Check for duplicates
        for (i = 0; i < cValues; i++) {
            lpCurrentTag = (LPCERTTAGS)lpsb[i].lpb;
            lpbTagEnd = (LPBYTE)lpCurrentTag + lpsb[i].cb;

            while ((LPBYTE)lpCurrentTag < lpbTagEnd) {
                // Check if this is the tag that contains the thumbprint
                if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag) {
                    if ((lpThumbprint->cbSize == lpCurrentTag->cbData - SIZE_CERTTAGS) &&
                      ! memcmp(lpThumbprint->pBlobData, &lpCurrentTag->rgbData,
                      lpThumbprint->cbSize)) {
                        return(TRUE);
                    }
                }

                lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
            }
        }
    }
    return(FALSE);
}


/***************************************************************************

    Name      : HrBuildCertSBinaryData

    Purpose   : Takes as input all the data needed for a cert entry
                in PR_USER_X509_CERTIFICATE and returns a pointer to
                memory that contains all the input data in the correct
                format to be plugged in to the lpb member of an SBinary
                structure.  This memory should be Freed by the caller.


    Parameters: bIsDefault - TRUE if this is the default cert
                pblobCertThumbPrint - The actual certificate thumbprint
                lplpbData - receives the buffer with the data
                lpcbData - receives size of the data

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  THUMBBLOB*            pPrint,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData)
{
    WORD        cbDefault, cbPrint;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;
    LPBYTE      lpb = NULL;


    cbDefault   = sizeof(bIsDefault);
    cbPrint     = (WORD) pPrint->cbSize;
    cProps      = 2;
    cbSize      = cbDefault + cbPrint;
    cbSize += (cProps * SIZE_CERTTAGS);

    if (! (lpb = LocalAlloc(LPTR, cbSize))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Set the default property
    lpCurrentTag = (LPCERTTAGS)lpb;
    lpCurrentTag->tag       = CERT_TAG_DEFAULT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbDefault;
    memcpy(&lpCurrentTag->rgbData, &bIsDefault, cbDefault);

    // Set the thumbprint property
    lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
    lpCurrentTag->tag       = CERT_TAG_THUMBPRINT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbPrint;
    memcpy(&lpCurrentTag->rgbData, pPrint->pBlobData, cbPrint);

    *lpcbData = cbSize;
    *lplpbData = lpb;
exit:
    return(hr);
}


/*  PVGetCertificateParam:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to get a parameter
**      from a certificate.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pCert            - CAPI certificate to query
**      IN dwParam          - parameter to find, ex: CERT_SHA1_HASH_PROP_ID
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the returned PVOID
**  Returns:
**      data that was obtained, NULL if failed
*/
LPVOID PVGetCertificateParam(
    PCCERT_CONTEXT  pCert,
    DWORD           dwParam,
    DWORD          *cbOut)
{
    DWORD cbData;
    void *pvData = NULL;

    if (!pCert) {
        SetLastError((DWORD)E_INVALIDARG);
        goto ErrorReturn;
    }

    cbData = 0;
    CertGetCertificateContextProperty(pCert, dwParam, NULL, &cbData);
    if (! cbData || (! (pvData = LocalAlloc(LPTR, cbData)))) {
        DebugTrace("CertGetCertificateContextProperty -> %x\n", GetLastError());
        goto ErrorReturn;
    }

    if (! CertGetCertificateContextProperty(pCert, dwParam, pvData, &cbData)) {
        DebugTrace("CertGetCertificateContextProperty -> %x\n", GetLastError());
        goto ErrorReturn;
    }

exit:
    if (cbOut) {
        *cbOut = cbData;
    }
    return(pvData);

ErrorReturn:
    if (pvData) {
        LocalFree(pvData);
        pvData = NULL;
    }
    cbData = 0;
    goto exit;
}


/*
**
**  FUNCTION:   GetAttributeString
**
**  PURPOSE:    Get the string associated with the given attribute
**
**  PARAMETERS: lplpszAttributeString - pointer that will be LocalAlloc'ed
**                to hold the string.  Caller must LocalFree this!
**              pbEncoded - the encoded blob
**              cbEncoded - size of the encoded blob
**              lpszObjID - object ID of attribute to retrieve
**
**  RETURNS:    HRESULT.
**
**  HISTORY:
**  96/10/03  markdu  Created for WAB
**
*/
HRESULT GetAttributeString(LPTSTR FAR * lplpszAttributeString,
  BYTE *pbEncoded,
  DWORD cbEncoded,
  LPCSTR lpszObjID)
{
    HRESULT             hr = hrSuccess;
    BOOL                fRet;
    PCERT_RDN_ATTR      pRdnAttr;
    PCERT_NAME_INFO     pNameInfo = NULL;
    DWORD               cbInfo;
    DWORD               cbData;  //N need both?

    // Initialize so we know if any data was copied in.
    *lplpszAttributeString = NULL;

    // Get the size of the subject name data
    cbInfo = 0;
    CryptDecodeObject(
      X509_ASN_ENCODING,    // indicates X509 encoding
      (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
      pbEncoded,            // pointer to a buffer holding the encoded name
      cbEncoded,            // length in bytes of the encoded name
                            //N maybe can use nocopy flag
      0,                    // flags
      NULL,                 // NULL used when just geting length
      &cbInfo);             // length in bytes of the decoded name
    if (0 == cbInfo) {
        hr = GetLastError();
        goto exit;
    }

    // Allocate space for the decoded name
    if (! (pNameInfo = LocalAlloc(LPTR, cbInfo))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Get the subject name
    if (! CryptDecodeObject(
      X509_ASN_ENCODING,    // indicates X509 encoding
      (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
      pbEncoded,            // pointer to a buffer holding the encoded name
      cbEncoded,            // length in bytes of the encoded name
      0,                    // flags
      pNameInfo,            // the buffer where the decoded name is written to
      &cbInfo)) {             // length in bytes of the decoded name
        hr = GetLastError();
        goto exit;
    }

    // Now we have a decoded name RDN array, so find the oid we want
    if (! (pRdnAttr = CertFindRDNAttr(lpszObjID, pNameInfo))) {
        hr = MAPI_E_NOT_FOUND;
        goto exit;
    }

    // We only handle certain types
    //N look to see if we should have a stack var for the ->
    if ((CERT_RDN_NUMERIC_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_PRINTABLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_IA5_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_VISIBLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_ISO646_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNIVERSAL_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_TELETEX_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNICODE_STRING != pRdnAttr->dwValueType)) {
        hr = MAPI_E_INVALID_PARAMETER;
        goto exit;
    }

    // Find out how much space to allocate.
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            cbData = WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              NULL,
              0,
              NULL,
              NULL);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            cbData = CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              NULL,
              0);
            break;

        default:
            cbData = pRdnAttr->Value.cbData + 1;
            break;
    }

    // Allocate the space for the string.
    if (! (*lplpszAttributeString = LocalAlloc(LPTR, cbData))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Copy the string
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            if (FALSE == WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              *lplpszAttributeString,
              cbData,
              NULL,
              NULL))
            {
              DWORD dwErr = GetLastError();
              switch(dwErr)
              {
                case ERROR_INSUFFICIENT_BUFFER:
                  hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                  break;
                case ERROR_INVALID_PARAMETER:
                  hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
                  break;
                default:
                  hr = ResultFromScode(MAPI_E_CALL_FAILED);
                  break;
               }
               goto exit;
            }
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              *lplpszAttributeString,
              cbData);
            break;

        default:
            lstrcpyn(*lplpszAttributeString, (LPCSTR)pRdnAttr->Value.pbData, cbData);
            (*lplpszAttributeString)[cbData - 1] = '\0';
            break;
    }

exit:
    if (hr && *lplpszAttributeString) {
        LocalFree(*lplpszAttributeString);
        *lplpszAttributeString = NULL;
    }

    if (NULL != pNameInfo) {
        LocalFree(pNameInfo);
    }
    return(hr);
}


/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpWABObject -> WAB Object
                lpaProps -> array of properties
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew
                fNoDuplicates = TRUE if we should not add duplicates

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(LPWABOBJECT lpWABObject,
  LPSPropValue lpaProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew,
  BOOL fNoDuplicates)
{
    UNALIGNED SBinaryArray * lprgsbOld = NULL;
    SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;


    // Find the size of any existing MVP entries
    if (PT_ERROR == PROP_TYPE(lpaProps[index].ulPropTag)) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgsbOld = &(lpaProps[index].Value.MVbin);
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;

        // Check for duplicates
        if (fNoDuplicates) {
            for (i = 0; i < cExisting; i++) {
                if (cbNew == lpsbOld[i].cb &&
                  ! memcmp(lpNew, lpsbOld[i].lpb, cbNew)) {
                    DebugTrace("AddPropToMVPBin found duplicate.\n");
                    return(hrSuccess);
                }
            }
        }

        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = lpWABObject->lpVtbl->AllocateMore(lpWABObject, cbMVP, lpaProps, (LPVOID*)&lpsbNew)) {
        DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = lpWABObject->lpVtbl->AllocateMore(lpWABObject, cbNew, lpaProps, (LPVOID*)&(lpsbNew[i].lpb))) {
        DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}





// enum for ADRENTRY props
enum {
    irnPR_ENTRYID = 0,
    irnPR_DISPLAY_NAME,
    irnPR_EMAIL_ADDRESS,
    irnPR_OBJECT_TYPE,
    irnMax
};

// enum for getting the entryid of an entry
enum {
    itbdPR_USER_X509_CERTIFICATE,
    itbMax
};
static const SizedSPropTagArray(itbMax, ptaCert) =
{
    itbMax,
    {
        PR_USER_X509_CERTIFICATE,
    }
};


enum {
   iconPR_DEF_CREATE_MAILUSER = 0,
   iconMax
};
static const SizedSPropTagArray(iconMax, ptaCon)=
{
   iconMax,
   {
       PR_DEF_CREATE_MAILUSER,
   }
};

// enum for setting the created properties
enum {
    imuPR_DISPLAY_NAME = 0,     // must be first so DL's can use same enum
    imuPR_EMAIL_ADDRESS,
    imuPR_ADDRTYPE,
    imuMax
};
static const SizedSPropTagArray(imuMax, ptag)=
{
    imuMax,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
    }
};

// enum for getting the entryid of an entry
enum {
    ieidPR_ENTRYID,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEID)=
{
    ieidMax,
    {
        PR_ENTRYID,
    }
};




HRESULT HrAddCertsToWAB(HWND hwnd, LPWABOBJECT lpWABObject, LPADRBOOK lpAdrBook, HCRYPTPROV hCryptProv,
  PCERT_CONTEXT * rgCertContext, ULONG cCertContexts, ULONG iLeaf, LPTSTR lpDisplayName, LPTSTR lpEmailAddress)
{
    HRESULT         hr;
    SCODE           sc;
    BOOL            fFound;
    ULONG           cCerts;
    LPSPropValue    ppv = NULL;
    LPSPropValue    ppvEID = NULL;
    BOOL            fAlreadyHasCert;
    ULONG           ul;
    LPADRLIST       lpAdrList = NULL;
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulObjectType;
    LPBYTE          lpCertProp;
    ULONG           cbCertProp;
    LPSPropValue    ppvUndo = NULL;
    HCERTSTORE      hcAB = 0, hcCA = 0;
    PCCERT_CONTEXT  pccLeaf = NULL;
    THUMBBLOB       Thumbprint = {0};
    ULONG           i, iEntry;
    BOOL            fShowUI = TRUE;
    HCRYPTPROV      hProv = 0;
    SPropValue      spv[imuMax];
    ULONG           cbEIDWAB;
    LPENTRYID       lpEIDWAB = NULL;
    ULONG           cProps;
    LPSPropValue    lpCreateEIDs = NULL;
    LPABCONT        lpContainer = NULL;
    BOOL            fCreateNew = FALSE;


    if (! rgCertContext || ! lpAdrBook || ! lpWABObject) {
        return(ResultFromScode(E_FAIL));
    }

    DebugTrace("Certificate for '%s'. Email: '%s'\n", lpDisplayName, lpEmailAddress ? lpEmailAddress : szEmpty);


    if (! (hcCA = CertOpenSystemStoreA(hCryptProv, szCA))) {
        hr = GetLastError();
        goto exit;
    }

    if (! (hcAB = CertOpenSystemStore(hCryptProv, szAB))) {
        hr = GetLastError();
        goto exit;
    }

    // Add all the certs to the cert stores
    // Leaf goes in WAB store, others go in CA
    for (i = 0; i < cCertContexts; i++) {
        if (i == iLeaf) {
            if (CertAddCertificateContextToStore(hcAB,
              rgCertContext[i],
              CERT_STORE_ADD_REPLACE_EXISTING,
              &pccLeaf)) {
                // Get it's thumbprint
                if (! (Thumbprint.pBlobData = (BYTE *)PVGetCertificateParam(
                  pccLeaf,
                  CERT_HASH_PROP_ID,
                  &Thumbprint.cbSize))) {
                    goto exit;
                }
            } else {
                hr = GetLastError();
                DebugTrace("CertAddCertificateContextToStore -> %x\n", hr);
                goto exit;
            }
        } else {

            if (! CertAddCertificateContextToStore(hcCA,
              rgCertContext[i],
              CERT_STORE_ADD_REPLACE_EXISTING,
              NULL)) {
                DebugTrace("CertAddCertificateContextToStore -> %x\n", GetLastError());
                // Don't fail, just go on
            }
        }
    }

    if (sc = lpWABObject->lpVtbl->AllocateBuffer(lpWABObject,
      sizeof(ADRLIST) + 1 * sizeof(ADRENTRY), (LPVOID*)&lpAdrList)) {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->cEntries = 1;
    lpAdrList->aEntries[0].ulReserved1 = 0;
    lpAdrList->aEntries[0].cValues = irnMax;

    // Allocate the prop array for the ADRENTRY
    if (sc = lpWABObject->lpVtbl->AllocateBuffer(lpWABObject,
      lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
      (LPVOID*)&lpAdrList->aEntries[0].rgPropVals)) {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb = 0;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb = NULL;

    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;


    if (lpDisplayName) {
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].Value.LPSZ = lpDisplayName;
    } else {
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_NULL;
    }
    if (lpEmailAddress) {
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].Value.LPSZ = lpEmailAddress;
    }  else {
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
    }

    hr = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
      (ULONG_PTR)hwnd,
      MAPI_DIALOG | WAB_RESOLVE_LOCAL_ONLY | WAB_RESOLVE_ALL_EMAILS |
        WAB_RESOLVE_NO_ONE_OFFS | WAB_RESOLVE_NO_NOT_FOUND_UI,
      NULL,     // BUGBUG: name for NewEntry dialog?
      lpAdrList);

    switch (GetScode(hr)) {
        case SUCCESS_SUCCESS:   // Should be a resolved entry now
            // Should have PR_ENTRYID in rgPropVals[irnPR_ENTRYID]
            if (lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag == PR_ENTRYID) {
                if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb,
                  (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb,
                  NULL,
                  MAPI_MODIFY,  // ulFlags
                  &ulObjectType,
                  (LPUNKNOWN *)&lpMailUser))) {
                    DebugTrace("OpenEntry -> %x\n", GetScode(hr));
                    goto exit;
                }
            }
            break;

        case MAPI_E_NOT_FOUND:
            // no match, create one
            // Get the PAB object
            if (HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbEIDWAB, &lpEIDWAB))) {
                goto exit;  // Bad stuff here!
            }

            if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbEIDWAB,     // size of EntryID to open
              lpEIDWAB,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjectType,
              (LPUNKNOWN *)&lpContainer))) {
                goto exit;
            }

            // Get us the creation entryids
            if (hr = lpContainer->lpVtbl->GetProps(lpContainer, (LPSPropTagArray)&ptaCon, 0, &cProps, &lpCreateEIDs)) {
                goto exit;  // Bad stuff here!
            }

            if (HR_FAILED(hr = lpContainer->lpVtbl->CreateEntry(lpContainer,
              lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
              (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
              0,        //CREATE_CHECK_DUP_STRICT
              (LPMAPIPROP *)&lpMailUser))) {
                goto exit;
            }

            // Successful creation of new entry.  Fill in email and displayname
            spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
            spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpEmailAddress;

            spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
            spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";
            spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
            spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpDisplayName;

            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
              imuMax,                   // cValues
              spv,                      // property array
              NULL))) {                 // problems array
                DebugTrace("SetProps -> %x\n", GetScode(hr));
            }
            // Need to save so we can get an entryid later
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READWRITE))) {
                goto exit;
            }

            if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
              (LPSPropTagArray)&ptaEID, 0, &ul, &ppvEID))) {
                goto exit;
            }

            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb =
              ppvEID[ieidPR_ENTRYID].Value.bin.cb;
            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb =
              ppvEID[ieidPR_ENTRYID].Value.bin.lpb;

            fCreateNew = TRUE;
            break;

        case MAPI_E_USER_CANCEL:
            // cancel, don't update
        default:
            break;
    }

    if (lpMailUser) {
        // Got the entry, Set the cert property
        if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser, (LPSPropTagArray)&ptaCert, 0, &ul, &ppv))) {
            // Shouldn't happen, but if it does, we don't have a lpPropArray
            goto exit;
        }

        if (! IsThumbprintInMVPBin(ppv[0], &Thumbprint)) {
            if (HR_FAILED(hr = HrBuildCertSBinaryData(PROP_ERROR(ppv[0]),  // Default if there is no current value
              &Thumbprint,
              &lpCertProp,
              &cbCertProp))) {
                goto exit;
            }

            // Add the new thumbprint to PR_USER_X509_CERTIFICATE
            if (HR_FAILED(hr = AddPropToMVPBin(lpWABObject,
              ppv,          // prop array
              0,            // index of PR_USER_X509_CERTIFICATE in ppv
              lpCertProp,
              cbCertProp,
              TRUE))) {     // fNoDuplicates
                goto exit;
            }

            if (fShowUI) {
                // Save undo information
                if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser, (LPSPropTagArray)&ptaCert, 0,
                  &ul, &ppvUndo))) {
                    ppvUndo = NULL;
                }
            }

            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser, 1, ppv, NULL))) {
                goto exit;
            }
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READWRITE))) {
                goto exit;
            }
        }

        if (fShowUI) {
            hr = lpAdrBook->lpVtbl->Details(lpAdrBook,
              (PULONG_PTR)&hwnd,
              NULL,
              NULL,
              lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb,
              (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb,
              NULL,
              NULL,
              NULL,
              0);
            if (ResultFromScode(hr) == MAPI_E_USER_CANCEL && (ppvUndo || fCreateNew)) {
                // Undo
                if (fCreateNew && lpContainer) {
                    ENTRYLIST EntryList;


                    EntryList.cValues = 1;
                    EntryList.lpbin = &lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin;

                    // Now, delete the entry found.
                    if (hr = lpContainer->lpVtbl->DeleteEntries(lpContainer, &EntryList, 0)) {
                        goto exit;
                    }
                } else {
                    // Not a new entry, restore the original cert props
                    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser, 1, ppvUndo, NULL))) {
                        goto exit;
                    }
                    if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, 0))) {
                        goto exit;
                    }
                }
            }
        }
    }

exit:
    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry)
        {
            if(lpAdrList->aEntries[iEntry].rgPropVals)
                lpWABObject->lpVtbl->FreeBuffer(lpWABObject,
                  lpAdrList->aEntries[iEntry].rgPropVals);
        }
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpAdrList);
        lpAdrList = NULL;
    }

    if (lpCreateEIDs) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpCreateEIDs);
    }

    if (ppvEID) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppvEID);
    }

    if (lpEIDWAB) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpEIDWAB);
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }

    if (lpMailUser) {
        lpMailUser->lpVtbl->Release(lpMailUser);
    }

    if (ppv) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppv);
    }

    if (ppvUndo) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppvUndo);
    }

    if (Thumbprint.pBlobData) {
        LocalFree(Thumbprint.pBlobData);
    }

    if (pccLeaf) {
        CertFreeCertificateContext(pccLeaf);
    }

    if (hcAB) {
        CertCloseStore(hcAB, 0);
    }

    if (hcCA) {
        CertCloseStore(hcCA, 0);
    }

    return(hr);
}


//*******************************************************************
//
//  FUNCTION:   ReadDataFromFile
//
//  PURPOSE:    Read data from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the data to be read
//              ppbData - receives the data that is read
//              pcbData - receives the size of the data that is read
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************
HRESULT ReadDataFromFile(
  LPCSTR      lpszFileName,
  PBYTE*      ppbData,
  PDWORD      pcbData)
{
    HRESULT             hr = hrSuccess;
    BOOL                fRet;
    HANDLE              hFile = 0;
    DWORD               cbFile;
    DWORD               cbData;
    PBYTE               pbData = 0;

    if ((NULL == ppbData) || (NULL == pcbData)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Open the file and find out how big it is
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
      lpszFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      0,
      NULL))) {
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    cbData = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbData) {
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    if (NULL == (pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto error;
    }

    if (! ReadFile(
      hFile,                      // handle of file to read
      pbData,                     // address of buffer that receives data
      cbData,                     // number of bytes to read
      &cbFile,                    // address of number of bytes read
      NULL)) {                    // address of structure for data
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    if (cbData != cbFile) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto error;
    }

    *ppbData = pbData;
    *pcbData = cbData;

out:
    if (hFile) {
        CloseHandle(hFile);
    }

    return(hr);

error:
    // BUGBUG some of the GetLastError calls above may not have worked.
    if (hrSuccess == hr) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
    }

    goto out;
}



LPAB_DIALOG_PANE_PARAMS GetLParamFromPropSheetPage(PROPSHEETPAGE *ps) {
    LONG lparam;
    LPAB_DIALOG_PANE_PARAMS lpABDialogPaneParams;
    ULONG i;

    lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS)(ps->lParam);
    if (lpABDialogPaneParams->dwSentry != LPARAM_SENTRY) {
        // Assume that CryptUI has passed us a wrapped lparam/cert pair
        // typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
        //    LPARAM          lParam;
        //    PCCERT_CONTEXT  pCertContext;
        // } CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;

        PCRYPTUI_INITDIALOG_STRUCT pCryptUIInitDialog = (PCRYPTUI_INITDIALOG_STRUCT)lpABDialogPaneParams;
        lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS )pCryptUIInitDialog->lParam;
        if (lpABDialogPaneParams->dwSentry != LPARAM_SENTRY) {
            // Bad lparam
            return(NULL);
        }
    }
    return(lpABDialogPaneParams);
}



INT_PTR CALLBACK ViewPageAddressBook(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fTrust;
    HANDLE              hGraphic;
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    WCHAR               rgwch[200];
    UINT                rguiStrings[7];
    LPAB_DIALOG_PANE_PARAMS lpABDialogPaneParams;
    PROPSHEETPAGE *     lpps;

    switch ( msg ) {
        case WM_INITDIALOG:
            // Get access to the parameters
        lpps = (PROPSHEETPAGE *)lParam;
        lpABDialogPaneParams = GetLParamFromPropSheetPage(lpps);
        if (! lpABDialogPaneParams) {
            return(FALSE);
        }
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)lpABDialogPaneParams);

        return TRUE;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_RESET:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
            }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_ADD_TO_ADDRESS_BOOK) {
                HRESULT hr = ResultFromScode(MAPI_E_CALL_FAILED);
                lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS)GetWindowLongPtr(hwndDlg, DWLP_USER);

                if (lpABDialogPaneParams) {
                    hr = HrAddCertsToWAB(hwndDlg, lpABDialogPaneParams->lpWABObject,
                      lpABDialogPaneParams->lpAdrBook,
                      lpABDialogPaneParams->hCryptProv,
                      lpABDialogPaneParams->rgCertContext,
                      lpABDialogPaneParams->cCertContexts,
                      lpABDialogPaneParams->iLeafCert,
                      lpABDialogPaneParams->lpDisplayName,
                      lpABDialogPaneParams->lpEmailAddress);
                }

                return TRUE;
            }
            else if (LOWORD(wParam) == IDHELP) {
                    return TRUE;
            }
            break;
    }
    return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   CertFileDisplay
//
//  PURPOSE:    Display the certificate properties of a pkcs7 file
//
//  PARAMETERS: hwnd = parent window handle
//              lpWABObject -> wab object
//              lpAdrBook -> Adrbook object
//              lpFileName -> Cert filename
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT CertFileDisplay(HWND hwnd,
  LPWABOBJECT lpWABObject,
  LPADRBOOK lpAdrBook,
  LPTSTR lpFileName) {
    HCRYPTPROV hCryptProvider = 0;
    HRESULT hr;
    CERT_CONTEXT CertContext;
    LPBYTE lpBuf = NULL;
    ULONG cbData = 0, cCert;
    HCRYPTMSG hMsg = NULL;
    PCERT_CONTEXT * rgCertContext = NULL;
    DWORD dwIssuerFlags = 0;
    ULONG i, j;
    PCCERT_CONTEXT pcCertContextTarget = NULL, pcCertContextIssuer;
    PCERT_INFO pCertInfoTarget = NULL;
    HCERTSTORE hCertStoreMsg = NULL;
    BOOL fFound = FALSE, fIssuer;
    PROPSHEETPAGE PSPage;
    TCHAR szTitle[MAX_RESOURCE_STRING + 1];
    TCHAR szABPaneTitle[MAX_RESOURCE_STRING + 1];
    AB_DIALOG_PANE_PARAMS ABDialogPaneParams;
    PCERT_INFO pCertInfo;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    LPTSTR rgPurposes[1] = {(LPTSTR)&cszOID_PKIX_KP_EMAIL_PROTECTION};


    // Get the crypt provider context
    if (! CryptAcquireContext(
      &hCryptProvider,
      NULL,
      NULL,
      PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT)) {
        hr = GetLastError();
        goto exit;
    }


    // Read the data from the file.
    if (hr = ReadDataFromFile(lpFileName, &lpBuf, &cbData)) {
        goto exit;
    }

    if (! (hMsg = CryptMsgOpenToDecode(
      PKCS_7_ASN_ENCODING,
      0,                          // dwFlags
      0,                          // dwMsgType
      hCryptProvider,
      NULL,                       // pRecipientInfo (not supported)
      NULL))) {                      // pStreamInfo (not supported)
        hr = GetLastError();
        DebugTrace("CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING) -> 0x%08x\n", GetScode(hr));
        goto exit;
    }

    if (! CryptMsgUpdate(hMsg, lpBuf, cbData, TRUE)) {
        hr = GetLastError();
        DebugTrace("CryptMsgUpdate -> 0x%08x\n", GetScode(hr));
        goto exit;
    }

    cbData = sizeof(cCert);
    if (! CryptMsgGetParam(
      hMsg,
      CMSG_CERT_COUNT_PARAM,        // dwParamType
      0,                            // dwIndex
      (void *)&cCert,
      &cbData)) {                     // pcbData
        hr = GetLastError();
        DebugTrace("CryptMsgGetParam(CMSG_CERT_COUNT_PARAM) -> 0x%08x\n", GetScode(hr));
        goto exit;
    }
    if (cbData != sizeof(cCert)) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto exit;
    }


    // Look for cert that's a "Leaf" node.
    // Unfortunately, there is no easy way to tell, so we'll have
    // to loop through each cert, checking to see if it is an issuer of any other cert
    // in the message.  If it is not an issuer of any other cert, it must be the leaf cert.
    //
    if (! (hCertStoreMsg = CertOpenStore(
      CERT_STORE_PROV_MSG,
      X509_ASN_ENCODING,
      hCryptProvider,
      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
      hMsg))) {
        hr = GetLastError();
        DebugTrace("CertOpenStore(msg) -> %x\n", hr);
        goto exit;
    } else {
        if (! (rgCertContext = LocalAlloc(LPTR, cCert * sizeof(PCERT_CONTEXT)))) {
            DebugTrace("LocalAlloc of cert table -> %u\n", GetLastError());
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }

        // Enumerate all certs on this message
        i = 0;
        while (pcCertContextTarget = CertEnumCertificatesInStore(hCertStoreMsg,
          pcCertContextTarget)) {

            rgCertContext[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(
              pcCertContextTarget);

#ifdef DEBUG
            DebugTraceCertContextName(rgCertContext[i], "Found Cert:");
#endif
            i++;
        };

        // Now we've got a table full of certs
        for (i = 0; i < cCert; i++) {
            pCertInfoTarget = rgCertContext[i]->pCertInfo;
            fIssuer = FALSE;

            for (j = 0; j < cCert; j++) {
                if (i != j) {
                    dwIssuerFlags = 0;

                    if (pcCertContextIssuer = CertGetIssuerCertificateFromStore(hCertStoreMsg,
                      rgCertContext[j],
                      NULL,
                      &dwIssuerFlags)) {

                        // Found an issuer
                        // Is it the same as the target?
                        fIssuer = CertCompareCertificate(X509_ASN_ENCODING,
                          pCertInfoTarget,   // target
                          pcCertContextIssuer->pCertInfo);     // test issuer

                        CertFreeCertificateContext(pcCertContextIssuer);

                        if (fIssuer) {
                            // This test cert is issued by the target, so
                            // we know that Target is NOT a leaf cert
                            break;
                        } // else, loop back to the enumerate where the test cert context will be freed.
                    }
                }
            }

            if (! fIssuer) {
                DebugTrace("Found a Cert which is not an issuer.\n");
#ifdef DEBUG
                DebugTraceCertContextName(rgCertContext[i], "Non-issuer cert:");
#endif
                // What is the email and display name of the leaf cert?

                pCertInfo = rgCertContext[i]->pCertInfo;

                GetAttributeString(&ABDialogPaneParams.lpDisplayName,
                  pCertInfo->Subject.pbData,
                  pCertInfo->Subject.cbData,
                  szOID_COMMON_NAME);

                GetAttributeString(&ABDialogPaneParams.lpEmailAddress,
                  pCertInfo->Subject.pbData,
                  pCertInfo->Subject.cbData,
                  szOID_RSA_emailAddr);

                ABDialogPaneParams.lpWABObject = lpWABObject;
                ABDialogPaneParams.lpAdrBook = lpAdrBook;
                ABDialogPaneParams.hCryptProv = hCryptProvider;
                ABDialogPaneParams.rgCertContext = rgCertContext;
                ABDialogPaneParams.cCertContexts = cCert;
                ABDialogPaneParams.iLeafCert = i;
                ABDialogPaneParams.dwSentry = LPARAM_SENTRY;

                memset(&PSPage, 0, sizeof(PROPSHEETPAGE));

                PSPage.dwSize = sizeof(PSPage);
                PSPage.dwFlags = 0;     // PSP_HASHELP;
                PSPage.hInstance = hInst;
                PSPage.pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_ADDRESS_BOOK);
                PSPage.hIcon = 0;
                LoadString(hInst, idsAddToABPaneTitle, szABPaneTitle, sizeof(szABPaneTit