MPILETIME_ASSERT(
           (DWORD)(ULONG_PTR)TVI_ROOT  == 0xFFFF0000 &&
           (DWORD)(ULONG_PTR)TVI_FIRST == 0xFFFF0001 &&
           (DWORD)(ULONG_PTR)TVI_LAST  == 0xFFFF0002 &&
           (DWORD)(ULONG_PTR)TVI_SORT  == 0xFFFF0003);

    if (hItem)
    {
        if (HIWORD64(hItem) == HIWORD64(TVI_ROOT))
        {
            switch (LOWORD(hItem))
            {
                case LOWORD(TVI_ROOT):
                case LOWORD(TVI_FIRST):
                case LOWORD(TVI_LAST):
                case LOWORD(TVI_SORT):
                    break;

                default:
                    AssertMsg(FALSE, TEXT("ValidateTreeItem() Invalid special item"));
                    fValid = FALSE;
                    break;
            }
        }
        else
        {
            __try
            {
                // Use "volatile" to force memory access at start of struct
                *(volatile void **)hItem;
                fValid = hItem->wSignature == TV_SIG;
            } __except(EXCEPTION_EXECUTE_HANDLER)
            {
                fValid = FALSE;
            } __endexcept
        }

    }
    else if (!flags)
    {
        // The only flag is VTI_NULLOK
        RIPMSG(FALSE, "ValidateTreeItem(): NULL HTREEITEM");
        fValid = FALSE;
    }

    return fValid;
}

// ----------------------------------------------------------------------------
//
//  Initialize TreeView on library entry -- register SysTreeView class
//
// ----------------------------------------------------------------------------

BOOL TV_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = TV_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szTreeViewClass;
    wc.hbrBackground   = NULL;
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(PTREE);
    wc.cbClsExtra      = 0;

    if (RegisterClass(&wc) && !GetClassInfo(hinst, c_szTreeViewClass, &wc))
        return FALSE;

    return TRUE;
}

// ----------------------------------------------------------------------------
//
// If the tooltip bubble is up, then pop it.
//
// ----------------------------------------------------------------------------

void TV_PopBubble(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->hToolTip)
    {
        pTree->hToolTip = NULL;
        SendMessage(pTree->hwndToolTips, TTM_POP, 0L, 0L);
    }
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_BEGINDRAG or TVN_BEGINRDRAG notification with information in the ptDrag and
//  itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL TV_SendBeginDrag(PTREE pTree, int code, TREEITEM * hItem, int x, int y)
{
    NM_TREEVIEW nm;
        
    TV_PopBubble(pTree);            // dismiss the infotip if we start to drag

    nm.itemNew.hItem = hItem;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);
    nm.itemOld.mask = 0;
    nm.ptDrag.x = x;
    nm.ptDrag.y = y;

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_ITEMEXPANDING or TVN_ITEMEXPANDED notification with information
//  in the action and itemNew fields of an NM_TREEVIEW structure
//
//  Returns FALSE to allow processing to continue, or TRUE to stop.
//
//  If the hItem is destroyed by the callback, then we always return TRUE.
//
//  Note that the application cannot stop a TVN_ITEMEXPANDED, so the only
//  way a TVN_ITEMEXPANDED can return "Stop" is if the item got destroyed.
//
// ----------------------------------------------------------------------------

BOOL TV_SendItemExpand(PTREE pTree, int code, TREEITEM * hItem, WPARAM action)
{
    NM_TREEVIEW nm;
    TVWATCHEDITEM wi;
    BOOL fResult;
    BOOL fWatched;

    ASSERT(code == TVN_ITEMEXPANDING || code == TVN_ITEMEXPANDED);

    nm.itemNew.mask = 0;
    nm.itemNew.hItem = hItem;
    if (hItem == TVI_ROOT)
        hItem = pTree->hRoot;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.iImage = hItem->iImage;
    nm.itemNew.iSelectedImage = hItem->iSelectedImage;
    switch(hItem->fKids) {
        case KIDS_CALLBACK:
        case KIDS_FORCE_YES:
            nm.itemNew.cChildren = 1;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
        case KIDS_FORCE_NO:
            nm.itemNew.cChildren = 0;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
    }
    nm.itemNew.mask |= (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE);
    nm.itemOld.mask = 0;

    nm.action = (UINT)(action & TVE_ACTIONMASK);

    //
    //  Some apps will delete the item while it is being expanded, since
    //  during expansion, they will realize, "Hey, the thing represented
    //  by this item no longer exists, I'd better delete it."  (E.g,.
    //  Explorer.)  So keep an eye on the item so we don't fault when
    //  this happens.
    //

    // If we can't start a watch, then tough, just send the notification
    // the unsafe way.
    fWatched = TV_StartWatch(pTree, &wi, hItem);

    fResult = (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);

    // The app return code from TVN_ITEMEXPANDED is ignored.
    // You can't stop a TVN_ITEMEXPANDED; it's already happened.
    if (code == TVN_ITEMEXPANDED)
        fResult = FALSE;                // Continue processing

    if (fWatched) {
        if (!TV_IsWatchValid(pTree, &wi))
            fResult = TRUE;             // Oh no!  Stop!

        TV_EndWatch(pTree, &wi);
    }

    return fResult;
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_SELCHANGING or TVN_SELCHANGED notification with information in
//  the itemOld and itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL TV_SendSelChange(PTREE pTree, int code, TREEITEM * hOldItem, TREEITEM * hNewItem, UINT action)
{
    NM_TREEVIEW nm;

    nm.action = action;

    nm.itemNew.hItem = hNewItem;
    nm.itemNew.state = hNewItem ? hNewItem->state : 0;
    nm.itemNew.lParam = hNewItem ? hNewItem->lParam : 0;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    nm.itemOld.hItem = hOldItem;
    nm.itemOld.state = hOldItem ? hOldItem->state : 0;
    nm.itemOld.lParam = hOldItem ? hOldItem->lParam : 0;
    nm.itemOld.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}
// ----------------------------------------------------------------------------
//
//  Returns the first visible item above the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM * TV_GetPrevVisItem(TREEITEM * hItem)
{
    TREEITEM * hParent = hItem->hParent;
    TREEITEM * hWalk;

    DBG_ValidateTreeItem(hItem, 0);

    if (hParent->hKids == hItem)
        return VISIBLE_PARENT(hItem);

    for (hWalk = hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);

checkKids:
    if (hWalk->hKids && (hWalk->state & TVIS_EXPANDED))
    {
        for (hWalk = hWalk->hKids; hWalk->hNext; hWalk = hWalk->hNext);

        goto checkKids;
    }
    return(hWalk);
}


// ----------------------------------------------------------------------------
//
//  Returns the first visible item below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM * TV_GetNextVisItem(TREEITEM * hItem)
{
    DBG_ValidateTreeItem(hItem, 0);

    if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return(hItem->hNext);

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Determine what part of what item is at the given (x,y) location in the
//  tree's client area.  If the location is outside the client area, NULL is
//  returned with the TVHT_TOLEFT, TVHT_TORIGHT, TVHT_ABOVE, and/or TVHT_BELOW
//  flags set in the wHitCode as appropriate.  If the location is below the
//  last item, NULL is returned with wHitCode set to TVHT_NOWHERE.  Otherwise,
//  the item is returned with wHitCode set to either TVHT_ONITEMINDENT,
//  TVHT_ONITEMBUTTON, TVHT_ONITEMICON, TVHT_ONITEMLABEL, or TVHT_ONITEMRIGHT
//
// ----------------------------------------------------------------------------

TREEITEM * TV_CheckHit(PTREE pTree, int x, int y, UINT *wHitCode)
{
    TREEITEM * hItem = pTree->hTop;
    int cxState;

    TVITEMEX sItem;

    *wHitCode = 0;

    if (x < 0)
        *wHitCode |= TVHT_TOLEFT;
    else if (x > (int) pTree->cxWnd)
        *wHitCode |= TVHT_TORIGHT;

    if (y < 0)
        *wHitCode |= TVHT_ABOVE;
    else if (y > (int) pTree->cyWnd)
        *wHitCode |= TVHT_BELOW;

    if (*wHitCode)
        return NULL;

    {
        int index = y / pTree->cyItem;

        while (hItem && index >= hItem->iIntegral) {
            index -= hItem->iIntegral;
            hItem = TV_GetNextVisItem(hItem);
        }
    }

    if (!hItem)
    {
        *wHitCode = TVHT_NOWHERE;
        return NULL;
    }

    x -= (pTree->cxBorder + (hItem->iLevel * pTree->cxIndent));
    x += pTree->xPos;

    if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
        (pTree->ci.style &TVS_LINESATROOT))
    {
        // Subtract some more to make up for the pluses at the root
        x -= pTree->cxIndent;
    }

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);
    cxState = TV_StateIndex(&sItem) ? pTree->cxState : 0;
    if (x <= (int) (hItem->iWidth + pTree->cxImage + cxState))
    {

        if (x >= 0) {
            if (pTree->himlState &&  (x < cxState)) {
                *wHitCode = TVHT_ONITEMSTATEICON;
            } else if (pTree->hImageList && (x < (int) pTree->cxImage + cxState)) {
                *wHitCode = TVHT_ONITEMICON;
            } else {
                *wHitCode = TVHT_ONITEMLABEL;
            }
        } else if ((x >= -pTree->cxIndent) && sItem.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
            *wHitCode = TVHT_ONITEMBUTTON;
        else
            *wHitCode = TVHT_ONITEMINDENT;
    }
    else
        *wHitCode = TVHT_ONITEMRIGHT;

    return hItem;
}

//  This is tricky because CheckForDragBegin yields and the app may have
//  destroyed the item we are thinking about dragging
//
//  To give the app some feedback, we give the hItem the drop highlight
//  if it isn't already the caret.  This also allows us to check if the
//  item got deleted behind our back - TV_DeleteItemRecurse makes sure
//  that deleted items are never the hCaret or hDropTarget.
//
//  After TV_CheckForDragBegin, the caller must call TV_FinishCheckDrag
//  to clean up the UI changes that TV_CheckForDragBegin temporarily
//  performed.
//
BOOL TV_CheckForDragBegin(PTREE pTree, HTREEITEM hItem, int x, int y)
{
    BOOL fDrag;

    //
    //  If the item is not the caret, then make it the (temporary)
    //  drop target so the user gets some feedback.
    //
    //  Bug#94368 raymondc - If hItem == pTree->hCaret, it still might not
    //  be visible if the control doesn't yet have focus and the treeview
    //  is not marked showselalways.  Maybe we should just always set
    //  hItem to DROPHILITE.
    //
    if (hItem == pTree->hCaret)
    {
        pTree->hOldDrop = NULL;
        pTree->fRestoreOldDrop = FALSE;
    }
    else
    {
        pTree->hOldDrop = pTree->hDropTarget;
        pTree->fRestoreOldDrop = TRUE;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hItem, 0, TVC_BYMOUSE);
        ASSERT(hItem == pTree->hDropTarget);
    }

    //
    //  We are dragging the hItem if CheckForDragBegin says okay,
    //  and TV_DeleteItemRecurse didn't wipe us out.
    //
    fDrag = CheckForDragBegin(pTree->ci.hwnd, x, y) &&
           (hItem == pTree->hDropTarget || hItem == pTree->hCaret);

    return fDrag;
}

void TV_FinishCheckDrag(PTREE pTree)
{
    //
    //  Clean up our temporary UI changes that happened when we started
    //  dragging.
    //
    if (pTree->fRestoreOldDrop)
    {
        HTREEITEM hOldDrop = pTree->hOldDrop;
        pTree->fRestoreOldDrop = FALSE;
        pTree->hOldDrop = NULL;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hOldDrop, 0, TVC_BYMOUSE);
    }
}

void TV_SendRButtonDown(PTREE pTree, int x, int y)
{
    BOOL fRet = FALSE;
    UINT wHitCode;
    TREEITEM * hItem = TV_CheckHit(pTree, x, y, &wHitCode);
    HWND hwnd = pTree->ci.hwnd;

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down

    //
    // Need to see if the user is going to start a drag operation
    //

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (TV_CheckForDragBegin(pTree, hItem, x, y))
    {
        // let them start dragging
        if (hItem)
        {
            pTree->htiDrag = hItem;
            TV_SendBeginDrag(pTree, TVN_BEGINRDRAG, hItem, x, y);
        }
    }
    else if (!IsWindow(hwnd))
    {
        return;             // bail!
    }
    else
    {
        SetFocus(pTree->ci.hwnd);  // Activate this window like listview...
        fRet = !CCSendNotify(&pTree->ci, NM_RCLICK, NULL);
    }

    // Don't finish the CheckForDragBegin until after the NM_RCLICK
    // because apps want to display the context menu while the
    // temporary drag UI is still active.
    TV_FinishCheckDrag(pTree);

    if (fRet)
        SendMessage(pTree->ci.hwndParent, WM_CONTEXTMENU, (WPARAM)pTree->ci.hwnd, GetMessagePos());
}


// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is invalidated
//
// ----------------------------------------------------------------------------

void TV_InvalidateItem(PTREE pTree, TREEITEM * hItem, UINT fRedraw)
{
    RECT rc;

    if (hItem && pTree->fRedraw && TV_GetItemRect(pTree, hItem, &rc, FALSE))
    {
        RedrawWindow(pTree->ci.hwnd, &rc, NULL, fRedraw);
    }
}

//
//  Given an item, compute where the text of this item ends up being painted.
//  Basically, stare at TV_DrawItem and dutifully reproduce all the code that
//  messes with the x-coordinate.
//
int ITEM_OFFSET(PTREE pTree, HTREEITEM hItem)
{
    int x = pTree->cxBorder + (hItem->iLevel * pTree->cxIndent);

    // state image
    if (pTree->himlState && TV_StateIndex(hItem))
        x += pTree->cxState;

    // image
    if (pTree->hImageList) {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // "plus" at the front of the tree
    if ((pTree->ci.style & TVS_LINESATROOT) &&
        (pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)))
        x += pTree->cxIndent;


    return x;
}

// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is filled into lprc
//
//  Returns TRUE if the item is shown, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL TV_GetItemRect(PTREE pTree, TREEITEM * hItem, LPRECT lprc, BOOL bItemRect)
{
    UINT iOffset;

    if (!hItem)
        return FALSE;

    DBG_ValidateTreeItem(hItem, 0);

    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    iOffset = hItem->iShownIndex - pTree->hTop->iShownIndex;

    if (bItemRect)
    {
        // Calculate where X position should start...
        lprc->left = -pTree->xPos + ITEM_OFFSET(pTree, hItem);
        lprc->right = lprc->left + hItem->iWidth;
    }
    else 
    {
        lprc->left = 0;
        lprc->right = pTree->cxWnd;
    }

    lprc->top = iOffset * pTree->cyItem;
    lprc->bottom = lprc->top + (pTree->cyItem * hItem->iIntegral) ;

    return TRUE;
}

void TV_OnSetRedraw(PTREE pTree, BOOL fRedraw)
{
    pTree->fRedraw = TRUE && fRedraw;
    if (pTree->fRedraw)
    {
        // This use to only refresh the items from hTop down, this is bad as if items are inserted
        // before the visible point within the tree then we would fail!
        if ( pTree->hRoot )
            pTree->cShowing = TV_UpdateShownIndexes(pTree,pTree->hRoot);

        //  Must force recalculation of all tree items to get the right cxMax.
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE); //REVIEW: could be smarter
    }
}

//  Treeview item watching implementation
//
//  You need to "watch" an item any time you hold onto its HTREEITEM
//  and then yield control to the application.  If you didn't watch
//  the item, then if the app deletes the item, you end up with a
//  stale HTREEITEM pointer and fault.
//
//  To begin watching an item, call TV_StartWatch with the item you
//  want to start watching.  When finished watching, call TV_EndWatch.
//
//  In between, you can call TV_IsWatchStale() which tells you if the
//  item has been deleted behind your back and you shouldn't use it.
//  Alternatively, use TV_IsWatchValid() which says if it's okay.
//
//  Additional bonus behavior for enumeration:  If the watched item
//  is deleted, we cache the hNext item so that you can step to the
//  item after the one that got deleted.  Note that this works even
//  if the hNext item gets deleted before you get a chance to look,
//  because we just move the cached item to the hNext's hNext.
//
//  Sample usage for watching:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiStartHere)) {
//      FunctionThatYields();
//      if (TV_IsWatchValid(pTree, &wi)) {
//          KeepUsing(htiStartHere);
//      } else {
//          // item was deleted while we yielded; stop using it
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//  Sample usage for enumerating:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiFirst)) {
//      while (TV_GetWatchItem(pTree, &wi)) {
//          FunctionThatYields(TV_GetWatchItem(pTree, &wi));
//          if (TV_IsWatchValid(pTree, &wi)) {
//              KeepUsing(htiStartHere);
//          } else {
//              // item was deleted while we yielded; stop using it
//          }
//          TV_NextWatchItem(pTree, &wi);
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//
//

//
//  TV_StartWatch - Begin watching an item.
//
//  Returns FALSE if out of memory.
//
BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart)
{
    pwi->hti = htiStart;
    pwi->fStale = FALSE;
    return DPA_AppendPtr(pTree->hdpaWatch, pwi) != -1;
}

//
//  TV_EndWatch - Remove the item from the watch list.
//
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi)
{
    int i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwiT = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwiT);
        if (pwi == pwiT)
        {
            DPA_DeletePtr(pTree->hdpaWatch, i);
            return TRUE;
        }
    }
    ASSERT(!"TV_EndWatch: Item not in list");
    return FALSE;
}

//  End of treeview item watching implementation

void TV_SetItemRecurse(PTREE pTree, TREEITEM *hItem, LPTVITEMEX ptvi)
{
    // Note:  This code assumes nobody will try to delete an item
    //        during a SetItem notification.
    while (hItem) {
        ptvi->hItem = hItem;
        TV_SetItem(pTree, ptvi);
        if (hItem->hKids) {
            TV_SetItemRecurse(pTree, hItem->hKids, ptvi);
        }

        hItem = hItem->hNext;
    }
}

BOOL TV_DoExpandRecurse(PTREE pTree, TREEITEM *hItem, BOOL fNotify)
{
    TVWATCHEDITEM wi;
    BOOL fRc = FALSE;

    if (TV_StartWatch(pTree, &wi, hItem))
    {
        while ((hItem = TV_GetWatchItem(pTree, &wi))) {

            // was the escape key pressed at any point since the last check?
            if (GetAsyncKeyState(VK_ESCAPE) & 0x1)
                goto failed;

            TV_Expand(pTree, TVE_EXPAND, hItem, fNotify); // yields
            if (TV_IsWatchValid(pTree, &wi)) {
                if (hItem->hKids) {
                    if (!TV_DoExpandRecurse(pTree, hItem->hKids, fNotify))
                        goto failed;
                }
            }
            TV_NextWatchItem(pTree, &wi);
        }
        fRc = TRUE;
    failed:
        TV_EndWatch(pTree, &wi);
    }
    return fRc;
}


void TV_ExpandRecurse(PTREE pTree, TREEITEM *hItem, BOOL fNotify)
{
    BOOL fRedraw = pTree->fRedraw;

    TV_OnSetRedraw(pTree, FALSE);
    
    // we're going to check this after each expand so clear it first
    GetAsyncKeyState(VK_ESCAPE);
    
    TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
    // Bug#94345 hItem may have gone bad during that TV_Expand
    TV_DoExpandRecurse(pTree, hItem->hKids, fNotify);
    TV_OnSetRedraw(pTree, fRedraw);
}

void TV_ExpandParents(PTREE pTree, TREEITEM *hItem, BOOL fNotify)
{
    if (hItem == TVI_ROOT || hItem == NULL) // Root has no parents
    {
        return;
    }

    hItem = hItem->hParent;
    if (hItem) {
        TVWATCHEDITEM wi;
        if (TV_StartWatch(pTree, &wi, hItem)) {
            TV_ExpandParents(pTree, hItem, fNotify);

            // Item may have gone invalid during expansion
            if (TV_IsWatchValid(pTree, &wi) &&

                // make sure this item is not in a collapsed branch
                !(hItem->state & TVIS_EXPANDED)) {

                TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
            }
            TV_EndWatch(pTree, &wi);
        }
    }
}

// makes sure an item is expanded and scrolled into view

BOOL TV_EnsureVisible(PTREE pTree, TREEITEM * hItem)
{
    TV_ExpandParents(pTree, hItem, TRUE);
    return TV_ScrollIntoView(pTree, hItem);
}

//
//  Walk up the tree towards the root until we find the item at level iLevel.
//  Note the cast to (char) because iLevel is a BYTE, so the root's level is
//  0xFF.  Casting to (char) turns 0xFF it into -1.
//
HTREEITEM TV_WalkToLevel(HTREEITEM hWalk, int iLevel)
{
    int i;
    for (i = (char)hWalk->iLevel - iLevel; i > 0; i--)
        hWalk = hWalk->hParent;
    return hWalk;
}

// this is to handle single expand mode.
// The new selection is toggled, and the old selection is collapsed

// assume that parents of hNewSel are already fully expanded
// to do this, we build a parent dpa for the old and new
// then go through find the first parent node of the old selection that's not in
// the new sel tree.  and expand that.
void TV_ExpandOnSelChange(PTREE pTree, TREEITEM *hNewSel, TREEITEM *hOldSel)
{
    LRESULT dwAbort;
    NM_TREEVIEW nm;
    BOOL fCollapsing;
    TVWATCHEDITEM wiOld, wiNew;

    // Revalidate hNewSel and hOldSel since they may have been deleted
    // during all the notifications that occurred in the meantime.
    if (!ValidateTreeItem(hOldSel, VTI_NULLOK) ||
        !ValidateTreeItem(hNewSel, VTI_NULLOK))
        return;

    if (TV_StartWatch(pTree, &wiOld, hOldSel))
    {
        if (TV_StartWatch(pTree, &wiNew, hNewSel))
        {
            // Let the app clean up after itself
            nm.itemOld.hItem = hOldSel;
            if (hOldSel)
                nm.itemOld.lParam = hOldSel->lParam;
            nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);

            nm.itemNew.hItem = hNewSel;
            if (hNewSel)
                nm.itemNew.lParam = hNewSel->lParam;
            nm.itemNew.mask = (TVIF_HANDLE | TVIF_PARAM);

            dwAbort = CCSendNotify(&pTree->ci, TVN_SINGLEEXPAND, &nm.hdr);

            UpdateWindow(pTree->ci.hwnd);

            // Revalidate hNewSel and hOldSel since they may have been deleted
            // by that notification.
            if (!TV_IsWatchValid(pTree, &wiOld) ||
                !TV_IsWatchValid(pTree, &wiNew))
                goto cleanup;

            // Collapse if the NewSel currently expanded.
            fCollapsing = hNewSel && (hNewSel->state & TVIS_EXPANDED);

            // Note that Ctrl+select allows the user to suppress the collapse
            // of the old selection.
            if (!(dwAbort & TVNRET_SKIPOLD)  && hOldSel && GetKeyState(VK_CONTROL) >= 0)
            {
                if (!(pTree->dwExStyle & TVS_EX_NOSINGLECOLLAPSE) )
            	{
                    //
                    //  Collapse parents until we reach the common ancestor between
                    //  hOldSel and hNewSel.  Note carefully that we don't cache
                    //  any HTREEITEMs to avoid revalidation problems.
                    //

                    //
                    //  Find the common ancestor, which might be the tree root.
                    //
                    int iLevelCommon;

                    if (!hNewSel)
                        iLevelCommon = -1;          // common ancestor is root
                    else
                    {
                        HTREEITEM hItemO, hItemN;
                        iLevelCommon = min((char)hOldSel->iLevel, (char)hNewSel->iLevel);
                        hItemO = TV_WalkToLevel(hOldSel, iLevelCommon);
                        hItemN = TV_WalkToLevel(hNewSel, iLevelCommon);
                        while (iLevelCommon >= 0 && hItemO != hItemN) {
                            iLevelCommon--;
                            hItemO = hItemO->hParent;
                            hItemN = hItemN->hParent;
                        }
                    }

                    //
                    //  Now walk up the tree from hOldSel, collapsing everything
                    //  until we reach the common ancestor.  Do not collapse the
                    //  common ancestor.
                    //

                    while ((char)hOldSel->iLevel > iLevelCommon)
                    {
                        TV_Expand(pTree, TVE_COLLAPSE, hOldSel, TRUE);
                        if (!TV_IsWatchValid(pTree, &wiOld))
                            break;
                        hOldSel = hOldSel->hParent;
                        TV_RestartWatch(pTree, &wiOld, hOldSel);
                    }
                }
                else if (hNewSel && hOldSel->hParent == hNewSel->hParent) // Only if are direct siblings
            	{
                    TV_Expand(pTree, TVE_COLLAPSE, hOldSel, TRUE);
                }
            }

            if ((!(dwAbort & TVNRET_SKIPNEW)) && hNewSel && TV_IsWatchValid(pTree, &wiNew) && 
                (!(pTree->dwExStyle & TVS_EX_NOSINGLECOLLAPSE) || !(hNewSel->state & TVIS_EXPANDED)))
            {
            	WPARAM wParam = pTree->dwExStyle & TVS_EX_NOSINGLECOLLAPSE ? TVE_EXPAND : TVE_TOGGLE;
                TV_Expand(pTree, wParam, hNewSel, TRUE);
                UpdateWindow(pTree->ci.hwnd);
            }

cleanup:
            TV_EndWatch(pTree, &wiNew);
        }
        TV_EndWatch(pTree, &wiOld);
    }
}

// ----------------------------------------------------------------------------
//
//  Notify the parent that the selection is about to change.  If the change is
//  accepted, de-select the current selected item and select the given item
//
//  sets hCaret
//
// in:
//      hItem   item to become selected
//      wType   TVGN_ values (TVGN_CARET, TVGN_DROPHILIGHT are only valid values)
//      flags   combination of flags
//          TVSIFI_NOTIFY        - send notify to parent window
//          TVSIFI_UPDATENOW     - do UpdateWindow() to force sync painting
//          TVSIFI_NOSINGLEEXPAND- don't do single-expand stuff
//      action  action code to send identifying how selection is being made
//
//  NOTE: Multiple Selection still needs to be added -- this multiplesel code
//        is garbage
//
// ----------------------------------------------------------------------------

BOOL TV_SelectItem(PTREE pTree, WPARAM wType, TREEITEM * hItem, UINT flags, UINT action)
{
    UINT uRDWFlags = RDW_INVALIDATE;

    if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
        uRDWFlags |= RDW_ERASE;

    if (!ValidateTreeItem(hItem, VTI_NULLOK))
        return FALSE;                   // Invalid parameter

    switch (wType) {

    case TVGN_FIRSTVISIBLE:
        if (!hItem)
            return FALSE;

        TV_EnsureVisible(pTree, hItem);
        if (pTree->fVert) TV_SetTopItem(pTree, hItem->iShownIndex);
        break;

    case TVGN_DROPHILITE:

        ASSERT(hItem == NULL || ITEM_VISIBLE(hItem));

        if (hItem != pTree->hDropTarget) {
            if (pTree->hDropTarget) {
                pTree->hDropTarget->state &= ~TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, pTree->hDropTarget, uRDWFlags);
            }

            if (hItem) {
                hItem->state |= TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, hItem, uRDWFlags);
            }
            pTree->hDropTarget = hItem;

            if (pTree->hCaret) {
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }


            if (flags & TVSIFI_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);
        }
        break;

    case TVGN_CARET:

        // REVIEW: we may want to scroll into view in this case
        // it's already the selected item, just return
        if (pTree->hCaret != hItem) 
        {
            TREEITEM * hOldSel;

            if ((flags & TVSIFI_NOTIFY) && TV_SendSelChange(pTree, TVN_SELCHANGING, pTree->hCaret, hItem, action))
                return FALSE;

            if (pTree->hCaret) {
                pTree->hCaret->state &= ~TVIS_SELECTED;
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }

            hOldSel = pTree->hCaret;
            pTree->hCaret = hItem;

            if (hItem) 
            {
                hItem->state |= TVIS_SELECTED;

                // make sure this item is not in a collapsed branch
                TV_ExpandParents(pTree, hItem, (flags & TVSIFI_NOTIFY));

                TV_InvalidateItem(pTree, hItem, uRDWFlags );

                if (action == TVC_BYMOUSE) {
                    // if selected by mouse, let's wait a doubleclick sec before scrolling
                    SetTimer(pTree->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
                    pTree->fScrollWait = TRUE;
                } else if (pTree->fRedraw)
                    TV_ScrollVertIntoView(pTree, hItem);
            }
            if (pTree->hwndToolTips)
                TV_Timer(pTree, IDT_TOOLTIPWAIT);

            if (flags & TVSIFI_NOTIFY)
                TV_SendSelChange(pTree, TVN_SELCHANGED, hOldSel, hItem, action);

            if ((pTree->ci.style & TVS_SINGLEEXPAND) &&
                !(flags & TVSIFI_NOSINGLEEXPAND) &&
                action != TVC_BYKEYBOARD &&
                hOldSel)
            {
                TV_ExpandOnSelChange(pTree, pTree->hCaret, hOldSel);
            }

            if (flags & TVSIFI_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);

            NotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                TV_GetAccId(hItem));
            NotifyWinEvent(EVENT_OBJECT_SELECTION, pTree->ci.hwnd, OBJID_CLIENT,
                TV_GetAccId(hItem));
        }
        break;

    default:
        DebugMsg(DM_TRACE, TEXT("Invalid type passed to TV_SelectItem"));
        return FALSE;
    }

    return TRUE;        // success
}

// remove all the children, but pretend they are still there

BOOL TV_ResetItem(PTREE pTree, HTREEITEM hItem)
{
    TV_DeleteItem(pTree, hItem, TVDI_CHILDRENONLY);

    hItem->state &= ~TVIS_EXPANDEDONCE;
    hItem->fKids = KIDS_FORCE_YES;      // force children

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Expand or collapse an item's children
//  Returns TRUE if any change took place and FALSE if unchanged
//
// ----------------------------------------------------------------------------

BOOL TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM * hItem, BOOL fNotify)
{
    WORD fOldState;
    UINT cntVisDescendants;
    TVITEMEX sItem;
    TREEITEM * hItemExpanding;

// deal with the evil invisible root for multiple root trees.
    hItemExpanding = hItem;
    if ((hItem == NULL) || (hItem == TVI_ROOT))
        hItem = pTree->hRoot;

    DBG_ValidateTreeItem(hItem, 0);

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);

    if (!(wCode & TVE_ACTIONMASK) || sItem.cChildren == 0)
        return FALSE;           // no children to expand or collapse

    if ((wCode & TVE_ACTIONMASK) == TVE_TOGGLE) {
        wCode = (wCode & ~TVE_ACTIONMASK);

        // if it's not expaned, or not fully expanded, expand now
        wCode |=
            (((!(hItem->state & TVIS_EXPANDED)) ||
              hItem->state & TVIS_EXPANDPARTIAL) ?
             TVE_EXPAND : TVE_COLLAPSE);
    }

    if (((wCode & TVE_ACTIONMASK) == TVE_EXPAND) && !(hItem->state & TVIS_EXPANDEDONCE))
    {
        // if its the first expand, ALWAYS notify the parent
        fNotify = TRUE;
    }

    // at this point the children may be added if they aren't already there (callback)

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDING, hItemExpanding, wCode))
        return FALSE;

    // if (!hItem->hKids && (hItem->fKids == KIDS_FORCE_NO))    // this may be right, but I don't
                                                                // have proof now.
    if (!hItem->hKids)
    {
        // kids we removed, or never there
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
        return FALSE;
    }

    fOldState = hItem->state;

    if (hItem->hParent) // never turn off TVIS_EXPANED for the invisible root
    {
        if ((wCode & TVE_ACTIONMASK) == TVE_EXPAND)
           hItem->state |= TVIS_EXPANDED;
        else
           hItem->state &= ~(TVIS_EXPANDED | TVIS_EXPANDPARTIAL);

        if (wCode & TVE_EXPANDPARTIAL) {
            hItem->state |= TVIS_EXPANDPARTIAL;
        } else {
            hItem->state &= ~(TVIS_EXPANDPARTIAL);
        }
    }

    // if we're not changing the expanded state
    // check to see if we're supposed to collapse reset
    if (!(fOldState & TVIS_EXPANDED) &&
        !(hItem->state & TVIS_EXPANDED))
    {
        if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
        {
            TV_ResetItem(pTree, hItem);
        }

        return FALSE;
    }

    // if we changed expaneded states, recalc the scrolling
    if ((fOldState ^ hItem->state) & TVIS_EXPANDED) {

        cntVisDescendants = TV_ScrollBelow(pTree, hItem, TRUE, hItem->state & TVIS_EXPANDED);

        if (hItem->state & TVIS_EXPANDED)
        {
            UINT wNewTop, wTopOffset, wLastKid;

            TV_ScrollBarsAfterExpand(pTree, hItem);

            wNewTop = pTree->hTop->iShownIndex;
            wTopOffset = hItem->iShownIndex - wNewTop;

            wLastKid = wTopOffset + cntVisDescendants + 1;

            if (wLastKid > pTree->cFullVisible)
            {
                wNewTop += min(wLastKid - pTree->cFullVisible, wTopOffset);
                TV_SetTopItem(pTree, wNewTop);
            }
        }
        else
        {
            TV_ScrollBarsAfterCollapse(pTree, hItem);
            TV_ScrollVertIntoView(pTree, hItem);

            // If we collapsed the subtree that contains the caret, then
            // pop the caret back to the last visible ancestor
            // Pass TVIS_NOSINGLEEXPAND so we won't expand an item right
            // after we collapsed it (d'oh!)
            if (pTree->hCaret)
            {
                TREEITEM * hWalk = TV_WalkToLevel(pTree->hCaret, hItem->iLevel);

                if (hWalk == hItem)
                {
                    TV_SelectItem(pTree, TVGN_CARET, hItem, (fNotify ? TVSIFI_NOTIFY : 0) | TVSIFI_UPDATENOW | TVSIFI_NOSINGLEEXPAND, TVC_UNKNOWN);
                }
            }
        }
    } else if ((fOldState ^ hItem->state) & TVIS_EXPANDPARTIAL) {
        // we didn't change the expanded state, only the expand partial
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
    }

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDED, hItem, wCode))
        return FALSE;

    hItem->state |= TVIS_EXPANDEDONCE;

    if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
    {
        TV_ResetItem(pTree, hItem);
    }

    // Bug#94368 raymondc v6 we generate a notification even if nothing happened,
    // which confuses accessibility.  E.g., app tried to expand something
    // that was already expanded.  Explorer Band does this when you navigate.
    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
        TV_GetAccId(hItem));

    return TRUE;
}

BOOL BetweenItems(PTREE pTree, HTREEITEM hItem, HTREEITEM hItemStart, HTREEITEM hItemEnd)
{
    if (hItemStart) {
        while ((hItemStart = TV_GetNextVisItem(hItemStart)) && (hItemEnd != hItemStart))
        {
            if (hItem == hItemStart)
                return TRUE;
        }
    }
    return FALSE;
}

// Now only Korean version is interested in incremental search with composition string.

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL TV_OnImeComposition(PTREE pTree, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    if (hImc = ImmGetContext(pTree->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&pTree->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }

        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&pTree->is, TRUE, pszCompStr, &lpsz))
                {
                    if (pTree->hCaret)
                    {
                        pTree->htiSearch = pTree->hCaret;
                    } 
                    else if (pTree->hRoot && pTree->hRoot->hKids)
                    {
                        pTree->htiSearch = pTree->hRoot->hKids;
                    } else
                        return fRet;
                }

                if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
                    return fRet;

                hItem = pTree->htiSearch;
                ti.cchTextMax  = sizeof(szTemp);
                iLen = lstrlen(lpsz);
                if (iLen > 1 && SameChars(lpsz, lpsz[0]))
                    lpszAlt = lpsz + iLen - 1;

                do 
                {
                    ti.pszText = szTemp;
                    hItem = TV_GetNextVisItem(hItem);
                    if (!hItem) 
                    {
                        iCycle++;
                        hItem = pTree->hRoot->hKids;
                    }

                    TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
                    if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
                        HIWORD64(ti.pszText)) 
                    {
                        // DebugMsg(DM_TRACE, "treesearch %d %s %s", (LPSTR)lpsz, (LPSTR)lpsz, (LPSTR)ti.pszText);
                        if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
                            (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
                             BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
                        {
                            DebugMsg(DM_TRACE, TEXT("Selecting"));
                            TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIFI_NOTIFY | TVSIFI_UPDATENOW, TVC_BYKEYBOARD);
                            //notify of navigation key usage
                            CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                            return fRet;
                        }
                    }
                }  while(iCycle < 2);

                // if they hit the same key twice in a row at the beginning of
                // the search, and there was no item found, they likely meant to
                // retstart the search
                if (lpszAlt)
                {

                    // first clear out the string so that we won't recurse again
                    IncrementSearchString(&pTree->is, 0, NULL);
                    TV_OnImeComposition(pTree, wParam, lParam);
                } 
                else 
                {
                    IncrementSearchBeep(&pTree->is);
                }
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(pTree->ci.hwnd, hImc);
    }
    return fRet;
}


void TV_OnChar(PTREE pTree, UINT ch, int cRepeat)
{
    LPTSTR lpsz = NULL;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;

    if (IncrementSearchString(&pTree->is, ch, &lpsz) || !pTree->htiSearch) 
    {
        if (pTree->hCaret) 
        {
            pTree->htiSearch = pTree->hCaret;
        } 
        else if (pTree->hRoot && pTree->hRoot->hKids) 
        {
            pTree->htiSearch = pTree->hRoot->hKids;
        } else
            return;
    }

    if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
        return;

    hItem = pTree->htiSearch;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    iLen = lstrlen(lpsz);
    if (iLen > 1 && SameChars(lpsz, lpsz[0]))
        lpszAlt = lpsz + iLen - 1;

    do {
        ti.pszText = szTemp;
        hItem = TV_GetNextVisItem(hItem);
        if (!hItem) {
            iCycle++;
            hItem = pTree->hRoot->hKids;
        }

        TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
        if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
            HIWORD64(ti.pszText)) {
            // DebugMsg(DM_TRACE, TEXT("treesearch %d %s %s"), (LPTSTR)lpsz, (LPTSTR)lpsz, (LPTSTR)ti.pszText);
            if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
                (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
                 BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
            {
                DebugMsg(DM_TRACE, TEXT("Selecting"));
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIFI_NOTIFY | TVSIFI_UPDATENOW, TVC_BYKEYBOARD);

                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                return;
            }
        }
    }  while(iCycle < 2);

    // if they hit the same key twice in a row at the beginning of
    // the search, and there was no item found, they likely meant to
    // retstart the search
    if (lpszAlt) 
    {

        // first clear out the string so that we won't recurse again
        IncrementSearchString(&pTree->is, 0, NULL);
        TV_OnChar(pTree, ch, cRepeat);
    } 
    else 
    {
        IncrementSearchBeep(&pTree->is);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
}

// ----------------------------------------------------------------------------
//
//  Handle WM_KEYDOWN messages
//  If control key is down, treat keys as scroll codes; otherwise, treat keys
//  as caret position changes.
//
// ----------------------------------------------------------------------------

BOOL TV_KeyDown(PTREE pTree, WPARAM wKey, LPARAM dwKeyData)
{
    TREEITEM * hItem;
    UINT wShownIndex;
    TV_KEYDOWN nm;
    BOOL fPuntChar;
    BOOL ret = TRUE;

    // Notify
    nm.wVKey = (WORD)wKey;
    fPuntChar = (BOOL)CCSendNotify(&pTree->ci, TVN_KEYDOWN, &nm.hdr);

    wKey = RTLSwapLeftRightArrows(&pTree->ci, wKey);

    if (GetKeyState(VK_CONTROL) < 0)
    {
        // control key is down
        UINT wScrollCode;

        switch (wKey)
        {
            case VK_LEFT:
                TV_HorzScroll(pTree, SB_LINEUP, 0);
                break;

            case VK_RIGHT:
                TV_HorzScroll(pTree, SB_LINEDOWN, 0);
                break;

            case VK_PRIOR:
                wScrollCode = SB_PAGEUP;
                goto kdVertScroll;

            case VK_HOME:
                wScrollCode = SB_TOP;
                goto kdVertScroll;

            case VK_NEXT:
                wScrollCode = SB_PAGEDOWN;
                goto kdVertScroll;

            case VK_END:
                wScrollCode = SB_BOTTOM;
                goto kdVertScroll;

            case VK_UP:
                wScrollCode = SB_LINEUP;
                goto kdVertScroll;

            case VK_DOWN:
                wScrollCode = SB_LINEDOWN;
kdVertScroll:
                TV_VertScroll(pTree, wScrollCode, 0);
                break;

            default:
                ret = FALSE;
        }

    } else {

        switch (wKey)
        {
        case VK_RETURN:
            fPuntChar = (BOOL)CCSendNotify(&pTree->ci, NM_RETURN, NULL);
            break;

        case VK_PRIOR:
            if (pTree->hCaret && (pTree->hCaret->iShownIndex > (pTree->cFullVisible - 1)))
            {
                wShownIndex = pTree->hCaret->iShownIndex - (pTree->cFullVisible - 1);
                goto selectIndex;
            }
            // fall thru

        case VK_HOME:
            wShownIndex = 0;
            goto selectIndex;

        case VK_NEXT:
            if (!pTree->hCaret)
            {
                wShownIndex = 0;
                goto selectIndex;
            }
            wShownIndex = pTree->hCaret->iShownIndex + (pTree->cFullVisible - 1);
            if (wShownIndex < pTree->cShowing)
                goto selectIndex;
            // fall thru

        case VK_END:
            wShownIndex = pTree->cShowing - 1;
selectIndex:
            hItem = TV_GetShownIndexItem(pTree->hRoot->hKids, wShownIndex);
            goto kdSetCaret;
            break;

        case VK_SUBTRACT:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
            }
            break;

        case VK_ADD:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
            }
            break;

        case VK_MULTIPLY:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_ExpandRecurse(pTree, pTree->hCaret, TRUE);
            }
            break;

        case VK_LEFT:
            if (pTree->hCaret && (pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
                break;
            } else if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_BACK:
            // get the parent, avoiding the root item
            fPuntChar = TRUE;
            if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_UP:
            if (pTree->hCaret)
                hItem = TV_GetPrevVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

            goto kdSetCaret;
            break;


        case VK_RIGHT:
            if (pTree->hCaret && !(pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
                break;
            } // else fall through

        case VK_DOWN:
            if (pTree->hCaret)
                hItem = TV_GetNextVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

kdSetCaret:
            if (hItem)
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIFI_NOTIFY | TVSIFI_UPDATENOW, TVC_BYKEYBOARD);

            break;

        case VK_SPACE:
            if ((pTree->ci.style & TVS_CHECKBOXES) && pTree->hCaret)
            {
                TV_HandleStateIconClick(pTree, pTree->hCaret);
                fPuntChar = TRUE; // don't beep
            }
            break;

        default:
            ret = FALSE;
        }
    }

    if (fPuntChar) {
        pTree->iPuntChar++;
    } else if (pTree->iPuntChar){
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while((pTree->iPuntChar > 0) && PeekMessage(&msg, pTree->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
            pTree->iPuntChar--;
        }
        //ASSERT(!pTree->iPuntChar);
    }


    if ( VK_MENU!=wKey )
    {
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
    }

    return ret;

}


// ----------------------------------------------------------------------------
//
//  Sets the tree's indent width per hierarchy level and recompute widths.
//
//  sets cxIndent
//
// ----------------------------------------------------------------------------

void TV_SetIndent(PTREE pTree, WPARAM cxIndent)
{
    if (pTree->hImageList) {
        if ((SHORT)cxIndent < pTree->cxImage)
            cxIndent = pTree->cxImage;
    }

    if ((SHORT)cxIndent < pTree->cyText)
        cxIndent = pTree->cyText;

    if (cxIndent < MAGIC_MININDENT)
        cxIndent = MAGIC_MININDENT;

    pTree->cxIndent = (SHORT)cxIndent;

    TV_CreateIndentBmps(pTree);
    TV_ScrollBarsAfterSetWidth(pTree, NULL);
}

// ----------------------------------------------------------------------------
//
//  Sets the tree's item height to be the maximum of the image height and text
//  height.  Then recompute the tree's full visible count.
//
//  sets cyItem, cFullVisible
//
// ----------------------------------------------------------------------------

void TV_SetItemHeight(PTREE pTree)
{
    // height MUST be even with TVS_HASLINES -- go ahead and make it always even
    if (!pTree->fCyItemSet)
        pTree->cyItem = (max(pTree->cyImage, pTree->cyText) + 1);
    // height not always even not, only on haslines style.
    if (pTree->cyItem <= 1) {
        pTree->cyItem = 1;          // Don't let it go zero or negative!
    } else if (!(pTree->ci.style & TVS_NONEVENHEIGHT))
        pTree->cyItem &= ~1;

    pTree->cFullVisible = pTree->cyWnd / pTree->cyItem;

    TV_CreateIndentBmps(pTree);
    TV_CalcScrollBars(pTree);
}

HIMAGELIST TV_SetImageList(PTREE pTree, HIMAGELIST hImage, int iImageIndex)
{
    HIMAGELIST hImageOld = NULL;
    int cx;
    int cy;

    switch (iImageIndex) 
    {

        case TVSIL_STATE:

            hImageOld = pTree->himlState;
            pTree->himlState = hImage;
            if (hImage) 
            {
                CCGetIconSize(&pTree->ci, hImage, &pTree->cxState , &pTree->cyState);
            } 
            else 
            {
                pTree->cxState = 0;
            }
            break;

        case TVSIL_NORMAL:
            hImageOld = pTree->hImageList;
            if (hImage && CCGetIconSize(&pTree->ci, hImage, &cx, &cy))
            {
                pTree->cxNativeImage = (SHORT)cx;
                pTree->cyNativeImage = (SHORT)cy;

                pTree->cxImage = (SHORT)((pTree->cxNativeImage) + MAGIC_INDENT);
                pTree->cyImage = (SHORT)(pTree->cyNativeImage);

                if (pTree->cxIndent < pTree->cxImage)
                    TV_SetIndent(pTree, pTree->cxImage);
                pTree->hImageList = hImage;

                if (!hImageOld && pTree->ci.style & TVS_CHECKBOXES)
                {
                    TV_InitCheckBoxes(pTree);
                }
            }
            else
            {
                pTree->cxImage = 0;
                pTree->cyImage = 0;
                pTree->cxNativeImage = 0;
                pTree->cyNativeImage = 0;
                pTree->hImageList = NULL;
            }
            break;

        default:
            DebugMsg(DM_TRACE, TEXT("sh TR - TVM_SETIMAGELIST: unrecognized iImageList"));
            break;

    }

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    return hImageOld;
}

// Bug#94345: does not deal with hfont == NULL

void TV_OnSetFont(PTREE pTree, HFONT hNewFont, BOOL fRedraw)
{
    HDC hdc;
    HFONT hfontSel;
    TCHAR c = TEXT('J');       // for bog
    SIZE size;

    if (pTree->fCreatedFont && pTree->hFont) {
        DeleteObject(pTree->hFont);
        pTree->fCreatedFont = FALSE;
    }

    if (hNewFont == NULL) {
        LOGFONT lf;
        HRESULT hr = E_FAIL;

        // Create identical theme font. Although theme manager APIs will be used for drawing text,
        // create a copy of the normal state font. The control will be sized based on this font's dimensions
        if (pTree->hTheme)
        {
            ZeroMemory(&lf, sizeof(LOGFONT));
            hr = GetThemeFont(pTree->hTheme, NULL, TVP_TREEITEM, TREIS_NORMAL, TMT_FONT, &lf);
        }

        if (FAILED(hr))
        {
            SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        }

        hNewFont = CreateFontIndirect(&lf);
        pTree->fCreatedFont = TRUE;         // make sure we delete it
    }

    hdc = GetDC(pTree->ci.hwnd);

    hfontSel = hNewFont ? SelectObject(hdc, hNewFont) : NULL;

    // Office9 Setup had a bug where they installed a bogus font,
    // which created okay but all APIs against it (e.g., GetTextExtentPoint)
    // failed!  Protect against failure by pre-setting the value to something
    // non-garbage.
    size.cy = 0;
    GetTextExtentPoint(hdc, &c, 1, &size);

    pTree->cyText = (SHORT)(size.cy + (g_cyBorder * 2));

    if (hfontSel)
        SelectObject(hdc, hfontSel);

    ReleaseDC(pTree->ci.hwnd, hdc);

    pTree->hFont = hNewFont;
    if (pTree->hFontBold)
        TV_CreateBoldFont(pTree);

    pTree->ci.uiCodePage = GetCodePageForFont(hNewFont);

    TV_DeleteHotFonts(pTree);

    TV_SetIndent(pTree, 16 /*g_cxSmIcon*/ + MAGIC_INDENT);
    TV_SetImageList(pTree, pTree->hImageList, TVSIL_NORMAL);

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    if (pTree->hwndToolTips)
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);

    // REVIEW: does this happen as a result of the above?
    // if (fRedraw)
    //    RedrawWindow(pTree->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

void TV_CreateBoldFont(PTREE pTree)
{
    LOGFONT lf;

    if (pTree->hFontBold)
        DeleteObject (pTree->hFontBold);

    GetObject(pTree->hFont, sizeof (lf), &lf);
    CCAdjustForBold(&lf);
    pTree->hFontBold = CreateFontIndirect(&lf);
}

// ----------------------------------------------------------------------------
//
//  Gets the item with the described relationship to the given item, NULL if
//  no item can be found with that relationship.
//
// ----------------------------------------------------------------------------

TREEITEM * TV_GetNextItem(PTREE pTree, TREEITEM * hItem, WPARAM wGetCode)
{
    switch (wGetCode) {
    case TVGN_ROOT:
        return pTree->hRoot->hKids;

    case TVGN_DROPHILITE:
        return pTree->hDropTarget;

    case TVGN_CARET:
        return pTree->hCaret;

    case TVGN_FIRSTVISIBLE:
        return pTree->hTop;

    case TVGN_LASTVISIBLE:
        return TV_GetShownIndexItem(pTree->hRoot->hKids, pTree->cShowing-1);

    case TVGN_CHILD:
        if (!hItem || (hItem == TVI_ROOT))
            return pTree->hRoot->hKids;
        break;
    }

    // all of these require a valid hItem
    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    switch (wGetCode) {
    case TVGN_NEXTVISIBLE:
        return TV_GetNextVisItem(hItem);

    case TVGN_PREVIOUSVISIBLE:
        return TV_GetPrevVisItem(hItem);

    case TVGN_NEXT:
        return hItem->hNext;

    case TVGN_PREVIOUS:
        if (hItem->hParent->hKids == hItem)
            return NULL;
        else {
            TREEITEM * hWalk;
            for (hWalk = hItem->hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);
            return hWalk;
        }

    case TVGN_PARENT:
        return VISIBLE_PARENT(hItem);

    case TVGN_CHILD:
        return hItem->hKids;
    }

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Returns the number of items (including the partially visible item at the
//  bottom based on the given flag) that fit in the tree's client window.
//
// ----------------------------------------------------------------------------

LRESULT TV_GetVisCount(PTREE pTree, BOOL fIncludePartial)
{
    int  i;

    if (!fIncludePartial)
        return(MAKELRESULTFROMUINT(pTree->cFullVisible));

    i = pTree->cFullVisible;

    if (pTree->cyWnd - (i * pTree->cyItem))
        i++;

    return i;
}


void TV_InvalidateInsertMarkRect(PTREE pTree, BOOL fErase)
{
    RECT rc;
    if (TV_GetInsertMarkRect(pTree, &rc))
        InvalidateRect(pTree->ci.hwnd, &rc, fErase);
}

// ----------------------------------------------------------------------------
//
//  recomputes tree's fields that rely on the tree's client window size
//
//  sets cxWnd, cyWnd, cFullVisible
//
// ----------------------------------------------------------------------------

BOOL TV_SizeWnd(PTREE pTree, UINT cxWnd, UINT cyWnd)
{
    RECT rc;
    UINT cxOld = pTree->cxWnd;
    if (!cxWnd || !cyWnd)
    {
        GetClientRect(pTree->ci.hwnd, &rc);
        cxWnd = rc.right;
        cyWnd = rc.bottom;
    }
    pTree->cxWnd = (SHORT)cxWnd;
    pTree->cyWnd = (SHORT)cyWnd;
    pTree->cFullVisible = cyWnd / pTree->cyItem;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        pTree->cxMax = (WORD) cxWnd;
    
    TV_CalcScrollBars(pTree);
    if (pTree->cxBorder)
    {
        rc.top = 0;
        rc.bottom = cyWnd;
        rc.right = cxOld;
        rc.left = cxOld - pTree->cxBorder;
        if (rc.left < (int)cxWnd) {
            // invalidate so clipping happens on right on size.
            InvalidateRect(pTree->ci.hwnd, &rc, TRUE);  
        }
    }

    TV_InvalidateInsertMarkRect(pTree, TRUE);

    return TRUE;
}


void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX tvi;
    int iState;

    tvi.stateMask = TVIS_STATEIMAGEMASK;
    TV_GetItem(pTree, hItem, TVIF_STATE, &tvi);

    iState = STATEIMAGEMASKTOINDEX(tvi.state & tvi.stateMask);
    iState %= (ImageList_GetImageCount(pTree->himlState) - 1);
    iState++;

    tvi.mask = TVIF_STATE;
    tvi.state = INDEXTOSTATEIMAGEMASK(iState);
    tvi.hItem = hItem;
    TV_SetItem(pTree, &tvi);

}


//
//  Eudora is a piece of work.
//
//  When they get a NM_DBLCLK notification from a treeview, they say,
//  "Oh, I know that treeview allocates its NMHDR from the stack, and
//  there's this local variable on Treeview's stack I'm really interested
//  in, so I'm going to hard-code an offset from the pnmhdr and read the
//  DWORD at that location so I can get at the local variable.  I will then
//  stop working if this value is zero."
//
//  The conversion to UNICODE changed our stack layout enough that they
//  end up always getting zero -- it's the NULL parameter which is the
//  final argument to CCSendNotify.  Since all this stack layout stuff is
//  sensitive to how the compiler's optimizer feels today, we create a
//  special notify structure Just For Eudora which mimics the stack layout
//  they expected to see in Win95.
//
typedef struct NMEUDORA {
    NMHDR   nmhdr;
    BYTE    Padding[48];
    DWORD   MustBeNonzero;      // Eudora fails to install if this is zero
} NMEUDORA;

// ----------------------------------------------------------------------------
//
//  WM_LBUTTONDBLCLK message -- toggle expand/collapse state of item's children
//  WM_LBUTTONDOWN message -- on item's button, do same as WM_LBUTTONDBLCLK,
//  otherwise select item and ensure that item is fully visible
//
// ----------------------------------------------------------------------------

void TV_ButtonDown(PTREE pTree, UINT wMsg, UINT wFlags, int x, int y, UINT TVBD_flags)
{
    UINT wHitCode;
    TREEITEM * hItem;
    HWND hwndTree;
    LRESULT lResult;
#ifdef _X86_
    NMEUDORA nmeu;
    nmeu.MustBeNonzero = 1;
    COMPILETIME_ASSERT(FIELD_OFFSET(NMEUDORA, MustBeNonzero) == 0x3C);
#endif

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down


    hItem = TV_CheckHit(pTree, x, y, &wHitCode);

    // Excel likes to destroy the entire tree when it gets a double-click
    // so we need to watch the item in case it vanishes behind our back.
    hwndTree = pTree->ci.hwnd;

    if (wMsg == WM_LBUTTONDBLCLK)
    {
        //
        // Cancel any name editing that might happen.
        //

        TV_CancelEditTimer(pTree);

        if (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON)) {
            goto ExpandItem;
        }

        //
        // Collapses node above the line double clicked on
        //
        else if ((pTree->ci.style & TVS_HASLINES) && (wHitCode & TVHT_ONITEMINDENT) &&
            (abs(x % pTree->cxIndent - pTree->cxIndent/2) <= g_cxDoubleClk)) {

            int i;

            for (i = hItem->iLevel - x/pTree->cxIndent + ((pTree->ci.style & TVS_LINESATROOT)?1:0); i > 1; i--)
                hItem = hItem->hParent;

ExpandItem:
#ifdef _X86_
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, &nmeu.nmhdr);
#else
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, NULL);
#endif
            if (!IsWindow(hwndTree))
                goto bail;
            if (!lResult) {
                // don't auto expand this if we're in single expand mode because the first click did it already
                if (!(pTree->ci.style & TVS_SINGLEEXPAND))
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }

        }

        pTree->fScrollWait = FALSE;

    } else {    // WM_LBUTTONDOWN

        if (wHitCode == TVHT_ONITEMBUTTON)
        {
            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {
                if (TVBD_flags & TVBD_FROMWHEEL)
                    TV_Expand(pTree, (TVBD_flags & TVBD_WHEELFORWARD) ? TVE_EXPAND : TVE_COLLAPSE, hItem, TRUE);
                else
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }
        }
        else if (wHitCode & TVHT_ONITEM ||
                ((pTree->ci.style & TVS_FULLROWSELECT) && (wHitCode & (TVHT_ONITEMRIGHT | TVHT_ONITEMINDENT))))
        {
            BOOL fSameItem, bDragging;

            ASSERT(hItem);

            fSameItem = (hItem == pTree->hCaret);

            if (TVBD_flags & TVBD_FROMWHEEL)
                bDragging = FALSE;
            else if (pTree->ci.style & TVS_DISABLEDRAGDROP)
                bDragging = FALSE;
            else {
                bDragging = TV_CheckForDragBegin(pTree, hItem, x, y);
                TV_FinishCheckDrag(pTree);
            }

            if (bDragging)
            {
                pTree->htiDrag = hItem;
                TV_SendBeginDrag(pTree, TVN_BEGINDRAG, hItem, x, y);
                return;
            }

            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {

                if (wHitCode == TVHT_ONITEMSTATEICON &&
                    (pTree->ci.style & TVS_CHECKBOXES)) {
                    TV_HandleStateIconClick(pTree, hItem);
                } else {

                    // Only set the caret (selection) if not dragging
                    TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIFI_NOTIFY | TVSIFI_UPDATENOW, TVC_BYMOUSE);

                    if (fSameItem && (wHitCode & TVHT_ONITEMLABEL) && pTree->fFocus &&
                        !(pTree->ci.style & TVS_SINGLEEXPAND))
                    {
                        //
                        // The item and window are currently selected and user clicked
                        // on label.  Try to enter into name editing mode.
                        //
                        SetTimer(pTree->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
                        pTree->fNameEditPending = TRUE;
                    }

                    if (fSameItem && (pTree->ci.style & TVS_SINGLEEXPAND) &&
                        (!(pTree->dwExStyle & TVS_EX_NOSINGLECOLLAPSE) || !(hItem->state & TVIS_EXPANDED)))
                    {
                        WPARAM wParam = pTree->dwExStyle & TVS_EX_NOSINGLECOLLAPSE ? TVE_EXPAND : TVE_TOGGLE;
                        TV_Expand(pTree, wParam, pTree->hCaret, TRUE);
                    }
                }
            }
        }
        else
        {
            CCSendNotify(&pTree->ci, NM_CLICK, NULL);
        }
    }

    if (!pTree->fFocus)
        SetFocus(pTree->ci.hwnd);

bail:;
}


// ----------------------------------------------------------------------------
//
//  Gets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------
BOOL TV_OnGetItem(PTREE pTree, LPTVITEMEX ptvi)
{
    if (!ptvi)
        return FALSE;

    if (!ValidateTreeItem(ptvi->hItem, 0))
        return FALSE;           // Invalid parameter

    TV_GetItem(pTree, ptvi->hItem, ptvi->mask, ptvi);

    return TRUE;        // success
}

BOOL TV_OnGetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    BOOL bRet;
    LPSTR pszA = NULL;
    LPWSTR pszW = NULL;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText)) {
        pszA = ptvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, ptvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL) {
            return FALSE;
        }
        ptvi->pszText = (LPSTR)pszW;
    }
    bRet = TV_OnGetItem(pTree, (LPTVITEMEXW)ptvi);
    if (pszA) {
        if (bRet && ptvi->cchTextMax)
            ConvertWToAN(pTree->ci.uiCodePage, pszA, ptvi->cchTextMax, (LPWSTR)(ptvi->pszText), -1);
        LocalFree(pszW);
        ptvi->pszText = pszA;
    }
    return bRet;
}

// ----------------------------------------------------------------------------
//
//  Sets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------

BOOL TV_SetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    LPSTR pszA = NULL;
    BOOL lRet;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText))
    {
        pszA = ptvi->pszText;
        ptvi->pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, pszA);

        if (ptvi->pszText == NULL)
        {
            ptvi->pszText = pszA;
            return -1;
        }
    }

    lRet = TV_SetItem(pTree, (LPCTVITEMEX)ptvi);

    if (pszA) {
        FreeProducedString(ptvi->pszText);
        ptvi->pszText = pszA;
    }

    return lRet;
}

BOOL TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi)
{
    UINT uRDWFlags = RDW_INVALIDATE;
    BOOL fEraseIfTransparent = FALSE;
    HTREEITEM hItem;
    BOOL bActualChange = FALSE; // HACK: We want to keep track of which
                                // attributes were changed from CALLBACK to
                                // "real", and don't invalidate if those were
                                // the only changes
    int iIntegralPrev;
    BOOL fName = FALSE;
    BOOL fFocusSel = FALSE;
    BOOL fRecalcWidth = FALSE;
    BOOL fStateImageChange = FALSE;

    if (!ptvi)
        return FALSE;

    hItem = ptvi->hItem;

    // deal with the evil invisible root for multiple root trees.
    if (hItem == TVI_ROOT)
    {
        hItem = pTree->hRoot;
    }

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    iIntegralPrev = hItem->iIntegral;

    // Bug#94368: send ITEMCHANING and ITEMCHANGED msgs

    if (ptvi->mask & TVIF_TEXT)
    {
        uRDWFlags |= RDW_ERASE;
        bActualChange = TRUE;

        if (!ptvi->pszText)
        {
            Str_Set(&hItem->lpstr, LPSTR_TEXTCALLBACK);
        }
        else
        {
#ifdef DEBUG
            ASSERTMSG(!pTree->fInTextCallback, "set item (text) getting called while we are in text callback!");
#endif
            if (!Str_Set(&hItem->lpstr, ptvi->pszText))
            {
                //
                // Memory allocation failed -  The best we can do now
                // is to set the item back to callback, and hope that
                // the top level program can handle it.
                //
                DebugMsg(DM_ERROR, TEXT("TreeView: Out of memory"));
                hItem->lpstr = LPSTR_TEXTCALLBACK;
            }
        }

        fRecalcWidth = TRUE;
        fName = TRUE;
    }

    if (ptvi->mask & TVIF_PARAM)
    {
        bActualChange = TRUE;
        hItem->lParam = ptvi->lParam;
    }

    if (ptvi->mask & TVIF_IMAGE)
    {
        if (hItem->iImage != (WORD)I_IMAGECALLBACK) {
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;
            if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
                uRDWFlags |= RDW_ERASE;

        }
        hItem->iImage = (SHORT)ptvi->iImage;
    }

    if (ptvi->mask & TVIF_SELECTEDIMAGE)
    {
        if (hItem->iSelectedImage != (WORD)I_IMAGECALLBACK)
            bActualChange = TRUE;
        hItem->iSelectedImage = (SHORT)ptvi->iSelectedImage;
    }

    if (ptvi->mask & TVIF_CHILDREN)
    {
        uRDWFlags |= RDW_ERASE;
        
        if (hItem->fKids != KIDS_CALLBACK)
            bActualChange = TRUE;

        switch (ptvi->cChildren)
        {
        case I_CHILDRENAUTO:
            hItem->fKids = KIDS_COMPUTE;
            break;
           
        case I_CHILDRENCALLBACK:
            hItem->fKids = KIDS_CALLBACK;
            break;
                 
        case 0:
            hItem->fKids = KIDS_FORCE_NO;
            break;

        default:
            hItem->fKids = KIDS_FORCE_YES;
            break;
        }

        //
        // If this item currently has no kid, reset the item.
        //
        if ((ptvi->cChildren == I_CHILDRENCALLBACK) && (hItem->hKids == NULL))
        {
            hItem->state &= ~TVIS_EXPANDEDONCE;
            if (hItem->hParent)
                hItem->state &= ~TVIS_EXPANDED;
        }
    }

    if (ptvi->mask & TVIF_INTEGRAL)
    {
        if (LOWORD(ptvi->iIntegral) > 0)
            hItem->iIntegral = LOWORD(ptvi->iIntegral);
    }

    if (ptvi->mask & TVIF_STATE)
    {
        // don't & ptvi->state with TVIS_ALL because win95 didn't
        // and setting TVIS_FOCUS was retrievable even though we don't use it
        UINT change = (hItem->state ^ ptvi->state) & ptvi->stateMask;

        if (change)
        {
            // Bug#94368: (TVIS_SELECTED | TVIS_DROPHILITED) changes
            // should effect tree state
            hItem->state ^= change;
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;

            if (hItem->state & TVIS_BOLD) {
                if (!pTree->hFontBold)
                    TV_CreateBoldFont(pTree);
             }

            if (change & TVIS_BOLD){
                // do this because changing the boldness
                uRDWFlags |= RDW_ERASE;
                fRecalcWidth = TRUE;
            }

            fStateImageChange = change & TVIS_STATEIMAGEMASK;
            if (fStateImageChange) {
                uRDWFlags |= RDW_ERASE;
                // Adding/removing a state image changes the ITEM_OFFSET
                // If old image was 0, then we are adding.
                // If new image is 0, then we are removing.
                // (If old=new, then we don't get into this code path, so we
                // don't have to worry about that case.)
                if (!(hItem->state & TVIS_STATEIMAGEMASK) || // new
                    !((hItem->state ^ change) & TVIS_STATEIMAGEMASK)) { // old
                    fRecalcWidth = TRUE;
                }
            }

            fFocusSel = ((change & TVIS_SELECTED) != 0);
        }
    }

    if (fRecalcWidth) {
        hItem->iWidth = 0;          // Invalidate old width
        if (TV_IsShowing(hItem)) {
            TV_ScrollBarsAfterSetWidth(pTree, hItem);
        }
    }

    // force a redraw if something changed AND if we are not
    // inside of a paint of this guy (callbacks will set the
    // item on the paint callback to implement lazy data schemes)

    if (bActualChange && (pTree->hItemPainting != hItem))
    {
        if (fEraseIfTransparent) {
            if (pTree->hImageList) {
                if (ImageList_GetBkColor(pTree->hImageList) == CLR_NONE) {
                    uRDWFlags |= RDW_ERASE;
                }
            }

        }

        // If item height changed, then we've got a lot of cleaning up
        // to do.
        if (hItem->iIntegral != iIntegralPrev)
        {
            TV_ScrollBarsAfterResize(pTree, hItem, iIntegralPrev, uRDWFlags);
        }
        else
        {
            TV_InvalidateItem(pTree, hItem, uRDWFlags);
        }

        // REVIEW: we might need to update the scroll bars if the
        // text length changed!
    }

    if (bActualChange)
    {
        if (fName)
            NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                TV_GetAccId(hItem));

        if (fFocusSel)
        {
            NotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                TV_GetAccId(hItem));
            NotifyWinEvent(((hItem->state & TVIS_SELECTED) ?
                EVENT_OBJECT_SELECTIONADD : EVENT_OBJECT_SELECTIONREMOVE),
                pTree->ci.hwnd, OBJID_CLIENT, TV_GetAccId(hItem));
        }

        if (fStateImageChange)
            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                TV_GetAccId(hItem));
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Calls TV_CheckHit to get the hit test results and then package it in a
//  structure back to the app.
//
// ----------------------------------------------------------------------------

HTREEITEM TV_OnHitTest(PTREE pTree, LPTV_HITTESTINFO lptvh)
{
    if (!lptvh)
        return 0; //Bug#94345: Validate LPTVHITTEST

    lptvh->hItem = TV_CheckHit(pTree, lptvh->pt.x, lptvh->pt.y, &lptvh->flags);

    return lptvh->hItem;
}

BOOL TV_IsItemTruncated(PTREE pTree, TREEITEM *hItem, LPRECT lprc)
{
    if (TV_GetItemRect(pTree,hItem,lprc,TRUE)) {
        lprc->left -= g_cxEdge;
        lprc->top -= g_cyBorder;
        if ((lprc->left + hItem->iWidth) > pTree->cxWnd) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL TV_HandleTTNShow(PTREE pTree, LPNMHDR lpnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip) {
        LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)lpnm;
        RECT rc;
        TVITEMEX item;

        // Now get the text associated with that item
        item.stateMask = TVIS_BOLD;
        TV_GetItem(pTree, pTree->hToolTip, TVIF_STATE, &item);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)((item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont), 0);

        TV_GetItemRect(pTree, pTree->hToolTip, &rc, TRUE);

        MapWindowRect(pTree->ci.hwnd, HWND_DESKTOP, &rc);
        // We draw the text with margins, so take those into account too.
        // These values come from TV_DrawItem...
        rc.top += g_cyBorder;
        rc.left += g_cxLabelMargin;

        //
        //  At this point, (rc.left, rc.top) are the coordinates we pass
        //  to DrawText.  Ask the tooltip how we should position it so the
        //  tooltip text shows up in precisely the same location.
        //
        // Bug#94368 raymondc v6: wrong coordinates if app has used TVM_SETITEMHEIGHT

        SendMessage(pTree->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rc);
        SetWindowPos(pTree->hwndToolTips, NULL, rc.left, rc.top,0,0,
                     SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        // This is an inplace tooltip, so disable animation.
        psi->dwStyle |= TTS_NOANIMATE;
        // handled!
        return TRUE;
    }

    return FALSE;
}

//
//  Copy the font from the treeview item into the tooltip so the tooltip
//  shows up in the correct font.
//
BOOL TV_HandleTTCustomDraw(PTREE pTree, LPNMTTCUSTOMDRAW pnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip &&
        (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
         pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
    {
        //
        //  Set up the customdraw DC to match the font of the TV item.
        //
        TVFAKEDRAW tvfd;
        DWORD dwCustom = 0;
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        dwCustom = TreeView_BeginFakeItemDraw(&tvfd, pTree->hToolTip);

        // If client changed the font, then transfer the font
        // from our private hdc into the tooltip's HDC.  We use
        // a private HDC because we only want to let the app change
        // the font, not the colors or anything else.
        if (dwCustom & CDRF_NEWFONT)
        {
            SelectObject(pnm->nmcd.hdc, GetCurrentObject(tvfd.nmcd.nmcd.hdc, OBJ_FONT));
        }
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);

        // Don't return other wacky flags to TT, since all we
        // did was change the font (if even that)
        return dwCustom & CDRF_NEWFONT;

    }
    return CDRF_DODEFAULT;

}

BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem)
{
    // update the item we're showing the bubble for...
    if (pTree->hToolTip != hItem) {
        // the hide will keep us from flashing
        ShowWindow(pTree->hwndToolTips, SW_HIDE);
        UpdateWindow(pTree->hwndToolTips);
        pTree->hToolTip = hItem;
        SendMessage(pTree->hwndToolTips, TTM_UPDATE, 0, 0);
        return TRUE;
    }
    return FALSE;
}

TREEITEM* TV_ItemAtCursor(PTREE pTree, LPRECT prc)
{
    RECT rc;
    UINT wHitCode;
    TREEITEM* hItem;

    GetCursorPos((LPPOINT)&rc);
    ScreenToClient(pTree->ci.hwnd, (LPPOINT)&rc);
    hItem = TV_CheckHit(pTree,rc.left,rc.top,&wHitCode);

    if (prc)
        *prc = rc;
    if (!(wHitCode & TVHT_ONITEM))
        hItem = NULL;

    return hItem;
}

BOOL TV_UpdateToolTipTarget(PTREE pTree)
{
    RECT rc;
    TREEITEM *hItem = TV_ItemAtCursor(pTree, &rc);

    if (!(pTree->ci.style & TVS_NOTOOLTIPS) 
            && !TV_IsItemTruncated(pTree, hItem, &rc)
            && !(pTree->ci.style & TVS_INFOTIP))
        hItem = NULL;
//    else if (!(pTree->ci.style & TVS_NOTOOLTIPS)
//                    || (pTree->ci.style & TVS_INFOTIP))
    return TV_SetToolTipTarget(pTree, hItem);
}

BOOL TV_UpdateToolTip(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->fRedraw)
       return (TV_UpdateToolTipTarget(pTree));
    return TRUE;
}

BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter)
{
    if (!ValidateTreeItem(hItem, VTI_NULLOK))   // NULL means remove insert mark
        return FALSE;

    TV_InvalidateInsertMarkRect(pTree, TRUE); // Make sure the old one gets erased

    pTree->fInsertAfter = BOOLIFY(fAfter);
    pTree->htiInsert = hItem;

    TV_InvalidateInsertMarkRect(pTree, FALSE); // Make sure the new one gets drawn

    return TRUE;
}

BOOL TV_GetInfoTip(PTREE pTree, LPTOOLTIPTEXT lpttt, HTREEITEM hti, LPTSTR szBuf, int cch)
{
    NMTVGETINFOTIP git;

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = cch;
    git.hItem = hti;
    git.lParam = hti->lParam;

    // for folded items pszText is prepopulated with the
    // item text, clients should append to this

    CCSendNotify(&pTree->ci, TVN_GETINFOTIP, &git.hdr);

    CCSetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);
    Str_Set(&pTree->pszTip, git.pszText);
    lpttt->lpszText = pTree->pszTip;
    if(pTree->ci.style & TVS_RTLREADING)
    {
        lpttt->uFlags |= TTF_RTLREADING;
    }

    return lpttt->lpszText && lpttt->lpszText[0];
}




void TV_HandleNeedText(PTREE pTree, LPTOOLTIPTEXT lpttt)
{
    TVITEMEX tvItem;
    TCHAR szBuf[INFOTIPSIZE];
    RECT rc;
    HTREEITEM hItem;

    // No distracting tooltips while in-place editing, please
    if (pTree->htiEdit)
    {
        return;
    }

    // If the cursor isn't over anything, then stop
    hItem = TV_ItemAtCursor(pTree, &rc);
    if (!hItem)
        return;

    // If the item has an infotip, then use it
    if (pTree->ci.style & TVS_INFOTIP) {
        if (hItem && TV_GetInfoTip(pTree, lpttt, hItem, szBuf, ARRAYSIZE(szBuf))) {
            pTree->fPlaceTooltip = FALSE;
            pTree->hToolTip = hItem;
            return;
        }
    }

    // Else it isn't an infotip
    CCResetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);

    // If the item is not truncated, then no need for a tooltip
    if (!TV_IsItemTruncated(pTree, hItem, &rc))
    {
        tvItem.hItem = NULL;
        return;
    }

    // Display an in-place tooltip for the item
    pTree->fPlaceTooltip = TRUE;
    pTree->hToolTip = hItem;
    tvItem.hItem = hItem;
    tvItem.mask = TVIF_TEXT | TVIF_STATE;
    tvItem.pszText = szBuf;
    tvItem.stateMask = TVIS_DROPHILITED | TVIS_SELECTED;
    COMPILETIME_ASSERT(MAXLABELTEXT <= ARRAYSIZE(szBuf));
    tvItem.cchTextMax = MAXLABELTEXT;
    TV_OnGetItem(pTree,&tvItem);

    Str_Set(&pTree->pszTip, tvItem.pszText);
    lpttt->lpszText = pTree->pszTip;
    DebugMsg(DM_TRACE, TEXT("TV_HandleNeedText for %d returns %s"), tvItem.hItem, lpttt->szText);
}

//
//  Visual Studio 5.0 Books Online (part of VB 5.0) subclasses
//  us and responds NFR_ANSI, so we end up getting TTN_NEEDTEXTA
//  instead of TTN_NEEDTEXTW.  We can't risk forcing the tooltip
//  to UNICODE because some other apps may have done this on purpose
//  (because they intend to intercept TTN_NEEDTEXTA and do custom tooltips).
//  So support the ANSI tooltip notification so VB stays happy.
//  Note: This doesn't have to be efficient, as it's an error case anyway.
//
void TV_HandleNeedTextA(PTREE pTree, LPTOOLTIPTEXTA lptttA)
{
    TOOLTIPTEXT ttt;
    ttt.szText[0] = TEXT('\0');
    ttt.hdr       = lptttA->hdr;
    ttt.lpszText  = ttt.szText;
    ttt.hinst     = lptttA->hinst;
    ttt.uFlags    = lptttA->uFlags;
    ttt.lParam    = lptttA->lParam;

    TV_HandleNeedText(pTree, &ttt);
    if (pTree->pszTipA)
        LocalFree(pTree->pszTipA);
    pTree->pszTipA = ProduceAFromW(pTree->ci.uiCodePage, ttt.lpszText);
    lptttA->lpszText = pTree->pszTipA;
    lptttA->uFlags  = ttt.uFlags;
}

// ----------------------------------------------------------------------------
//
//  TV_Timer
//
//  Checks to see if it is our name editing timer.  If so it  calls of to
//  do name editing
//
// ----------------------------------------------------------------------------
LRESULT TV_Timer(PTREE pTree, UINT uTimerId)
{
    switch (uTimerId)
    {
        case IDT_NAMEEDIT:
            // Kill the timer as we wont need any more messages from it.
            KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);

            if (pTree->fNameEditPending)
            {
                // And start name editing mode.
                if (!TV_EditLabel(pTree, pTree->hCaret, NULL))
                {
                    TV_DismissEdit(pTree, FALSE);
                }

                // remove the flag...
                pTree->fNameEditPending = FALSE;
            }
            break;
            
        case IDT_SCROLLWAIT:
            KillTimer(pTree->ci.hwnd, IDT_SCROLLWAIT);
            if (pTree->fScrollWait)
            {
                if (pTree->hCaret) {
                    TV_ScrollVertIntoView(pTree, pTree->hCaret);
                }
                pTree->fScrollWait = FALSE;
            }
            break;


    }
    return 0;
}

// ----------------------------------------------------------------------------
//
//  TV_Command
//
//  Process the WM_COMMAND.  See if it is an input from our edit windows.
//  if so we may want to dismiss it, and or set it is being dirty...
//
// ----------------------------------------------------------------------------
void TV_Command(PTREE pTree, int id, HWND hwndCtl, UINT codeNotify)
{
    if ((pTree != NULL) && (hwndCtl == pTree->hwndEdit))
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
            // We will use the ID of the window as a Dirty flag...
            SetWindowID(pTree->hwndEdit, 1);
            TV_SetEditSize(pTree);
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)

            //
            //  Fix horrible undocumented hanging problem:  LVN_ENDLABELEDIT
            //  is sent in response to EN_KILLFOCUS, which is send in response
            //  to WM_KILLFOCUS, and it is undocumented that you cannot display
            //  UI during WM_KILLFOCUS when a journal record hook is active,
            //  because the presence of a hook forces serialization of activation,
            //  and so when you put up UI, you generate activation changes, which
            //  get stuck because you haven't finished responding to the previous
            //  WM_KILLFOCUS message yet.
            //
            //  See NT bug 414634.
            //
            if (InSendMessage())
                ReplyMessage(0);

            if (!TV_DismissEdit(pTree, FALSE))
               return;
            break;

        case HN_BEGINDIALOG: // penwin is bringing up a dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = TRUE;
            break;

        case HN_ENDDIALOG: // penwin has destroyed dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = FALSE;
            break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(pTree->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror);
void TV_CreateToolTips(PTREE pTree);

void TV_InitCheckBoxes(PTREE pTree)
{
    HIMAGELIST himl;
    TVITEMEX ti;

    himl = CreateCheckBoxImagelist(pTree->hImageList, TRUE, TRUE, IS_WINDOW_RTL_MIRRORED(pTree->ci.hwnd));
    if (pTree->hImageList) 
    {
        COLORREF cr = ImageList_GetBkColor(pTree->hImageList);
        ImageList_SetBkColor(himl, IsUsingCleartype()? (CLR_NONE) : (cr));
    }

    TV_SetImageList(pTree, himl, TVSIL_STATE);

    ti.mask = TVIF_STATE;
    ti.state = INDEXTOSTATEIMAGEMASK(1);
    ti.stateMask = TVIS_STATEIMAGEMASK;
    TV_SetItemRecurse(pTree, pTree->hRoot, &ti);
}

void TV_OnStyleChanged(PTREE pTree, WPARAM gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags;
        DWORD styleNew;

        TV_DismissEdit(pTree, FALSE);

        // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
        // because it doesn't work
        styleNew = pinfo->styleNew;
        if (styleNew & TVS_HASLINES) 
        {
            if (styleNew & TVS_FULLROWSELECT)
            {
                RIPMSG(FALSE, "TV_OnStyleChanged(): Cannot combine TVS_HASLINES and TVS_FULLROWSELECT");
            }
            styleNew &= ~TVS_FULLROWSELECT;
        }

        changeFlags = pTree->ci.style ^ styleNew; // those that changed
        pTree->ci.style = styleNew;               // change our version

        pTree->ci.style &= ~TVS_RTLREADING;
        pTree->ci.style |= (pinfo->styleNew & TVS_RTLREADING);       

        if (changeFlags & (TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT))
            TV_CreateIndentBmps(pTree);

        if (changeFlags & TVS_CHECKBOXES)
        {
            if (pTree->ci.style & TVS_CHECKBOXES)
            {
                TV_InitCheckBoxes(pTree);
            }
        }

        if (changeFlags & TVS_NOTOOLTIPS)
        {
            if (pTree->ci.style & TVS_NOTOOLTIPS)
            {
                DestroyWindow(pTree->hwndToolTips);
                pTree->hwndToolTips = NULL;
            }
            else
            {
                TV_CreateToolTips(pTree);
            }
        }

        if (changeFlags & TVS_TRACKSELECT)
        {
            if (!(pTree->ci.style & TVS_TRACKSELECT))
            {
                if (pTree->hHot) 
                {
                    TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE | RDW_ERASE);
                    pTree->hHot = NULL;
                }
            }
        }
        // Checkboxes and stuff may have changed width - go recompute
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        DWORD changeFlags;
        changeFlags = (pinfo->styleNew & WS_EX_RTLREADING) ?TVS_RTLREADING :0;

        if (changeFlags ^ (pTree->ci.style & TVS_RTLREADING))
        {
            pTree->ci.style ^= TVS_RTLREADING;
            TV_DismissEdit(pTree, FALSE);   // Cancels edits

            DestroyWindow(pTree->hwndToolTips);
            pTree->hwndToolTips = NULL;
            TV_CreateToolTips(pTree);
        }
    }

}

void TV_OnMouseMove(PTREE pTree, DWORD dwPos, WPARAM wParam)
{
    if (pTree->ci.style & TVS_TRACKSELECT) {
        POINT pt;
        HTREEITEM hHot;
        UINT wHitCode;

        pt.x = GET_X_LPARAM(dwPos);
        pt.y = GET_Y_LPARAM(dwPos);

        hHot = TV_CheckHit(pTree,pt.x,pt.y,&wHitCode);

        if (!(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(wHitCode & TVHT_ONITEM)) {
            hHot = NULL;
        }

        if (hHot != pTree->hHot) {
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            TV_InvalidateItem(pTree, hHot, RDW_INVALIDATE);
            pTree->hHot = hHot;
            // update now so that we won't have an invalid area
            // under the tooltips
            UpdateWindow(pTree->ci.hwnd);
        }
    }

    if (pTree->hwndToolTips) {

        if (!TV_UpdateToolTip(pTree)) {
            RelayToToolTips(pTree->hwndToolTips, pTree->ci.hwnd, WM_MOUSEMOVE, wParam, dwPos);
        }
    }
}

void TV_OnWinIniChange(PTREE pTree, WPARAM wParam)
{
    if (!wParam ||
        (wParam == SPI_SETNONCLIENTMETRICS) ||
        (wParam == SPI_SETICONTITLELOGFONT)) {

        if (pTree->fCreatedFont)
            TV_OnSetFont(pTree, NULL, TRUE);

        if (!pTree->fIndentSet) {
            // this will validate against the minimum
            TV_SetIndent(pTree, 0);
        }
    }
}

void TV_OnSetBkColor(PTREE pTree, COLORREF clr)
{
    if (pTree->clrBk != (COLORREF)-1) 
    {
        DeleteObject(pTree->hbrBk);
    }

    pTree->clrBk = clr;
    if (clr != (COLORREF)-1) 
    {
        pTree->hbrBk = CreateSolidBrush(clr);
    }
    TV_CreateIndentBmps(pTree); // This also invalidates

    pTree->clrBkNonTheme = clr;
}

DWORD TV_SetExtendedStyle(PTREE pTree, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = pTree->dwExStyle;

    if (dwExMask)
        dwNewStyle = (pTree->dwExStyle & ~ dwExMask) | (dwNewStyle & dwExMask);

    // do validation of the new flags here...

    pTree->dwExStyle = dwNewStyle;

    // if ((dwOldStyle ^ dwNewStyle) & TVS_EX_NOSINGLECOLLAPSE) ... do whatever (no need to invalidate rect, this is behavior style)

    return dwOldStyle;
}

BOOL TV_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        if (GetKeyState(VK_CONTROL) < 0) {
            switch (lpmsg->wParam) {
            case VK_LEFT:
            case VK_RIGHT:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_UP:
            case VK_DOWN:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        } else {

            switch (lpmsg->wParam) {

            case VK_RETURN:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_SUBTRACT:
            case VK_ADD:
            case VK_MULTIPLY:
            case VK_LEFT:
            case VK_BACK:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_SPACE:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

HTREEITEM TV_FindAccId(HTREEITEM hItem, DWORD dwAccId)
{
    HTREEITEM hKid;
    HTREEITEM hNext;

    if (hItem->dwAccId == dwAccId)
        return hItem;

    for (hKid = hItem->hKids; hKid; hKid = hNext) 
    {
        HTREEITEM hItemFound;
        hNext = hKid->hNext;

        // recurse on each child
        hItemFound = TV_FindAccId(hKid, dwAccId);

        if (hItemFound)
            return hItemFound;
    }

    return NULL;
}

LRESULT TV_MapAccIDToHTREEITEM(PTREE pTree, DWORD dwAccId)
{
    return (LRESULT)TV_FindAccId(pTree->hRoot, dwAccId);
}

LRESULT TV_MapHTREEITEMToAccID(PTREE pTree, HTREEITEM hItem)
{
    DBG_ValidateTreeItem(hItem, 0);

    return (LRESULT)(hItem->dwAccId);
}

// ----------------------------------------------------------------------------
//
//  TV_WndProc
//
//  Take a guess.
//
// ----------------------------------------------------------------------------

LRESULT CALLBACK TV_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowPtr(hwnd, 0);

    if (pTree) 
    {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (pTree->ci.style & TVS_TRACKSELECT) && !pTree->fTrackSet) 
        {

            TRACKMOUSEEVENT tme;

            pTree->fTrackSet = TRUE;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = pTree->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
        else if (uMsg == g_uDragImages)
        {
            return TV_GenerateDragImage(pTree, (SHDRAGIMAGE*)lParam);
        }
        else if (uMsg == WM_THEMECHANGED)  // Check for theme changes
        {
            HTHEME hTheme;
            if (pTree->hTheme)
                CloseThemeData(pTree->hTheme);

            pTree->hTheme = NULL;


            hTheme = OpenThemeData(pTree->ci.hwnd, L"TreeView");

            // Reset cached brushes
            if (hTheme)
            {
                TV_InitThemeMetrics(pTree, hTheme);
            }
            else
            {
                // Background color (system)
                SendMessage(pTree->ci.hwnd, TVM_SETBKCOLOR, 0, pTree->clrBkNonTheme);

                // Line color (system)
                SendMessage(pTree->ci.hwnd, TVM_SETLINECOLOR, 0, pTree->clrLineNonTheme);
            }

            pTree->hTheme = hTheme;

            InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
        }
    } 
    else 
    {
        if (uMsg == WM_CREATE) 
            return TV_OnCreate(hwnd, (LPCREATESTRUCT)lParam);

        goto DoDefault;
    }



    switch (uMsg)
    {
        case WM_MOUSELEAVE:
            pTree->fTrackSet = FALSE;
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            pTree->hHot = NULL;
            TV_PopBubble(pTree);
            break;
            
        case TVMP_CALCSCROLLBARS:
            TV_CalcScrollBars(pTree);
            break;

        case TVM_MAPACCIDTOHTREEITEM:
            return TV_MapAccIDToHTREEITEM(pTree, (DWORD)wParam);
            break;

        case TVM_MAPHTREEITEMTOACCID:
            return TV_MapHTREEITEMToAccID(pTree, (HTREEITEM)wParam);
            break;

        case TVM_GETITEMSTATE:
            {
                TVITEMEX tvi;

                tvi.mask = TVIF_STATE;
                tvi.stateMask = (UINT) lParam;
                tvi.hItem = (HTREEITEM)wParam;
                if (!TV_OnGetItem(pTree, &tvi))
                    return 0;

                return tvi.state;
            }
            
        case TVM_SETBKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrBk;
            TV_OnSetBkColor(pTree, (COLORREF)lParam);
            return lres;
        }

        case TVM_SETTEXTCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrText;
            pTree->clrText = (COLORREF)lParam;
            if (pTree->hbrText && pTree->hbrText != g_hbrWindowText)
            {
                DeleteObject(pTree->hbrText);
            }

            if (pTree->clrText == (COLORREF)-1)
            {
                pTree->hbrText = NULL;
            }
            else
            {
                pTree->hbrText = CreateSolidBrush(pTree->clrText);
            }

            if (!pTree->hbrText)
                pTree->hbrText = g_hbrWindowText;
            TV_CreateIndentBmps(pTree); // This also invalidates
            return lres;
        }

        case TVM_GETBKCOLOR:
            return (LRESULT)pTree->clrBk;

        case TVM_GETTEXTCOLOR:
            return (LRESULT)pTree->clrText;

        case TVM_GETSCROLLTIME:
            return (LRESULT)pTree->uMaxScrollTime;

        case TVM_SETSCROLLTIME:
        {
            UINT u = pTree->uMaxScrollTime;
            pTree->uMaxScrollTime = (UINT)wParam;
            return (LRESULT)u;
        }


        case TVM_INSERTITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_InsertItemA(pTree, (LPTV_INSERTSTRUCTA)lParam);

        case TVM_GETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_OnGetItemA(pTree, (LPTVITEMEXA)lParam);

        case TVM_SETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_SetItemA(pTree, (LPTVITEMEXA)lParam);

        case TVM_INSERTITEM:
            return (LRESULT)TV_InsertItem(pTree, (LPTV_INSERTSTRUCT)lParam);

        case TVM_DELETEITEM:
            // Assume if items are being deleted that name editing is invalid.
            TV_DismissEdit(pTree, TRUE);
            return TV_DeleteItem(pTree, (TREEITEM *)lParam, TVDI_NORMAL);

        case TVM_GETNEXTITEM:
            return (LRESULT)TV_GetNextItem(pTree, (TREEITEM *)lParam, wParam);

        case TVM_GETITEMRECT:
            // lParam points to hItem to get rect from on input
            if (!lParam)
                return 0;
            if (!ValidateTreeItem(*(HTREEITEM *)lParam, 0))
                return 0;               // Invalid parameter
            return (LRESULT)TV_GetItemRect(pTree, *(HTREEITEM *)lParam, (LPRECT)lParam, (BOOL)wParam);

        case TVM_GETITEM:
            return (LRESULT)TV_OnGetItem(pTree, (LPTVITEMEX)lParam);

        case TVM_SETITEM:
            return (LRESULT)TV_SetItem(pTree, (LPCTVITEMEX)lParam);

        case TVM_ENSUREVISIBLE:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return 0;
            return TV_EnsureVisible(pTree, (TREEITEM *)lParam);

        case TVM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)TV_SetImageList(pTree, (HIMAGELIST)lParam, (int)wParam);

        case TVM_EXPAND:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return FALSE;               // invalid parameter
            return TV_Expand(pTree, wParam, (TREEITEM *)lParam, FALSE);

        case TVM_HITTEST:
            return (LRESULT)TV_OnHitTest(pTree, (LPTV_HITTESTINFO)lParam);

        case TVM_GETCOUNT:
            return MAKELRESULTFROMUINT(pTree->cItems);

        case TVM_GETIMAGELIST:
            switch (wParam) {
            case TVSIL_NORMAL:
                return MAKELRESULTFROMUINT(pTree->hImageList);
            case TVSIL_STATE:
                return MAKELRESULTFROMUINT(pTree->himlState);
            default:
                return 0;
            }

        case TVM_GETISEARCHSTRINGA:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchStringA(&pTree->is, pTree->ci.uiCodePage, (LPSTR)lParam);
            else
                return 0;

        case TVM_GETISEARCHSTRING:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchString(&pTree->is, (LPTSTR)lParam);
            else
                return 0;

        case TVM_EDITLABELA:
        {
            LPWSTR lpEditString = NULL;
            HWND   hRet;

            if (wParam)
            {
                lpEditString = ProduceWFromA(pTree->ci.uiCodePage, (LPSTR)wParam);
            }

            hRet = TV_EditLabel(pTree, (HTREEITEM)lParam, lpEditString);

            if (lpEditString)
            {
                FreeProducedString(lpEditString);
            }

            return MAKELRESULTFROMUINT(hRet);
        }

        case TVM_EDITLABEL:
            return MAKELRESULTFROMUINT(TV_EditLabel(pTree, (HTREEITEM)lParam,
                    (LPTSTR)wParam));


        case TVM_GETVISIBLECOUNT:
            return TV_GetVisCount(pTree, (BOOL) wParam);

        case TVM_SETINDENT:
            TV_SetIndent(pTree, wParam);
            pTree->fIndentSet = TRUE;
            break;

        case TVM_GETINDENT:
            return MAKELRESULTFROMUINT(pTree->cxIndent);

        case TVM_CREATEDRAGIMAGE:
            return MAKELRESULTFROMUINT(TV_CreateDragImage(pTree, (TREEITEM *)lParam));

        case TVM_GETEDITCONTROL:
            return (LRESULT)(ULONG_PTR)pTree->hwndEdit;

        case TVM_SORTCHILDREN:
            return TV_SortChildren(pTree, (TREEITEM *)lParam, (BOOL)wParam);

        case TVM_SORTCHILDRENCB:
            return TV_SortChildrenCB(pTree, (TV_SORTCB *)lParam, (BOOL)wParam);

        case TVM_SELECTITEM:
            // wParam: separate action flags (TVGN) and select item flags (TVSIF)
            return TV_SelectItem(pTree, (wParam & TVGN_VALID),
                                (TREEITEM *)lParam,
                                 TVSIFI_NOTIFY | TVSIFI_UPDATENOW | ((wParam & TVSI_NOSINGLEEXPAND) ? TVSIFI_NOSINGLEEXPAND : 0),
                                 TVC_UNKNOWN);

        case TVM_ENDEDITLABELNOW:
            return TV_DismissEdit(pTree, (BOOL)wParam);

        case TVM_GETTOOLTIPS:
            return (LRESULT)(ULONG_PTR)pTree->hwndToolTips;

        case TVM_SETTOOLTIPS:{
            HWND hwndOld = pTree->hwndToolTips;

            pTree->hwndToolTips = (HWND)wParam;
            return (LRESULT)(ULONG_PTR)hwndOld;
        }

        case TVM_GETITEMHEIGHT:
            return pTree->cyItem;

        case TVM_SETITEMHEIGHT:
        {
            int iOld = pTree->cyItem;
            pTree->fCyItemSet = (wParam != (WPARAM)-1);
            pTree->cyItem = (SHORT)wParam; // must be even
            TV_SetItemHeight(pTree);
            return iOld;
        }
        case TVM_SETBORDER:
        {
            int cyOld = pTree->cyBorder
                , cxOld = pTree->cxBorder;

            if (wParam & TVSBF_YBORDER)
                pTree->cyBorder = HIWORD(lParam);
            if (wParam & TVSBF_XBORDER)
                pTree->cxBorder = LOWORD(lParam);

            TV_CalcScrollBars(pTree);
            return MAKELONG(cxOld, cyOld);
        }
        case TVM_GETBORDER:
            return MAKELONG(pTree->cxBorder, pTree->cyBorder);
        case TVM_SETINSERTMARK:
            return TV_SetInsertMark(pTree, (TREEITEM *)lParam, (BOOL) wParam);
        
        case TVM_SETINSERTMARKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrim;
            pTree->clrim = (COLORREF) lParam;
            TV_InvalidateInsertMarkRect(pTree, FALSE); // Repaint in new color
            return lres;
        }
        case TVM_GETINSERTMARKCOLOR:
            return pTree->clrim;

        case TVM_TRANSLATEACCELERATOR:
            return TV_TranslateAccelerator(hwnd, (LPMSG)lParam);

        case TVM_SETLINECOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrLine;
            pTree->clrLineNonTheme = (COLORREF)lParam;

            pTree->clrLine = (COLORREF)lParam;
            if (pTree->hbrLine && pTree->hbrLine != g_hbrGrayText)
            {
                DeleteObject(pTree->hbrLine);
            }

            if (pTree->clrLine == CLR_DEFAULT)
            {
                pTree->hbrLine = NULL;
            }
            else
            {
                pTree->hbrLine = CreateSolidBrush(pTree->clrLine);
            }

            if (!pTree->hbrLine)
                pTree->hbrLine = g_hbrGrayText;

            TV_CreateIndentBmps(pTree); // This also invalidates

            return lres;
        }

        case TVM_GETLINECOLOR:
            return (LRESULT)pTree->clrLine;

        case TVM_SETEXTENDEDSTYLE:
            return TV_SetExtendedStyle(pTree, (DWORD)lParam, (DWORD)wParam);

        case TVM_GETEXTENDEDSTYLE:
            return pTree->dwExStyle;

        case WM_IME_COMPOSITION:
            // Now only Korean version is interested in incremental search with composition string.
            if (g_fDBCSInputEnabled) {
            if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
            {
                if (TV_OnImeComposition(pTree, wParam, lParam))
                {
                    lParam &= ~GCS_RESULTSTR;
                    goto DoDefault;
                }
                else
                    break;
            }
            }
            goto DoDefault;

        case WM_CHAR:
            if (pTree->iPuntChar) 
            {
                pTree->iPuntChar--;
                return TRUE;
            } 
            else 
            {
                return HANDLE_WM_CHAR(pTree, wParam, lParam, TV_OnChar);
            }

        case WM_DESTROY:
            TV_DestroyTree(pTree);
            break;

        case WM_SETCURSOR:
            {
                NMMOUSE nm;
                HTREEITEM hItem;
                nm.dwHitInfo = lParam;
                hItem = TV_ItemAtCursor(pTree, NULL);
                if(hItem)
                {
                    nm.dwItemSpec = (ULONG_PTR)hItem;
                    nm.dwItemData = (ULONG_PTR)(hItem->lParam);
                }
                else
                {
                    nm.dwItemSpec = 0;
                    nm.dwItemData = 0;
                }
                             
#ifdef UNIX
		if (pTree->hwndEdit != (HWND)wParam)
#endif
                if (CCSendNotify(&pTree->ci, NM_SETCURSOR, &nm.hdr)) 
                {
                    return 0;
                }
            }
            if (pTree->ci.style & TVS_TRACKSELECT)
            {
                if (pTree->hHot)
                {
                    if (!pTree->hCurHot)
                    {
                        pTree->hCurHot = LoadCursor(NULL, IDC_HAND);
                    }
                    SetCursor(pTree->hCurHot);
                    return TRUE;
                }
            }
            goto DoDefault;
            break;

        case WM_WININICHANGE:
            TV_OnWinIniChange(pTree, wParam);
            break;

        case WM_STYLECHANGED:
            TV_OnStyleChanged(pTree, wParam, (LPSTYLESTRUCT)lParam);
            break;

        case WM_SETREDRAW:
            TV_OnSetRedraw(pTree, (BOOL)wParam);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT:
            TV_Paint(pTree, (HDC)wParam);
            break;

        case WM_NCPAINT:
            if (pTree->hTheme && pTree->ci.dwExStyle & WS_EX_CLIENTEDGE)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;

                if (CCDrawNonClientTheme(pTree->hTheme, hwnd, hrgn, pTree->hbrBk, 0, 0))
                {
                    return TRUE;
                }
            }
            goto DoDefault;


        case WM_ERASEBKGND:
            {
                RECT rc;

                TV_GetBackgroundBrush(pTree, (HDC) wParam);
                GetClipBox((HDC) wParam, &rc);
                FillRect((HDC)wParam, &rc, pTree->hbrBk);
            }
            return TRUE;

        case WM_GETDLGCODE:
            return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

        case WM_HSCROLL:
            TV_HorzScroll(pTree, GET_WM_HSCROLL_CODE(wParam, lParam), GET_WM_HSCROLL_POS(wParam, lParam));
            break;

        case WM_VSCROLL:
            TV_VertScroll(pTree, GET_WM_VSCROLL_CODE(wParam, lParam), GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_KEYDOWN:
            if (TV_KeyDown(pTree, wParam, lParam))
                IncrementSearchString(&pTree->is, 0, NULL);
                goto DoDefault;


        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
            TV_ButtonDown(pTree, uMsg, (UINT) wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;

            pTree->fFocus = FALSE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                UpdateWindow(pTree->ci.hwnd);
            }
            CCSendNotify(&pTree->ci, NM_KILLFOCUS, NULL);
            IncrementSearchString(&pTree->is, 0, NULL);
            break;

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);

            pTree->fFocus = TRUE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, TV_GetAccId(pTree->hCaret));
            }
            else
                TV_SelectItem(pTree, TVGN_CARET, pTree->hTop, TVSIFI_NOTIFY | TVSIFI_UPDATENOW, TVC_INTERNAL);

            CCSendNotify(&pTree->ci, NM_SETFOCUS, NULL);
            break;

        case WM_GETFONT:
            return MAKELRESULTFROMUINT(pTree->hFont);

        case WM_SETFONT:
            TV_OnSetFont(pTree, (HFONT) wParam, (BOOL) lParam);
            break;

        case WM_SIZE:
            TV_SizeWnd(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_ENABLE:
            // HACK: we don't get WM_STYLECHANGE on EnableWindow()
            if (wParam)
                pTree->ci.style &= ~WS_DISABLED;        // enabled
            else
                pTree->ci.style |= WS_DISABLED; // disabled
            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
#if 0
            if(pTree->hwndToolTips) {
                SendMessage(pTree->hwndToolTips, TTM_SETTIPBKCOLOR, (WPARAM)GetSysColor(COLOR_WINDOW), 0);
                SendMessage(pTree->hwndToolTips, TTM_SETTIPTEXTCOLOR, (WPARAM)GetSysColor(COLOR_WINDOWTEXT), 0);
            }
#endif

            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_RBUTTONDOWN:
            TV_SendRButtonDown(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_TIMER:
            TV_Timer(pTree, (UINT) wParam);
            break;

    case WM_MOUSEMOVE:
        TV_OnMouseMove(pTree, (DWORD) lParam, wParam);
        break;

        case WM_COMMAND:
            TV_Command(pTree, (int)GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam),
                    (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case WM_NOTIFY:
            {
            LPNMHDR lpnm = (LPNMHDR)lParam;

            if ((lpnm->code <= PGN_FIRST) && (PGN_LAST <= lpnm->code))
            {
                LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm);

                return TV_OnPagerControlNotify(pTree, lpnm);
            }
            if (lpnm->hwndFrom == pTree->hwndToolTips)
            {
                switch (lpnm->code)
                {
                case TTN_NEEDTEXT:
                    TV_HandleNeedText(pTree, (LPTOOLTIPTEXT)lpnm);
                    break;

                case TTN_NEEDTEXTA:
                    TV_HandleNeedTextA(pTree, (LPTOOLTIPTEXTA)lpnm);
                    break;

                case TTN_SHOW:
                    return TV_HandleTTNShow(pTree, lpnm);

                case NM_CUSTOMDRAW:
                    return TV_HandleTTCustomDraw(pTree, (LPNMTTCUSTOMDRAW)lpnm);
                }
            }
            break;
        }

        case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pTree->ci, lParam);

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            goto DoDefault;

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TREEVIEW;
            goto DoDefault;

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(pTree->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                if (pTree->hCaret)
                    TV_InvalidateItem(pTree, pTree->hCaret, TRUE);

            goto DoDefault;
        }

        case WM_SYSKEYDOWN:
            TV_KeyDown(pTree, wParam, lParam);
            //fall through

        default:
            // Special handling of magellan mouse message
            if (uMsg == g_msgMSWheel) 
            {
                DWORD dwStyle;
                int   cScrollLines;
                int   cPage;
                int   pos;
                int   cDetants;
                int   iWheelDelta = (int)(short)HIWORD(wParam);
                BOOL  fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
                BOOL  fDataZoom = (BOOL) (wParam & MK_SHIFT);

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) 
                {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (fScroll) 
                {
                    if (    g_ucScrollLines > 0 &&
                            cDetants != 0 &&
                            (WS_VSCROLL | WS_HSCROLL) & (dwStyle = GetWindowStyle(hwnd)))
                    {

                        if (dwStyle & WS_VSCROLL) 
                        {
                            cPage = max(1, (pTree->cFullVisible - 1));
                            cScrollLines =
                                          cDetants *
                                          min(g_ucScrollLines, (UINT) cPage);

                            pos = max(0, pTree->hTop->iShownIndex + cScrollLines);
                            TV_VertScroll(pTree, SB_THUMBPOSITION, pos);
                        } 
                        else 
                        {
                            cPage = max(MAGIC_HORZLINE,
                                        (pTree->cxWnd - MAGIC_HORZLINE)) /
                                    MAGIC_HORZLINE;

                            cScrollLines =
                                          cDetants *
                                          (int) min((ULONG) cPage, g_ucScrollLines) *
                                          MAGIC_HORZLINE;

                            pos = max(0, pTree->xPos + cScrollLines);
                            TV_HorzScroll(pTree, SB_THUMBPOSITION, pos);
                        }
                    }
                    return 1;
                } 
                else if (fDataZoom)
                {
                    UINT wHitCode;
                    POINT pt;

                    pt.x = GET_X_LPARAM(lParam);
                    pt.y = GET_Y_LPARAM(lParam);
                    ScreenToClient(hwnd, &pt);

                    // If we are rolling forward and hit an item then navigate into that
                    // item or expand tree (simulate lbuttondown which will do it).  We
                    // also need to handle rolling backwards over the ITEMBUTTON so
                    // that we can collapse the tree in that case.  Otherwise
                    // just fall through so it isn't handled.  In that case if we
                    // are being hosted in explorer it will do a backwards
                    // history navigation.
                    if (TV_CheckHit(pTree, pt.x, pt.y, &wHitCode) &&
                        (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON))) {
                        UINT uFlags = TVBD_FROMWHEEL;
                        uFlags |= (iWheelDelta > 0) ? TVBD_WHEELFORWARD : TVBD_WHEELBACK;

                        if ((uFlags & TVBD_WHEELFORWARD) || (wHitCode == TVHT_ONITEMBUTTON)) {
                            TV_ButtonDown(pTree, WM_LBUTTONDOWN, 0, pt.x, pt.y, uFlags);
                            return 1;
                        }
                    }
                    // else fall through
                }
            }
            else
            {
                LRESULT lres;
                if (CCWndProc(&pTree->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return(0L);
}

// NOTE: there is very similar code in the listview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK TV_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowInt(GetParent(hwnd), 0);
    ASSERT(pTree);

    if (!pTree)
        return 0L;  // wierd cases can get here...

    switch (msg) 
    {
    case WM_KEYDOWN:
        switch (wParam) 
        {
        case VK_RETURN:
            TV_DismissEdit(pTree, FALSE);
            return 0L;

        case VK_ESCAPE:
            TV_DismissEdit(pTree, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam)
        {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }

        // 97903: Localization says we need this for DBCS chars
    case WM_IME_CHAR:
        msg = WM_CHAR;
        break;

    }

    return CallWindowProc(pTree->pfnEditWndProc, hwnd, msg, wParam, lParam);
}


void TV_SetEditSize(PTREE pTree)
{
    RECT rcLabel;
    UINT seips;

    if (pTree->htiEdit == NULL)
        return;

    TV_GetItemRect(pTree, pTree->htiEdit, &rcLabel, TRUE);

    // get exact the text bounds (acount for borders used when drawing)

    InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);

    seips = 0;
#ifdef DEBUG
    // If we are in one of the no-scroll modes then it's possible for the
    // resulting rectangle not to be visible.  Similarly, if the item itself
    // isn't visible, then the resulting rectangle is definitely not visible.
    // Tell SetEditInPlaceSize not to get upset in those cases.
    if ((pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL)) ||
        !ITEM_VISIBLE(pTree->htiEdit))
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(pTree->hwndEdit, &rcLabel, (HFONT)SendMessage(pTree->hwndEdit, WM_GETFONT, 0, 0), seips);
}


void TV_CancelEditTimer(PTREE pTree)
{
    if (pTree->fNameEditPending)
    {
        KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);
        pTree->fNameEditPending = FALSE;
    }
}

HWND TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial)
{
    TCHAR szLabel[MAXLABELTEXT];
    TV_DISPINFO nm;

    if (!(pTree->ci.style & TVS_EDITLABELS))
        return NULL;

    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    TV_DismissEdit(pTree, FALSE);


    // Now get the text associated with that item
    nm.item.pszText = szLabel;
    nm.item.cchTextMax = ARRAYSIZE(szLabel);
    nm.item.stateMask = TVIS_BOLD;
    // this cast is ok as long as TVIF_INTEGRAL or anything past it isn't asked for
    TV_GetItem(pTree, hItem, TVIF_TEXT | TVIF_STATE, (LPTVITEMEX)&nm.item);

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText
    // doesn't include the terminating NULL
    pTree->hwndEdit = CreateEditInPlaceWindow(pTree->ci.hwnd,
        pszInitial? pszInitial : nm.item.pszText, ARRAYSIZE(szLabel) - 1,
        WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL,
        (nm.item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont);

    if (pTree->hwndEdit) {
        if (pszInitial)     // if initialized, it's dirty.
            SetWindowID(pTree->hwndEdit, 1);
        //
        // Now notify the parent of this window and see if they want it.
        // We do it after we cretae the window, but before we show it
        // such that our parent can query for it and do things like limit
        // the number of characters that are input
        nm.item.hItem = hItem;
        nm.item.state = hItem->state;
        nm.item.lParam = hItem->lParam;
        nm.item.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_TEXT);

        if ((BOOL)CCSendNotify(&pTree->ci, TVN_BEGINLABELEDIT, &nm.hdr))
        {
            DestroyWindow(pTree->hwndEdit);
            pTree->hwndEdit = NULL;
            return NULL;
        }

        TV_PopBubble(pTree);

        TV_ScrollIntoView(pTree, hItem);

        pTree->pfnEditWndProc = SubclassWindow(pTree->hwndEdit, TV_EditWndProc);

        pTree->htiEdit = hItem;

        TV_SetEditSize(pTree);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(pTree->hwndEdit);
        ShowWindow(pTree->hwndEdit, SW_SHOW);
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(pTree->hwndEdit);
    }

    return pTree->hwndEdit;
}


BOOL TV_DismissEdit(PTREE pTree, BOOL fCancel)
{
    HWND hwndEdit;
    BOOL fOkToContinue = TRUE;
    HTREEITEM htiEdit;

    if (pTree->fNoDismissEdit)
        return FALSE;

    hwndEdit = pTree->hwndEdit;

    if (!hwndEdit) {
        // Also make sure there are no pending edits...
        TV_CancelEditTimer(pTree);
        return TRUE;
    }

    // Assume that if we are not visible that the window is in the
    // process of being destroyed and we should not process the
    // editing of the window...
    if (!IsWindowVisible(pTree->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        //  FALL THROUGH
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // TV_DeleteItemRecurse will set htiEdit to NULL if the program
    // deleted the items out from underneath us (while we are waiting
    // for the edit timer).
    htiEdit = pTree->htiEdit;

    if (htiEdit != NULL)
    {
        TV_DISPINFO nm;
        TCHAR szLabel[MAXLABELTEXT];

        DBG_ValidateTreeItem(htiEdit, 0);

        // Initialize notification message.
        nm.item.hItem = htiEdit;
        nm.item.lParam = htiEdit->lParam;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
            nm.item.mask |= TVIF_TEXT;
        }

        // Make sure the text redraws properly
        TV_InvalidateItem(pTree, htiEdit, RDW_INVALIDATE | RDW_ERASE);
        pTree->fNoDismissEdit = TRUE; // this is so that we don't recurse due to killfocus
        ShowWindow(hwndEdit, SW_HIDE);
        pTree->fNoDismissEdit = FALSE;

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&pTree->ci, TVN_ENDLABELEDIT, &nm.hdr);
        if (fOkToContinue && !fCancel)
        {
            // Bug#94368 raymondc: The caller might have deleted the item in
            // response to the edit.  We should revalidate here (or make
            // delete item invalidate our edit item).  Treat a deletion
            // as if it were a rejected edit.

            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            // Note: The callee may have set the handle to null to tell
            // us that the handle to item is no longer valid.
            if (nm.item.hItem != NULL)
            {
                if (htiEdit->lpstr != LPSTR_TEXTCALLBACK)
                {
                    // Set the item text (everything's set up in nm.item)
                    //
                    nm.item.mask = TVIF_TEXT;
                    TV_SetItem(pTree, (LPTVITEMEX)&nm.item);
                }
                else
                {
                    CCSendNotify(&pTree->ci, TVN_SETDISPINFO, &nm.hdr);
                }
            }
        }
    }

    // If we did not reenter edit mode before now reset the edit state
    // variables to NULL
    if (hwndEdit == pTree->hwndEdit)
    {
        pTree->htiEdit = NULL;
        pTree->hwndEdit = NULL; // so we don't get reentered on the kill focus
    }

    // done with the edit control
    DestroyWindow(hwndEdit);

    return fOkToContinue;
}

LRESULT TV_OnCalcSize(PTREE pTree, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;

    switch(pcalcsize->dwFlag) {
    case PGF_CALCHEIGHT:
        pcalcsize->iHeight = pTree->cShowing * pTree->cyItem;
        TraceMsg(TF_WARNING, "tv.PGF_CALCHEIGHT: cShow=%d cShow*cyItem=%d AWR()=%d",
            pTree->cShowing, pTree->cShowing * pTree->cyItem, pcalcsize->iHeight);
        break;

    case PGF_CALCWIDTH:
        break;
    }
    return 0L;
}

LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TV_OnScroll(pTree, pnm);
        break;
    case PGN_CALCSIZE:
        return TV_OnCalcSize(pTree, pnm);
        break;
    }
    return 0L;
}

LRESULT TV_OnScroll(PTREE pTree, LPNMHDR pnm)
{
  
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    RECT rc = pscroll->rcParent;
    RECT rcTemp;
    int iDir = pscroll->iDir;
    int dyScroll = pscroll->iScroll;
    TREEITEM * hItem;
    UINT uCode;
    int parentsize;
    TREEITEM *  hPrevItem;
    TREEITEM *  hNextItem;
    int y;
    
#ifndef UNIX
    POINT pt = {pscroll->iXpos, pscroll->iYpos};
    POINT ptTemp = pt;
    TREEITEM *  hCurrentItem = TV_CheckHit(pTree, pt.x + 1, pt.y + 1 , &uCode);
#else
    POINT pt; 
    POINT ptTemp;
    TREEITEM *  hCurrentItem;

    pt.x = pscroll->iXpos;
    pt.y = pscroll->iYpos;

    ptTemp = pt;
    hCurrentItem = TV_CheckHit(pTree, pt.x + 1, pt.y + 1 , &uCode);
#endif

    switch(iDir)
    {
        case PGF_SCROLLUP:
            //Check if any Item is partially visible at the left/top. if so then set the bottom 
            // of that Item to be our current offset and then scroll. This avoids skipping over
            // certain Items when partial Items are displayed at the left or top
            y = pt.y;       
            TV_GetItemRect(pTree,hCurrentItem,&rcTemp, TRUE);
 
            if (rcTemp.top  <  y-1)
            {
                hCurrentItem =TV_GetNextItem(pTree,hCurrentItem,TVGN_NEXTVISIBLE);
            }

            // Now do the calculation
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((pt.y - parentsize) > 0))
            {
                dyScroll = parentsize;
            } else if ((pt.y - pTree->cyItem) > 0) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem;
            } else {
                pscroll->iScroll = pt.y;
                return 0L;
            }
            ptTemp.y -= dyScroll;
            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                // if  the hit test gives us the same Item as our CurrentItem then set the Item 
                // to one Item to the top/left  of the  CurrentItem 

                hPrevItem = TV_GetNextItem(pTree,hCurrentItem, TVGN_PREVIOUSVISIBLE);
                if ((hItem == hCurrentItem) && ( hPrevItem != NULL))
                {
                    hItem = hPrevItem;
                }

                //When scrolling left if we end up in the middle of some Item then we align it to the 
                //right of that Item this is to avoid scrolling more than the pager window width but if the
                // Item happens to be the left Item of  our current Item then we end up in not scrolling
                //if thats the case then move one more Item to the left.


                if (hItem == hPrevItem) 
                {
                    hItem = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUSVISIBLE);
                    if(!hItem)
                    {
                        dyScroll = pt.y;
                        break;
                    }
                }

                TV_GetItemRect(pTree,hItem,&rcTemp, TRUE);
                dyScroll = pt.y - rcTemp.bottom;
            }
            break;
        case PGF_SCROLLDOWN:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(pTree->ci.hwnd, &rcChild);
            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((childsize - pt.y - parentsize) > parentsize))
            {
                dyScroll = parentsize;
            } else if ( (childsize - pt.y - parentsize) > (pTree->cyItem * hCurrentItem->iIntegral) ) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem * hCurrentItem->iIntegral;
            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += dyScroll;

            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                if ((hItem == hCurrentItem) && 
                    ((hNextItem = TV_GetNextItem(pTree,hItem,TVGN_NEXTVISIBLE)) != NULL))
                {
                    hItem = hNextItem;
                }
                TV_GetItemRect(pTree, hItem, &rcTemp, TRUE);
                dyScroll = rcTemp.top  - pt.y ;
            }

            break;
        }
    }
    //Set the scroll value
    pscroll->iScroll = dyScroll;
    return 0L;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\multilingual\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\usonly\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\unicwrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       unicwrap.h
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//
//----------------------------------------------------------------------------

#ifndef _UNICWRAP_H_
#define _UNICWRAP_H_

HFONT WINAPI CreateFontIndirectWrap(CONST LOGFONTW * plfw);

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStr (CStr)
//
//  Purpose:    Base class for conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStr
{
public:
    operator char *();

protected:
    CConvertStr(UINT uCP);
    ~CConvertStr();
    void Free();

    UINT    _uCP;
    LPSTR   _pstr;
    char    _ach[MAX_PATH * 2];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::CConvertStr
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::CConvertStr(UINT uCP)
{
    _uCP = uCP;
    _pstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::~CConvertStr
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::~CConvertStr()
{
    Free();
}





//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CConvertStr::operator char *()
{
    return _pstr;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrIn (CStrI)
//
//  Purpose:    Converts string function arguments which are passed into
//              a Windows API.
//
//----------------------------------------------------------------------------

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr);
    CStrIn(LPCWSTR pwstr, int cwch);
    CStrIn(UINT uCP, LPCWSTR pwstr);
    CStrIn(UINT uCP, LPCWSTR pwstr, int cwch);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch);

    int _cchLen;
};




//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class with a given length
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn(LPCWSTR pwstr, int cwch) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwch);
}

inline
CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr, int cwch) : CConvertStr(uCP)
{
    Init(pwstr, cwch);
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn() : CConvertStr(CP_ACP)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrIn::strlen()
{
    return _cchLen;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIM)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr);
};



//+---------------------------------------------------------------------------
//
//  Class:      CStrOut (CStrO)
//
//  Purpose:    Converts string function arguments which are passed out
//              from a Windows API.
//
//----------------------------------------------------------------------------

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOut::BufSize()
{
    return _cwchBuf * 2;
}





//
//      Multi-Byte ---> Unicode conversion
//

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStrW (CStr)
//
//  Purpose:    Base class for multibyte conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::CConvertStrW
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::~CConvertStrW
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::~CConvertStrW()
{
    Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::operator WCHAR *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline 
CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}


//+---------------------------------------------------------------------------
//
//  Class:      CStrInW (CStrI)
//
//  Purpose:    Converts multibyte strings into UNICODE
//
//----------------------------------------------------------------------------

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr) { Init(pstr, -1); }
    CStrInW(LPCSTR pstr, int cch) { Init(pstr, cch); }
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch);

    int _cwchLen;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrInW::CStrInW()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrInW::strlen()
{
    return _cwchLen;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOutW (CStrO)
//
//  Purpose:    Converts returned unicode strings into ANSI.  Used for [out]
//                              params (so we initialize with a buffer that should later be
//                              filled with the correct ansi data)
//                      
//
//----------------------------------------------------------------------------

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf);
    ~CStrOutW();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPSTR       _pstr;
    int     _cchBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOutW::BufSize()
{
    return _cchBuf;
}



#endif // _UNICWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tvscroll.c ===
#include "ctlspriv.h"
#include "treeview.h"

BOOL TV_EnsureVisible(PTREE pTree, TREEITEM * hItem);

// ----------------------------------------------------------------------------
//
//  Updates the iShownIndex for every item below (in list order) a given item
//
// ----------------------------------------------------------------------------

#define TVITEM_HIDDEN -1
int TV_UpdateShownIndexes(PTREE pTree, HTREEITEM hWalk)
{
    WORD iShownIndex;

    if (hWalk == pTree->hRoot) {
        hWalk = pTree->hRoot->hKids;
        if (hWalk) {
            hWalk->iShownIndex = 0;
        } else {
            return TVITEM_HIDDEN;
        }
    }

    iShownIndex = hWalk->iShownIndex + hWalk->iIntegral;
    if (iShownIndex <= 0)
    {
        return(TVITEM_HIDDEN);
    }

    while ((hWalk = TV_GetNextVisItem(hWalk)) != NULL) {
        hWalk->iShownIndex = iShownIndex;
        iShownIndex += (WORD) hWalk->iIntegral;
    }

//#ifdef DEBUG
//      TraceMsg(TF_TREEVIEW, "tv: updated show indexes (now %d items)", (int)iShownIndex);
//#endif
    return (int)iShownIndex;
}

//
// in:
//      hItem   expanded node to count decendants of
//
// returns:
//      total number of expanded descendants below the given item.
//

UINT TV_CountVisibleDescendants(HTREEITEM hItem)
{
    UINT cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
    {
        cnt += hItem->iIntegral;
        if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
            cnt += TV_CountVisibleDescendants(hItem);
    }
    return cnt;
}

//  scrolls nItems in the direction of fDown starting from iTopShownIndex
void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown)
{
    RECT rc;
    SMOOTHSCROLLINFO si;

    rc.left = 0;
    rc.top = (iTopShownIndex+1) * pTree->cyItem;
    rc.right = pTree->cxWnd;
    rc.bottom = pTree->cyWnd;

    si.cbSize = sizeof(si);
    si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
    si.hwnd = pTree->ci.hwnd;
    si.dx = 0;
    si.dy = ((fDown)?1:-1) * nItems * pTree->cyItem;
    si.lprcSrc = &rc;
    si.lprcClip = &rc;
    si.hrgnUpdate = NULL;
    si.lprcUpdate = NULL;
    si.fuScroll = SW_ERASE|SW_INVALIDATE;
    si.uMaxScrollTime = pTree->uMaxScrollTime;
    si.cxMinScroll = 1;
    si.cyMinScroll = 1;
    si.pfnScrollProc = NULL;
    SmoothScrollWindow(&si);
    TV_UpdateToolTip(pTree);
}

//
//  If fRedrawParent is FALSE, then the return value is garbage.
//  If fRedrawParent is TRUE, then returns the number of children scrolled.
//
//  Does not update iShownIndex for any items.
//
UINT TV_ScrollBelow(PTREE pTree, HTREEITEM hItem, BOOL fRedrawParent, BOOL fDown)
{
    int     iTop;
    UINT    cnt;

    // Do nothing if the item is not visible
    if (!ITEM_VISIBLE(hItem))
        return 0;
    
    cnt = hItem->iIntegral; // default return val
    if (pTree->fRedraw) {
        UINT cVisDesc;
        BOOL fEffect;

        // iTop is the top edge (client coordinates) of the bottom integral
        // cell of the item that just got expanded/contracted.
        // (Confused yet?  I sure am.)
        iTop = hItem->iShownIndex - pTree->hTop->iShownIndex + hItem->iIntegral - 1;
        cVisDesc = TV_CountVisibleDescendants(hItem);

        // See if the item being expanded/contracted has any effect on the
        // screen.  If not, then don't TV_ScrollItems or we will end up
        // double-counting them when we do post-scroll adjustment.
        if (fDown)
        {
            // When scrolling down, we have an effect if the item that just
            // got expanded was below the top of the screen
            fEffect = iTop >= 0;
        }
        else
        {
            // When scrolling up, we have an effect if any of the items
            // that just got collapsed out were below the top of the screen
            fEffect = (int)(iTop + cVisDesc) >= 0;
        }

        if (fEffect)
        {
            TV_ScrollItems(pTree, cVisDesc, iTop, fDown);
        }

        TV_InvalidateItem(pTree, hItem, TRUE);

        if (fRedrawParent)
            cnt = cVisDesc;

    } else {

        if (fRedrawParent)
            cnt = TV_CountVisibleDescendants(hItem);

    }

    return(cnt);
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      TVFAKEDRAW tvfd;
//      TreeView_BeginFakeCustomDraw(pTree, &tvfd);
//      for each item you care about {
//          TreeView_BeginFakeItemDraw(&tvfd, hitem);
//          <party on the HDC in tvfd.nmcd.nmcd.hdc>
//          TreeView_EndFakeItemDraw(&tvfd);
//      }
//      TreeView_EndFakeCustomDraw(&tvfd);
//

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd)
{
    ptvfd->nmcd.nmcd.hdc = GetDC(pTree->ci.hwnd);
    ptvfd->nmcd.nmcd.uItemState = 0;
    ptvfd->nmcd.nmcd.dwItemSpec = 0;
    ptvfd->nmcd.nmcd.lItemlParam = 0;
    ptvfd->hfontPrev = (HFONT)GetCurrentObject(ptvfd->nmcd.nmcd.hdc, OBJ_FONT);

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&ptvfd->nmcd.nmcd.rc);

    ptvfd->pTree = pTree;
    ptvfd->dwCustomPrev = pTree->ci.dwCustom;

    pTree->ci.dwCustom = CIFakeCustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &ptvfd->nmcd.nmcd);
}

DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW ptvfd, HTREEITEM hitem)
{
    PTREE pTree = ptvfd->pTree;

    // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    ptvfd->nmcd.nmcd.dwItemSpec = (DWORD_PTR)hitem;
    ptvfd->nmcd.nmcd.lItemlParam = hitem->lParam;

    if (hitem->state & TVIS_BOLD) {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFontBold);
    } else {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFont);
    }

    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        // Font should not depend on colors or flags since those change
        // dynamically but we cache the width info forever.  So we don't
        // need to set up uItemState.
        ptvfd->nmcd.clrText = pTree->clrText;
        ptvfd->nmcd.clrTextBk = pTree->clrBk;
        ptvfd->nmcd.iLevel = hitem->iLevel;
        ptvfd->dwCustomItem = CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &ptvfd->nmcd.nmcd);
    } else {
        ptvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    return ptvfd->dwCustomItem;
}

void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    if (!(ptvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (ptvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &ptvfd->nmcd.nmcd);
    }
}

void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    // notify parent afterwards if they want us to
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &ptvfd->nmcd.nmcd);
    }

    // Restore previous state
    pTree->ci.dwCustom = ptvfd->dwCustomPrev;
    SelectObject(ptvfd->nmcd.nmcd.hdc, ptvfd->hfontPrev);
    ReleaseDC(pTree->ci.hwnd, ptvfd->nmcd.nmcd.hdc);
}


// ----------------------------------------------------------------------------
//
//  Returns the width of the widest shown item in the tree
//
// ----------------------------------------------------------------------------

UINT TV_RecomputeMaxWidth(PTREE pTree)
{
    if (!(pTree->ci.style & TVS_NOSCROLL)) {
        HTREEITEM hItem;
        WORD wMax = 0;

        // REVIEW: this might not be the most efficient traversal of the tree

        for (hItem = pTree->hRoot->hKids; hItem; hItem = TV_GetNextVisItem(hItem))
        {
            if (wMax < FULL_WIDTH(pTree, hItem))
                wMax = FULL_WIDTH(pTree, hItem);
        }

        return((UINT)wMax);
    } else {
        return pTree->cxWnd;
    }
}


// ----------------------------------------------------------------------------
//
//  Returns the horizontal text extent of the given item's text
//
// ----------------------------------------------------------------------------

WORD TV_GetItemTextWidth(HDC hdc, PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX sItem;
    TCHAR szTemp[MAX_PATH];
    SIZE size = {0,0};

    sItem.pszText = szTemp;
    sItem.cchTextMax = ARRAYSIZE(szTemp);

    TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

    GetTextExtentPoint(hdc, sItem.pszText, lstrlen(sItem.pszText), &size);
    return (WORD)(size.cx + (g_cxLabelMargin * 2) + pTree->cxBorder);
}


// ----------------------------------------------------------------------------
//
//  Compute the text extent and the full width (indent, image, and text) of
//  the given item.
//
//  If there is a HDC, then we assume that the HDC has been set up with
//  the proper attributes (specifically, the font).  If there is no HDC,
//  then we will set one up, measure the text, then tear it down.
//  If you will be measuring more than one item, it is recommended that
//  the caller set up the HDC and keep re-using it, because creating,
//  initializing, then destroy the HDC is rather slow.
//
// ----------------------------------------------------------------------------

void TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc)
{
    TVFAKEDRAW  tvfd;                    // in case client uses customdraw
    int iOldWidth = hItem->iWidth;

    if (hdc == NULL) {
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
    }
    else
    {
        tvfd.nmcd.nmcd.hdc = hdc;
    }
    
    hItem->iWidth = TV_GetItemTextWidth(tvfd.nmcd.nmcd.hdc, pTree, hItem);

    if (!(pTree->ci.style & TVS_NOSCROLL) && iOldWidth != hItem->iWidth)
        if (pTree->cxMax < FULL_WIDTH(pTree, hItem)) {
            PostMessage(pTree->ci.hwnd, TVMP_CALCSCROLLBARS, 0, 0);
            pTree->cxMax = FULL_WIDTH(pTree, hItem);
        }
    
    if (hdc == NULL)
    {
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);
    }
}


// ----------------------------------------------------------------------------
//
//  Returns TRUE if the item is expanded, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL TV_IsShowing(HTREEITEM hItem)
{
    for (hItem = hItem->hParent; hItem; hItem = hItem->hParent)
        if (!(hItem->state & TVIS_EXPANDED))
            return FALSE;

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  If the added item is showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollBarsAfterAdd(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM   hPrev;

    if (!TV_IsShowing(hItem))
    {
        // item isn't visible -- set index to NOTVISIBLE and return
        hItem->iShownIndex = (WORD)-1;
        return FALSE;
    }

    hPrev = TV_GetPrevVisItem(hItem);

    // increment every shown index after newly added item

    hItem->iShownIndex = (hPrev) ? hPrev->iShownIndex + hPrev->iIntegral : 0;

    TV_UpdateShownIndexes(pTree, hItem);

    pTree->cShowing += hItem->iIntegral;

    TV_ComputeItemWidth(pTree, hItem, NULL);

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the removed item was showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollBarsAfterRemove(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM hWalk;
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    // decrement every shown index after removed item
    hItem->iShownIndex = (WORD)-1;

    hWalk = TV_GetNextVisItem(hItem);
    if (hWalk) 
    {
        hWalk->iShownIndex -= (WORD) hItem->iIntegral;
        TV_UpdateShownIndexes(pTree, hWalk);

        // If we delete the top item, the tree scrolls to the end, so ...
        if (pTree->hTop == hItem) 
        {
            TV_SetTopItem(pTree, hWalk->iShownIndex);
        }
    }

    pTree->cShowing -= hItem->iIntegral;

    if (pTree->fRedraw) 
    {
        if (!hItem->iWidth)
            TV_ComputeItemWidth(pTree, hItem, NULL);


        if (!(pTree->ci.style & TVS_NOSCROLL))
            if (pTree->cxMax == FULL_WIDTH(pTree, hItem))
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);

        TV_CalcScrollBars(pTree);
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Common worker function for
//  TV_ScrollBarsAfterExpand and TV_ScrollBarsAfterCollapse, since they
//  are completely identical save for two lines of code.
//
//  If the expanded items are / collapsed items were showing, update
//  the shown (expanded) count, the max item width -- then recompute
//  the scroll bars.
//
// ----------------------------------------------------------------------------

#define SBAEC_COLLAPSE  0
#define SBAEC_EXPAND    1

BOOL TV_ScrollBarsAfterExpandCollapse(PTREE pTree, HTREEITEM hParent, UINT flags)
{
    WORD cxMax = 0;
    HTREEITEM hWalk;
    TVFAKEDRAW tvfd;

    if (!ITEM_VISIBLE(hParent))
        return FALSE;

    //
    // We're going to be measuring a lot of items, so let's set up
    // our DC ahead of time.
    //
    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    for (hWalk = hParent->hKids;
         hWalk && (hWalk->iLevel > hParent->iLevel);
         hWalk = TV_GetNextVisItem(hWalk))
    {
         if (flags == SBAEC_COLLAPSE)
            hWalk->iShownIndex = (WORD)-1;
         if (!hWalk->iWidth)
         {
            TreeView_BeginFakeItemDraw(&tvfd, hWalk);
            TV_ComputeItemWidth(pTree, hWalk, tvfd.nmcd.nmcd.hdc);
            TreeView_EndFakeItemDraw(&tvfd);
         }
         if (cxMax < FULL_WIDTH(pTree, hWalk))
             cxMax = FULL_WIDTH(pTree, hWalk);
    }

    TreeView_EndFakeCustomDraw(&tvfd);

    // update every shown index after expanded parent
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hParent);

    // Update the pTree->cxMax if it is affected by the items we
    // expanded/collapsed.

    if (!(pTree->ci.style & TVS_NOSCROLL))
    {
        if (flags == SBAEC_COLLAPSE)
        {
            // If one of our newly-hidden items was responsible for
            // the width being what it is, recompute the max width
            // since we hid those items.
            if (cxMax == pTree->cxMax)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
        }
        else
        {
            // If one of our newly-shown items was responsible is wider
            // then the previous max, then we have set a new max.
            if (cxMax > pTree->cxMax)
                pTree->cxMax = cxMax;
        }
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the expanded items are showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollBarsAfterExpand(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_EXPAND);
}


// ----------------------------------------------------------------------------
//
//  If the collapsed items were showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollBarsAfterCollapse(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_COLLAPSE);
}

// ----------------------------------------------------------------------------
//
//  If the added item changed height, then scroll thing around,
//  update the shown (expanded) count, recompute the scroll bars.
//
//  sets cShowing
//
// ----------------------------------------------------------------------------

void TV_ScrollBarsAfterResize(PTREE pTree, HTREEITEM hItem, int iIntegralPrev, UINT uRDWFlags)
{
    int iMaxIntegral = max(hItem->iIntegral, iIntegralPrev);

    ASSERT(hItem->iIntegral != iIntegralPrev);

    if (pTree->fRedraw)
    {
        int iTop = hItem->iShownIndex - pTree->hTop->iShownIndex +
                    iMaxIntegral - 1;
        if (iTop >= 0)
        {
            int iGrowth = hItem->iIntegral - iIntegralPrev;
            TV_ScrollItems(pTree, abs(iGrowth), iTop, iGrowth > 0);
        }
    }

    // update every shown index after resized item
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hItem);
    TV_CalcScrollBars(pTree);

    // Invalidate based on the worst-case height so we handle
    // both the grow and shrink cases.
    if (pTree->fRedraw)
    {
        RECT rc;
        if (TV_GetItemRect(pTree, hItem, &rc, FALSE))
        {
            rc.bottom = rc.top + pTree->cyItem * iMaxIntegral;
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, uRDWFlags);
        }
    }
}



// ----------------------------------------------------------------------------
//
//  Returns the item just below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM * TV_GetNext(TREEITEM * hItem)
{
    DBG_ValidateTreeItem(hItem, FALSE);

    if (hItem->hKids)
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return hItem->hNext;

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Go through all the items in the tree, recomputing each item's text extent
//  and full width (indent, image, and text).
//
// ----------------------------------------------------------------------------

void TV_RecomputeItemWidths(PTREE pTree)
{
    HTREEITEM hItem;
    TVFAKEDRAW tvfd;

    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    hItem = pTree->hRoot->hKids;
    while (hItem)
    {
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
        TV_ComputeItemWidth(pTree, hItem, tvfd.nmcd.nmcd.hdc);
        TreeView_EndFakeItemDraw(&tvfd);
        hItem = TV_GetNext(hItem);
    }
    TreeView_EndFakeCustomDraw(&tvfd);
}


// ----------------------------------------------------------------------------
//
//  If a single item's width changed, alter the max width if needed.
//  If all widths changed, recompute widths and max width.
//  Then recompute the scroll bars.
//
//  sets cxMax
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollBarsAfterSetWidth(PTREE pTree, HTREEITEM hItem)
{
    if (hItem)
    {
        UINT iOldWidth = FULL_WIDTH(pTree, hItem);
        TV_ComputeItemWidth(pTree, hItem, NULL);

        if (!(pTree->ci.style & TVS_NOSCROLL)) {
            if (pTree->cxMax == iOldWidth)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
            else
                return(FALSE);
        }
    }
    else
    {
        TV_RecomputeItemWidths(pTree);
        pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically as needed to make given item fully visible
//  vertically
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollVertIntoView(PTREE pTree, HTREEITEM hItem)
{
    // This function has crashed in stress before, so we need to assert the incoming parameters.
    ASSERT(hItem);
    ASSERT(pTree && pTree->hTop);

    // Do nothing if the parameters are invalid
    if (!hItem || !pTree || !(pTree->hTop))
        return FALSE;

    // Do nothing if this item is not visible
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    if (hItem->iShownIndex < pTree->hTop->iShownIndex)
        return(TV_SetTopItem(pTree, hItem->iShownIndex));

    if (hItem->iShownIndex >= (pTree->hTop->iShownIndex + pTree->cFullVisible))
        return(TV_SetTopItem(pTree, hItem->iShownIndex + 1 - pTree->cFullVisible));

    return FALSE;
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically and horizontally as needed to make given item
//  fully visible vertically and horizontally
//
// ----------------------------------------------------------------------------

BOOL TV_ScrollIntoView(PTREE pTree, HTREEITEM hItem)
{
    UINT iWidth, iOffset;
    BOOL fChange;

    fChange = TV_ScrollVertIntoView(pTree, hItem);

    // ensure that item's text is fully visible horizontally
    iWidth = pTree->cxImage + pTree->cxState + hItem->iWidth;
    if (iWidth > (UINT)pTree->cxWnd)
        iWidth = pTree->cxWnd; //hItem->iWidth;

    iOffset = ITEM_OFFSET(pTree, hItem);

    if ((int) (iOffset) < pTree->xPos)
        fChange |= TV_SetLeft(pTree, iOffset);
    else if ((iOffset + iWidth) > (UINT)(pTree->xPos + pTree->cxWnd))
        fChange |= TV_SetLeft(pTree, iOffset + iWidth - pTree->cxWnd);

    return fChange;
}


// ----------------------------------------------------------------------------
//
//  Sets position of horizontal scroll bar and scrolls window to match that
//  position
//
//  sets xPos
//
// ----------------------------------------------------------------------------

BOOL TV_SetLeft(PTREE pTree, int x)
{
    if (!pTree->fHorz || pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL))
        return(FALSE);

    if (x > (int) (pTree->cxMax - pTree->cxWnd))
        x = (pTree->cxMax - pTree->cxWnd);
    if (x < 0)
        x = 0;

    if (x == pTree->xPos)
        return(FALSE);

    if (pTree->fRedraw) 
    {
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
        si.hwnd = pTree->ci.hwnd;
        si.dx = pTree->xPos - x;
        si.dy = 0;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE;
        si.uMaxScrollTime = pTree->uMaxScrollTime;
        si.cxMinScroll = 1;
        si.cyMinScroll = 1;
        si.pfnScrollProc = NULL;
        SmoothScrollWindow(&si);
    }

    pTree->xPos = (SHORT) x;

    SetScrollPos(pTree->ci.hwnd, SB_HORZ, x, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Returns the tree's item that has the given shown index, NULL if no item
//  found with that index.
//
// ----------------------------------------------------------------------------

HTREEITEM TV_GetShownIndexItem(HTREEITEM hItem, UINT wShownIndex)
{
    HTREEITEM hWalk;

    if (hItem == NULL)
        return NULL;

    //ASSERT((int)wShownIndex >= 0);

    for (hWalk = hItem;
         hWalk && (hWalk->iShownIndex <= wShownIndex);
         hWalk = hWalk->hNext) {
        
         hItem = hWalk;
         
         if (hWalk->iShownIndex + (UINT)hWalk->iIntegral > wShownIndex) 
             return hWalk;
    }

    return TV_GetShownIndexItem(hItem->hKids, wShownIndex);
}


// ----------------------------------------------------------------------------
//
//  Sets position of vertical scroll bar and scrolls window to match that
//  position
//
//  sets hTop
//
// ----------------------------------------------------------------------------

BOOL TV_SmoothSetTopItem(PTREE pTree, UINT wNewTop, UINT uSmooth)
{
    HTREEITEM hItem = pTree->hRoot->hKids;
    UINT wOldTop;

    if (!hItem)
        return FALSE;
    
    if ((pTree->ci.style & TVS_NOSCROLL) || (wNewTop == (UINT)-1) || (pTree->cShowing <= pTree->cFullVisible)) {
        // we've wrapped around (treat as a negative index) -- use min pos
        // or there aren't enough items to scroll
        wNewTop = 0;
    } else if (wNewTop > (UINT)(pTree->cShowing - pTree->cFullVisible)) {
        // we've gone too far down -- use max pos
        wNewTop = (pTree->cShowing - pTree->cFullVisible);

    }

    // if there's no room for anything to show. peg at the end
    if (wNewTop > 0 && wNewTop >= pTree->cShowing) {
        wNewTop = pTree->cShowing - 1;
    }

    hItem = TV_GetShownIndexItem(hItem, wNewTop);

    //ASSERT(hItem);

    if (NULL == hItem || pTree->hTop == hItem)
        return FALSE;
    // need to refetch because wNewTop couldhave pointed to the middle of this item,
    // which is not allowed
    wNewTop = hItem->iShownIndex;
    
    wOldTop = pTree->hTop->iShownIndex;

    pTree->hTop = hItem;

    if (pTree->fRedraw) 
    {
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
        si.hwnd = pTree->ci.hwnd;
        si.dx = 0;
        si.dy = (int) (wOldTop - wNewTop) * (int) pTree->cyItem;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE | uSmooth;
        si.uMaxScrollTime = pTree->uMaxScrollTime;
        si.cxMinScroll = 1;
        si.cyMinScroll = 1;
        si.pfnScrollProc = NULL;
        SmoothScrollWindow(&si);
    }

    SetScrollPos(pTree->ci.hwnd, SB_VERT, wNewTop, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Computes the horizontal and vertical scroll bar ranges, pages, and
//  positions, adding or removing the scroll bars as needed.
//
//  sets fHorz, fVert
//
// ----------------------------------------------------------------------------

BOOL TV_CalcScrollBars(PTREE pTree)
{
    // UINT wMaxPos;
    BOOL fChange = FALSE;
    SCROLLINFO si;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        return FALSE;

    si.cbSize = sizeof(SCROLLINFO);

    if (!(pTree->ci.style & TVS_NOHSCROLL))
    {
        if ((SHORT)pTree->cxMax > (SHORT)pTree->cxWnd)
        {
            if (!pTree->fHorz)
            {
                fChange = TRUE;
                pTree->fHorz = TRUE;
            }

            si.fMask = SIF_PAGE | SIF_RANGE;
            si.nMin = 0;
            si.nMax = pTree->cxMax - 1;
            si.nPage = pTree->cxWnd;

            TV_SetLeft(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_HORZ, &si, TRUE));
        }
        else if (pTree->fHorz)
        {
            TV_SetLeft(pTree, 0);
            SetScrollRange(pTree->ci.hwnd, SB_HORZ, 0, 0, TRUE);

            pTree->fHorz = FALSE;
            fChange = TRUE;
        }
    }

    if (pTree->cShowing > pTree->cFullVisible)
    {
        if (!pTree->fVert)
        {
            pTree->fVert = TRUE;
            fChange = TRUE;
        }

        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = pTree->cShowing - 1;
        si.nPage = pTree->cFullVisible;

        TV_SetTopItem(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_VERT, &si, TRUE));

    }
    else if (pTree->fVert)
    {
        TV_SetTopItem(pTree, 0);
        SetScrollRange(pTree->ci.hwnd, SB_VERT, 0, 0, TRUE);

        pTree->fVert = FALSE;
        fChange = TRUE;
    }

    if (fChange)
        TV_SizeWnd(pTree, 0, 0);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Handles horizontal scrolling.
//
// ----------------------------------------------------------------------------

BOOL TV_HorzScroll(PTREE pTree, UINT wCode, UINT wNewPos)
{
    BOOL fChanged;

    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cxMax - pTree->cxWnd;
            break;

        case SB_ENDSCROLL:
            wNewPos = pTree->xPos;
            break;

        case SB_LINEDOWN:
            wNewPos = pTree->xPos + MAGIC_HORZLINE;
            break;

        case SB_LINEUP:
            wNewPos = pTree->xPos - MAGIC_HORZLINE;
            break;

        case SB_PAGEDOWN:
            wNewPos = pTree->xPos + (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_PAGEUP:
            wNewPos = pTree->xPos - (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SetLeft(pTree, wNewPos))
        UpdateWindow(pTree->ci.hwnd);

    return(fChanged);
}


// ----------------------------------------------------------------------------
//
//  Handles vertical scrolling.
//
// ----------------------------------------------------------------------------

BOOL TV_VertScroll(PTREE pTree, UINT wCode, UINT wPos)
{
    UINT wNewPos = 0;
    UINT wOldPos;
    BOOL fChanged;
    UINT uSmooth = 0;

    if (!pTree->hTop)
        return FALSE;
    
    wOldPos = pTree->hTop->iShownIndex;
    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cShowing - pTree->cFullVisible;
            break;

        case SB_ENDSCROLL:
            wNewPos = wOldPos;
            break;

        case SB_LINEDOWN:
            wNewPos = wOldPos + pTree->hTop->iIntegral;
            break;

        case SB_LINEUP:
            wNewPos = wOldPos - 1;
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_PAGEDOWN:
            wNewPos = wOldPos + (pTree->cFullVisible - 1);
            break;

        case SB_PAGEUP:
            wNewPos = wOldPos - (pTree->cFullVisible - 1);
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            uSmooth = SSW_EX_IMMEDIATE;
            wNewPos = wPos;
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SmoothSetTopItem(pTree, wNewPos, uSmooth))
        UpdateWindow(pTree->ci.hwnd);
    return(fChanged);
}


#ifdef DEBUG
static int nCompares;
#endif

typedef struct {
    LPTSTR lpstr;
    BOOL bCallBack;
    HTREEITEM hItem;
} TVCOMPARE, *LPTVCOMPARE;

// Pointer comparision function for Sort and Search functions.
// lParam is lParam passed to sort/search functions.  Returns
// -1 if p1 < p2, 0 if p1 == p2, and 1 if p1 > p2.
//
int CALLBACK TV_DefCompare(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
#ifdef DEBUG
        ++nCompares;
#endif

        return lstrcmpi(sCmp1->lpstr, sCmp2->lpstr);
}


int CALLBACK TV_CompareItems(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
        TV_SORTCB *pSortCB = (TV_SORTCB *)lParam;
#ifdef DEBUG
        ++nCompares;
#endif

        return(pSortCB->lpfnCompare(sCmp1->hItem->lParam, sCmp2->hItem->lParam,
                pSortCB->lParam));
}


UINT TV_CountKids(HTREEITEM hItem)
{
    int cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
        cnt++;

    return cnt;
}


BOOL TV_SortCB(PTREE pTree, TV_SORTCB *pSortCB, BOOL bRecurse,
        PFNDPACOMPARE lpfnDPACompare)
{
        HDPA dpaSort;
        HDSA dsaCmp;
        HTREEITEM hItem, hNext, hFirstMoved;
        LPTVCOMPARE psCompare, *ppsCompare;
        int i, cKids;
        HTREEITEM hParent = pSortCB->hParent;

#ifdef DEBUG
        DWORD dwTime = GetTickCount();
        nCompares = 0;
#endif

        if (!hParent || hParent == TVI_ROOT)
            hParent = pTree->hRoot;

        if (!ValidateTreeItem(hParent, FALSE))
            return FALSE;               // Invalid parameter

        // Code below assumes at least one kid
        cKids = TV_CountKids(hParent);
        if (!cKids)
            return FALSE;

        // Create a DSA for all the extra info we'll need
        dsaCmp = DSA_Create(sizeof(TVCOMPARE), cKids);
        if (!dsaCmp)
            goto Error1;

        // Create a DPA containing all the tree items
        dpaSort = DPA_Create(cKids);
        if (!dpaSort)
            goto Error2;

        for (hItem = hParent->hKids; hItem; hItem = hItem->hNext)
        {
                TVCOMPARE sCompare;
                int nItem;

                // If I can't sort all of them, I don't want to sort any of them

                // We want to cache the text callback for default processing
                if (!lpfnDPACompare && hItem->lpstr==LPSTR_TEXTCALLBACK)
                {
                        TVITEMEX sItem;
                        TCHAR szTemp[MAX_PATH];

                        sItem.pszText = szTemp;
                        sItem.cchTextMax  = ARRAYSIZE(szTemp);
                        TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

                        sCompare.lpstr = NULL;
                        sCompare.bCallBack = TRUE;
                        Str_Set(&sCompare.lpstr, sItem.pszText);
                        if (!sCompare.lpstr)
                        {
                                goto Error3;
                        }
                }
                else
                {
                        sCompare.lpstr = hItem->lpstr;
                        sCompare.bCallBack = FALSE;
                }

                // Create the pointer for this guy and add it to the DPA list
                sCompare.hItem = hItem;
                nItem = DSA_AppendItem(dsaCmp, &sCompare);
                if (nItem < 0)
                {
                        if (sCompare.bCallBack)
                        {
                                Str_Set(&sCompare.lpstr, NULL);
                        }
                        goto Error3;
                }

                if (DPA_AppendPtr(dpaSort, DSA_GetItemPtr(dsaCmp, nItem)) < 0)
                {
                        goto Error3;
                }
        }

        // Sort the DPA, then stick them back under the parent in the new order
        DPA_Sort(dpaSort, lpfnDPACompare ? (PFNDPACOMPARE)lpfnDPACompare :
                 (PFNDPACOMPARE) TV_DefCompare, (LPARAM)pSortCB);


        // Look for the first moved item, so we can invalidate a smaller area
        ppsCompare = (LPTVCOMPARE *)DPA_GetPtrPtr(dpaSort);
        if (hParent->hKids != (*ppsCompare)->hItem)
        {
                hParent->hKids = (*ppsCompare)->hItem;
                hFirstMoved = hParent->hKids;
        }
        else
        {
                hFirstMoved = NULL;
        }

        // We do n-1 iterations here
        for (i = DPA_GetPtrCount(dpaSort) - 1; i > 0; --i, ++ppsCompare)
        {
                hNext = (*(ppsCompare+1))->hItem;
                if ((*ppsCompare)->hItem->hNext != hNext && !hFirstMoved)
                {
                        hFirstMoved = hNext;
                }
                (*ppsCompare)->hItem->hNext = hNext;
        }
        (*ppsCompare)->hItem->hNext = NULL;

        TV_UpdateShownIndexes(pTree, hParent);
        if ((pSortCB->hParent == TVI_ROOT) || !hParent) {
            if (pTree->cShowing < pTree->cFullVisible) {
                pTree->hTop = pTree->hRoot->hKids;
            }
        }

        if (hFirstMoved && (hParent->state & TVIS_EXPANDED))
        {
                RECT rcUpdate;

                TV_GetItemRect(pTree, hFirstMoved, &rcUpdate, FALSE);
                if (hParent->hNext)
                {
                        RECT rcTemp;

                        TV_GetItemRect(pTree, hParent->hNext, &rcTemp, FALSE);
                        rcUpdate.bottom = rcTemp.bottom;
                }
                else
                {
                        RECT rcClient;
                        GetClientRect(pTree->ci.hwnd, &rcClient);
                        // Set to maximal positive number, so the whole rest of
                        // the treeview gets invalidated
                        rcUpdate.bottom = rcClient.bottom;
                }
                if (pTree->fRedraw)
                    InvalidateRect(pTree->ci.hwnd, &rcUpdate, TRUE);
        }

Error3:
        DPA_Destroy(dpaSort);
Error2:
        for (i = DSA_GetItemCount(dsaCmp) - 1; i >= 0; --i)
        {
                psCompare = DSA_GetItemPtr(dsaCmp, i);
                if (psCompare->bCallBack)
                {
                        Str_Set(&(psCompare->lpstr), NULL);
                }
        }
        DSA_Destroy(dsaCmp);
Error1:

#ifdef DEBUG
        TraceMsg(TF_TREEVIEW, "tv.sort: %ld ms; %d cmps", GetTickCount()-dwTime, nCompares);
#endif

    {
        int wNewPos;
        // restore the scroll position
        if (GetWindowStyle(pTree->ci.hwnd) & WS_VSCROLL) {
            SCROLLINFO si;

            si.cbSize = sizeof(SCROLLINFO);
            si.fMask = SIF_POS;
            wNewPos = 0;
            if (GetScrollInfo(pTree->ci.hwnd, SB_VERT, &si)) {
                wNewPos = si.nPos;
            }

        } else {
            wNewPos = 0;
        }

        if (TV_SetTopItem(pTree, wNewPos))
            UpdateWindow(pTree->ci.hwnd);
    }

    // if the caret is the child of the thing that was sorted, make sure it's
    // visible (but if we're sorting something completely unrelated, don't bother
    if (pTree->hCaret) {
        hItem = pTree->hCaret;
        do {
            // do this first.  if hParent is hCaret, we don't want to ensure visible...
            // only if it's an eventual child
            hItem = hItem->hParent;
            if (hParent == hItem) {
                TV_EnsureVisible(pTree, pTree->hCaret);
            }
        } while(hItem && hItem != pTree->hRoot);
    }

    // The items in the view may have moved around; let apps know
    // Do this last because this call might yield
    NotifyWinEvent(EVENT_OBJECT_REORDER, pTree->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}


BOOL TV_SortChildrenCB(PTREE pTree, LPTV_SORTCB pSortCB, BOOL bRecurse)
{
    if (pSortCB == NULL)
    {
        RIPMSG(0, "TVM_SORTCHILDRENCB: Invalid parameter (NULL for TVSORTCB)");
        return FALSE;
    }

    return(TV_SortCB(pTree, pSortCB, bRecurse, (PFNDPACOMPARE)TV_CompareItems));
}


BOOL TV_SortChildren(PTREE pTree, HTREEITEM hParent, BOOL bRecurse)
{
    TV_SORTCB sSortCB;

    sSortCB.hParent = hParent;
    return(TV_SortCB(pTree, &sSortCB, bRecurse, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\usrctl32.h ===
#if !defined(USRCTL32__UsrCtl32_h__INCLUDED)
#define USRCTL32__UsrCtl32_h__INCLUDED

//
// Known dimensions of sys fonts
//
#define  SYSFONT_CXCHAR     8
#define  SYSFONT_CYCHAR     16

//
// user control macros
//
#define UserAssert(e) \
            ASSERT(e)

#define UserLocalAlloc(uFlag,uBytes) \
            HeapAlloc(GetProcessHeap(), uFlag, (uBytes))

#define UserLocalReAlloc(p, uBytes, uFlags)     \
            HeapReAlloc(GetProcessHeap(), uFlags, (LPSTR)(p), (uBytes))

#define UserLocalFree(p) \
            HeapFree(GetProcessHeap(), 0, (LPSTR)(p))

#define UserLocalSize(p) \
            HeapSize(GetProcessHeap(), 0, (LPSTR)(p))

#define SetWindowState(hwnd, flags)   \
            SetWindowLong(hwnd, GWL_STYLE, GetWindowStyle(hwnd) | (flags))

#define ClearWindowState(hwnd, flags)   \
            SetWindowLong(hwnd, GWL_STYLE, GetWindowStyle(hwnd) & ~(flags))

#define SYSMET(i)               GetSystemMetrics( SM_##i )
#define SYSMETRTL(i)            GetSystemMetrics( SM_##i )
#define SYSRGB(i)               GetSysColor(COLOR_##i)
#define SYSRGBRTL(i)            GetSysColor(COLOR_##i)
#define SYSHBR(i)               GetSysColorBrush(COLOR_##i)


typedef struct tagWW
{
    DWORD   dwState;
    DWORD   dwState2;
    DWORD   dwExStyle;
    DWORD   dwStyle;
} WW, *PWW;

#define GET_STATE(pctl)     ((pctl)->pww->dwState)
#define GET_STATE2(pctl)    ((pctl)->pww->dwState2)
#define GET_EXSTYLE(pctl)   ((pctl)->pww->dwExStyle)
#define GET_STYLE(pctl)     ((pctl)->pww->dwStyle)

#define TESTFLAG(field,bits)  (((field)&(bits)) ? TRUE : FALSE)

//
// Window Style and State Masks -
//
// High byte of word is byte index from the start of the state field
// in the WND structure, low byte is the mask to use on the byte.
// These masks assume the order of the state and style fields of a
// window instance structure.
//
// This is how the Test/Set/Clr/MaskWF value ranges map to the corresponding
// fields in the window structure.
//
//   offset                 WND field
//   0 - 3                  state        - private
//   4 - 7                  state2       - private
//   8 - B                  ExStyle      - public, exposed in SetWindowLong(GWL_EXSTYLE)
//   C - F                  style        - public, exposed in SetWindowLong(GWL_STYLE)
//                                         C-D are reserved for window class designer.
//                                         E-F are reserved for WS_ styles.
//
// See windows
\core\ntuser\inc\user.h definition of WND struct 
// See public\internal\windows\inc\wowuserp.h for WW struct

//
// State flags, from 0x0000 to 0x0380.
//

//
// DON'T MOVE ANY ONE OF THE FOLLOWING WFXPRESENT FLAGS,
// BECAUSE WFFRAMEPRESENTMASK DEPENDS ON THEIR VALUES
//
#define WS_ST_MPRESENT                 0x00000001
#define WS_ST_VPRESENT                 0x00000002
#define WS_ST_HPRESENT                 0x00000004
#define WS_ST_CPRESENT                 0x00000008
#define WS_ST_FRAMEON                  0x00000040
#define WS_ST_ANSIPROC                 0x00080000
#define WS_ST_ANSICREATOR              0x20000000

#define WS_S2_OLDUI                    0x00000008
#define WS_S2_WIN31COMPAT              0x00000100
#define WS_S2_WIN40COMPAT              0x00000200
#define WS_S2_LINEUPBUTTONDOWN         0x00010000
#define WS_S2_PAGEUPBUTTONDOWN         0x00020000
#define WS_S2_PAGEDNBUTTONDOWN         0x00040000
#define WS_S2_LINEDNBUTTONDOWN         0x00080000
#define WS_S2_VERTSCROLLTRACK          0x00200000

#define WFMPRESENT              0x0001
#define WFVPRESENT              0x0002
#define WFHPRESENT              0x0004
#define WFCPRESENT              0x0008
#define WFFRAMEPRESENTMASK      0x000F

#define WFSENDSIZEMOVE          0x0010
#define WFMSGBOX                0x0020  // used to maintain count of msg boxes on screen
#define WFFRAMEON               0x0040
#define WFHASSPB                0x0080
#define WFNONCPAINT             0x0101
#define WFSENDERASEBKGND        0x0102
#define WFERASEBKGND            0x0104
#define WFSENDNCPAINT           0x0108
#define WFINTERNALPAINT         0x0110
#define WFUPDATEDIRTY           0x0120
#define WFHIDDENPOPUP           0x0140
#define WFMENUDRAW              0x0180

//
// NOTE -- WFDIALOGWINDOW is used in WOW.  DO NOT CHANGE without
//   changing WD_DIALOG_WINDOW in winuser.w
//
#define WFDIALOGWINDOW          0x0201

#define WFTITLESET              0x0202
#define WFSERVERSIDEPROC        0x0204
#define WFANSIPROC              0x0208
#define WFBEINGACTIVATED        0x0210  // prevent recursion in xxxActivateThis Window
#define WFHASPALETTE            0x0220
#define WFPAINTNOTPROCESSED     0x0240  // WM_PAINT message not processed
#define WFSYNCPAINTPENDING      0x0280
#define WFGOTQUERYSUSPENDMSG    0x0301
#define WFGOTSUSPENDMSG         0x0302
#define WFTOGGLETOPMOST         0x0304  // Toggle the WS_EX_TOPMOST bit ChangeStates

//
// DON'T MOVE REDRAWIFHUNGFLAGS WITHOUT ADJUSTING WFANYHUNGREDRAW
//
#define WFREDRAWIFHUNG          0x0308
#define WFREDRAWFRAMEIFHUNG     0x0310
#define WFANYHUNGREDRAW         0x0318

#define WFANSICREATOR           0x0320
#define WFREALLYMAXIMIZABLE     0x0340  // The window fills the work area or monitor when maximized
#define WFDESTROYED             0x0380

//
// State2 flags, from 0x0400 to 0x0780.
//
#define WFWMPAINTSENT           0x0401
#define WFDONTVALIDATE          0x0402
#define WFSTARTPAINT            0x0404
#define WFOLDUI                 0x0408
#define WFCEPRESENT             0x0410  // Client edge present
#define WFBOTTOMMOST            0x0420  // Bottommost window
#define WFFULLSCREEN            0x0440
#define WFINDESTROY             0x0480

//
// DON'T MOVE ANY ONE OF THE FOLLOWING WFWINXXCOMPAT FLAGS,
// BECAUSE WFWINCOMPATMASK DEPENDS ON THEIR VALUES
//
#define WFWIN31COMPAT           0x0501  // Win 3.1 compatible window
#define WFWIN40COMPAT           0x0502  // Win 4.0 compatible window
#define WFWIN50COMPAT           0x0504  // Win 5.0 compatibile window
#define WFWINCOMPATMASK         0x0507  // Compatibility flag mask

#define WFMAXFAKEREGIONAL       0x0508  // Window has a fake region for maxing on 1 monitor

//
// Active Accessibility (Window Event) state
//
#define WFCLOSEBUTTONDOWN       0x0510
#define WFZOOMBUTTONDOWN        0x0520
#define WFREDUCEBUTTONDOWN      0x0540
#define WFHELPBUTTONDOWN        0x0580
#define WFLINEUPBUTTONDOWN      0x0601  // Line up/left scroll button down
#define WFPAGEUPBUTTONDOWN      0x0602  // Page up/left scroll area down
#define WFPAGEDNBUTTONDOWN      0x0604  // Page down/right scroll area down
#define WFLINEDNBUTTONDOWN      0x0608  // Line down/right scroll area down
#define WFSCROLLBUTTONDOWN      0x0610  // Any scroll button down?
#define WFVERTSCROLLTRACK       0x0620  // Vertical or horizontal scroll track...

#define WFALWAYSSENDNCPAINT     0x0640  // Always send WM_NCPAINT to children
#define WFPIXIEHACK             0x0680  // Send (HRGN)1 to WM_NCPAINT (see PixieHack)

//
// WFFULLSCREENBASE MUST HAVE LOWORD OF 0. See SetFullScreen macro.
//
#define WFFULLSCREENBASE        0x0700  // Fullscreen flags take up 0x0701
#define WFFULLSCREENMASK        0x0707  // and 0x0702 and 0x0704
#define WEFTRUNCATEDCAPTION     0x0708  // The caption text was truncated -> caption tootip

#define WFNOANIMATE             0x0710  // ???
#define WFSMQUERYDRAGICON       0x0720  // ??? Small icon comes from WM_QUERYDRAGICON
#define WFSHELLHOOKWND          0x0740  // ???
#define WFISINITIALIZED         0x0780  // Window is initialized -- checked by WoW32

//
// Window Extended Style, from 0x0800 to 0x0B80.
//
#define WEFDLGMODALFRAME        0x0801  // WS_EX_DLGMODALFRAME
#define WEFDRAGOBJECT           0x0802  // ???
#define WEFNOPARENTNOTIFY       0x0804  // WS_EX_NOPARENTNOTIFY
#define WEFTOPMOST              0x0808  // WS_EX_TOPMOST
#define WEFACCEPTFILES          0x0810  // WS_EX_ACCEPTFILES
#define WEFTRANSPARENT          0x0820  // WS_EX_TRANSPARENT
#define WEFMDICHILD             0x0840  // WS_EX_MDICHILD
#define WEFTOOLWINDOW           0x0880  // WS_EX_TOOLWINDOW
#define WEFWINDOWEDGE           0x0901  // WS_EX_WINDOWEDGE
#define WEFCLIENTEDGE           0x0902  // WS_EX_CLIENTEDGE
#define WEFEDGEMASK             0x0903  // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
#define WEFCONTEXTHELP          0x0904  // WS_EX_CONTEXTHELP

//
// intl styles
//
#define WEFRIGHT                0x0910  // WS_EX_RIGHT
#define WEFRTLREADING           0x0920  // WS_EX_RTLREADING
#define WEFLEFTSCROLL           0x0940  // WS_EX_LEFTSCROLLBAR


#define WEFCONTROLPARENT        0x0A01  // WS_EX_CONTROLPARENT
#define WEFSTATICEDGE           0x0A02  // WS_EX_STATICEDGE
#define WEFAPPWINDOW            0x0A04  // WS_EX_APPWINDOW
#define WEFLAYERED              0x0A08  // WS_EX_LAYERED

#ifdef USE_MIRRORING
#define WEFNOINHERITLAYOUT      0x0A10  // WS_EX_NOINHERITLAYOUT
#define WEFLAYOUTVBHRESERVED    0x0A20  // WS_EX_LAYOUTVBHRESERVED
#define WEFLAYOUTRTL            0x0A40  // WS_EX_LAYOUTRTL
#define WEFLAYOUTBTTRESERVED    0x0A80  // WS_EX_LAYOUTBTTRESERVED
#endif

//
// To delay adding a new state3 DWORD in the WW structure, we're using
// the extended style bits for now.  If we'll need more of these, we'll
// add the new DWORD and move these ones around
//
#define WEFPUIFOCUSHIDDEN         0x0B80  // focus indicators hidden
#define WEFPUIACCELHIDDEN         0x0B40  // keyboard acceleraors hidden
#define WEFPREDIRECTED            0x0B20  // redirection bit
#define WEFPCOMPOSITING           0x0B10  // compositing

//
// Window styles, from 0x0E00 to 0x0F80.
//
#define WFMAXBOX                0x0E01  // WS_MAXIMIZEBOX
#define WFTABSTOP               0x0E01  // WS_TABSTOP
#define WFMINBOX                0x0E02  // WS_MAXIMIZEBOX
#define WFGROUP                 0x0E02  // WS_GROUP
#define WFSIZEBOX               0x0E04  // WS_THICKFRAME, WS_SIZEBOX
#define WFSYSMENU               0x0E08  // WS_SYSMENU
#define WFHSCROLL               0x0E10  // WS_HSCROLL
#define WFVSCROLL               0x0E20  // WS_VSCROLL
#define WFDLGFRAME              0x0E40  // WS_DLGFRAME
#define WFTOPLEVEL              0x0E40  // ???
#define WFBORDER                0x0E80  // WS_BORDER
#define WFBORDERMASK            0x0EC0  // WS_BORDER | WS_DLGFRAME
#define WFCAPTION               0x0EC0  // WS_CAPTION

#define WFTILED                 0x0F00  // WS_OVERLAPPED, WS_TILED
#define WFMAXIMIZED             0x0F01  // WS_MAXIMIZE
#define WFCLIPCHILDREN          0x0F02  // WS_CLIPCHILDREN
#define WFCLIPSIBLINGS          0x0F04  // WS_CLIPSIBLINGS
#define WFDISABLED              0x0F08  // WS_DISABLED
#define WFVISIBLE               0x0F10  // WS_VISIBLE
#define WFMINIMIZED             0x0F20  // WS_MINIMIZE
#define WFCHILD                 0x0F40  // WS_CHILD
#define WFPOPUP                 0x0F80  // WS_POPUP
#define WFTYPEMASK              0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONICPOPUP           0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONIC                WFMINIMIZED


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


VOID GetIconSize(HICON hicon, PSIZE psize);
VOID AlterWindowStyle(HWND hwnd, DWORD mask, DWORD flags);
UINT GetACPCharSet();
LONG TestWF(HWND hwnd, DWORD flag);

BOOL DrawFrame(HDC hdc, LPRECT prect, int clFrame, int cmd);    // private export 



__inline BOOL IsEmptyString(PVOID p, ULONG bAnsi)
{
    return (BOOL)!(bAnsi ? *(LPSTR)p : *(LPWSTR)p);
}

__inline DWORD UserGetVersion()
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        return 0;
    }

    return (DWORD)MAKEWORD(osvi.dwMinorVersion, osvi.dwMajorVersion);
}

#ifdef __cplusplus
}
#endif // __cplusplus




#endif // USRCTL32__UsrCtl32_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\updown.c ===
#include "ctlspriv.h"

/////////////////////////////////////////////////////////////////////////////
//
// updown.c : A micro-scrollbar control; useful for increment/decrement.
//
/////////////////////////////////////////////////////////////////////////////

#define NUM_UDACCELS 3

#define DONTCARE    0
#define SIGNED      1
#define UNSIGNED    2

#define UD_HITNOWHERE 0
#define UD_HITDOWN 1
#define UD_HITUP 2

typedef struct {
    CCONTROLINFO ci;
    HWND    hwndBuddy;
    unsigned fUp        : 1;
    unsigned fDown      : 1;
    unsigned fUnsigned  : 1;
    unsigned fSharedBorder  : 1;
    unsigned fSunkenBorder  : 1;
    unsigned fUpDownDestroyed : 1;  // This tells the buddy that updown destoryed.
    BOOL     fTrackSet: 1;
    unsigned fSubclassed:1;     // did we subclass the buddy?

    UINT     nBase;
    int      nUpper;
    int      nLower;
    int      nPos;
    UINT     uClass;
    BOOL     bDown;
    DWORD    dwStart;
    UINT     nAccel;
    UDACCEL  *udAccel;
    UINT     uHot;
    int      cReenterSetint;    // To avoid recursion death in setint()

    HTHEME   hTheme;
    HTHEME   hThemeBuddy;

} UDSTATE, *PUDSTATE;


// Constants:
//
#define CLASS_UNKNOWN   0
#define CLASS_EDIT  1
#define CLASS_LISTBOX   2

#define MAX_INTLENGTH   18 // big enough for all intl stuff, too

// this is the space to the left and right of the arrow (in pixels)
#define XBORDER 0

#define BASE_DECIMAL    10
#define BASE_HEX        16

// Declarations:
//
LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

/////////////////////////////////////////////////////////////////////////////

//
// ***** Internal workhorses *****
//


// Validates the buddy.
//
void isgoodbuddy(PUDSTATE np)
{
    if (!np->hwndBuddy)
        return;
    if (!IsWindow(np->hwndBuddy))
    {
#if defined(DEBUG) && !defined(WIN32)
        DebugOutput(DBF_ERROR | DBF_USER,
                    TEXT("UpDown: invalid buddy handle 0x04X; ")
                    TEXT("resetting to NULL"), np->hwndBuddy);
#endif
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
    if (GetParent(np->hwndBuddy) != np->ci.hwndParent)
    {
#if defined(DEBUG) && !defined(WIN32)
        DebugOutput(DBF_ERROR | DBF_USER,
                    TEXT("UpDown: buddy has different parent; ")
                    TEXT("resetting to NULL"));
#endif
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
}

// Picks a good buddy.
//
void pickbuddy(PUDSTATE np)
{
    if (np->ci.style & UDS_AUTOBUDDY)
        np->hwndBuddy = GetWindow(np->ci.hwnd, GW_HWNDPREV);
}

void unachor(PUDSTATE np)
{
    RECT rc;
    RECT rcBuddy;
    RECT rcUD;

    if ( np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT))) {
        GetWindowRect(np->hwndBuddy, &rcBuddy);
        GetWindowRect(np->ci.hwnd, &rcUD);
        UnionRect(&rc, &rcUD, &rcBuddy);
        MapWindowRect(NULL, np->ci.hwndParent, &rc);
        MoveWindow(np->hwndBuddy, rc.left, rc.top,
                                rc.right - rc.left, rc.bottom - rc.top, FALSE);

    }
}

// Anchor this control to the buddy's edge, if appropriate.
//
void anchor(PUDSTATE np)
{
    BOOL bAlignToBuddy;
    int nOver = 0,  nHasBorder;
    RECT rc, rcBuddy;
    int nHeight, nWidth;

    np->fSharedBorder = FALSE;

    isgoodbuddy(np);
    nHasBorder = (np->ci.style & WS_BORDER) == WS_BORDER;

    bAlignToBuddy = np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT));

    if (bAlignToBuddy)
    {
        if ((np->uClass == CLASS_EDIT) ||
                (GetWindowLong(np->hwndBuddy, GWL_EXSTYLE) & WS_EX_CLIENTEDGE))
        {
            np->fSunkenBorder = TRUE;
        }

        GetWindowRect(np->hwndBuddy, &rc);

        if ((np->uClass == CLASS_EDIT) || (GetWindowLong(np->hwndBuddy, GWL_STYLE) & WS_BORDER))
        {
            // FEATURE: for full generalization, should handle border AND clientedge

            nOver = g_cxBorder * (np->fSunkenBorder ? 2 : 1);
            np->fSharedBorder = TRUE;

            // turn off border styles...
            np->ci.style &= ~WS_BORDER;

            SetWindowLong(np->ci.hwnd, GWL_STYLE, np->ci.style);
            SetWindowLong(np->ci.hwnd, GWL_EXSTYLE, GetWindowLong(np->ci.hwnd, GWL_EXSTYLE) & ~(WS_EX_CLIENTEDGE));
        }
    }
    else
    {
        GetWindowRect(np->ci.hwnd, &rc);
    }

    nHeight = rc.bottom - rc.top;
    nWidth = rc.right - rc.left;

    //
    // If the parent is RTL mirrored, then placement of the
    // child (i.e. anchor point) should be relative to the visual 
    // right edge (near edge). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(np->ci.hwndParent))
    {
        rc.left = rc.right;
    }

    ScreenToClient(np->ci.hwndParent, (LPPOINT)&rc.left);
    rc.right = rc.left + nWidth;

    if (bAlignToBuddy)
    {
        nWidth = g_cxVScroll - g_cxBorder;
        if (nWidth > nHeight) {             // don't let the aspect ratio
            nWidth = nHeight;               // get worse than square
        }
        nWidth += nOver;
        rcBuddy = rc;

        if (np->ci.style & UDS_ALIGNLEFT)
        {
            // size buddy to right
            rcBuddy.left += nWidth - nOver;
            rc.right = rc.left + nWidth;
        }
        else
        {
            // size buddy to left
            rcBuddy.right -= nWidth - nOver;
            rc.left = rc.right - nWidth;
        }
        // size the buddy to fit the updown on the appropriate side
        MoveWindow(np->hwndBuddy, rcBuddy.left, rcBuddy.top,
                                rcBuddy.right - rcBuddy.left, nHeight, TRUE);
    }
    else if (!(np->ci.style & UDS_HORZ))
    {
        nWidth = g_cxVScroll + 2 * nHasBorder;
    }

    SetWindowPos(np->ci.hwnd, NULL, rc.left, rc.top, nWidth, nHeight,
        SWP_DRAWFRAME | SWP_NOZORDER | SWP_NOACTIVATE);
}


// Use this to make any and all comparisons involving the nPos,
// nUpper or nLower fields of the PUDSTATE. It determines
// whether to do a signed or unsigned comparison and returns
//  > 0 for (x > y)
//  < 0 for (x < y)
// == 0 for (x == y).
//
// fCompareType is SIGNED to force a signed comparison,
// fCompareType is UNSIGNED to force an unsigned comparison,
// fCompareType is DONTCARE to use the np->fUnsigned flag to decide.
//
// In comments, comparison operators are suffixed with "D", "U" or "S"
// to emphasize whether the comparison is DONTCARE, UNSIGNED, or SIGNED.
// For example "x <U y" means "x < y as UNSIGNED".

int compare(PUDSTATE np, int x, int y, UINT fCompareType)
{
    if ((fCompareType == UNSIGNED) || ((np->fUnsigned) && !(fCompareType == SIGNED)) )
    {
        // Do unsigned comparisons
        if ((UINT)x > (UINT)y)
            return 1;
        else if ((UINT)x < (UINT)y)
            return -1;
    }
    else
    {
        // Do signed comparisons
        if (x > y)
            return 1;
        else if (x < y)
            return -1;
    }

    return 0;
}

// Use this after any pos change to make sure pos stays in range.
// Wraps as necessary.
// returns nonzero if the current value was out of range (and therefore
// got changed so it fit into range again)
//

BOOL nudge(PUDSTATE np)
{
    BOOL bOutOfRange = TRUE;
    int min = np->nUpper;
    int max = np->nLower;

    // if (max <D min) swap(min, max)
    if (compare(np,max,min, DONTCARE) < 0)
    {
        int t;
        t = min;
        min = max;
        max = t;
    }


    if (np->ci.style & UDS_WRAP)
    {
        // if (nPos <D min) nPos = max      -- wrap from below to above
        // else if (nPos >D max) nPos = min -- wrap from above to below

        if ((compare(np, np->nPos, min, DONTCARE) < 0))
            np->nPos = max;
        else if ((compare(np, np->nPos, max, DONTCARE) > 0))
            np->nPos = min;
        else bOutOfRange = FALSE;
    }
    else
    {
        // if (nPos <D min) nPos = min      -- pin at min
        // else if (nPos >D max) nPos = max -- pin at max

        if (compare(np,np->nPos,min, DONTCARE) < 0)
            np->nPos = min;
        else if (compare(np,np->nPos,max, DONTCARE) > 0)
            np->nPos = max;
        else
            bOutOfRange = FALSE;
    }

    return(bOutOfRange);
}

// Sets the state of the buttons (pushed, released).
//
void squish(PUDSTATE np, UINT bTop, UINT bBottom)
{
    BOOL bInvalidate = FALSE;

    if (np->nUpper == np->nLower || !IsWindowEnabled(np->ci.hwnd))
    {
        bTop = FALSE;
        bBottom = FALSE;
    }
    else
    {
        bTop = !!bTop;
        bBottom = !!bBottom;
    }

    if (np->fUp != bTop)
    {
        np->fUp = bTop;
        bInvalidate = TRUE;

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 1);
    }

    if (np->fDown != bBottom)
    {
        np->fDown = bBottom;
        bInvalidate = TRUE;

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 2);
    }

    if (bInvalidate)
    {
        np->dwStart = GetTickCount();
        InvalidateRect(np->ci.hwnd, NULL, FALSE);
    }
}

// Gets the intl 1000 separator
//
void getthousands(LPTSTR pszThousand)
{
#ifdef WIN32
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pszThousand, 2))
    {
        pszThousand[0] = TEXT(',');
        pszThousand[1] = TEXT('\0');
    }
#else
    static DWORD uLast = 0;
    static TCHAR cThou;
    DWORD uNow;

    /* Only check the intl setting every 5 seconds.
     */
    uNow = GetTickCount();
    if (uNow - uLast > 5000)
    {
        if (!GetProfileString(TEXT("intl"), TEXT("sThousand"), pszThousand, pszThousand, 2))
        {
            pszThousand[0] = TEXT(',');
            pszThousand[1] = TEXT('\0');
        }
        cThou = pszThousand[0];
        uLast = uNow;
    }
    else
    {
        pszThousand[0] = cThou;
        pszThousand[1] = 0;
    }

#endif
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT getgrouping(void)
{
    UINT grouping;
    LPTSTR psz;
    TCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }

    return grouping;
}

// Gets the caption of the buddy
// Returns the current position of the updown control
// and sets *pfError on error.
//
LRESULT getint(PUDSTATE np, BOOL *pfError)
{
    TCHAR szInt[MAX_INTLENGTH]; // big enough for all intl stuff, too
    TCHAR szThousand[2];
    TCHAR cTemp;
    int nPos;
    int sign = 1;
    LPTSTR p = szInt;
    BOOL bInValid = TRUE;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        if (np->uClass == CLASS_LISTBOX)
        {
            np->nPos = (int)SendMessage(np->hwndBuddy, LB_GETCURSEL, 0, 0L);
            bInValid = nudge(np);
        }
        else
        {
            GetWindowText(np->hwndBuddy, szInt, ARRAYSIZE(szInt));

            switch (np->nBase)
            {
                case BASE_HEX:
                    if ((*p == TEXT('x')) || (*p == TEXT('X')))
                        // ignore first character
                        p++;
                    else if ((*p == TEXT('0')) && ((*(p + 1) == TEXT('x')) || (*(p + 1) == TEXT('X'))))
                        // ignore first two characters (TEXT("0x") or "0X")
                        p += 2;

                    for (nPos = 0; *p; p++)
                    {
                        if ((*p >= TEXT('A')) && (*p <= TEXT('F')))
                            cTemp = (TCHAR)(*p - TEXT('A') + 10);
                        else if ((*p >= TEXT('a')) && (*p <= TEXT('f')))
                            cTemp = (TCHAR)(*p - TEXT('a') + 10);
                        else if ((*p >= TEXT('0')) && (*p <= TEXT('9')))
                            cTemp = (TCHAR)(*p - TEXT('0'));
                        else
                            goto BadValue;

                        nPos = (nPos * 16) + cTemp;
                    }
                    np->nPos = nPos;
                    break;

                case BASE_DECIMAL:
        default:
                    getthousands(szThousand);
                    if (*p == TEXT('-') && !np->fUnsigned)
                    {
                        sign = -1;
                        ++p;
                    }

                    for (nPos=0; *p; p++)
                    {
                        cTemp = *p;

                        // If there is a thousand separator, just ignore it.
                        // Do not validate that it's in the right place,
                        // because it prevents the user from editing the
                        // middle of a number.
                        if (cTemp == szThousand[0])
                        {
                            continue;
                        }

                        cTemp -= TEXT('0');
                        if ((UINT)cTemp > 9)
                        {
                            goto BadValue;
                        }
                        nPos = (nPos*10) + cTemp;
                    }

                    np->nPos = nPos*sign;
                    break;
            }
            bInValid = nudge(np);
        }
    }

BadValue:
    if (pfError)
        *pfError = bInValid;
    return np->nPos;
}

// Sets the caption of the buddy if appropriate.
//
void setint(PUDSTATE np)
{
    TCHAR szInt[MAX_INTLENGTH];
    TCHAR szThousand[2];
    int pos = np->nPos;
    LPTSTR p = szInt;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        BOOL fError;
        /*
         * If we have reentered, then maybe the app has set up a loop.
         * Check to see if the value has actually changed.  If not,
         * then there's no need to set it again.  This breaks the
         * recursion.
         */
        if (np->cReenterSetint && (LRESULT)pos==getint(np, &fError) && !fError)
        {
            return;
        }
        np->nPos = pos;

        np->cReenterSetint++;

        if (np->uClass == CLASS_LISTBOX)
        {
            SendMessage(np->hwndBuddy, LB_SETCURSEL, pos, 0L);
            FORWARD_WM_COMMAND(GetParent(np->hwndBuddy),
                                GetDlgCtrlID(np->hwndBuddy),
                np->hwndBuddy, LBN_SELCHANGE, SendMessage);
        }
        else
        {
            switch (np->nBase)
            {
                case BASE_HEX:

                    if ((np->nUpper | np->nLower) >= 0x00010000)
                        wsprintf(p, TEXT("0x%08X"), pos);
                    else
                        wsprintf(p, TEXT("0x%04X"), pos);
                    break;

                case BASE_DECIMAL:
        default:
                    if (pos < 0 && !np->fUnsigned)
                    {
                        *p++ = TEXT('-');
                        pos = -pos;
                    }

                    if (pos >= 1000 && !(np->ci.style & UDS_NOTHOUSANDS))
                    {
                        TCHAR szFmt[MAX_INTLENGTH];
                        NUMBERFMT nf;
                        nf.NumDigits = 0;   // no digits after decimal point
                        nf.LeadingZero = 0; // no leading zeros
                        nf.Grouping = getgrouping();
                        nf.lpDecimalSep = TEXT(""); // no decimal point
                        nf.lpThousandSep = szThousand;
                        nf.NegativeOrder = 0; // (not used - we always pass positive numbers)
                        getthousands(szThousand);
                        wsprintf(szFmt, TEXT("%u"), pos);
                        GetNumberFormat(LOCALE_USER_DEFAULT, 0, szFmt, &nf, p, MAX_INTLENGTH - 1);
                    }
                    else
                    {
                        wsprintf(p, TEXT("%u"), pos);
                    }
                    break;
            }

            SetWindowText(np->hwndBuddy, szInt);
        }

        np->cReenterSetint;
    }
}

// Use this to click the pos up or down by one.
//
void bump(PUDSTATE np)
{
    BOOL bChanged = FALSE;
    UINT uElapsed, increment;
    int direction, i;

    /* So I'm not really getting seconds here; it's close enough, and
     * dividing by 1024 keeps __aFuldiv from being needed.
     */
    uElapsed = (UINT)((GetTickCount() - np->dwStart) / 1024);

    if (np->udAccel != NULL)
    {
        increment = np->udAccel[0].nInc;
        for (i=np->nAccel-1; i>=0; --i)
        {
            if (np->udAccel[i].nSec <= uElapsed)
            {
                increment = np->udAccel[i].nInc;
                break;
            }
        }
    }
    else
    {
        increment = 1;
    }

    if (increment == 0)
    {
        DebugMsg(DM_ERROR, TEXT("bad accelerator value"));
        return;
    }

    direction = compare(np,np->nUpper,np->nLower, DONTCARE) < 0 ? -1 : 1;
    if (np->fUp)
    {
        bChanged = TRUE;
    }
    if (np->fDown)
    {
        direction = -direction;
        bChanged = TRUE;
    }

    if (bChanged)
    {
        /* Make sure we have a multiple of the increment
         * Note that we should loop only when the increment changes
         */
        NM_UPDOWN nm;

        nm.iPos = np->nPos;
        nm.iDelta = increment*direction;
        if (CCSendNotify(&np->ci, UDN_DELTAPOS, &nm.hdr))
            return;

        np->nPos += nm.iDelta;
        for ( ; ; )
        {
            if (!((int)np->nPos % (int)increment))
            {
                break;
            }
            np->nPos += direction;
        }

        nudge(np);
        setint(np);
        if (np->ci.style & UDS_HORZ)
            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);
        else
            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
    }
}

//#pragma data_seg(DATASEG_READONLY)
const TCHAR c_szListbox[] = TEXT("listbox");
//#pragma data_seg()

// Sets the new buddy
//
LRESULT setbuddy(PUDSTATE np, HWND hwndBuddy)
{
    HWND hOldBuddy;
    TCHAR szClName[10];

    hOldBuddy = np->hwndBuddy;

    if (np->hThemeBuddy)
    {
        CloseThemeData(np->hThemeBuddy);
        np->hThemeBuddy = NULL;
    }

    if ((np->hwndBuddy = hwndBuddy) == NULL)
    {
        pickbuddy(np);
        hwndBuddy = np->hwndBuddy;
    }

    if ((hOldBuddy != hwndBuddy) && np->fSubclassed)
    {
        ASSERT(hOldBuddy);
        RemoveWindowSubclass(hOldBuddy, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
    }

    np->uClass = CLASS_UNKNOWN;
    if (hwndBuddy)
    {
        if (np->ci.style & UDS_ARROWKEYS)
        {
            np->fSubclassed = TRUE;
            SetWindowSubclass(hwndBuddy, ArrowKeyProc, 0, (ULONG_PTR)np);
        }

        GetClassName(hwndBuddy, szClName, ARRAYSIZE(szClName));
        if (!lstrcmpi(szClName, c_szEdit))
        {
            np->uClass = CLASS_EDIT;
            np->hThemeBuddy = OpenThemeData(hwndBuddy, WC_EDIT);
        }
        else if (!lstrcmpi(szClName, c_szListbox))
        {
            np->uClass = CLASS_LISTBOX;
        }
    }

    anchor(np);
    return (LRESULT)hOldBuddy;
}


//
// This is how CCThemeDrawEdge should be implemented once DrawThemeLine supports part and 
// state ids
//
//
BOOL UpDown_ThemeDrawEdge(HTHEME hTheme, HDC hdc, PRECT prc, int iPartId, int iStateId, UINT uFlags)
{
    BOOL  fRet = FALSE;
    RECT  rc;
    int   cxBorder, cyBorder;

    if (SUCCEEDED(GetThemeInt(hTheme, iPartId, iStateId, TMT_SIZINGBORDERWIDTH, &cxBorder)))
    {
        cyBorder = cxBorder;
    }
    else
    {
        cxBorder = g_cxBorder;
        cyBorder = g_cyBorder;
    }

    rc = *prc;

    if (uFlags & BF_LEFT)
    {
        rc.left += cxBorder;
    }

    if (uFlags & BF_TOP)
    {
        rc.top += cyBorder;
    }

    if (uFlags & BF_RIGHT)
    {
        rc.right -= cxBorder;
    }

    if (uFlags & BF_BOTTOM)
    {
        rc.bottom -= cyBorder;
    }

    ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

    if (SUCCEEDED(DrawThemeBackground(hTheme, hdc, iPartId, iStateId, prc, 0)))
    {
        fRet = TRUE;

        if (uFlags & BF_ADJUST)
        {
            *prc = rc;
        }
    }

    SelectClipRgn(hdc, NULL);

    return fRet;
}

// Paint the whole control
//

// PaintUpDownControl is theme aware
void PaintUpDownControl(PUDSTATE np, HDC hdc)
{
    UINT uFlags;
    PAINTSTRUCT ps;
    RECT rcBtn;
    RECT rc;

    int iPartId;
    int iStateId;

    BOOL bEnabled = (np->nUpper != np->nLower) && IsWindowEnabled(np->ci.hwnd);

    if (np->hwndBuddy)
        bEnabled = bEnabled && IsWindowEnabled(np->hwndBuddy);

    if (hdc)
        ps.hdc = hdc;
    else
        BeginPaint(np->ci.hwnd, &ps);

    GetClientRect(np->ci.hwnd, &rcBtn);

    // if we are autobuddy'd and anchored to a sunken-edge control, we draw the
    // "nonclient" area of ourselves to blend in with our buddy.
    if (!np->hTheme || (np->hThemeBuddy && (np->uClass == CLASS_EDIT)))
    {
        if (np->fSharedBorder && np->fSunkenBorder)
        {
            UINT bf = BF_TOP | BF_BOTTOM | BF_ADJUST |
                      (np->ci.style & UDS_ALIGNLEFT ? BF_LEFT : 0) |
                      (np->ci.style & UDS_ALIGNRIGHT ? BF_RIGHT : 0);

            if (!np->hThemeBuddy)
            {
                DrawEdge(ps.hdc, &rcBtn, EDGE_SUNKEN, bf);
            }
            else
            {
                UpDown_ThemeDrawEdge(np->hThemeBuddy, 
                                     ps.hdc, 
                                     &rcBtn, 
                                     EP_EDITTEXT, 
                                     bEnabled ? ETS_NORMAL : ETS_DISABLED, 
                                     bf);

            }
        }
    }

    // with remaining space, draw appropriate scrollbar arrow controls in
    // upper and lower halves

    rc = rcBtn;
    if (np->ci.style & UDS_HORZ)
    {
        iPartId = SPNP_DOWNHORZ;  // Down horizontal
        iStateId = DNHZS_NORMAL;

        uFlags = DFCS_SCROLLLEFT;
        if (np->fDown)
        {
            uFlags |= DFCS_PUSHED;

            iStateId = DNHZS_PRESSED;
        }

        if (!bEnabled)
        {
            uFlags |= DFCS_INACTIVE;

            iStateId = DNHZS_DISABLED;
        }
            
        if (np->uHot == UD_HITDOWN)
        {
            uFlags |= DFCS_HOT;

            if (iStateId == DNHZS_NORMAL)
                iStateId = DNHZS_HOT;
        }
        
        // Horizontal ones
        rc.right = (rcBtn.right + rcBtn.left) / 2;

        if (np->hTheme)
        {
            DrawThemeBackground(np->hTheme, ps.hdc, iPartId, iStateId, &rc, 0);
        }
        else
        {
            DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                             uFlags);
        }

        iPartId = SPNP_UPHORZ;  // Up horizontal
        iStateId = UPHZS_NORMAL;

        uFlags = DFCS_SCROLLRIGHT;
        if (np->fUp)
        {
            uFlags |= DFCS_PUSHED;

            iStateId = UPHZS_PRESSED;
        }

        if (!bEnabled)
        {
            uFlags |= DFCS_INACTIVE;

            iStateId = UPHZS_DISABLED;
        }
            
        if (np->uHot == UD_HITUP)
        {
            uFlags |= DFCS_HOT;

            if (iStateId == UPHZS_NORMAL)
                iStateId = UPHZS_HOT;
        }

        rc.left = rcBtn.right - (rc.right - rc.left); // handles odd-x case, too
        rc.right = rcBtn.right;

        if (np->hTheme)
        {
            DrawThemeBackground(np->hTheme, ps.hdc, iPartId, iStateId, &rc, 0);
        }
        else
        {
            DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);
        }
    }
    else
    {
        iPartId = SPNP_UP;  // Up vertical
        iStateId = UPS_NORMAL;

        uFlags = DFCS_SCROLLUP;
        if (np->fUp)
        {
            uFlags |= DFCS_PUSHED;

            iStateId = UPS_PRESSED;
        }

        if (!bEnabled)
        {
            uFlags |= DFCS_INACTIVE;

            iStateId = UPS_DISABLED;
        }
            
        if (np->uHot == UD_HITUP)
        {
            uFlags |= DFCS_HOT;

            if (iStateId == UPS_NORMAL)
                iStateId = UPS_HOT;
        }

        rc.bottom = (rcBtn.bottom + rcBtn.top) / 2;

        if (np->hTheme)
        {
            DrawThemeBackground(np->hTheme, ps.hdc, iPartId, iStateId, &rc, 0);
        }
        else
        {
            DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);
        }

        iPartId = SPNP_DOWN;  // Down vertical
        iStateId = DNS_NORMAL;

        uFlags = DFCS_SCROLLDOWN;
        if (np->fDown)
        {
            uFlags |= DFCS_PUSHED;

            iStateId = DNS_PRESSED;
        }

        if (!bEnabled)
        {
            uFlags |= DFCS_INACTIVE;

            iStateId = DNS_DISABLED;
        }
            
        if (np->uHot == UD_HITDOWN)
        {
            uFlags |= DFCS_HOT;

            if (iStateId == DNS_NORMAL)
                iStateId = DNS_HOT;
        }

        rc.top = rcBtn.bottom - (rc.bottom - rc.top); // handles odd-y case, too
        rc.bottom = rcBtn.bottom;

        if (np->hTheme)
        {
            DrawThemeBackground(np->hTheme, ps.hdc, iPartId, iStateId, &rc, 0);
        }
        else
        {
            DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                             uFlags);
        }
    }

    if (hdc == NULL)
        EndPaint(np->ci.hwnd, &ps);
}


LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    PUDSTATE    np = (PUDSTATE)dwRefData;
    int         cDetants;
    HRGN        hrgnEdit = NULL;
    LRESULT     lResult;

    switch (uMsg)
    {
    case WM_NCDESTROY:
        RemoveWindowSubclass(hWnd, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
        np->hwndBuddy = NULL;
        if (np->fUpDownDestroyed)
        {
            // The buddy was destroyed after updown so free the memory now
            // And pass off to the message to who we subclassed...
            LocalFree((HLOCAL)np);
        }
        break;

    case WM_GETDLGCODE:
        return (DefSubclassProc(hWnd, uMsg, wParam, lParam) | DLGC_WANTARROWS);

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                /* Get the value from the buddy if this is the first key down
                 */
                if (!(lParam&(1L<<30)))
                {
                    getint(np, NULL);
                }

                /* Update the visuals and bump the value
                 */
                np->bDown = (wParam == VK_DOWN);
                squish(np, !np->bDown, np->bDown);
                bump(np);

                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(np->ci), UISF_HIDEFOCUS);
            }
            return(0L);

        default:
            break;
        }
        break;

    case WM_KEYUP:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                squish(np, FALSE, FALSE);
            }
            return(0L);

        default:
            break;
        }
        break;

        // this is dumb.
        // wm_char's aren't sent for arrow commands..
        // what you're really eating here is & and (.
#if 0
    case WM_CHAR:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            return(0L);

        default:
            break;
        }
        break;
#endif

    case WM_KILLFOCUS:
        // Reset wheel scroll amount
        gcWheelDelta = 0;
        break;

    case WM_NCPAINT:
        if (np->hTheme && (np->uClass == CLASS_EDIT))
        {
            RECT rc;
            HRGN hrgnSpin;
            
            //
            // exclude the updown window rect from the edit painting region
            //

            GetWindowRect(np->ci.hwnd, &rc);
            hrgnSpin = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);

            if (hrgnSpin)
            {
                switch (wParam)
                {
                case 0:
                case 1:
                    //
                    // update the entire edit nc area
                    //
                    GetWindowRect(hWnd, &rc);
                    hrgnEdit = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);

                    if (!hrgnEdit)
                    {
                        break;
                    }

                    wParam = (WPARAM)hrgnEdit;

                    // fall through

                default:

                    //
                    // exclude spin rgn from edit rgn
                    //
                    CombineRgn((HRGN)wParam, (HRGN)wParam, hrgnSpin, RGN_DIFF);
                }

                DeleteObject(hrgnSpin);
            }
        }
        break;

    default:
        if ((uMsg == g_msgMSWheel) && (GetCapture() != np->ci.hwnd)) 
        {

            int iWheelDelta = GET_WHEEL_DELTA_WPARAM(wParam);
            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;

            if (cDetants != 0)
            {
                gcWheelDelta %= WHEEL_DELTA;

                if (GET_KEYSTATE_WPARAM(wParam) & (MK_SHIFT | MK_CONTROL))
                {
                    break;
                }

                getint(np, NULL);
                np->bDown = (cDetants > 0);
                cDetants = abs(cDetants);
                while (cDetants-- > 0) 
                {
                    squish(np, !np->bDown, np->bDown);
                    bump(np);
                }
                squish(np, FALSE, FALSE);
            }

            return 1;
        }

        break;
    }

    lResult = DefSubclassProc(hWnd, uMsg, wParam, lParam);

    if (hrgnEdit)
    {
        DeleteObject(hrgnEdit);
    }

    return lResult;
}

UINT setbase(PUDSTATE np, UINT wNewBase)
{
    UINT wOldBase;

    switch (wNewBase)
    {
        case BASE_DECIMAL:
        case BASE_HEX:
            np->fUnsigned = (wNewBase != BASE_DECIMAL);
            wOldBase = np->nBase;
            np->nBase = wNewBase;
            setint(np);
            return wOldBase;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////

HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hwndBuddy, int nUpper, int nLower, int nPos)
{
    HWND hWnd = CreateWindow(s_szUpdownClass, NULL, dwStyle, x, y, cx, cy,
                             hParent, IntToPtr_(HMENU, nID), hInst, 0L);
    if (hWnd)
    {
        SendMessage(hWnd, UDM_SETBUDDY, (WPARAM)hwndBuddy, 0L);
        SendMessage(hWnd, UDM_SETRANGE, 0, MAKELONG(nUpper, nLower));
        SendMessage(hWnd, UDM_SETPOS, 0, MAKELONG(nPos, 0));
    }
    return hWnd;
}

UINT UD_HitTest(PUDSTATE np, int x, int y)
{
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        // Horizontal placement
        if (x < (rc.right / 2))
        {
            return UD_HITDOWN;
        }
        else if (x > (rc.right / 2))
        {
            return UD_HITUP;
        }
    }
    else
    {
        if (y > (rc.bottom / 2))
        {
            return UD_HITDOWN;
        }
        else if (y < (rc.bottom / 2))
        {
            return UD_HITUP;
        }
    }

    return UD_HITNOWHERE;
}

void UD_Invalidate(PUDSTATE np, UINT uWhich, BOOL fErase)
{
    int iMid;
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        iMid = rc.right / 2;
        if (uWhich == UD_HITDOWN) {
            rc.right = iMid;
        } else if (uWhich == UD_HITUP) {
            rc.left = iMid;
        } else
            return;
    }
    else
    {
        iMid = rc.bottom /2;
        if (uWhich == UD_HITDOWN) {
            rc.top = iMid;
        } else if (uWhich == UD_HITUP){
            rc.bottom = iMid;
        } else
            return;
    }

    InvalidateRect(np->ci.hwnd, &rc, fErase);
}

void UD_OnMouseMove(PUDSTATE np, DWORD dwPos)
{
    if (np->ci.style & UDS_HOTTRACK) {

        UINT uHot = UD_HitTest(np, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));

        if (uHot != np->uHot) {
            UD_Invalidate(np, np->uHot, FALSE);
            UD_Invalidate(np, uHot, FALSE);
            np->uHot = uHot;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

// UpDownWndProc:
//

// UpDownWndProc is theme aware
LRESULT CALLBACK UpDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    int i;
    BOOL f;
    LRESULT lres;
    PUDSTATE np = GetWindowPtr(hwnd, 0);

    if (np) {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (np->ci.style & UDS_HOTTRACK) && !np->fTrackSet) {

            TRACKMOUSEEVENT tme;

            np->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = np->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
        else if (uMsg == WM_THEMECHANGED)  // Check for theme changes
        {
            if (np->hTheme)
                CloseThemeData(np->hTheme);

            np->hTheme = OpenThemeData(np->ci.hwnd, L"Spin");

            if (np->hTheme)
            {
                // Ensure style is applied
                np->ci.style |= UDS_HOTTRACK;
            }

            if (np->hThemeBuddy)
            {
                CloseThemeData(np->hThemeBuddy);
                np->hThemeBuddy = NULL;
            }

            if (np->hwndBuddy && (np->uClass == CLASS_EDIT))
            {
                np->hThemeBuddy = OpenThemeData(np->hwndBuddy, WC_EDIT);
            }

            InvalidateRect(np->ci.hwnd, NULL, TRUE);
        }

    } else if (uMsg != WM_CREATE)
        goto DoDefault;

    switch (uMsg)
    {

    case WM_MOUSEMOVE:
        UD_OnMouseMove(np, (DWORD) lParam);
        break;

    case WM_MOUSELEAVE:
        np->fTrackSet = FALSE;
        UD_Invalidate(np, np->uHot, FALSE);
        np->uHot = UD_HITNOWHERE;
        break;

    case WM_LBUTTONDOWN:
    {
        // Don't set a timer if on the middle border
        BOOL bTimeIt = TRUE;

        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        SetCapture(hwnd);
        getint(np, NULL);

        switch (np->uClass)
        {
        case CLASS_EDIT:
        case CLASS_LISTBOX:
            SetFocus(np->hwndBuddy);
            break;
        }

        switch(UD_HitTest(np, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))) {
        case UD_HITDOWN:
            np->bDown = TRUE;
            squish(np, FALSE, TRUE);
            break;

        case UD_HITUP:
            np->bDown = FALSE;
            squish(np, TRUE, FALSE);
            break;

        case UD_HITNOWHERE:
            bTimeIt = FALSE;
            break;
        }

        if (bTimeIt)
        {
            SetTimer(hwnd, 1, GetProfileInt(TEXT("windows"), TEXT("CursorBlinkRate"), 530), NULL);
            bump(np);
        }
        break;
    }

    case WM_TIMER:
    {
        POINT pt;

        if (GetCapture() != hwnd)
        {
            goto EndScroll;
        }

        SetTimer(hwnd, 1, 100, NULL);

        GetWindowRect(hwnd, &rc);
        if (np->ci.style & UDS_HORZ) {
            i = (rc.left + rc.right) / 2;
            if (np->bDown)
            {
                rc.right = i;
            }
            else
            {
                rc.left = i;
            }
        } else {
            i = (rc.top + rc.bottom) / 2;
            if (np->bDown)
            {
                rc.top = i;
            }
            else
            {
                rc.bottom = i;
            }
        }
        InflateRect(&rc, (g_cxFrame+1)/2, (g_cyFrame+1)/2);
        GetCursorPos(&pt);
        if (PtInRect(&rc, pt))
        {
            squish(np, !np->bDown, np->bDown);
            bump(np);
        }
        else
        {
            squish(np, FALSE, FALSE);
        }
        break;
    }

    case WM_LBUTTONUP:
        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        if (GetCapture() == hwnd)
        {
EndScroll:
            squish(np, FALSE, FALSE);
            // We cannot call CCReleaseCapture() here, because it busts a lot of apps.
            ReleaseCapture();
            KillTimer(hwnd, 1);

            if (np->uClass == CLASS_EDIT)
                Edit_SetSel(np->hwndBuddy, 0, -1);

                        if (np->ci.style & UDS_HORZ)
                            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
                        else
                            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
        }
        break;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WININICHANGE:
        if (np && (!wParam ||
            (wParam == SPI_SETNONCLIENTMETRICS) ||
            (wParam == SPI_SETICONTITLELOGFONT))) {
            InitGlobalMetrics(wParam);
            unachor(np);
            anchor(np);
        }
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        PaintUpDownControl(np, (HDC)wParam);
        break;

    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(np->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;

    case UDM_SETRANGE:
        np->nUpper = GET_X_LPARAM(lParam);
        np->nLower = GET_Y_LPARAM(lParam);
        nudge(np);
        break;
        
    case UDM_SETRANGE32:
        np->nUpper = (int)lParam;
        np->nLower = (int)wParam;
        break;
        
    case UDM_GETRANGE32:
        if (lParam) {
            *((LPINT)lParam) = np->nUpper;
        }
        if (wParam) {
            *((LPINT)wParam) = np->nLower;
        }
        break;
        
    case UDM_GETRANGE:
        return MAKELONG(np->nUpper, np->nLower);

    case UDM_SETBASE:
        // wParam: new base
        // lParam: not used
        // return: 0 if invalid base is specified,
        //         previous base otherwise
        return (LRESULT)setbase(np, (UINT)wParam);

    case UDM_GETBASE:
        return np->nBase;

    case UDM_SETPOS:
        lParam = GET_X_LPARAM(lParam);
        // FALL THROUGH

    case UDM_SETPOS32:
    {
        int iNewPos = (int)lParam;
        if (compare(np, np->nLower, np->nUpper, DONTCARE) < 0) {

            if (compare(np, iNewPos, np->nUpper, DONTCARE) > 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) < 0) {
                iNewPos = np->nLower;
            }
        } else {
            if (compare(np, iNewPos, np->nUpper, DONTCARE) < 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) > 0) {
                iNewPos = np->nLower;
            }
        }

        i = np->nPos;
        np->nPos = iNewPos;
        setint(np);
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
        return (LRESULT)i;
    }

    case UDM_GETPOS:
        lres = getint(np, &f);
        return MAKELRESULT(lres, f);

    case UDM_GETPOS32:
        return getint(np, (BOOL *)lParam);

    case UDM_SETBUDDY:
        return setbuddy(np, (HWND)wParam);

    case UDM_GETBUDDY:
        return (LRESULT)np->hwndBuddy;

    case UDM_SETACCEL:
        if (wParam == 0)
        {
            return FALSE;
        }

        if (wParam >= NUM_UDACCELS)
        {
            UDACCEL *puda;
            puda = (UDACCEL *)LocalReAlloc((HLOCAL)np->udAccel, sizeof(UDACCEL)*wParam, LMEM_MOVEABLE);
            if (!puda)
            {
                return FALSE;
            }
            else
            {
                np->udAccel = puda;
            }
        }

        if (np->udAccel != NULL)
        {
            np->nAccel = (UINT)wParam;

            for (i = 0; i < (int)wParam; i++)
            {
                np->udAccel[i] = ((LPUDACCEL)lParam)[i];
            }
        }

        return TRUE;

    case UDM_GETACCEL:
        if (wParam > np->nAccel)
        {
            wParam = np->nAccel;
        }

        if (np->udAccel)
        {
            for (i=0; i<(int)wParam; ++i)
            {
                ((LPUDACCEL)lParam)[i] = np->udAccel[i];
            }
        }

        return np->nAccel;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&np->ci, lParam);

    case WM_CREATE:
        // Allocate the instance data space.
        np = (PUDSTATE)LocalAlloc(LPTR, sizeof(UDSTATE));
        if (!np)
            return -1;

        SetWindowPtr(hwnd, 0, np);

        #define lpCreate ((CREATESTRUCT *)lParam)
        CIInitialize(&np->ci, hwnd, lpCreate);

        np->hTheme = OpenThemeData(np->ci.hwnd, L"Spin");

        // np->fUp =
        // np->fDown =
            // np->fUnsigned =
            // np->fSharedBorder =
            // np->fSunkenBorder =
        //  FALSE;

        if (lpCreate->style & UDS_UNSIGNED)
            np->fUnsigned = TRUE;

        if (lpCreate->dwExStyle & WS_EX_CLIENTEDGE)
            np->fSunkenBorder = TRUE;

        np->nBase = BASE_DECIMAL;
        np->nUpper = 0;
        np->nLower = 100;
        np->nPos = 0;
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
        ASSERT(np->cReenterSetint == 0);

        np->udAccel = (UDACCEL *)LocalAlloc(LPTR, sizeof(UDACCEL) * NUM_UDACCELS);
        if (np->udAccel)
        {
            np->nAccel = NUM_UDACCELS;

            np->udAccel[0].nSec = 0;
            np->udAccel[0].nInc = 1;

            np->udAccel[1].nSec = 2;
            np->udAccel[1].nInc = 5;

            np->udAccel[2].nSec = 5;
            np->udAccel[2].nInc = 20;
        }
        else
        {
            np->nAccel = 0;
        }

        /* This does the pickbuddy and anchor
         */
        setbuddy(np, NULL);
        setint(np);

        // Automatically enable hot tracking if themes are being used
        if (np->hTheme)
            np->ci.style |= UDS_HOTTRACK;

        break;

    case WM_DESTROY:
        if (np) 
        {

            if (np->hTheme)
            {
                CloseThemeData(np->hTheme);
                np->hTheme = NULL;
            }

            if (np->hThemeBuddy)
            {
                CloseThemeData(np->hThemeBuddy);
                np->hThemeBuddy = NULL;
            }

            if (np->udAccel)
            {
                LocalFree((HLOCAL)np->udAccel);
            }

            if (np->hwndBuddy)
            {
                //  Our buddy needs to be unsubclassed, which we'll do
                //  in response to WM_NCDESTROY;  doing so now would 
                //  bust any subsequent call to the suclass proc.
                DebugMsg(DM_TRACE, TEXT("UpDown Destroyed while buddy subclassed"));
                np->fUpDownDestroyed = TRUE;
            }
            else
            {
                LocalFree((HLOCAL)np);
            }

            SetWindowPtr(hwnd, 0, 0);
        }

        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_UPDOWN;
        goto DoDefault;

    default:
    {
        if (CCWndProc(&np->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/////////////////////////////////////////////////////////////////////////////

// InitUpDownClass:
// Adds our WNDCLASS to the system.
//
#pragma code_seg(CODESEG_INIT)

BOOL InitUpDownClass(HINSTANCE hInst)
{
    WNDCLASS wndclass;

    wndclass.lpfnWndProc    = UpDownWndProc;
    wndclass.lpszClassName  = s_szUpdownClass;
    wndclass.hInstance  = hInst;
    wndclass.hCursor    = LoadCursor(NULL, IDC_ARROW);
    wndclass.hIcon      = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.style      = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = sizeof(PUDSTATE);

    if (!RegisterClass(&wndclass) && !GetClassInfo(hInst, s_szUpdownClass, &wndclass))
        return FALSE;
    return TRUE;
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\wow6432\makefile.inc ===
!include "..\makefile.inc"

#
# The regular 32bit comctl32.dll and the 32bit-on-64bit comctl32.dll tend to get
# linked at the same time, so their .pdb signatures, ages, and names are identical.
# To fix this, we uniquize the .pdb name further.
#
# We follow the cryptic but terse precedent of the other wow6432 binaries and just
# prepend "w" to the name.
#
!if !defined(SXS_WOW6432_W_PREFIX)
TARGETPDB=w$(TARGETPDB)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\usrctl32.c ===
// UsrCtl32.cpp : Defines the entry point for the DLL application.
//

#include "ctlspriv.h"
#pragma hdrstop
#include "UsrCtl32.h"

#define AWS_MASK (BS_TYPEMASK | BS_RIGHT | BS_RIGHTBUTTON | \
        WS_HSCROLL | WS_VSCROLL | SS_TYPEMASK)

VOID AlterWindowStyle(HWND hwnd, DWORD mask, DWORD flags)
{
    ULONG ulStyle;

    if (mask & ~AWS_MASK) 
    {
        TraceMsg(TF_STANDARD, "AlterWindowStyle: bad mask %x", mask);
        return;
    }

    ulStyle = GetWindowStyle(hwnd);
    mask &= AWS_MASK;
    ulStyle = (ulStyle & (~mask)) | (flags & mask);

    SetWindowLong(hwnd, GWL_STYLE, ulStyle);
}


LONG TestWF(HWND hwnd, DWORD flag)
{
    LPDWORD pdwWW;

    // GWLP_WOWWORDS returns a pointer to the WW struct in the hwnd.
    // We're interest in the first four DWORDS: state, state2, 
    // ExStyle (exposed, although not all bits, by GetWindowExStyle),
    // and style (exposed by GetWindowStyle). 
    //
    // The parameter flag, contains information on how to pick the field 
    // we want and how to build the WS_xxx or WS_EX_xxx we want to 
    // check for. 
    // 
    // See UsrCtl32.h for more details on how this is done. 
    //
    pdwWW = (LPDWORD)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if ( pdwWW )
    {
        INT  iField;     // the field we want
        INT  iShift;     // how many bytes to shift flag
        LONG ulMask;     // WS_xxx or WS_EX_xxx flag 

        iField = ( HIBYTE(flag) & 0xFC ) >> 2;
        iShift = HIBYTE(flag) & 0x03;
        ulMask = LOBYTE(flag) << (iShift << 3);

        ASSERT( 0 <= iField && iField < 4 );
        return pdwWW[iField] & ulMask;
    };

    return 0;

}

UINT GetACPCharSet()
{
    static UINT charset = (UINT)~0;
    CHARSETINFO csInfo;

    if (charset != (UINT)~0) {
        return charset;
    }

    // Sundown: In the TCI_SRCCODEPAGE case, the GetACP() return value is zero-extended.
    if (!TranslateCharsetInfo((DWORD*)UIntToPtr( GetACP() ), &csInfo, TCI_SRCCODEPAGE)) {
        return DEFAULT_CHARSET;
    }
    charset = csInfo.ciCharset;
    UserAssert(charset != (UINT)~0);
    return csInfo.ciCharset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\win95\i386\cctl1632.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Tue Jul 09 16:59:49 1996

;Command Line: ..\..\..\dev\tools\binr\thunk.exe -NC _TEXT -o Cctl1632 ..\Cctl1632.thk 

	TITLE	$Cctl1632.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_Cctl1632TargetTable	;Flat address of target table in 16-bit module.

public FT_Cctl1632Checksum32
FT_Cctl1632Checksum32	dd	01e9ah


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

; The next two symbols must be exported so BBT knows not to optimize
; them.  (We tag them as KeepTogetherRange in the BBT config file.)

public Cctl1632_ThunkData32	;This symbol must be exported.
public FT_Prolog_Cctl1632

Cctl1632_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	01e9ah	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_Cctl1632 - offset Cctl1632_ThunkData32
	dd	offset FT_Prolog_Cctl1632 - offset Cctl1632_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public Cctl1632_ThunkConnect32@16
Cctl1632_ThunkConnect32@16:
	pop	edx
	push	offset Cctl1632_ThkData16
	push	offset Cctl1632_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
Cctl1632_ThkData16 label byte
	db	"Cctl1632_ThunkData16",0


		


pfnQT_Thunk_Cctl1632	dd offset QT_Thunk_Cctl1632
pfnFT_Prolog_Cctl1632	dd offset FT_Prolog_Cctl1632
	.data
QT_Thunk_Cctl1632 label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_Cctl1632 label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include Cctl1632.inc



;************************ START OF THUNK BODIES************************




;
public DestroyPropertySheetPage16@4
DestroyPropertySheetPage16@4:
	FAPILOG16	35
	mov	cl,2
; DestroyPropertySheetPage(16) = DestroyPropertySheetPage16(32) {}
;
; dword ptr [ebp+8]:  hpage
;
public IIDestroyPropertySheetPage16@4
IIDestroyPropertySheetPage16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;hpage: dword->dword
	call	dword ptr [pfnQT_Thunk_Cctl1632]
	cwde
	leave
	retn	4





;
public CreatePage16@8
CreatePage16@8:
	FAPILOG16	18
	mov	cl,1
; CreatePage(16) = CreatePage16(32) {}
;
; dword ptr [ebp+8]:  hpage
; dword ptr [ebp+12]:  hwndParent
;
public IICreatePage16@8
IICreatePage16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;hpage: dword->dword
	push	word ptr [ebp+12]	;hwndParent: dword->word
	call	dword ptr [pfnQT_Thunk_Cctl1632]
	movzx	eax,ax
	leave
	retn	8






;
public GetPageInfoME@24
GetPageInfoME@24:
	FAPILOG16	0
	mov	cx, (6 SHL 10) + (0 SHL 8) + 0
; GetPageInfo(16) = GetPageInfoME(32) {}
;
; dword ptr [ebp+8]:  hpage
; dword ptr [ebp+12]:  pszCaption
; dword ptr [ebp+16]:  cbCaption
; dword ptr [ebp+20]:  ppt
; dword ptr [ebp+24]:  phIcon
; dword ptr [ebp+28]:  pb
;
public IIGetPageInfoME@24
IIGetPageInfoME@24:
	call	dword ptr [pfnFT_Prolog_Cctl1632]
	xor	eax,eax
	push	eax
	push	eax
	sub	esp,4
	mov	esi,[ebp+20]
	or	esi,esi
	jz	@F
	or	byte ptr [esi], 0
	or	byte ptr [esi + 7], 0
@@:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	mov	edx, dword ptr [ebp+28]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	push	dword ptr [ebp+8]	;hpage: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	word ptr [ebp+16]	;cbCaption: dword->word
	mov	esi,[ebp+20]
	or	esi,esi
	jnz	M0
	push	esi
	jmp	M1
M0:
	lea	edi,[ebp-76]
	push	edi	;ppt: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],010h	;Set flag to fixup ESP-rel argument.
M1:
	mov	eax, dword ptr [ebp+24]
	call	SMapLS
	mov	[ebp-68],edx
	push	eax
	mov	eax, dword ptr [ebp+28]
	call	SMapLS
	mov	[ebp-72],edx
	push	eax
	call	FT_Thunk
	movsx	ebx,ax
	call	SUnMapLS_IP_EBP_12
	mov	edi,[ebp+20]
	or	edi,edi
	jz	M2
	lea	esi,[ebp-76]	;ppt  Struct16->Struct32
	lodsw
	cwde
	stosd
	lodsw
	cwde
	stosd
M2:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	M3
	mov	word ptr [edx+2], 0
M3:
	mov	ecx, dword ptr [ebp-68]
	call	SUnMapLS
	mov	edx, dword ptr [ebp+28]
	or	edx,edx
	jz	M4
	mov	word ptr [edx+2], 0
M4:
	mov	ecx, dword ptr [ebp-72]
	call	SUnMapLS
	jmp	FT_Exit24




;
public GetPageInfo16@20
GetPageInfo16@20:
	FAPILOG16	0
	mov	cx, (5 SHL 10) + (0 SHL 8) + 0
; GetPageInfo(16) = GetPageInfo16(32) {}
;
; dword ptr [ebp+8]:  hpage
; dword ptr [ebp+12]:  pszCaption
; dword ptr [ebp+16]:  cbCaption
; dword ptr [ebp+20]:  ppt
; dword ptr [ebp+24]:  phIcon
;
public IIGetPageInfo16@20
IIGetPageInfo16@20:
	call	dword ptr [pfnFT_Prolog_Cctl1632]
	xor	eax,eax
	push	eax
	sub	esp,4
	mov	esi,[ebp+20]
	or	esi,esi
	jz	@F
	or	byte ptr [esi], 0
	or	byte ptr [esi + 7], 0
@@:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	push	dword ptr [ebp+8]	;hpage: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	word ptr [ebp+16]	;cbCaption: dword->word
	mov	esi,[ebp+20]
	or	esi,esi
	jnz	L0
	push	esi
	jmp	L1
L0:
	lea	edi,[ebp-72]
	push	edi	;ppt: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],04h	;Set flag to fixup ESP-rel argument.
L1:
	mov	eax, dword ptr [ebp+24]
	call	SMapLS
	mov	[ebp-68],edx
	push	eax
	call	FT_Thunk
	movsx	ebx,ax
	call	SUnMapLS_IP_EBP_12
	mov	edi,[ebp+20]
	or	edi,edi
	jz	L2
	lea	esi,[ebp-72]	;ppt  Struct16->Struct32
	lodsw
	cwde
	stosd
	lodsw
	cwde
	stosd
L2:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	L3
	mov	word ptr [edx+2], 0
L3:
	mov	ecx, dword ptr [ebp-68]
	call	SUnMapLS
	jmp	FT_Exit20




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] GetPageInfo16',0
	db	'[F] CreatePage16',0
	db	'[F] DestroyPropertySheetPage16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef GetPageInfo:far16
externDef CreatePage:far16
externDef DestroyPropertySheetPage:far16


FT_Cctl1632TargetTable label word
	dw	offset GetPageInfo
	dw	   seg GetPageInfo
	dw	offset CreatePage
	dw	   seg CreatePage
	dw	offset DestroyPropertySheetPage
	dw	   seg DestroyPropertySheetPage




	.data

public Cctl1632_ThunkData16	;This symbol must be exported.
Cctl1632_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	01e9ah	;Checksum
	dw	offset FT_Cctl1632TargetTable
	dw	seg    FT_Cctl1632TargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public Cctl1632_ThunkConnect16
Cctl1632_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    Cctl1632_ThunkData16
	push	offset Cctl1632_ThunkData16
	push	seg    Cctl1632_ThkData32
	push	offset Cctl1632_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
Cctl1632_ThkData32 label byte
	db	"Cctl1632_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\color.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color.h

Abstract:

    This module contains the header information for the Win32 color dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <colordlg.h>
#include <help.h>




//
//  Constant Declarations.
//

#define COLORBOXES           64
#define NUM_X_BOXES          8
#define BOX_X_MARGIN         5
#define BOX_Y_MARGIN         5
//
//  Range of values for HLS scrollbars.
//  HLS-RGB conversions work best when RANGE is divisible by 6.
//
#define RANGE                240

#define HLSMAX               RANGE
#define RGBMAX               255

#define HUEINC               4
#define SATINC               8
#define LUMINC               8


//
//  This used to be in wingdi.h, but recently moved to wingdip.h
//  Including wingdip.h causes too many compiler errors, so define
//  the one constant we need here.
//
#define HS_DITHEREDTEXTCLR   9

#define COLORPROP  (LPCTSTR) 0xA000L




//
//  Typedef Declarations.
//

typedef struct {
    UINT           ApiType;
    LPCHOOSECOLOR  pCC;
    HANDLE         hLocal;
    HANDLE         hDialog;
    HPALETTE       hPal;
    DWORD          currentRGB;
    WORD           currentHue;
    WORD           currentSat;
    WORD           currentLum;
    WORD           nHueWidth;
    WORD           nSatHeight;
    WORD           nLumHeight;
    WORD           nCurMix;
    WORD           nCurDsp;
    WORD           nCurBox;
    WORD           nHuePos;
    WORD           nSatPos;
    WORD           nLumPos;
    RECT           rOriginal;
    RECT           rRainbow;
    RECT           rLumScroll;
    RECT           rLumPaint;
    RECT           rCurrentColor;
    RECT           rNearestPure;
    RECT           rColorSamples;
    BOOL           bFoldOut;
    DWORD          rgbBoxColor[COLORBOXES];
#ifdef UNICODE
    LPCHOOSECOLORA pCCA;
#endif
} COLORINFO;

typedef COLORINFO *PCOLORINFO;

#define LPDIS LPDRAWITEMSTRUCT




//
//  Extern Declarations.
//

extern HDC hDCFastBlt;
extern DWORD rgbClient;
extern WORD gHue,gSat,gLum;
extern HBITMAP hRainbowBitmap;
extern BOOL bMouseCapture;
extern WNDPROC lpprocStatic;
extern SHORT nDriverColors;
extern DWORD rgbBoxColor[COLORBOXES];

extern TCHAR szOEMBIN[];

extern RECT rColorBox[COLORBOXES];
extern SHORT nBoxHeight, nBoxWidth;
extern HWND hSave;
extern WNDPROC qfnColorDlg;




//
//  Context Help IDs.
//

const static DWORD aColorHelpIDs[] =             // Context Help IDs
{
    COLOR_BOX1,        IDH_COLOR_BASIC,
    COLOR_CUSTOM1,     IDH_COLOR_CUSTOM_CUSTOM,
    COLOR_MIX,         IDH_COLOR_DEFINE,
    COLOR_RAINBOW,     IDH_COLOR_SAMPLE_COLOR,
    COLOR_LUMSCROLL,   IDH_COLOR_SAMPLE_SCROLL,
    COLOR_CURRENT,     IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID,       IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID_LEFT,  IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID_RIGHT, IDH_COLOR_COLOR_SOLID,
    COLOR_HUEACCEL,    IDH_COLOR_HUE,
    COLOR_HUE,         IDH_COLOR_HUE,
    COLOR_SATACCEL,    IDH_COLOR_SAT,
    COLOR_SAT,         IDH_COLOR_SAT,
    COLOR_LUMACCEL,    IDH_COLOR_LUM,
    COLOR_LUM,         IDH_COLOR_LUM,
    COLOR_REDACCEL,    IDH_COLOR_RED,
    COLOR_RED,         IDH_COLOR_RED,
    COLOR_GREENACCEL,  IDH_COLOR_GREEN,
    COLOR_GREEN,       IDH_COLOR_GREEN,
    COLOR_BLUEACCEL,   IDH_COLOR_BLUE,
    COLOR_BLUE,        IDH_COLOR_BLUE,
    COLOR_ADD,         IDH_COLOR_ADD,

    0, 0
};




//
// Function Prototypes.
//

//
//  color.c
//
BOOL
ChooseColorX(
    PCOLORINFO pCI);

BOOL_PTR CALLBACK
ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL
ChangeColorBox(
    register PCOLORINFO pCI,
    DWORD dwRGBcolor);

VOID
HiLiteBox(
    HDC hDC,
    SHORT nBox,
    SHORT fStyle);

VOID
ChangeBoxSelection(
    PCOLORINFO pCI,
    SHORT nNewBox);

VOID
ChangeBoxFocus(
    PCOLORINFO pCI,
    SHORT nNewBox);

BOOL
ColorKeyDown(
    WPARAM wParam,
    int *id,
    PCOLORINFO pCI,
    BOOL bRTL);

VOID
PaintBox(
    PCOLORINFO pCI,
    register HDC hDC,
    SHORT i);

BOOL
InitScreenCoords(
    HWND hDlg,
    PCOLORINFO pCI);

VOID
SetupRainbowCapture(
    PCOLORINFO pCI);

BOOL_PTR
InitColor(
    HWND hDlg,
    WPARAM wParam,
    PCOLORINFO pCI);

VOID
ColorPaint(
    HWND hDlg,
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect);

LONG WINAPI
WantArrows(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

DWORD
MapColor(
    PCOLORINFO pCI,
    DWORD rgb);

VOID
TermColor();


#ifdef UNICODE
  VOID
  ThunkChooseColorA2W(
      PCOLORINFO pCI);

  VOID
  ThunkChooseColorW2A(
      PCOLORINFO pCI);
#endif


//
//  color2.c
//
VOID
ChangeColorSettings(
    register PCOLORINFO pCI);

VOID
LumArrowPaint(
    HDC hDC,
    SHORT y,
    PCOLORINFO pCI);

VOID
EraseLumArrow(
    HDC hDC,
    PCOLORINFO pCI);

VOID
EraseCrossHair(
    HDC hDC,
    PCOLORINFO pCI);

VOID
CrossHairPaint(
    register HDC hDC,
    SHORT x,
    SHORT y,
    PCOLORINFO pCI);

VOID
NearestSolid(
    register PCOLORINFO pCI);

VOID
HLSPostoHLS(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
HLStoHLSPos(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
SetHLSEdit(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
SetRGBEdit(
    SHORT nRGBEdit,
    PCOLORINFO pCI);

BOOL
InitRainbow(
    register PCOLORINFO pCI);

VOID
PaintRainbow(
    HDC hDC,
    LPRECT lpRect,
    register PCOLORINFO pCI);

void
RainbowPaint(
    register PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect);

VOID
RGBtoHLS(
    DWORD lRGBColor);

WORD
HueToRGB(
    WORD n1,
    WORD n2,
    WORD hue);

DWORD
HLStoRGB(
    WORD hue,
    WORD lum,
    WORD sat);

SHORT
RGBEditChange(
    SHORT nDlgID,
    PCOLORINFO pCI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\color2.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color2.c

Abstract:

    This module implements the support for the Win32 color dialog.

Revision History:

--*/



// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "color.h"

// from pwin32.h
#define MMoveTo(hdc, x, y)        MoveToEx(hdc, x, y, NULL)





////////////////////////////////////////////////////////////////////////////
//
//  ChangeColorSettings
//
//  Updates color shown.
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeColorSettings(
    register PCOLORINFO pCI)
{
    register HDC hDC;
    HWND hDlg = pCI->hDialog;
    DWORD dwRGBcolor = pCI->currentRGB;

    RGBtoHLS(dwRGBcolor);
    if (gLum != pCI->currentLum)
    {
        hDC = GetDC(hDlg);
        EraseLumArrow(hDC, pCI);
        pCI->currentLum = gLum;
        HLStoHLSPos(COLOR_LUM, pCI);
        LumArrowPaint(hDC, pCI->nLumPos, pCI);
        ReleaseDC(hDlg, hDC);
    }
    if ((gHue != pCI->currentHue) || (gSat != pCI->currentSat))
    {
        pCI->currentHue = gHue;
        pCI->currentSat = gSat;
        InvalidateRect(hDlg, (LPRECT)&pCI->rLumPaint, FALSE);
        hDC = GetDC(hDlg);
        EraseCrossHair(hDC, pCI);
        HLStoHLSPos(COLOR_HUE, pCI);
        HLStoHLSPos(COLOR_SAT, pCI);
        CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
        ReleaseDC(hDlg, hDC);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LumArrowPaint
//
////////////////////////////////////////////////////////////////////////////

VOID LumArrowPaint(
    HDC hDC,
    SHORT y,
    PCOLORINFO pCI)
{
    HBRUSH hBrush;
    int x, h;

    hBrush = SelectObject(hDC, GetSysColorBrush(COLOR_BTNTEXT));

    for (x = pCI->rLumScroll.left + 2, h = 1;
         x < pCI->rLumScroll.right - 2;
         x++, h += 2)
    {
        PatBlt(hDC, x, y - h / 2, 1, h, PATCOPY);
    }

    SelectObject(hDC, hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  EraseLumArrow
//
////////////////////////////////////////////////////////////////////////////

VOID EraseLumArrow(
    HDC hDC,
    PCOLORINFO pCI)
{
    HBRUSH hBrush;
    RECT Rect;

    hBrush = (HBRUSH)SendMessage( pCI->hDialog,
                                  WM_CTLCOLORDLG,
                                  (WPARAM)hDC,
                                  (LPARAM)pCI->hDialog );

    Rect.left   = pCI->rLumScroll.left + 1;
    Rect.right  = pCI->rLumScroll.right;
    Rect.top    = pCI->nLumPos - (pCI->rLumScroll.right - pCI->rLumScroll.left);
    Rect.bottom = pCI->nLumPos + (pCI->rLumScroll.right - pCI->rLumScroll.left) + 1;

    FillRect(hDC, &Rect, hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  EraseCrossHair
//
////////////////////////////////////////////////////////////////////////////

VOID EraseCrossHair(
    HDC hDC,
    PCOLORINFO pCI)
{
    HBITMAP hOldBitmap;
    WORD distancex, distancey;
    WORD topy, bottomy, leftx, rightx;
    RECT rRainbow;

    CopyRect(&rRainbow, &pCI->rRainbow);

    distancex = (WORD)(10 * cxBorder);
    distancey = (WORD)(10 * cyBorder);
    topy    = ((WORD)rRainbow.top > pCI->nSatPos - distancey)
                  ? (WORD)rRainbow.top
                  : pCI->nSatPos - distancey;
    bottomy = ((WORD)rRainbow.bottom < pCI->nSatPos + distancey)
                  ? (WORD)rRainbow.bottom
                  : pCI->nSatPos + distancey;
    leftx   = ((WORD)rRainbow.left > pCI->nHuePos - distancex)
                  ? (WORD)rRainbow.left
                  : pCI->nHuePos - distancex;
    rightx  = ((WORD)rRainbow.right < pCI->nHuePos + distancex)
                  ? (WORD)rRainbow.right
                  : pCI->nHuePos + distancex;

    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);
    BitBlt( hDC,
            leftx,
            topy,
            rightx - leftx,
            bottomy - topy,
            hDCFastBlt,
            leftx - (WORD)rRainbow.left,
            topy - (WORD)rRainbow.top,
            SRCCOPY );
    SelectObject(hDCFastBlt, hOldBitmap);
}


////////////////////////////////////////////////////////////////////////////
//
//  CrossHairPaint
//
////////////////////////////////////////////////////////////////////////////

VOID CrossHairPaint(
    register HDC hDC,
    SHORT x,
    SHORT y,
    PCOLORINFO pCI)
{
    SHORT distancex, distancey;
    SHORT topy, bottomy, topy2, bottomy2;
    SHORT leftx, rightx, leftx2, rightx2;
    RECT rRainbow;

    CopyRect(&rRainbow, &pCI->rRainbow);
    distancex = (SHORT)(5 * cxBorder);
    distancey = (SHORT)(5 * cyBorder);
    topy     = (SHORT)((rRainbow.top > y - 2 * distancey)
                         ? rRainbow.top
                         : y - 2 * distancey);
    bottomy  = (SHORT)((rRainbow.bottom < y + 2 * distancey)
                         ? rRainbow.bottom
                         : y + 2 * distancey);
    leftx    = (SHORT)((rRainbow.left > x - 2 * distancex)
                         ? rRainbow.left
                         : x - 2 * distancex);
    rightx   = (SHORT)((rRainbow.right < x + 2 * distancex)
                         ? rRainbow.right
                         : x + 2 * distancex);
    topy2    = (SHORT)((rRainbow.top > y - distancey)
                         ? rRainbow.top
                         : y - distancey);
    bottomy2 = (SHORT)((rRainbow.bottom < y + distancey)
                         ? rRainbow.bottom
                         : y + distancey);
    leftx2 = (SHORT)((rRainbow.left > x - distancex)
                         ? rRainbow.left
                         : x - distancex);
    rightx2 = (SHORT)((rRainbow.right < x + distancex)
                         ? rRainbow.right
                         : x + distancex);
    if (rRainbow.top < topy2)
    {
        if ((x - 1) >= rRainbow.left)
        {
            MMoveTo(hDC, x - 1, topy2);
            LineTo(hDC, x - 1, topy);
        }
        if ((int)x < rRainbow.right)
        {
            MMoveTo(hDC, x, topy2);
            LineTo(hDC, x, topy);
        }
        if ((x + 1) < rRainbow.right)
        {
            MMoveTo(hDC, x + 1, topy2);
            LineTo(hDC, x + 1, topy);
        }
    }
    if (rRainbow.bottom > bottomy2)
    {
        if ((x - 1) >= rRainbow.left)
        {
            MMoveTo(hDC, x - 1, bottomy2);
            LineTo(hDC, x - 1, bottomy);
        }
        if ((int)x < rRainbow.right)
        {
            MMoveTo(hDC, x, bottomy2);
            LineTo(hDC, x, bottomy);
        }
        if ((x + 1) < rRainbow.right)
        {
            MMoveTo(hDC, x + 1, bottomy2);
            LineTo(hDC, x + 1, bottomy);
        }
    }
    if (rRainbow.left < leftx2)
    {
        if ((y - 1) >= rRainbow.top)
        {
            MMoveTo(hDC, leftx2, y - 1);
            LineTo(hDC, leftx, y - 1);
        }
        if ((int)y < rRainbow.bottom)
        {
            MMoveTo(hDC, leftx2, y);
            LineTo(hDC, leftx, y);
        }
        if ((y + 1) < rRainbow.bottom)
        {
            MMoveTo(hDC, leftx2, y + 1);
            LineTo(hDC, leftx, y + 1);
        }
    }
    if (rRainbow.right > rightx2)
    {
        if ((y - 1) >= rRainbow.top)
        {
            MMoveTo(hDC, rightx2, y - 1);
            LineTo(hDC, rightx, y - 1);
        }
        if ((int)y < rRainbow.bottom)
        {
            MMoveTo(hDC, rightx2, y);
            LineTo(hDC, rightx, y);
        }
        if ((y + 1) < rRainbow.bottom)
        {
            MMoveTo(hDC, rightx2, y + 1);
            LineTo(hDC, rightx, y + 1);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NearestSolid
//
////////////////////////////////////////////////////////////////////////////

VOID NearestSolid(
    register PCOLORINFO pCI)
{
    register HDC hDC;
    HWND hDlg = pCI->hDialog;

    hDC = GetDC(hDlg);
    EraseCrossHair(hDC, pCI);
    EraseLumArrow(hDC, pCI);
    RGBtoHLS(pCI->currentRGB = GetNearestColor(hDC, pCI->currentRGB));
    pCI->currentHue = gHue;
    pCI->currentLum = gLum;
    pCI->currentSat = gSat;
    HLStoHLSPos(0, pCI);
    CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
    LumArrowPaint(hDC, pCI->nLumPos, pCI);
    ReleaseDC(hDlg, hDC);
    SetHLSEdit(0, pCI);
    SetRGBEdit(0, pCI);
    InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
    InvalidateRect(hDlg, (LPRECT)&pCI->rLumPaint, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  HLSPostoHLS
//
////////////////////////////////////////////////////////////////////////////

VOID HLSPostoHLS(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    switch (nHLSEdit)
    {
        case COLOR_HUE:
        {
            pCI->currentHue = (WORD)((pCI->nHuePos - pCI->rRainbow.left) *
                                     (RANGE - 1) / (pCI->nHueWidth - 1));
            break;
        }
        case COLOR_SAT:
        {
            pCI->currentSat = (WORD)(RANGE -
                                     (pCI->nSatPos - pCI->rRainbow.top) *
                                     RANGE / (pCI->nSatHeight - 1));
            break;
        }
        case COLOR_LUM:
        {
            pCI->currentLum = (WORD)(RANGE -
                                     (pCI->nLumPos - pCI->rLumPaint.top) *
                                     RANGE / (pCI->nLumHeight - 1));
            break;
        }
        default:
        {
            pCI->currentHue = (WORD)((pCI->nHuePos - pCI->rRainbow.left) *
                                     (RANGE - 1) / pCI->nHueWidth);
            pCI->currentSat = (WORD)(RANGE -
                                     (pCI->nSatPos - pCI->rRainbow.top) *
                                     RANGE / pCI->nSatHeight);
            pCI->currentLum = (WORD)(RANGE -
                                     (pCI->nLumPos - pCI->rLumPaint.top) *
                                     RANGE / pCI->nLumHeight);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HLStoHLSPos
//
////////////////////////////////////////////////////////////////////////////

VOID HLStoHLSPos(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    switch (nHLSEdit)
    {
        case ( COLOR_HUE ) :
        {
            pCI->nHuePos = (WORD)(pCI->rRainbow.left + pCI->currentHue *
                                  pCI->nHueWidth / (RANGE - 1));
            break;
        }
        case COLOR_SAT:
        {
            pCI->nSatPos = (WORD)(pCI->rRainbow.top +
                                  (RANGE - pCI->currentSat) *
                                  (pCI->nSatHeight - 1) / RANGE);
            break;
        }
        case COLOR_LUM:
        {
            pCI->nLumPos = (WORD)(pCI->rLumPaint.top +
                                  (RANGE - pCI->currentLum) *
                                  (pCI->nLumHeight - 1) / RANGE);
            break;
        }
        default:
        {
            pCI->nHuePos = (WORD)(pCI->rRainbow.left + pCI->currentHue *
                                  pCI->nHueWidth / (RANGE - 1));
            pCI->nSatPos = (WORD)(pCI->rRainbow.top +
                                  (RANGE - pCI->currentSat) *
                                  (pCI->nSatHeight - 1) / RANGE);
            pCI->nLumPos = (WORD)(pCI->rLumPaint.top +
                                  (RANGE - pCI->currentLum) *
                                  (pCI->nLumHeight - 1) / RANGE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetHLSEdit
//
////////////////////////////////////////////////////////////////////////////

VOID SetHLSEdit(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    register HWND hRainbowDlg = pCI->hDialog;

    switch (nHLSEdit)
    {
        case ( COLOR_HUE ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_HUE, pCI->currentHue, FALSE);
            break;
        }
        case ( COLOR_SAT ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_SAT, pCI->currentSat, FALSE);
            break;
        }
        case ( COLOR_LUM ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_LUM, pCI->currentLum, FALSE);
            break;
        }
        default :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_HUE, pCI->currentHue, FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_SAT, pCI->currentSat, FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_LUM, pCI->currentLum, FALSE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRGBEdit
//
////////////////////////////////////////////////////////////////////////////

VOID SetRGBEdit(
    SHORT nRGBEdit,
    PCOLORINFO pCI)
{
    register HWND hRainbowDlg = pCI->hDialog;
    DWORD rainbowRGB = pCI->currentRGB;

    switch (nRGBEdit)
    {
        case ( COLOR_RED ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_RED, GetRValue(rainbowRGB), FALSE);
            break;
        }
        case ( COLOR_GREEN ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_GREEN, GetGValue(rainbowRGB), FALSE);
            break;
        }
        case ( COLOR_BLUE ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_BLUE, GetBValue(rainbowRGB), FALSE);
            break;
        }
        default :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_RED, GetRValue(rainbowRGB), FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_GREEN, GetGValue(rainbowRGB), FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_BLUE, GetBValue(rainbowRGB), FALSE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitRainbow
//
//  Returns TRUE iff we make it.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitRainbow(
    register PCOLORINFO pCI)
{
    HDC hDC;
    WORD Sat, Hue;
    HBITMAP hOldBitmap;
    RECT Rect;
    HBRUSH hbrSwipe;
    WORD nHueWidth, nSatHeight;
    register HWND hRainbowDlg = pCI->hDialog;

    RGBtoHLS(pCI->currentRGB);

    SetupRainbowCapture(pCI);

    nHueWidth = pCI->nHueWidth = (WORD)(pCI->rRainbow.right -
                                        pCI->rRainbow.left);
    nSatHeight = pCI->nSatHeight = (WORD)(pCI->rRainbow.bottom -
                                          pCI->rRainbow.top);

    pCI->currentHue = gHue;
    pCI->currentSat = gSat;
    pCI->currentLum = gLum;

    HLStoHLSPos(0, pCI);
    SetRGBEdit(0, pCI);
    SetHLSEdit(0, pCI);

    if (!hRainbowBitmap)
    {
        hDC = GetDC(hRainbowDlg);
        hRainbowBitmap = CreateCompatibleBitmap(hDC, nHueWidth, nSatHeight);
        if (!hRainbowBitmap)
        {
            return (FALSE);
        }
    }

    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);

    //
    //  NOTE: The final pass through this loop paints on and past the end
    //        of the selected bitmap.  Windows is a good product, and doesn't
    //        let such foolishness happen.
    //
    Rect.bottom = 0;
    for (Sat = RANGE; Sat > 0; Sat -= SATINC)
    {
        Rect.top = Rect.bottom;
        Rect.bottom = (nSatHeight * RANGE - (Sat - SATINC) * nSatHeight) / RANGE;
        Rect.right = 0;

        for (Hue = 0; Hue < (RANGE - 1); Hue += HUEINC)
        {
            Rect.left = Rect.right;
            Rect.right = ((Hue + HUEINC) * nHueWidth) / RANGE;
            hbrSwipe = CreateSolidBrush(HLStoRGB(Hue, RANGE / 2, Sat));
            FillRect(hDCFastBlt, &Rect, hbrSwipe);
            DeleteObject(hbrSwipe);
        }
    }

    SelectObject(hDCFastBlt, hOldBitmap);
    ReleaseDC(hRainbowDlg, hDC);

    UpdateWindow(hRainbowDlg);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintRainbow
//
////////////////////////////////////////////////////////////////////////////

VOID PaintRainbow(
    HDC hDC,
    LPRECT lpRect,
    register PCOLORINFO pCI)
{
    HBITMAP hOldBitmap;

    if (!hRainbowBitmap)
    {
        return;
    }
    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);
    BitBlt( hDC,
            lpRect->left,
            lpRect->top,
            lpRect->right - lpRect->left,
            lpRect->bottom - lpRect->top,
            hDCFastBlt,
            lpRect->left - pCI->rRainbow.left,
            lpRect->top - pCI->rRainbow.top,
            SRCCOPY );
    SelectObject(hDCFastBlt, hOldBitmap);
    CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
    UpdateWindow(pCI->hDialog);
}


////////////////////////////////////////////////////////////////////////////
//
//  RainbowPaint
//
////////////////////////////////////////////////////////////////////////////

void RainbowPaint(
    register PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect)
{
    WORD Lum;
    RECT Rect;
    HBRUSH hbrSwipe;

    //
    //  Paint the Current Color Sample.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rCurrentColor)))
    {
        hbrSwipe = CreateSolidBrush(pCI->currentRGB);
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
    }

    //
    //  Paint the Nearest Pure Color Sample.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rNearestPure)))
    {
        hbrSwipe = CreateSolidBrush(GetNearestColor(hDC, pCI->currentRGB));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
    }

    //
    //  Paint the Luminosity Range.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rLumPaint)))
    {
        Rect.left = pCI->rLumPaint.left;
        Rect.right = pCI->rLumPaint.right;
        Rect.top = pCI->rLumPaint.bottom - LUMINC / 2;
        Rect.bottom = pCI->rLumPaint.bottom;
        hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                              0,
                                              pCI->currentSat ));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
        for (Lum = LUMINC; Lum < RANGE; Lum += LUMINC)
        {
            Rect.bottom = Rect.top;
            Rect.top = (((pCI->rLumPaint.bottom + LUMINC / 2) * (DWORD)RANGE -
                         (Lum + LUMINC) * pCI->nLumHeight) / RANGE);
            hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                                  Lum,
                                                  pCI->currentSat ));
            FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
            DeleteObject(hbrSwipe);
        }
        Rect.bottom = Rect.top;
        Rect.top = pCI->rLumPaint.top;
        hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                              RANGE,
                                              pCI->currentSat ));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);

        //
        //  Paint the bounding rectangle only when it might be necessary.
        //
        if (!EqualRect(lpPaintRect, (LPRECT)&pCI->rLumPaint))
        {
            hbrSwipe = SelectObject(hDC, GetStockObject(NULL_BRUSH));
            Rectangle( hDC,
                       pCI->rLumPaint.left - 1,
                       pCI->rLumPaint.top - 1,
                       pCI->rLumPaint.right + 1,
                       pCI->rLumPaint.bottom + 1 );
            SelectObject(hDC, hbrSwipe);
        }
    }

    //
    //  Paint the Luminosity Arrow.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&pCI->rLumScroll))
    {
        LumArrowPaint(hDC, pCI->nLumPos, pCI);
    }

    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&pCI->rRainbow))
    {
        PaintRainbow(hDC, (LPRECT)&Rect, pCI);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Color conversion routines --
//
//  RGBtoHLS() takes a DWORD RGB value, translates it to HLS, and stores the
//  results in the global vars H, L, and S.  HLStoRGB takes the current values
//  of H, L, and S and returns the equivalent value in an RGB DWORD.  The vars
//  H, L and S are written to only by 1) RGBtoHLS (initialization) or 2) the
//  scrollbar handlers.
//
//  A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
//  Their algorithm is in floating point.
//
//  There are potential roundoff errors lurking throughout here.
//     (0.5 + x/y) without floating point,
//     (x / y) phrased ((x + (y / 2)) / y) yields very small roundoff error.
//  This makes many of the following divisions look funny.
//
//
//  H,L, and S vary over 0 - HLSMAX.
//  R,G, and B vary over 0 - RGBMAX.
//  HLSMAX BEST IF DIVISIBLE BY 6.
//  RGBMAX, HLSMAX must each fit in a byte.
//
//  Hue is undefined if Saturation is 0 (grey-scale).
//  This value determines where the Hue scrollbar is initially set for
//  achromatic colors.
//
////////////////////////////////////////////////////////////////////////////

#define UNDEFINED (HLSMAX * 2 / 3)


////////////////////////////////////////////////////////////////////////////
//
//  RGBtoHLS
//
////////////////////////////////////////////////////////////////////////////

VOID RGBtoHLS(
    DWORD lRGBColor)
{
    WORD R, G, B;                 // input RGB values
    WORD cMax,cMin;               // max and min RGB values
    WORD cSum,cDif;
    SHORT Rdelta, Gdelta, Bdelta; // intermediate value: % of spread from max

    //
    //  get R, G, and B out of DWORD.
    //
    R = GetRValue(lRGBColor);
    G = GetGValue(lRGBColor);
    B = GetBValue(lRGBColor);

    //
    //  Calculate lightness.
    //
    cMax = max(max(R, G), B);
    cMin = min(min(R, G), B);
    cSum = cMax + cMin;
    gLum = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX) / (2 * RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)
    {
        //
        //  r = g = b --> Achromatic case.
        //
        gSat = 0;                         // saturation
        gHue = UNDEFINED;                 // hue
    }
    else
    {
        //
        //  Chromatic case.
        //

        //
        //  Saturation.
        //
        //  Note: Division by cSum is not a problem, as cSum can only
        //        be 0 if the RGB value is 0L, and that is achromatic.
        //
        if (gLum <= (HLSMAX / 2))
        {
            gSat = (WORD)(((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        }
        else
        {
            gSat = (WORD)((DWORD)((cDif * (DWORD)HLSMAX) +
                               (DWORD)((2 * RGBMAX - cSum) / 2)) /
                       (2 * RGBMAX - cSum));
        }

        //
        //  Hue.
        //
        Rdelta = (SHORT)((((cMax - R) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Gdelta = (SHORT)((((cMax - G) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Bdelta = (SHORT)((((cMax - B) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);

        if (R == cMax)
        {
            gHue = Bdelta - Gdelta;
        }
        else if (G == cMax)
        {
            gHue = (WORD)((HLSMAX / 3) + Rdelta - Bdelta);
        }
        else  // (B == cMax)
        {
            gHue = (WORD)(((2 * HLSMAX) / 3) + Gdelta - Rdelta);
        }

        if ((short)gHue < 0)
        {
            //
            //  This can occur when R == cMax and G is > B.
            //
            gHue += HLSMAX;
        }
        if (gHue >= HLSMAX)
        {
            gHue -= HLSMAX;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HueToRGB
//
//  Utility routine for HLStoRGB.
//
////////////////////////////////////////////////////////////////////////////

WORD HueToRGB(
    WORD n1,
    WORD n2,
    WORD hue)
{
    if (hue >= HLSMAX)
    {
        hue -= HLSMAX;
    }

    //
    //  Return r, g, or b value from this tridrant.
    //
    if (hue < (HLSMAX / 6))
    {
        return ((WORD)(n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    if (hue < (HLSMAX/2))
    {
        return (n2);
    }
    if (hue < ((HLSMAX*2)/3))
    {
        return ((WORD)(n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) +
                       (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    else
    {
        return (n1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HLStoRGB
//
////////////////////////////////////////////////////////////////////////////

DWORD HLStoRGB(
    WORD hue,
    WORD lum,
    WORD sat)
{
    WORD R, G, B;                      // RGB component values
    WORD Magic1, Magic2;               // calculated magic numbers

    if (sat == 0)
    {
        //
        //  Achromatic case.
        //
        R = G = B = (WORD)((lum * RGBMAX) / HLSMAX);
    }
    else
    {
        //
        //  Chromatic case
        //

        //
        //  Set up magic numbers.
        //
        if (lum <= (HLSMAX / 2))
        {
            Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);
        }
        else
        {
            Magic2 = lum + sat -
                     (WORD)(((lum * sat) + (DWORD)(HLSMAX / 2)) / HLSMAX);
        }
        Magic1 = (WORD)(2 * lum - Magic2);

        //
        //  Get RGB, change units from HLSMAX to RGBMAX.
        //
        R = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue + (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        G = (WORD)(((HueToRGB(Magic1, Magic2, hue) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        B = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue - (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
    }
    return (RGB(R, G, B));
}


////////////////////////////////////////////////////////////////////////////
//
//  RGBEditChange
//
//  Checks the edit box for a valid entry and updates the Hue, Sat, and Lum
//  edit controls if appropriate.  Also updates Lum picture and current
//  color sample.
//
//  nDlgID - Dialog ID of Red, Green or Blue edit control.
//
////////////////////////////////////////////////////////////////////////////

SHORT RGBEditChange(
    SHORT nDlgID,
    PCOLORINFO pCI)
{
    BOOL bOK;               // check that value in edit control is uint
    BYTE *currentValue;     // pointer to byte in RGB to change (or reset)
    SHORT nVal;
    TCHAR cEdit[3];
    register HWND hDlg = pCI->hDialog;

    currentValue = (BYTE *)&pCI->currentRGB;
    switch (nDlgID)
    {
        case ( COLOR_GREEN ) :
        {
            currentValue++;
            break;
        }
        case ( COLOR_BLUE ) :
        {
            currentValue += 2;
            break;
        }
    }
    nVal = (SHORT)GetDlgItemInt(hDlg, nDlgID, (BOOL FAR *)&bOK, FALSE);
    if (bOK)
    {
        if (nVal > RGBMAX)
        {
            nVal = RGBMAX;
            SetDlgItemInt(hDlg, nDlgID, nVal, FALSE);
        }
        if (nVal != (SHORT) *currentValue)
        {
            *currentValue = LOBYTE(nVal);
            ChangeColorSettings(pCI);
            SetHLSEdit(nDlgID, pCI);
        }
    }
    else if (GetDlgItemText(hDlg, nDlgID, (LPTSTR)cEdit, 2))
    {
        SetRGBEdit(nDlgID, pCI);
        SendDlgItemMessage(hDlg, nDlgID, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
    }
    return (SHORT)(bOK ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\cdids.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    cdids.h

Abstract:

    This module contains the resource ID definitions for the Win32
    common dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <shlobj.h>




//
//  Constant Declarations.
//

#define IDA_OPENFILE         100
#define IDA_OPENFILEVIEW     101
#define IDA_PRINTFOLDER      102

#define IDC_PARENT           (FCIDM_BROWSERFIRST + 1)
#define IDC_NEWFOLDER        (FCIDM_BROWSERFIRST + 2)
#define IDC_VIEWLIST         (FCIDM_BROWSERFIRST + 3)
#define IDC_VIEWDETAILS      (FCIDM_BROWSERFIRST + 4)
#define IDC_DROPDRIVLIST     (FCIDM_BROWSERFIRST + 5)
#define IDC_REFRESH          (FCIDM_BROWSERFIRST + 6)
#define IDC_PREVIOUSFOLDER   (FCIDM_BROWSERFIRST + 7)
#define IDC_JUMPDESKTOP      (FCIDM_BROWSERFIRST + 9)
#define IDC_VIEWMENU         (FCIDM_BROWSERFIRST + 10)
#define IDC_BACK             (FCIDM_BROWSERFIRST + 11)


#define IDC_PLACESBAR_BASE   (FCIDM_BROWSERFIRST  + 100)

#define DUMMYFILEOPENORD     400
#define FONTDLGMMAXES        401

#define FCIDM_FIRST          FCIDM_GLOBALFIRST
#define FCIDM_LAST           FCIDM_GLOBALLAST

#define MH_POPUPS            600

#define MH_ITEMS             (700 - FCIDM_FIRST)
#define MH_TOOLTIPBASE       (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))


#define IDB_JUMPDESKTOP      800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\color.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color.c

Abstract:

    This module implements the Win32 color dialog.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "color.h"
#include "util.h"

// from pwin32.h
#define LONG2POINT(l, pt)    ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))




//
//  Global Variables.
//

DWORD rgbBoxColorDefault[COLORBOXES] =
{
 0x8080FF, 0x80FFFF, 0x80FF80, 0x80FF00, 0xFFFF80, 0xFF8000, 0xC080FF, 0xFF80FF,
 0x0000FF, 0x00FFFF, 0x00FF80, 0x40FF00, 0xFFFF00, 0xC08000, 0xC08080, 0xFF00FF,
 0x404080, 0x4080FF, 0x00FF00, 0x808000, 0x804000, 0xFF8080, 0x400080, 0x8000FF,
 0x000080, 0x0080FF, 0x008000, 0x408000, 0xFF0000, 0xA00000, 0x800080, 0xFF0080,
 0x000040, 0x004080, 0x004000, 0x404000, 0x800000, 0x400000, 0x400040, 0x800040,
 0x000000, 0x008080, 0x408080, 0x808080, 0x808040, 0xC0C0C0, 0x400040, 0xFFFFFF,
 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF,
 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF
};

RECT rColorBox[COLORBOXES];

UINT msgCOLOROKA;
UINT msgSETRGBA;

UINT msgCOLOROKW;
UINT msgSETRGBW;

LPCCHOOKPROC glpfnColorHook = 0;





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorA
//
//  ANSI entry point for ChooseColor when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColorA(
    LPCHOOSECOLORA pCCA)
{
    LPCHOOSECOLORW pCCW;
    BOOL bRet;
    DWORD cbLen;
    COLORINFO CI;

    ZeroMemory(&CI, sizeof(COLORINFO));

    if (!pCCA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCCA->lStructSize != sizeof(CHOOSECOLORA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pCCW = (LPCHOOSECOLORW)LocalAlloc(LPTR, sizeof(CHOOSECOLORW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  Init simple invariants.
    //
    pCCW->lStructSize = sizeof(CHOOSECOLORW);
    pCCW->hwndOwner = pCCA->hwndOwner;
    pCCW->hInstance = pCCA->hInstance;
    pCCW->lpfnHook = pCCA->lpfnHook;

    //
    //  TemplateName array invariant.
    //
    if (pCCA->Flags & CC_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pCCA->lpTemplateName))
        {
            cbLen = lstrlenA(pCCA->lpTemplateName) + 1;
            if (!(pCCW->lpTemplateName = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pCCA->lpTemplateName,
                                     -1,
                                     (LPWSTR)pCCW->lpTemplateName,
                                     cbLen );
            }
        }
        else
        {
            pCCW->lpTemplateName = (LPWSTR)pCCA->lpTemplateName;
        }
    }
    else
    {
        pCCW->lpTemplateName = NULL;
    }

    CI.pCC = pCCW;
    CI.pCCA = pCCA;
    CI.ApiType = COMDLG_ANSI;

    ThunkChooseColorA2W(&CI);
    if (bRet = ChooseColorX(&CI))
    {
        ThunkChooseColorW2A(&CI);
    }

    if (!IS_INTRESOURCE(pCCW->lpTemplateName))
    {
        LocalFree((HLOCAL)pCCW->lpTemplateName);
    }

    LocalFree(pCCW);

    return (bRet);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorW
//
//  Stub UNICODE function for ChooseColor when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColorW(
    LPCHOOSECOLORW pCCW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  ChooseColor
//
//  The ChooseColor function creates a system-defined dialog box from
//  which the user can select a color.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColor(
    LPCHOOSECOLOR pCC)
{
    COLORINFO CI;

    ZeroMemory(&CI, sizeof(COLORINFO));

    CI.pCC = pCC;
    CI.ApiType = COMDLG_WIDE;

    return ( ChooseColorX(&CI) );
}


////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorX
//
//  Worker routine for the ChooseColor api.
//
////////////////////////////////////////////////////////////////////////////

BOOL ChooseColorX(
    PCOLORINFO pCI)
{
    LPCHOOSECOLOR pCC = pCI->pCC;
    INT_PTR iRet = FALSE;
    TCHAR szDialog[cbDlgNameMax];
    LPTSTR lpDlg;
    HANDLE hDlgTemplate;
    HRSRC hRes;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    //
    //  Initialize the error code.
    //
    StoreExtendedError(0);
    g_bUserPressedCancel = FALSE;

    if (!pCC)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCC->lStructSize != sizeof(CHOOSECOLOR))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pCC->Flags & CC_ENABLEHOOK)
    {
        if (!pCC->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pCC->lpfnHook = 0;
    }

    if (pCC->Flags & CC_ENABLETEMPLATE)
    {
        //
        //  Both custom instance handle and the dialog template name are
        //  user specified. Locate the dialog resource in the specified
        //  instance block and load it.
        //
        if (!(hRes = FindResource( (HMODULE)pCC->hInstance,
                                   pCC->lpTemplateName,
                                   RT_DIALOG )))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource((HMODULE)pCC->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }
    else if (pCC->Flags & CC_ENABLETEMPLATEHANDLE)
    {
        //
        //  A handle to the pre-loaded resource has been specified.
        //
        hDlgTemplate = pCC->hInstance;
    }
    else
    {
        LangID = GetDialogLanguage(pCC->hwndOwner, NULL);

        //
        // Warning! Warning! Warning!
        //
        // We have to set g_tlsLangID before any call for CDLoadString
        //
        TlsSetValue(g_tlsLangID, (LPVOID) LangID);

        if (!CDLoadString( g_hinst,
                         dlgChooseColor,
                         szDialog,
                         cbDlgNameMax - 1 ))
        {
            StoreExtendedError(CDERR_LOADSTRFAILURE);
            return (FALSE);
        }
        lpDlg = szDialog;
        if (!(hRes = FindResourceExFallback(g_hinst, RT_DIALOG, lpDlg, LangID)))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }
    // In case it did nt called upove and some new code called CDLoadString.
    TlsSetValue(g_tlsLangID, (LPVOID) LangID);

    if (LockResource(hDlgTemplate))
    {
        if (pCI->pCC->Flags & CC_ENABLEHOOK)
        {
            glpfnColorHook = GETHOOKFN(pCI->pCC);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(pCC))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           pCC->hwndOwner,
                                           ColorDlgProc,
                                           (LPARAM)pCI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       pCC->hwndOwner,
                                       ColorDlgProc,
                                       (LPARAM)pCI );
#endif
        glpfnColorHook = 0;
        if (iRet == -1 || ((iRet == 0) && (!g_bUserPressedCancel) && (!GetStoredExtendedError())) )
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (iRet == IDOK);
}


// Does this dialog have Right to left layout?
BOOL IsRTL(HWND hDlg)
{
    return ((GetWindowLongPtr(hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorDlgProc
//
//  Color Dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PCOLORINFO pCI;
    BOOL_PTR bRet;
    BOOL_PTR bHookRet = FALSE;

    int temp;
    PAINTSTRUCT ps;
    HDC hDC;
    RECT rRect;
    RECT rcTemp;
    SHORT id;
    WORD nVal;
    BOOL bUpdateExample = FALSE;
    BOOL bOK;
    HWND hPointWnd;
    TCHAR cEdit[3];
    DWORD FAR *lpCust ;
    int i;
    POINT pt;
    LPCCHOOKPROC lpfnHook;

    //
    //  The call to PvGetInst will fail until set under WM_INITDIALOG.
    //
    if (pCI = (PCOLORINFO)GetProp(hDlg, COLORPROP))
    {
        lpfnHook = GETHOOKFN(pCI->pCC);

        if ((lpfnHook) &&
            (bRet = (* lpfnHook)(hDlg, wMsg, wParam, lParam)))
        {
            if ((wMsg == WM_COMMAND) &&
                (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL))
            {
                //
                //  Set global flag stating that the user pressed cancel.
                //
                g_bUserPressedCancel = TRUE;
            }

            return (bRet);
        }
    }
    else if (wMsg != WM_INITDIALOG)
    {
        if (glpfnColorHook &&
            (bRet = (*glpfnColorHook)(hDlg, wMsg, wParam, lParam)))
        {
            return (bRet);
        }
        else
        {
            return (FALSE);
        }
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Change cursor to hourglass.
            //
            HourGlass(TRUE);

            pCI = (PCOLORINFO)lParam;

            SetProp(hDlg, COLORPROP, (HANDLE)pCI);
            glpfnColorHook = 0;

            bRet = InitColor(hDlg, wParam, pCI);

            //
            //  Change cursor back to arrow.
            //
            HourGlass(FALSE);

            return (bRet);
            break;
        }
        case ( WM_MOVE ) :
        {
            if (pCI)
            {
                SetupRainbowCapture(pCI);
            }
            return(FALSE);
            break;
        }
        case ( WM_LBUTTONDBLCLK ) :
        {
            LONG2POINT(lParam, pt);
            if (PtInRect((LPRECT)&pCI->rNearestPure, pt))
            {
                NearestSolid(pCI);
            }
            break;
        }
        case ( WM_MOUSEMOVE ) :
        {
            //
            //  Dialog Boxes don't receive MOUSEMOVE unless mouse is captured.
            //  If mouse isn't captured, break.
            //
            if (!bMouseCapture)
            {
                break;
            }

            // Fall Thru...
        }
        case ( WM_LBUTTONDOWN ) :
        {
            LONG2POINT(lParam, pt);
            if (PtInRect((LPRECT)&pCI->rRainbow, pt))
            {
                if (wMsg == WM_LBUTTONDOWN)
                {
                    hDC = GetDC(hDlg);
                    EraseCrossHair(hDC, pCI);
                    ReleaseDC(hDlg, hDC);
                }

                pCI->nHuePos = LOWORD(lParam);
                HLSPostoHLS(COLOR_HUE, pCI);
                SetHLSEdit(COLOR_HUE, pCI);

                pCI->nSatPos = HIWORD(lParam);
                HLSPostoHLS(COLOR_SAT, pCI);
                SetHLSEdit(COLOR_SAT, pCI);
                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                            pCI->currentLum,
                                            pCI->currentSat );
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                hDC = GetDC(hDlg);
                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rLumPaint);
                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                ReleaseDC(hDlg, hDC);

                SetRGBEdit(0, pCI);

                if (!bMouseCapture)
                {
                    SetCapture(hDlg);
                    CopyRect(&rcTemp, &pCI->rRainbow);
                    MapWindowPoints(hDlg, NULL, (LPPOINT)&rcTemp, 2);
                    ClipCursor(&rcTemp);
                    bMouseCapture = TRUE;
                }
            }
            else if ( PtInRect((LPRECT)&pCI->rLumPaint, pt) ||
                      PtInRect((LPRECT)&pCI->rLumScroll, pt) )
            {
                hDC = GetDC(hDlg);
                EraseLumArrow(hDC, pCI);
                LumArrowPaint(hDC, pCI->nLumPos = HIWORD(lParam), pCI);
                HLSPostoHLS(COLOR_LUM, pCI);
                SetHLSEdit(COLOR_LUM, pCI);
                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                            pCI->currentLum,
                                            pCI->currentSat );
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                ReleaseDC(hDlg, hDC);
                ValidateRect(hDlg, (LPRECT)&pCI->rLumScroll);
                ValidateRect(hDlg, (LPRECT)&pCI->rColorSamples);

                SetRGBEdit(0, pCI);

                if (!bMouseCapture)
                {
                    SetCapture(hDlg);
                    CopyRect(&rcTemp, &pCI->rLumScroll);
                    MapWindowPoints(hDlg, NULL, (LPPOINT)&rcTemp, 2);
                    ClipCursor(&rcTemp);
                    bMouseCapture = TRUE;
                }
            }
            else
            {
                hPointWnd = ChildWindowFromPoint(hDlg, pt);
                if (hPointWnd == GetDlgItem(hDlg, COLOR_BOX1))
                {
                    rRect.top    = rColorBox[0].top;
                    rRect.left   = rColorBox[0].left;
                    rRect.right  = rColorBox[NUM_BASIC_COLORS - 1].right +
                                   BOX_X_MARGIN;
                    rRect.bottom = rColorBox[NUM_BASIC_COLORS - 1].bottom +
                                   BOX_Y_MARGIN;
                    temp = (NUM_BASIC_COLORS) / NUM_X_BOXES;
                    id = 0;
                }
                else if (hPointWnd == GetDlgItem(hDlg, COLOR_CUSTOM1))
                {
                    rRect.top    = rColorBox[NUM_BASIC_COLORS].top;
                    rRect.left   = rColorBox[NUM_BASIC_COLORS].left;
                    rRect.right  = rColorBox[COLORBOXES - 1].right + BOX_X_MARGIN;
                    rRect.bottom = rColorBox[COLORBOXES - 1].bottom + BOX_Y_MARGIN;
                    temp = (NUM_CUSTOM_COLORS) / NUM_X_BOXES;
                    id = NUM_BASIC_COLORS;
                }
                else
                {
                    return (FALSE);
                }

                if (hPointWnd != GetFocus())
                {
                    SetFocus(hPointWnd);
                }

                if (HIWORD(lParam) >= (WORD)rRect.bottom)
                {
                    break;
                }
                if (LOWORD(lParam) >= (WORD)rRect.right)
                {
                    break;
                }
                if (HIWORD(lParam) < (WORD)rRect.top)
                {
                    break;
                }
                if (LOWORD(lParam) < (WORD)rRect.left)
                {
                    break;
                }

                //
                //  Make sure the click wasn't on a border between squares.
                //
                if ( ((LOWORD(lParam) - rRect.left) % nBoxWidth) >=
                     (nBoxWidth - BOX_X_MARGIN) )
                {
                    break;
                }
                if ( ((HIWORD(lParam) - rRect.top) % nBoxHeight) >=
                     (nBoxHeight - BOX_Y_MARGIN) )
                {
                    break;
                }

                //
                //  Now calculate which square was selected.
                //
                id += (SHORT)(((HIWORD(lParam) - rRect.top) * temp /
                              (rRect.bottom - rRect.top)) * NUM_X_BOXES);

                id += (SHORT)(((LOWORD(lParam) - rRect.left) * NUM_X_BOXES) /
                              (rRect.right - rRect.left));

                if ((id < nDriverColors) || (id >= NUM_BASIC_COLORS))
                {
                    ChangeBoxSelection(pCI, id);
                    pCI->nCurBox = id;
                    ChangeBoxFocus(pCI, id);
                    if (id >= NUM_BASIC_COLORS)
                    {
                        pCI->nCurMix = pCI->nCurBox;
                    }
                    else
                    {
                        pCI->nCurDsp = pCI->nCurBox;
                    }
                    pCI->currentRGB = pCI->rgbBoxColor[pCI->nCurBox];
                    pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                    hDC = GetDC(hDlg);
                    if (pCI->bFoldOut)
                    {
                        ChangeColorSettings(pCI);
                        SetHLSEdit(0, pCI);
                        SetRGBEdit(0, pCI);
                        RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                    }
                    PaintBox(pCI, hDC, pCI->nCurDsp);
                    PaintBox(pCI, hDC, pCI->nCurMix);
                    ReleaseDC(hDlg, hDC);
                }
            }
            break;
        }
        case ( WM_LBUTTONUP ) :
        {
            LONG2POINT(lParam, pt);
            if (bMouseCapture)
            {
                bMouseCapture = FALSE;
                SetCapture(NULL);
                ClipCursor((LPRECT)NULL);
                if (PtInRect((LPRECT)&pCI->rRainbow, pt))
                {
                    hDC = GetDC(hDlg);
                    CrossHairPaint( hDC,
                                    pCI->nHuePos = LOWORD(lParam),
                                    pCI->nSatPos = HIWORD(lParam),
                                    pCI );
                    RainbowPaint(pCI, hDC, (LPRECT)&pCI->rLumPaint);
                    ReleaseDC(hDlg, hDC);
                    ValidateRect(hDlg, (LPRECT)&pCI->rRainbow);
                }
                else if (PtInRect((LPRECT)&pCI->rLumPaint, pt))
                {
                    //
                    //  Update Sample Shown.
                    //
                    hDC = GetDC(hDlg);
                    LumArrowPaint(hDC, pCI->nLumPos, pCI);
                    ReleaseDC(hDlg, hDC);
                    ValidateRect(hDlg, (LPRECT)&pCI->rLumPaint);
                }
            }
            break;
        }
        case ( WM_CHAR ) :
        {
            if (wParam == VK_SPACE)
            {
                if (GetFocus() == GetDlgItem(hDlg, COLOR_BOX1))
                {
                    temp = pCI->nCurDsp;
                }
                else if (GetFocus() == GetDlgItem(hDlg, COLOR_CUSTOM1))
                {
                    temp = pCI->nCurMix;
                }
                else
                {
                    return (FALSE);
                }
                pCI->currentRGB = pCI->rgbBoxColor[temp];
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                if (pCI->bFoldOut)
                {
                    ChangeColorSettings(pCI);
                    SetHLSEdit(0, pCI);
                    SetRGBEdit(0, pCI);
                }
                InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
                ChangeBoxSelection(pCI, (short)temp);
                pCI->nCurBox = (short)temp;
                bUpdateExample = TRUE;
            }
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            if (ColorKeyDown(wParam, &temp, pCI, IsRTL(hDlg)))
            {
                ChangeBoxFocus(pCI, (SHORT)temp);
            }
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            return (DLGC_WANTALLKEYS | DLGC_WANTARROWS | DLGC_HASSETSEL);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pCI)
            {
                return (FALSE);
            }

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDOK ) :
                {
                    pCI->pCC->rgbResult = pCI->currentRGB;
                    goto LeaveDialog;
                }
                case ( IDCANCEL ) :
                {
                    g_bUserPressedCancel = TRUE;
LeaveDialog:
                    if (bMouseCapture)
                    {
                        bMouseCapture = FALSE;
                        SetCapture(NULL);
                        ClipCursor((LPRECT)NULL);
                    }
                    lpCust = pCI->pCC->lpCustColors;
                    for ( i = NUM_BASIC_COLORS;
                          i < NUM_BASIC_COLORS + NUM_CUSTOM_COLORS;
                          i++ )
                    {
                        *lpCust++ = pCI->rgbBoxColor[i];
                    }

                    bRet = (GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
                    lpfnHook = GETHOOKFN(pCI->pCC);

#ifdef UNICODE
                    if (pCI->ApiType == COMDLG_ANSI)
                    {
                        if (bRet && lpfnHook)
                        {
                            ThunkChooseColorW2A(pCI);
                            bHookRet = (*lpfnHook)( hDlg,
                                                    msgCOLOROKA,
                                                    0,
                                                    (LONG_PTR)(LPTSTR)pCI->pCCA );
                        }
                    }
                    else
#endif
                    {
                        if (bRet && lpfnHook)
                        {
                            bHookRet = (*lpfnHook)( hDlg,
                                                    msgCOLOROKW,
                                                    0,
                                                    (LONG_PTR)(LPTSTR)pCI->pCC );
                        }
                    }

                    if (bHookRet)
                    {
#ifdef UNICODE
                        if (pCI->ApiType == COMDLG_ANSI)
                        {
                            ThunkChooseColorA2W(pCI);
                            pCI->pCC->lCustData = pCI->pCCA->lCustData;
                        }
#endif
                        break;
                    }
                }
                case ( IDABORT ) :
                {
                    if (pCI->pCC->Flags & CC_ENABLEHOOK)
                    {
                        glpfnColorHook = GETHOOKFN(pCI->pCC);
                    }

                    RemoveProp(hDlg, COLORPROP);
                    EndDialog( hDlg,
                               (GET_WM_COMMAND_ID(wParam, lParam) == IDABORT)
                                   ? (BOOL_PTR)lParam
                                   : bRet );

                    if (hRainbowBitmap)
                    {
                        DeleteObject(hRainbowBitmap);
                        hRainbowBitmap = NULL;
                    }
                    if (hDCFastBlt)
                    {
                        DeleteDC(hDCFastBlt);
                        hDCFastBlt = 0;
                    }
                    break;
                }
                case ( pshHelp ) :
                {
#ifdef UNICODE
                    if (pCI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pCI->pCC->hwndOwner)
                        {
                            ThunkChooseColorW2A(pCI);
                            SendMessage( pCI->pCC->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pCI->pCCA );
                            ThunkChooseColorA2W(pCI);
                            pCI->pCC->lCustData = pCI->pCCA->lCustData;
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pCI->pCC->hwndOwner)
                        {
                            SendMessage( pCI->pCC->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pCI->pCC );
                        }
                    }
                    break;
                }
                case ( COLOR_SOLID ) :
                {
                    NearestSolid(pCI);
                    break;
                }
                case ( COLOR_RED ) :
                case ( COLOR_GREEN ) :
                case ( COLOR_BLUE ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        RGBEditChange(GET_WM_COMMAND_ID(wParam, lParam), pCI);
                        InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt( hDlg,
                                       GET_WM_COMMAND_ID(wParam, lParam),
                                       &bOK,
                                       FALSE );
                        if (!bOK)
                        {
                            SetRGBEdit(GET_WM_COMMAND_ID(wParam, lParam), pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_HUE ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_HUE, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE - 1)
                            {
                                nVal = RANGE - 1;
                                SetDlgItemInt(hDlg, COLOR_HUE, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentHue)
                            {
                                hDC = GetDC(hDlg);
                                EraseCrossHair(hDC, pCI);
                                pCI->currentHue = nVal;
                                pCI->currentRGB = HLStoRGB( nVal,
                                                            pCI->currentLum,
                                                            pCI->currentSat );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                HLStoHLSPos(COLOR_HUE, pCI);
                                CrossHairPaint( hDC,
                                                pCI->nHuePos,
                                                pCI->nSatPos,
                                                pCI );
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rLumPaint,
                                                FALSE );
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_HUE,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_HUE, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_HUE,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_HUE, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_HUE, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_SAT ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_SAT, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE)
                            {
                                nVal = RANGE;
                                SetDlgItemInt(hDlg, COLOR_SAT, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentSat)
                            {
                                hDC = GetDC(hDlg);
                                EraseCrossHair(hDC, pCI);
                                pCI->currentSat = nVal;
                                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                                            pCI->currentLum,
                                                            nVal );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                HLStoHLSPos(COLOR_SAT, pCI);
                                CrossHairPaint( hDC,
                                                pCI->nHuePos,
                                                pCI->nSatPos,
                                                pCI );
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rLumPaint,
                                                FALSE );
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_SAT,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_SAT, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_SAT,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_SAT, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_SAT, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_LUM ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_LUM, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE)
                            {
                                nVal = RANGE;
                                SetDlgItemInt(hDlg, COLOR_LUM, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentLum)
                            {
                                hDC = GetDC(hDlg);
                                EraseLumArrow(hDC, pCI);
                                pCI->currentLum = nVal;
                                HLStoHLSPos(COLOR_LUM, pCI);
                                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                                            nVal,
                                                            pCI->currentSat );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                LumArrowPaint(hDC, pCI->nLumPos, pCI);
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_LUM,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_LUM, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_LUM,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_LUM, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_LUM, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_ADD ) :
                {
                    pCI->rgbBoxColor[pCI->nCurMix] = pCI->currentRGB;
                    InvalidateRect(hDlg, (LPRECT)rColorBox + pCI->nCurMix, FALSE);

                    if (pCI->nCurMix >= COLORBOXES - 1)
                    {
                        pCI->nCurMix = NUM_BASIC_COLORS;
                    }
#if HORIZONTELINC
                    else
                    {
                        pCI->nCurMix++;
                    }
#else
                    else if (pCI->nCurMix >= NUM_BASIC_COLORS + 8)
                    {
                        //
                        //  Increment nCurBox VERTICALLY!  extra code
                        //  for vertical instead of horizontal increment.
                        //
                        pCI->nCurMix -= 7;
                    }
                    else
                    {
                        pCI->nCurMix += 8;
                    }
#endif
                    break;
                }
                case ( COLOR_MIX ) :
                {
                    //
                    //  Change cursor to hourglass.
                    //
                    HourGlass(TRUE);

                    InitRainbow(pCI);

                    //
                    //  Code relies on COLOR_HUE through COLOR_BLUE being
                    //  consecutive.
                    //
                    for (temp = COLOR_HUE; temp <= COLOR_BLUE; temp++)
                    {
                        EnableWindow(GetDlgItem(hDlg, temp), TRUE);
                    }
                    for (temp = COLOR_HUEACCEL; temp <= COLOR_BLUEACCEL; temp++)
                    {
                        EnableWindow(GetDlgItem(hDlg, temp), TRUE);
                    }

                    EnableWindow(GetDlgItem(hDlg, COLOR_ADD), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_SOLID), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_MIX), FALSE);

                    GetWindowRect(hDlg, (LPRECT)&rcTemp);

                    SetWindowPos( hDlg,
                                  NULL,
                                  pCI->rOriginal.left,
                                  pCI->rOriginal.top,
                                  pCI->rOriginal.right - pCI->rOriginal.left,
                                  pCI->rOriginal.bottom - pCI->rOriginal.top,
                                  SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

                    //
                    //  Only invalidate exposed area.
                    //
                    rcTemp.right = rcTemp.left;
                    rcTemp.left = pCI->rOriginal.left;
                    InvalidateRect(hDlg, (LPRECT)&rcTemp, FALSE);

                    //
                    //  Change cursor back to arrow.
                    //
                    HourGlass(FALSE);

                    SetFocus(GetDlgItem(hDlg, COLOR_HUE));
                    pCI->bFoldOut = TRUE;

                    break;
                }
            }
            break;
        }
        case ( WM_QUERYNEWPALETTE ) :
        {
            if (pCI->hPal)
            {
                HDC hdc = GetDC(hDlg);

                SelectPalette(hdc, pCI->hPal, FALSE);
                i = RealizePalette(hdc);
                ReleaseDC(hDlg, hdc);

                if (i > 0)
                {
                    InvalidateRect(hDlg, NULL, FALSE);
                }
            }
            break;
        }
        case ( WM_PALETTECHANGED ) :
        {
            if (pCI->hPal && (HWND)wParam != hDlg)
            {
                InvalidateRect(hDlg, NULL, FALSE);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            BeginPaint(hDlg, (LPPAINTSTRUCT)&ps);
            ColorPaint(hDlg, pCI, ps.hdc, (LPRECT)&ps.rcPaint);
            EndPaint(hDlg, (LPPAINTSTRUCT)&ps);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aColorHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aColorHelpIDs );
            }
            break;
        }
        default :
        {
            if (wMsg == msgSETRGBA || wMsg == msgSETRGBW)
            {
                if (ChangeColorBox(pCI, (DWORD)lParam))
                {
                    pCI->currentRGB = MapColor(pCI, (DWORD) lParam);

                    if (pCI->nCurBox < pCI->nCurMix)
                    {
                        pCI->nCurDsp = pCI->nCurBox;
                    }
                    else
                    {
                        pCI->nCurMix = pCI->nCurBox;
                    }
                }
                if (pCI->bFoldOut)
                {
                    pCI->currentRGB = MapColor(pCI, (DWORD) lParam);
                    ChangeColorSettings(pCI);
                    SetHLSEdit(0, pCI);
                    SetRGBEdit(0, pCI);
                    hDC = GetDC(hDlg);
                    RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                    ReleaseDC(hDlg, hDC);
                }
                break;
            }
            return (FALSE);
            break;
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeColorBox
//
//  Update box shown.
//
////////////////////////////////////////////////////////////////////////////

BOOL ChangeColorBox(
    register PCOLORINFO pCI,
    DWORD dwRGBcolor)
{
    register short nBox;

    for (nBox = 0; nBox < COLORBOXES; nBox++)
    {
        if (pCI->rgbBoxColor[nBox] == dwRGBcolor)
        {
            break;
        }
    }
    if (nBox >= COLORBOXES)
    {
        //
        //  Color Not Found.  Now What Should We Do?
        //
    }
    else
    {
        ChangeBoxSelection(pCI, nBox);
        pCI->nCurBox = nBox;
    }

    return (nBox < COLORBOXES);
}


////////////////////////////////////////////////////////////////////////////
//
//  HiLiteBox
//
////////////////////////////////////////////////////////////////////////////

VOID HiLiteBox(
    HDC hDC,
    SHORT nBox,
    SHORT fStyle)
{
    RECT rRect;
    HBRUSH hBrush;

    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + nBox);
    rRect.left--, rRect.top--, rRect.right++, rRect.bottom++;
    hBrush = CreateSolidBrush((fStyle & 1) ? 0L : GetSysColor(COLOR_3DFACE));
    FrameRect(hDC, (LPRECT)&rRect, hBrush);
    DeleteObject(hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeBoxSelection
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeBoxSelection(
    PCOLORINFO pCI,
    SHORT nNewBox)
{
    register HDC hDC;
    register HWND hDlg = pCI->hDialog;

    hDC = GetDC(hDlg);
    HiLiteBox(hDC, pCI->nCurBox, 0);
    HiLiteBox(hDC, nNewBox, 1);
    ReleaseDC(hDlg, hDC);
    pCI->currentRGB = pCI->rgbBoxColor[nNewBox];
    pCI->currentRGB = MapColor(pCI, pCI->currentRGB);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeBoxFocus
//
//  Can't trust the state of the XOR for DrawFocusRect, so must draw
//  the rectangle in the window background color first.
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeBoxFocus(
    PCOLORINFO pCI,
    SHORT nNewBox)
{
    HANDLE hDlg = pCI->hDialog;
    HDC    hDC;
    RECT   rRect;
    LPWORD nCur = (LPWORD)((nNewBox < (NUM_BASIC_COLORS))
                               ? (LONG_PTR)&pCI->nCurDsp
                               : (LONG_PTR)&pCI->nCurMix);
    HPEN   hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
    HBRUSH hBrush = GetStockObject(HOLLOW_BRUSH);

    hDC = GetDC(hDlg);
    hPen = SelectObject(hDC, hPen);
    hBrush = SelectObject(hDC, hBrush);
    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + *nCur);
    InflateRect((LPRECT)&rRect, 3, 3);
    Rectangle(hDC, rRect.left, rRect.top, rRect.right, rRect.bottom);
    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + (*nCur = nNewBox));
    InflateRect((LPRECT)&rRect, 3, 3);
    Rectangle(hDC, rRect.left, rRect.top, rRect.right, rRect.bottom);
    DrawFocusRect(hDC, (LPRECT)&rRect);
    hPen = SelectObject(hDC, hPen);
    SelectObject(hDC, hBrush);
    ReleaseDC(hDlg, hDC);
    DeleteObject(hPen);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorKeyDown
//
////////////////////////////////////////////////////////////////////////////

BOOL ColorKeyDown(
    WPARAM wParam,
    int *id,
    PCOLORINFO pCI,
    BOOL bRTL)
{
    WORD temp;

    temp = (WORD)GetWindowLong(GetFocus(), GWL_ID);
    if (temp == COLOR_BOX1)
    {
        temp = pCI->nCurDsp;
    }
    else if (temp == COLOR_CUSTOM1)
    {
        temp = pCI->nCurMix;
    }
    else
    {
        return (FALSE);
    }

    // Switch meaning of right and left if we have RTL layout.
    if (bRTL)
    {
        if (wParam == VK_LEFT)
        {
            wParam = VK_RIGHT;
        }
        else if (wParam == VK_RIGHT)
        {
            wParam = VK_LEFT;
        }
    }

    switch (wParam)
    {
        case ( VK_UP ) :
        {
            if (temp >= (NUM_BASIC_COLORS + NUM_X_BOXES))
            {
                temp -= NUM_X_BOXES;
            }
            else if ((temp < NUM_BASIC_COLORS) && (temp >= NUM_X_BOXES))
            {
                temp -= NUM_X_BOXES;
            }
            break;
        }
        case ( VK_HOME ) :
        {
            if (temp == pCI->nCurDsp)
            {
                temp = 0;
            }
            else
            {
                temp = NUM_BASIC_COLORS;
            }
            break;
        }
        case ( VK_END ) :
        {
            if (temp == pCI->nCurDsp)
            {
                temp = (WORD)(nDriverColors - 1);
            }
            else
            {
                temp = COLORBOXES - 1;
            }
            break;
        }
        case ( VK_DOWN ) :
        {
            if (temp < (NUM_BASIC_COLORS - NUM_X_BOXES))
            {
                temp += NUM_X_BOXES;
            }
            else if ((temp >= (NUM_BASIC_COLORS)) &&
                     (temp < (COLORBOXES - NUM_X_BOXES)))
            {
                temp += NUM_X_BOXES;
            }
            break;
        }
        case ( VK_LEFT ) :
        {
            if (temp % NUM_X_BOXES)
            {
                temp--;
            }
            break;
        }
        case ( VK_RIGHT ) :
        {
            if (!(++temp % NUM_X_BOXES))
            {
                --temp;
            }
            break;
        }
    }

    //
    //  If we've received colors from the driver, make certain the arrow would
    //  not take us to an undefined color.
    //
    if ((temp >= (WORD)nDriverColors) && (temp < NUM_BASIC_COLORS))
    {
        temp = pCI->nCurDsp;
    }

    *id = temp;
    return ((temp != pCI->nCurDsp) && (temp != pCI->nCurMix));
}


////////////////////////////////////////////////////////////////////////////
//
//  FillBox
//
////////////////////////////////////////////////////////////////////////////

VOID FillBox(
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT prc,
    COLORREF rgb)
{
    HBRUSH hBrush;
    RECT rc = *prc;

    DrawEdge(hDC, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);

    hBrush = CreateSolidBrush(MapColor(pCI, rgb));
    FillRect(hDC, &rc, hBrush);
    DeleteObject(hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintBox
//
////////////////////////////////////////////////////////////////////////////

VOID PaintBox(
    PCOLORINFO pCI,
    register HDC hDC,
    SHORT i)
{
    if ((i < NUM_BASIC_COLORS) && (i >= nDriverColors))
    {
        return;
    }

    FillBox(pCI, hDC, &rColorBox[i], pCI->rgbBoxColor[i]);

    if (i == (short)pCI->nCurBox)
    {
        HiLiteBox(hDC, i, 1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitScreenCoords
//
//  Returns TRUE iff we make it.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitScreenCoords(
    HWND hDlg,
    PCOLORINFO pCI)
{
    RECT rRect;
    SHORT i;
//  DWORD *lpDriverRGB;
    HWND hBox1, hCustom1;

    hBox1 = GetDlgItem(hDlg, COLOR_BOX1);
    hCustom1 = GetDlgItem(hDlg, COLOR_CUSTOM1);
    lpprocStatic = (WNDPROC)GetWindowLongPtr(hBox1, GWLP_WNDPROC);
    SetWindowLongPtr(hBox1, GWLP_WNDPROC, (LONG_PTR)WantArrows);
    SetWindowLongPtr(hCustom1, GWLP_WNDPROC, (LONG_PTR)WantArrows);

    GetWindowRect(hBox1, (LPRECT)&rRect);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rRect, 2);
    rRect.left += (BOX_X_MARGIN + 1) / 2;
    rRect.top += (BOX_Y_MARGIN + 1) / 2;
    rRect.right -= (BOX_X_MARGIN + 1) / 2;
    rRect.bottom -= (BOX_Y_MARGIN + 1) / 2;
    nBoxWidth = (SHORT)((rRect.right - rRect.left) / NUM_X_BOXES);
    nBoxHeight = (SHORT)((rRect.bottom - rRect.top) /
                         (NUM_BASIC_COLORS / NUM_X_BOXES));

    //
    //  Assume no colors from driver.
    //
    nDriverColors = 0;

    for (i = 0; i < NUM_BASIC_COLORS; i++)
    {
        rColorBox[i].left = rRect.left + nBoxWidth * (i % NUM_X_BOXES);
        rColorBox[i].right = rColorBox[i].left + nBoxWidth - BOX_X_MARGIN;
        rColorBox[i].top = rRect.top + nBoxHeight * (i / NUM_X_BOXES);
        rColorBox[i].bottom = rColorBox[i].top + nBoxHeight - BOX_Y_MARGIN;

        //
        //  Setup the colors.  If the driver still has colors to give, take it.
        //  If not, if the driver actually gave colors, set the color to white.
        //  Otherwise set to the default colors.
        //
        if (i < nDriverColors)
        {
            // pCI->rgbBoxColor[i] = *lpDriverRGB++;
        }
        else
        {
            pCI->rgbBoxColor[i] = nDriverColors
                                      ? 0xFFFFFF
                                      : rgbBoxColorDefault[i];
        }
    }

    //
    //  If no driver colors, use default number.
    //
    if (!nDriverColors)
    {
        nDriverColors = NUM_BASIC_COLORS;
    }

    GetWindowRect(hCustom1, (LPRECT)&rRect);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rRect, 2);
    rRect.left += (BOX_X_MARGIN + 1) / 2;
    rRect.top += (BOX_Y_MARGIN + 1) / 2;
    rRect.right -= (BOX_X_MARGIN + 1) / 2;
    rRect.bottom -= (BOX_Y_MARGIN + 1) / 2;

    for (; i < COLORBOXES; i++)
    {
        rColorBox[i].left = rRect.left +
                       nBoxWidth * ((i - (NUM_BASIC_COLORS)) % NUM_X_BOXES);
        rColorBox[i].right = rColorBox[i].left + nBoxWidth - BOX_X_MARGIN;
        rColorBox[i].top = rRect.top +
                       nBoxHeight * ((i - (NUM_BASIC_COLORS)) / NUM_X_BOXES);
        rColorBox[i].bottom = rColorBox[i].top + nBoxHeight - BOX_Y_MARGIN;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetupRainbowCapture
//
////////////////////////////////////////////////////////////////////////////

VOID SetupRainbowCapture(
    PCOLORINFO pCI)
{
    HWND hwnd;
    HWND hDlg = pCI->hDialog;

    hwnd = GetDlgItem(hDlg, COLOR_RAINBOW);
    GetClientRect(hwnd, &pCI->rRainbow);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rRainbow, 2);

    hwnd = GetDlgItem(hDlg, COLOR_LUMSCROLL);
    GetClientRect(hwnd, &pCI->rLumPaint);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rLumPaint, 2);

    hwnd = GetDlgItem(hDlg, COLOR_CURRENT);
    GetClientRect(hwnd, &pCI->rColorSamples);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rColorSamples, 2);

    pCI->rLumScroll = pCI->rLumPaint;
    pCI->rLumScroll.left = pCI->rLumScroll.right;
    pCI->rLumScroll.right += cxSize / 2;
    pCI->nLumHeight = (WORD)(pCI->rLumPaint.bottom - pCI->rLumPaint.top);

    pCI->rNearestPure = pCI->rColorSamples;
    pCI->rCurrentColor = pCI->rColorSamples;
    pCI->rCurrentColor.right = (pCI->rColorSamples.left + pCI->rColorSamples.right) / 2;
    pCI->rNearestPure.left = pCI->rCurrentColor.right;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitColor
//
//  Returns TRUE iff everything's OK.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR InitColor(
    HWND hDlg,
    WPARAM wParam,
    PCOLORINFO pCI)
{
    SHORT i;
    RECT rRect;
    LPCHOOSECOLOR pCC = pCI->pCC;
    HDC hDC;
    DWORD FAR *lpCust;
    BOOL_PTR bRet;
    HWND hCtlSolid = GetDlgItem(hDlg, COLOR_SOLID);

    if (!hDCFastBlt)
    {
        hDC = GetDC(hDlg);
        hDCFastBlt = CreateCompatibleDC(hDC);
        ReleaseDC(hDlg, hDC);
        if (!hDCFastBlt)
        {
            return(FALSE);
        }
    }

    pCI->hDialog = hDlg;

    SetupRainbowCapture(pCI);

    if (pCC->Flags & CC_RGBINIT)
    {
        pCI->currentRGB = pCC->rgbResult;
    }
    else
    {
        pCI->currentRGB = 0L;
    }
    if (pCC->Flags & (CC_PREVENTFULLOPEN | CC_FULLOPEN))
    {
        EnableWindow(GetDlgItem(hDlg, COLOR_MIX), FALSE);
    }

    if (pCC->Flags & CC_SOLIDCOLOR)
    {
        ShowWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), SW_HIDE);
    }

    if (pCC->Flags & CC_FULLOPEN)
    {
        InitRainbow(pCI);
        pCI->bFoldOut = TRUE;
        RGBtoHLS(pCI->currentRGB);
        pCI->currentHue = gHue;
        pCI->currentSat = gSat;
        pCI->currentLum = gLum;
        SetRGBEdit(0, pCI);
        SetHLSEdit(0, pCI);
    }
    else
    {
        //
        //  Code relies on COLOR_HUE through COLOR_BLUE being consecutive.
        //
        for (i = COLOR_HUE; i <= COLOR_BLUE; i++)
        {
            EnableWindow(GetDlgItem(hDlg, i), FALSE);
        }
        for (i = COLOR_HUEACCEL; i <= COLOR_BLUEACCEL; i++)
        {
            EnableWindow(GetDlgItem(hDlg, i), FALSE);
        }

        EnableWindow(GetDlgItem(hDlg, COLOR_ADD), FALSE);

        EnableWindow(hCtlSolid, FALSE);
        EnableWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), FALSE);

        pCI->bFoldOut = FALSE;

        GetWindowRect(GetDlgItem(hDlg, COLOR_BOX1), &rRect);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rRect, 2);
        i = (SHORT)rRect.right;
        GetWindowRect(GetDlgItem(hDlg, COLOR_RAINBOW), &rRect);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rRect, 2);
        GetWindowRect(hDlg, &(pCI->rOriginal));
        MoveWindow( hDlg,
                    pCI->rOriginal.left,
                    pCI->rOriginal.top,
                    (rRect.left + i) / 2,
                    pCI->rOriginal.bottom - pCI->rOriginal.top,
                    FALSE );
    }

    InitScreenCoords(hDlg, pCI);

    lpCust = pCC->lpCustColors;
    for (i = NUM_BASIC_COLORS; i < NUM_BASIC_COLORS + NUM_CUSTOM_COLORS; i++)
    {
        pCI->rgbBoxColor[i] = *lpCust++;
    }

    pCI->nCurBox = pCI->nCurDsp = 0;
    pCI->nCurMix = NUM_BASIC_COLORS;
    ChangeColorBox(pCI, pCI->currentRGB);
    if (pCI->nCurBox < pCI->nCurMix)
    {
        pCI->nCurDsp = pCI->nCurBox;
    }
    else
    {
        pCI->nCurMix = pCI->nCurBox;
    }

    if (!(pCC->Flags & CC_SHOWHELP))
    {
        HWND hHelp;

        EnableWindow(hHelp = GetDlgItem(hDlg, pshHelp), FALSE);
        ShowWindow(hHelp, SW_HIDE);
    }

    SetWindowLong( hCtlSolid,
                   GWL_STYLE,
                   GetWindowLong(hCtlSolid, GWL_STYLE) & (~WS_TABSTOP) );

    if (pCC->lpfnHook)
    {
        LPCCHOOKPROC lpfnHook = GETHOOKFN(pCC);

#ifdef UNICODE
        if (pCI->ApiType == COMDLG_ANSI)
        {
            ThunkChooseColorW2A(pCI);
            bRet = ((* lpfnHook)( hDlg,
                                  WM_INITDIALOG,
                                  wParam,
                                  (LPARAM)pCI->pCCA ));

            //
            //  Strange win 31 example uses lCustData to hold a temporary
            //  variable that it passes back to calling function.
            //
            ThunkChooseColorA2W(pCI);
            pCC->lCustData = pCI->pCCA->lCustData;
        }
        else
#endif
        {
            bRet = ((* lpfnHook)( hDlg,
                                  WM_INITDIALOG,
                                  wParam,
                                  (LPARAM)pCC ));
        }
    }
    else
    {
        bRet = TRUE;
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorPaint
//
////////////////////////////////////////////////////////////////////////////

VOID ColorPaint(
    HWND hDlg,
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect)
{
    SHORT i;
    HWND hFocus;

    for (i = 0; i < nDriverColors; i++)
    {
        PaintBox(pCI, hDC, i);
    }
    for (i = NUM_BASIC_COLORS; i < COLORBOXES; i++)
    {
        PaintBox(pCI, hDC, i);
    }

    //
    //  Must redraw focus as well as paint boxes.
    //
    hFocus = GetFocus();
    if (hFocus == GetDlgItem(hDlg, COLOR_BOX1))
    {
        i = pCI->nCurDsp;
    }
    else if (hFocus == GetDlgItem(hDlg, COLOR_CUSTOM1))
    {
        i = pCI->nCurMix;
    }
    else
    {
        goto NoDrawFocus;
    }
    ChangeBoxFocus(pCI, i);

NoDrawFocus:
    RainbowPaint(pCI, hDC, lpPaintRect);
}


////////////////////////////////////////////////////////////////////////////
//
//  WantArrows
//
////////////////////////////////////////////////////////////////////////////

LONG WINAPI WantArrows(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    PCOLORINFO pCI;
    RECT rcTemp;
    HDC hDC;
    WORD temp;

    switch (msg)
    {
        case ( WM_GETDLGCODE ) :
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);

        case WM_KEYDOWN:
        case WM_CHAR:
            return ((LONG) SendMessage(GetParent(hWnd), msg, wParam, lParam));

        case ( WM_SETFOCUS ) :
        case ( WM_KILLFOCUS ) :
        {
            if (pCI = (PCOLORINFO) GetProp(GetParent(hWnd), COLORPROP))
            {
                if (GetWindowLong(hWnd, GWL_ID) == COLOR_BOX1)
                {
                    temp = pCI->nCurDsp;
                }
                else
                {
                    temp = pCI->nCurMix;
                }

                hDC = GetDC(GetParent(hWnd));
                CopyRect((LPRECT)&rcTemp, (LPRECT)rColorBox + temp);
                InflateRect((LPRECT)&rcTemp, 3, 3);
                DrawFocusRect(hDC, (LPRECT)&rcTemp);
                ReleaseDC(GetParent(hWnd), hDC);
            }
            break;
        }

        default:
            break;
    }

    return ((LONG)CallWindowProc(lpprocStatic, hWnd, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  MapColor
//
////////////////////////////////////////////////////////////////////////////

DWORD MapColor(
    PCOLORINFO pCI,
    DWORD rgb)
{
    if (pCI->pCC->Flags & CC_SOLIDCOLOR)
    {
        HDC hdc = GetDC(NULL);

        rgb = GetNearestColor(hdc, rgb);
        ReleaseDC(NULL, hdc);
    }

    return (rgb);
}


////////////////////////////////////////////////////////////////////////////
//
//  TermColor
//
////////////////////////////////////////////////////////////////////////////

VOID TermColor()
{
    if (hRainbowBitmap)
    {
        DeleteObject(hRainbowBitmap);
        hRainbowBitmap = NULL;
    }
    if (hDCFastBlt)
    {
        DeleteDC(hDCFastBlt);
        hDCFastBlt = 0;
    }
}






/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseColorA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkChooseColorA2W(
    PCOLORINFO pCI)
{
    LPCHOOSECOLORW pCCW = pCI->pCC;
    LPCHOOSECOLORA pCCA = pCI->pCCA;

    pCCW->lCustData = pCCA->lCustData;
    pCCW->Flags = pCCA->Flags;

    pCCW->hInstance = pCCA->hInstance;

    pCCW->lpfnHook = pCCA->lpfnHook;

    //
    //  CC_RGBINIT conditional = time it takes to do it => just do it.
    //
    pCCW->rgbResult = pCCA->rgbResult;

    pCCW->lpCustColors = pCCA->lpCustColors;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseColorW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkChooseColorW2A(
    PCOLORINFO pCI)
{
    LPCHOOSECOLORW pCCW = pCI->pCC;
    LPCHOOSECOLORA pCCA = pCI->pCCA;

    //
    //  Supposedly invariant, but not necessarily.
    //
    pCCA->Flags = pCCW->Flags;
    pCCA->lCustData = pCCW->lCustData;

    pCCA->lpfnHook = pCCW->lpfnHook;

    pCCA->rgbResult = pCCW->rgbResult;
    pCCA->lpCustColors = pCCW->lpCustColors;
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_CC_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_CC_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PCOLORINFO pCI;

    if (pCI = (PCOLORINFO)GetProp(hDlg, COLORPROP))
    {
        if (pCI->pCC && pCI->pCCA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkChooseColorA2W(pCI);
            }
            else
            {
                ThunkChooseColorW2A(pCI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\comdlg32.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    comdlg32.h

Abstract:

    This module contains the private header information for the Win32
    common dialogs.

Revision History:

--*/



#ifndef COMDLG_COMDLG32
#define COMDLG_COMDLG32

//
//  Include Files.
//
#include <w4warn.h>

/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4306) // 'type cast' : conversion from 'LANGID' to 'LPVOID ' of greater size
#pragma warning(disable:4245) // 'initializing' : conversion from 'HRESULT' to 'DWORD', signed/unsigned mismatch
#pragma warning(disable:4213) // nonstandard extension used : cast on l-value
#pragma warning(disable:4305) // 'type cast' : truncation from 'LPVOID ' to 'LANGID'
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4189) // 'hEnum' : local variable is initialized but not referenced
#pragma warning(disable:4057) // 'function' : 'const LPCSTR ' differs in indirection to slightly different base types f 'BYTE [32]'
#pragma warning(disable:4706) // assignment within conditional expression
#pragma warning(disable:4701) // local variable 'lFract' may be used without having been initialized
#pragma warning(disable:4702) // unreachable code

#include "isz.h"
#include "cderr.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//  Constant Declarations.
//

#define SEM_NOERROR               0x8003

//
//  There really should be no "max" path lengths, but for now,
//  since unc will take up RMLEN (lmcons.h), make it 98.
//
#define CCHUNCPATH                98
#define CCHNETPATH                358

#define MAX_THREADS               128

#define CHAR_A                    TEXT('a')
#define CHAR_CAP_A                TEXT('A')
#define CHAR_C                    TEXT('c')
#define CHAR_Z                    TEXT('z')
#define CHAR_NULL                 TEXT('\0')
#define CHAR_COLON                TEXT(':')
#define CHAR_BSLASH               TEXT('\\')
#define CHAR_DOT                  TEXT('.')
#define CHAR_QMARK                TEXT('?')
#define CHAR_STAR                 TEXT('*')
#define CHAR_SLASH                TEXT('/')
#define CHAR_SPACE                TEXT(' ')
#define CHAR_QUOTE                TEXT('"')
#define CHAR_PLUS                 TEXT('+')
#define CHAR_LTHAN                TEXT('<')
#define CHAR_BAR                  TEXT('|')
#define CHAR_COMMA                TEXT(',')
#define CHAR_LBRACKET             TEXT('[')
#define CHAR_RBRACKET             TEXT(']')
#define CHAR_EQUAL                TEXT('=')
#define CHAR_SEMICOLON            TEXT(';')

#define STR_BLANK                 TEXT("")
#define STR_SEMICOLON             TEXT(";")

#define IS_DOTEND(ch)   ((ch) == CHAR_DOT || (ch) == 0 || ((ch) != CHAR_STAR))

#define PARSE_DIRECTORYNAME       -1
#define PARSE_INVALIDDRIVE        -2
#define PARSE_INVALIDPERIOD       -3
#define PARSE_MISSINGDIRCHAR      -4
#define PARSE_INVALIDCHAR         -5
#define PARSE_INVALIDDIRCHAR      -6
#define PARSE_INVALIDSPACE        -7
#define PARSE_EXTENSIONTOOLONG    -8
#define PARSE_FILETOOLONG         -9
#define PARSE_EMPTYSTRING         -10
#define PARSE_WILDCARDINDIR       -11
#define PARSE_WILDCARDINFILE      -12
#define PARSE_INVALIDNETPATH      -13
#define PARSE_NOXMEMORY           -14

#define OF_FILENOTFOUND           2
#define OF_PATHNOTFOUND           3
#define OF_NOFILEHANDLES          4
#define OF_ACCESSDENIED           5         // OF_NODISKINFLOPPY
#define OF_WRITEPROTECTION        19
#define OF_SHARINGVIOLATION       32
#define OF_NETACCESSDENIED        65
#define OF_DISKFULL               82
#define OF_INT24FAILURE           83
#define OF_CREATENOMODIFY         96
#define OF_NODRIVE                97
#define OF_PORTNAME               98
#define OF_LAZYREADONLY           99
#define OF_DISKFULL2              112

#ifndef DCE_UNICODIZED
  #define DeviceCapabilitiesExA DeviceCapabilitiesEx
#endif

//
//  Used to determine which type of message to send to the app.
//
#define COMDLG_ANSI               0x0
#define COMDLG_WIDE               0x1

#define HNULL                     ((HANDLE) 0)

#define cbResNameMax              32
#define cbDlgNameMax              32




//
//  Platform specific definitions.
//

#ifdef WINNT
  #define IS16BITWOWAPP(p) ((p)->Flags & CD_WOWAPP)
#else
  #define IS16BITWOWAPP(p) (GetProcessDword(0, GPD_FLAGS) & GPF_WIN16_PROCESS)
#endif

#ifdef WX86
  #define ISWX86APP(p)            ((p)->Flags & CD_WX86APP)
  #define GETGENERICHOOKFN(p,fn)  (ISWX86APP(p) ? Wx86GetX86Callback((p)->fn) : (p)->fn)
#else
  #define ISWX86APP(p)            (FALSE)
  #define GETGENERICHOOKFN(p,fn)  ((p)->fn)
#endif

#define GETHOOKFN(p)            GETGENERICHOOKFN(p,lpfnHook)
#define GETPRINTHOOKFN(p)       GETGENERICHOOKFN(p,lpfnPrintHook)
#define GETSETUPHOOKFN(p)       GETGENERICHOOKFN(p,lpfnSetupHook)
#define GETPAGEPAINTHOOKFN(p)   GETGENERICHOOKFN(p,lpfnPagePaintHook)

#ifndef CD_WX86APP
  #define CD_WX86APP      (0)     // Nothing special if we don't have it defined
#endif




//
//  Typedef Declarations.
//




//
//  External Declarations.
//

extern HINSTANCE g_hinst;              // instance handle of library

extern SHORT cyCaption, cyBorder, cyVScroll;
extern SHORT cxVScroll, cxBorder, cxSize;

extern TCHAR szNull[];
extern TCHAR szStar[];
extern TCHAR szStarDotStar[];

extern BOOL bMouse;                    // system has a mouse
extern BOOL bCursorLock;
extern BOOL bWLO;                      // running with WLO
extern BOOL bDBCS;                     // running DBCS
extern WORD wWinVer;                   // windows version
extern WORD wDOSVer;                   // DOS version
extern BOOL g_bUserPressedCancel;        // user pressed cancel button

//
//  initialized via RegisterWindowMessage
//
extern UINT msgWOWLFCHANGE;
extern UINT msgWOWDIRCHANGE;
extern UINT msgWOWCHOOSEFONT_GETLOGFONT;

extern UINT msgLBCHANGEA;
extern UINT msgSHAREVIOLATIONA;
extern UINT msgFILEOKA;
extern UINT msgCOLOROKA;
extern UINT msgSETRGBA;
extern UINT msgHELPA;

extern UINT msgLBCHANGEW;
extern UINT msgSHAREVIOLATIONW;
extern UINT msgFILEOKW;
extern UINT msgCOLOROKW;
extern UINT msgSETRGBW;
extern UINT msgHELPW;

extern UINT g_cfCIDA;
extern DWORD g_tlsLangID;



//
//  Function Prototypes.
//

VOID TermFind(void);
VOID TermColor(void);
VOID TermFont(void);
VOID TermFile(void);
VOID TermPrint(void);

void FreeImports(void);

//
//  dlgs.c
//
VOID
HourGlass(
    BOOL bOn);

void
StoreExtendedError(
    DWORD dwError);

DWORD
GetStoredExtendedError(void);

HBITMAP WINAPI
LoadAlterBitmap(
    int id,
    DWORD rgbReplace,
    DWORD rgbInstead);

VOID
AddNetButton(
    HWND hDlg,
    HANDLE hInstance,
    int dyBottomMargin,
    BOOL bAddAccel,
    BOOL bTryLowerRight,
    BOOL bTryLowerLeft);

BOOL
IsNetworkInstalled(void);

int CDLoadStringEx(UINT uiCP, HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer, int nBufferMax);
int CDLoadString(HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer, int nBufferMax);

LANGID 
GetDialogLanguage(
    HWND hwndOwner, 
    HANDLE hDlgTemplate);

//
//  parse.c
//
int
ParseFileNew(
    LPTSTR pszPath,
    int *pnExtOffset,
    BOOL bWowApp,
    BOOL bNewStyle);

int
ParseFileOld(
    LPTSTR pszPath,
    int *pnExtOffset,
    int *pnOldExt,
    BOOL bWowApp,
    BOOL bNewStyle);

DWORD
ParseFile(
    LPTSTR lpstrFileName,
    BOOL bLFNFileSystem,
    BOOL bWowApp,
    BOOL bNewStyle);

LPTSTR
PathRemoveBslash(
    LPTSTR lpszPath);

BOOL
IsWild(
    LPCTSTR lpsz);

VOID
AppendExt(
    LPTSTR lpszPath,
    LPCTSTR lpExtension,
    BOOL bWildcard);

BOOL
IsUNC(
    LPCTSTR lpszPath);

BOOL
PortName(
    LPTSTR lpszFileName);

BOOL
IsDirectory(
    LPTSTR pszPath);

int
WriteProtectedDirCheck(
    LPCTSTR lpszFile);

BOOL
FOkToWriteOver(
    HWND hDlg,
    LPTSTR szFileName);

int
CreateFileDlg(
    HWND hDlg,
    LPTSTR szPath);




//
//  Fileopen specific stuff stashed here so we can free it upon
//  a DLL_PROCESS_DETACH.
//
typedef struct _OFN_DISKINFO {
    UINT   cchLen;           // number of chars allocated in 4 lptstrs
    LPTSTR lpAbbrName;       // single line form
    LPTSTR lpMultiName;      // drop-down form
    LPTSTR lpName;           // true form (for comparisons)
    LPTSTR lpPath;           // path prefix (a:, or \\server\share) for file searches
    TCHAR  wcDrive;          // drive letter, 0 for unc
    BOOL   bCasePreserved;
    DWORD  dwType;
    BOOL   bValid;
} OFN_DISKINFO;

#define MAX_DISKS                 100
#define WNETENUM_BUFFSIZE         0x4000

//
//  Defines for AddNetButton.
//
#define FILE_LEFT_MARGIN          5
#define FILE_RIGHT_MARGIN         3
#define FILE_TOP_MARGIN           0
#define FILE_BOTTOM_MARGIN        3


#ifdef WX86
  //
  // Wx86 support for calling from RISC into x86 hooks
  //
  PVOID
  Wx86GetX86Callback(
      PVOID lpfnHook);

  typedef PVOID
  (*PALLOCCALLBX86)(
      PVOID pfnx86,
      ULONG CBParamType,
      PVOID ThunkDebug,
      PULONG  pLogFlags);

  extern PALLOCCALLBX86 pfnAllocCallBx86;
#endif


#ifdef __cplusplus
};  // extern "C"
#endif


// For WOW support on WINNT
#ifdef WINNT
  VOID Ssync_ANSI_UNICODE_Struct_For_WOW(HWND hDlg, BOOL fDirection, DWORD dwID);
  VOID Ssync_ANSI_UNICODE_CC_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_CF_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_OFN_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_PD_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
#endif

// For nested FileOpen/Save common dialog support (something several 16-bit apps
// are known to do).  We keep a list of all the dialogs that are active for each
// thread in a process.  We make the assumption that common dialogs are THREAD
// modal -- so the first CURDLG struct in the list for a given thread is the
// currently active dialog (has the focus) for that thread.  The ptr to the head
// of the list is stored in the thread local storage (TLS) for the thread --
// indexed by g_tlsiCurDlg.  Bug #100453 et. al.
typedef struct _CURDLG {
  DWORD           dwCurDlgNum;     // incremental dlg number (per process)
  LPTSTR          lpstrCurDir;     // current directory for the current dialog
  struct _CURDLG *next;
} CURDLG;
typedef CURDLG *LPCURDLG;


//Macro to check if the given structure is the new structure.
#define IS_NEW_OFN(pOFN)  (pOFN->lStructSize >= sizeof(OPENFILENAME))

// moved from prnsetup.h
#define DN_PADDINGCHARS           16             // extra devnames padding

//
// Some local constants taken from printui.dll
//
enum 
{
    //
    // INTERNET_MAX_HOST_NAME_LENGTH is decalred in wininet.h
    //
    kDNSMax = INTERNET_MAX_HOST_NAME_LENGTH,
    kServerBufMax = kDNSMax + 2 + 1,

    //
    // Max printer name should really be MAX_PATH, but if you create
    // a max path printer and connect to it remotely, win32spl prepends
    // "\\server\" to it, causing it to exceed max path.  The new UI
    // therefore makes the max path MAX_PATH-kServerLenMax, but we still
    // allow the old case to work.
    //
    kPrinterBufMax = MAX_PATH + kServerBufMax + 1,

    //
    // The initial hint for EnumPrinters API.
    //
    kInitialPrinterHint = 0x400,
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
ThunkDevNamesA2W(
    IN      HGLOBAL hDevNamesA,
    IN OUT  HGLOBAL *phDevNamesW
    );

HRESULT
ThunkDevNamesW2A(
    IN      HGLOBAL hDevNamesW,
    IN OUT  HGLOBAL *phDevNamesA
    );

HRESULT 
InvokeAddPrinterWizardModal(
    IN  HWND hwnd,
    OUT BOOL *pbPrinterAdded
    );

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // !COMDLG_COMDLG32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\d32tlog.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    tlog.h

Abstract:

    This module implements the travel log functionality for file open
    and save as dialogs.

Revision History:
    02-20-98          arulk                 created

--*/
#ifndef _TLOG_H_
#define _TLOG_H_

#ifdef __cplusplus

#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>


//
//  Defines for Travel Log.
//
#define TRAVEL_BACK             0x0001
#define TRAVEL_FORWARD          0x0002



//--------------------------------------------------------------------
//Travel Log Link Class Definition
//--------------------------------------------------------------------
class TLogLink
{
public:
    TLogLink();
    TLogLink(LPITEMIDLIST pidl);    
    ~TLogLink();
    UINT AddRef();
    UINT Release();
    TLogLink *GetNextLink() { return _ptllNext;};
    TLogLink *GetPrevLink() { return _ptllPrev;};

    void SetNextLink(TLogLink* ptllNext);    

    HRESULT GetPidl(LPITEMIDLIST* ppidl);    
    HRESULT SetPidl(LPITEMIDLIST pidl);

    BOOL    CanTravel(int iDir);


private:
    UINT _cRef;
    LPITEMIDLIST _pidl;
    TLogLink * _ptllPrev;
    TLogLink * _ptllNext;
};



//------------------------------------------------------------------------
//Travel Log Class Definition
//------------------------------------------------------------------------
class TravelLog
{
public:
    friend HRESULT Create_TravelLog(TravelLog *pptlog);
    TravelLog();
    ~TravelLog();
    UINT AddRef();
    UINT Release();
    HRESULT AddEntry(LPITEMIDLIST pidl);
    BOOL CanTravel(int iDir);
    HRESULT Travel(int iDir);
    HRESULT GetCurrent(LPITEMIDLIST *ppidl);

private:
    UINT _cRef;
    TLogLink *_ptllCurrent;
    TLogLink *_ptllRoot;
};

#endif //_cplusplus

#ifdef _cplusplus
extern "C" {
#endif //_cplusplus

HRESULT Create_TravelLog(TravelLog **pptlog);

#ifdef _cplusplus
extern "C"
};
#endif //_cplusplus

#endif //_TLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\d32tlog.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    tlog.cpp

Abstract:

    This module implements the travel log functionality for file open
    and save as dialogs.

Revision History:
    02-20-98          arulk                 created

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "util.h"
#include "d32tlog.h"

//-------------------------------------------------------------------------
// Travel Log Link implementation
//-------------------------------------------------------------------------

TLogLink::TLogLink()
:_cRef(1), _pidl(NULL), _ptllNext(NULL), _ptllPrev(NULL)
{
}


TLogLink::TLogLink(LPITEMIDLIST  pidl)
:_cRef(1), _pidl(NULL), _ptllNext(NULL), _ptllPrev(NULL)
{
    _pidl = ILClone(pidl);
}

TLogLink::~TLogLink()
{
    if (_pidl)
    {
        ILFree(_pidl);
    }

    if (_ptllNext)
    {
        _ptllNext->Release();
    }
}

UINT TLogLink::AddRef()
{
    return ++_cRef;
}

UINT TLogLink::Release()
{
    if (--_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


void TLogLink::SetNextLink(TLogLink* ptllNext)
{
    //Do we already have Next Link ?
    if (_ptllNext)
    {
        // Release the next link
        _ptllNext->Release();
    }

    //Set the given pointer as our next pointer
    _ptllNext = ptllNext;

    if (_ptllNext)
    {
        //Since we are caching the pointer , Add reference to it
        _ptllNext->AddRef();

        //Also update the prev link of our new pointer to point to us
        _ptllNext->_ptllPrev = this;
    }
}


HRESULT TLogLink::GetPidl(LPITEMIDLIST* ppidl)
{
    *ppidl = ILClone(_pidl);
    if (*ppidl)
        return NOERROR;
    else {
        return E_OUTOFMEMORY;
    }
}

HRESULT TLogLink::SetPidl(LPITEMIDLIST pidl)
{
    if (_pidl)
    {
        ILFree(_pidl);
    }
    _pidl = ILClone(pidl);
    return NOERROR;
}

BOOL TLogLink::CanTravel(int iDir)
{
    BOOL fRet = FALSE;
    switch ( iDir )
    {
        case ( TRAVEL_BACK ) :
        {
            if (_ptllPrev != NULL)
            {
                fRet = TRUE;
            }
            break;
        }

        case ( TRAVEL_FORWARD ) :
        {
            if (_ptllNext !=NULL)
            {
                fRet = TRUE;
            }
            break;
        }
    }

    return fRet;
}


//----------------------------------------------------------------------------------
//Travel Log Class  Implementation
//----------------------------------------------------------------------------------

TravelLog::TravelLog()
:_cRef(1),_ptllCurrent(NULL), _ptllRoot(NULL)
{
}


TravelLog::~TravelLog()
{
    if (_ptllRoot)
    {
        _ptllRoot->Release();
    }
}

UINT TravelLog::AddRef()
{
   return  ++_cRef;
}


UINT TravelLog::Release()
{
    if (--_cRef > 0 )
        return _cRef;

    delete this;
    return 0;
}


HRESULT TravelLog::AddEntry(LPITEMIDLIST pidl)
{
    TLogLink  *ptll =  new TLogLink(pidl);
    if (!ptll)
        return E_FAIL;

    if (_ptllCurrent) {
        _ptllCurrent->SetNextLink(ptll);
        ptll->Release();
    }
    else
    {
        _ptllRoot = ptll;
    }

    _ptllCurrent = ptll;
    
    return NOERROR;
}


BOOL TravelLog::CanTravel(int iDir)
{
    if (_ptllCurrent)
    {
        return _ptllCurrent->CanTravel(iDir);
    }
    return FALSE;
}

HRESULT TravelLog::Travel(int iDir)
{
    HRESULT hres = E_FAIL;
    TLogLink *ptll;
    switch(iDir)
    {
        case ( TRAVEL_FORWARD ) :
        {
            if (CanTravel(iDir))
            {
                ptll = _ptllCurrent->GetNextLink();
                _ptllCurrent = ptll;
                hres = NOERROR;
            }
            break;

        }

        case ( TRAVEL_BACK ):
        {
            if (CanTravel(iDir))
            {
                ptll = _ptllCurrent->GetPrevLink();
                _ptllCurrent = ptll;
                hres = NOERROR;
            }
            break;

        }
    }

    return hres;
}


HRESULT TravelLog::GetCurrent(LPITEMIDLIST *ppidl)
{
    //Set the return value. Just in case
    *ppidl = NULL;
    if (_ptllCurrent)
    {
        return _ptllCurrent->GetPidl(ppidl);
        
    }
    return E_FAIL;
}

HRESULT Create_TravelLog(TravelLog **pptlog)
{
    HRESULT hres = E_FAIL;
    *pptlog = new TravelLog();

    if (*pptlog)
    {
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\debug.c ===
// precompiled headers
#include "precomp.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "comdlg32"
#define SZ_MODULE           "COMDLG32"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\data.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    data.c

Abstract:

    This module contains the global data for the Win32 common dialogs.
    Anything added here must have 'extern' added to privcomd.h.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop


//
//  Global Variables.
//

//
//  FileOpen
//
TCHAR szOEMBIN[]        = TEXT("OEMBIN");
TCHAR szNull[]          = TEXT("");
TCHAR szStar[]          = TEXT("*");
TCHAR szStarDotStar[12] = TEXT("*.*");
TCHAR szDotStar[]       = TEXT(".*");

RECT g_rcDlg;

TCHAR g_szInitialCurDir[MAX_PATH];


//
//  Color
//
DWORD rgbClient;
WORD gHue, gSat, gLum;
HBITMAP hRainbowBitmap;
BOOL bMouseCapture;
WNDPROC lpprocStatic;
SHORT nDriverColors;
BOOL g_bUserPressedCancel;

HWND hSave;

WNDPROC qfnColorDlg = NULL;
HDC hDCFastBlt = NULL;

SHORT cyCaption, cyBorder, cyVScroll;
SHORT cxVScroll, cxBorder, cxSize;
SHORT nBoxHeight, nBoxWidth;


//
//  dlgs.c
//
HINSTANCE g_hinst = NULL;

BOOL bMouse;                      // system has a mouse
BOOL bCursorLock;
WORD wWinVer;                     // Windows version
WORD wDOSVer;                     // DOS version

UINT msgHELPA;                    // initialized using RegisterWindowMessage
UINT msgHELPW;                    // initialized using RegisterWindowMessage

HDC hdcMemory = HNULL;            // temp DC used to draw bitmaps
HBITMAP hbmpOrigMemBmp = HNULL;   // bitmap originally selected into hdcMemory

OFN_DISKINFO gaDiskInfo[MAX_DISKS];

CRITICAL_SECTION g_csLocal;
CRITICAL_SECTION g_csNetThread;

DWORD dwNumDisks;

HANDLE hMPR;
HANDLE hMPRUI;
HANDLE hLNDEvent;

DWORD g_tlsiCurDlg;    // TLS index used to get the ptr to current CURDLG struct
                       // for each thread (see CURDLG in comdlg32.h)

DWORD g_tlsiExtError;  // ExtErrors are the most recent error per thread.

DWORD g_tlsLangID;     // TLS index used to get the current LangID for each thread.

DWORD cbNetEnumBuf;
LPTSTR gpcNetEnumBuf;

#ifdef WX86
  PALLOCCALLBX86 pfnAllocCallBx86;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\filemru.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filemru.cpp

Abstract:

    This module contains the functions for implementing file mru
    in file open and file save dialog boxes

Revision History:
    01/22/98                arulk                   created
 
--*/


#define MAX_MRU   25
BOOL  LoadMRU(LPCTSTR pszFilter, HWND hwndCombo, int nMax);
BOOL  AddToMRU(LPOPENFILENAME lpOFN);

BOOL GetPathFromLastVisitedMRU(LPTSTR pszDir, DWORD cchDir);
BOOL AddToLastVisitedMRU(LPCTSTR pszFile, int nFileOffset);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\filenew.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filenew.h

Abstract:

    This module contains the header information for the new Win32 fileopen
    dialogs.

Revision History:

--*/



#undef StrCpy
#undef StrCat



#include "d32tlog.h"

////////////////////////////////////////////////////////////////////////////
//
//  TEMPMEM class
//
////////////////////////////////////////////////////////////////////////////

class TEMPMEM
{
public:
    TEMPMEM(UINT cb)
    {
        m_uSize = cb;
        m_pMem = cb ? LocalAlloc(LPTR, cb) : NULL;
    }

    ~TEMPMEM()
    {
        if (m_pMem)
        {
            LocalFree(m_pMem);
        }
    }

    operator LPBYTE() const
    {
        return ((LPBYTE)m_pMem);
    }

    BOOL Resize(UINT cb);

private:
    LPVOID m_pMem;

protected:
    UINT m_uSize;
};


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR class
//
////////////////////////////////////////////////////////////////////////////

class TEMPSTR : public TEMPMEM
{
public:
    TEMPSTR(UINT cc = 0) : TEMPMEM(cc * sizeof(TCHAR))
    {
    }

    operator LPTSTR() const
    {
        return ((LPTSTR)(LPBYTE) * (TEMPMEM *)this);
    }

    BOOL StrCpy(LPCTSTR pszText);
    BOOL StrCat(LPCTSTR pszText);
    BOOL StrSize(UINT cb)
    {
        return (TEMPMEM::Resize(cb * sizeof(TCHAR)));
    }
};


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM class
//
//  One object of this class exists for each item in the location dropdown.
//
//  Data members:
//    psfSub   - instance of IShellFolder bound to this container
//    pidlThis - IDL of this container, relative to its parent
//    pidlFull - IDL of this container, relative to the desktop
//    cIndent  - indent level (0-based)
//    dwFlags  -
//        MLBI_PERMANENT - item is an "information source" and should
//                         always remain
//    dwAttrs  - attributes of this container as reported by GetAttributesOf()
//    iImage, iSelectedImage - indices into the system image list for this
//                             object
//
//  Member functions:
//    ShouldInclude() - returns whether item belongs in the location dropdown
//    IsShared() - returns whether an item is shared or not
//    SwitchCurrentDirectory() - changes the Win32 current directory to the
//                               directory indicated by this item
//
////////////////////////////////////////////////////////////////////////////

class MYLISTBOXITEM
{
public:
    IShellFolder *psfSub;
    IShellFolder *psfParent;
    LPITEMIDLIST pidlThis;
    LPITEMIDLIST pidlFull;
    DWORD cIndent;
    DWORD dwFlags;
    DWORD dwAttrs;
    int iImage;
    int iSelectedImage;
    HWND _hwndCmb;

    MYLISTBOXITEM();
    ULONG AddRef();
    ULONG Release();

    BOOL Init( HWND hwndCmb,
               MYLISTBOXITEM *pParentItem,
               IShellFolder *psf,
               LPCITEMIDLIST pidl,
               DWORD c,
               DWORD f,
               IShellTaskScheduler* pScheduler);

    //This function is used to initialize all members directly.
    BOOL Init(HWND hwndCmb, IShellFolder *psf, LPCITEMIDLIST pidl, DWORD c, DWORD f, DWORD dwAttrs, int iImage,
                int iSelectedImage);

    inline BOOL ShouldInclude()
    {
        return (dwAttrs & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM));
    }

    inline BOOL IsShared()
    {
        return (dwAttrs & SFGAO_SHARE);
    }

    void SwitchCurrentDirectory(ICurrentWorkingDirectory * pcwd);

    IShellFolder* GetShellFolder();

    static  void CALLBACK _AsyncIconTaskCallback(LPCITEMIDLIST pidl, LPVOID pvData, LPVOID pvHint, INT iIconIndex, INT iOpenIconIndex);

private:
    ~MYLISTBOXITEM();
    LONG _cRef;
};


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser class
//
////////////////////////////////////////////////////////////////////////////

typedef BOOL (*EIOCALLBACK)(class CFileOpenBrowser*that, LPCITEMIDLIST pidl, LPARAM lParam);

typedef enum
{
    ECODE_S_OK     = 0,
    ECODE_BADDRIVE = 1,
    ECODE_BADPATH  = 2,
} ECODE;

typedef enum
{
    OKBUTTON_NONE     = 0x0000,
    OKBUTTON_NODEFEXT = 0x0001,
    OKBUTTON_QUOTED   = 0x0002,
} OKBUTTON_FLAGS;
typedef UINT OKBUTTONFLAGS;


typedef struct _SHTCUTINFO
{
    BOOL            fReSolve;           //[IN]      Should we resolve the shortcut
    DWORD           dwAttr;             //[IN/OUT]  Attributes of the target pointed by shortcut
    LPTSTR          pszLinkFile;        //[OUT]     Target file name
    UINT            cchFile;            //[IN]      size of buffer pointed to by pszLinkFile
    LPITEMIDLIST *  ppidl;               //[OUT]     pidl of the  target pointed to by shortcut
}SHTCUTINFO, *PSHTCUTINFO;

typedef enum   
{
    LOCTYPE_RECENT_FOLDER = 1,
    LOCTYPE_MYPICTURES_FOLDER = 2,
    LOCTYPE_OTHERS = 3,
    LOCTYPE_WIA_FOLDER = 4
}LOCTYPE;


class CFileOpenBrowser
                : public IShellBrowser
                , public ICommDlgBrowser2
                , public IServiceProvider
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND *lphwnd);
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode);

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode, LPSTREAM *pStrm);
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND *lphwnd);
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView *pshv);
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView *ppshv);
    STDMETHOD(OnStateChange) (THIS_ struct IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ struct IShellView *ppshv, LPCITEMIDLIST lpItem);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(Notify) (THIS_ struct IShellView *ppshv, DWORD dwNotifyType);
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView *ppshv, WCHAR *pszText, INT cchMax);
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_ REFGUID guidService, REFIID riid, LPVOID* ppvObj);


    // *** Our own methods ***
    CFileOpenBrowser(HWND hDlg, BOOL fIsSaveAs);
    ~CFileOpenBrowser();
    HRESULT SwitchView(struct IShellFolder *psfNew, LPCITEMIDLIST pidlNew, FOLDERSETTINGS *pfs, SHELLVIEWID const *pvid, BOOL fUseDefultView);
    void OnDblClick(BOOL bFromOKButton);
    LRESULT OnNotify(LPNMHDR lpnmhdr);
    BOOL OnSetCursor(void);
    void ViewCommand(UINT uIndex);
    void PaintDriveLine(DRAWITEMSTRUCT *lpdis);
    void GetFullPath(LPTSTR pszBuf);
    BOOL OnSelChange(int iItem = -1, BOOL bForceUpdate = FALSE);
    void OnDotDot();
    void RefreshFilter(HWND hwndFilter);
    BOOL JumpToPath(LPCTSTR pszDirectory, BOOL bTranslate = FALSE);
    BOOL JumpToIDList(LPCITEMIDLIST pidlNew, BOOL bTranslate = FALSE, BOOL bAddToNavStack = TRUE);
    BOOL SetDirRetry(LPTSTR pszDir, BOOL bNoValidate = FALSE);
    BOOL MultiSelectOKButton(LPCTSTR pszFiles, OKBUTTONFLAGS Flags);
    BOOL OKButtonPressed(LPCTSTR pszFile, OKBUTTONFLAGS Flags);
    UINT GetDirectoryFromLB(LPTSTR szBuffer, int *pichRoot);
    void SetCurrentFilter(LPCTSTR pszFilter, OKBUTTONFLAGS Flags = OKBUTTON_QUOTED);
    UINT GetFullEditName(LPTSTR pszBuf, UINT cLen, TEMPSTR *pTempStr = NULL, BOOL *pbNoDefExt = NULL);
    void ProcessEdit();
    LRESULT OnCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL OnCDMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void RemoveOldPath(int *piNewSel);
    BOOL LinkMatchSpec(LPCITEMIDLIST pidl, LPCTSTR szSpec);
    BOOL GetLinkStatus(LPCITEMIDLIST pidl,PSHTCUTINFO pinfo);
    HRESULT ResolveLink(LPCITEMIDLIST pidl, PSHTCUTINFO pinfo, IShellFolder *psf = NULL);
    void SelFocusChange(BOOL bSelChange);
    void SelRename(void);
    void SetSaveButton(UINT idSaveButton);
    void RealSetSaveButton(UINT idSaveButton);
    void SetEditFile(LPCTSTR pszFile, LPCTSTR pszFileFriendly, BOOL bShowExt, BOOL bSaveNullExt = TRUE);
    BOOL EnumItemObjects(UINT uItem, EIOCALLBACK pfnCallBack, LPARAM lParam);
    BOOL IsKnownExtension(LPCTSTR pszExtension);
    UINT FindNameInView(LPTSTR pszFile, OKBUTTONFLAGS Flags, LPTSTR pszPathName,
                        int nFileOffset, int nExtOffset, int *pnErrCode,
                        BOOL bTryAsDir = TRUE);
    void UpdateLevel(HWND hwndLB, int iInsert, MYLISTBOXITEM *pParentItem);
    void InitializeDropDown(HWND hwndCtl);
    BOOL FSChange(LONG lNotification, LPCITEMIDLIST *ppidl);
    int GetNodeFromIDList(LPCITEMIDLIST pidl);
    void Timer(WPARAM wID);
    BOOL CreateHookDialog(POINT *pPtSize);
    void OnGetMinMax(LPMINMAXINFO pmmi);
    void OnSize(int, int);
    void VerifyListViewPosition(void);
    BOOL CreateToolbar();     // Creates the file open toolbar
    void EnableFileMRU(BOOL fEnable);  // Enable/Disable File MRU based on the flag passed
    void UpdateNavigation();           // Updates the Navigation by adding the current pidl 
                                       // to the navigation stack
    void UpdateUI(LPITEMIDLIST pidlNew);  // Updates the back navigation button and the hot item on the places bar
    LPCTSTR JumpToInitialLocation(LPCTSTR pszDir, LPTSTR pszFile);
    BOOL    InitLookIn(HWND hDlg);      //Initializes the look in drop down.

    int _CopyFileNameToOFN(LPTSTR pszFile, DWORD *pdwError);
    void _CopyTitleToOFN(LPCTSTR pszTitle);

    BOOL _IsNoDereferenceLinks(LPCWSTR pszFile, IShellItem *psi);
    BOOL _OpenAsContainer(IShellItem *psi, SFGAOF sfgao);

    HRESULT _ParseName(LPCITEMIDLIST pidlParent, IShellFolder *psf, IBindCtx *pbc, LPCOLESTR psz, IShellItem **ppsi);
    HRESULT _ParseNameAndTest(LPCOLESTR pszIn, IBindCtx *pbc, IShellItem **ppsi, BOOL fAllowJump);
    HRESULT _ParseShellItem(LPCOLESTR pszIn, IShellItem **ppsi, BOOL fAllowJump);
    HRESULT _TestShellItem(IShellItem *psi, BOOL fAllowJump, IShellItem **ppsiReal);
#ifdef RETURN_SHELLITEMS
    HRESULT _ItemOKButtonPressed(LPCTSTR pszFile, OKBUTTONFLAGS Flags);
    HRESULT _ProcessShellItem(IShellItem *psi);
#endif RETURN_SHELLITEMS    
    HRESULT _MakeFakeCopy(IShellItem *psi, LPWSTR *ppszPath);
    
    BOOL    CheckForRestrictedFolder(LPCTSTR lpszPath, int nFileOffset); //Checks to see whether a file can be saved in the given path.
                                                        
    void ResetDialogHeight(HWND hDlg, HWND hwndExclude, HWND hwndGrip, int nCtlsBottom);
    void ReAdjustDialog();              // if help and open as read only is hidden then this function readjusts the dialog
                                        // to reclaim the space occupied by these controls

    //Places Bar Related Functions
    HWND CreatePlacesbar(HWND hDlg);    // Creates places bar
    void _RecreatePlacesbar();
    void _CleanupPlacesbar();
    void _FillPlacesbar(HWND hwndPlacesbar);
    BOOL _EnumPlacesBarItem(HKEY hkey, int i , SHFILEINFO *psfi, LPITEMIDLIST *ppidl);
    BOOL _GetPlacesBarItemToolTip(int idCmd, LPTSTR pText, DWORD dwSize);
    BOOL _GetPBItemFromTokenStrings(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl);
    BOOL _GetPBItemFromCSIDL(DWORD csidl, SHFILEINFO * psfi, LPITEMIDLIST *ppidl);
    BOOL _GetPBItemFromPath(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl);

    //Pidl Processing Functions
    BOOL _ProcessPidlSelection();           //Processes the selection pidl if any.
    HRESULT _ProcessItemAsFile(IShellItem *psi);

    //General Utility Functions
    BOOL _ValidateSelectedFile(LPCTSTR pszFile, int *pErrCode);
    BOOL _PostProcess(LPTSTR pszFile);
    BOOL _IsThumbnailFolder(LPCITEMIDLIST pidl);
    BOOL _IsWIAFolder(IShellFolder *psf);
    LOCTYPE _GetLocationType(MYLISTBOXITEM *pLocation);
    void _WaitCursor(BOOL fWait);
    BOOL CFileOpenBrowser::_IsRestrictedDrive(LPCTSTR pszPath, LPCITEMIDLIST pidl);
    void CFileOpenBrowser::JumpToLocationIfUnrestricted(LPCTSTR pszPath, LPCITEMIDLIST pidl, BOOL bTranslate);
    BOOL CFileOpenBrowser::_SaveAccessDenied(LPCTSTR pszFile);
    void _CleanupDialog(BOOL fRet);

    void OnThemeActive(HWND hwndDlg, BOOL bActive);
    
    //Member Variables
    LONG _cRef;                             // compobj refcount
    int _iCurrentLocation;                   // index of curr selection in location dropdown
    int _iVersion;                           //  Which version of dialog are we showing
    MYLISTBOXITEM *_pCurrentLocation;        // ptr to object for same
    HWND _hwndDlg;                           // handle of this dialog
    HWND _hSubDlg;                           // handle of the hook dialog
    IShellView *_psv;                        // current view object
    IShellFolder *_psfCurrent;               // current shellfolder object
    TravelLog    *_ptlog;                    // ptr to travel log
    HWND _hwndView;                          // current view window
    HWND _hwndToolbar;                       // toolbar window
    HWND _hwndPlacesbar;                     // places bar window
    HWND _hwndLastFocus;                     // ctrl that had focus before OK button
    HIMAGELIST _himl;                        // system imagelist (small images)
    TEMPSTR _pszHideExt;                     // saved file with extension
    TEMPSTR _tszDefSave;                     // saved file with extension
    TEMPSTR _pszDefExt;                      // writable version of the DefExt
    TEMPSTR _pszObjectPath;                  // full object path
    TEMPSTR _pszObjectCurDir;                // object current directory (folder)
    UINT _uRegister;
    int _iComboIndex;
    int _iNodeDrives;                        // location of my computer in drop down
    int _iNodeDesktop;                       // location of  Desktop in drop down
    int _iCommandID;                         // Next command id to use for a Placebar Item
    int _iCheckedButton;                     // if > 0 tells which places bar button is checked

    BOOL _bEnableSizing;                     // if sizing is enabled
    BOOL _bUseCombo;                         // Use the edit window instead of comboxex for app compatibility
    POINT _ptLastSize;                       // last known size of dialog
    POINT _ptMinTrack;                       // initial size of view
    SIZE _sizeView;                          // last known size of view
    HWND _hwndGrip;                          // window handle of sizing grip
    DWORD _dwPlacesbarPadding;               // default placesbar toolbar padding

    LPOPENFILENAME _pOFN;                   // caller's OPENFILENAME struct

    BOOL _bSave : 1;                         // whether this is a save-as dialog
    BOOL _fShowExtensions : 1;               // whether to show extensions
    BOOL _bUseHideExt : 1;                   // whether pszHideExt is valid
    BOOL _bDropped : 1;
    BOOL _bNoInferDefExt : 1;                // don't get defext from combo
    BOOL _fSelChangedPending : 1;            // we have a selchanging message pending
    BOOL _bSelIsObject : 1;                  // the last selected object is an object, not a file
    BOOL _bUseSizeView : 1;                  // only use cached size after failure to create view...
    BOOL _bAppRedrawn : 1;                   // Did app call RedrawWindow? - see ResetDialogHeight
    BOOL _bDestroyPlacesbarImageList : 1;    // Free placesbar imagelist first time only
    HWND _hwndTips;                          // hWnd of tooltip control for this window

    LPOPENFILEINFO _pOFI;                   // info for thunking (ansi callers only)
    ICurrentWorkingDirectory * _pcwd;        // Interface to AutoComplete COM Object that sets CurrentWorkingDir
    UINT _CachedViewMode;                   // we force Some folders into specific views.  this caches the users choice
    UINT _fCachedViewFlags;                 // we also need to cache the view flags.

    // Apphack for Borland JBuilder Professional - see ResetDialogHeight
    int  _topOrig;                           // original window top

    LPITEMIDLIST _pidlSelection;                // This is currently selected items pidl.

    IShellTaskScheduler* _pScheduler;       // This TaskScheduler is used to do delayed Icon extractions.
    int _cWaitCursor;
    LONG _cRefCannotNavigate;
    HWND _hwndModelessFocus;
    WNDPROC _lpOKProc;

    // Perf: Big structures go at the end
    TCHAR _szLastFilter[MAX_PATH + 1];       // last filter chosen by the user
    TCHAR _szStartDir[MAX_PATH + 1];         // saved starting directory
    TCHAR _szCurDir[MAX_PATH + 1];           // currently viewed dir (if FS)
    TCHAR _szBuf[MAX_PATH + 4];              // scratch buffer
    TCHAR _szTipBuf[MAX_PATH + 1];           // tool tip buffer

    ////////////////////////////////////////////////////////////////////////////
    //
    //  WAIT_CURSOR class
    //
    ////////////////////////////////////////////////////////////////////////////

    class WAIT_CURSOR
    {
    private:
        CFileOpenBrowser *_that;
    public:
        WAIT_CURSOR(CFileOpenBrowser *that) : _that(that)
        {
            _that->_WaitCursor(TRUE);
        }

        ~WAIT_CURSOR()
        {
            _that->_WaitCursor(FALSE);
        }
    };


};

#define VIEW_JUMPDESKTOP    (VIEW_NEWFOLDER + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\filemru.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filemru.cpp

Abstract:

    This module contains the functions for implementing file mru
    in file open and file save dialog boxes

Revision History:
    01/22/98                arulk                   created
 
--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "filemru.h"

#ifndef ASSERT
#define ASSERT Assert
#endif

#define REGSTR_PATH_FILEMRU     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\OpenSaveMRU\\")
#define REGSTR_PATH_LASTVISITED  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\LastVisitedMRU\\")

HANDLE CreateMRU(LPCTSTR pszExt, int nMax)
{
    TCHAR szRegPath[256];
    MRUINFO mi =  {
        sizeof(MRUINFO),
        nMax,
        MRU_CACHEWRITE,
        HKEY_CURRENT_USER,
        szRegPath,
        NULL        // NOTE: use default string compare
    };

    //Get the Registry path for the given file type MRU
    lstrcpy(szRegPath,REGSTR_PATH_FILEMRU);
    StrCatBuff(szRegPath, pszExt ? pszExt : TEXT("*"), ARRAYSIZE(szRegPath));
    
    //Call the comctl32 mru implementation to load the MRU from
    //the registry
    return CreateMRUList(&mi);
}

BOOL GetMRUEntry(HANDLE hMRU, int iIndex, LPTSTR lpString, UINT cbSize)
{
     //Check for valid parameters
     if(!lpString || !cbSize || !hMRU)
     { 
         return FALSE;
     }
     
    //Check for valid index
    if (iIndex < 0 || iIndex > EnumMRUList(hMRU, -1, NULL, 0))
    {
        return FALSE;
    }

    if ((EnumMRUList(hMRU, iIndex, lpString, cbSize) > 0 ))
    {
        return TRUE;
    }
    return FALSE;
}

typedef struct {
    HANDLE mru;
    LPTSTR psz;
} EXTMRU, *PEXTMRU;

STDAPI_(int) _FreeExtMru(void * pvItem, void * pvData)
{
    PEXTMRU pem = (PEXTMRU) pvItem;

    if (pem)
    {
        ASSERT(pem->psz);
        ASSERT(pem->mru);

        LocalFree(pem->psz);
        FreeMRUList(pem->mru);

        LocalFree(pem);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(int) _ExtMruFindExt(void * pvFind, void * pvItem, LPARAM pvParam)
{
    ASSERT(pvFind && pvItem);

    return StrCmp(((PEXTMRU)pvItem)->psz, (LPCTSTR)pvFind);
}

PEXTMRU _AllocExtMru(LPCTSTR pszExt, int nMax)
{
    PEXTMRU pem = (PEXTMRU) LocalAlloc(LPTR, SIZEOF(EXTMRU));

    if (pem)
    {
        pem->psz = StrDup(pszExt);
        pem->mru = CreateMRU (pszExt, nMax);

        if (pem->psz && pem->mru)
            return pem;

        _FreeExtMru(pem, NULL);
    }

    return NULL;
}

        
        
HDPA _CreateExtMruDpa(LPCTSTR pszFilter, int nMax, int *pcItems)
{
    //Convert the filter string of form *.c;*.cpp;*.h into form
    // *.c\0*.cpp\0*.h\0. Also count the file types

    LPTSTR pszFree = StrDup(pszFilter);
    *pcItems = 0;

    if (pszFree)
    {
        HDPA hdpa = DPA_Create(4);

        if (hdpa)
        {
            LPTSTR pszNext = pszFree;
            int cItems = 0;
            LPTSTR pszSemi;
            do
            {
                pszSemi = StrChr(pszNext, CHAR_SEMICOLON);

                if (pszSemi) 
                    *pszSemi = CHAR_NULL;
                    
                LPTSTR pszExt = PathFindExtension(pszNext);

                if (*pszExt)
                {
                    //  walk past the dot...
                    pszExt++;

                    //  make sure this extension isnt already in the dpa
                    if (-1 == DPA_Search(hdpa, pszExt, 0, _ExtMruFindExt, NULL, 0))
                    {
                        PEXTMRU pem = _AllocExtMru(pszExt, nMax);
                        if (!pem)
                            break;

                        DPA_SetPtr(hdpa, cItems++,  (void *)pem);
                    }
                }

                //  we only have a next if there was more than one...
                if (pszSemi)
                    pszNext = pszSemi + 1;    
                    
            } while (pszSemi);

            *pcItems = cItems;
        }

        LocalFree(pszFree);
        return hdpa;
    }

    return NULL;
}

BOOL LoadMRU(LPCTSTR pszFilter, HWND hwndCombo, int nMax)
{   
    //Check if valid filter string is passed
    if (!pszFilter || !pszFilter[0] || nMax <= 0)
    {
        return FALSE;
    }
    
    //First reset the hwndCombo
    SendMessage(hwndCombo, CB_RESETCONTENT, (WPARAM)0L, (LPARAM)0L);

    int cDPAItems;   
    HDPA hdpa = _CreateExtMruDpa(pszFilter, nMax, &cDPAItems);

    if (hdpa)
    {
        TCHAR szFile[MAX_PATH];
        //Set the comboboxex item values
        COMBOBOXEXITEM  cbexItem = {0};
        cbexItem.mask = CBEIF_TEXT;                 // This combobox displays only text
        cbexItem.iItem = -1;                        // Always insert the item at the end
        cbexItem.pszText = szFile;                  // This buffer contains the string
        cbexItem.cchTextMax = ARRAYSIZE(szFile);    // Size of the buffer

        //Now load the hwndcombo with file list from MRU.
        //We use a kind of round robin algorithm for filling
        //the mru. We start with first MRU and try to fill the combobox
        //with one string from each mru. Until we have filled the required
        //strings or we have exhausted all strings in the mrus

        for (int j = 0; nMax > 0; j++)
        {
            //Variable used for checking whether we are able to load atlease one string
            //during the loop
            BOOL fCouldLoadAtleastOne = FALSE;

            for (int i = 0; i < cDPAItems && nMax > 0; i++)
            {
                PEXTMRU pem = (PEXTMRU)DPA_FastGetPtr(hdpa, i);

                if (pem && GetMRUEntry(pem->mru, j, szFile, SIZECHARS(szFile)))
                {
                    SendMessage(hwndCombo, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(void *)&cbexItem);
                    nMax--;
                    fCouldLoadAtleastOne = TRUE;
                }
            }

            //Check for possible infinite loop
            if(!fCouldLoadAtleastOne)
            {
                //We couldn't load string from any of the MRU's so there's no point
                //in continuing this loop further. This is the max number of strings 
                // we can load for this user, for this filter type.
                break;
            }
        }

        DPA_DestroyCallback(hdpa, _FreeExtMru, NULL);
    }
    
    return TRUE;
}

//This function adds the selected file into the MRU of the appropriate file MRU's
//This functions also takes care of MultiFile Select case in which the file selected
//will  c:\winnt\file1.c\0file2.c\0file3.c\0. Refer GetOpenFileName documentation for 
// how the multifile is returned.

BOOL AddToMRU(LPOPENFILENAME lpOFN)
{
    TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    LPTSTR  lpFile;
    LPTSTR  lpExt;
    BOOL fAddToStar =  TRUE;
    HANDLE hMRUStar;

    //Check if we have valid file name
    if (!lpOFN->lpstrFile)
        return FALSE;

    hMRUStar = CreateMRU(szStar, 10);   //File MRU For *.* file extension

    //Copy the Directory for the selected file
    lstrcpyn(szDir, lpOFN->lpstrFile, lpOFN->nFileOffset);

    //point to the first file
    lpFile = lpOFN->lpstrFile + lpOFN->nFileOffset;

    do
    {
        // PERF: if there are multiple files  of the same extension type,
        // don't keep re-creating the mru.
        lpExt = PathFindExtension(lpFile);
        if (lpExt && *lpExt)
        {
            lpExt += 1; // Remove dot
        }


        HANDLE hMRU = CreateMRU(lpExt, 10);
        if (hMRU)
        {
            PathCombine(szFile, szDir, lpFile);
            AddMRUString(hMRU, szFile);
            if((lstrcmpi(lpExt, szStar)) && hMRUStar)
            {
                //Add to the *.* file mru also
                AddMRUString(hMRUStar, szFile);
            }

            FreeMRUList(hMRU);
        }
        lpFile = lpFile + lstrlen(lpFile) + 1;
    } while (((lpOFN->Flags & OFN_ALLOWMULTISELECT)) && (*lpFile != CHAR_NULL));

    //Free the * file mru
    if (hMRUStar)
    {
        FreeMRUList(hMRUStar);
    }
   return TRUE;
}





////////////////////////////////////////////////////////////////////////////
//
//  Last Visited MRU Implementation
//     All Strings stored in the registry are stored in unicode format.
//
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//  CreateLastVisitedItem
////////////////////////////////////////////////////////////////////////////
LPBYTE CreateLastVisitedItem(LPCWSTR wszModule, LPCWSTR wszPath, DWORD *pcbOut)
{
    LPBYTE pitem = NULL;
    DWORD cbLen1, cbLen2;
    cbLen1 = CbFromCchW(lstrlenW(wszModule)+1);
    cbLen2 = CbFromCchW(lstrlenW(wszPath)+1);

    pitem = (LPBYTE) LocalAlloc(LPTR, cbLen1+cbLen2);

    if (pitem)
    {
        memcpy(pitem, wszModule, cbLen1);
        memcpy(pitem+cbLen1, wszPath, cbLen2);
        *pcbOut = cbLen1+cbLen2;
    }

    return pitem;
}

int cdecl LastVisitedCompareProc(const void *p1, const void *p2, size_t cb)
{
    return StrCmpIW((LPWSTR)p1,(LPWSTR)p2);
}

////////////////////////////////////////////////////////////////////////////
//  Store all the strings in the registry as unicode strings
////////////////////////////////////////////////////////////////////////////
BOOL AddToLastVisitedMRU(LPCTSTR pszFile, int nFileOffset)
{
    BOOL bRet = FALSE;
    if (!PathIsTemporary(pszFile))
    {
        MRUDATAINFO mi =
        {
            SIZEOF(MRUDATAINFO),
            MAX_MRU,
            MRU_BINARY | MRU_CACHEWRITE,
            HKEY_CURRENT_USER,
            REGSTR_PATH_LASTVISITED,
            LastVisitedCompareProc
        };

        HANDLE hMRU = CreateMRUList((MRUINFO *)&mi);
        if (hMRU)
        {
            WCHAR wszDir[MAX_PATH];
            WCHAR wszModulePath[MAX_PATH];
    
            //Get the module name
            GetModuleFileNameWrapW(GetModuleHandle(NULL), wszModulePath, ARRAYSIZE(wszModulePath));
            WCHAR* pszModuleName = PathFindFileNameW(wszModulePath);

            int i = FindMRUData(hMRU, (void *)pszModuleName, CbFromCchW(lstrlenW(pszModuleName)+1), NULL);
            if (i >= 0)
            {
                DelMRUString(hMRU, i);
            }

            //Get the Directoy from file.
            SHTCharToUnicode(pszFile, wszDir, ARRAYSIZE(wszDir)); 
            wszDir[nFileOffset - 1] = CHAR_NULL;

            DWORD cbSize;
            LPBYTE pitem = CreateLastVisitedItem(pszModuleName, wszDir, &cbSize);
            if (pitem)
            {
                AddMRUData(hMRU, pitem, cbSize);
                bRet = TRUE;
                LocalFree(pitem);
            }

            FreeMRUList(hMRU);
        }
    }
    return bRet;
}

BOOL GetPathFromLastVisitedMRU(LPTSTR pszDir, DWORD cchDir)
{
    BOOL bRet = FALSE;

    MRUDATAINFO mi =
    {
        SIZEOF(MRUDATAINFO),
        MAX_MRU,
        MRU_BINARY | MRU_CACHEWRITE,
        HKEY_CURRENT_USER,
        REGSTR_PATH_LASTVISITED,
        LastVisitedCompareProc
    };

    pszDir[0] = 0;

    HANDLE hMRU = CreateMRUList((MRUINFO *)&mi);
    if (hMRU)
    {
        WCHAR wszModulePath[MAX_PATH];
    
        //Get the module name
        GetModuleFileNameWrapW(GetModuleHandle(NULL), wszModulePath, ARRAYSIZE(wszModulePath));
        WCHAR* pszModuleName = PathFindFileNameW(wszModulePath);

        int i = FindMRUData(hMRU, pszModuleName, CbFromCchW(lstrlenW(pszModuleName) + 1), NULL);
        if (i >= 0)
        {
            BYTE buf[CbFromCchW(2*MAX_PATH)];

            if (-1 != EnumMRUList(hMRU, i, buf, SIZEOF(buf)))
            {
                LPWSTR psz = (LPWSTR)((LPBYTE)buf + CbFromCchW(lstrlenW((LPWSTR)buf) +1));
                SHUnicodeToTChar(psz, pszDir, cchDir);
                bRet = TRUE;
            }
        }
        FreeMRUList(hMRU);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\fileopen.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    fileopen.c

Abstract:

    This module implements the Win32 fileopen dialogs.

Revision History:

--*/



// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "fileopen.h"
#include "util.h"

//
//  Constant Declarations.
//

#define WNTYPE_DRIVE         1

#define MIN_DEFEXT_LEN       4

#define BMPHIOFFSET          9

//
//  hbmpDirs array index values.
//  Note:  Two copies: for standard background, and hilite.
//         Relative order is important.
//
#define OPENDIRBMP           0
#define CURDIRBMP            1
#define STDDIRBMP            2
#define FLOPPYBMP            3
#define HARDDRVBMP           4
#define CDDRVBMP             5
#define NETDRVBMP            6
#define RAMDRVBMP            7
#define REMDRVBMP            8
  //
  //  If the following disktype is passed to AddDisk, then bTmp will be
  //  set to true in the DISKINFO structure (if the disk is new).
  //
#define TMPNETDRV            9

#define MAXDOSFILENAMELEN    (12 + 1)     // 8.3 filename + 1 for NULL

//
//  Maximum number of filters on one filter line.
//
#define MAXFILTERS           36

//
//  File exclusion bits (don't show files of these types).
//
#define EXCLBITS             (FILE_ATTRIBUTE_HIDDEN)




//
//  Global Variables.
//

//
//  Caching drive list.
//
extern DWORD dwNumDisks;
extern OFN_DISKINFO gaDiskInfo[MAX_DISKS];
extern TCHAR g_szInitialCurDir[MAX_PATH];

DWORD dwNumDlgs = 0;

//
//  Used to update the dialogs after coming back from the net dlg button.
//
BOOL bGetNetDrivesSync = FALSE;
LPTSTR lpNetDriveSync = NULL;
BOOL bNetworkInstalled = TRUE;

//
//  Following array is used to send messages to all dialog box threads
//  that have requested enumeration updating from the worker
//  thread.  The worker thread sends off a message to each slot
//  in the array that is non-NULL.
//
HWND gahDlg[MAX_THREADS];

//
//  Strings for Filter Parsing.
//
const static TCHAR szSemiColonSpaceTab[] = TEXT("; \t");
const static TCHAR szSemiColonTab[] = TEXT(";\t");

//
//  For WNet apis.
//
HANDLE hLNDThread = NULL;

WNDPROC lpLBProc = NULL;
WNDPROC lpOKProc = NULL;

//
//  Drive/Dir bitmap dimensions.
//
LONG dxDirDrive = 0;
LONG dyDirDrive = 0;

//
//  REARCHITECT: This needs to be on a per dialog basis for multi-threaded apps.
//
WORD wNoRedraw = 0;

UINT msgWOWDIRCHANGE;
UINT msgLBCHANGEA;
UINT msgSHAREVIOLATIONA;
UINT msgFILEOKA;

UINT msgLBCHANGEW;
UINT msgSHAREVIOLATIONW;
UINT msgFILEOKW;

BOOL bInChildDlg;
BOOL bFirstTime;
BOOL bInitializing;

//
//  Used by the worker thread to enumerate network disk resources.
//
extern DWORD cbNetEnumBuf;
extern LPTSTR gpcNetEnumBuf;

//
//  List Net Drives global variables.
//
extern HANDLE hLNDEvent;
BOOL bLNDExit = FALSE;

extern CRITICAL_SECTION g_csLocal;
extern CRITICAL_SECTION g_csNetThread;

extern DWORD g_tlsiCurDlg;

extern HDC hdcMemory;
extern HBITMAP hbmpOrigMemBmp;

HBITMAP hbmpDirDrive = HNULL;




//
//  Static Declarations.
//

static WORD cLock = 0;

//
//  Not valid RGB color.
//
static DWORD rgbWindowColor = 0xFF000000;
static DWORD rgbHiliteColor = 0xFF000000;
static DWORD rgbWindowText  = 0xFF000000;
static DWORD rgbHiliteText  = 0xFF000000;
static DWORD rgbGrayText    = 0xFF000000;
static DWORD rgbDDWindow    = 0xFF000000;
static DWORD rgbDDHilite    = 0xFF000000;

TCHAR szCaption[TOOLONGLIMIT + WARNINGMSGLENGTH];
TCHAR szWarning[TOOLONGLIMIT + WARNINGMSGLENGTH];

LPOFNHOOKPROC glpfnFileHook = 0;

//
//  REARCHITECT:
//  Of course, in the case where there is a multi-threaded process
//  that has > 1 threads simultaneously calling GetFileOpen, the
//  following globals may cause problems.
//
static LONG dyItem = 0;
static LONG dyText;
static BOOL bChangeDir = FALSE;
static BOOL bCasePreserved;

//
//  Used for formatting long unc names (ex. banyan).
//
static DWORD dwAveCharPerLine = 10;


//
//  Context Help IDs.
//

const static DWORD aFileOpenHelpIDs[] =
{
    edt1,        IDH_OPEN_FILENAME,
    stc3,        IDH_OPEN_FILENAME,
    lst1,        IDH_OPEN_FILENAME,
    stc1,        IDH_OPEN_PATH,
    lst2,        IDH_OPEN_PATH,
    stc2,        IDH_OPEN_FILETYPE,
    cmb1,        IDH_OPEN_FILETYPE,
    stc4,        IDH_OPEN_DRIVES,
    cmb2,        IDH_OPEN_DRIVES,
    chx1,        IDH_OPEN_READONLY,
    pshHelp,     IDH_HELP,
    psh14,       IDH_PRINT_NETWORK,

    0, 0
};

const static DWORD aFileSaveHelpIDs[] =
{
    edt1,        IDH_OPEN_FILENAME,
    stc3,        IDH_OPEN_FILENAME,
    lst1,        IDH_OPEN_FILENAME,
    stc1,        IDH_OPEN_PATH,
    lst2,        IDH_OPEN_PATH,
    stc2,        IDH_SAVE_FILETYPE,
    cmb1,        IDH_SAVE_FILETYPE,
    stc4,        IDH_OPEN_DRIVES,
    cmb2,        IDH_OPEN_DRIVES,
    chx1,        IDH_OPEN_READONLY,
    pshHelp,     IDH_HELP,
    psh14,       IDH_PRINT_NETWORK,

    0, 0
};




//
//  Function Prototypes.
//

SHORT
GetFileTitleX(
    LPTSTR lpszFile,
    LPTSTR lpszTitle,
    WORD wBufSize);

BOOL
GetFileName(
    POPENFILEINFO pOFI,
    DLGPROC qfnDlgProc);

BOOL_PTR CALLBACK
FileOpenDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR CALLBACK
FileSaveDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR
InitFileDlg(
    HWND hDlg,
    WPARAM wParam,
    POPENFILEINFO pOFI);

int
InitTlsValues(
    POPENFILEINFO pOFI);

DWORD
InitFilterBox(
    HANDLE hDlg,
    LPCTSTR lpszFilter);

VOID
InitCurrentDisk(
    HWND hDlg,
    POPENFILEINFO pOFI,
    WORD cmb);

VOID
vDeleteDirDriveBitmap();

BOOL
LoadDirDriveBitmap();

void
SetRGBValues();

BOOL
FSetUpFile();

BOOL_PTR
FileOpenCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI,
    BOOL bSave);

BOOL
UpdateListBoxes(
    HWND hDlg,
    POPENFILEINFO pOFI,
    LPTSTR lpszFilter,
    WORD wMask);

BOOL
OKButtonPressed(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave);

BOOL
MultiSelectOKButton(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave);

LRESULT WINAPI
dwOKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT WINAPI
dwLBSubclass(
    HWND hLB,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

int
InvalidFileWarning(
    HWND hDlg,
    LPTSTR szFile,
    DWORD wErrCode,
    UINT mbType);

VOID
MeasureItem(
    HWND hDlg,
    LPMEASUREITEMSTRUCT mis);

int
Signum(
    int nTest);

VOID
DrawItem(
    POPENFILEINFO pOFI,
    HWND hDlg,
    WPARAM wParam,
    LPDRAWITEMSTRUCT lpdis,
    BOOL bSave);

BOOL
SpacesExist(
    LPTSTR szFileName);

void
StripFileName(
    HANDLE hDlg,
    BOOL bWowApp);

LPTSTR
lstrtok(
    LPTSTR lpStr,
    LPCTSTR lpDelim);

LPTSTR
ChopText(
    HWND hwndDlg,
    int idStatic,
    LPTSTR lpch);

BOOL
FillOutPath(
    HWND hList,
    POPENFILEINFO pOFI);

BOOL
ShortenThePath(
    LPTSTR pPath);

int
FListAll(
    POPENFILEINFO pOFI,
    HWND hDlg,
    LPTSTR szSpec);

int
ChangeDir(
    HWND hDlg,
    LPCTSTR lpszDir,
    BOOL bForce,
    BOOL bError);

BOOL
IsFileSystemCasePreserving(
    LPTSTR lpszDisk);

BOOL
IsLFNDriveX(
    HWND hDlg,
    LPTSTR szPath);

int
DiskAddedPreviously(
    TCHAR wcDrive,
    LPTSTR lpszName);

int
AddDisk(
    TCHAR wcDrive,
    LPTSTR lpName,
    LPTSTR lpProvider,
    DWORD dwType);

VOID
EnableDiskInfo(
    BOOL bValid,
    BOOL bDoUnc);

VOID
FlushDiskInfoToCmb2();

BOOL
CallNetDlg(
    HWND hWnd);

UINT
GetDiskType(
    LPTSTR lpszDisk);

DWORD
GetUNCDirectoryFromLB(
    HWND hDlg,
    WORD nLB,
    POPENFILEINFO pOFI);

VOID
SelDisk(
    HWND hDlg,
    LPTSTR lpszDisk);

VOID
LNDSetEvent(
    HWND hDlg);

VOID
UpdateLocalDrive(
    LPTSTR szDrive,
    BOOL bGetVolName);

VOID
GetNetDrives(
    DWORD dwScope);

VOID
ListNetDrivesHandler();

VOID
LoadDrives(
    HWND hDlg);

DWORD
GetDiskIndex(
    DWORD dwDriveType);

VOID
CleanUpFile();

VOID
FileOpenAbort();

VOID
TermFile();


#ifdef UNICODE
//VOID                                 // prototype in fileopen.h
//ThunkOpenFileNameA2WDelayed(
//    POPENFILEINFO pOFI);

//BOOL                                 // prototype in fileopen.h
//ThunkOpenFileNameA2W(
//    POPENFILEINFO pOFI);

//BOOL                                 // prototype in fileopen.h
//ThunkOpenFileNameW2A(
//    POPENFILEINFO pOFI);

BOOL
GenericGetFileNameA(
    LPOPENFILENAMEA pOFNA,
    DLGPROC qfnDlgProc);

LPWSTR
ThunkANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars);

LPWSTR
ThunkMultiANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars);

BOOL
Multi_strcpyAtoW(
    LPWSTR pDestW,
    LPCSTR pSrcA,
    int cChars);

INT
Multi_strlenA(
    LPCSTR str);

#endif



// The Win9x code relies on calling SetCurrentDirectory wherever SheChangeDirEx is
// called. (Ideally SheChangeDirExA should be implemented).
// Ref: NT5 bug 161292 and Millenium bug 95478


#ifndef UNICODE
#undef SheChangeDirEx
#define SheChangeDirEx SetCurrentDirectory
#endif





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleA
//
//  ANSI entry point for GetFileTitle when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitleA(
    LPCSTR lpszFileA,
    LPSTR lpszTitleA,
    WORD cbBuf)
{
    LPWSTR lpszFileW;
    LPWSTR lpszTitleW;
    BOOL fResult;
    DWORD cbLen;

    //
    //  Init File string.
    //
    if (lpszFileA)
    {
        cbLen = lstrlenA(lpszFileA) + 1;
        if (!(lpszFileW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }
        else
        {
            SHAnsiToUnicode((LPSTR)lpszFileA,lpszFileW,cbLen );
        }
    }
    else
    {
        lpszFileW = NULL;
    }

    if (!(lpszTitleW = (LPWSTR)LocalAlloc(LPTR, (cbBuf * sizeof(WCHAR)))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        if (lpszFileW)
        {
            LocalFree(lpszFileW);
        }
        return (FALSE);
    }

    if (!(fResult = GetFileTitleW(lpszFileW, lpszTitleW, cbBuf)))
    {
        SHUnicodeToAnsi(lpszTitleW,lpszTitleA,cbBuf);
    }
    else if (fResult > 0)
    {
        //
        //  Buffer is too small - Ansi size needed (including null terminator).
        //  Get the offset to the filename.
        //
        SHORT nNeeded = (SHORT)(INT)LOWORD(ParseFile(lpszFileW, TRUE, FALSE, FALSE));
        LPSTR lpA = (LPSTR)lpszFileA;

        lpA += WideCharToMultiByte( CP_ACP,
                                    0,
                                    lpszFileW,
                                    nNeeded,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );

        fResult = lstrlenA(lpA) + 1;
        if (fResult <= cbBuf)
        {
            lstrcpyA(lpszTitleA, lpA);
            fResult = 0;
        }
    }

    //
    //  Clean up memory.
    //
    LocalFree(lpszTitleW);

    if (lpszFileW)
    {
        LocalFree(lpszFileW);
    }

    return ((SHORT)fResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleW
//
//  Stub UNICODE function for GetFileTitle when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitleW(
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitle
//
//  The GetFileTitle function returns the name of the file identified
//  by the lpCFile parameter.  This is useful if the file name was
//  received via some method other than GetOpenFileName
//  (e.g. command line, drag drop).
//
//  Returns:  0 on success
//            < 0, Parsing failure (invalid file name)
//            > 0, buffer too small, size needed (including NULL terminator)
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitle(
    LPCTSTR lpCFile,
    LPTSTR lpTitle,
    WORD cbBuf)
{
    LPTSTR lpFile;
    DWORD cbLen;
    SHORT fResult;

    //
    //  Init File string.
    //
    if (lpCFile)
    {
        cbLen = lstrlen(lpCFile) + 1;
        if (!(lpFile = (LPTSTR)LocalAlloc(LPTR, (cbLen * sizeof(TCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }
        else
        {
            lstrcpy(lpFile, lpCFile);
        }
    }
    else
    {
        lpFile = NULL;
    }

    fResult = GetFileTitleX(lpFile, lpTitle, cbBuf);

    //
    //  Clean up memory.
    //
    if (lpFile)
    {
        LocalFree(lpFile);
    }

    return (fResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleX
//
//  Worker routine for the GetFileTitle api.
//
//  Assumes:  lpszFile  points to NULL terminated DOS filename (may have path)
//            lpszTitle points to buffer to receive NULL terminated file title
//            wBufSize  is the size of buffer pointed to by lpszTitle
//
//  Returns:  0 on success
//            < 0, Parsing failure (invalid file name)
//            > 0, buffer too small, size needed (including NULL terminator)
//
////////////////////////////////////////////////////////////////////////////

SHORT GetFileTitleX(
    LPTSTR lpszFile,
    LPTSTR lpszTitle,
    WORD wBufSize)
{
    SHORT nNeeded;
    LPTSTR lpszPtr;

    //
    //  New 32 bit apps will get a title based on the user's preferences.
    //
    if ((GetProcessVersion(0) >= 0x040000) && !(CDGetAppCompatFlags() & CDACF_FILETITLE))
    {
        SHFILEINFO info;
        DWORD_PTR result;


        if (!lpszFile || !*lpszFile)
        {
            return (PARSE_EMPTYSTRING);
        }

        //
        //  If we have a root directory name (eg. c:\), then we need to go
        //  to the old implementation so that it will return -1.
        //  SHGetFileInfo will return the display name for the directory
        //  (which is the volume name).  This is incompatible with Win95
        //  and previous versions of NT.
        //
        if ((lstrlen(lpszFile) != 3) ||
            (lpszFile[1] != CHAR_COLON) || (!ISBACKSLASH(lpszFile, 2)))
        {
            result = SHGetFileInfo( lpszFile,
                                    FILE_ATTRIBUTE_NORMAL,
                                    &info,
                                    sizeof(info),
                                    SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES );

            if (result && (*info.szDisplayName))
            {
                UINT uDisplayLen = lstrlen(info.szDisplayName);

                //
                //  If no buffer or insufficient size, return the required chars.
                //  Original GetFileTitle API did not copy on failure.
                //
                if (!lpszTitle || (uDisplayLen >= (UINT)wBufSize))
                {
                    return ( (SHORT)(uDisplayLen + 1) );
                }

                //
                //  We already know it fits, so we don't need lstrcpyn.
                //
                lstrcpy(lpszTitle, info.szDisplayName);
                return (0);
            }
        }
    }

    //
    //  Use the old implementation.
    //
    nNeeded = (SHORT)(int)LOWORD(ParseFile(lpszFile, TRUE, FALSE, FALSE));
    if (nNeeded >= 0)
    {
        //
        //  Is the filename valid?
        //
        lpszPtr = lpszFile + nNeeded;
        if ((nNeeded = (SHORT)lstrlen(lpszPtr) + 1) <= (int)wBufSize)
        {
            //
            //  ParseFile() fails if wildcards in directory, but OK if in name.
            //  Since they arent OK here, the check is needed here.
            //
            if (StrChr(lpszPtr, CHAR_STAR) || StrChr(lpszPtr, CHAR_QMARK))
            {
                nNeeded = PARSE_WILDCARDINFILE;
            }
            else
            {
                lstrcpy(lpszTitle, lpszPtr);

                //
                //  Remove trailing spaces.
                //
                lpszPtr = lpszTitle + lstrlen(lpszTitle) - 1;
                while (*lpszPtr && *lpszPtr == CHAR_SPACE)
                {
                    *lpszPtr-- = CHAR_NULL;
                }

                nNeeded = 0;
            }
        }
    }

    return (nNeeded);
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileNameA
//
//  ANSI entry point for GetOpenFileName when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileNameA(
    LPOPENFILENAMEA pOFNA)
{
    if (!pOFNA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    return ( GenericGetFileNameA(pOFNA, FileOpenDlgProc) );
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileNameW
//
//  Stub UNICODE function for GetOpenFileName when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileNameW(
    LPOPENFILENAMEW pOFNW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileName
//
//  The GetOpenFileName function creates a system-defined dialog box
//  that enables the user to select a file to open.
//
//  Returns:  TRUE    if user specified name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileName(
    LPOPENFILENAME pOFN)
{
    OPENFILEINFO OFI;

    ZeroMemory(&OFI, sizeof(OPENFILEINFO));

    if (!pOFN)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    OFI.pOFN = pOFN;
    OFI.ApiType = COMDLG_WIDE;
    OFI.iVersion = OPENFILEVERSION;

    return (GetFileName(&OFI, FileOpenDlgProc));
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileNameA
//
//  ANSI entry point for GetSaveFileName when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileNameA(
    LPOPENFILENAMEA pOFNA)
{
    return (GenericGetFileNameA(pOFNA, FileSaveDlgProc));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileNameW
//
//  Stub UNICODE function for GetSaveFileName when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileNameW(
    LPOPENFILENAMEW pOFNW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileName
//
//  The GetSaveFileName function creates a system-defined dialog box
//  that enables the user to select a file to save.
//
//  Returns:  TRUE    if user desires to save file and gave a proper name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileName(
    LPOPENFILENAME pOFN)
{
    OPENFILEINFO OFI;

    ZeroMemory(&OFI, sizeof(OPENFILEINFO));

    OFI.pOFN = pOFN;
    OFI.ApiType = COMDLG_WIDE;
    OFI.iVersion = OPENFILEVERSION;

    return ( GetFileName(&OFI, FileSaveDlgProc) );
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFileName
//
//  This is the meat of both GetOpenFileName and GetSaveFileName.
//
//  Returns:  TRUE    if user specified name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFileName(
    POPENFILEINFO pOFI,
    DLGPROC qfnDlgProc)
{
    LPOPENFILENAME pOFN = pOFI->pOFN;
    INT_PTR iRet = 0;
    LPTSTR lpDlg;
    HANDLE hRes, hDlgTemplate;
    WORD wErrorMode;
    HDC hdcScreen;
    HBITMAP hbmpTemp;
    LPCURDLG lpCurDlg;
    static fFirstTime = TRUE;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); 

    if (!pOFN)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pOFN->lStructSize == OPENFILENAME_SIZE_VERSION_400)
    {
        // Note: We do not want to make a copy of the OFN structure passed in. 
        // This confuses all MFC based apps since they query
        // MFC and end up getting stale data if we make a copy and endup updating only the
        // copy until Comdlg api returns.
        pOFI->iVersion = OPENFILEVERSION_NT4;
    }

    if ((pOFN->lStructSize != sizeof(OPENFILENAME)) && 
        (pOFN->lStructSize != OPENFILENAME_SIZE_VERSION_400)
       )
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pOFN->nMaxFile == 0)
    {
        //Bail out for NULL lpstrFile Only for NT5 and above applications
        if (!IS16BITWOWAPP(pOFN) && (pOFI->iVersion >= OPENFILEVERSION_NT5))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            return (FALSE);
        }
    }


    //
    //  See if the application should get the new look.
    //
    //  Do not allow the new look if they have hooks, templates, or
    //  multi select without the OFN_EXPLORER bit.
    //
    //  Also don't allow the new look if we are in the context of
    //  a 16 bit process.
    //
    if ( ((pOFN->Flags & OFN_EXPLORER) ||
          (!(pOFN->Flags & (OFN_ENABLEHOOK |
                            OFN_ENABLETEMPLATE |
                            OFN_ENABLETEMPLATEHANDLE |
                            OFN_ALLOWMULTISELECT)))) &&
         (!IS16BITWOWAPP(pOFN)) )
    {
        BOOL fRet;
#ifdef UNICODE
        //
        //  To be used by the thunking routines for multi selection.
        //
        pOFI->bUseNewDialog = TRUE;
#endif
        //
        //  Show the new explorer look.
        //
        StoreExtendedError(0);
        g_bUserPressedCancel = FALSE;

        if (qfnDlgProc == FileOpenDlgProc)
        {
            fRet = (NewGetOpenFileName(pOFI));
        }
        else
        {
            fRet = (NewGetSaveFileName(pOFI));
        }

        return fRet;
    }

    if (fFirstTime)
    {
        //
        //  Create a DC that is compatible with the screen and find the
        //  handle of the null bitmap.
        //
        hdcScreen = GetDC(HNULL);
        if (!hdcScreen)
        {
            goto CantInit;
        }
        hdcMemory = CreateCompatibleDC(hdcScreen);
        if (!hdcMemory)
        {
            goto ReleaseScreenDC;
        }

        hbmpTemp = CreateCompatibleBitmap(hdcMemory, 1, 1);
        if (!hbmpTemp)
        {
            goto ReleaseMemDC;
        }
        hbmpOrigMemBmp = SelectObject(hdcMemory, hbmpTemp);
        if (!hbmpOrigMemBmp)
        {
            goto ReleaseMemDC;
        }
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        DeleteObject(hbmpTemp);
        ReleaseDC(HNULL, hdcScreen);

        fFirstTime = FALSE;
    }

    if (pOFN->Flags & OFN_ENABLEHOOK)
    {
        if (!pOFN->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pOFN->lpfnHook = NULL;
    }

    HourGlass(TRUE);
    StoreExtendedError(0);

    //
    //  Force re-compute for font changes between calls.
    //
    dyItem = dyText = 0;

    g_bUserPressedCancel = FALSE;

    if (!FSetUpFile())
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        goto TERMINATE;
    }

    if (pOFN->Flags & OFN_ENABLETEMPLATE)
    {
        if (!(hRes = FindResource( pOFN->hInstance,
                                   pOFN->lpTemplateName,
                                   RT_DIALOG )))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            goto TERMINATE;
        }
        if (!(hDlgTemplate = LoadResource(pOFN->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            goto TERMINATE;
        }
        LangID = GetDialogLanguage(pOFN->hwndOwner, hDlgTemplate);
    }
    else if (pOFN->Flags & OFN_ENABLETEMPLATEHANDLE)
    {
        hDlgTemplate = pOFN->hInstance;
        LangID = GetDialogLanguage(pOFN->hwndOwner, hDlgTemplate);
    }
    else
    {
        if (pOFN->Flags & OFN_ALLOWMULTISELECT)
        {
            lpDlg = MAKEINTRESOURCE(MULTIFILEOPENORD);
        }
        else
        {
            lpDlg = MAKEINTRESOURCE(FILEOPENORD);
        }

        LangID = GetDialogLanguage(pOFN->hwndOwner, NULL);
        if (!(hRes = FindResourceExFallback(g_hinst, RT_DIALOG, lpDlg, LangID)))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            goto TERMINATE;
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            goto TERMINATE;
        }
    }

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) LangID);

    //
    //  No kernel network error dialogs.
    //
    wErrorMode = (WORD)SetErrorMode(SEM_NOERROR);
    SetErrorMode(SEM_NOERROR | wErrorMode);

    if (LockResource(hDlgTemplate))
    {
        if (pOFN->Flags & OFN_ENABLEHOOK)
        {
            glpfnFileHook = GETHOOKFN(pOFN);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(pOFN))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           pOFN->hwndOwner,
                                           qfnDlgProc,
                                           (DWORD_PTR)pOFI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       pOFN->hwndOwner,
                                       qfnDlgProc,
                                       (DWORD)pOFI );
#endif

        if (iRet == -1 || ((iRet == 0) && (!g_bUserPressedCancel) && (!GetStoredExtendedError())))
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
        else
        {
            FileOpenAbort();
        }

        glpfnFileHook = 0;
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
        goto TERMINATE;
    }

    SetErrorMode(wErrorMode);

    if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
    {
        // restore the thread list to the previous dialog (if any)
        TlsSetValue(g_tlsiCurDlg, (LPVOID)lpCurDlg->next);
        LocalFree(lpCurDlg->lpstrCurDir);
        LocalFree(lpCurDlg);
    }

TERMINATE:

    CleanUpFile();
    HourGlass(FALSE);
    return (iRet == IDOK);

ReleaseMemDC:
    DeleteDC(hdcMemory);

ReleaseScreenDC:
    ReleaseDC(HNULL, hdcScreen);

CantInit:
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileHookCmd
//
//  Called when a hook function processes a WM_COMMAND message.
//  Called by FileOpenDlgProc and FileSaveDlgProc.
//
////////////////////////////////////////////////////////////////////////////

BOOL FileHookCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case ( IDCANCEL ) :
        {
            //
            //  Set global flag stating that the
            //  user pressed cancel.
            //
            g_bUserPressedCancel = TRUE;

            //  Fall Thru...
        }
        case ( IDOK ) :
        case ( IDABORT ) :
        {
#ifdef UNICODE
            //
            //  Apps that side-effect these messages may
            //  not have their internal unicode strings
            //  updated.  They may also forget to gracefully
            //  exit the network enum'ing worker thread.
            //
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                ThunkOpenFileNameA2W(pOFI);
            }
#endif
            break;
        }
        case ( cmb1 ) :
        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( MYCBN_DRAW ) :
                case ( MYCBN_LIST ) :
                case ( MYCBN_REPAINT ) :
                case ( MYCBN_CHANGEDIR ) :
                {
                    //
                    //  In case an app has a hook, and returns
                    //  true for processing WM_COMMAND messages,
                    //  we still have to worry about our
                    //  internal message that came through via
                    //  WM_COMMAND.
                    //
                    FileOpenCmd( hDlg,
                                 wParam,
                                 lParam,
                                 pOFI,
                                 FALSE );
                    break;
                }
            }
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenDlgProc
//
//  Gets the name of a file to open from the user.
//
//  edt1 = file name
//  lst1 = list of files in current directory matching current pattern
//  cmb1 = lists file patterns
//  stc1 = is current directory
//  lst2 = lists directories on current drive
//  cmb2 = lists drives
//  IDOK = is Open pushbutton
//  IDCANCEL = is Cancel pushbutton
//  chx1 = is for opening read only files
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FileOpenDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    POPENFILEINFO pOFI;
    BOOL_PTR bRet, bHookRet;


    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN->lpfnHook)
        {
            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFI->pOFN);

            bHookRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam);

            if (bHookRet)
            {

                if (wMsg == WM_COMMAND)
                {
                    return (FileHookCmd(hDlg, wParam, lParam, pOFI));
                }

                return (bHookRet);
            }
        }
    }
    else if (glpfnFileHook &&
             (wMsg != WM_INITDIALOG) &&
             (bHookRet = (*glpfnFileHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bHookRet);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            pOFI = (POPENFILEINFO)lParam;

            SetProp(hDlg, FILEPROP, (HANDLE)pOFI);
            glpfnFileHook = 0;

            //
            //  If we are being called from a Unicode app, turn off
            //  the ES_OEMCONVERT style on the filename edit control.
            //
//          if (pOFI->ApiType == COMDLG_WIDE)
            {
                LONG lStyle;
                HWND hEdit = GetDlgItem(hDlg, edt1);

                //
                //  Grab the window style.
                //
                lStyle = GetWindowLong(hEdit, GWL_STYLE);

                //
                //  If the window style bits include ES_OEMCONVERT,
                //  remove this flag and reset the style.
                //
                if (lStyle & ES_OEMCONVERT)
                {
                    lStyle &= ~ES_OEMCONVERT;
                    SetWindowLong(hEdit, GWL_STYLE, lStyle);
                }
            }

            bInitializing = TRUE;
            bRet = InitFileDlg(hDlg, wParam, pOFI);
            bInitializing = FALSE;

            HourGlass(FALSE);
            return (bRet);
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (!bInChildDlg)
            {
                if (bFirstTime == TRUE)
                {
                    bFirstTime = FALSE;
                }
                else if (wParam)
                {
                    //
                    //  If becoming active.
                    //
                    LNDSetEvent(hDlg);
                }
            }
            return (FALSE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            MeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wNoRedraw < 2)
            {
                DrawItem(pOFI, hDlg, wParam, (LPDRAWITEMSTRUCT)lParam, FALSE);
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            SetRGBValues();
            LoadDirDriveBitmap();
            break;
        }
        case ( WM_COMMAND ) :
        {
            return (FileOpenCmd(hDlg, wParam, lParam, pOFI, FALSE));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            //
            //  This logic used to be in CBN_SETFOCUS in fileopencmd,
            //  but CBN_SETFOCUS is called whenever there is a click on
            //  the List Drives combo.  This causes the worker thread
            //  to start up and flicker when the combo box is refreshed.
            //
            //  But, refreshes are only needed when someone focuses out of
            //  the common dialog and then back in (unless someone is logged
            //  in remote, or there is a background thread busy connecting!)
            //  so fix the flicker by moving the logic here.
            //
            if (!wNoRedraw)
            {
                LNDSetEvent(hDlg);
            }
            return (FALSE);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFileOpenHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFileOpenHelpIDs );
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  FileSaveDlgProc
//
//  Obtains the name of the file that the user wants to save.
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FileSaveDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    POPENFILEINFO pOFI;
    BOOL_PTR bRet, bHookRet;
    TCHAR szTitle[cbCaption];


    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN->lpfnHook)
        {
            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFI->pOFN);

            bHookRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam);

            if (bHookRet)
            {
                if (wMsg == WM_COMMAND)
                {
                    return (FileHookCmd(hDlg, wParam, lParam, pOFI));
                }

                return (bHookRet);
            }
        }
    }
    else if (glpfnFileHook &&
             (wMsg != WM_INITDIALOG) &&
             (bHookRet = (*glpfnFileHook)(hDlg, wMsg, wParam, lParam)))
        {
            return (bHookRet);
        }
    
    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            pOFI = (POPENFILEINFO)lParam;
            if (!(pOFI->pOFN->Flags &
                  (OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
            {
                CDLoadString(g_hinst, iszFileSaveTitle, szTitle, cbCaption);
                SetWindowText(hDlg, szTitle);
                CDLoadString(g_hinst, iszSaveFileAsType, szTitle, cbCaption);
                SetDlgItemText(hDlg, stc2, szTitle);
            }
            glpfnFileHook = 0;
            SetProp(hDlg, FILEPROP, (HANDLE)pOFI);

            //
            //  If we are being called from a Unicode app, turn off
            //  the ES_OEMCONVERT style on the filename edit control.
            //
//          if (pOFI->ApiType == COMDLG_WIDE)
            {
                LONG lStyle;
                HWND hEdit = GetDlgItem(hDlg, edt1);

                //
                //  Grab the window style.
                //
                lStyle = GetWindowLong(hEdit, GWL_STYLE);

                //
                //  If the window style bits include ES_OEMCONVERT,
                //  remove this flag and reset the style.
                //
                if (lStyle & ES_OEMCONVERT)
                {
                    lStyle &= ~ES_OEMCONVERT;
                    SetWindowLong (hEdit, GWL_STYLE, lStyle);
                }
            }

            bInitializing = TRUE;
            bRet = InitFileDlg(hDlg, wParam, pOFI);
            bInitializing = FALSE;

            HourGlass(FALSE);
            return (bRet);
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (!bInChildDlg)
            {
                if (bFirstTime == TRUE)
                {
                    bFirstTime = FALSE;
                }
                else if (wParam)
                {
                    //
                    //  If becoming active.
                    //
                    if (!wNoRedraw)
                    {
                        LNDSetEvent(hDlg);
                    }
                }
            }
            return (FALSE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            MeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wNoRedraw < 2)
            {
                DrawItem(pOFI, hDlg, wParam, (LPDRAWITEMSTRUCT)lParam, TRUE);
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            SetRGBValues();
            LoadDirDriveBitmap();
            break;
        }
        case ( WM_COMMAND ) :
        {
            return (FileOpenCmd(hDlg, wParam, lParam, pOFI, TRUE));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            //
            //  This logic used to be in CBN_SETFOCUS in fileopencmd,
            //  but CBN_SETFOCUS is called whenever there is a click on
            //  the List Drives combo.  This causes the worker thread
            //  to start up and flicker when the combo box is refreshed.
            //
            //  But, refreshes are only needed when someone focuses out of
            //  the common dialog and then back in (unless someone is logged
            //  in remote, or there is a background thread busy connecting!)
            //  so fix the flicker by moving the logic here.
            //
            if (!wNoRedraw)
            {
                LNDSetEvent(hDlg);
            }

            return (FALSE);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFileSaveHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFileSaveHelpIDs );
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitFileDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR InitFileDlg(
    HWND hDlg,
    WPARAM wParam,
    POPENFILEINFO pOFI)
{
    DWORD lRet, nFilterIndex;
    LPOPENFILENAME pOFN = pOFI->pOFN;
    int nFileOffset, nExtOffset;
    RECT rRect;
    RECT rLbox;
    BOOL_PTR bRet;
   
    if (!InitTlsValues(pOFI))
    {
        //
        //  The extended error is set inside of the above call.
        //
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    lpLBProc = (WNDPROC)GetWindowLongPtr(GetDlgItem(hDlg, lst2), GWLP_WNDPROC);
    lpOKProc = (WNDPROC)GetWindowLongPtr(GetDlgItem(hDlg, IDOK), GWLP_WNDPROC);

    if (!lpLBProc || !lpOKProc)
    {
        StoreExtendedError(FNERR_SUBCLASSFAILURE);
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    //
    //  Save original directory for later restoration if necessary.
    //
    *pOFI->szCurDir = 0;
    GetCurrentDirectory(MAX_FULLPATHNAME + 1, pOFI->szCurDir);

    //
    //  Check out if the filename contains a path.  If so, override whatever
    //  is contained in lpstrInitialDir.  Chop off the path and put up only
    //  the filename.
    //
    if ( pOFN->lpstrFile &&
         *pOFN->lpstrFile &&
         !(pOFN->Flags & OFN_NOVALIDATE) )
    {
        if (DBL_BSLASH(pOFN->lpstrFile + 2) &&
            ((*(pOFN->lpstrFile + 1) == CHAR_COLON)))
        {
            lstrcpy(pOFN->lpstrFile , pOFN->lpstrFile + sizeof(TCHAR));
        }

        lRet = ParseFile(pOFN->lpstrFile, TRUE, IS16BITWOWAPP(pOFN), FALSE);
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        nExtOffset  = (int)(SHORT)HIWORD(lRet);

        //
        //  Is the filename invalid?
        //
        if ( (nFileOffset < 0) &&
             (nFileOffset != PARSE_EMPTYSTRING) &&
             (pOFN->lpstrFile[nExtOffset] != CHAR_SEMICOLON) )
        {
            StoreExtendedError(FNERR_INVALIDFILENAME);
            EndDialog(hDlg, FALSE);
            return (FALSE);
        }
    }

    pOFN->Flags &= ~(OFN_FILTERDOWN | OFN_DRIVEDOWN | OFN_DIRSELCHANGED);

    pOFI->idirSub = 0;

    if (!(pOFN->Flags & OFN_SHOWHELP))
    {
        HWND hHelp;

        EnableWindow(hHelp = GetDlgItem(hDlg, pshHelp), FALSE);

        //
        //  Move the window out of this spot so that no overlap will be
        //  detected.
        //
        MoveWindow(hHelp, -8000, -8000, 20, 20, FALSE);
        ShowWindow(hHelp, SW_HIDE);
    }

    if (pOFN->Flags & OFN_CREATEPROMPT)
    {
        pOFN->Flags |= (OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);
    }
    else if (pOFN->Flags & OFN_FILEMUSTEXIST)
    {
        pOFN->Flags |= OFN_PATHMUSTEXIST;
    }

    if (pOFN->Flags & OFN_HIDEREADONLY)
    {
        HWND hReadOnly;

        EnableWindow(hReadOnly = GetDlgItem(hDlg, chx1), FALSE);

        //
        //  Move the window out of this spot so that no overlap will be
        //  detected.
        //
        MoveWindow(hReadOnly, -8000, -8000, 20, 20, FALSE);
        ShowWindow(hReadOnly, SW_HIDE);
    }
    else
    {
        CheckDlgButton(hDlg, chx1, (pOFN->Flags & OFN_READONLY) != 0);
    }

    SendDlgItemMessage(hDlg, edt1, EM_LIMITTEXT, (WPARAM)MAX_PATH, 0L);

    //
    //  Insert file specs into cmb1.
    //  Custom filter first.
    //  Must also check if filter contains anything.
    //
    if ( pOFN->lpstrFile &&
         (StrChr(pOFN->lpstrFile, CHAR_STAR) ||
          StrChr(pOFN->lpstrFile, CHAR_QMARK)) )
    {
        lstrcpy(pOFI->szLastFilter, pOFN->lpstrFile);
    }
    else
    {
        pOFI->szLastFilter[0] = CHAR_NULL;
    }

    if (pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter)
    {
        SHORT nLength;

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_INSERTSTRING,
                            0,
                            (LONG_PTR)pOFN->lpstrCustomFilter );

        nLength = (SHORT)(lstrlen(pOFN->lpstrCustomFilter) + 1);
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            0,
                            (LONG)(nLength) );

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_LIMITTEXT,
                            (WPARAM)(pOFN->nMaxCustFilter),
                            0L );

        if (pOFI->szLastFilter[0] == CHAR_NULL)
        {
            lstrcpy(pOFI->szLastFilter, pOFN->lpstrCustomFilter + nLength);
        }
    }
    else
    {
        //
        //  Given no custom filter, the index will be off by one.
        //
        if (pOFN->nFilterIndex != 0)
        {
            pOFN->nFilterIndex--;
        }
    }

    //
    //  Listed filters next.
    //
    if (pOFN->lpstrFilter && *pOFN->lpstrFilter)
    {
        if (pOFN->nFilterIndex > InitFilterBox(hDlg, pOFN->lpstrFilter))
        {
            pOFN->nFilterIndex = 0;
        }
    }
    else
    {
        pOFN->nFilterIndex = 0;
    }
    pOFI->szSpecCur[0] = CHAR_NULL;

    //
    //  If an entry exists, select the one indicated by nFilterIndex.
    //
    if ((pOFN->lpstrFilter && *pOFN->lpstrFilter) ||
        (pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
    {
        LPCTSTR lpFilter;

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETCURSEL,
                            (WPARAM)(pOFN->nFilterIndex),
                            0L );

        nFilterIndex = pOFN->nFilterIndex;
        SendMessage( hDlg,
                     WM_COMMAND,
                     GET_WM_COMMAND_MPS( cmb1,
                                         GetDlgItem(hDlg, cmb1),
                                         MYCBN_DRAW ) );
        pOFN->nFilterIndex = nFilterIndex;

        if (pOFN->nFilterIndex ||
            !(pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
        {
            lpFilter = pOFN->lpstrFilter +
                       SendDlgItemMessage( hDlg,
                                           cmb1,
                                           CB_GETITEMDATA,
                                           (WPARAM)pOFN->nFilterIndex,
                                           0L );
        }
        else
        {
            lpFilter = pOFN->lpstrCustomFilter +
                       lstrlen(pOFN->lpstrCustomFilter) + 1;
        }
        if (*lpFilter)
        {
            TCHAR szText[MAX_FULLPATHNAME];

            // lpFilter can be longer than MAX_FULLPATHNAME!!!
            StrCpyN(szText, lpFilter, ARRAYSIZE(szText));

            //
            //  Filtering is case-insensitive.
            //
            CharLower(szText);

            if (pOFI->szLastFilter[0] == CHAR_NULL)
            {
                lstrcpy(pOFI->szLastFilter, szText);
            }

            if (!(pOFN->lpstrFile && *pOFN->lpstrFile))
            {
                SetDlgItemText(hDlg, edt1, szText);
            }
        }
    }

    InitCurrentDisk(hDlg, pOFI, cmb2);

    bFirstTime = TRUE;
    bInChildDlg = FALSE;

    SendMessage( hDlg,
                 WM_COMMAND,
                 GET_WM_COMMAND_MPS(cmb2, GetDlgItem(hDlg, cmb2), MYCBN_DRAW) );
    SendMessage( hDlg,
                 WM_COMMAND,
                 GET_WM_COMMAND_MPS(cmb2, GetDlgItem(hDlg, cmb2), MYCBN_LIST) );

    if (pOFN->lpstrFile && *pOFN->lpstrFile)
    {
        TCHAR szText[MAX_FULLPATHNAME];

        lRet = ParseFile( pOFN->lpstrFile,
                          IsLFNDriveX(hDlg, pOFN->lpstrFile),
                          IS16BITWOWAPP(pOFN),
                          FALSE );
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        nExtOffset  = (int)(SHORT)HIWORD(lRet);

        //
        //  Is the filename invalid?
        //
        if ( !(pOFN->Flags & OFN_NOVALIDATE) &&
             (nFileOffset < 0) &&
             (nFileOffset != PARSE_EMPTYSTRING) &&
             (pOFN->lpstrFile[nExtOffset] != CHAR_SEMICOLON) )
        {
            StoreExtendedError(FNERR_INVALIDFILENAME);
            EndDialog(hDlg, FALSE);
            return (FALSE);
        }
        lstrcpy(szText, pOFN->lpstrFile);
        SetDlgItemText(hDlg, edt1, szText);
    }

    SetWindowLongPtr(GetDlgItem(hDlg, lst2), GWLP_WNDPROC, (LONG_PTR)dwLBSubclass);
    SetWindowLongPtr(GetDlgItem(hDlg, IDOK), GWLP_WNDPROC, (LONG_PTR)dwOKSubclass);

    if (pOFN->lpstrTitle && *pOFN->lpstrTitle)
    {
        SetWindowText(hDlg, pOFN->lpstrTitle);
    }

    //
    //  By setting dyText to rRect.bottom/8, dyText defaults to 8 items showing
    //  in the listbox.  This only matters if the applications hook function
    //  steals all WM_MEASUREITEM messages.  Otherwise, dyText will be set in
    //  the MeasureItem() routine.  Check for !dyItem in case message ordering
    //  has already sent WM_MEASUREITEM and dyText is already initialized.
    //
    if (!dyItem)
    {
        GetClientRect(GetDlgItem(hDlg, lst1), (LPRECT) &rRect);
        if (!(dyText = (rRect.bottom / 8)))
        {
            //
            //  If no size to rectangle.
            //
            dyText = 8;
        }
    }

    //  The template has changed to make it extremely clear that
    //  this is not a combobox, but rather an edit control and a listbox.  The
    //  problem is that the new templates try to align the edit box and listbox.
    //  Unfortunately, when listboxes add borders, they expand beyond their
    //  borders.  When edit controls add borders, they stay within their
    //  borders.  This makes it impossible to align the two controls strictly
    //  within the template.  The code below will align the controls, but only
    //  if they are using the standard dialog template.
    //
    if (!(pOFN->Flags & (OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        GetWindowRect(GetDlgItem(hDlg, lst1), (LPRECT)&rLbox);
        GetWindowRect(GetDlgItem(hDlg, edt1), (LPRECT)&rRect);
        rRect.left = rLbox.left;
        rRect.right = rLbox.right;
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rRect, 2);
        SetWindowPos( GetDlgItem(hDlg, edt1),
                      0,
                      rRect.left,
                      rRect.top,
                      rRect.right - rRect.left,
                      rRect.bottom - rRect.top,
                      SWP_NOZORDER );
    }

    if (pOFN->lpfnHook)
    {
        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
        if (pOFI->ApiType == COMDLG_ANSI)
        {
            ThunkOpenFileNameW2A(pOFI);
            bRet = ((*lpfnHook)( hDlg,
                                 WM_INITDIALOG,
                                 wParam,
                                 (LPARAM)pOFI->pOFNA ));
            //
            //  Strange win 31 example uses lCustData to
            //  hold a temporary variable that it passes back to
            //  calling function.
            //
            ThunkOpenFileNameA2W(pOFI);
        }
        else
#endif
        {
            bRet = ((*lpfnHook)( hDlg,
                                 WM_INITDIALOG,
                                 wParam,
                                 (LPARAM)pOFN ));
        }
    }
    else
    {
#ifdef UNICODE
        //
        //  Have to thunk A version even when there isn't a hook proc so it
        //  doesn't reset W version on delayed thunk back.
        //
        if (pOFI->ApiType == COMDLG_ANSI)
        {
            pOFI->pOFNA->Flags = pOFN->Flags;
        }
#endif
        bRet = TRUE;
    }

    //
    //  At first, assume there is net support !
    //
    if ((pOFN->Flags & OFN_NONETWORKBUTTON))
    {
        HWND hNet;

        if (hNet = GetDlgItem(hDlg, psh14))
        {
            EnableWindow(hNet = GetDlgItem(hDlg, psh14), FALSE);

            ShowWindow(hNet, SW_HIDE);
        }
    }
    else
    {
        AddNetButton( hDlg,
                      ((pOFN->Flags & OFN_ENABLETEMPLATE)
                          ? pOFN->hInstance
                          : g_hinst),
                      FILE_BOTTOM_MARGIN,
                      (pOFN->Flags & (OFN_ENABLETEMPLATE |
                                       OFN_ENABLETEMPLATEHANDLE))
                          ? FALSE
                          : TRUE,
                      (pOFN->Flags & OFN_NOLONGNAMES)
                          ? FALSE
                          : TRUE,
                      FALSE);
    }
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTlsValues
//
////////////////////////////////////////////////////////////////////////////

int InitTlsValues(
    POPENFILEINFO pOFI)
{
    //
    //  As long as we do not call TlsGetValue before this,
    //  everything should be ok.
    //
    LPCURDLG lpCurDlg, lpPrevDlg;
    DWORD    dwError;
    LPTSTR   lpCurDir;

    if (dwNumDlgs == MAX_THREADS)
    {
        dwError = CDERR_INITIALIZATION;
        goto ErrorExit0;
    }

    // alloc for the current directory
    if (lpCurDir = (LPTSTR)LocalAlloc(LPTR, CCHNETPATH * sizeof(TCHAR)))
    {
        GetCurrentDirectory(CCHNETPATH, lpCurDir);

        if ( (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             (StrChr(lpCurDir, CHAR_SPACE)) )
        {
            GetShortPathName(lpCurDir, lpCurDir, CCHNETPATH);
        }

    }
    else
    {
        dwError = CDERR_MEMALLOCFAILURE;
        goto ErrorExit0;
    }

    // add a CurDlg struct to the list for this thread
    if (lpCurDlg = (LPCURDLG)LocalAlloc(LPTR, sizeof(CURDLG)))
    {
        // get start of CURDLG list for this thread
        // Note: lpPrevDlg will be NULL if there wasn't a previous dialog
        lpPrevDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

        // make sure TlsGetValue() actually succeeded (a NULL return could
        // mean there wasn't a previous dialog in the list)
        if (GetLastError() != NO_ERROR)
        {
            dwError = CDERR_INITIALIZATION;
            goto ErrorExit2;
        }

        // push the new dlg to the front of the list
        lpCurDlg->next = lpPrevDlg;

        lpCurDlg->lpstrCurDir = lpCurDir;
        PathAddBackslash(lpCurDlg->lpstrCurDir);

        EnterCriticalSection(&g_csLocal);
        lpCurDlg->dwCurDlgNum = dwNumDlgs++;
        LeaveCriticalSection(&g_csLocal);

        // save the new head of the list for the thread
        if (!TlsSetValue(g_tlsiCurDlg, (LPVOID)lpCurDlg))
        {
            dwError = CDERR_INITIALIZATION;
            goto ErrorExit2;
        }
    }
    else
    {
        dwError = CDERR_MEMALLOCFAILURE;
        goto ErrorExit1;
    }

    return(TRUE);


ErrorExit2:
    LocalFree(lpCurDlg);

ErrorExit1:
    LocalFree(lpCurDir);

ErrorExit0:
    StoreExtendedError(dwError);
    return (FALSE);

}


////////////////////////////////////////////////////////////////////////////
//
//  InitFilterBox
//
//  Places the double null terminated list of filters in the combo box.
//  The list should consist of pairs of null terminated strings, with
//  an additional null terminating the list.
//
////////////////////////////////////////////////////////////////////////////

DWORD InitFilterBox(
    HANDLE hDlg,
    LPCTSTR lpszFilter)
{
    DWORD nOffset = 0;
    DWORD nIndex = 0;
    register WORD nLen;


    while (*lpszFilter)
    {
        //
        //  First string put in as string to show.
        //
        nIndex = (DWORD) SendDlgItemMessage( hDlg,
                                             cmb1,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM)lpszFilter );
        nLen = (WORD)(lstrlen(lpszFilter) + 1);
        (LPTSTR)lpszFilter += nLen;
        nOffset += nLen;

        //
        //  Second string put in as itemdata.
        //
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            (WPARAM)nIndex,
                            nOffset );

        //
        //  Advance to next element.
        //
        nLen = (WORD)(lstrlen(lpszFilter) + 1);
        (LPTSTR)lpszFilter += nLen;
        nOffset += nLen;
    }

    return (nIndex);
}

void TokenizeFilterString(LPTSTR pszFilterString, LPTSTR *ppszFilterArray, int cFilterArray, BOOL bLFN)
{
    LPCTSTR pszDelim = bLFN ? szSemiColonTab : szSemiColonSpaceTab;
    int nFilters = 0;
    cFilterArray--; // Need one for the NULL at the end.

    //
    //  Find the first filter in the string, and add it to the
    //  array.
    //
    ppszFilterArray[nFilters] = lstrtok(pszFilterString, pszDelim);

    //
    //  Now we are going to loop through all the filters in the string
    //  parsing the one we already have, and then finding the next one
    //  and starting the loop over again.
    //
    while (ppszFilterArray[nFilters] && (nFilters < cFilterArray))
    {
        //
        //  Check to see if the first character is a space.  If so, remove
        //  the spaces, and save the pointer back into the same spot.  We
        //  need to do this because the FindFirstFile/Next api will still
        //  work on filenames that begin with a space since they also
        //  look at the short names.  The short names will begin with the
        //  same first real letter as the long filename.  For example, the
        //  long filename is "  my document" the first letter of this short
        //  name is "m", so searching on "m*.*" or " m*.*" will yield the
        //  same results.
        //
        if (bLFN && (*ppszFilterArray[nFilters] == CHAR_SPACE))
        {
            LPTSTR pszTemp = ppszFilterArray[nFilters];
            while ((*pszTemp == CHAR_SPACE) && *pszTemp)
            {
                pszTemp = CharNext(pszTemp);
            }
            ppszFilterArray[nFilters] = pszTemp;
        }

        //
        //  Ready to move on to the next filter.  Find the next
        //  filter based upon the type of file system we're using.
        //
        ppszFilterArray[++nFilters] = lstrtok(NULL, pszDelim);

        //
        //  In case we found a pointer to NULL, then look for the
        //  next filter.
        //
        while (ppszFilterArray[nFilters] && !*ppszFilterArray[nFilters])
        {
            ppszFilterArray[nFilters] = lstrtok(NULL, pszDelim);
        }
    }
}


BOOL FoundFilterMatch(LPCTSTR pszIn, BOOL bLFN)
{
    TCHAR szFilter[MAX_FULLPATHNAME];
    LPTSTR pszF[MAXFILTERS + 1];
    BOOL fFoundMatches = FALSE;
    int i;
    
    StrCpyN(szFilter, pszIn, SIZECHARS(szFilter));

    TokenizeFilterString(szFilter, pszF, ARRAYSIZE(pszF), bLFN);

    for (i = 0; i < ARRAYSIZE(pszF) && pszF[i] && !fFoundMatches; i++)
    {
        HANDLE hff;
        WIN32_FIND_DATA FindFileData;

        //
        //  Find First for each filter.
        //
        hff = FindFirstFile(pszF[i], &FindFileData);

        if (hff == INVALID_HANDLE_VALUE)
        {
            continue;
        }

        do
        {
            if ((FindFileData.dwFileAttributes & EXCLBITS) ||
                (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                continue;
            }
            fFoundMatches = TRUE;
            break;

        } while (FindNextFile(hff, &FindFileData));

        FindClose(hff);
    }

    return fFoundMatches;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetAppOpenDir
//
////////////////////////////////////////////////////////////////////////////

void GetAppOpenDir(LPCTSTR pszDir, LPTSTR pszOut, LPITEMIDLIST *ppidl)
{
    BOOL fUseMyDocs = FALSE;
    TCHAR szPersonal[MAX_PATH];

    *pszOut = 0;       // prepare to return empty string
    if (ppidl)
        *ppidl = NULL;

    if (SHGetSpecialFolderPath(NULL, szPersonal, CSIDL_PERSONAL, FALSE))
    {
        
        if (*pszDir)
        {
            //
            //  if the current directory is a temp dir 
            //  or is the mydocs dir, then use my docs
            //  otherwise we should just use this directory
            //
            if ((0 == lstrcmpi(pszDir, szPersonal) || PathIsTemporary(pszDir)))
                fUseMyDocs = TRUE;
        }
        else
        {
            TCHAR szPath[MAX_FULLPATHNAME];

            if (GetCurrentDirectory(ARRAYSIZE(szPath), szPath) 
            && (PathIsTemporary(szPath) || (0 == lstrcmpi(szPath, szPersonal))))
                fUseMyDocs = TRUE;
        }
    }

    if (fUseMyDocs)
    {
        lstrcpy(pszOut, szPersonal);
        if (ppidl)
        {
            SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, ppidl);
        }
    }
    else
    {
        lstrcpy(pszOut, pszDir);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InitCurrentDisk
//
////////////////////////////////////////////////////////////////////////////

VOID InitCurrentDisk(HWND hDlg, POPENFILEINFO pOFI, WORD cmb)
{
    TCHAR szPath[MAX_FULLPATHNAME];

    //
    //  Clear out stale unc stuff from disk info.
    //  Unc \\server\shares are persistent through one popup session
    //  and then we resync with the system.  This is to fix a bug
    //  where a user's startup dir is unc but the system no longer has
    //  a connection and hence the cmb2 appears blank.
    //
    EnableDiskInfo(FALSE, TRUE);

    if (pOFI->pOFN->lpstrInitialDir)
    {
        //
        //  Notice that we force ChangeDir to succeed here
        //  but that TlsGetValue(g_tlsiCurDlg)->lpstrCurDir will return "" which
        //  when fed to SheChangeDirEx means GetCurrentDir will be called.
        //  So, the default cd behavior at startup is:
        //      1. lpstrInitialDir
        //      2. GetCurrentDir
        //
        szPath[0] = 0;
        if ( (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             (StrChr(pOFI->pOFN->lpstrInitialDir, CHAR_SPACE)) &&
             (GetShortPathName( pOFI->pOFN->lpstrInitialDir,
                                szPath,
                                MAX_FULLPATHNAME )) &&
             (szPath[0] != 0) )
        {
            ChangeDir(hDlg, szPath, TRUE, FALSE);
        }
        else
        {
            ChangeDir(hDlg, pOFI->pOFN->lpstrInitialDir, TRUE, FALSE);
        }
    }
    else
    {
        GetAppOpenDir(TEXT(""),szPath, NULL);
        ChangeDir(hDlg, szPath, TRUE, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  vDeleteDirDriveBitmap
//
//  Gets rid of bitmaps, if they exist.
//
////////////////////////////////////////////////////////////////////////////

VOID vDeleteDirDriveBitmap()
{
    if (hbmpOrigMemBmp)
    {
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        if (hbmpDirDrive != HNULL)
        {
            DeleteObject(hbmpDirDrive);
            hbmpDirDrive = HNULL;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadDirDriveBitmap
//
//  Creates the drive/directory bitmap.  If an appropriate bitmap
//  already exists, it just returns immediately.  Otherwise, it
//  loads the bitmap and creates a larger bitmap with both regular
//  and highlight colors.
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadDirDriveBitmap()
{
    BITMAP bmp;
    HANDLE hbmp, hbmpOrig;
    HDC hdcTemp;
    BOOL bWorked = FALSE;

    if ( (hbmpDirDrive != HNULL) &&
         (rgbWindowColor == rgbDDWindow) &&
         (rgbHiliteColor == rgbDDHilite))
    {
        if (SelectObject(hdcMemory, hbmpDirDrive))
        {
            return (TRUE);
        }
    }

    vDeleteDirDriveBitmap();

    rgbDDWindow = rgbWindowColor;
    rgbDDHilite = rgbHiliteColor;

    if (!(hdcTemp = CreateCompatibleDC(hdcMemory)))
    {
        goto LoadExit;
    }

    if (!(hbmp = LoadAlterBitmap(bmpDirDrive, rgbSolidBlue, rgbWindowColor)))
    {
        goto DeleteTempDC;
    }

    GetObject(hbmp, sizeof(BITMAP), (LPTSTR)&bmp);
    dyDirDrive = bmp.bmHeight;
    dxDirDrive = bmp.bmWidth;

    hbmpOrig = SelectObject(hdcTemp, hbmp);

    hbmpDirDrive = CreateDiscardableBitmap(hdcTemp, dxDirDrive * 2, dyDirDrive);
    if (!hbmpDirDrive)
    {
        goto DeleteTempBmp;
    }

    if (!SelectObject(hdcMemory, hbmpDirDrive))
    {
        vDeleteDirDriveBitmap();
        goto DeleteTempBmp;
    }

    BitBlt(hdcMemory, 0, 0, dxDirDrive, dyDirDrive, hdcTemp, 0, 0, SRCCOPY);
    SelectObject(hdcTemp, hbmpOrig);

    DeleteObject(hbmp);

    if (!(hbmp = LoadAlterBitmap(bmpDirDrive, rgbSolidBlue, rgbHiliteColor)))
    {
        goto DeleteTempDC;
    }

    hbmpOrig = SelectObject(hdcTemp, hbmp);
    BitBlt(hdcMemory, dxDirDrive, 0, dxDirDrive, dyDirDrive, hdcTemp, 0, 0, SRCCOPY);
    SelectObject(hdcTemp, hbmpOrig);

    bWorked = TRUE;

DeleteTempBmp:
    DeleteObject(hbmp);

DeleteTempDC:
    DeleteDC(hdcTemp);

LoadExit:
    return (bWorked);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRGBValues
//
//  This sets the various system colors in static variables.  It's
//  called at init time and when system colors change.
//
////////////////////////////////////////////////////////////////////////////

void SetRGBValues()
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


////////////////////////////////////////////////////////////////////////////
//
//  FSetUpFile
//
//  This loads in the resources & initializes the data used by the
//  file dialogs.
//
//  Returns:  TRUE    if successful
//            FALSE   if any bitmap fails
//
////////////////////////////////////////////////////////////////////////////

BOOL FSetUpFile()
{
    if (cLock++)
    {
        return (TRUE);
    }

    SetRGBValues();

    return (LoadDirDriveBitmap());
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPathOffset
//
////////////////////////////////////////////////////////////////////////////

int GetPathOffset(LPTSTR lpszDir)
{
    LPTSTR lpszSkipRoot;

    if (!lpszDir || !*lpszDir)
    {
        return (-1);
    }

    lpszSkipRoot = PathSkipRoot(lpszDir);

    if (lpszSkipRoot)
    {
        return (int)((lpszSkipRoot - 1) - lpszDir);
    }
    else
    {
        //
        //  Unrecognized format.
        //
        return (-1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenCmd
//
//  Handles WM_COMMAND for Open & Save dlgs.
//
//  edt1 = file name
//  lst1 = list of files in current directory matching current pattern
//  cmb1 = lists file patterns
//  stc1 = is current directory
//  lst2 = lists directories on current drive
//  cmb2 = lists drives
//  IDOK = is Open pushbutton
//  IDCANCEL = is Cancel pushbutton
//  chx1 = is for opening read only files
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR FileOpenCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    LPOPENFILENAME pOFN;
    LPTSTR pch, pch2;
    WORD i, sCount, len;
    LRESULT wFlag;
    BOOL_PTR bRet, bHookRet;
    TCHAR szText[MAX_FULLPATHNAME];
    HWND hwnd;
    LPCURDLG  lpCurDlg;


    if (!pOFI)
    {
        return (FALSE);
    }

    pOFN = pOFI->pOFN;
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case ( IDOK ) :
        {
#ifdef UNICODE
            //
            //  Apps that side-effect this message may not have their
            //  internal unicode strings updated (eg. Corel Mosaic).
            //
            //  NOTE: Must preserve the internal flags.
            //
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                DWORD InternalFlags = pOFN->Flags & OFN_ALL_INTERNAL_FLAGS;

                ThunkOpenFileNameA2W(pOFI);

                pOFN->Flags |= InternalFlags;
            }
#endif
            //
            //  If the focus is on the directory box, or if the selection
            //  within the box has changed since the last listing, give a
            //  new listing.
            //
            if (bChangeDir || ((GetFocus() == GetDlgItem(hDlg, lst2)) &&
                               (pOFN->Flags & OFN_DIRSELCHANGED)))
            {
                bChangeDir = FALSE;
                goto ChangingDir;
            }
            else if ((GetFocus() == (hwnd = GetDlgItem(hDlg, cmb2))) &&
                     (pOFN->Flags & OFN_DRIVEDOWN))
            {
                //
                //  If the focus is on the drive or filter combobox, give
                //  a new listing.
                //
                SendDlgItemMessage(hDlg, cmb2, CB_SHOWDROPDOWN, FALSE, 0L);
                break;
            }
            else if ((GetFocus() == (hwnd = GetDlgItem(hDlg, cmb1))) &&
                     (pOFN->Flags & OFN_FILTERDOWN))
            {
                SendDlgItemMessage(hDlg, cmb1, CB_SHOWDROPDOWN, FALSE, 0L);
                lParam = (LPARAM)hwnd;
                goto ChangingFilter;
            }
            else
            {
#ifdef UNICODE
                //
                //  Visual Basic passes in an uninitialized lpstrDefExt string.
                //  Since we only have to use it in OKButtonPressed, update
                //  lpstrDefExt here along with whatever else is only needed
                //  in OKButtonPressed.
                //
                if (pOFI->ApiType == COMDLG_ANSI)
                {
                    ThunkOpenFileNameA2WDelayed(pOFI);
                }
#endif
                if (OKButtonPressed(hDlg, pOFI, bSave))
                {
                    bRet = TRUE;

                    if (pOFN->lpstrFile)
                    {
                        if (!(pOFN->Flags & OFN_NOVALIDATE))
                        {
                            if (pOFN->nMaxFile >= 3)
                            {
                                if ((pOFN->lpstrFile[0] == 0) ||
                                    (pOFN->lpstrFile[1] == 0) ||
                                    (pOFN->lpstrFile[2] == 0))
                                {
                                    bRet = FALSE;
                                    StoreExtendedError(FNERR_BUFFERTOOSMALL);
                                }
                            }
                            else
                            {
                                bRet = FALSE;
                                StoreExtendedError(FNERR_BUFFERTOOSMALL);
                            }
                        }
                    }

                    goto AbortDialog;
                }
            }

            SendDlgItemMessage(hDlg, edt1, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            return (TRUE);

            break;
        }
        case ( IDCANCEL ) :
        {
            bRet = FALSE;
            g_bUserPressedCancel = TRUE;
            goto AbortDialog;
        }
        case ( IDABORT ) :
        {
            bRet = (BYTE)lParam;
AbortDialog:
            //
            //  Return the most recently used filter.
            //
            pOFN->nFilterIndex = (WORD)SendDlgItemMessage( hDlg,
                                                           cmb1,
                                                           CB_GETCURSEL,
                                                           (WPARAM)0,
                                                           (LPARAM)0 );
            if (pOFN->lpstrCustomFilter)
            {
                len = (WORD)(lstrlen(pOFN->lpstrCustomFilter) + 1);
                sCount = (WORD)lstrlen(pOFI->szLastFilter);
                if (pOFN->nMaxCustFilter > (DWORD)(sCount + len))
                {
                    lstrcpy(pOFN->lpstrCustomFilter + len, pOFI->szLastFilter);
                }
            }

            if (!pOFN->lpstrCustomFilter ||
                (*pOFN->lpstrCustomFilter == CHAR_NULL))
            {
                pOFN->nFilterIndex++;
            }

            if (((GET_WM_COMMAND_ID(wParam, lParam)) == IDOK) && pOFN->lpfnHook)
            {
                LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                if (pOFI->ApiType == COMDLG_ANSI)
                {
                    ThunkOpenFileNameW2A(pOFI);
                    bHookRet = (*lpfnHook)( hDlg,
                                            msgFILEOKA,
                                            0,
                                            (LPARAM)pOFI->pOFNA );
                    //
                    //  For apps that side-effect pOFNA stuff and expect it to
                    //  be preserved through dialog exit, update internal
                    //  struct after the hook proc is called.
                    //
                    ThunkOpenFileNameA2W(pOFI);
                }
                else
#endif
                {
                    bHookRet = (*lpfnHook)( hDlg,
                                            msgFILEOKW,
                                            0,
                                            (LPARAM)pOFI->pOFN );
                }
                if (bHookRet)
                {
                    HourGlass(FALSE);
                    break;
                }
            }

            wNoRedraw = 0;

            if (pOFI->pOFN->Flags & OFN_ENABLEHOOK)
            {
                LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                glpfnFileHook = lpfnHook;
            }

            RemoveProp(hDlg, FILEPROP);

            EndDialog(hDlg, bRet);

            if (pOFI)
            {
                if ((pOFN->Flags & OFN_NOCHANGEDIR) && *pOFI->szCurDir)
                {
                    ChangeDir(hDlg, pOFI->szCurDir, TRUE, FALSE);
                }
            }

            //
            //  WARNING:
            //  If the app subclasses ID_ABORT, the worker thread will never
            //  get exited.  This will cause problems.  Currently, there are
            //  no apps that do this, though.
            //

            return (TRUE);
            break;
        }
        case ( edt1 ) :
        {
            if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE )
            {
                int iIndex, iCount;
                HWND hLBox = GetDlgItem(hDlg, lst1);
                WORD wIndex = (WORD)SendMessage(hLBox, LB_GETCARETINDEX, 0, 0);

                szText[0] = CHAR_NULL;

                if (wIndex == (WORD)LB_ERR)
                {
                    break;
                }

                SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                             WM_GETTEXT,
                             (WPARAM)MAX_FULLPATHNAME,
                             (LPARAM)szText );

                if ((iIndex = (int)SendMessage( hLBox,
                                                LB_FINDSTRING,
                                                (WPARAM)(wIndex - 1),
                                                (LPARAM)szText )) != LB_ERR)
                {
                    RECT rRect;

                    iCount = (int)SendMessage(hLBox, LB_GETTOPINDEX, 0, 0L);
                    GetClientRect(hLBox, (LPRECT)&rRect);

                    if ((iIndex < iCount) ||
                        (iIndex >= (iCount + rRect.bottom / dyText)))
                    {
                        SendMessage(hLBox, LB_SETCARETINDEX, (WPARAM)iIndex, 0);
                        SendMessage(hLBox, LB_SETTOPINDEX, (WPARAM)iIndex, 0);
                    }
                }
                return (TRUE);
            }
            else if ( GET_WM_COMMAND_CMD(wParam, lParam) ==  EN_SETFOCUS )
            {
                SetModeBias(MODEBIASMODE_FILENAME);
            }
            else if ( GET_WM_COMMAND_CMD(wParam, lParam)== EN_KILLFOCUS )
            {
                SetModeBias(MODEBIASMODE_DEFAULT);
            }
            break;
        }
        case ( lst1 ) :
        {
            //
            //  A double click means OK.
            //
            if (GET_WM_COMMAND_CMD(wParam, lParam)== LBN_DBLCLK)
            {
                SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, 0, 0));
                return (TRUE);
            }
            else if (pOFN && (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE))
            {
                if (pOFN->Flags & OFN_ALLOWMULTISELECT)
                {
                    int *pSelIndex;

                    //
                    //  Muliselection allowed.
                    //
                    sCount = (SHORT)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                                LB_GETSELCOUNT,
                                                0,
                                                0L );
                    if (!sCount)
                    {
                        //
                        //  If nothing selected, clear edit control.
                        //
                        SetDlgItemText(hDlg, edt1, szNull);
                    }
                    else
                    {
                        DWORD cchMemBlockSize = 2048;
                        DWORD cchTotalLength = 0;

                        pSelIndex = (int *)LocalAlloc(LPTR, sCount * sizeof(int));
                        if (!pSelIndex)
                        {
                            goto LocalFailure1;
                        }

                        sCount = (SHORT)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETSELITEMS,
                                            (WPARAM)sCount,
                                            (LONG_PTR)(LPTSTR)pSelIndex );

                        pch2 = pch = (LPTSTR)
                             LocalAlloc(LPTR, cchMemBlockSize * sizeof(TCHAR));
                        if (!pch)
                        {
                            goto LocalFailure2;
                        }

                        for (*pch = CHAR_NULL, i = 0; i < sCount; i++)
                        {
                            len = (WORD)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETTEXTLEN,
                                            (WPARAM)(*(pSelIndex + i)),
                                            (LPARAM)0 );

                            //
                            //  Add the length of the selected file to the
                            //  total length of selected files. + 2 for the
                            //  space that goes in between files and for the
                            //  possible dot added at the end of the filename
                            //  if the file does not have an extension.
                            //
                            cchTotalLength += (len + 2);

                            if (cchTotalLength > cchMemBlockSize)
                            {
                                LPTSTR pTemp;
                                UINT cchPrevLen = cchTotalLength - (len + 2);

                                cchMemBlockSize = cchMemBlockSize << 1;
                                pTemp = (LPTSTR)LocalReAlloc(
                                                 pch,
                                                 cchMemBlockSize * sizeof(TCHAR),
                                                 LMEM_MOVEABLE );
                                if (pTemp)
                                {
                                    pch = pTemp;
                                    pch2 = pch + cchPrevLen;
                                }
                                else
                                {
                                    LocalFree(pch);
                                    goto LocalFailure2;
                                }

                            }

                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETTEXT,
                                         (WPARAM)(*(pSelIndex + i)),
                                         (LONG_PTR)pch2 );

                            if (!StrChr(pch2, CHAR_DOT))
                            {
                                *(pch2 + len++) = CHAR_DOT;
                            }

                            pch2 += len;
                            *pch2++ = CHAR_SPACE;
                        }
                        if (pch2 != pch)
                        {
                            *--pch2 = CHAR_NULL;
                        }

                        SetDlgItemText(hDlg, edt1, pch);
                        LocalFree((HANDLE)pch);
LocalFailure2:
                        LocalFree((HANDLE)pSelIndex);
                    }
LocalFailure1:
                    if (pOFN->lpfnHook)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETCARETINDEX,
                                               0,
                                               0L );
                        if (!(i & 0x8000))
                        {
                            wFlag = (SendMessage(
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETSEL,
                                         (WPARAM)i,
                                         0L )
                                     ? CD_LBSELADD
                                     : CD_LBSELSUB);
                        }
                        else
                        {
                            wFlag = CD_LBSELNOITEMS;
                        }
                    }
                }
                else
                {
                    //
                    //  Multiselection is not allowed.
                    //  Put the file name in the edit control.
                    //
                    szText[0] = CHAR_NULL;

                    i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                           LB_GETCURSEL,
                                           0,
                                           0L );

                    if (i != (WORD)LB_ERR)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETTEXT,
                                               (WPARAM)i,
                                               (LONG_PTR)szText );

                        if (!StrChr(szText, CHAR_DOT))
                        {
                            if (i < MAX_FULLPATHNAME - 1)
                            {
                                szText[i]     = CHAR_DOT;
                                szText[i + 1] = CHAR_NULL;
                            }
                        }

                        if (!bCasePreserved)
                        {
                            CharLower(szText);
                        }

                        SetDlgItemText(hDlg, edt1, szText);
                        if (pOFN->lpfnHook)
                        {
                            i = (WORD)SendMessage(
                                          GET_WM_COMMAND_HWND(wParam, lParam),
                                          LB_GETCURSEL,
                                          0,
                                          0L );
                            wFlag = CD_LBSELCHANGE;
                        }
                    }
                }

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                    else
#endif
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                }

                SendDlgItemMessage(hDlg, edt1, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                return (TRUE);
            }
            break;
        }
        case ( cmb1 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    if (wWinVer >= 0x030A)
                    {
                        pOFN->Flags |= OFN_FILTERDOWN;
                    }
                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(cmb1, lParam, MYCBN_DRAW) );

                    return (TRUE);
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    //
                    //  Need to change the file listing in lst1.
                    //
                    if (pOFN->Flags & OFN_FILTERDOWN)
                    {
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_DRAW ) :
                {
                    SHORT nIndex;
                    LPCTSTR lpFilter;

                    HourGlass(TRUE);

                    pOFN->Flags &= ~OFN_FILTERDOWN;
ChangingFilter:
                    nIndex = (SHORT)SendDlgItemMessage( hDlg,
                                                        cmb1,
                                                        CB_GETCURSEL,
                                                        0,
                                                        0L );
                    if (nIndex < 0)
                    {
                        //
                        //  No current selection.
                        //
                        break;
                    }

                    //
                    //  Must also check if filter contains anything.
                    //
                    if (nIndex ||
                        !(pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
                    {
                        lpFilter = pOFN->lpstrFilter +
                                   SendDlgItemMessage( hDlg,
                                                       cmb1,
                                                       CB_GETITEMDATA,
                                                       (WPARAM)nIndex,
                                                       0L );
                    }
                    else
                    {
                        lpFilter = pOFN->lpstrCustomFilter +
                                   lstrlen(pOFN->lpstrCustomFilter) + 1;
                    }
                    if (*lpFilter)
                    {
                        GetDlgItemText( hDlg,
                                        edt1,
                                        szText,
                                        MAX_FULLPATHNAME - 1 );
                        bRet = (!szText[0] ||
                                (StrChr(szText, CHAR_STAR)) ||
                                (StrChr(szText, CHAR_QMARK)));
                        lstrcpy(szText, lpFilter);
                        if (bRet)
                        {
                            CharLower(szText);
                            SetDlgItemText(hDlg, edt1, szText);
                            SendDlgItemMessage( hDlg,
                                                edt1,
                                                EM_SETSEL,
                                                (WPARAM)0,
                                                (LPARAM)-1 );
                        }
                        FListAll(pOFI, hDlg, szText);
                        if (!bInitializing)
                        {
                            lstrcpy(pOFI->szLastFilter, szText);
#ifdef WINNT
                            //
                            //  Provide dynamic lpstrDefExt updating
                            //  when lpstrDefExt is user initialized.
                            //
                            if (StrChr((LPTSTR)lpFilter, CHAR_DOT) &&
                                pOFN->lpstrDefExt)
                            {
                                DWORD cbLen = MIN_DEFEXT_LEN - 1; // only 1st 3
                                LPTSTR lpTemp = (LPTSTR)(pOFN->lpstrDefExt);

                                while (*lpFilter++ != CHAR_DOT);
                                if (!(StrChr((LPTSTR)lpFilter, CHAR_STAR)) &&
                                    !(StrChr((LPTSTR)lpFilter, CHAR_QMARK)))
                                {
                                    while (cbLen--)
                                    {
                                        *lpTemp++ = *lpFilter++;
                                    }
                                    *lpTemp = CHAR_NULL;
                                }
                            }
#endif
                        }
                    }
                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
#ifdef UNICODE
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                        else
#endif
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                    }
                    HourGlass(FALSE);
                    return (TRUE);

                    break;
                }

                default :
                {
                    break;
                }
            }
            break;
        }
        case ( lst2 ) :
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
            {
                if (!(pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    if ((DWORD)SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L ) != pOFI->idirSub - 1)
                    {
                        StripFileName(hDlg, IS16BITWOWAPP(pOFN));
                        pOFN->Flags |= OFN_DIRSELCHANGED;
                    }
                }
                return (TRUE);
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SETFOCUS)
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                SendMessage( GetDlgItem(hDlg, IDCANCEL),
                             BM_SETSTYLE,
                             (WPARAM)BS_PUSHBUTTON,
                             (LPARAM)TRUE );
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_KILLFOCUS)
            {
                if (pOFN && (pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    pOFN->Flags &= ~OFN_DIRSELCHANGED;
                }
                else
                {
                    bChangeDir = FALSE;
                }
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
            {
                TCHAR szNextDir[CCHNETPATH];
                LPTSTR lpCurDir;
                DWORD idir;
                DWORD idirNew;
                int cb;
                LPTSTR pstrPath;
ChangingDir:
                bChangeDir = FALSE;
                pOFN->Flags &= ~OFN_DIRSELCHANGED;
                idirNew = (DWORD)SendDlgItemMessage( hDlg,
                                                     lst2,
                                                     LB_GETCURSEL,
                                                     0,
                                                     0L );
                //
                //  Can use relative path name.
                //
                *pOFI->szPath = 0;
                if (idirNew >= pOFI->idirSub)
                {
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   (WPARAM)idirNew,
                                                   (LPARAM)pOFI->szPath );
                    //
                    //  sanity check
                    //
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    lstrcpy(szNextDir, lpCurDir);

                    //
                    //  Fix phenom with c:\\foobar - because of inconsistency
                    //  in directory display guaranteed to have a valid
                    //  lpCurDir here, right?
                    //
                    PathAddBackslash(szNextDir);
                    lstrcat(szNextDir, pOFI->szPath);

                    pstrPath = szNextDir;

                    idirNew = pOFI->idirSub;    // for msgLBCHANGE message
                }
                else
                {
                    //
                    //  Need full path name.
                    //
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   0,
                                                   (LPARAM)pOFI->szPath );

                    //
                    //  The following condition is necessary because wb displays
                    //  \\server\share (the disk resource name) for unc, but
                    //  for root paths (eg. c:\) for device conns, this in-
                    //  consistency is hacked around here and in FillOutPath.
                    //
                    if (DBL_BSLASH(pOFI->szPath))
                    {
                        lstrcat(pOFI->szPath, TEXT("\\"));
                        cb++;
                    }

                    for (idir = 1; idir <= idirNew; ++idir)
                    {
                        cb += (int) SendDlgItemMessage(
                                             hDlg,
                                             lst2,
                                             LB_GETTEXT,
                                             (WPARAM)idir,
                                             (LPARAM)&pOFI->szPath[cb] );

                        pOFI->szPath[cb++] = CHAR_BSLASH;
                    }

                    //
                    //  The root is a special case.
                    //
                    if (idirNew)
                    {
                        pOFI->szPath[cb - 1] = CHAR_NULL;
                    }

                    pstrPath = pOFI->szPath;
                }

                if (!*pstrPath ||
                    (ChangeDir(hDlg, pstrPath, FALSE, TRUE) == CHANGEDIR_FAILED))
                {
                    break;
                }

                //
                //  List all directories under this one.
                //
                UpdateListBoxes(hDlg, pOFI, NULL, mskDirectory);

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                    else
#endif
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                }
                return (TRUE);
            }
            break;
        }
        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    pOFN->Flags |= OFN_DRIVEDOWN;

                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    //
                    //  It would seem reasonable to merely do the update
                    //  at this point, but that would rely on message
                    //  ordering, which isnt a smart move.  In fact, if
                    //  you hit ALT-DOWNARROW, DOWNARROW, ALT-DOWNARROW,
                    //  you receive CBN_DROPDOWN, CBN_SELCHANGE, and then
                    //  CBN_CLOSEUP.  But if you use the mouse to choose
                    //  the same element, the last two messages trade
                    //  places.  PostMessage allows all messages in the
                    //  sequence to be processed, and then updates are
                    //  done as needed.
                    //
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(
                                     cmb2,
                                     GET_WM_COMMAND_HWND(wParam, lParam),
                                     MYCBN_DRAW ) );
                    return (TRUE);
                    break;
                }
                case ( MYCBN_LIST ) :
                {
                    LoadDrives(hDlg);
                    break;
                }
                case ( MYCBN_REPAINT ) :
                {
                    int cchCurDir;
                    LPTSTR lpCurDir;

                    // sanity
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    cchCurDir = GetPathOffset(lpCurDir);
                    if (cchCurDir != -1)
                    {
                        TCHAR szRepaintDir[CCHNETPATH];
                        HWND hCmb2 = (HWND)lParam;

                        lstrcpy(szRepaintDir, lpCurDir);
                        szRepaintDir[cchCurDir] = CHAR_NULL;
                        SendMessage( hCmb2,
                                     CB_SELECTSTRING,
                                     (WPARAM)-1,
                                     (LPARAM)szRepaintDir );
                    }
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    StripFileName(hDlg, IS16BITWOWAPP(pOFN));

                    //
                    //  Version check not needed, since flag never set
                    //  for versions not supporting CBN_CLOSEUP. Putting
                    //  check at CBN_DROPDOWN is more efficient since it
                    //  is less frequent than CBN_SELCHANGE.

                    if (pOFN->Flags & OFN_DRIVEDOWN)
                    {
                        //
                        //  Don't fill lst2 while the combobox is down.
                        //
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_CHANGEDIR ) :
                case ( MYCBN_DRAW ) :
                {
                    TCHAR szTitle[WARNINGMSGLENGTH];
                    LPTSTR lpFilter;
                    int nDiskInd, nInd;
                    DWORD dwType = 0;
                    LPTSTR lpszPath = NULL;
                    LPTSTR lpszDisk = NULL;
                    HWND hCmb2;
                    OFN_DISKINFO *pofndiDisk = NULL;
                    static szDrawDir[CCHNETPATH];
                    int nRet;

                    HourGlass(TRUE);

                    //
                    //  Clear Flag for future CBN_SELCHANGE messeges.
                    //
                    pOFN->Flags &= ~OFN_DRIVEDOWN;

                    //
                    //  Change the drive.
                    //
                    szText[0] = CHAR_NULL;

                    hCmb2 = (HWND)lParam;

                    if (hCmb2 != NULL)
                    {
                        nInd = (int) SendMessage(hCmb2, CB_GETCURSEL, 0, 0L);

                        if (nInd != CB_ERR)
                        {
                            SendMessage( hCmb2,
                                         CB_GETLBTEXT,
                                         nInd,
                                         (LPARAM)(LPTSTR)szDrawDir );
                        }

                        if ((nInd == CB_ERR) || ((INT_PTR)pofndiDisk == CB_ERR))
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir)
                                {
                                    lstrcpy((LPTSTR)szDrawDir,
                                            lpCurDlg->lpstrCurDir);
                                }
                            }
                        }

                        CharLower((LPTSTR)szDrawDir);

                        //
                        //  Should always succeed.
                        //
                        nDiskInd = DiskAddedPreviously(0, (LPTSTR)szDrawDir);
                        if (nDiskInd != 0xFFFFFFFF)
                        {
                            pofndiDisk = &gaDiskInfo[nDiskInd];
                        }
                        else
                        {
                            //
                            //  Skip update in the case where it fails.
                            //
                            return (TRUE);
                        }

                        dwType = pofndiDisk->dwType;

                        lpszDisk = pofndiDisk->lpPath;
                    }

                    if ((GET_WM_COMMAND_CMD(wParam, lParam)) == MYCBN_CHANGEDIR)
                    {
                        if (lpNetDriveSync)
                        {
                            lpszPath = lpNetDriveSync;
                            lpNetDriveSync = NULL;
                        }
                        else
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir)
                                {
                                    lstrcpy((LPTSTR)szDrawDir,
                                            lpCurDlg->lpstrCurDir);

                                    lpszPath = (LPTSTR)szDrawDir;
                                }
                            }
                        }
                    }
                    else
                    {
                        lpszPath = lpszDisk;
                    }

                    if (bInitializing)
                    {
                        lpFilter = szTitle;
                        if (pOFN->lpstrFile &&
                            (StrChr(pOFN->lpstrFile, CHAR_STAR) ||
                             StrChr(pOFN->lpstrFile, CHAR_QMARK)))
                        {
                            lstrcpy(lpFilter, pOFN->lpstrFile);
                        }
                        else
                        {
                            HWND hcmb1 = GetDlgItem(hDlg, cmb1);

                            nInd = (int) SendMessage(hcmb1, CB_GETCURSEL, 0, 0L);
                            if (nInd == CB_ERR)
                            {
                                //
                                //  No current selection.
                                //
                                goto NullSearch;
                            }

                            //
                            //  Must also check if filter contains anything.
                            //
                            if (nInd ||
                                !(pOFN->lpstrCustomFilter &&
                                  *pOFN->lpstrCustomFilter))
                            {
                                lpFilter = (LPTSTR)(pOFN->lpstrFilter);
                                lpFilter += SendMessage( hcmb1,
                                                         CB_GETITEMDATA,
                                                         (WPARAM)nInd,
                                                         0 );
                            }
                            else
                            {
                                lpFilter = pOFN->lpstrCustomFilter;
                                lpFilter += lstrlen(pOFN->lpstrCustomFilter) + 1;
                            }
                        }
                    }
                    else
                    {
NullSearch:
                        lpFilter = NULL;
                    }

                    //
                    //  UpdateListBoxes cuts up filter string in place.
                    //
                    if (lpFilter)
                    {
                        lstrcpy(szTitle, lpFilter);
                        CharLower(szTitle);
                    }

                    if (dwType == REMDRVBMP)
                    {
                        DWORD err = WNetRestoreConnection(hDlg, lpszDisk);

                        if (err != WN_SUCCESS)
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }

                        pofndiDisk->dwType = NETDRVBMP;

                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                   hCmb2,
                                   CB_SELECTSTRING,
                                   (WPARAM)-1,
                                   (LPARAM)(LPTSTR)pofndiDisk->lpAbbrName ),
                            (LPARAM)NETDRVBMP );
                    }

                    //
                    //  Calls to ChangeDir will call SelDisk, so no need
                    //  to update cmb2 on our own here (used to be after
                    //  updatelistboxes).
                    //
                    if ((nRet = ChangeDir( hDlg,
                                           lpszPath,
                                           FALSE,
                                           FALSE )) == CHANGEDIR_FAILED)
                    {
                        int mbRet;

                        while (nRet == CHANGEDIR_FAILED)
                        {
                            if (dwType == FLOPPYBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_DRIVE,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION));
                            }
                            else if (dwType == CDDRVBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_CDROM,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION) );
                            }
                            else
                            {
                                //
                                //  See if it's a RAW volume.
                                //
                                if (dwType == HARDDRVBMP &&
                                    GetLastError() == ERROR_UNRECOGNIZED_VOLUME)
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_UNRECOGNIZED_VOLUME,
                                                   (UINT)(MB_OK |
                                                          MB_ICONEXCLAMATION) );
                                }
                                else
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_DIR_ACCESS_DENIED,
                                                   (UINT)(MB_RETRYCANCEL |
                                                          MB_ICONEXCLAMATION) );
                                }
                            }

                            if (bFirstTime || (mbRet != IDRETRY))
                            {
                                lpszPath = NULL;
                                nRet = ChangeDir(hDlg, lpszPath, TRUE, FALSE);
                            }
                            else
                            {
                                nRet = ChangeDir(hDlg, lpszPath, FALSE, FALSE);
                            }
                        }
                    }

                    UpdateListBoxes( hDlg,
                                     pOFI,
                                     lpFilter ? szTitle : lpFilter,
                                     (WORD)(mskDrives | mskDirectory) );

                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                        nInd = (int) SendDlgItemMessage( hDlg,
                                                         cmb2,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0 );
#ifdef UNICODE
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                        else
#endif
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                    }

                    HourGlass(FALSE);

                    return (TRUE);

                    break;
                }
                default :
                {
                    break;
                }
            }
            break;
        }
        case ( pshHelp ) :
        {
#ifdef UNICODE
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                if (msgHELPA && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPA,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            else
#endif
            {
                if (msgHELPW && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPW,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            break;
        }
        case ( psh14 ) :
        {
            bGetNetDrivesSync = TRUE;
            if (CallNetDlg(hDlg))
            {
                LNDSetEvent(hDlg);
            }
            else
            {
                bGetNetDrivesSync = FALSE;
            }
            break;
        }
        default :
        {
            break;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateListBoxes
//
//  Fills out File and Directory List Boxes in a single pass
//  given (potentially) multiple filters
//
//  It assumes the string of extensions are delimited by semicolons.
//
//  hDlg        Handle to File Open/Save dialog
//  pOFI        pointer to OPENFILEINFO structure
//  lpszFilter  pointer to filter, if NULL, use pOFI->szSpecCur
//  wMask       mskDirectory and/or mskDrives, or NULL
//
//  Returns:  TRUE   if match
//            FALSE  if not
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateListBoxes(
    HWND hDlg,
    POPENFILEINFO pOFI,
    LPTSTR lpszFilter,
    WORD wMask)
{
    LPTSTR lpszF[MAXFILTERS + 1];
    LPTSTR lpszTemp;
    SHORT i, nFilters;
    HWND hFileList = GetDlgItem(hDlg, lst1);
    HWND hDirList = GetDlgItem(hDlg, lst2);
    BOOL bRet = FALSE;
    TCHAR szSpec[MAX_FULLPATHNAME];
    BOOL bDriveChange;
    BOOL bFindAll = FALSE;
    RECT rDirLBox;
    BOOL bLFN;
    HANDLE hff;
    DWORD dwErr;
    WIN32_FIND_DATA FindFileData;
    TCHAR szBuffer[MAX_FULLPATHNAME];       // add one for CHAR_DOT
    WORD wCount;
    LPCURDLG lpCurDlg;


    //
    //  Save the drive bit and then clear it out.
    //
    bDriveChange = wMask & mskDrives;
    wMask &= ~mskDrives;

    if (!lpszFilter)
    {
        GetDlgItemText( hDlg,
                        edt1,
                        lpszFilter = szSpec,
                        MAX_FULLPATHNAME - 1 );

        //
        //  If any directory or drive characters are in there, or if there
        //  are no wildcards, use the default spec.
        //
        if ( StrChr(szSpec, CHAR_BSLASH) ||
             StrChr(szSpec, CHAR_SLASH)  ||
             StrChr(szSpec, CHAR_COLON)  ||
             (!((StrChr(szSpec, CHAR_STAR)) ||
                (StrChr(szSpec, CHAR_QMARK)))) )
        {
            lstrcpy(szSpec, pOFI->szSpecCur);
        }
        else
        {
            lstrcpy(pOFI->szLastFilter, szSpec);
        }
    }

    //
    //  We need to find out what kind of a drive we are running
    //  on in order to determine if spaces are valid in a filename
    //  or not.
    //
    bLFN = IsLFNDriveX(hDlg, TEXT("\0"));

    //
    //  Find the first filter in the string, and add it to the
    //  array.
    //
    if (bLFN)
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonTab);
    }
    else
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonSpaceTab);
    }

    //
    //  Now we are going to loop through all the filters in the string
    //  parsing the one we already have, and then finding the next one
    //  and starting the loop over again.
    //
    while (lpszF[nFilters] && (nFilters < MAXFILTERS))
    {
        //
        //  Check to see if the first character is a space.
        //  If so, remove the spaces, and save the pointer
        //  back into the same spot.  Why?  because the
        //  FindFirstFile/Next api will _still_ work on
        //  filenames that begin with a space because
        //  they also look at the short names.  The
        //  short names will begin with the same first
        //  real letter as the long filename.  For
        //  example, the long filename is "  my document"
        //  the first letter of this short name is "m",
        //  so searching on "m*.*" or " m*.*" will yield
        //  the same results.
        //
        if (bLFN && (*lpszF[nFilters] == CHAR_SPACE))
        {
            lpszTemp = lpszF[nFilters];
            while ((*lpszTemp == CHAR_SPACE) && *lpszTemp)
            {
                lpszTemp = CharNext(lpszTemp);
            }

            lpszF[nFilters] = lpszTemp;
        }

        //
        //  The original code used to do a CharUpper here to put the
        //  filter strings in upper case.  EG:  *.TXT  However, this
        //  is not a good thing to do for Turkish.  Capital 'i' does
        //  not equal 'I', so the CharUpper is being removed.
        //
        //  CharUpper(lpszF[nFilters]);

        //
        //  Compare the filter with *.*.  If we find *.* then
        //  set the boolean bFindAll, and this will cause the
        //  files listbox to be filled in at the same time the
        //  directories listbox is filled.  This saves time
        //  from walking the directory twice (once for the directory
        //  names and once for the filenames).
        //
        if (!lstrcmpi(lpszF[nFilters], szStarDotStar))
        {
            bFindAll = TRUE;
        }

        //
        //  Now we need to check if this filter is a duplicate
        //  of an already existing filter.
        //
        for (wCount = 0; wCount < nFilters; wCount++)
        {
            //
            //  If we find a duplicate, decrement the current
            //  index pointer by one so that the last location
            //  is written over (thus removing the duplicate),
            //  and break out of this loop.
            //
            if (!lstrcmpi(lpszF[nFilters], lpszF[wCount]))
            {
                nFilters--;
                break;
            }
        }

        //
        //  Ready to move on to the next filter.  Find the next
        //  filter based upon the type of file system we're using.
        //
        if (bLFN)
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonTab);
        }
        else
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
        }

        //
        //  In case we found a pointer to NULL, then look for the
        //  next filter.
        //
        while (lpszF[nFilters] && !*lpszF[nFilters])
        {
            if (bLFN)
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonTab);
            }
            else
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
            }
        }
    }

    //
    //  Add NULL terminator only if needed.
    //
    if (nFilters >= MAXFILTERS)
    {
        lpszF[MAXFILTERS] = 0;
    }

    HourGlass(TRUE);

    SendMessage(hFileList, WM_SETREDRAW, FALSE, 0L);
    SendMessage(hFileList, LB_RESETCONTENT, 0, 0L);
    if (wMask & mskDirectory)
    {
        wNoRedraw |= 2;     // HACK!!! WM_SETREDRAW isn't complete
        SendMessage(hDirList, WM_SETREDRAW, FALSE, 0L);

        //
        //  LB_RESETCONTENT causes InvalidateRect(hDirList, 0, TRUE) to be
        //  sent as well as repositioning the scrollbar thumb and drawing
        //  it immediately.  This causes flicker when the LB_SETCURSEL is
        //  made, as it clears out the listbox by erasing the background of
        //  each item.
        //
        SendMessage(hDirList, LB_RESETCONTENT, 0, 0L);
    }

    //
    //  Always open enumeration for *.*
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
    hff = FindFirstFile(szStarDotStar, &FindFileData);

    if ( hff == INVALID_HANDLE_VALUE)
    {
        //
        //  Error.  Call GetLastError to determine what happened.
        //
        dwErr = GetLastError();

        //
        //  With the ChangeDir logic handling AccessDenied for cds,
        //  if we are not allowed to enum files, that's ok, just get out.
        //
        if (dwErr == ERROR_ACCESS_DENIED)
        {
            wMask = mskDirectory;
            goto Func4EFailure;
        }

        //
        //  For bad path of bad filename.
        //
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            wMask = mskDrives;
            goto Func4EFailure;
        }
    }

    //
    //  A listing was made, even if empty.
    //
    bRet = TRUE;
    wMask &= mskDirectory;

    //
    //  GetLastError says no more files.
    //
    if (hff == INVALID_HANDLE_VALUE  && dwErr == ERROR_FILE_NOT_FOUND)
    {
        //
        //  Things went well, but there are no files.
        //
        goto NoMoreFilesFound;
    }

    do
    {
        if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
        {
#ifdef UNICODE
            UNICODE_STRING Name;
            BOOLEAN fSpace = FALSE;

            RtlInitUnicodeString(&Name, FindFileData.cFileName);
            if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
            {
                //
                //  Legal 8.3 name and no spaces, so use the principal
                //  file name.
                //
                lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
            }
            else
#endif
            {
#ifdef WINNT
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                //
                //  Use the alternate file name.
                //
                lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
#else
                if (FindFileData.cAlternateFileName[0])
                {
                    //
                    //  Use the alternate file name.
                    //
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
                }
                else
                {
                    //
                    //  Use the main file name.
                    //
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                }
#endif
            }
        }
        else
        {
            lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
        }

        if ((FindFileData.dwFileAttributes & EXCLBITS))
        {
            continue;
        }

        if ((pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT))
        {
            if (StrChr(szBuffer, CHAR_SPACE))
            {
                //
                //  HPFS does not support alternate filenames
                //  for multiselect, bump all spacey filenames.
                //
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
            }
        }

        if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (wMask & mskDirectory)
            {
                //
                //  Don't include the subdirectories "." and "..".
                //
                if (szBuffer[0] == CHAR_DOT)
                {
                    if ((szBuffer[1] == CHAR_NULL) ||
                        ((szBuffer[1] == CHAR_DOT) && (szBuffer[2] == CHAR_NULL)))
                    {
                        continue;
                    }
                }
                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }
                i = (WORD)SendMessage( hDirList,
                                       LB_ADDSTRING,
                                       0,
                                       (DWORD_PTR)szBuffer );
            }
        }
        else if (bFindAll)
        {
            if (!bCasePreserved)
            {
                CharLower(szBuffer);
            }

            SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
        }
    } while (FindNextFile(hff, &FindFileData));

    if (hff == INVALID_HANDLE_VALUE)
    {
        goto Func4EFailure;
    }

    FindClose(hff);

    if (!bFindAll)
    {
        for (i = 0; lpszF[i]; i++)
        {
            if (!lstrcmpi(lpszF[i], szStarDotStar))
            {
                continue;
            }

            //
            //  Find First for each filter.
            //
            hff = FindFirstFile(lpszF[i], &FindFileData);

            if (hff == INVALID_HANDLE_VALUE)
            {
                DWORD dwErr = GetLastError();

                if ((dwErr == ERROR_FILE_NOT_FOUND) ||
                    (dwErr == ERROR_INVALID_NAME))
                {
                    //
                    //  Things went well, but there are no files.
                    //
                    continue;
                }
                else
                {
                    wMask = mskDrives;
                    goto Func4EFailure;
                }
            }

            do
            {
                if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
                {
#ifdef UNICODE
                    UNICODE_STRING Name;
                    BOOLEAN fSpace = FALSE;

                    RtlInitUnicodeString(&Name, FindFileData.cFileName);
                    if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
                    {
                        //
                        //  Legal 8.3 name and no spaces, so use the principal
                        //  file name.
                        //
                        lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                    }
                    else
#endif
                    {
#ifdef WINNT
                        if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                        {
                            continue;
                        }

                        //
                        //  Use the alternate file name.
                        //
                        lstrcpy( szBuffer,
                                 (LPTSTR)FindFileData.cAlternateFileName );
#else
                        if (FindFileData.cAlternateFileName[0])
                        {
                            //
                            //  Use the alternate file name.
                            //
                            lstrcpy( szBuffer,
                                     (LPTSTR)FindFileData.cAlternateFileName );
                        }
                        else
                        {
                            //
                            //  Use the main file name.
                            //
                            lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                        }
#endif
                    }
                }
                else
                {
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);

                    if (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT)
                    {
                        if (StrChr(szBuffer, CHAR_SPACE))
                        {
                            //
                            //  HPFS does not support alternate filenames
                            //  for multiselect, bump all spacey filenames.
                            //
                            if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                            {
                                continue;
                            }

                            lstrcpy( szBuffer,
                                     (LPTSTR)FindFileData.cAlternateFileName );
                        }
                    }
                }

                if ((FindFileData.dwFileAttributes & EXCLBITS) ||
                    (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    continue;
                }

                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }

                SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
            } while (FindNextFile(hff, &FindFileData));

            if (hff != INVALID_HANDLE_VALUE)
            {
                FindClose(hff);
            }
        }
    }

NoMoreFilesFound:

Func4EFailure:
    if (wMask)
    {
        if (wMask == mskDirectory)
        {
            LPTSTR lpCurDir = NULL;

            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
            {
                lpCurDir = lpCurDlg->lpstrCurDir;
            }

            FillOutPath(hDirList, pOFI);

            //
            //  The win31 way of chopping the text by just passing
            //  it on to user doesn't work for unc names since user
            //  doesn't see the drivelessness of them (thinks drive is
            //  a bslash char).  So, special case it here.
            //
            lstrcpy(pOFI->szPath, lpCurDir);

            if (DBL_BSLASH(pOFI->szPath))
            {
                SetDlgItemText(hDlg, stc1, ChopText(hDlg, stc1, pOFI->szPath));
            }
            else
            {
                DlgDirList(hDlg, pOFI->szPath, 0, stc1, DDL_READONLY);
            }

            SendMessage(hDirList, LB_SETCURSEL, pOFI->idirSub - 1, 0L);

            if (bDriveChange)
            {
                //
                //  The design here is to show the selected drive whenever the
                //  user changes drives, or whenever the number of
                //  subdirectories is sufficiently low to allow them to be
                //  shown along with the drive.  Otherwise, show the
                //  immediate parent and all the children that can be shown.
                //  This all was done to meet the UITF spec.
                //
                i = 0;
            }
            else
            {
                //
                //  Show as many children as possible.
                //
                if ((i = (SHORT)(pOFI->idirSub - 2)) < 0)
                {
                    i = 0;
                }
            }

            //
            //  LB_SETTOPINDEX must be after LB_SETCURSEL, as LB_SETCURSEL will
            //  alter the top index to bring the current selection into view.
            //
            SendMessage(hDirList, LB_SETTOPINDEX, (WPARAM)i, 0L);
        }
        else
        {
            SetDlgItemText(hDlg, stc1, szNull);
        }

        wNoRedraw &= ~2;
        SendMessage(hDirList, WM_SETREDRAW, TRUE, 0L);

        GetWindowRect(hDirList, (LPRECT)&rDirLBox);
        rDirLBox.left++, rDirLBox.top++;
        rDirLBox.right--, rDirLBox.bottom--;
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rDirLBox, 2);

        //
        //  If there are less than enough directories to fill the listbox,
        //  Win 3.0 doesn't clear out the bottom.  Pass TRUE as the last
        //  parameter to demand a WM_ERASEBACKGROUND message.
        //
        InvalidateRect(hDlg, (LPRECT)&rDirLBox, (BOOL)(wWinVer < 0x030A));
    }

    SendMessage(hFileList, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hFileList, (LPRECT)0, (BOOL)TRUE);

#ifndef WIN32
   ResetDTAAddress();
#endif

   HourGlass(FALSE);
   return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  OKButtonPressed
//
//  Note:  There are 4 cases for validation of a file name:
//    1)  OFN_NOVALIDATE        allows invalid characters
//    2)  No validation flags   No invalid characters, but path need not exist
//    3)  OFN_PATHMUSTEXIST     No invalid characters, path must exist
//    4)  OFN_FILEMUSTEXIST     No invalid characters, path & file must exist
//
////////////////////////////////////////////////////////////////////////////

BOOL OKButtonPressed(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode = 0;
    DWORD cch;
    DWORD cchSearchPath;
    LPOPENFILENAME pOFN = pOFI->pOFN;
    int nFileOffset, nExtOffset;
    HANDLE hFile;
    BOOL bAddExt = FALSE;
    BOOL bUNCName = FALSE;
    int nTempOffset;
    TCHAR szPathName[MAX_FULLPATHNAME];
    DWORD lRet;
    BOOL blfn;
    LPCURDLG lpCurDlg;
    TCHAR ch = 0;


    if (cch = GetUNCDirectoryFromLB(hDlg, lst2, pOFI))
    {
        nTempOffset = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                       lst2,
                                                       LB_GETTEXTLEN,
                                                       0,
                                                       0 );
    }
    else
    {
        nTempOffset = 0;
    }

    GetDlgItemText(hDlg, edt1, pOFI->szPath + cch, MAX_FULLPATHNAME - 1);

    if (cch)
    {
        //
        //  If a drive or new UNC was specified, forget the old UNC.
        //
        if ((pOFI->szPath[cch + 1] == CHAR_COLON) ||
            (DBL_BSLASH(pOFI->szPath + cch)) )
        {
            lstrcpy(pOFI->szPath, pOFI->szPath + cch);
        }
        else if ((ISBACKSLASH(pOFI->szPath, cch)) ||
                 (pOFI->szPath[cch] == CHAR_SLASH))
        {
            //
            //  If a directory from the root is given, put it immediately
            //  after the \\server\share listing.
            //
            lstrcpy(pOFI->szPath + nTempOffset, pOFI->szPath + cch);
        }
    }

    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        blfn = FALSE;
    }
    else
    {
        blfn = IsLFNDriveX(hDlg, pOFI->szPath);
    }

    lRet = ParseFile(pOFI->szPath, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    nExtOffset  = (int)(SHORT)HIWORD(lRet);

    if (nFileOffset == PARSE_EMPTYSTRING)
    {
        UpdateListBoxes(hDlg, pOFI, NULL, 0);
        return (FALSE);
    }
    else if ((nFileOffset != PARSE_DIRECTORYNAME) &&
             (pOFN->Flags & OFN_NOVALIDATE))
    {
        pOFN->nFileOffset = (WORD)nFileOffset;
        pOFN->nFileExtension = (WORD)nExtOffset;
        if (pOFN->lpstrFile)
        {
            cch = lstrlen(pOFI->szPath);
            if (cch < pOFN->nMaxFile)
            {
                lstrcpy(pOFN->lpstrFile, pOFI->szPath);
            }
            else
            {
                //
                //  For single file requests, we will never go over 64K
                //  because the filesystem is limited to 256.
                //
                if (cch > 0x0000FFFF)
                {
                    pOFN->lpstrFile[0] = (TCHAR)0xFFFF;
                }
                else
                {
                    pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                }
                pOFN->lpstrFile[1] = CHAR_NULL;
            }
        }
        return (TRUE);
    }
    else if ((pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             SpacesExist(pOFI->szPath))
    {
        return (MultiSelectOKButton(hDlg, pOFI, bSave));
    }
    else if (pOFI->szPath[nExtOffset] == CHAR_SEMICOLON)
    {
        pOFI->szPath[nExtOffset] = CHAR_NULL;
        nFileOffset = (int)(SHORT)LOWORD(ParseFile( pOFI->szPath,
                                                    blfn,
                                                    IS16BITWOWAPP(pOFN),
                                                    FALSE ));
        pOFI->szPath[nExtOffset] = CHAR_SEMICOLON;
        if ( (nFileOffset >= 0) &&
             (StrChr(pOFI->szPath + nFileOffset, CHAR_STAR) ||
              StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK)) )
        {
            lstrcpy(pOFI->szLastFilter, pOFI->szPath + nFileOffset);
            if (FListAll(pOFI, hDlg, pOFI->szPath) == CHANGEDIR_FAILED)
            {
                //
                //  Conform with cchSearchPath error code settings in
                //  PathCheck.
                //
                cchSearchPath = 2;
                goto PathCheck;
            }
            return (FALSE);
        }
        else
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto Warning;
        }
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        //
        //  End with slash?
        //
        if ((ISBACKSLASH(pOFI->szPath, nExtOffset - 1)) ||
            (pOFI->szPath[nExtOffset - 1] == CHAR_SLASH))
        {
            //
            //  ... and is not the root, get rid of the slash.
            //
            if ( (nExtOffset != 1) &&
                 (pOFI->szPath[nExtOffset - 2] != CHAR_COLON) &&
                 (nExtOffset != nTempOffset + 1) )
            {
                pOFI->szPath[nExtOffset - 1] = CHAR_NULL;
            }
        }
        else if ((pOFI->szPath[nExtOffset - 1] == CHAR_DOT) &&
                 ((pOFI->szPath[nExtOffset - 2] == CHAR_DOT) ||
                  (ISBACKSLASH(pOFI->szPath, nExtOffset - 2)) ||
                  (pOFI->szPath[nExtOffset - 2] == CHAR_SLASH)) &&
                 ((DBL_BSLASH(pOFI->szPath)) ||
                  ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                   (DBL_BSLASH(pOFI->szPath + 2)))))
        {
            pOFI->szPath[nExtOffset] = CHAR_BSLASH;
            pOFI->szPath[nExtOffset + 1] = CHAR_NULL;
        }

        //
        //  Fall through to Directory Checking.
        //
    }
    else if (nFileOffset < 0)
    {
        //
        //  Put in nErrCode so that call can be used from other points.
        //
        nErrCode = (DWORD)nFileOffset;
Warning:

        //
        //  If the disk is not a floppy and they tell me there's no
        //  disk in the drive, dont believe it.  Instead, put up the error
        //  message that they should have given us.
        //  (Note that the error message is checked first since checking
        //  the drive type is slower.)
        //
        if (nErrCode == ERROR_ACCESS_DENIED)
        {
            if (bUNCName)
            {
                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
            }
            else
            {
                szPathName[0] = CharLowerChar(szPathName[0]);

                if (GetDiskType(szPathName) == DRIVE_REMOTE)
                {
                    nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                }
                else if (GetDiskType(szPathName) == DRIVE_REMOVABLE)
                {
                    nErrCode = ERROR_NO_DISK_IN_DRIVE;
                }
                else if (GetDiskType(szPathName) == DRIVE_CDROM)
                {
                    nErrCode = ERROR_NO_DISK_IN_CDROM;
                }
            }
        }

        if ((nErrCode == ERROR_WRITE_PROTECT) ||
            (nErrCode == ERROR_CANNOT_MAKE) ||
            (nErrCode == ERROR_NO_DISK_IN_DRIVE) ||
            (nErrCode == ERROR_NO_DISK_IN_CDROM))
        {
            pOFI->szPath[0] = szPathName[0];
        }

        InvalidFileWarning(hDlg, pOFI->szPath, nErrCode, 0);

        //
        //  Can't cd case (don't want WM_ACTIVATE to setevent to GetNetDrives!).
        //  Reset wNoRedraw.
        //
        wNoRedraw &= ~1;
        return (FALSE);
    }

    bUNCName = ((DBL_BSLASH(pOFI->szPath)) ||
                ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                (DBL_BSLASH(pOFI->szPath + 2))));

    nTempOffset = nFileOffset;

    //
    //  Get the fully-qualified path.
    //
    {
        BOOL bSlash;
        BOOL bRet;
        WORD nNullOffset;

        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            ch = *(pOFI->szPath + nFileOffset);
            *(pOFI->szPath + nFileOffset) = CHAR_NULL;
            nNullOffset = (WORD) nFileOffset;
        }

        //
        //  For files of the format c:filename where c is not the
        //  current directory, SearchPath does not return the curdir of c
        //  so, prefetch it - should searchpath be changed?
        //
        if (nFileOffset)
        {
            if (*(pOFI->szPath + nFileOffset - 1) == CHAR_COLON)
            {
                //
                //  If it fails, fall through to the error generated below.
                //
                if (ChangeDir(hDlg, pOFI->szPath, FALSE, FALSE) != CHANGEDIR_FAILED)
                {
                    //
                    //  Replace old null offset.
                    //
                    *(pOFI->szPath + nFileOffset) = ch;
                    ch = *pOFI->szPath;

                    //
                    //  Don't pass drive-colon into search path.
                    //
                    *pOFI->szPath = CHAR_NULL;
                    nNullOffset = 0;
                }
            }
        }

        if (bSlash = (*pOFI->szPath == CHAR_SLASH))
        {
            *pOFI->szPath = CHAR_BSLASH;
        }

        szPathName[0] = CHAR_NULL;

        HourGlass(TRUE);

        //
        //  REARCHITECT:
        //  Each wow thread can change the current directory.
        //  Since searchpath doesn't check current dirs on a per thread basis,
        //  reset it here and hope that we don't get interrupted between
        //  setting and searching...
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

        if (pOFI->szPath[0] == TEXT('\0'))  // space for name (pretend it's valid for now)
        {
            lstrcpy(szPathName, (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL));
            bRet = 1;
        }
        else
        {
            bRet = GetFullPathName( pOFI->szPath,
                                    MAX_FULLPATHNAME,
                                    szPathName,
                                    NULL );
        }

        if (!bRet && (pOFI->szPath[1] == CHAR_COLON))
        {
            int nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);

            //
            //  If it's a remembered connection, try to reconnect it.
            //
            if (nDriveIndex != 0xFFFFFFFF  &&
                gaDiskInfo[nDriveIndex].dwType == REMDRVBMP)
            {
                DWORD err = WNetRestoreConnection( hDlg,
                                                   gaDiskInfo[nDriveIndex].lpPath );

                if (err == WN_SUCCESS)
                {
                    gaDiskInfo[nDriveIndex].dwType = NETDRVBMP;
                    nDriveIndex = (int) SendDlgItemMessage(
                           hDlg,
                           cmb2,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM)(LPTSTR)gaDiskInfo[nDriveIndex].lpPath );
                    SendDlgItemMessage( hDlg,
                                        cmb2,
                                        CB_SETITEMDATA,
                                        (WPARAM)nDriveIndex,
                                        (LPARAM)NETDRVBMP );
                    bRet = GetFullPathName( pOFI->szPath,
                                            MAX_FULLPATHNAME,
                                            szPathName,
                                            NULL);
                }
            }
        }
        HourGlass(FALSE);

        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            *(pOFI->szPath + nNullOffset) = ch;
        }

        if (bSlash)
        {
            *pOFI->szPath = CHAR_SLASH;
        }

        if (bRet)
        {
            cchSearchPath = 0;

            if (nFileOffset != PARSE_DIRECTORYNAME)
            {
                ch = *(szPathName + lstrlen(szPathName) - 1);
                if (!ISBACKSLASH(szPathName, lstrlen(szPathName) - 1))
                {
                    lstrcat(szPathName, TEXT("\\"));
                }
                lstrcat(szPathName, (LPTSTR)(pOFI->szPath + nFileOffset));
            }
            else
            {
                //
                //  Hack to get around SearchPath inconsistencies.
                //
                //  searching for c: returns c:
                //  searching for server share dir1 .. returns  server share
                //  in these two cases bypass the regular ChangeDir call that
                //  uses szPathName and use the original pOFI->szPath instead
                //  OKButtonPressed needs to be simplified!
                //
                int cch = GetPathOffset(pOFI->szPath);

                if (cch > 0)
                {
                    if (bUNCName)
                    {
                        //
                        //  If this fails, how is szPathName used?
                        //  szPathName's disk should equal pOFI->szPath's
                        //  so the cch will be valid.
                        //
                        szPathName[cch] = CHAR_BSLASH;
                        szPathName[cch + 1] = CHAR_NULL;
                        if (ChangeDir( hDlg,
                                       pOFI->szPath,
                                       FALSE,
                                       TRUE ) != CHANGEDIR_FAILED)
                        {
                            goto ChangedDir;
                        }
                    }
                    else
                    {
                        if (!pOFI->szPath[cch])
                        {
                            if (ChangeDir( hDlg,
                                           pOFI->szPath,
                                           FALSE,
                                           TRUE) != CHANGEDIR_FAILED)
                            {
                                goto ChangedDir;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            if (!(pOFN->Flags & OFN_PATHMUSTEXIST))
            {
                lstrcpy(szPathName, pOFI->szPath);
            }
            if (((nErrCode = GetLastError()) == ERROR_INVALID_DRIVE) ||
                (pOFI->szPath[1] == CHAR_COLON))
            {
                cchSearchPath = 1;
            }
            else
            {
                cchSearchPath = 2;
            }
        }
    }

    //
    //  Full pattern?
    //
    if ( !cchSearchPath &&
         ((StrChr(pOFI->szPath + nFileOffset, CHAR_STAR)) ||
          (StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK))) )
    {
        TCHAR szSameDirFile[MAX_FULLPATHNAME];

        if (nTempOffset)
        {
            //
            //  Must restore character in case it is part of the filename,
            //  e.g. nTempOffset is 1 for "\foo.txt".
            //
            ch = pOFI->szPath[nTempOffset];
            pOFI->szPath[nTempOffset] = 0;
            ChangeDir(hDlg, pOFI->szPath, FALSE, TRUE);
            pOFI->szPath[nTempOffset] = ch;
        }
        if (!nExtOffset)
        {
            lstrcat(pOFI->szPath + nFileOffset, TEXT("."));
        }
        lstrcpy(szSameDirFile, pOFI->szPath + nFileOffset);
        lstrcpy(pOFI->szLastFilter, pOFI->szPath + nFileOffset);

        if (FListAll(pOFI, hDlg, szSameDirFile) < 0)
        {
            MessageBeep(0);
        }
        return (FALSE);
    }

    //
    //  We either have a file pattern or a real file.
    //  If its a directory
    //       (1) Add on default pattern
    //       (2) Act like its a pattern (goto pattern (1))
    //  Else if its a pattern
    //       (1) Update everything
    //       (2) display files in whatever dir were now in
    //  Else if its a file name!
    //       (1) Check out the syntax
    //       (2) End the dialog given OK
    //       (3) Beep/message otherwise
    //

    //
    //  Drive-letter:\dirpath ??
    //
    if (!cchSearchPath)
    {
        DWORD dwFileAttr;

        if ((dwFileAttr = GetFileAttributes(szPathName)) != 0xFFFFFFFF)
        {
            if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                {
ChangedDir:
                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, FALSE, 0L);
                    if (*pOFI->szLastFilter)
                    {
                        SetDlgItemText(hDlg, edt1, pOFI->szLastFilter);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, edt1, szStarDotStar);
                    }

                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb1,
                                                     GetDlgItem(hDlg, cmb1),
                                                     CBN_CLOSEUP ) );
                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb2,
                                                     GetDlgItem(hDlg, cmb2),
                                                     MYCBN_CHANGEDIR ) );

                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(GetDlgItem(hDlg, edt1), NULL, FALSE);
                }
                return (FALSE);
            }
        }
    }

    //
    //  Was there a path and did it fail?
    //
    if (nFileOffset && cchSearchPath && (pOFN->Flags & OFN_PATHMUSTEXIST))
    {
PathCheck:
        if (cchSearchPath == 2)
        {
            nErrCode = ERROR_PATH_NOT_FOUND;
        }
        else if (cchSearchPath == 1)
        {
            int nDriveIndex;

            //
            //  Lowercase drive letters since DiskAddedPreviously is case
            //  sensitive.
            //
            CharLower(pOFI->szPath);

            //  We can get here without performing an OpenFile call.  As such
            //  the szPathName can be filled with random garbage.  Since we
            //  only need one character for the error message, set
            //  szPathName[0] to the drive letter.
            //
            if (pOFI->szPath[1] == CHAR_COLON)
            {
                nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);
            }
            else
            {
                nDriveIndex = DiskAddedPreviously(0, pOFI->szPath);
            }

            if (nDriveIndex == 0xFFFFFFFF)
            {
                nErrCode = ERROR_NO_DRIVE;
            }
            else
            {
                if (bUNCName)
                {
                    nErrCode = ERROR_NO_DRIVE;
                }
                else
                {
                    switch (GetDiskType(pOFI->szPath))
                    {
                        case ( DRIVE_REMOVABLE ) :
                        {
                            szPathName[0] = pOFI->szPath[0];
                            nErrCode = ERROR_NO_DISK_IN_DRIVE;
                            break;
                        }
                        case ( DRIVE_CDROM ) :
                        {
                           szPathName[0] = pOFI->szPath[0];
                           nErrCode = ERROR_NO_DISK_IN_CDROM;
                           break;
                        }
                        default :
                        {
                           nErrCode = ERROR_PATH_NOT_FOUND;
                        }
                    }
                }
            }
        }
        else
        {
            nErrCode = ERROR_FILE_NOT_FOUND;
        }

        //
        //  If we don't set wNoRedraw here, then WM_ACTIVATE will set the
        //  GetNetDrives event.
        //
        wNoRedraw |= 1;

        goto Warning;
    }

    if (PortName(pOFI->szPath + nFileOffset))
    {
        nErrCode = ERROR_PORTNAME;
        goto Warning;
    }

#if 0
    //
    //  Check if we've received a string in the form "C:filename.ext".
    //  If we have, convert it to the form "C:.\filename.ext".  This is done
    //  because the kernel will search the entire path, ignoring the drive
    //  specification after the initial search.  Making it include a slash
    //  causes kernel to only search at that location.
    //  Note:  Only increment nExtOffset, not nFileOffset.  This is done
    //  because only nExtOffset is used later, and nFileOffset can then be
    //  used at the Warning: label to determine if this hack has occurred,
    //  and thus it can strip out the ".\" when putting out the error.
    //
    if ((nFileOffset == 2) && (pOFI->szPath[1] == CHAR_COLON))
    {
        lstrcpy(szWarning, pOFI->szPath + 2);
        lstrcpy(pOFI->szPath + 4, szWarning);
        pOFI->szPath[2] = CHAR_DOT;
        pOFI->szPath[3] = CHAR_BSLASH;
        nExtOffset += 2;
    }
#endif

    //
    //  Add the default extension unless filename ends with period or no
    //  default extension exists.  If the file exists, consider asking
    //  permission to overwrite the file.
    //
    //  NOTE:  When no extension given, default extension is tried 1st.
    //
    if ( (nFileOffset != PARSE_DIRECTORYNAME) &&
         nExtOffset &&
         !pOFI->szPath[nExtOffset] &&
         pOFN->lpstrDefExt &&
         *pOFN->lpstrDefExt &&
         (((DWORD)nExtOffset + lstrlen(pOFN->lpstrDefExt)) < pOFN->nMaxFile) )
    {
        DWORD dwFileAttr;
        int nExtOffset2 = lstrlen(szPathName);

        bAddExt = TRUE;

        AppendExt(pOFI->szPath, pOFN->lpstrDefExt, FALSE);
        AppendExt(szPathName, pOFN->lpstrDefExt, FALSE);

        //
        //  Directory may match default extension.  Change to it as if it had
        //  been typed in.  A dir w/o the extension would have been switched
        //  to in the logic above.
        //
        if ((dwFileAttr = GetFileAttributes(pOFI->szPath)) != 0xFFFFFFFF)
        {
            if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                {
                    goto ChangedDir;
                }
            }
        }

        hFile = CreateFile( szPathName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
        if (hFile == INVALID_HANDLE_VALUE)
        {
            nErrCode = GetLastError();

            //
            //  Fix bug where progman cannot OK a file being browsed for new
            //  item because it has Execute only permission.
            //
            if (nErrCode == ERROR_ACCESS_DENIED)
            {
                hFile = CreateFile( szPathName,
                                    GENERIC_EXECUTE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
                }
            }
        }

        if (nErrCode == ERROR_SHARING_VIOLATION)
        {
            goto SharingViolationInquiry;
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(hFile))
            {
                nErrCode = GetLastError();
                goto Warning;
            }

AskPermission:
            //
            //  Is the file read-only?
            //
            if (pOFN->Flags & OFN_NOREADONLYRETURN)
            {
                int nRet;
                if ((nRet = GetFileAttributes(szPathName)) != -1)
                {
                    if (nRet & ATTR_READONLY)
                    {
                        nErrCode = ERROR_LAZY_READONLY;
                        goto Warning;
                    }
                }
                else
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }
            }

            if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                (nErrCode == ERROR_ACCESS_DENIED))
            {
                goto Warning;
            }

            if (pOFN->Flags & OFN_OVERWRITEPROMPT)
            {
                if (bSave && !FOkToWriteOver(hDlg, szPathName))
                {
                    PostMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, edt1),
                                 (LPARAM)1L );
                    return (FALSE);
                }
            }

            if (nErrCode == ERROR_SHARING_VIOLATION)
            {
                goto SharingViolationInquiry;
            }
            goto FileNameAccepted;
        }
        else
        {
            *(pOFI->szPath + nExtOffset) = CHAR_NULL;
            szPathName[nExtOffset2] = CHAR_NULL;
        }
    }
    else
    {
        //
        //  Extension should not be added.
        //
        bAddExt = FALSE;
    }

    hFile = CreateFile( szPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        nErrCode = GetLastError();

        //
        //  Fix bug where progman cannot OK a file being browsed for new item
        //  because it has Execute only permission.
        //
        if (nErrCode == ERROR_ACCESS_DENIED)
        {
            hFile = CreateFile( szPathName,
                                GENERIC_EXECUTE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
            if (hFile == INVALID_HANDLE_VALUE)
            {
                nErrCode = GetLastError();
            }
        }
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            nErrCode = GetLastError();
            goto Warning;
        }
        goto AskPermission;
    }
    else
    {
        if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
            (nErrCode == ERROR_PATH_NOT_FOUND))
        {
            //
            //  Figure out if the default extension should be tacked on.
            //
            if (bAddExt)
            {
                AppendExt(pOFI->szPath, pOFN->lpstrDefExt, FALSE);
                AppendExt(szPathName, pOFN->lpstrDefExt, FALSE);
            }
        }
        else if (nErrCode == ERROR_SHARING_VIOLATION)
        {

SharingViolationInquiry:
            //
            //  If the app is "share aware", fall through.
            //  Otherwise, ask the hook function.
            //
            if (!(pOFN->Flags & OFN_SHAREAWARE))
            {
                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        CHAR szPathNameA[MAX_FULLPATHNAME];

                        RtlUnicodeToMultiByteSize(
                              &cch,
                              szPathName,
                              lstrlenW(szPathName) * sizeof(TCHAR) );

                        SHUnicodeToAnsi(szPathName,(LPSTR)&szPathNameA[0],cch + 1);

                        cch = (DWORD)(*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONA,
                                           0,
                                           (LONG_PTR)(LPSTR)szPathNameA );
                    }
                    else
#endif
                    {
                        cch = (DWORD)(*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONW,
                                           0,
                                           (LONG_PTR)szPathName );
                    }
                    if (cch == OFN_SHARENOWARN)
                    {
                        return (FALSE);
                    }
                    else if (cch != OFN_SHAREFALLTHROUGH)
                    {
                        goto Warning;
                    }
                }
                else
                {
                    goto Warning;
                }
            }
            goto FileNameAccepted;
        }

        if (!bSave)
        {
            if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
                (nErrCode == ERROR_PATH_NOT_FOUND))
            {
                if (pOFN->Flags & OFN_FILEMUSTEXIST)
                {
                    if (pOFN->Flags & OFN_CREATEPROMPT)
                    {
                        //
                        //  Don't alter pOFI->szPath.
                        //
                        bInChildDlg = TRUE;
                        cch = (DWORD)CreateFileDlg(hDlg, pOFI->szPath);
                        bInChildDlg = FALSE;
                        if (cch == IDYES)
                        {
                            goto TestCreation;
                        }
                        else
                        {
                            return (FALSE);
                        }
                    }
                    goto Warning;
                }
            }
            else
            {
                goto Warning;
            }
        }

        //
        //  The file doesn't exist.  Can it be created?  This is needed because
        //  there are many extended characters which are invalid that won't be
        //  caught by ParseFile.
        //  Two more good reasons:  Write-protected disks & full disks.
        //
        //  BUT, if they dont want the test creation, they can request that we
        //  not do it using the OFN_NOTESTFILECREATE flag.  If they want to
        //  create files on a share that has create-but-no-modify privileges,
        //  they should set this flag but be ready for failures that couldn't
        //  be caught, such as no create privileges, invalid extended
        //  characters, a full disk, etc.
        //

TestCreation:
        if ((pOFN->Flags & OFN_PATHMUSTEXIST) &&
            (!(pOFN->Flags & OFN_NOTESTFILECREATE)))
        {
            //
            //  Must use the FILE_FLAG_DELETE_ON_CLOSE flag so that the
            //  file is automatically deleted when the handle is closed
            //  (no need to call DeleteFile).  This is necessary in the
            //  event that the directory only has Add & Read access.
            //  The CreateFile call will succeed, but the DeleteFile call
            //  will fail.  By adding the above flag to the CreateFile
            //  call, it overrides the access rights and deletes the file
            //  during the call to CloseHandle.
            //
#ifdef WINNT
            hFile = CreateFile( szPathName,
                                FILE_ADD_FILE,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
#else

            // Win95/Memphis don't support FILE_ADD_FILE flag, use GENERIC_READ instead.

            hFile = CreateFile( szPathName,
                                GENERIC_READ,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
#endif
            if (hFile == INVALID_HANDLE_VALUE)
            {
                nErrCode = GetLastError();
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(hFile))
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }
            }
            else
            {
                //
                //  Unable to create it.
                //
                //  If it's not write-protection, a full disk,
                //  network protection, or the user popping the drive door
                //  open, assume that the filename is invalid.
                //
                if ( (nErrCode != ERROR_WRITE_PROTECT) &&
                     (nErrCode != ERROR_CANNOT_MAKE) &&
                     (nErrCode != ERROR_NETWORK_ACCESS_DENIED) &&
                     (nErrCode != ERROR_ACCESS_DENIED) )
                {
                    nErrCode = 0;
                }
                goto Warning;
            }
        }
    }

FileNameAccepted:

    HourGlass(TRUE);

    lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    cch = (DWORD)HIWORD(lRet);

    pOFN->nFileOffset = (WORD)nFileOffset;
    if (nExtOffset || bAddExt)
    {
        pOFN->nFileExtension = LOWORD(cch);
    }
    else
    {
        pOFN->nFileExtension = 0;
    }

    pOFN->Flags &= ~OFN_EXTENSIONDIFFERENT;
    if (pOFN->lpstrDefExt && pOFN->nFileExtension)
    {
        TCHAR szPrivateExt[4];
        SHORT i;

        for (i = 0; i < 3; i++)
        {
            szPrivateExt[i] = *(pOFN->lpstrDefExt + i);
        }
        szPrivateExt[3] = CHAR_NULL;

        if (lstrcmpi(szPrivateExt, szPathName + cch))
        {
            pOFN->Flags |= OFN_EXTENSIONDIFFERENT;
        }
    }

    //
    //  If we're called from wow, and the user hasn't changed
    //  directories, shorten the path to abbreviated 8.3 format.
    //
    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(szPathName);

        //
        //  If the path was shortened, the offset might have changed so
        //  we must parse the file again.
        //
        lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        cch  = (DWORD)HIWORD(lRet);

        //
        //  When in Save dialog, the file may not exist yet, so the file
        //  name cannot be shortened.  So, we need to test if it's an
        //  8.3 filename and popup an error message if not.
        //
        if (bSave)
        {
            LPTSTR lptmp;
            LPTSTR lpExt = NULL;

            for (lptmp = szPathName + nFileOffset; *lptmp; lptmp++)
            {
                if (*lptmp == CHAR_DOT)
                {
                    if (lpExt)
                    {
                        //
                        //  There's more than one dot in the file, so it is
                        //  invalid.
                        //
                        nErrCode = FNERR_INVALIDFILENAME;
                        goto Warning;
                    }
                    lpExt = lptmp;
                }
                if (*lptmp == CHAR_SPACE)
                {
                    nErrCode = FNERR_INVALIDFILENAME;
                    goto Warning;
                }
            }

            if (lpExt)
            {
                //
                //  There's an extension.
                //
                *lpExt = 0;
            }

            if ((lstrlen(szPathName + nFileOffset) > 8) ||
                (lpExt && lstrlen(lpExt + 1) > 3))
            {
                if (lpExt)
                {
                    *lpExt = CHAR_DOT;
                }

                nErrCode = FNERR_INVALIDFILENAME;
                goto Warning;
            }
            if (lpExt)
            {
                *lpExt = CHAR_DOT;
            }
        }
    }

    if (pOFN->lpstrFile)
    {
        DWORD cchLen = lstrlen(szPathName);

        if (cchLen < pOFN->nMaxFile)
        {
            lstrcpy(pOFN->lpstrFile, szPathName);
        }
        else
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            //  For single file requests, we will never go over 64K
            //  because the filesystem is limited to 256.
            //
#ifdef UNICODE
            pOFN->lpstrFile[0] = (TCHAR)LOWORD(cchLen);
            if (pOFN->nMaxFile >= 2)
            {
                pOFN->lpstrFile[1] = CHAR_NULL;
            }
#else
            pOFN->lpstrFile[0] = LOBYTE(cchLen);
            pOFN->lpstrFile[1] = HIBYTE(cchLen);
            pOFN->lpstrFile[2] = CHAR_NULL;
#endif
        }
    }

    //
    //  File Title.  Note that it's cut off at whatever the buffer length
    //               is, so if the buffer is too small, no notice is given.
    //
    if (pOFN->lpstrFileTitle && pOFN->nMaxFileTitle)
    {
        cch = lstrlen(szPathName + nFileOffset);
        if (cch > pOFN->nMaxFileTitle)
        {
            szPathName[nFileOffset + pOFN->nMaxFileTitle - 1] = CHAR_NULL;
        }
        lstrcpy(pOFN->lpstrFileTitle, szPathName + nFileOffset);
    }


    if (!(pOFN->Flags & OFN_HIDEREADONLY))
    {
        if (IsDlgButtonChecked(hDlg, chx1))
        {
            pOFN->Flags |= OFN_READONLY;
        }
        else
        {
            pOFN->Flags &= ~OFN_READONLY;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MultiSelectOKButton
//
////////////////////////////////////////////////////////////////////////////

BOOL MultiSelectOKButton(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode;
    LPTSTR lpCurDir;
    LPTSTR lpchStart;                  // start of an individual filename
    LPTSTR lpchEnd;                    // end of an individual filename
    DWORD cch;
    HANDLE hFile;
    LPOPENFILENAME pOFN;
    BOOL EOS = FALSE;                  // end of string flag
    BOOL bRet;
    TCHAR szPathName[MAX_FULLPATHNAME - 1];
    LPCURDLG lpCurDlg;


    pOFN = pOFI->pOFN;

    //
    //  Check for space for first full path element.
    //
    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    lstrcpy(pOFI->szPath, lpCurDir);
    if (StrChr(pOFI->szPath, CHAR_SPACE))
    {
        GetShortPathName(pOFI->szPath, pOFI->szPath, MAX_FULLPATHNAME);
    }

    if (!bCasePreserved)
    {
        CharLower(pOFI->szPath);
    }

    cch = (DWORD) ( lstrlen(pOFI->szPath) +
            sizeof(TCHAR) +
            SendDlgItemMessage(hDlg, edt1, WM_GETTEXTLENGTH, 0, 0L) );
    if (pOFN->lpstrFile)
    {
        if (cch > pOFN->nMaxFile)
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string (if possible).
            //
            if (pOFN->nMaxFile >= 3)
            {
#ifdef UNICODE
                pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                pOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
#else
                pOFN->lpstrFile[0] = (TCHAR)LOBYTE(cch);
                pOFN->lpstrFile[1] = (TCHAR)HIBYTE(cch);
#endif
                pOFN->lpstrFile[2] = CHAR_NULL;
            }
            else
            {
#ifdef UNICODE
                pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                if (pOFN->nMaxFile == 2)
                {
                    pOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
                }
#else
                pOFN->lpstrFile[0] = LOBYTE(cch);
                pOFN->lpstrFile[1] = HIBYTE(cch);
                pOFN->lpstrFile[2] = CHAR_NULL;
#endif
            }
        }
        else
        {
            //
            //  Copy in the full path as the first element.
            //
            lstrcpy(pOFN->lpstrFile, pOFI->szPath);
            lstrcat(pOFN->lpstrFile, TEXT(" "));

            //
            //  Get the other files here.
            //
            cch = lstrlen(pOFN->lpstrFile);

            //
            //  The path is guaranteed to be less than 64K (actually, < 260).
            //
            pOFN->nFileOffset = LOWORD(cch);
            lpchStart = pOFN->lpstrFile + cch;

            GetDlgItemText( hDlg,
                            edt1,
                            lpchStart,
                            (int)(pOFN->nMaxFile - cch - 1) );

            while (*lpchStart == CHAR_SPACE)
            {
                lpchStart = CharNext(lpchStart);
            }
            if (*lpchStart == CHAR_NULL)
            {
                return (FALSE);
            }

            //
            //  Go along file path looking for multiple filenames delimited by
            //  spaces.  For each filename found, try to open it to make sure
            //  it's a valid file.
            //
            while (!EOS)
            {
                //
                //  Find the end of the filename.
                //
                lpchEnd = lpchStart;
                while (*lpchEnd && *lpchEnd != CHAR_SPACE)
                {
                    lpchEnd = CharNext(lpchEnd);
                }

                //
                //  Mark the end of the filename with a NULL.
                //
                if (*lpchEnd == CHAR_SPACE)
                {
                    *lpchEnd = CHAR_NULL;
                }
                else
                {
                    //
                    //  Already NULL, found the end of the string.
                    //
                    EOS = TRUE;
                }

                //
                //  Check that the filename is valid.
                //
                bRet = GetFullPathName( lpchStart,
                                        ARRAYSIZE(szPathName),
                                        szPathName,
                                        NULL);

                if (!bRet)
                {
                    nErrCode = ERROR_FILE_NOT_FOUND;
                    goto MultiFileNotFound;
                }

                hFile = CreateFile( szPathName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                //
                //  Fix bug where progman cannot OK a file being browsed for
                //  new item because it has Execute only permission.
                //
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
                    if (nErrCode == ERROR_ACCESS_DENIED)
                    {
                        hFile = CreateFile( szPathName,
                                            GENERIC_EXECUTE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL );
                    }
                    else
                    {
                        goto MultiFileNotFound;
                    }
                }
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
MultiFileNotFound:
                    if ( ((pOFN->Flags & OFN_FILEMUSTEXIST) ||
                          (nErrCode != ERROR_FILE_NOT_FOUND)) &&
                         ((pOFN->Flags & OFN_PATHMUSTEXIST) ||
                          (nErrCode != ERROR_PATH_NOT_FOUND)) &&
                         (!(pOFN->Flags & OFN_SHAREAWARE) ||
                          (nErrCode != ERROR_SHARING_VIOLATION)) )
                    {
                        if ( (nErrCode == ERROR_SHARING_VIOLATION) &&
                             pOFN->lpfnHook )
                        {
                            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                            if (pOFI->ApiType == COMDLG_ANSI)
                            {
                                CHAR szPathNameA[MAX_FULLPATHNAME];

                                RtlUnicodeToMultiByteSize(
                                     &cch,
                                     szPathName,
                                     lstrlenW(szPathName) * sizeof(TCHAR) );

                                SHUnicodeToAnsi(szPathName,(LPSTR)&szPathNameA[0],cch + 1);

                                cch = (DWORD)(*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONA,
                                                   0,
                                                   (LONG_PTR)(LPSTR)szPathNameA );
                            }
                            else
#endif
                            {
                                cch = (DWORD)(*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONW,
                                                   0,
                                                   (LONG_PTR)szPathName );
                            }
                            if (cch == OFN_SHARENOWARN)
                            {
                                return (FALSE);
                            }
                            else if (cch == OFN_SHAREFALLTHROUGH)
                            {
                                goto EscapedThroughShare;
                            }
                        }
                        else if (nErrCode == ERROR_ACCESS_DENIED)
                        {
                            szPathName[0] = CharLowerChar(szPathName[0]);

                            if (GetDiskType(szPathName) != DRIVE_REMOVABLE)
                            {
                                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                            }
                        }
                        if ((nErrCode == ERROR_WRITE_PROTECT) ||
                            (nErrCode == ERROR_CANNOT_MAKE)   ||
                            (nErrCode == ERROR_ACCESS_DENIED))
                        {
                            *lpchStart = szPathName[0];
                        }
MultiWarning:
                        InvalidFileWarning(hDlg, lpchStart, nErrCode, 0);
                        return (FALSE);
                    }
                }
EscapedThroughShare:
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    if (!CloseHandle(hFile))
                    {
                        nErrCode = GetLastError();
                        goto MultiWarning;
                    }
                    if ((pOFN->Flags & OFN_NOREADONLYRETURN) &&
                        (GetFileAttributes(szPathName) & FILE_ATTRIBUTE_READONLY))
                    {
                        nErrCode = ERROR_LAZY_READONLY;
                        goto MultiWarning;
                    }

                    if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                        (nErrCode == ERROR_ACCESS_DENIED))
                    {
                        goto MultiWarning;
                    }

                    if (pOFN->Flags & OFN_OVERWRITEPROMPT)
                    {
                        if (bSave && !FOkToWriteOver(hDlg, szPathName))
                        {
                            PostMessage( hDlg,
                                         WM_NEXTDLGCTL,
                                         (WPARAM)GetDlgItem(hDlg, edt1),
                                         (LPARAM)1L );
                            return (FALSE);
                        }
                    }
                }

                //
                //  This file is valid, so check the next one.
                //
                if (!EOS)
                {
                    lpchStart = lpchEnd + 1;
                    while (*lpchStart == CHAR_SPACE)
                    {
                        lpchStart = CharNext(lpchStart);
                    }
                    if (*lpchStart == CHAR_NULL)
                    {
                        EOS = TRUE;
                    }
                    else
                    {
                        //
                        //  Not at end, replace NULL with SPACE.
                        //
                        *lpchEnd = CHAR_SPACE;
                    }
                }
            }

            //
            //  Limit String.
            //
            *lpchEnd = CHAR_NULL;
        }
    }

    //
    //  This doesn't really mean anything for multiselection.
    //
    pOFN->nFileExtension = 0;

    pOFN->nFilterIndex = (int) SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  dwOKSubclass
//
//  Simulates a double click if the user presses OK with the mouse
//  and the focus was on the directory listbox.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By setting the global flag bChangeDir
//  when the directory listbox loses the focus and clearing it when
//  the OK button loses the focus, we can check whether a mouse
//  click should update the directory.
//
//  Returns:  Return value from default listbox proceedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwOKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        if (bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg = GetParent(hOK), FILEPROP))
            {
                SendDlgItemMessage( hDlg,
                                    lst2,
                                    LB_SETCURSEL,
                                    (WPARAM)(pOFI->idirSub - 1),
                                    0L );
            }
            bChangeDir = FALSE;
        }
    }
    return (CallWindowProc(lpOKProc, hOK, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  dwLBSubclass
//
//  Simulates a double click if the user presses OK with the mouse.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By simulating a double click, the change
//  takes place.
//
//  Returns:  Return value from default listbox proceedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwLBSubclass(
    HWND hLB,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        hDlg = GetParent(hLB);
        bChangeDir = (GetDlgItem(hDlg, IDOK) == (HWND)wParam) ? TRUE : FALSE;
        if (!bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
            {
                SendMessage( hLB,
                             LB_SETCURSEL,
                             (WPARAM)(pOFI->idirSub - 1),
                             0L );
            }
        }
    }
    return (CallWindowProc(lpLBProc, hLB, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  InvalidFileWarning
//
////////////////////////////////////////////////////////////////////////////

int InvalidFileWarning(
    HWND hDlg,
    LPTSTR szFile,
    DWORD wErrCode,
    UINT mbType)
{
    SHORT isz;
    BOOL bDriveLetter = FALSE;
    int nRet = 0;

    if (lstrlen(szFile) > TOOLONGLIMIT)
    {
        *(szFile + TOOLONGLIMIT) = CHAR_NULL;
    }

    switch (wErrCode)
    {
        case ( ERROR_NO_DISK_IN_DRIVE ) :
        {
            isz = iszNoDiskInDrive;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DISK_IN_CDROM ) :
        {
            isz = iszNoDiskInCDRom;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DRIVE ) :
        {
            isz = iszDriveDoesNotExist;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_TOO_MANY_OPEN_FILES ) :
        {
            isz = iszNoFileHandles;
            break;
        }
        case ( ERROR_PATH_NOT_FOUND ) :
        {
            isz = iszPathNotFound;
            break;
        }
        case ( ERROR_FILE_NOT_FOUND ) :
        {
            isz = iszFileNotFound;
            break;
        }
        case ( ERROR_CANNOT_MAKE ) :
        case ( ERROR_DISK_FULL ) :
        {
            isz = iszDiskFull;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_WRITE_PROTECT ) :
        {
            isz = iszWriteProtection;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_SHARING_VIOLATION ) :
        {
            isz = iszSharingViolation;
            break;
        }
        case ( ERROR_CREATE_NO_MODIFY ) :
        {
            isz = iszCreateNoModify;
            break;
        }
        case ( ERROR_NETWORK_ACCESS_DENIED ) :
        {
            isz = iszNetworkAccessDenied;
            break;
        }
        case ( ERROR_PORTNAME ) :
        {
            isz = iszPortName;
            break;
        }
        case ( ERROR_LAZY_READONLY ) :
        {
            isz = iszReadOnly;
            break;
        }
        case ( ERROR_DIR_ACCESS_DENIED ) :
        {
            isz = iszDirAccessDenied;
            break;
        }
        case ( ERROR_FILE_ACCESS_DENIED ) :
        case ( ERROR_ACCESS_DENIED ) :
        {
            isz = iszFileAccessDenied;
            break;
        }
        case ( ERROR_UNRECOGNIZED_VOLUME ) :
        {
            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                           NULL,
                           wErrCode,
                           GetUserDefaultLCID(),
                           szWarning,
                           WARNINGMSGLENGTH,
                           NULL );
            goto DisplayError;
        }
        default :
        {
            isz = iszInvalidFileName;
            break;
        }
    }
    if (!CDLoadString( g_hinst,
                     isz,
                     szCaption,
                     WARNINGMSGLENGTH ))
    {
        wsprintf( szWarning,
                  TEXT("Error occurred, but error resource cannot be loaded.") );
    }
    else
    {
        wsprintf( szWarning,
                  szCaption,
                  bDriveLetter ? (LPTSTR)(CHAR)*szFile : szFile );

DisplayError:
        GetWindowText(hDlg, szCaption, WARNINGMSGLENGTH);

        if (!mbType)
        {
            mbType = MB_OK | MB_ICONEXCLAMATION;
        }

        nRet = MessageBox(hDlg, szWarning, szCaption, mbType);
    }

    if (isz == iszInvalidFileName)
    {
        PostMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, edt1),
                     (LPARAM)1L );
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  MeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID MeasureItem(
    HWND hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    if (!dyItem)
    {
        HDC hDC = GetDC(hDlg);
        TEXTMETRIC TM;
        HANDLE hFont;

        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
        dyText = TM.tmHeight;
        dyItem = max(dyDirDrive, dyText);
    }

    if (mis->CtlID == lst1)
    {
        mis->itemHeight = dyText;
    }
    else
    {
        mis->itemHeight = dyItem;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Signum
//
//  Returns the sign of an integer:
//           -1 if integer < 0
//            0 if integer = 0
//            1 if integer > 0
//
//  Note:  Signum *could* be defined as an inline macro, but that causes
//         the C compiler to disable Loop optimization, Global register
//         optimization, and Global optimizations for common subexpressions
//         in any function that the macro would appear.  The cost of a call
//         to the function seemed worth the optimizations.
//
////////////////////////////////////////////////////////////////////////////

int Signum(
    int nTest)
{
    return ((nTest == 0) ? 0 : (nTest > 0) ? 1 : -1);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawItem
//
//  Draws the drive/directory pictures in the respective combo list boxes.
//
//  lst1 is listbox for files
//  lst2 is listbox for directories
//  cmb1 is combobox for filters
//  cmb2 is combobox for drives
//
////////////////////////////////////////////////////////////////////////////

VOID DrawItem(
    POPENFILEINFO pOFI,
    HWND hDlg,
    WPARAM wParam,
    LPDRAWITEMSTRUCT lpdis,
    BOOL bSave)
{
    HDC hdcList;
    RECT rc;
//  RECT rcCmb2;
    TCHAR szText[MAX_FULLPATHNAME + 1];
    int dxAcross;
    LONG nHeight;
    LONG rgbBack, rgbText, rgbOldBack, rgbOldText;
    SHORT nShift = 1;             // to shift directories right in lst2
    BOOL bSel;
    int BltItem;
    int nBackMode;

    if ((int)lpdis->itemID < 0)
    {
        DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LPARAM)lpdis);
        return;
    }

    *szText = CHAR_NULL;

    if (lpdis->CtlID != lst1 && lpdis->CtlID != lst2 && lpdis->CtlID != cmb2)
    {
        return;
    }

    if (!pOFI)
    {
        return;
    }

    hdcList = lpdis->hDC;

    if (lpdis->CtlID != cmb2)
    {
        SendDlgItemMessage( hDlg,
                            (int)lpdis->CtlID,
                            LB_GETTEXT ,
                            (WPARAM)lpdis->itemID,
                            (LONG_PTR)szText );

        if (*szText == 0)
        {
            //
            //  If empty listing.
            //
            DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LONG_PTR)lpdis);
            return;
        }

        if (!bCasePreserved)
        {
            CharLower(szText);
        }
    }

    nHeight = (lpdis->CtlID == lst1) ? dyText : dyItem;

    CopyRect((LPRECT)&rc, (LPRECT)&lpdis->rcItem);

    rc.bottom = rc.top + nHeight;

    if (bSave && (lpdis->CtlID == lst1))
    {
        rgbBack = rgbWindowColor;
        rgbText = rgbGrayText;
    }
    else
    {
        //
        //  Careful checking of bSel is needed here.  Since the file
        //  listbox (lst1) can allow multiselect, only ODS_SELECTED needs
        //  to be set.  But for the directory listbox (lst2), ODS_FOCUS
        //  also needs to be set.
        //
        bSel = (lpdis->itemState & (ODS_SELECTED | ODS_FOCUS));
        if ((bSel & ODS_SELECTED) &&
            ((lpdis->CtlID != lst2) || (bSel & ODS_FOCUS)))
        {
            rgbBack = rgbHiliteColor;
            rgbText = rgbHiliteText;
        }
        else
        {
            rgbBack = rgbWindowColor;
            rgbText = rgbWindowText;
        }
    }

    rgbOldBack = SetBkColor(hdcList, rgbBack);
    rgbOldText = SetTextColor(hdcList, rgbText);

    //
    //  Drives -- text is now in UI style, c: VolumeName/Server-Sharename.
    //
    if (lpdis->CtlID == cmb2)
    {
        HANDLE hCmb2 = GetDlgItem(hDlg, cmb2);

        dxAcross = dxDirDrive / BMPHIOFFSET;

        BltItem = (int) SendMessage(hCmb2, CB_GETITEMDATA, lpdis->itemID, 0);

        SendMessage(hCmb2, CB_GETLBTEXT, lpdis->itemID, (LPARAM)szText);

        if (bSel & ODS_SELECTED)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst2)
    {
        //
        //  Directories.
        //
        dxAcross = dxDirDrive / BMPHIOFFSET;

        if (lpdis->itemID > pOFI->idirSub)
        {
            nShift = (SHORT)pOFI->idirSub;
        }
        else
        {
            nShift = (SHORT)lpdis->itemID;
        }

        //
        //  Must be at least 1.
        //
        nShift++;

        BltItem = 1 + Signum(lpdis->itemID + 1 - pOFI->idirSub);
        if (bSel & ODS_FOCUS)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst1)
    {
        //
        //  Prep for TextOut below.
        //
        dxAcross = -dxSpace;
    }

    if (bSave && (lpdis->CtlID == lst1) && !rgbText)
    {
        HBRUSH hBrush = CreateSolidBrush(rgbBack);
        HBRUSH hOldBrush;

        nBackMode = SetBkMode(hdcList, TRANSPARENT);
        hOldBrush = SelectObject( lpdis->hDC,
                                  hBrush
                                      ? hBrush
                                      : GetStockObject(WHITE_BRUSH) );

        FillRect(lpdis->hDC, (LPRECT)(&(lpdis->rcItem)), hBrush);
        SelectObject(lpdis->hDC, hOldBrush);
        if (hBrush)
        {
            DeleteObject(hBrush);
        }

        GrayString( lpdis->hDC,
                    GetStockObject(BLACK_BRUSH),
                    NULL,
                    (LPARAM)szText,
                    0,
                    lpdis->rcItem.left + dxSpace,
                    lpdis->rcItem.top,
                    0,
                    0 );
        SetBkMode(hdcList, nBackMode);
    }

#if 0
    else if (lpdis->CtlID == cmb2)
    {
        rcCmb2.right = rc.right;
        rcCmb2.left = rc.left + (WORD)(dxSpace + dxAcross) + (dxSpace * nShift);
        rcCmb2.top = rc.top + (dyItem - dyText) / 2;
        rcCmb2.bottom = rc.top + nHeight;

        DrawText( hdcList,
                  szText,
                  -1,
                  &rcCmb2,
                  DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );
    }
#endif

    else
    {
        //
        //  Draw the name.
        //
        ExtTextOut( hdcList,
                    rc.left + (WORD)(dxSpace + dxAcross) + dxSpace * nShift,
                    rc.top + (nHeight - dyText) / 2,
                    ETO_OPAQUE | ETO_CLIPPED,
                    (LPRECT)&rc,
                    szText,
                    lstrlen(szText),
                    NULL );
    }

    //
    //  Draw the picture.
    //
    if (lpdis->CtlID != lst1)
    {
        BitBlt( hdcList,
                rc.left + dxSpace * nShift,
                rc.top + (dyItem - dyDirDrive) / 2,
                dxAcross,
                dyDirDrive,
                hdcMemory,
                BltItem * dxAcross,
                0,
                SRCCOPY );
    }

    SetTextColor(hdcList, rgbOldText);
    SetBkColor(hdcList, rgbBack);

    if (lpdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(hdcList, (LPRECT)&lpdis->rcItem);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SpacesExist
//
////////////////////////////////////////////////////////////////////////////

BOOL SpacesExist(
    LPTSTR szFileName)
{
    while (*szFileName)
    {
        if (*szFileName == CHAR_SPACE)
        {
            return (TRUE);
        }
        else
        {
            szFileName++;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  StripFileName
//
//  Removes all but the filename from editbox contents.
//  This is to be called before the user makes directory or drive
//  changes by selecting them instead of typing them.
//
////////////////////////////////////////////////////////////////////////////

void StripFileName(
    HANDLE hDlg,
    BOOL bWowApp)
{
    TCHAR szText[MAX_FULLPATHNAME];
    SHORT nFileOffset, cb;

    if (GetDlgItemText(hDlg, edt1, szText, MAX_FULLPATHNAME - 1))
    {
        DWORD lRet;

        lRet = ParseFile(szText, IsLFNDriveX(hDlg, szText), bWowApp, FALSE);
        nFileOffset = LOWORD(lRet);
        cb = HIWORD(lRet);
        if (nFileOffset < 0)
        {
            //
            //  If there was a parsing error, check for CHAR_SEMICOLON
            //  delimeter.
            //
            if (szText[cb] == CHAR_SEMICOLON)
            {
                szText[cb] = CHAR_NULL;
                nFileOffset = (WORD)ParseFile( szText,
                                               IsLFNDriveX(hDlg, szText),
                                               bWowApp,
                                               FALSE );
                szText[cb] = CHAR_SEMICOLON;
                if (nFileOffset < 0)
                {
                    //
                    //  Still trouble, so Exit.
                    //
                    szText[0] = CHAR_NULL;
                }
            }
            else
            {
                szText[0] = CHAR_NULL;
            }
        }
        if (nFileOffset > 0)
        {
            lstrcpy(szText, (LPTSTR)(szText + nFileOffset));
        }
        if (nFileOffset)
        {
            SetDlgItemText(hDlg, edt1, szText);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  lstrtok
//
////////////////////////////////////////////////////////////////////////////

LPTSTR lstrtok(
    LPTSTR lpStr,
    LPCTSTR lpDelim)
{
    static LPTSTR lpString;
    LPTSTR lpRetVal, lpTemp;

    //
    //  If we are passed new string skip leading delimiters.
    //
    if (lpStr)
    {
        lpString = lpStr;

        while (*lpString && StrChr(lpDelim, *lpString))
        {
            lpString = CharNext(lpString);
        }
    }

    //
    //  If there are no more tokens, return NULL.
    //
    if (!*lpString)
    {
        return (CHAR_NULL);
    }

    //
    //  Save head of token.
    //
    lpRetVal = lpString;

    //
    //  Find delimiter or end of string.
    //
    while (*lpString && !StrChr(lpDelim, *lpString))
    {
        lpString = CharNext(lpString);
    }

    //
    //  If we found a delimiter insert string terminator and skip.
    //
    if (*lpString)
    {
        lpTemp = CharNext(lpString);
        *lpString = CHAR_NULL;
        lpString = lpTemp;
    }

    //
    //  Return token.
    //
    return (lpRetVal);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChopText
//
////////////////////////////////////////////////////////////////////////////

LPTSTR ChopText(
    HWND hwndDlg,
    int idStatic,
    LPTSTR lpch)
{
    RECT rc;
    register int cxField;
    BOOL fChop = FALSE;
    HWND hwndStatic;
    HDC hdc;
    TCHAR chDrv;
    HANDLE hOldFont;
    LPTSTR lpstrStart = lpch;
    SIZE Size;
    BOOL bRet;

    //
    //  Get length of static field.
    //
    hwndStatic = GetDlgItem(hwndDlg, idStatic);
    GetClientRect(hwndStatic, (LPRECT)&rc);
    cxField = rc.right - rc.left;

    //
    //  Chop characters off front end of text until short enough.
    //
    hdc = GetDC(hwndStatic);

    hOldFont = NULL;

    while ((bRet = GetTextExtentPoint(hdc, lpch, lstrlen(lpch), &Size)) &&
           (cxField < Size.cx))
    {
        if (!fChop)
        {
            chDrv = *lpch;

            //
            //  Proportional font support.
            //
            if (bRet = GetTextExtentPoint(hdc, lpch, 7, &Size))
            {
                cxField -= Size.cx;
            }
            else
            {
                break;
            }

            if (cxField <= 0)
            {
               break;
            }

            lpch += 7;
        }
        while (*lpch && (!ISBACKSLASH_P(lpstrStart, lpch)))
        {
            lpch++;
        }
        //Skip the backslash 
        lpch++;

        fChop = TRUE;
    }

    ReleaseDC(hwndStatic, hdc);

    //
    //  If any characters chopped off, replace first three characters in
    //  remaining text string with ellipsis.
    //
    if (fChop)
    {
        //Skip back to include the backslash
        lpch--;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = *(lpstrStart + 2);
        *--lpch = *(lpstrStart + 1);
        *--lpch = *lpstrStart;
    }

    return (lpch);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillOutPath
//
//  Fills out lst2 given that the current directory has been set.
//
//  Returns:  TRUE    if they DO NOT match
//            FALSE   if match
//
////////////////////////////////////////////////////////////////////////////

BOOL FillOutPath(
    HWND hList,
    POPENFILEINFO pOFI)
{
    TCHAR szPath[CCHNETPATH];
    LPTSTR lpCurDir;
    LPTSTR lpB, lpF;
    TCHAR wc;
    int cchPathOffset;
    LPCURDLG lpCurDlg;

    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    lpF = szPath;    
    lstrcpy(lpF, lpCurDir);

    //
    //  Wow apps started from lfn dirs will set the current directory to an
    //  lfn, but only in the case where it is less than 8 chars.
    //
    if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(lpF);
    }

    *lpF = (TCHAR)CharLower((LPTSTR)*lpF);
    cchPathOffset = GetPathOffset(lpF);
    if (cchPathOffset == -1)
    {
        cchPathOffset = 0;
    }
    lpB = (lpF + cchPathOffset);

    //
    //  Hack to retain Winball display functionality.
    //  Drived disks are displayed as C:\ (the root dir).
    //  whereas unc disks are displayed as \\server\share (the disk).
    //  Hence, extend display of drived disks by one char.
    //
    if (*(lpF + 1) == CHAR_COLON)
    {
        wc = *(++lpB);
        *lpB = CHAR_NULL;
    }
    else
    {
        //
        //  Since we use lpF over and over again to speed things
        //  up, and since GetCurrentDirectory returns the disk name
        //  for unc, but the root path for drives, we have the following hack
        //  for when we are at the root of the unc directory, and lpF
        //  contains old stuff out past cchPathOffset.
        //
        PathAddBackslash(lpF);

        wc = 0;
        *lpB++ = CHAR_NULL;
    }

    //
    //  Insert the items for the path to the current dir
    //  Insert the root...
    //
    pOFI->idirSub = 0;

    SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);

    if (wc)
    {
        *lpB = wc;
    }

    for (lpF = lpB; *lpB; lpB++)
    {
        if ((ISBACKSLASH_P(szPath, lpB)) || (*lpB == CHAR_SLASH))
        {
            *lpB = CHAR_NULL;

            SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);

            lpF = lpB + 1;

            *lpB = CHAR_BSLASH;
        }
    }

    //
    //  Assumes that a path always ends with one last un-delimited dir name.
    //  Check to make sure we have at least one.
    //
    if (lpF != lpB)
    {
        SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShortenThePath
//
//  Takes a pathname and converts all dirs to shortnames if they are
//  not valid DOS 8.3 names.
//
//  Returns:  TRUE    if pathname converted
//            FALSE   if ran out of space, buffer left alone
//
////////////////////////////////////////////////////////////////////////////

BOOL ShortenThePath(
    LPTSTR pPath)
{
    TCHAR szDest[MAX_PATH];
    LPTSTR pSrcNextSpec, pReplaceSpec;
    LPTSTR pDest, p;
    LPTSTR pSrc;
    int cchPathOffset;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;
    UINT i;
    int nSpaceLeft = MAX_PATH - 1;

#ifdef UNICODE
    UNICODE_STRING Name;
    BOOLEAN fSpace = FALSE;
#endif


    //
    //  Save pointer to beginning of buffer.
    //
    pSrc = pPath;

    //
    //  Eliminate double quotes.
    //
    for (p = pDest = pSrc; *p; p++, pDest++)
    {
        if (*p == CHAR_QUOTE)
        {
            p++;
        }
        *pDest = *p;
    }

    *pDest = CHAR_NULL;

    //
    //  Strip out leading spaces.
    //
    while (*pSrc == CHAR_SPACE)
    {
        pSrc++;
    }

    //
    //  Skip past \\foo\bar or <drive>:
    //
    pDest = szDest;
    pSrcNextSpec = pSrc;

    //
    //  Reuse shell32 internal api that calculates path offset.
    //  The cchPathOffset variable will be the offset that when added to
    //  the pointer will result in a pointer to the backslash before the
    //  first part of the path.
    //
    //  NOTE:  UNICODE only call.
    //
    cchPathOffset = GetPathOffset(pSrc);

    //
    //  Check to see if it's valid.  If pSrc is not of the \\foo\bar
    //  or <drive>: form we just do nothing.
    //
    if (cchPathOffset == -1)
    {
        return (TRUE);
    }

    //
    //  cchPathOffset will always be at least 1 and is the number of
    //  characters - 1 that we want to copy (that is, if 0 was
    //  permissible, it would denote 1 character).
    //
    do
    {
        *pDest++ = *pSrcNextSpec++;

        if (!--nSpaceLeft)
        {
            return (FALSE);
        }
    } while (cchPathOffset--);

    //
    //  At this point, we have just the filenames that we can shorten:
    //  \\foo\bar\it\is\here ->  it\is\here
    //  c:\angry\lions       ->  angry\lions
    //
    while (pSrcNextSpec)
    {
        //
        //  pReplaceSpec holds the current spec we need to replace.
        //  By default, if we can't find the altname, then just use this.
        //
        pReplaceSpec = pSrcNextSpec;

        //
        //  Search for trailing "\"
        //  pSrcNextSpec will point to the next spec to fix.
        //  (*pSrcNextSpec = NULL if done)
        //
        while (*pSrcNextSpec && (!ISBACKSLASH_P(pReplaceSpec, pSrcNextSpec)))
        {
            pSrcNextSpec++;
        }

        if (*pSrcNextSpec)
        {
            //
            //  If there is more, then pSrcNextSpec should point to it.
            //  Also delimit this spec.
            //
            *pSrcNextSpec = CHAR_NULL;
        }
        else
        {
            pSrcNextSpec = NULL;
        }

        hFind = FindFirstFile(pSrc, &FindData);

        //
        //  We could exit as soon as this FindFirstFileFails,
        //  but there's the special case of having execute
        //  without read permission.  This would fail since the lfn
        //  is valid for lfn apps.
        //
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

#ifdef UNICODE
            //
            //  See if it's not a legal 8.3 name or if there are spaces
            //  in the name.  If either is true, use the alternate name.
            //
            RtlInitUnicodeString(&Name, FindData.cFileName);
            if (!RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) || fSpace)
#endif
            {
                if (FindData.cAlternateFileName[0])
                {
                    pReplaceSpec = FindData.cAlternateFileName;
                }
            }
        }

        i = lstrlen(pReplaceSpec);
        nSpaceLeft -= i;

        if (nSpaceLeft <= 0)
        {
            return (FALSE);
        }

        lstrcpy(pDest, pReplaceSpec);
        pDest += i;

        //
        //  Now replace the CHAR_NULL with a slash if necessary.
        //
        if (pSrcNextSpec)
        {
            *pSrcNextSpec++ = CHAR_BSLASH;

            //
            //  Also add backslash to destination.
            //
            *pDest++ = CHAR_BSLASH;
            nSpaceLeft--;
        }
    }

    lstrcpy(pPath, szDest);

    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  FListAll
//
//  Given a file pattern, it changes the directory to that of the spec,
//  and updates the display.
//
////////////////////////////////////////////////////////////////////////////

int FListAll(
    POPENFILEINFO pOFI,
    HWND hDlg,
    LPTSTR szSpec)
{
    LPTSTR szPattern;
    TCHAR chSave;
    int nRet = 0;
    TCHAR szDirBuf[MAX_FULLPATHNAME + 1];

    if (!bCasePreserved)
    {
        CharLower(szSpec);
    }

    //
    //  No directory.
    //
    if (!(szPattern = StrRChr( szSpec,
                               szSpec + lstrlen(szSpec),
                               CHAR_BSLASH )) &&
        !StrChr(szSpec, CHAR_COLON))
    {
        lstrcpy(pOFI->szSpecCur, szSpec);
        if (!bInitializing)
        {
            UpdateListBoxes(hDlg, pOFI, szSpec, mskDirectory);
        }
    }
    else
    {
        *szDirBuf = CHAR_NULL;

        //
        //  Just root + pattern.
        //
        if (szPattern == StrChr(szSpec, CHAR_BSLASH))
        {
            if (!szPattern)
            {
                //
                //  Didn't find a slash, must have drive.
                //
                szPattern = CharNext(CharNext(szSpec));
            }
            else if ((szPattern == szSpec) ||
                     ((szPattern - 2 == szSpec) &&
                      (*(szSpec + 1) == CHAR_COLON)))
            {
                szPattern = CharNext(szPattern);
            }
            else
            {
                goto KillSlash;
            }
            chSave = *szPattern;
            if (chSave != CHAR_DOT)
            {
                //
                //  If not c:.. or c:.
                //
                *szPattern = CHAR_NULL;
            }
            lstrcpy(szDirBuf, szSpec);
            if (chSave == CHAR_DOT)
            {
                szPattern = szSpec + lstrlen(szSpec);
                AppendExt(szPattern, pOFI->pOFN->lpstrDefExt, TRUE);
            }
            else
            {
                *szPattern = chSave;
            }
        }
        else
        {
KillSlash:
            *szPattern++ = 0;
            lstrcpy(szDirBuf, szSpec);
        }

        if ((nRet = ChangeDir(hDlg, szDirBuf, TRUE, FALSE)) < 0)
        {
            return (nRet);
        }

        lstrcpy(pOFI->szSpecCur, szPattern);
        SetDlgItemText(hDlg, edt1, pOFI->szSpecCur);

        SelDisk(hDlg, NULL);

        if (!bInitializing)
        {
            SendMessage( hDlg,
                         WM_COMMAND,
                         GET_WM_COMMAND_MPS( cmb2,
                                             GetDlgItem(hDlg, cmb2),
                                             MYCBN_DRAW ) );
        }
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeDir
//
//  Changes the current directory and/or resource.
//
//  lpszDir - Fully qualified, or partially qualified names.
//            To change to another disk and cd automatically to the
//            last directory as set in the shell's environment, specify
//            only a disk name (i.e. c: or \\triskal\scratch - must not end
//            in backslash).
//  bForce  - If True, then caller requires that ChangeDir successfully cd
//            somewhere.  Order of cding is as follows:
//                1. lpszDir
//                2. current dir for the current thread
//                3. root of current dir for the current thread
//                4. c:
//  bError - if TRUE, then pop up an AccessDenied dialog at every step
//           in the force.
//
//  Returns an index into gaDiskInfo for new disk chosen or,
//  the ADDDISK_error code.
//  Returns ADDDISK_NOCHANGE in the event that it cannot cd to the root
//  directory of the specific file.
//
////////////////////////////////////////////////////////////////////////////

int ChangeDir(
    HWND hDlg,
    LPCTSTR lpszDir,
    BOOL bForce,
    BOOL bError)
{
    TCHAR szCurDir[CCHNETPATH];
    LPTSTR lpCurDir;
    int cchDirLen;
    TCHAR wcDrive = 0;
    int nIndex;
    BOOL nRet;
    LPCURDLG lpCurDlg;


    //
    //  SheChangeDirEx will call GetCurrentDir, but will use what it
    //  gets only in the case where the path passed in was no good.
    //

    //
    //  1st, try request.
    //
    if (lpszDir && *lpszDir)
    {
        lstrcpyn(szCurDir, lpszDir, CCHNETPATH);

        //
        //  Remove trailing spaces.
        //
        lpCurDir = szCurDir + lstrlen(szCurDir) - 1;
        while (*lpCurDir && (*lpCurDir == CHAR_SPACE))
        {
            *lpCurDir-- = CHAR_NULL;
        }

        nRet = SheChangeDirEx(szCurDir);
        
#ifdef UNICODE
        if (nRet == ERROR_ACCESS_DENIED)
#else
        if (!nRet)
#endif       
        {
            if (bError)
            {
                //
                //  Casting to LPTSTR is ok below - InvalidFileWarning will
                //  not change this string because the path is always
                //  guaranteed to be <= MAX_FULLPATHNAME.
                //
                InvalidFileWarning( hDlg,
                                    (LPTSTR)lpszDir,
                                    ERROR_DIR_ACCESS_DENIED,
                                    0 );
            }

            if (!bForce)
            {
                return (CHANGEDIR_FAILED);
            }
        }
        else
        {
            goto ChangeDir_OK;
        }
    }

    //
    //  2nd, try lpCurDlg->lpstrCurDir value (which we got above).
    //
    //  !!! need to check for a null return value ???
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

    nRet = SheChangeDirEx(lpCurDir);

#ifdef UNICODE
    if (nRet == ERROR_ACCESS_DENIED)
#else
    if (!nRet)
#endif
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                lpCurDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    //
    //  3rd, try root of lpCurDlg->lpstrCurDir or GetCurrentDir (sanity).
    //
    lstrcpy(szCurDir, lpCurDir);
    cchDirLen = GetPathOffset(szCurDir);

    //
    //  Sanity check - it's guaranteed not to fail ...
    //
    if (cchDirLen != -1)
    {
        szCurDir[cchDirLen] = CHAR_BSLASH;
        szCurDir[cchDirLen + 1] = CHAR_NULL;

        nRet = SheChangeDirEx(szCurDir);

#ifdef UNICODE
        if (nRet == ERROR_ACCESS_DENIED)
#else
        if (!nRet)
#endif        
        {
            if (bError)
            {
                InvalidFileWarning( hDlg,
                                    (LPTSTR)lpszDir,
                                    ERROR_DIR_ACCESS_DENIED,
                                    0 );
            }
        }
        else
        {
            goto ChangeDir_OK;
        }
    }

    //
    //  4th, try c:
    //
    lstrcpy(szCurDir, TEXT("c:"));
    nRet = SheChangeDirEx(szCurDir);

#ifdef UNICODE
    if (nRet == ERROR_ACCESS_DENIED)
#else
    if (!nRet)
#endif
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                (LPTSTR)lpszDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    return (CHANGEDIR_FAILED);

ChangeDir_OK:

    GetCurrentDirectory(CCHNETPATH, szCurDir);

    nIndex = DiskAddedPreviously(0, szCurDir);

    //
    //  If the disk doesn't exist, add it.
    //
    if (nIndex == -1)
    {
        HWND hCmb2 = GetDlgItem(hDlg, cmb2);
        LPTSTR lpszDisk = NULL;
        DWORD dwType;
        TCHAR wc1, wc2;

        if (szCurDir[1] == CHAR_COLON)
        {
            wcDrive = szCurDir[0];
        }
        else
        {
            lpszDisk = &szCurDir[0];
        }

        cchDirLen = GetPathOffset(szCurDir);
        if (cchDirLen != -1)
        {
            wc1 = szCurDir[cchDirLen];
            wc2 = szCurDir[cchDirLen + 1];

            szCurDir[cchDirLen] = CHAR_BSLASH;
            szCurDir[cchDirLen + 1] = CHAR_NULL;
        }

        dwType = GetDiskIndex(GetDiskType(szCurDir));

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = CHAR_NULL;
        }

        nIndex = AddDisk(wcDrive, lpszDisk, NULL, dwType);

        SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

        wNoRedraw |= 1;

        SendMessage( hCmb2,
                     CB_SETITEMDATA,
                     (WPARAM)SendMessage(
                                 hCmb2,
                                 CB_ADDSTRING,
                                 (WPARAM)0,
                                 (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                     (LPARAM)gaDiskInfo[nIndex].dwType );

        if ((dwType != NETDRVBMP) && (dwType != REMDRVBMP))
        {
            gaDiskInfo[nIndex].bCasePreserved =
                IsFileSystemCasePreserving(gaDiskInfo[nIndex].lpPath);
        }

        wNoRedraw &= ~1;

        SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = wc1;
            szCurDir[cchDirLen + 1] = wc2;
        }
    }
    else
    {
        //
        //  Validate the disk if it has been seen before.
        //
        //  For unc names that fade away, refresh the cmb2 box.
        //
        if (!gaDiskInfo[nIndex].bValid)
        {
            gaDiskInfo[nIndex].bValid = TRUE;

            SendDlgItemMessage(
                   hDlg,
                   cmb2,
                   CB_SETITEMDATA,
                   (WPARAM)SendDlgItemMessage(
                               hDlg,
                               cmb2,
                               CB_ADDSTRING,
                               (WPARAM)0,
                               (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                   (LPARAM)gaDiskInfo[nIndex].dwType );
        }
    }

    //
    //  Update our global concept of Case.
    //
    if (nIndex >= 0)
    {
        //
        //  Send special WOW message to indicate the directory has
        //  changed.
        //
        SendMessage(hDlg, msgWOWDIRCHANGE, 0, 0);

        //
        //  Get pointer to current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        if (!lpCurDlg || !lpCurDir)
        {
            return (CHANGEDIR_FAILED);
        }

        bCasePreserved = gaDiskInfo[nIndex].bCasePreserved;

        //
        //  In case the unc name already has a drive letter, correct
        //  lst2 display.
        //
        cchDirLen = 0;

        //
        //  Compare with szCurDir since it's been lowercased.
        //
        if (DBL_BSLASH(szCurDir) &&
            (*gaDiskInfo[nIndex].lpAbbrName != szCurDir[0]))
        {
            if ((cchDirLen = GetPathOffset(szCurDir)) != -1)
            {
                szCurDir[--cchDirLen] = CHAR_COLON;
                szCurDir[--cchDirLen] = *gaDiskInfo[nIndex].lpAbbrName;
            }
        }

        if ((gaDiskInfo[nIndex].dwType == CDDRVBMP) ||
            (gaDiskInfo[nIndex].dwType == FLOPPYBMP))
        {
            if (*lpCurDir != gaDiskInfo[nIndex].wcDrive)
            {
                TCHAR szDrive[5];

                //
                //  Get new volume info - should always succeed.
                //
                szDrive[0] = gaDiskInfo[nIndex].wcDrive;
                szDrive[1] = CHAR_COLON;
                szDrive[2] = CHAR_BSLASH;
                szDrive[3] = CHAR_NULL;
                UpdateLocalDrive(szDrive, TRUE);

                //
                //  Flush to the cmb before selecting the disk.
                //
                if ( lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg) )
                {
                    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;
                    FlushDiskInfoToCmb2();
                }
            }
        }
        
        lstrcpy(lpCurDir, (LPTSTR)&szCurDir[cchDirLen]);
        PathAddBackslash(lpCurDir);

        //
        //  If the worker thread is running, then trying to select here
        //  will just render the cmb2 blank, which is what we want;
        //  otherwise, it should successfully select it.
        //
        SelDisk(hDlg, gaDiskInfo[nIndex].lpPath);
    }
//  else
//  {
//      print out error message returned from AddDisk ...
//  }

    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsFileSystemCasePreserving
//
////////////////////////////////////////////////////////////////////////////

BOOL IsFileSystemCasePreserving(
    LPTSTR lpszDisk)
{
    TCHAR szPath[MAX_FULLPATHNAME];
    DWORD dwFlags;

    if (!lpszDisk)
    {
        return (FALSE);
    }

    lstrcpy(szPath, lpszDisk);
    lstrcat(szPath, TEXT("\\"));

    if (GetVolumeInformation( szPath,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              &dwFlags,
                              NULL,
                              0 ))
    {
        return ((dwFlags & FS_CASE_IS_PRESERVED));
    }

    //
    //  Default to FALSE if there is an error.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsLFNDriveX
//
////////////////////////////////////////////////////////////////////////////

BOOL IsLFNDriveX(
    HWND hDlg,
    LPTSTR szPath)
{
    TCHAR szRootPath[MAX_FULLPATHNAME];
    DWORD dwVolumeSerialNumber;
    DWORD dwMaximumComponentLength;
    DWORD dwFileSystemFlags;
    LPTSTR lpCurDir;
    LPCURDLG lpCurDlg;


    if (!szPath[0] || !szPath[1] ||
        (szPath[1] != CHAR_COLON && !(DBL_BSLASH(szPath))))
    {
        //
        //  If the path is not a full path then get the directory path
        //  from the TLS current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        lstrcpy(szRootPath, lpCurDir);
    }
    else
    {
        lstrcpy(szRootPath, szPath);
    }

    if (szRootPath[1] == CHAR_COLON)
    {
        szRootPath[2] = CHAR_BSLASH;
        szRootPath[3] = 0;
    }
    else if (DBL_BSLASH(szRootPath))
    {
        int i;
        LPTSTR p;

        //
        //  Stop at "\\foo\bar".
        //
        for (i = 0, p = szRootPath + 2; *p && i < 2; p++)
        {
            if (ISBACKSLASH_P(szRootPath, p))
            {
                i++;
            }
        }

        switch (i)
        {
            case ( 0 ) :
            {
                return (FALSE);
            }
            case ( 1 ) :
            {
                if (lstrlen(szRootPath) < MAX_FULLPATHNAME - 2)
                {
                    *p = CHAR_BSLASH;
                    *(p + 1) = CHAR_NULL;
                }
                else
                {
                    return (FALSE);
                }
                break;
            }

            case ( 2 ) :
            {
                *p = CHAR_NULL;
                break;
            }
        }
    }

    if (GetVolumeInformation( szRootPath,
                              NULL,
                              0,
                              &dwVolumeSerialNumber,
                              &dwMaximumComponentLength,
                              &dwFileSystemFlags,
                              NULL,
                              0 ))
    {
        if (dwMaximumComponentLength == (MAXDOSFILENAMELEN - 1))
        {
            return (FALSE);
        }
        else
        {
            return (TRUE);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DiskAddedPreviously
//
//  This routine checks to see if a disk resource has been previously
//  added to the global structure.
//
//  wcDrive  - if this is set, then there is no lpszName comparison
//  lpszName - if wcDrive is not set, but the lpszName is of the form
//               "c:\" then set wcDrive = *lpszName and index by drive letter
//             else assume lpszName is a unc name
//
//  Returns:   0xFFFFFFFF   failure (disk doesn't exist in list)
//             0 - 128      number of disk in list
//
////////////////////////////////////////////////////////////////////////////

int DiskAddedPreviously(
    TCHAR wcDrive,
    LPTSTR lpszName)
{
    WORD i;

    //
    //  There are two index schemes (by drive or by unc \\server\share).
    //  If it doesn't have a drive letter, assume unc.
    //
    if (wcDrive || (lpszName && (*(lpszName + 1) == CHAR_COLON)))
    {
        if (!wcDrive)
        {
            wcDrive = *lpszName;
            wcDrive = (TCHAR)CharLower((LPTSTR)wcDrive);
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            //
            //  See if the drive letters are the same.
            //
            if (wcDrive)
            {
                if (wcDrive == (TCHAR)CharLower((LPTSTR)gaDiskInfo[i].wcDrive))
                {
                    return (i);
                }
            }
        }
    }
    else if (lpszName)
    {
        DWORD cchDirLen;
        TCHAR wc;

        //
        //  Check remote name (\\server\share).
        //
        cchDirLen = GetPathOffset(lpszName);

        //
        //  If we're given a unc path, get the disk name.
        //  Otherwise, assume the whole thing is a disk name.
        //
        if (cchDirLen != -1)
        {
            wc = *(lpszName + cchDirLen);
            *(lpszName + cchDirLen) = CHAR_NULL;
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            if (!lstrcmpi(gaDiskInfo[i].lpName, lpszName))
            {
                if (cchDirLen != -1)
                {
                    *(lpszName + cchDirLen) = wc;
                }
                return (i);
            }
        }

        if (cchDirLen != -1)
        {
            *(lpszName + cchDirLen) = wc;
        }
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddDisk
//
//  Adds a disk to one of the global structures:
//      gaNetDiskInfo
//      gaLocalDiskInfo
//
//  wcDrive    - the drive to attach to (this parm should be 0 for unc)
//  lpName     - \\server\share name for remote disks
//               volume name for local disks
//  lpProvider - used for remote disks only, the name of the provider
//               used with WNetFormatNetworkName api
//  dwType     - type of the bitmap to display
//               except when we are adding a drive letter temporarily
//               at startup this parameter can equal TMPNETDRV in which
//               case we set the bitmap to NETDRVBMP
//
//  Returns:  -2    Cannot Add Disk
//            -1    DiskInfo did not change
//             0    dwNumDisks - DiskInfo changed
//
////////////////////////////////////////////////////////////////////////////

int AddDisk(
    TCHAR wcDrive,
    LPTSTR lpName,
    LPTSTR lpProvider,
    DWORD dwType)
{
    int nIndex, nRet;
    DWORD cchMultiLen = 0;
    DWORD cchAbbrLen = 0;
    DWORD cchLen;
    DWORD dwRet = 0;
    LPTSTR lpBuff;
    OFN_DISKINFO *pofndiDisk = NULL, *pgDI;


    //
    //  Sanity check - wcDrive and/or lpName must be set.
    //
    if (!wcDrive && (!lpName || !*lpName))
    {
        return (ADDDISK_INVALIDPARMS);
    }

    nIndex = DiskAddedPreviously(wcDrive, lpName);

    if (nIndex != 0xFFFFFFFF)
    {
        //
        //  Do not add a temporary drive letter if we already
        //  have something better (added, for example, in a previous call).
        //
        if (dwType == TMPNETDRV)
        {
            gaDiskInfo[nIndex].bValid = TRUE;
            return (ADDDISK_NOCHANGE);
        }

        //  Using a floating profile, there can be collisions between
        //  local and network drives in which case we take the former.
        //
        //  Note: If the drive is remembered, we assume that getdrivetype
        //        will return false and that the drive is not added.
        //        But if it was added, then we overwrite anyway,
        //        since it's the desired behavior.
        //
        if ((dwType == REMDRVBMP) &&
            (dwType != gaDiskInfo[nIndex].dwType))
        {
            return (ADDDISK_NOCHANGE);
        }

        //
        //  Update previous connections.
        //
        if (!lstrcmpi(lpName, gaDiskInfo[nIndex].lpName))
        {
            //
            //  Don't update a connection as remembered, unless it's been
            //  invalidated.
            //
            if (dwType != REMDRVBMP)
            {
                gaDiskInfo[nIndex].dwType = dwType;
            }
            gaDiskInfo[nIndex].bValid = TRUE;

            return (ADDDISK_NOCHANGE);
        }
        else if (!*lpName && ((dwType == CDDRVBMP) || (dwType == FLOPPYBMP)))
        {
            //
            //  Guard against lazy calls to updatelocaldrive erasing current
            //  changed dir volume name (set via changedir).
            //
            return (ADDDISK_NOCHANGE);
        }
    }

    if (dwNumDisks >= MAX_DISKS)
    {
        return (ADDDISK_MAXNUMDISKS);
    }

    //
    //  If there is a drive, then lpPath needs only 4.
    //  If it's unc, then lpPath just equals lpName.
    //
    if (wcDrive)
    {
        cchLen = 4;
    }
    else
    {
        cchLen = 0;
    }

    if (lpName && *lpName)
    {
        //
        //  Get the length of the standard (Remote/Local) name.
        //
        cchLen += (lstrlen(lpName) + 1);

        if (lpProvider && *lpProvider &&
            ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
        {
            //
            //  Get the length for the multiline name.
            //
            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchMultiLen,
                                           WNFMT_MULTILINE,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard)
            //
            if (wcDrive)
            {
                cchMultiLen += 4;
            }

            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchAbbrLen,
                                           WNFMT_ABBREVIATED,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard).
            //
            if (wcDrive)
            {
                cchAbbrLen += 4;
            }
        }
        else
        {
            //
            //  Make enough room so that lpMulti and lpAbbr can point to
            //  4 characters (drive letter + : + space + null) ahead of
            //  lpremote.
            //
            if (wcDrive)
            {
                cchLen += 4;
            }
        }
    }
    else
    {
        //
        //  Make enough room so that lpMulti and lpAbbr can point to
        //  4 characters (drive letter + : + space + null) ahead of
        //  lpremote.
        //
        if (wcDrive)
        {
            cchLen += 4;
        }
    }

    //
    //  Allocate a temp OFN_DISKINFO object to work with.
    //  When we are finished, we'll request the critical section
    //  and update the global array.
    //
    pofndiDisk = (OFN_DISKINFO *)LocalAlloc(LPTR, sizeof(OFN_DISKINFO));
    if (!pofndiDisk)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    lpBuff = (LPTSTR)LocalAlloc( LPTR,
                                 (cchLen + cchMultiLen + cchAbbrLen) * sizeof(TCHAR));
    if (!lpBuff)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    if (dwType == TMPNETDRV)
    {
        pofndiDisk->dwType = NETDRVBMP;
    }
    else
    {
        pofndiDisk->dwType = dwType;
    }

    //
    //  Always set these slots, even though wcDrive can equal 0.
    //
    pofndiDisk->wcDrive = wcDrive;
    pofndiDisk->bValid = TRUE;

    pofndiDisk->cchLen = cchLen + cchAbbrLen + cchMultiLen;

    //
    //  NOTE: lpAbbrName must always point to the head of lpBuff
    //        so that we can free the block later at DLL_PROCESS_DETACH
    //
    if (lpName && *lpName && lpProvider && *lpProvider &&
        ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
    {
        //
        //  Create an entry for a network disk.
        //
        pofndiDisk->lpAbbrName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchAbbrLen -= 3;
        }

        dwRet = WNetFormatNetworkName( lpProvider,
                                       lpName,
                                       lpBuff,
                                       &cchAbbrLen,
                                       WNFMT_ABBREVIATED,
                                       dwAveCharPerLine );
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        lpBuff += cchAbbrLen;

        pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchMultiLen -= 3;
        }

        dwRet = WNetFormatNetworkName(lpProvider, lpName,
                                      lpBuff, &cchMultiLen, WNFMT_MULTILINE, dwAveCharPerLine);
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        //
        //  Note: this assumes that the lpRemoteName
        //        returned by WNetEnumResources is always in
        //        the form \\server\share (without a trailing bslash).
        //
        pofndiDisk->lpPath = lpBuff;

        //
        //  if it's not unc.
        //
        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_NULL;
        }

        lstrcpy(lpBuff, lpName);
        pofndiDisk->lpName = lpBuff;

        pofndiDisk->bCasePreserved =
            IsFileSystemCasePreserving(pofndiDisk->lpPath);
    }
    else
    {
        //
        //  Create entry for a local name, or a network one with
        //  no name yet.
        //
        pofndiDisk->lpAbbrName = pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;
        }

        if (lpName)
        {
            lstrcpy(lpBuff, lpName);
        }
        else
        {
            *lpBuff = CHAR_NULL;
        }

        pofndiDisk->lpName = lpBuff;

        if (wcDrive)
        {
            lpBuff += lstrlen(lpBuff) + 1;
            *lpBuff = wcDrive;
            *(lpBuff + 1) = CHAR_COLON;
            *(lpBuff + 2) = CHAR_NULL;
        }

        pofndiDisk->lpPath = lpBuff;

        if ((dwType == NETDRVBMP) || (dwType == REMDRVBMP))
        {
            pofndiDisk->bCasePreserved =
                IsFileSystemCasePreserving(pofndiDisk->lpPath);
        }
        else
        {
            pofndiDisk->bCasePreserved = FALSE;
        }
    }

    //
    //  Now we need to update the global array.
    //
    if (nIndex == 0xFFFFFFFF)
    {
        nIndex = dwNumDisks;
    }

    pgDI = &gaDiskInfo[nIndex];

    //
    //  Enter critical section and update data.
    //
    EnterCriticalSection(&g_csLocal);

    pgDI->cchLen = pofndiDisk->cchLen;
    pgDI->lpAbbrName = pofndiDisk->lpAbbrName;
    pgDI->lpMultiName = pofndiDisk->lpMultiName;
    pgDI->lpName = pofndiDisk->lpName;
    pgDI->lpPath = pofndiDisk->lpPath;
    pgDI->wcDrive = pofndiDisk->wcDrive;
    pgDI->bCasePreserved = pofndiDisk->bCasePreserved;
    pgDI->dwType = pofndiDisk->dwType;
    pgDI->bValid = pofndiDisk->bValid;

    LeaveCriticalSection(&g_csLocal);

    if ((DWORD)nIndex == dwNumDisks)
    {
        dwNumDisks++;
    }

    nRet = nIndex;

AddDisk_Error:

    if (pofndiDisk)
    {
        LocalFree(pofndiDisk);
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableDiskInfo
//
////////////////////////////////////////////////////////////////////////////

VOID EnableDiskInfo(
    BOOL bValid,
    BOOL bDoUnc)
{
    DWORD dwCnt = dwNumDisks;

    EnterCriticalSection(&g_csLocal);
    while (dwCnt--)
    {
        if (gaDiskInfo[dwCnt].dwType == NETDRVBMP)
        {
            if (!(DBL_BSLASH(gaDiskInfo[dwCnt].lpAbbrName)) || bDoUnc)
            {
                gaDiskInfo[dwCnt].bValid = bValid;
            }

            //
            //  Always re-invalidate remembered just in case someone
            //  escapes from fileopen, removes a connection
            //  overriding a remembered and comes back expecting to see
            //  the original remembered.
            //
        }
    }
    LeaveCriticalSection(&g_csLocal);
}


////////////////////////////////////////////////////////////////////////////
//
//  FlushDiskInfoToCmb2
//
////////////////////////////////////////////////////////////////////////////

VOID FlushDiskInfoToCmb2()
{
    DWORD dwDisk;
    DWORD dwDlg;

    for (dwDlg = 0; dwDlg < dwNumDlgs; dwDlg++)
    {
        if (gahDlg[dwDlg])
        {
            HWND hCmb2;

            if (hCmb2 = GetDlgItem(gahDlg[dwDlg], cmb2))
            {
                wNoRedraw |= 1;

                SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

                SendMessage(hCmb2, CB_RESETCONTENT, 0, 0);

                dwDisk = dwNumDisks;
                while (dwDisk--)
                {
                    if (gaDiskInfo[dwDisk].bValid)
                    {
                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                hCmb2,
                                CB_ADDSTRING,
                                (WPARAM)0,
                                (LPARAM)(LPTSTR)gaDiskInfo[dwDisk].lpAbbrName ),
                            (LPARAM)gaDiskInfo[dwDisk].dwType );
                    }
                }

                wNoRedraw &= ~1;

                SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hCmb2, NULL, FALSE);

                SendMessage( gahDlg[dwDlg],
                             WM_COMMAND,
                             GET_WM_COMMAND_MPS(cmb2, hCmb2, MYCBN_REPAINT) );
            }
            gahDlg[dwDlg] = NULL;           
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CallNetDlg
//
//  Calls the appropriate network dialog in winnet driver.
//
//  hwndParent - parent window of network dialog
//
//  Returns:  TRUE     there are new drives to display
//            FALSE    there are no new drives to display
//
////////////////////////////////////////////////////////////////////////////

BOOL CallNetDlg(
    HWND hWnd)
{
    DWORD wRet;

    HourGlass(TRUE);

    wRet = WNetConnectionDialog(hWnd, WNTYPE_DRIVE);

    if ((wRet != WN_SUCCESS) && (wRet != WN_CANCEL) && (wRet != 0xFFFFFFFF))
    {
        if (!CDLoadString( g_hinst,
                         iszNoNetButtonResponse,
                         szCaption,
                         WARNINGMSGLENGTH ))
        {
            //
            //  !!!!! CAUTION
            //  The following is not portable between code pages.
            //
            wsprintf( szWarning,
                      TEXT("Error occurred, but error resource cannot be loaded.") );
        }
        else
        {
            wsprintf(szWarning, szCaption);

            GetWindowText(hWnd, szCaption, WARNINGMSGLENGTH);
            MessageBox( hWnd,
                        szWarning,
                        szCaption,
                        MB_OK | MB_ICONEXCLAMATION );
        }
    }

    HourGlass(FALSE);

    return (wRet == WN_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskType
//
////////////////////////////////////////////////////////////////////////////

UINT GetDiskType(
    LPTSTR lpszDisk)
{
    //
    //  Unfortunately GetDriveType is not for deviceless connections.
    //  So assume all unc stuff is just "remote" - no way of telling
    //  if it's a cdrom or not.
    //
    if (DBL_BSLASH(lpszDisk))
    {
        return (DRIVE_REMOTE);
    }
    else
    {
        return (GetDriveType(lpszDisk));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUNCDirectoryFromLB
//
//  If lb contains a UNC listing, the function returns the full UNC path.
//
//  Returns:   0 if no UNC listing in lb
//             length of UNC listing string
//
////////////////////////////////////////////////////////////////////////////

DWORD GetUNCDirectoryFromLB(
    HWND hDlg,
    WORD nLB,
    POPENFILEINFO pOFI)
{
    DWORD cch;
    DWORD idir;
    DWORD idirCurrent;

    cch = (DWORD)SendDlgItemMessage( hDlg,
                                     nLB,
                                     LB_GETTEXT,
                                     0,
                                     (LPARAM)(LPTSTR)pOFI->szPath );
    //
    //  If not UNC listing, return 0.
    //
    if (pOFI->szPath[0] != CHAR_BSLASH)
    {
        return (0);
    }

    idirCurrent = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                   nLB,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L );
    if (idirCurrent < (pOFI->idirSub - 1))
    {
        pOFI->idirSub = idirCurrent;
    }
    pOFI->szPath[cch++] = CHAR_BSLASH;
    for (idir = 1; idir < pOFI->idirSub; ++idir)
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idir,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    //
    //  Only add the subdirectory if it's not the \\server\share point.
    //
    if (idirCurrent && (idirCurrent >= pOFI->idirSub))
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idirCurrent,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    pOFI->szPath[cch] = CHAR_NULL;

    return (cch);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelDisk
//
//  Selects the given disk in the combo drive list.  Works for unc names,
//  too.
//
////////////////////////////////////////////////////////////////////////////

VOID SelDisk(
    HWND hDlg,
    LPTSTR lpszDisk)
{
    HWND hCmb = GetDlgItem(hDlg, cmb2);

    if (lpszDisk)
    {
        CharLower(lpszDisk);

        SendMessage( hCmb,
                     CB_SETCURSEL,
                     (WPARAM)SendMessage( hCmb,
                                          CB_FINDSTRING,
                                          (WPARAM)-1,
                                          (LPARAM)lpszDisk ),
                     0L );
    }
    else
    {
        TCHAR szChangeSel[CCHNETPATH];
        LPTSTR lpCurDir;
        LPCURDLG lpCurDlg;
        int cch = CCHNETPATH;

        if ((lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) &&
            (lpCurDir = lpCurDlg->lpstrCurDir))
        {
            lstrcpy(szChangeSel, lpCurDir);
            GetCurrentDirectory(ARRAYSIZE(szChangeSel), szChangeSel);

            if ((cch = GetPathOffset(szChangeSel)) != -1)
            {
                szChangeSel[cch] = CHAR_NULL;
            }

            SendMessage( hCmb,
                         CB_SETCURSEL,
                         (WPARAM)SendMessage( hCmb,
                                              CB_FINDSTRING,
                                              (WPARAM)-1,
                                              (LPARAM)szChangeSel ),
                         0L );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LNDSetEvent
//
////////////////////////////////////////////////////////////////////////////

VOID LNDSetEvent(
    HWND hDlg)
{
    LPCURDLG lpCurDlg;

    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if ( lpCurDlg &&
         hLNDEvent &&
         !wNoRedraw &&
         hLNDThread &&
         bNetworkInstalled)
    {
        gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

        SetEvent(hLNDEvent);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateLocalDrive
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateLocalDrive(
    LPTSTR szDrive,
    BOOL bGetVolName)
{
    DWORD dwFlags = 0;
    DWORD dwDriveType;
    TCHAR szVolLabel[MAX_PATH];

    //
    //  No unc here - so bypass extra call to GetDiskType and call
    //  GetDriveType directly.
    //
    dwDriveType = GetDriveType(szDrive);
    if ((dwDriveType != 0) && (dwDriveType != 1))
    {
        BOOL bRet = TRUE;

        szVolLabel[0] = CHAR_NULL;
        szDrive[1] = CHAR_COLON;
        szDrive[2] = CHAR_NULL;

        if ( bGetVolName ||
             ((dwDriveType != DRIVE_REMOVABLE) &&
              (dwDriveType != DRIVE_CDROM) &&
              (dwDriveType != DRIVE_REMOTE)) )
        {
            //
            //  Removing call to CharUpper since it causes trouble on
            //  turkish machines.
            //
            //  CharUpper(szDrive);

            if (GetFileAttributes(szDrive) != (DWORD)0xffffffff)
            {
                if (dwDriveType != DRIVE_REMOTE)
                {
                    szDrive[2] = CHAR_BSLASH;

                    bRet = GetVolumeInformation( szDrive,
                                                 szVolLabel,
                                                 MAX_PATH,
                                                 NULL,
                                                 NULL,
                                                 &dwFlags,
                                                 NULL,
                                                 (DWORD)0 );

                    //
                    //  The adddisk hack to prevent lazy loading from
                    //  overwriting the current removable media's label
                    //  with "" (because it never calls getvolumeinfo)
                    //  is to not allow null lpnames to overwrite, so when
                    //  the volume label really is null, we make it a space.
                    //
                    if (!szVolLabel[0])
                    {
                        szVolLabel[0] = CHAR_SPACE;
                        szVolLabel[1] = CHAR_NULL;
                    }
                }
            }
        }

        if (bRet)
        {
            int nIndex;

            CharLower(szDrive);

            if (dwDriveType == DRIVE_REMOTE)
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  TMPNETDRV );
            }
            else
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  GetDiskIndex(dwDriveType) );
            }

            if (nIndex != ADDDISK_NOCHANGE)
            {
                gaDiskInfo[nIndex].bCasePreserved =
                    (dwFlags & FS_CASE_IS_PRESERVED);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNetDrives
//
//  Enumerates network disk resources and updates the global disk info
//  structure.
//
//  dwScope   RESOURCE_CONNECTED or RESOURCE_REMEMBERED
//
//  Returns the last connection that did not previously exist.
//
////////////////////////////////////////////////////////////////////////////

VOID GetNetDrives(
    DWORD dwScope)
{
    DWORD dwRet;
    HANDLE hEnum = NULL;

    //
    //  Guard against termination with the enum handle open.
    //
    dwRet = WNetOpenEnum( dwScope,
                          RESOURCETYPE_DISK,
                          RESOURCEUSAGE_CONNECTABLE,
                          NULL,
                          &hEnum );
    if (dwRet == WN_SUCCESS)
    {
        while (dwRet == WN_SUCCESS)
        {
            DWORD dwCount = 0xffffffff;
            DWORD cbSize = cbNetEnumBuf;

            if (bLNDExit)
            {
                WNetCloseEnum(hEnum);
                return;
            }

            dwRet = WNetEnumResource(hEnum, &dwCount, gpcNetEnumBuf, &cbSize);
            switch (dwRet)
            {
                case ( WN_SUCCESS ) :
                {
                    //
                    //  Add the Entries to the listbox.
                    //
                    TCHAR wcDrive = 0;
                    NETRESOURCE *pNetRes;
                    WORD i;

                    pNetRes = (LPNETRESOURCE)gpcNetEnumBuf;

                    for (i = 0; dwCount; dwCount--, i++)
                    {
                        if (pNetRes[i].lpLocalName)
                        {
                            CharLower(pNetRes[i].lpLocalName);
                            wcDrive = *pNetRes[i].lpLocalName;
                        }
                        else
                        {
                            //
                            //  Skip deviceless names that are not
                            //  LanMan provided (or, in the case where there
                            //  is no LanMan provider name, skip deviceless
                            //  always).
                            //
                            wcDrive = 0;
                        }

                        if (!DBL_BSLASH(pNetRes[i].lpRemoteName))
                        {
                            continue;
                        }

                        //
                        //  When bGetNetDrivesSync is TRUE, we are coming back
                        //  from the Network button, so we want to cd to the
                        //  last connected drive.
                        //      (see last command in this routine)
                        //
                        if (bGetNetDrivesSync)
                        {
                            int nIndex;
                            WORD k;

                            nIndex = AddDisk( wcDrive,
                                              pNetRes[i].lpRemoteName,
                                              pNetRes[i].lpProvider,
                                              (dwScope == RESOURCE_REMEMBERED)
                                                  ? REMDRVBMP
                                                  : NETDRVBMP );

                            //
                            //  If it's a new connection, update global state.
                            //
                            if (nIndex >= 0)
                            {
                                //
                                //  Since flushdiskinfotocmb2 will clear out
                                //  the array below, remember it's state here.
                                //  It's a hack, but a nice way to find out
                                //  exactly which of the many threads
                                //  completed a net dlg operation.
                                //
                                for (k = 0; k < dwNumDlgs; k++)
                                {
                                    if (gahDlg[k])
                                    {
                                        //  Could encounter small problems with
                                        //  preemption here, but assume that
                                        //  user cannot simultaneously return
                                        //  from two different net dlg calls.
                                        //
                                        lpNetDriveSync = gaDiskInfo[nIndex].lpPath;

                                        SendMessage(
                                            gahDlg[k],
                                            WM_COMMAND,
                                            GET_WM_COMMAND_MPS(
                                                   cmb2,
                                                   GetDlgItem(gahDlg[k], cmb2),
                                                   MYCBN_CHANGEDIR ) );
                                    }
                                }
                            }
                        }
                        else
                        {
                            AddDisk( wcDrive,
                                     pNetRes[i].lpRemoteName,
                                     pNetRes[i].lpProvider,
                                     (dwScope == RESOURCE_REMEMBERED)
                                         ? REMDRVBMP
                                         : NETDRVBMP );
                        }
                    }
                    break;
                }
                case ( WN_MORE_DATA ) :
                {
                    LPTSTR pcTemp;

                    pcTemp = (LPTSTR)LocalReAlloc( gpcNetEnumBuf,
                                                   cbSize,
                                                   LMEM_MOVEABLE );
                    if (!pcTemp)
                    {
                        cbNetEnumBuf = 0;
                    }
                    else
                    {
                        gpcNetEnumBuf = pcTemp;
                        cbNetEnumBuf = cbSize;
                        dwRet = WN_SUCCESS;
                        break;
                    }
                }
                case ( WN_NO_MORE_ENTRIES ) :
                case ( WN_EXTENDED_ERROR ) :
                case ( WN_NO_NETWORK ) :
                {
                    //
                    //  WN_NO_MORE_ENTRIES is a success error code.
                    //  It is special cased when we fall out of the loop.
                    //
                    break;
                }
                case ( WN_BAD_HANDLE ) :
                default :
                {
                    break;
                }
            }
        }

        WNetCloseEnum(hEnum);

        //
        //  Flush once per event - there will always be a call with
        //  dwscope = connected.
        //
        if (dwScope == RESOURCE_CONNECTED)
        {
            FlushDiskInfoToCmb2();
        }

        if (bGetNetDrivesSync)
        {
            bGetNetDrivesSync = FALSE;
        }
    }
}


#if 0
// See comments in ListNetDrivesHandler

////////////////////////////////////////////////////////////////////////////
//
//  HideNetButton
//
////////////////////////////////////////////////////////////////////////////

VOID HideNetButton()
{
    DWORD dwDlg;
    HWND hNet;

    for (dwDlg = 0; dwDlg < dwNumDlgs; dwDlg++)
    {
        hNet = GetDlgItem(gahDlg[dwDlg], psh14);

        EnableWindow(hNet, FALSE);
        ShowWindow(hNet, SW_HIDE);
    }
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  ListNetDrivesHandler
//
////////////////////////////////////////////////////////////////////////////

VOID ListNetDrivesHandler()
{
    BOOL bInit = TRUE;
    HANDLE hEnum = NULL;
  
    if (!gpcNetEnumBuf &&
        !(gpcNetEnumBuf = (LPTSTR)LocalAlloc(LPTR, cbNetEnumBuf)))
    {
        hLNDThread = NULL;
        return;
    }

    if (bLNDExit)
    {
        goto LNDExitThread1;
    }

    EnterCriticalSection(&g_csNetThread);
   
    while (1)
    {
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        //
        //  hLNDEvent will always be valid since we have loaded ourself
        //  and FreeLibrary will not produce a DLL_PROCESS_DETACH.
        //
        WaitForSingleObject(hLNDEvent, INFINITE);

        //
        //  In case this is the exit event.
        //
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        EnableDiskInfo(FALSE, FALSE);
       
        if (bInit)
        {
            GetNetDrives(RESOURCE_REMEMBERED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            bInit = FALSE;
        }
        else
        {
            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }
        }

        ResetEvent(hLNDEvent);
    }

LNDExitThread:

    bLNDExit = FALSE;       
    LeaveCriticalSection(&g_csNetThread);

LNDExitThread1:

    FreeLibraryAndExitThread(g_hinst, 1);

    //
    //  The ExitThread is implicit in this return.
    //
    return;
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadDrives
//
//  Lists the current drives (connected) in the combo box.
//
////////////////////////////////////////////////////////////////////////////

VOID LoadDrives(
    HWND hDlg)
{
    //
    //  Hard-code this - It's internal && always cmb2/psh14.
    //
    HWND hCmb = GetDlgItem(hDlg, cmb2);
    DWORD dwThreadID;
    LPCURDLG lpCurDlg;
    BOOL bFirstAttach = FALSE;
    WORD wCurDrive;
    TCHAR szDrive[5];
    
    if (!hLNDEvent)
    {
        //
        //  Don't check if this succeeds since we can run without the net.
        //
        hLNDEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        bFirstAttach = TRUE;
    }
    else
    {
        //
        //  Assume all previous connections (except unc) are valid
        //  for first display - but only when they exist.
        //
        EnableDiskInfo(TRUE, FALSE);
    }

    //
    //  Set the hDlg into the refresh array before initially
    //  creating the thread so that the worker thread can hide/disable
    //  the net button in the event that there is no network.
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    // sanity check
    if (!lpCurDlg)
    {
        return;
    }

    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

    //
    //  If there is no worker thread for network disk enumeration,
    //  start up here rather than in the dll, since it's only
    //  for the fileopen dlg.
    //
    //  Always start a thread if the number of active fileopen dialogs
    //  goes from 0 to 1
    //
    if ((lpCurDlg->dwCurDlgNum == 0) && (!hLNDThread))
    {
        if (hLNDEvent && (bNetworkInstalled = IsNetworkInstalled()))
        {
            TCHAR szModule[MAX_PATH];

            //
            //  Do this once when dialog thread count goes from 0 to 1.
            //
            GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule));
            if (LoadLibrary(szModule))
            {
                hLNDThread = CreateThread(
                                   NULL,
                                   (DWORD)0,
                                   (LPTHREAD_START_ROUTINE)ListNetDrivesHandler,
                                   (LPVOID)NULL,
                                   (DWORD_PTR)NULL,
                                   &dwThreadID );
            }
        }
        else
        {
            HWND hNet = GetDlgItem(hDlg, psh14);

            EnableWindow(hNet, FALSE);
            ShowWindow(hNet, SW_HIDE);
        }
    }

    // Fix for Millenium BUG #113035
    // Putting the get drives information code instead of in the 
    // ListNetDriveHandler thread.
    

    //
    //  Get the drive information for all drives.
    //
    //  NOTE: If we don't redo all volume info, then a change in a volume
    //        label will never be caught by wow apps unless wowexec is
    //        killed and restarted.  Therefore, information for all drives
    //        should be retrieved here.
    //
    for (wCurDrive = 0; wCurDrive <= 25; wCurDrive++)
    {
        szDrive[0] = (CHAR_A + (TCHAR)wCurDrive);
        szDrive[1] = CHAR_COLON;
        szDrive[2] = CHAR_BSLASH;
        szDrive[3] = CHAR_NULL;

        UpdateLocalDrive(szDrive, FALSE);
    }
    
    FlushDiskInfoToCmb2();

    //
    //  Now invalidate all net conns and re-enum, but only if there is
    //  indeed a worker thread too.
    //
    if (!bFirstAttach)
    {
        EnableDiskInfo(FALSE, FALSE);
    }
    
    LNDSetEvent(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskIndex
//
////////////////////////////////////////////////////////////////////////////

DWORD GetDiskIndex(
    DWORD dwDriveType)
{
    if (dwDriveType == 1)
    {
        //
        //  Drive doesn't exist!
        //
        return (0);
    }
    else if (dwDriveType == DRIVE_CDROM)
    {
        return (CDDRVBMP);
    }
    else if (dwDriveType == DRIVE_REMOVABLE)
    {
        return (FLOPPYBMP);
    }
    else if (dwDriveType == DRIVE_REMOTE)
    {
        return (NETDRVBMP);
    }
    else if (dwDriveType == DRIVE_RAMDISK)
    {
        return (RAMDRVBMP);
    }

    return (HARDDRVBMP);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpFile
//
//  This releases the memory used by the system dialog bitmaps.
//
////////////////////////////////////////////////////////////////////////////

VOID CleanUpFile()
{
    //
    //  Check if anyone else is around.
    //
    if (--cLock)
    {
        return;
    }

    //
    //  Select the null bitmap into our memory DC so that the
    //  DirDrive bitmap can be discarded.
    //
    SelectObject(hdcMemory, hbmpOrigMemBmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenAbort
//
////////////////////////////////////////////////////////////////////////////

VOID FileOpenAbort()
{
    LPCURDLG lpCurDlg;


    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if (lpCurDlg)
    {
        EnterCriticalSection(&g_csLocal);

        if (dwNumDlgs > 0)
        {
            dwNumDlgs--;
        }

        if (dwNumDlgs == 0)
        {
            //
            //  If there are no more fileopen dialogs for this process,
            //  then signal the worker thread it's all over.
            //
            if (hLNDEvent && hLNDThread)
            {
                bLNDExit = TRUE;
                SetEvent(hLNDEvent);

                CloseHandle(hLNDThread);
                hLNDThread = NULL;
            }
        }

        LeaveCriticalSection(&g_csLocal);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TermFile
//
////////////////////////////////////////////////////////////////////////////

VOID TermFile()
{
    vDeleteDirDriveBitmap();
    if (hdcMemory)
    {
        DeleteDC(hdcMemory);
    }

    if (hLNDEvent)
    {
        CloseHandle(hLNDEvent);
        hLNDEvent = NULL;
    }

    if (gpcNetEnumBuf)
    {
        LocalFree(gpcNetEnumBuf);
    }

    while (dwNumDisks)
    {
        dwNumDisks--;
        if (gaDiskInfo[dwNumDisks].lpAbbrName)
        {
            LocalFree(gaDiskInfo[dwNumDisks].lpAbbrName);
        }
    }
}






/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2WDelayed
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkOpenFileNameA2WDelayed(
    POPENFILEINFO pOFI)
{
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        DWORD cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);

        if (pOFNW->lpstrDefExt)
        {
            LocalFree((HLOCAL)pOFNW->lpstrDefExt);
        }
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return;
        }
        else
        {
            if (pOFNA->lpstrDefExt)
            {
                SHAnsiToUnicode(pOFNA->lpstrDefExt,(LPWSTR)pOFNW->lpstrDefExt,cbLen );
            }
        }
    }

    //
    //  Need to thunk back to A value since Claris Filemaker side effects
    //  this in an ID_OK subclass without hooking at the very last moment.
    //  Do an |= instead of an = to preserve internal flags.
    //
    pOFNW->Flags &= OFN_ALL_INTERNAL_FLAGS;
    pOFNW->Flags |= pOFNA->Flags;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2W
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameA2W(
    POPENFILEINFO pOFI)
{
    int    nRet;


    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    pOFNW->Flags = pOFNA->Flags;
    pOFNW->lCustData = pOFNA->lCustData;

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if ((pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW)) 
       )
    {
        pOFNW->pvReserved = pOFNA->pvReserved ;
        pOFNW->dwReserved = pOFNA->dwReserved;
        pOFNW->FlagsEx   = pOFNA->FlagsEx;
    }

    //
    //  Various WOW apps change the strings and *ptrs* to the strings in the
    //  OPENFILENAME struct while processing messages with their hook procs.
    //  Handle that silliness here.  (We probably don't want to promote this
    //  beyond WOW).
    //
    if (pOFNA->Flags & CD_WOWAPP)
    {
        pOFNW->lpstrFilter = (LPCWSTR)
                       ThunkMultiANSIStrToWIDE( (LPWSTR)pOFNW->lpstrFilter,
                                                (LPSTR)pOFNA->lpstrFilter,
                                                0 );

        pOFNW->lpstrCustomFilter =
                       ThunkMultiANSIStrToWIDE( pOFNW->lpstrCustomFilter,
                                                pOFNA->lpstrCustomFilter,
                                                pOFNA->nMaxCustFilter );

        pOFNW->lpstrFile =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFile,
                                           pOFNA->lpstrFile,
                                           pOFNA->nMaxFile );

        pOFNW->lpstrFileTitle =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFileTitle,
                                           pOFNA->lpstrFileTitle,
                                           pOFNA->nMaxFileTitle );

        pOFNW->lpstrInitialDir = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrInitialDir,
                                           (LPSTR)pOFNA->lpstrInitialDir,
                                           0 );

        pOFNW->lpstrTitle = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrTitle,
                                           (LPSTR)pOFNA->lpstrTitle,
                                           0 );

        pOFNW->lpstrDefExt = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrDefExt,
                                           (LPSTR)pOFNA->lpstrDefExt,
                                           0 );

        pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        pOFNW->nMaxFile       = pOFNA->nMaxFile;
        pOFNW->nMaxFileTitle  = pOFNA->nMaxFileTitle;
        pOFNW->nFileOffset    = pOFNA->nFileOffset;
        pOFNW->nFileExtension = pOFNA->nFileExtension;
    }
    else
    {
        if (pOFNW->lpstrFile)
        {
            if (pOFNA->lpstrFile)
            {
                nRet = SHAnsiToUnicode(pOFNA->lpstrFile,pOFNW->lpstrFile,pOFNW->nMaxFile );
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrFileTitle && pOFNW->nMaxFileTitle)
        {
            if (pOFNA->lpstrFileTitle)
            {
                nRet=MultiByteToWideChar(CP_ACP,
                              0,
                              pOFNA->lpstrFileTitle,
                              pOFNA->nMaxFileTitle,
                              pOFNW->lpstrFileTitle,
                              pOFNW->nMaxFileTitle);
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrCustomFilter)
        {
            if (pOFI->pasCustomFilter)
            {
                LPSTR psz = pOFI->pasCustomFilter->Buffer;
                DWORD cch = 0;

                if (*psz || *(psz + 1))
                {
                    cch = 2;
                    while (*psz || *(psz + 1))
                    {
                        psz++;
                        cch++;
                    }
                }

                if (cch)
                {
                    pOFI->pasCustomFilter->Length = cch;

                    nRet = MultiByteToWideChar(CP_ACP,
                                    0,
                                    pOFI->pasCustomFilter->Buffer,
                                    pOFI->pasCustomFilter->Length,
                                    pOFI->pusCustomFilter->Buffer,
                                    pOFI->pusCustomFilter->MaximumLength );
                    if (nRet == 0)
                    {
                        return (FALSE);
                    }
                }
            }
        }
    }

    pOFNW->nFilterIndex = pOFNA->nFilterIndex;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameW2A
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameW2A(
    POPENFILEINFO pOFI)
{
    int nRet;

    LPOPENFILENAMEW pOFNW = pOFI->pOFN;
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPWSTR pszW;
    USHORT cch;

    //
    //  Supposedly invariant, but not necessarily.
    //    Definition: invariant - changed by 16-bit apps frequently
    //
    pOFNA->Flags = pOFNW->Flags;
    pOFNA->lCustData = pOFNW->lCustData;
    
    // this way we can assert that we are covered.
    DEBUG_CODE(pOFNA->nFileOffset = 0 );

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if (pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW) 
       )
    {
        pOFNA->pvReserved = pOFNW->pvReserved;
        pOFNA->dwReserved = pOFNW->dwReserved;
        pOFNA->FlagsEx   = pOFNW->FlagsEx;
    }


    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        nRet = SHUnicodeToAnsi(pOFNW->lpstrFileTitle,pOFNA->lpstrFileTitle,pOFNA->nMaxFileTitle);

        if (nRet == 0)
        {
            return (FALSE);
        }
    }

    if (pOFNA->lpstrCustomFilter)
    {
        pszW = pOFI->pusCustomFilter->Buffer;

        cch = 0;
        if (*pszW || *(pszW + 1))
        {
            cch = 2;
            while (*pszW || *(pszW + 1))
            {
                pszW++;
                cch++;
            }
        }

        if (cch)
        {
            pOFI->pusCustomFilter->Length = cch;
            nRet = WideCharToMultiByte(CP_ACP,
                                0,
                                pOFI->pusCustomFilter->Buffer,
                                pOFI->pusCustomFilter->Length,
                                pOFI->pasCustomFilter->Buffer,
                                pOFI->pasCustomFilter->MaximumLength,
                                NULL,
                                NULL);
            if (nRet == 0)
            {
                return (FALSE);
            }
        }
    }

    pOFNA->nFilterIndex   = pOFNW->nFilterIndex;

    if (pOFNA->lpstrFile && pOFNW->lpstrFile)
    {
        if (GetStoredExtendedError() == FNERR_BUFFERTOOSMALL)
        {
            //
            //  In the case where the lpstrFile buffer is too small,
            //  lpstrFile contains the size of the buffer needed for
            //  the string rather than the string itself.
            //
            pszW = pOFNW->lpstrFile;
            switch (pOFNA->nMaxFile)
            {
                case ( 3 ) :
                default :
                {
                    pOFNA->lpstrFile[2] = CHAR_NULL;

                    // fall thru...
                }
                case ( 2 ) :
                {
                    pOFNA->lpstrFile[1] = HIBYTE(*pszW);

                    // fall thru...
                }
                case ( 1 ) :
                {
                    pOFNA->lpstrFile[0] = LOBYTE(*pszW);

                    // fall thru...
                }
                case ( 0 ) :
                {
                    break;
                }
            }
        }
        else
        {
            LPWSTR pFileW = pOFNW->lpstrFile;
            DWORD cchFile = 0;

            // Find the length of string to be converted. This takes care of both single select (there will be only string)
            // and multiselect case (there will multiple strings with double null termination)
            while (*pFileW)
            {
                DWORD cch = lstrlenW(pFileW) +1;
                cchFile +=cch;
                pFileW += cch;
            }

            if (pOFNW->Flags & OFN_ALLOWMULTISELECT)
            {
                // for the double null terminator
                cchFile++;
            }
              
            // need to copy the whole buffer after the initial directory
            nRet =WideCharToMultiByte(CP_ACP,
                          0,
                          pOFNW->lpstrFile,
                          cchFile,
                          pOFNA->lpstrFile, pOFNA->nMaxFile,
                          NULL, NULL);

            if (nRet == 0)
            {
                return (FALSE);
            }

            if ((SHORT)pOFNW->nFileOffset > 0)
            {
                pOFNA->nFileOffset = (WORD) WideCharToMultiByte( CP_ACP,
                                                                 0,
                                                                 pOFNW->lpstrFile,
                                                                 pOFNW->nFileOffset,
                                                                 NULL,
                                                                 0,
                                                                 NULL,
                                                                 NULL );
            }
            else
            {
                pOFNA->nFileOffset = pOFNW->nFileOffset;
            }

            if ((SHORT)pOFNW->nFileExtension > 0)
            {
                pOFNA->nFileExtension = (WORD) WideCharToMultiByte( CP_ACP,
                                                                    0,
                                                                    pOFNW->lpstrFile,
                                                                    pOFNW->nFileExtension,
                                                                    NULL,
                                                                    0,
                                                                    NULL,
                                                                    NULL );
            }
            else
            {
                pOFNA->nFileExtension = pOFNW->nFileExtension;    
            }
        }
    }
    else
    {
        pOFNA->nFileOffset    = pOFNW->nFileOffset;
        pOFNA->nFileExtension = pOFNW->nFileExtension;

    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GenericGetFileNameA
//
////////////////////////////////////////////////////////////////////////////

BOOL GenericGetFileNameA(
    LPOPENFILENAMEA pOFNA,
    DLGPROC qfnDlgProc)
{
    LPOPENFILENAMEW pOFNW;
    BOOL bRet = FALSE;
    OFN_UNICODE_STRING usCustomFilter;
    OFN_ANSI_STRING asCustomFilter;
    DWORD cbLen;
    LPSTR pszA;
    DWORD cch;
    LPBYTE pStrMem = NULL;
    OPENFILEINFO OFI = {0};
        
    if (!pOFNA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

     //Set the Open File Version
    OFI.iVersion = OPENFILEVERSION;

    if (pOFNA->lStructSize == OPENFILENAME_SIZE_VERSION_400)
    {
        OFI.iVersion = OPENFILEVERSION_NT4;
    }

    //  we allow both sizes because we allocate a full size one anyway
    //  and we want to preserve the original structure for notifies
    if ((pOFNA->lStructSize != OPENFILENAME_SIZE_VERSION_400) &&
        (pOFNA->lStructSize != sizeof(OPENFILENAMEA))
       )
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pOFNW = (LPOPENFILENAMEW)LocalAlloc(LPTR, sizeof(OPENFILENAMEW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  Constant stuff.
    //
    pOFNW->lStructSize = sizeof(OPENFILENAMEW);
    pOFNW->hwndOwner = pOFNA->hwndOwner;
    pOFNW->hInstance = pOFNA->hInstance;
    pOFNW->lpfnHook = pOFNA->lpfnHook;

    //  it will always be a valid structsize at this point
    if (pOFNA->lStructSize != OPENFILENAME_SIZE_VERSION_400)
    {
        pOFNW->pvReserved = pOFNA->pvReserved;
        pOFNW->dwReserved = pOFNA->dwReserved;
        pOFNW->FlagsEx   = pOFNA->FlagsEx;
    }

    //
    //  Init TemplateName constant.
    //
    if (pOFNA->Flags & OFN_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pOFNA->lpTemplateName))
        {
            cbLen = lstrlenA(pOFNA->lpTemplateName) + 1;
            if (!(pOFNW->lpTemplateName = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                goto GenericExit;
            }
            else
            {
                SHAnsiToUnicode(pOFNA->lpTemplateName,(LPWSTR)pOFNW->lpTemplateName,cbLen);
            }
        }
        else
        {
            (DWORD_PTR)pOFNW->lpTemplateName = (DWORD_PTR)pOFNA->lpTemplateName;
        }
    }
    else
    {
        pOFNW->lpTemplateName = NULL;
    }

    //
    //  Initialize Initial Dir constant.
    //
    if (pOFNA->lpstrInitialDir)
    {
        cbLen = lstrlenA(pOFNA->lpstrInitialDir) + 1;
        if (!(pOFNW->lpstrInitialDir = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrInitialDir,(LPWSTR)pOFNW->lpstrInitialDir,cbLen);
        }
    }
    else
    {
        pOFNW->lpstrInitialDir = NULL;
    }

    //
    //  Initialize Title constant.
    //
    if (pOFNA->lpstrTitle)
    {
        cbLen = lstrlenA(pOFNA->lpstrTitle) + 1;
        if (!(pOFNW->lpstrTitle = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrTitle,(LPWSTR)pOFNW->lpstrTitle,cbLen );
        }
    }
    else
    {
        pOFNW->lpstrTitle = NULL;
    }

    //
    //  Initialize Def Ext constant.
    //
    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrDefExt,(LPWSTR)pOFNW->lpstrDefExt,cbLen );
        }
    }
    else
    {
        pOFNW->lpstrDefExt = NULL;
    }

    //
    //  Initialize Filter constant.  Note: 16-bit apps change this.
    //
    if (pOFNA->lpstrFilter)
    {
        pszA = (LPSTR)pOFNA->lpstrFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            //
            //  Pick up trailing nulls.
            //
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  Need to do cch + 1 in the Local Alloc rather than just cch.
        //  This is to make sure there is at least one extra null in the
        //  string so that if a filter does not have the second part of
        //  the pair, three nulls will be placed in the wide string.
        //
        //  Example:  "Print File (*.prn)\0\0\0"
        //
        if (!(pOFNW->lpstrFilter = (LPWSTR)LocalAlloc(LPTR, ((cch + 1) * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar(CP_ACP,
                     0,
                     pOFNA->lpstrFilter,
                     cch,
                     (LPWSTR)pOFNW->lpstrFilter, 
                     cch);
        }
    }
    else
    {
        pOFNW->lpstrFilter = NULL;
    }

    //
    //  Initialize File strings.
    //
    if (pOFNA->lpstrFile)
    {
        if (pOFNA->nMaxFile <= (DWORD)lstrlenA(pOFNA->lpstrFile))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            goto GenericExit;
        }
        pOFNW->nMaxFile = pOFNA->nMaxFile;

        if (!(pOFNW->lpstrFile = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFile * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFile = 0;
        pOFNW->lpstrFile = NULL;
    }

    //
    //  Initialize File Title strings.
    //
    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        //
        //  Calculate length of lpstrFileTitle.
        //
        pszA = pOFNA->lpstrFileTitle;
        cch = 0;
        try
        {
            while (*pszA++)
            {
                cch++;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            if (cch)
            {
                cch--;
            }
            (pOFNA->lpstrFileTitle)[cch] = CHAR_NULL;
        }

        if (pOFNA->nMaxFileTitle < cch)
        {
            //
            //  Override the incorrect length from the app.
            //  Make room for the null.
            //
            pOFNW->nMaxFileTitle = cch + 1;
        }
        else
        {
            pOFNW->nMaxFileTitle = pOFNA->nMaxFileTitle;
        }

        if (!(pOFNW->lpstrFileTitle = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFileTitle * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFileTitle = 0;
        pOFNW->lpstrFileTitle = NULL;
    }

    //
    //  Initialize custom filter strings.
    //
    if ((asCustomFilter.Buffer = pOFNA->lpstrCustomFilter))
    {
        pszA = pOFNA->lpstrCustomFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  JVert-inspired-wow-compatibility-hack-to-make-vbasic2.0-makeexe
        //  save-as-dialog-box-work-even-though-they-didn't-fill-in-
        //  the-whole-structure(nMaxCustFilter)-according-to-winhelp-spec fix
        //
        if (!(pOFNA->Flags & OFN_NOLONGNAMES))
        {
            if (((DWORD)cch >= pOFNA->nMaxCustFilter) ||
                (pOFNA->nMaxCustFilter < 40))
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
            asCustomFilter.Length = cch;
            asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
            pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        }
        else
        {
            asCustomFilter.Length = cch;
            if (pOFNA->nMaxCustFilter < cch)
            {
                asCustomFilter.MaximumLength = cch;
                pOFNW->nMaxCustFilter = cch;
            }
            else
            {
                asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
                pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
            }
        }
        usCustomFilter.MaximumLength = (asCustomFilter.MaximumLength + 1) * sizeof(WCHAR);
        usCustomFilter.Length = asCustomFilter.Length * sizeof(WCHAR);
    }
    else
    {
        pOFNW->nMaxCustFilter = usCustomFilter.MaximumLength = 0;
        pOFNW->lpstrCustomFilter = NULL;
    }

    if (usCustomFilter.MaximumLength > 0)
    {
        if (!(pStrMem = (LPBYTE)LocalAlloc(LPTR, usCustomFilter.MaximumLength)))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            pOFNW->lpstrCustomFilter = usCustomFilter.Buffer = (LPWSTR)pStrMem;
        }
    }
    else
    {
        pStrMem = NULL;
    }

    OFI.pOFN = pOFNW;
    OFI.pOFNA = pOFNA;
    OFI.pasCustomFilter = &asCustomFilter;
    OFI.pusCustomFilter = &usCustomFilter;
    OFI.ApiType = COMDLG_ANSI;

    //
    //  The following should always succeed.
    //
    if (!ThunkOpenFileNameA2W(&OFI))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        goto GenericExit;
    }

    bRet = GetFileName(&OFI, qfnDlgProc);
    if (g_bUserPressedCancel == FALSE)
    {
        ThunkOpenFileNameW2A(&OFI);
    }

GenericExit:

    if (pStrMem)
    {
        LocalFree(pStrMem);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFile))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFile);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFileTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFileTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFilter))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFilter);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrDefExt))
    {
        LocalFree((HLOCAL)pOFNW->lpstrDefExt);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrInitialDir))
    {
        LocalFree((HLOCAL)pOFNW->lpstrInitialDir);
    }

    if (!IS_INTRESOURCE(pOFNW->lpTemplateName))
    {
        LocalFree((HLOCAL)pOFNW->lpTemplateName);
    }

    LocalFree(pOFNW);

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strlenA
//
//  This is a strlen for ANSI string lists that have several strings that
//  are *separated* by a NULL char and are *terminated* by two NULL chars.
//
//  Returns length of string including all NULL *separators* but not the
//  2nd NULL *terminator*.  (ie. cat0dog00 would return length = 8)
//
////////////////////////////////////////////////////////////////////////////

int Multi_strlenA(
    LPCSTR str)
{
    int ctr = 0;

    if (str)
    {
        while (*str)
        {
            while (*str++)
            {
                ctr++;
            }
            ctr++;                // count the NULL separator
        }
    }

    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strcpyAtoW
//
//  This is a strcpy for string lists that have several strings that are
//  *separated* by a NULL char and are *terminated* by two NULL chars.
//  Returns FALSE if:
//    1. the wide buffer is determined to be too small
//    2. the ptr to either buffer is NULL
//  Returns TRUE if the copy was successful.
//
////////////////////////////////////////////////////////////////////////////

BOOL Multi_strcpyAtoW(
    LPWSTR pDestW,
    LPCSTR pSrcA,
    int cChars)
{
    int off = 0;
    int cb;

    if (!pSrcA || !pDestW)
    {
        return (FALSE);
    }

    cChars = max(cChars, (Multi_strlenA(pSrcA) + 1));

    if (LocalSize((HLOCAL)pDestW) < (cChars * sizeof(WCHAR)))
    {
        return (FALSE);
    }

    while (*pSrcA)
    {
        cb = lstrlenA(pSrcA) + 1;

        off += MultiByteToWideChar(CP_ACP,0,pSrcA,cb,pDestW + off, cb);
        pSrcA += cb;
    }

    pDestW[off] = L'\0';

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkMultiANSIStrToWIDE
//
//  Thunks an ANSI multi-string (a list of NULL *separated* strings with
//  two NULLs *terminating* the list) to the equivalent WIDE multi-string.
//
//  Note: If the original wide buffer is too small to contain the new list,
//        it will be free'd and a new wide buffer will be allocated.  If a
//        new wide buffer can't be allocated, the ptr to the original wide
//        buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkMultiANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    int size;
    HLOCAL hBufW;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    //
    //  First try to copy to the existing wide buffer since most of the time
    //  there will be no change to the buffer ptr anyway.
    //
    if (!(Multi_strcpyAtoW(pDestW, pSrcA, cChars)))
    {
        //
        //  If the wide buffer is too small (or NULL or invalid), allocate
        //  a bigger buffer.
        //
        size = max(cChars, (Multi_strlenA(pSrcA) + 1));
        cChars = size;

        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if ((Multi_strcpyAtoW((LPWSTR)hBufW, pSrcA, cChars)))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }

    return (pDestW);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkANSIStrToWIDE
//
//  Thunks an ANSI string to WIDE.
//
//  Note: If the original wide buffer is too small to contain the new
//        string, it will be free'd and a new wide buffer will be allocated.
//        If a new wide buffer can't be allocated, the ptr to the original
//        wide buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    HLOCAL hBufW;
    int size;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    size = max(cChars, (lstrlenA(pSrcA) + 1));
    cChars = size;

    //
    //  If the wide buffer is too small (or NULL or invalid), allocate a
    //  bigger buffer.
    //
    if (LocalSize((HLOCAL)pDestW) < (size * sizeof(WCHAR)))
    {
        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if (SHAnsiToUnicode(pSrcA,(LPWSTR)hBufW,cChars ))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }
    else
    {
        //
        //  Just use the original wide buffer.
        //
        SHAnsiToUnicode(pSrcA,pDestW, cChars);
    }

    return (pDestW);
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_OFN_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the OPENFILENAME structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_OFN_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    POPENFILEINFO pOFI;

    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN && pOFI->pOFNA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkOpenFileNameA2W(pOFI);
            }
            else
            {
                ThunkOpenFileNameW2A(pOFI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\filenew.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filenew.cpp

Abstract:

    This module implements the Win32 explorer fileopen dialogs.

--*/
//
//  Include Files.
//

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "fileopen.h"
#include "d32tlog.h"
#include "filenew.h"
#include "filemru.h"
#include "util.h"
#include "uxtheme.h"

#ifndef ASSERT
#define ASSERT Assert
#endif



//
//  Constant Declarations.
//

#define IDOI_SHARE           1

#define CDM_SETSAVEBUTTON    (CDM_LAST + 100)
#define CDM_FSNOTIFY         (CDM_LAST + 101)
#define CDM_SELCHANGE        (CDM_LAST + 102)

#define TIMER_FSCHANGE       100

#define NODE_DESKTOP         0
#define NODE_DRIVES          1

#define DEREFMACRO(x)        x

#define FILE_PADDING         10

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

#define MAXDOSFILENAMELEN    (12 + 1)     // 8.3 filename + 1 for NULL

//
//  IShellView::MenuHelp flags.
//
#define MH_DONE              0x0001
//      MH_LONGHELP
#define MH_MERGEITEM         0x0004
#define MH_SYSITEM           0x0008
#define MH_POPUP             0x0010
#define MH_TOOLBAR           0x0020
#define MH_TOOLTIP           0x0040

//
//  IShellView::MenuHelp return values.
//
#define MH_NOTHANDLED        0
#define MH_STRINGFILLED      1
#define MH_ALLHANDLED        2

#define MYCBN_DRAW           0x8000
#define MIN_DEFEXT_LEN       4

#define MAX_DRIVELIST_STRING_LEN  (64 + 4)


#define REGSTR_PATH_PLACESBAR TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\comdlg32\\Placesbar")
#define MAXPLACESBARITEMS   5

//
//  Macro Definitions.
//

#define IsServer(psz)        (IsUNC(psz) && !StrChr((psz) + 2, CHAR_BSLASH))

#define LPIDL_GetIDList(_pida,n) \
    (LPCITEMIDLIST)(((LPBYTE)(_pida)) + (_pida)->aoffset[n])

#define RECTWIDTH(_rc)       ((_rc).right - (_rc).left)
#define RECTHEIGHT(_rc)      ((_rc).bottom - (_rc).top)

#define IsVisible(_hwnd)     (GetWindowLong(_hwnd, GWL_STYLE) & WS_VISIBLE)

#define HwndToBrowser(_hwnd) (CFileOpenBrowser *)GetWindowLongPtr(_hwnd, DWLP_USER)
#define StoreBrowser(_hwnd, _pbrs) \
    SetWindowLongPtr(_hwnd, DWLP_USER, (LONG_PTR)_pbrs);


//
//  Typedef Declarations.
//

typedef struct _OFNINITINFO
{
    LPOPENFILEINFO  lpOFI;
    BOOL            bSave;
    BOOL            bEnableSizing;
    HRESULT         hrOleInit;
} OFNINITINFO, *LPOFNINITINFO;


#define VC_NEWFOLDER    0
#define VC_VIEWLIST     1
#define VC_VIEWDETAILS  2


//
//  Global Variables.
//

HWND gp_hwndActiveOpen = NULL;
HACCEL gp_haccOpen = NULL;
HACCEL gp_haccOpenView = NULL;
HHOOK gp_hHook = NULL;
int gp_nHookRef = -1;
UINT gp_uQueryCancelAutoPlay = 0;



static int g_cxSmIcon = 0 ;
static int g_cySmIcon = 0 ;
static int g_cxGrip;
static int g_cyGrip;

const LPCSTR c_szCommandsA[] =
{
    CMDSTR_NEWFOLDERA,
    CMDSTR_VIEWLISTA,
    CMDSTR_VIEWDETAILSA,
};

const LPCWSTR c_szCommandsW[] =
{
    CMDSTR_NEWFOLDERW,
    CMDSTR_VIEWLISTW,
    CMDSTR_VIEWDETAILSW,
};


extern "C"
{ 
    extern RECT g_rcDlg;
}




//
//  Function Prototypes.
//

LRESULT CALLBACK
OKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

void
GetControlsArea(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    POINT *pPtSize,
    LPINT pTop);

BOOL_PTR CALLBACK
OpenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void
StoreLengthInString(
    LPTSTR lpStr,
    UINT cchLen,
    UINT cchStore);



//
//  Context Help IDs.
//

DWORD aFileOpenHelpIDs[] =
{
    stc2,    IDH_OPEN_FILETYPE,   // The positions of these array elements
    cmb1,    IDH_OPEN_FILETYPE,   // shouldn't be changed without updating
    stc4,    IDH_OPEN_LOCATION,   // InitSaveAsControls().
    cmb2,    IDH_OPEN_LOCATION,
    stc1,    IDH_OPEN_FILES32,
    lst2,    IDH_OPEN_FILES32,    // defview
    stc3,    IDH_OPEN_FILENAME,
    edt1,    IDH_OPEN_FILENAME,
    cmb13,   IDH_OPEN_FILENAME,
    chx1,    IDH_OPEN_READONLY,
    IDOK,    IDH_OPEN_BUTTON,
    ctl1,    IDH_OPEN_SHORTCUT_BAR,
    0, 0
};

DWORD aFileSaveHelpIDs[] =
{
    stc2,    IDH_SAVE_FILETYPE,   // The positions of these array elements
    cmb1,    IDH_SAVE_FILETYPE,   // shouldn't be changed without updating
    stc4,    IDH_OPEN_LOCATION,   // InitSaveAsControls().
    cmb2,    IDH_OPEN_LOCATION,
    stc1,    IDH_OPEN_FILES32,
    lst2,    IDH_OPEN_FILES32,    // defview
    stc3,    IDH_OPEN_FILENAME,
    edt1,    IDH_OPEN_FILENAME,
    cmb13,   IDH_OPEN_FILENAME,
    chx1,    IDH_OPEN_READONLY,
    IDOK,    IDH_SAVE_BUTTON,
    ctl1,    IDH_OPEN_SHORTCUT_BAR,
    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  CD_SendShareMsg
//
////////////////////////////////////////////////////////////////////////////

WORD CD_SendShareMsg(
    HWND hwnd,
    LPTSTR szFile,
    UINT ApiType)
{
    if (ApiType == COMDLG_ANSI)
    {
        CHAR szFileA[MAX_PATH + 1];

        SHUnicodeToAnsi(szFile,szFileA,SIZECHARS(szFileA));

        return ((WORD)SendMessage(hwnd,
                                    msgSHAREVIOLATIONA,
                                    0,
                                    (LONG_PTR)(LPSTR)(szFileA)));
    }
    else
    {
        return ((WORD)SendMessage(hwnd,
                                    msgSHAREVIOLATIONW,
                                    0,
                                    (LONG_PTR)(LPTSTR)(szFile)));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendHelpMsg
//
////////////////////////////////////////////////////////////////////////////

VOID CD_SendHelpMsg(
    LPOPENFILENAME pOFN,
    HWND hwndDlg,
    UINT ApiType)
{
    if (ApiType == COMDLG_ANSI)
    {
        if (msgHELPA && pOFN->hwndOwner)
        {
            SendMessage(pOFN->hwndOwner,
                         msgHELPA,
                         (WPARAM)hwndDlg,
                         (LPARAM)pOFN);
        }
    }
    else
    {
        if (msgHELPW && pOFN->hwndOwner)
        {
            SendMessage(pOFN->hwndOwner,
                         msgHELPW,
                         (WPARAM)hwndDlg,
                         (LPARAM)pOFN);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendOKMsg
//
////////////////////////////////////////////////////////////////////////////

LRESULT CD_SendOKMsg(
    HWND hwnd,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    LRESULT Result;

    if (pOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameW2A(pOFI);
        Result = SendMessage(hwnd, msgFILEOKA, 0, (LPARAM)(pOFI->pOFNA));

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);
    }
    else
    {
        Result = SendMessage(hwnd, msgFILEOKW, 0, (LPARAM)(pOFN));
    }

    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendLBChangeMsg
//
////////////////////////////////////////////////////////////////////////////

LRESULT CD_SendLBChangeMsg(
    HWND hwnd,
    int Id,
    short Index,
    short Code,
    UINT ApiType)
{
    if (ApiType == COMDLG_ANSI)
    {
        return (SendMessage(hwnd, msgLBCHANGEA, Id, MAKELONG(Index, Code)));
    }
    else
    {
        return (SendMessage(hwnd, msgLBCHANGEW, Id, MAKELONG(Index, Code)));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Macro calls to SendOFNotify
//
////////////////////////////////////////////////////////////////////////////

#define CD_SendShareNotify(_hwndTo, _hwndFrom, _szFile, _pofn, _pofi) \
    (WORD)SendOFNotify(_hwndTo, _hwndFrom, CDN_SHAREVIOLATION, _szFile, _pofn, _pofi)

#define CD_SendHelpNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_HELP, NULL, _pofn, _pofi)

#define CD_SendOKNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_FILEOK, NULL, _pofn, _pofi)

#define CD_SendTypeChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_TYPECHANGE, NULL, _pofn, _pofi)

#define CD_SendInitDoneNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_INITDONE, NULL, _pofn, _pofi)

#define CD_SendSelChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_SELCHANGE, NULL, _pofn, _pofi)

#define CD_SendFolderChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_FOLDERCHANGE, NULL, _pofn, _pofi)

#define CD_SendIncludeItemNotify(_hwndTo, _hwndFrom, _psf, _pidl, _pofn, _pofi) \
    SendOFNotifyEx(_hwndTo, _hwndFrom, CDN_INCLUDEITEM, (void *)_psf, (void *)_pidl, _pofn, _pofi)



////////////////////////////////////////////////////////////////////////////
//
//  SendOFNotifyEx
//
////////////////////////////////////////////////////////////////////////////

LRESULT SendOFNotifyEx(
    HWND hwndTo,
    HWND hwndFrom,
    UINT code,
    void * psf,
    void * pidl,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    OFNOTIFYEX ofnex;

    if (pOFI->ApiType == COMDLG_ANSI)
    {
        OFNOTIFYEXA ofnexA;
        LRESULT Result;

        ofnexA.psf  = psf;
        ofnexA.pidl = pidl;

        //
        //  Convert the OFN from Unicode to Ansi.
        //
        ThunkOpenFileNameW2A(pOFI);

        ofnexA.lpOFN = pOFI->pOFNA;

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(WOWGetNotifySize(code) == sizeof(OFNOTIFYEXA));
#endif
        Result = SendNotify(hwndTo, hwndFrom, code, &ofnexA.hdr);

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);

        return (Result);
    }
    else
    {
        ofnex.psf   = psf;
        ofnex.pidl  = pidl;
        ofnex.lpOFN = pOFN;

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(WOWGetNotifySize(code) == sizeof(OFNOTIFYEXW));
#endif
        return (SendNotify(hwndTo, hwndFrom, code, &ofnex.hdr));
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SendOFNotify
//
////////////////////////////////////////////////////////////////////////////

LRESULT SendOFNotify(
    HWND hwndTo,
    HWND hwndFrom,
    UINT code,
    LPTSTR szFile,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    OFNOTIFY ofn;

    if (pOFI->ApiType == COMDLG_ANSI)
    {
        OFNOTIFYA ofnA;
        LRESULT Result;

        //
        //  Convert the file name from Unicode to Ansi.
        //
        if (szFile)
        {
            CHAR szFileA[MAX_PATH + 1];

            SHUnicodeToAnsi(szFile,szFileA,SIZECHARS(szFileA));

            ofnA.pszFile = szFileA;
        }
        else
        {
            ofnA.pszFile = NULL;
        }

        //
        //  Convert the OFN from Unicode to Ansi.
        //
        ThunkOpenFileNameW2A(pOFI);

        ofnA.lpOFN = pOFI->pOFNA;

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(WOWGetNotifySize(code) == sizeof(OFNOTIFYA));
#endif
        Result = SendNotify(hwndTo, hwndFrom, code, &ofnA.hdr);

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);

        return (Result);
    }
    else
    {
        ofn.pszFile = szFile;
        ofn.lpOFN   = pOFN;

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(WOWGetNotifySize(code) == sizeof(OFNOTIFY));
#endif
        return (SendNotify(hwndTo, hwndFrom, code, &ofn.hdr));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPMEM::Resize
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPMEM::Resize(
    UINT cb)
{
    UINT uOldSize = m_uSize;

    m_uSize = cb;

    if (!cb)
    {
        if (m_pMem)
        {
            LocalFree(m_pMem);
            m_pMem = NULL;
        }

        return TRUE;
    }

    if (!m_pMem)
    {
        m_pMem = LocalAlloc(LPTR, cb);
        return (m_pMem != NULL);
    }

    void * pTemp = LocalReAlloc(m_pMem, cb, LHND);

    if (pTemp)
    {
        m_pMem = pTemp;
        return TRUE;
    }

    m_uSize = uOldSize;
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR::StrCpy
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPSTR::StrCpy(
    LPCTSTR pszText)
{
    if (!pszText)
    {
        StrSize(0);
        return TRUE;
    }

    UINT uNewSize = lstrlen(pszText) + 1;

    if (!StrSize(uNewSize))
    {
        return FALSE;
    }

    lstrcpy(*this, pszText);

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR::StrCat
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPSTR::StrCat(
    LPCTSTR pszText)
{
    if (!(LPTSTR)*this)
    {
        //
        //  This should 0 init.
        //
        if (!StrSize(MAX_PATH))
        {
            return FALSE;
        }
    }

    UINT uNewSize = lstrlen(*this) + lstrlen(pszText) + 1;

    if (m_uSize < uNewSize * sizeof(TCHAR))
    {
        //
        //  Add on some more so we do not ReAlloc too often.
        //
        uNewSize += MAX_PATH;

        if (!StrSize(uNewSize))
        {
            return FALSE;
        }
    }

    lstrcat(*this, pszText);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsVolumeLFN
//
////////////////////////////////////////////////////////////////////////////
BOOL IsVolumeLFN(LPCTSTR pszRoot)
{
    DWORD dwVolumeSerialNumber;
    DWORD dwMaximumComponentLength;
    DWORD dwFileSystemFlags;

    //
    //  We need to find out what kind of a drive we are running
    //  on in order to determine if spaces are valid in a filename
    //  or not.
    //
    if (GetVolumeInformation(pszRoot,
                              NULL,
                              0,
                              &dwVolumeSerialNumber,
                              &dwMaximumComponentLength,
                              &dwFileSystemFlags,
                              NULL,
                              0))
    {
        if (dwMaximumComponentLength != (MAXDOSFILENAMELEN - 1))
            return TRUE;
    }

    return FALSE;

}



////////////////////////////////////////////////////////////////////////////
//
//  CDMessageBox
//
////////////////////////////////////////////////////////////////////////////

int _cdecl CDMessageBox(
    HWND hwndParent,
    UINT idText,
    UINT uFlags,
    ...)
{
    TCHAR szText[MAX_PATH + WARNINGMSGLENGTH];
    TCHAR szTitle[WARNINGMSGLENGTH];
    va_list ArgList;

    CDLoadString(g_hinst, idText, szTitle, ARRAYSIZE(szTitle));
    va_start(ArgList, uFlags);
    wvsprintf(szText, szTitle, ArgList);
    va_end(ArgList);

    GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle));

    return (MessageBox(hwndParent, szText, szTitle, uFlags));
}


int OFErrFromHresult(HRESULT hr)
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        return OF_FILENOTFOUND;

    case E_ACCESSDENIED:
        return OF_ACCESSDENIED;

    default:
        return -1;
    }
}


BOOL CFileOpenBrowser::_SaveAccessDenied(LPCTSTR pszFile)
{
    if (CDMessageBox(_hwndDlg, iszDirSaveAccessDenied, MB_YESNO | MB_ICONEXCLAMATION, pszFile) == IDYES)
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetFolderLocation(_hwndDlg, CSIDL_PERSONAL, NULL, 0, &pidl)))
        {
            JumpToIDList(pidl);
            ILFree(pidl);
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  InvalidFileWarningNew
//
////////////////////////////////////////////////////////////////////////////

VOID InvalidFileWarningNew(
    HWND hWnd,
    LPCTSTR pszFile,
    int wErrCode)
    
{
    int isz;
    BOOL bDriveLetter = FALSE;

    switch (wErrCode)
    {
        case (OF_ACCESSDENIED) :
        {
            isz = iszFileAccessDenied;
            break;
        }
        case (ERROR_NOT_READY) :
        {
            isz = iszNoDiskInDrive;
            bDriveLetter = TRUE;
            break;
        }
        case (OF_NODRIVE) :
        {
            isz = iszDriveDoesNotExist;
            bDriveLetter = TRUE;
            break;
        }
        case (OF_NOFILEHANDLES) :
        {
            isz = iszNoFileHandles;
            break;
        }
        case (OF_PATHNOTFOUND) :
        {
            isz = iszPathNotFound;
            break;
        }
        case (OF_FILENOTFOUND) :
        {
            isz = iszFileNotFound;
            break;
        }
        case (OF_DISKFULL) :
        case (OF_DISKFULL2) :
        {
            isz = iszDiskFull;
            bDriveLetter = TRUE;
            break;
        }
        case (OF_WRITEPROTECTION) :
        {
            isz = iszWriteProtection;
            bDriveLetter = TRUE;
            break;
        }
        case (OF_SHARINGVIOLATION) :
        {
            isz = iszSharingViolation;
            break;
        }
        case (OF_CREATENOMODIFY) :
        {
            isz = iszCreateNoModify;
            break;
        }
        case (OF_NETACCESSDENIED) :
        {
            isz = iszNetworkAccessDenied;
            break;
        }
        case (OF_PORTNAME) :
        {
            isz = iszPortName;
            break;
        }
        case (OF_LAZYREADONLY) :
        {
            isz = iszReadOnly;
            break;
        }
        case (OF_INT24FAILURE) :
        {
            isz = iszInt24Error;
            break;
        }
        default :
        {
            isz = iszInvalidFileName;
            break;
        }
    }

    if (bDriveLetter)
    {
        CDMessageBox(hWnd, isz, MB_OK | MB_ICONEXCLAMATION, *pszFile);
    }
    else
    {
        CDMessageBox(hWnd, isz, MB_OK | MB_ICONEXCLAMATION, pszFile);
    }

    if (isz == iszInvalidFileName)
    {
        CFileOpenBrowser *pDlgStruct = HwndToBrowser(hWnd);

        if (pDlgStruct && pDlgStruct->_bUseCombo)
        {
            PostMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, cmb13), 1);
        }
        else
        {
            PostMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, edt1), 1);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetControlRect
//
////////////////////////////////////////////////////////////////////////////

void GetControlRect(
    HWND hwndDlg,
    UINT idOldCtrl,
    LPRECT lprc)
{
    HWND hwndOldCtrl = GetDlgItem(hwndDlg, idOldCtrl);

    GetWindowRect(hwndOldCtrl, lprc);
    MapWindowRect(HWND_DESKTOP, hwndDlg, lprc);
}


////////////////////////////////////////////////////////////////////////////
//
//  HideControl
//
//  Subroutine to hide a dialog control.
//
//  WARNING WARNING WARNING:  Some code in the new look depends on hidden
//  controls remaining where they originally were, even when disabled,
//  because they're templates for where to create new controls (the toolbar,
//  or the main list).  Therefore, HideControl() must not MOVE the control
//  being hidden - it may only hide and disable it.  If this needs to change,
//  there must be a separate hiding subroutine used for template controls.
//
////////////////////////////////////////////////////////////////////////////

void HideControl(
    HWND hwndDlg,
    UINT idControl)
{
    HWND hCtrl = ::GetDlgItem(hwndDlg, idControl);

    ::ShowWindow(hCtrl, SW_HIDE);
    ::EnableWindow(hCtrl, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectEditText
//
////////////////////////////////////////////////////////////////////////////

void SelectEditText(
    HWND hwndDlg)
{
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hwndDlg);

    if (pDlgStruct && pDlgStruct->_bUseCombo)
    {
        HWND hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        Edit_SetSel(hwndEdit, 0, -1);
    }
    else
    {
        Edit_SetSel(GetDlgItem(hwndDlg, edt1), 0, -1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPathFromLocation
//
////////////////////////////////////////////////////////////////////////////

BOOL GetPathFromLocation(
    MYLISTBOXITEM *pLocation,
    LPTSTR pszBuf)
{
    BOOL fRet = FALSE;

    //
    //  Zero out the return buffer in case of error.
    //
    *pszBuf = 0;

    //
    //  Try normal channels first.
    //

    //See if the IShellFolder we have is a shorcut if so get path from shortcut
    if (pLocation->psfSub)
    {
        IShellLink *psl;

        if (SUCCEEDED(pLocation->psfSub->QueryInterface(IID_PPV_ARG(IShellLink, &psl))))
        {
            fRet = SUCCEEDED(psl->GetPath(pszBuf, MAX_PATH, 0, 0));
            psl->Release();
        }
    }

    if (!fRet)
        fRet = SHGetPathFromIDList(pLocation->pidlFull, pszBuf);

    if (!fRet)
    {
        //
        //  Call GetDisplayNameOf with empty pidl.
        //
        if (pLocation->psfSub)
        {
            STRRET str;
            ITEMIDLIST idNull = {0};

            if (SUCCEEDED(pLocation->psfSub->GetDisplayNameOf(&idNull,
                                                               SHGDN_FORPARSING,
                                                               &str)))
            {
                fRet = TRUE;
                StrRetToBuf(&str, &idNull, pszBuf, MAX_PATH);
            }
        }
    }

    //
    //  Return the result.
    //
    return (fRet);
}

inline _IsSaveContainer(SFGAOF f)
{
    return ((f & (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR)) == (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR));
}

inline _IsOpenContainer(SFGAOF f)
{
    return ((f & SFGAO_FOLDER) && (f & (SFGAO_STORAGEANCESTOR | SFGAO_FILESYSANCESTOR)));
}

inline _IncludeSaveItem(SFGAOF f)
{
    return (f & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM));
}

inline _IncludeOpenItem(SFGAOF f)
{
    return (f & (SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STREAM | SFGAO_FILESYSTEM));
}

inline _IsFolderShortcut(SFGAOF f)
{
    return ((f & (SFGAO_FOLDER | SFGAO_LINK)) == (SFGAO_FOLDER | SFGAO_LINK));
}

inline _IsStream(SFGAOF f)
{
    return ((f & SFGAO_STREAM) || ((f & SFGAO_FILESYSTEM) && !(f & SFGAO_FILESYSANCESTOR)));
}

inline _IsCollection(SFGAOF f)
{
    return ((f & (SFGAO_STREAM | SFGAO_FOLDER)) == (SFGAO_STREAM | SFGAO_FOLDER));
}


#define MLBI_PERMANENT        0x0001
#define MLBI_PSFFROMPARENT    0x0002

MYLISTBOXITEM::MYLISTBOXITEM() : _cRef(1)
{
}

// This is a special Case Init Function for Initializing Recent Files folder at the top 
// of namespace in the look in control.
BOOL MYLISTBOXITEM::Init(
        HWND hwndCmb,
        IShellFolder *psf,
        LPCITEMIDLIST pidl,
        DWORD c,
        DWORD f,
        DWORD dwAttribs,
        int  iImg,
        int  iSelImg)
{
    _hwndCmb = hwndCmb;
    cIndent = c;
    dwFlags = f;
    pidlThis = ILClone(pidl);
    pidlFull =  ILClone(pidl);
    psfSub = psf;
    psfSub->AddRef();
    dwAttrs = dwAttribs;
    iImage = iImg;
    iSelectedImage = iSelImg;
    return TRUE;
}

BOOL MYLISTBOXITEM::Init(
        HWND hwndCmb,
        MYLISTBOXITEM *pParentItem,
        IShellFolder *psf,
        LPCITEMIDLIST pidl,
        DWORD c,
        DWORD f,
        IShellTaskScheduler* pScheduler)
{

    if (psf == NULL)
    {
        // Invalid parameter passed.
        return FALSE;
    }

    _hwndCmb = hwndCmb;

    cIndent = c;
    dwFlags = f;

    pidlThis = ILClone(pidl);
    if (pParentItem == NULL)
    {
        pidlFull = ILClone(pidl);
    }
    else
    {
        pidlFull = ILCombine(pParentItem->pidlFull, pidl);
    }

    if (pidlThis == NULL || pidlFull == NULL)
    {
        psfSub = NULL;
    }

    if (dwFlags & MLBI_PSFFROMPARENT)
    {
        psfParent = psf;
    }
    else
    {
        psfSub = psf;
    }
    psf->AddRef();

    dwAttrs = SHGetAttributes(psf, pidl, SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STREAM | SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_SHARE);

    AddRef();
    if (E_PENDING != SHMapIDListToImageListIndexAsync(pScheduler, psf, pidl, 0, 
                                            _AsyncIconTaskCallback, this, NULL, &iImage, &iSelectedImage))
    {
        Release();
    }
 
    return TRUE;
}

ULONG MYLISTBOXITEM::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG MYLISTBOXITEM::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

MYLISTBOXITEM::~MYLISTBOXITEM()
{
    if (psfSub != NULL)
    {
        psfSub->Release();
    }

    if (psfParent != NULL)
    {
        psfParent->Release();
    }

    if (pidlThis != NULL)
    {
        SHFree(pidlThis);
    }

    if (pidlFull != NULL)
    {
        SHFree(pidlFull);
    }
}

void MYLISTBOXITEM::_AsyncIconTaskCallback(LPCITEMIDLIST pidl, void * pvData, 
                                           void * pvHint, INT iIconIndex, INT iOpenIconIndex)
{
    MYLISTBOXITEM *plbItem = (MYLISTBOXITEM *)pvData;

    plbItem->iImage = iIconIndex;
    plbItem->iSelectedImage = iOpenIconIndex;

    // Make sure the combobox redraws.
    if (plbItem->_hwndCmb)
    {
        RECT rc;
        if (GetClientRect(plbItem->_hwndCmb, &rc))
        {
            InvalidateRect(plbItem->_hwndCmb, &rc, FALSE);
        }
    }

    plbItem->Release();
}

BOOL IsContainer(
    IShellFolder *psf,
    LPCITEMIDLIST pidl)
{
    return _IsOpenContainer(SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_STORAGEANCESTOR | SFGAO_FILESYSANCESTOR));
}

BOOL IsLink(
    IShellFolder *psf,
    LPCITEMIDLIST pidl)
{
    return SHGetAttributes(psf, pidl, SFGAO_LINK);
}

IShellFolder *MYLISTBOXITEM::GetShellFolder()
{
    if (!psfSub)
    {
        HRESULT hr;

        if (ILIsEmpty(pidlThis))    // Some caller passes an empty pidl
            hr = psfParent->QueryInterface(IID_PPV_ARG(IShellFolder, &psfSub));
        else
            hr = psfParent->BindToObject(pidlThis, NULL, IID_PPV_ARG(IShellFolder, &psfSub));

        if (FAILED(hr))
        {
            psfSub = NULL;
        }
        else
        {
            psfParent->Release();
            psfParent = NULL;
        }
    }

    return (psfSub);
}


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM::SwitchCurrentDirectory
//
////////////////////////////////////////////////////////////////////////////

void MYLISTBOXITEM::SwitchCurrentDirectory(
    ICurrentWorkingDirectory * pcwd)
{
    TCHAR szDir[MAX_PATH + 1];

    if (!pidlFull)
    {
        SHGetSpecialFolderPath(NULL, szDir, CSIDL_DESKTOPDIRECTORY, FALSE);
    }
    else
    {
        GetPathFromLocation(this, szDir);
    }

    if (szDir[0])
    {
        SetCurrentDirectory(szDir);

        //
        //  Let AutoComplete know our Current Working Directory.
        //
        if (pcwd)
            pcwd->SetDirectory(szDir);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ShouldIncludeObject
//
////////////////////////////////////////////////////////////////////////////

BOOL ShouldIncludeObject(
    CFileOpenBrowser *that,
    LPSHELLFOLDER psfParent,
    LPCITEMIDLIST pidl,
    DWORD dwFlags)
{
    BOOL fInclude = FALSE;
    DWORD dwAttrs = SHGetAttributes(psfParent, pidl, SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STREAM | SFGAO_FILESYSTEM);
    if (dwAttrs)
    {
        if ((dwFlags & OFN_ENABLEINCLUDENOTIFY) && that)
        {
            fInclude = BOOLFROMPTR(CD_SendIncludeItemNotify(that->_hSubDlg,
                                                        that->_hwndDlg,
                                                        psfParent,
                                                        pidl,
                                                        that->_pOFN,
                                                        that->_pOFI));
        }

        if (!fInclude)
        {
            fInclude = that->_bSave ? _IncludeSaveItem(dwAttrs) : _IncludeOpenItem(dwAttrs);
        }
    }
    return (fInclude);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnableFileMRU
//
//
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::EnableFileMRU(BOOL fEnable)
{

    HWND hwnd = NULL; 
    if (fEnable)
    {
        HWND hwndCombo;
        //Make sure combobox is there
        hwndCombo = GetDlgItem(_hwndDlg, cmb13);

        if (hwndCombo)
        {
            // if we are using the combobox then remove the edit box
            _bUseCombo = TRUE;
            SetFocus(hwndCombo);
            hwnd = GetDlgItem(_hwndDlg,edt1);
        }
        else
        {
            goto UseEdit;
        }


    }
    else
    {
UseEdit:
        //We are not going to use  combobox.
        _bUseCombo  = FALSE;
    
        //SetFocus to the edit window
        SetFocus(GetDlgItem(_hwndDlg,edt1));
  
        //Destroy the combo box
        hwnd = GetDlgItem(_hwndDlg, cmb13);

    }
    
    if (hwnd)
    {
        DestroyWindow(hwnd);
    }

}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreateToolbar
//
//  CreateToolbar member function.
//      creates and initializes the places bar  in the dialog
//
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::CreateToolbar()
{

   TBBUTTON atbButtons[] =
   {
       { 0,                 IDC_BACK,                        0,    BTNS_BUTTON,          { 0, 0 }, 0, -1 },
       { VIEW_PARENTFOLDER, IDC_PARENT,        TBSTATE_ENABLED,    BTNS_BUTTON,          { 0, 0 }, 0, -1 },
       { VIEW_NEWFOLDER,    IDC_NEWFOLDER,     TBSTATE_ENABLED,    BTNS_BUTTON,          { 0, 0 }, 0, -1 },
       { VIEW_LIST,         IDC_VIEWMENU,      TBSTATE_ENABLED,    BTNS_WHOLEDROPDOWN,   { 0, 0 }, 0, -1 },
   };

   TBBUTTON atbButtonsNT4[] =
   {
       { 0, 0, 0, BTNS_SEP, { 0, 0 }, 0, 0 },
       { VIEW_PARENTFOLDER, IDC_PARENT, TBSTATE_ENABLED, BTNS_BUTTON, { 0, 0 }, 0, -1 },
       { 0, 0, 0, BTNS_SEP, { 0, 0 }, 0, 0 },
       { VIEW_NEWFOLDER, IDC_NEWFOLDER, TBSTATE_ENABLED, BTNS_BUTTON, { 0, 0 }, 0, -1 },
       { 0, 0, 0, BTNS_SEP, { 0, 0 }, 0, 0 },
       { VIEW_LIST,    IDC_VIEWLIST,    TBSTATE_ENABLED | TBSTATE_CHECKED, BTNS_CHECKGROUP, { 0, 0 }, 0, -1 },
       { VIEW_DETAILS, IDC_VIEWDETAILS, TBSTATE_ENABLED,                   BTNS_CHECKGROUP, { 0, 0 }, 0, -1 }
   };

   LPTBBUTTON lpButton = atbButtons;
   int iNumButtons = ARRAYSIZE(atbButtons);
   RECT rcToolbar;

   BOOL bBogusCtrlID = SHGetAppCompatFlags(ACF_FILEOPENBOGUSCTRLID) & ACF_FILEOPENBOGUSCTRLID;

   DWORD dwStyle = WS_TABSTOP | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | WS_CHILD | CCS_NORESIZE |WS_GROUP | CCS_NODIVIDER;

   // If app wants toolbar to have bogus ctrl ID, make it not a tabstop.
   if (bBogusCtrlID)
       dwStyle &= ~WS_TABSTOP;

   BOOL bAppHack =  (CDGetAppCompatFlags() & CDACF_NT40TOOLBAR) ? TRUE : FALSE;

    if (bAppHack)
    {
        lpButton = atbButtonsNT4;
        iNumButtons =ARRAYSIZE(atbButtonsNT4);
        dwStyle &= ~TBSTYLE_FLAT;
    }

    GetControlRect(_hwndDlg, stc1, &rcToolbar);

    _hwndToolbar = CreateToolbarEx(_hwndDlg,
                                   dwStyle,
                                   // stc1: use static text ctrlID
                                   // For apps that expect the old bad way, use IDOK.
                                   bBogusCtrlID ? IDOK : stc1,
                                   12,
                                   HINST_COMMCTRL,
                                   IDB_VIEW_SMALL_COLOR,
                                   lpButton,
                                   iNumButtons,
                                   0,
                                   0,
                                   0,
                                   0,
                                   sizeof(TBBUTTON));
    if (_hwndToolbar)
    {
        TBADDBITMAP ab;

        SendMessage(_hwndToolbar, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        //Documentation says that we need to send TB_BUTTONSTRUCTSIZE before we add bitmaps
        SendMessage(_hwndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), (LPARAM)0);
        
        SendMessage(_hwndToolbar,  TB_SETMAXTEXTROWS, (WPARAM)0, (LPARAM)0);

        if (!bAppHack)
        {
            if (!IsRestricted(REST_NOBACKBUTTON))
            {
                //Add the back/forward navigation buttons
                ab.hInst = HINST_COMMCTRL;
                ab.nID   = IDB_HIST_SMALL_COLOR;

                int iIndex = (int) SendMessage(_hwndToolbar, TB_ADDBITMAP, 5, (LPARAM)&ab);

                //Now set the image index for back button
                TBBUTTONINFO tbbi;
                tbbi.cbSize = sizeof(TBBUTTONINFO);
                tbbi.dwMask = TBIF_IMAGE | TBIF_BYINDEX;
                SendMessage(_hwndToolbar, TB_GETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
                tbbi.iImage =  iIndex + HIST_BACK;
                SendMessage(_hwndToolbar, TB_SETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
            }
            else
            {
                //Back button is restricted. Delete the back button from the toolbar
                SendMessage(_hwndToolbar, TB_DELETEBUTTON, (WPARAM)0, (LPARAM)0);
            }
        
        }

        ::SetWindowPos(_hwndToolbar,
                        // Place it after its static control (unless app expects old way)
                        bBogusCtrlID ? NULL : GetDlgItem(_hwndDlg, stc1),
                        rcToolbar.left,
                        rcToolbar.top,
                        rcToolbar.right - rcToolbar.left,
                        rcToolbar.bottom - rcToolbar.top,
                        SWP_NOACTIVATE | SWP_SHOWWINDOW | (bBogusCtrlID ? SWP_NOZORDER : 0));
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_GetPBItemFromCSIDL(DWORD csidl, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
//       Gets a SHFileInfo and pidl for a CSIDL which is used in the places bar
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_GetPBItemFromCSIDL(DWORD csidl, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
{
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, ppidl)))
    {
        // Are there restrictions on mydocuments or mycomputer?  Check for SFGAO_NONENUMERATED
        // This is for the policies that hide mydocs and mycomputer.
        if ((csidl == CSIDL_PERSONAL) || (csidl == CSIDL_DRIVES))
        {
            DWORD dwAttr = SFGAO_NONENUMERATED;
            if (SUCCEEDED(SHGetAttributesOf(*ppidl, &dwAttr)) && (dwAttr & SFGAO_NONENUMERATED))
            {
                // We won't create a placesbar item for this guy.
                ILFree(*ppidl);
                return FALSE;
            }
            
        }

        return SHGetFileInfo((LPCTSTR)*ppidl, 0, psfi, sizeof(*psfi), SHGFI_SYSICONINDEX  | SHGFI_PIDL | SHGFI_DISPLAYNAME);
    } 

    return FALSE;
}


typedef struct 
{
    LPCWSTR pszToken;
    int nFolder; //CSIDL
} STRINGTOCSIDLMAP;

static const STRINGTOCSIDLMAP g_rgStringToCSIDL[] = 
{
    { L"MyDocuments",       CSIDL_PERSONAL },
    { L"MyMusic",           CSIDL_MYMUSIC },
    { L"MyPictures",        CSIDL_MYPICTURES },
    { L"MyVideo",           CSIDL_MYVIDEO },
    { L"CommonDocuments",   CSIDL_COMMON_DOCUMENTS },
    { L"CommonPictures",    CSIDL_COMMON_PICTURES },
    { L"CommonMusic",       CSIDL_COMMON_MUSIC },
    { L"CommonVideo",       CSIDL_COMMON_VIDEO },
    { L"Desktop",           CSIDL_DESKTOP },
    { L"Recent",            CSIDL_RECENT },
    { L"MyNetworkPlaces",   CSIDL_NETHOOD },
    { L"MyFavorites",       CSIDL_FAVORITES },
    { L"MyComputer",        CSIDL_DRIVES },
    { L"Printers",          CSIDL_PRINTERS },
    { L"ProgramFiles",      CSIDL_PROGRAM_FILES },
};

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_GetPBItemFromTokenStrings(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
//       Gets a SHFileInfo and pidl for a path which is used in the places bar
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_GetPBItemFromTokenStrings(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
{
    for (int i = 0; i < ARRAYSIZE(g_rgStringToCSIDL); i++)
    {
        if (StrCmpI(lpszPath, g_rgStringToCSIDL[i].pszToken) == 0)
        {
            return _GetPBItemFromCSIDL(g_rgStringToCSIDL[i].nFolder, psfi, ppidl);
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_GetPBItemFromPath(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
//       Gets a SHFileInfo and pidl for a path which is used in the places bar
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_GetPBItemFromPath(LPTSTR lpszPath, SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
{
    TCHAR szTemp[MAX_PATH];

    //Expand environment strings if any
    if (ExpandEnvironmentStrings(lpszPath, szTemp, SIZECHARS(szTemp)))
    {
        lstrcpy(lpszPath, szTemp);
    }
    
    SHGetFileInfo(lpszPath,0,psfi,sizeof(*psfi), SHGFI_ICON|SHGFI_LARGEICON | SHGFI_DISPLAYNAME);
    SHILCreateFromPath(lpszPath, ppidl, NULL);
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_EnumPlacesBarItem(HKEY, int, SHFILEINFO)
//      Enumerates the Place bar item in the registry
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::_EnumPlacesBarItem(HKEY hkey, int i , SHFILEINFO * psfi, LPITEMIDLIST *ppidl)
{
    BOOL bRet = FALSE;


    if (hkey == NULL)
    {
        static const int aPlaces[] =
        {
            CSIDL_RECENT,
            CSIDL_DESKTOP,
            CSIDL_PERSONAL,
            CSIDL_DRIVES,
            CSIDL_NETWORK,
        };

        if (i >= 0 && i < MAXPLACESBARITEMS)
        {
           bRet =  _GetPBItemFromCSIDL(aPlaces[i], psfi, ppidl);
        }      
    }
    else
    {

        TCHAR szName[MAX_PATH];
        TCHAR szValue[MAX_PATH];
        DWORD cbValue;
        DWORD dwType;

        cbValue = ARRAYSIZE(szValue);
         
        wsprintf(szName, TEXT("Place%d"), i);

        if (RegQueryValueEx(hkey, szName, NULL, &dwType, (LPBYTE)szValue, &cbValue) == ERROR_SUCCESS)
        {
            if ((dwType != REG_DWORD) && (dwType != REG_EXPAND_SZ) && (dwType != REG_SZ))
            {
                return FALSE;
            }

            if (dwType == REG_DWORD)
            {
                bRet = _GetPBItemFromCSIDL((DWORD)*szValue, psfi, ppidl);
            }
            else
            {
                if (dwType == REG_SZ)
                {
                    // Check for special strings that indicate places.
                    bRet = _GetPBItemFromTokenStrings(szValue, psfi, ppidl);
                }

                if (!bRet)
                {
                    bRet = _GetPBItemFromPath(szValue, psfi, ppidl);
                }
            }
        } 
    }

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_GetPlacesBarItemToolTip
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_GetPlacesBarItemToolTip(int idCmd, LPTSTR pText, DWORD dwSize)
{
    TBBUTTONINFO tbbi;
    LPITEMIDLIST pidl;
    BOOL bRet = FALSE;

    // Return null string in case anything goes wrong
    pText[0] = TEXT('\0');

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.lParam = 0;
    tbbi.dwMask = TBIF_LPARAM;
    
    if (SendMessage(_hwndPlacesbar, TB_GETBUTTONINFO, idCmd, (LPARAM)&tbbi) < 0)
        return FALSE;

    pidl = (LPITEMIDLIST)tbbi.lParam;

    if (pidl)
    {
        IShellFolder *psf;
        LPITEMIDLIST pidlLast;

        HRESULT hres = CDBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), (LPCITEMIDLIST *)&pidlLast);
        if (SUCCEEDED(hres))
        {
            IQueryInfo *pqi;

            if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidlLast, IID_IQueryInfo, NULL, (void**)&pqi)))
            {
                WCHAR *pwszTip;

                if (SUCCEEDED(pqi->GetInfoTip(0, &pwszTip)) && pwszTip)
                {
                    SHUnicodeToTChar(pwszTip, pText, dwSize);
                    SHFree(pwszTip);
                    bRet = TRUE;
                }
                pqi->Release();
            }
            psf->Release();
        }
    }
    return bRet;
}




///////////////////////////////////////////////////////////////////////////
// 
// CFileOpenBrorwser::_RecreatePlacesbar
//
// called when something changes that requires the placesbar be recreated (e.g. icons change)
//
///////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::_RecreatePlacesbar()
{
    if (_hwndPlacesbar)
    {
        // Free any pidls in the places bar
        _CleanupPlacesbar();

        // Remove all buttons in places bar
        int cButtons = (int)SendMessage(_hwndPlacesbar, TB_BUTTONCOUNT, 0, 0);
        for (int i = 0; i < cButtons; i++)
        {
            SendMessage(_hwndPlacesbar, TB_DELETEBUTTON, 0, 0);
        }

        // Put them back in, with potentially new images.
        _FillPlacesbar(_hwndPlacesbar);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreatePlacesBar
//
//  CreatePlacesBar member function.
//      creates and initializes the places bar  in the dialog
//
//
////////////////////////////////////////////////////////////////////////////
HWND CFileOpenBrowser::CreatePlacesbar(HWND hwndDlg)
{
    HWND hwndTB = GetDlgItem(hwndDlg, ctl1);

    if (hwndTB)
    {

        //Set the version for the toolbar
        SendMessage(hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // Sets the size of the TBBUTTON structure.
        SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

        SetWindowTheme(hwndTB, L"Placesbar", NULL);

        SendMessage(hwndTB, TB_SETMAXTEXTROWS, 2, 0); // Try to set toolbar to show 2 rows

        // For themes, we'll change the default padding, so we need to save it
        // off in case we need to restore it.
        _dwPlacesbarPadding = SendMessage(hwndTB, TB_GETPADDING, 0, 0);

        _FillPlacesbar(hwndTB);
    }
    return hwndTB;
}


void CFileOpenBrowser::_FillPlacesbar(HWND hwndPlacesbar)
{
    HKEY hkey = NULL;
    int i;
    TBBUTTON tbb;
    SHFILEINFO sfi;
    LPITEMIDLIST pidl;
    HIMAGELIST himl;

    //See if Places bar key is available
    RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_PLACESBAR, &hkey);

    Shell_GetImageLists(&himl, NULL);

    for (i=0; i < MAXPLACESBARITEMS; i++)
    {
        if (_EnumPlacesBarItem(hkey, i, &sfi, &pidl))
        {
             //Now Add the item to the toolbar
             tbb.iBitmap   = sfi.iIcon;
             tbb.fsState   = TBSTATE_ENABLED;
             tbb.fsStyle   = BTNS_BUTTON;
             tbb.idCommand =  IDC_PLACESBAR_BASE + _iCommandID;
             tbb.iString   = (INT_PTR)&sfi.szDisplayName;
             tbb.dwData    = (INT_PTR)pidl;

             SendMessage(hwndPlacesbar, TB_ADDBUTTONS, (UINT)1, (LPARAM)&tbb);

             //Increment the command ID 
             _iCommandID++;
        }
    }

    //Close the reg key
    if (hkey)
    {
        RegCloseKey(hkey);
    }

    HIMAGELIST himlOld = (HIMAGELIST) SendMessage(hwndPlacesbar, TB_SETIMAGELIST, 0, (LPARAM)himl);

    // Destroy the old imagelist only the first time.  After this, the imagelist we get back is the
    // one we've set, the system imagelist.
    if ((himlOld != NULL) && _bDestroyPlacesbarImageList)
    {
        ImageList_Destroy(himlOld);
    }
    _bDestroyPlacesbarImageList = FALSE;

    OnThemeActive(_hwndDlg, IsAppThemed());

    // Add the buttons
    SendMessage(hwndPlacesbar, TB_AUTOSIZE, (WPARAM)0, (LPARAM)0);
}





void CFileOpenBrowser::_CleanupPlacesbar()
{
    if (_hwndPlacesbar)
    {
        TBBUTTONINFO tbbi;
        LPITEMIDLIST pidl;

        for (int i=0; i < MAXPLACESBARITEMS; i++)
        {
            tbbi.cbSize = SIZEOF(tbbi);
            tbbi.lParam = 0;
            tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
            if (SendMessage(_hwndPlacesbar, TB_GETBUTTONINFO, i, (LPARAM)&tbbi) >= 0)
            {
                pidl = (LPITEMIDLIST)tbbi.lParam;

                if (pidl)
                {
                    ILFree(pidl);
                }
            }
        }
    }
}

// Less padding for themes
#define PLACESBAR_THEMEPADDING MAKELPARAM(2, 2)

void CFileOpenBrowser::OnThemeActive(HWND hwndDlg, BOOL bActive)
{
    HWND hwndPlacesBar = GetDlgItem(hwndDlg, ctl1);
    if (hwndPlacesBar)
    {
        // For themes, use the default colour scheme for the places toolbar:
        COLORSCHEME cs;
        cs.dwSize = SIZEOF(cs);
        cs.clrBtnHighlight  = bActive ? CLR_DEFAULT : GetSysColor(COLOR_BTNHIGHLIGHT);
        cs.clrBtnShadow     = bActive ? CLR_DEFAULT : GetSysColor(COLOR_3DDKSHADOW);
        SendMessage(hwndPlacesBar, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);

        // For themes, we have a background, so make the toolbar background non-transparent
        // (the resource specifies TBSTYLE_FLAT, which includes TBSTYLE_TRANSPARENT)
        DWORD_PTR dwTBStyle = SendMessage(hwndPlacesBar, TB_GETSTYLE, 0, 0);
        SendMessage(hwndPlacesBar, TB_SETSTYLE, 0, bActive ? (dwTBStyle & ~TBSTYLE_TRANSPARENT) : (dwTBStyle | TBSTYLE_TRANSPARENT));
    
        // Special padding for themes on comctlv6 only  (RAID #424528)
        if (SendMessage(hwndPlacesBar, CCM_GETVERSION, 0, 0) >= 0x600)
        {
            SendMessage(hwndPlacesBar, TB_SETPADDING, 0, bActive? PLACESBAR_THEMEPADDING : _dwPlacesbarPadding);
        }

        // Remove the clientedge extended style for themes
        LONG_PTR dwPlacesExStyle = GetWindowLongPtr(hwndPlacesBar, GWL_EXSTYLE);
        SetWindowLongPtr(hwndPlacesBar, GWL_EXSTYLE, bActive ? (dwPlacesExStyle  & ~WS_EX_CLIENTEDGE) : (dwPlacesExStyle | WS_EX_CLIENTEDGE));
        // And apply these frame style changes...
        SetWindowPos(hwndPlacesBar, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE | SWP_FRAMECHANGED);

        // Ensure buttons go right to edge of client area (client area has changed)
        RECT rc;
        GetClientRect(hwndPlacesBar, &rc);
        SendMessage(hwndPlacesBar, TB_SETBUTTONWIDTH, 0, (LPARAM)MAKELONG(RECTWIDTH(rc), RECTWIDTH(rc)));
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CFileOpenBrowser
//
//  CFileOpenBrowser constructor.
//  Minimal construction of the object.  Much more construction in
//  InitLocation.
//
////////////////////////////////////////////////////////////////////////////

CFileOpenBrowser::CFileOpenBrowser(
    HWND hDlg,
    BOOL fIsSaveAs)
    : _cRef(1),
      _iCurrentLocation(-1),
      _iVersion(OPENFILEVERSION),
      _pCurrentLocation(NULL),
      _psv(NULL),
      _hwndDlg(hDlg),
      _hwndView(NULL),
      _hwndToolbar(NULL),
      _psfCurrent(NULL),
      _bSave(fIsSaveAs),
      _iComboIndex(-1),
      _hwndTips(NULL),
      _ptlog(NULL),
      _iCheckedButton(-1),
      _pidlSelection(NULL),
      _lpOKProc(NULL)
{
    _iNodeDesktop = NODE_DESKTOP;
    _iNodeDrives  = NODE_DRIVES;

    _szLastFilter[0] = CHAR_NULL;

    _bEnableSizing = FALSE;
    _bUseCombo     = TRUE;
    _hwndGrip = NULL;
    _ptLastSize.x = 0;
    _ptLastSize.y = 0;
    _sizeView.cx = 0;
    _bUseSizeView = FALSE;
    _bAppRedrawn = FALSE;
    _bDestroyPlacesbarImageList = TRUE;

    HMENU hMenu;
    hMenu = GetSystemMenu(hDlg, FALSE);
    DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_RESTORE,  MF_BYCOMMAND);

    Shell_GetImageLists(NULL, &_himl);

    //
    //  This setting could change on the fly, but I really don't care
    //  about that rare case.
    //
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
    _fShowExtensions = ss.fShowExtensions;

    _pScheduler = NULL;
    CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
}




////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::~CFileOpenBrowser
//
//  CFileOpenBrowser destructor.
//
////////////////////////////////////////////////////////////////////////////

CFileOpenBrowser::~CFileOpenBrowser()
{
    if (_uRegister)
    {
        SHChangeNotifyDeregister(_uRegister);
        _uRegister = 0;
    }

    //
    //  Ensure that we discard the tooltip window.
    //
    if (_hwndTips)
    {
        DestroyWindow(_hwndTips);
        _hwndTips = NULL;                // handle is no longer valid
    }

    if (_hwndGrip)
    {
        DestroyWindow(_hwndGrip);
        _hwndGrip = NULL;
    }

    _CleanupPlacesbar();

    if (_pcwd)
    {
        _pcwd->Release();
    }

    if (_ptlog)
    {
       _ptlog->Release();
    }

    Pidl_Set(&_pidlSelection,NULL);

    if (_pScheduler)
        _pScheduler->Release();
}

HRESULT CFileOpenBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFileOpenBrowser, IShellBrowser),                              // IID_IShellBrowser
        QITABENT(CFileOpenBrowser, ICommDlgBrowser2),                           // IID_ICommDlgBrowser2
        QITABENTMULTI(CFileOpenBrowser, ICommDlgBrowser, ICommDlgBrowser2),     // IID_ICommDlgBrowser
        QITABENT(CFileOpenBrowser, IServiceProvider),                           // IID_IServiceProvider
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFileOpenBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFileOpenBrowser::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CFileOpenBrowser::GetWindow(HWND *phwnd)
{
    *phwnd = _hwndDlg;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ContextSensitiveHelp
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::ContextSensitiveHelp(
    BOOL fEnable)
{
    //
    //  Shouldn't need in a common dialog.
    //
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetStatusTextSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetStatusTextSB(
    LPCOLESTR pwch)
{
    //
    //  We don't have any status bar.
    //
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetFocusedChild
//
////////////////////////////////////////////////////////////////////////////

HWND GetFocusedChild(
    HWND hwndDlg,
    HWND hwndFocus)
{
    HWND hwndParent;

    if (!hwndDlg)
    {
        return (NULL);
    }

    if (!hwndFocus)
    {
        hwndFocus = ::GetFocus();
    }

    //
    //  Go up the parent chain until the parent is the main dialog.
    //
    while ((hwndParent = ::GetParent(hwndFocus)) != hwndDlg)
    {
        if (!hwndParent)
        {
            return (NULL);
        }

        hwndFocus = hwndParent;
    }

    return (hwndFocus);
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnableModelessSB
//
////////////////////////////////////////////////////////////////////////////
typedef struct 
{
    UINT idExcept;
    BOOL fEnable;
} ENABLEKIDS;

#define PROP_WASDISABLED TEXT("Comdlg32_WasDisabled")

BOOL CALLBACK _EnableKidsEnum(HWND hwnd, LPARAM lp)
{
    ENABLEKIDS *pek = (ENABLEKIDS *)lp;
    if (pek->idExcept != GetDlgCtrlID(hwnd))
    {
        if (pek->fEnable)
        {
            // When re-enabling, don't re-enable windows that were
            // previously disabled
            if (!RemoveProp(hwnd, PROP_WASDISABLED))
            {
                EnableWindow(hwnd, TRUE);
            }
        }
        else
        {
            // When disabling, remember whether the window was already
            // disabled so we don't accidentally re-enable it
            if (EnableWindow(hwnd, pek->fEnable))
            {
                SetProp(hwnd, PROP_WASDISABLED, IntToPtr(TRUE));
            }
        }

    }
    return TRUE;
}

void EnableChildrenWithException(HWND hwndDlg, UINT idExcept, BOOL fEnable)
{
    ENABLEKIDS ek = {idExcept, fEnable};
    ::EnumChildWindows(hwndDlg, _EnableKidsEnum, (LPARAM)&ek);
}

STDMETHODIMP CFileOpenBrowser::EnableModelessSB(BOOL fEnable)
{
    LONG cBefore = _cRefCannotNavigate;
    if (fEnable)
    {
        _cRefCannotNavigate--;
    }
    else
    {
        _cRefCannotNavigate++;
    }

    ASSERT(_cRefCannotNavigate >= 0);

    if (!cBefore || !_cRefCannotNavigate)
    {
        //  we changed state
        ASSERT(_cRefCannotNavigate >= 0);
        if (!fEnable)
            _hwndModelessFocus = GetFocusedChild(_hwndDlg, NULL);
        EnableChildrenWithException(_hwndDlg, IDCANCEL, fEnable);

        if (fEnable && _hwndModelessFocus)
            SetFocus(_hwndModelessFocus);
            
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::TranslateAcceleratorSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::TranslateAcceleratorSB(
    LPMSG pmsg,
    WORD wID)
{
    //
    //  We don't use the  Key Stroke.
    //
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::BrowseObject
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::BrowseObject(
    LPCITEMIDLIST pidl,
    UINT wFlags)
{
    return JumpToIDList(pidl);
}




BOOL _IsRecentFolder(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);
    BOOL fRet = FALSE;
    LPITEMIDLIST pidlRecent = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (pidlRecent)
    {
        fRet = ILIsEqual(pidlRecent, pidl);
        ILFree(pidlRecent);
    }

    return fRet;
}

// My Pictures or My Videos
BOOL CFileOpenBrowser::_IsThumbnailFolder(LPCITEMIDLIST pidl)
{
    BOOL fThumbnailFolder = FALSE;
    WCHAR szPath[MAX_PATH + 1];
    if (SHGetPathFromIDList(pidl, szPath))
    {
        fThumbnailFolder = PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_MYPICTURES), szPath) ||
                           PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_MYVIDEO), szPath);
    }

    return fThumbnailFolder;
}


static const GUID CLSID_WIA_FOLDER1 =
{ 0xe211b736, 0x43fd, 0x11d1, { 0x9e, 0xfb, 0x00, 0x00, 0xf8, 0x75, 0x7f, 0xcd} };
static const GUID CLSID_WIA_FOLDER2 = 
{ 0xFB0C9C8A, 0x6C50, 0x11D1, { 0x9F, 0x1D, 0x00, 0x00, 0xf8, 0x75, 0x7f, 0xcd} };


LOCTYPE CFileOpenBrowser::_GetLocationType(MYLISTBOXITEM *pLocation)
{
    if (_IsRecentFolder(pLocation->pidlFull))
        return LOCTYPE_RECENT_FOLDER;

    if (_IsThumbnailFolder(pLocation->pidlFull))
        return LOCTYPE_MYPICTURES_FOLDER;

    IShellFolder *psf = pLocation->GetShellFolder(); // Note: this is a MYLISTBOXITEM member variable, don't need to Release()
    if (_IsWIAFolder(psf))
    {
        return LOCTYPE_WIA_FOLDER;
    }

    return LOCTYPE_OTHERS;
}

// Is it a windows image acquisition folder?
BOOL CFileOpenBrowser::_IsWIAFolder(IShellFolder *psf)
{
    CLSID clsid;
    return (psf &&
            SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) &&
            (IsEqualGUID(clsid, CLSID_WIA_FOLDER1) || IsEqualGUID(clsid, CLSID_WIA_FOLDER2)));
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetViewStateStream
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetViewStateStream(
    DWORD grfMode,
    LPSTREAM *pStrm)
{
    //
    //  FEATURE: We should implement this so there is some persistence
    //  for the file open dailog.
    //
    ASSERT(_pCurrentLocation);
    ASSERT(pStrm);
    
    *pStrm = NULL;

    if ((grfMode == STGM_READ) && _IsRecentFolder(_pCurrentLocation->pidlFull))
    {
        //  we want to open the stream from the registry...
        *pStrm = SHOpenRegStream(HKEY_LOCAL_MACHINE, TEXT("Software\\microsoft\\windows\\currentversion\\explorer\\recentdocs"), 
            TEXT("ViewStream"), grfMode);
    }
    return (*pStrm ? S_OK : E_FAIL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetControlWindow
//
//  Get the handles of the various windows in the File Cabinet.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetControlWindow(
    UINT id,
    HWND *lphwnd)
{
    if (id == FCW_TOOLBAR)
    {
        *lphwnd = _hwndToolbar;
        return S_OK;
    }

    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SendControlMsg
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SendControlMsg(
    UINT id,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pret)
{
    LRESULT lres = 0;

    if (id == FCW_TOOLBAR)
    {
        //
        //  We need to translate messages from defview intended for these
        //  buttons to our own.
        //
        switch (uMsg)
        {
            case (TB_CHECKBUTTON) :
            {
#if 0 // we don't do this anymore because we use the viewmenu dropdown
                switch (wParam)
                {
                    case (SFVIDM_VIEW_DETAILS) :
                    {
                        wParam = IDC_VIEWDETAILS;
                        break;
                    }
                    case (SFVIDM_VIEW_LIST) :
                    {
                        wParam = IDC_VIEWLIST;
                        break;
                    }
                    default :
                    {
                        goto Bail;
                    }
                }
                break;
#endif
            }
            default :
            {
                goto Bail;
                break;
            }
        }

        lres = SendMessage(_hwndToolbar, uMsg, wParam, lParam);
    }

Bail:
    if (pret)
    {
        *pret = lres;
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::QueryActiveShellView
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::QueryActiveShellView(
    LPSHELLVIEW *ppsv)
{
    if (_psv)
    {
        *ppsv = _psv;
        _psv->AddRef();
        return S_OK;
    }
    *ppsv = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnViewWindowActive
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnViewWindowActive(
    LPSHELLVIEW _psv)
{
    //
    //  No need to process this. We don't do menus.
    //
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::InsertMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::InsertMenusSB(
    HMENU hmenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetMenuSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetMenuSB(
    HMENU hmenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RemoveMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::RemoveMenusSB(
    HMENU hmenuShared)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetToolbarItems
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetToolbarItems(
    LPTBBUTTON lpButtons,
    UINT nButtons,
    UINT uFlags)
{
    //
    //  We don't let containers customize our toolbar.
    //
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDefaultCommand
//
//  Process a double-click or Enter keystroke in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnDefaultCommand(
    struct IShellView *ppshv)
{
    if (ppshv != _psv)
    {
        return (E_INVALIDARG);
    }

    OnDblClick(FALSE);

    return S_OK;
}




///////////////////////////////////
// *** IServiceProvider methods ***
///////////////////////////////////
HRESULT CFileOpenBrowser::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL;
    
    if (IsEqualGUID(guidService, SID_SCommDlgBrowser))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetCurrentFilter
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SetCurrentFilter(
    LPCTSTR pszFilter,
    OKBUTTONFLAGS Flags)
{
    LPTSTR lpNext;

    //
    //  Don't do anything if it's the same filter.
    //
    if (lstrcmp(_szLastFilter, pszFilter) == 0)
    {
        return;
    }

    lstrcpyn(_szLastFilter, pszFilter, ARRAYSIZE(_szLastFilter));
    int nLeft = ARRAYSIZE(_szLastFilter) - lstrlen(_szLastFilter) - 1;

    //
    //  Do nothing if quoted.
    //
    if (Flags & OKBUTTON_QUOTED)
    {
        return;
    }

    //
    //  If pszFilter matches a filter spec, select that spec.
    //
    HWND hCmb = GetDlgItem(_hwndDlg, cmb1);
    if (hCmb)
    {
        int nMax = ComboBox_GetCount(hCmb);
        int n;

        BOOL bCustomFilter = _pOFN->lpstrCustomFilter && *_pOFN->lpstrCustomFilter;

        for (n = 0; n < nMax; n++)
        {
            LPTSTR pFilter = (LPTSTR)ComboBox_GetItemData(hCmb, n);
            if (pFilter && pFilter != (LPTSTR)CB_ERR)
            {
                if (!lstrcmpi(pFilter, pszFilter))
                {
                    if (n != ComboBox_GetCurSel(hCmb))
                    {
                        ComboBox_SetCurSel(hCmb, n);
                    }
                    break;
                }
            }
        }
    }

    //
    //  For LFNs, tack on a '*' after non-wild extensions.
    //
    for (lpNext = _szLastFilter; nLeft > 0;)
    {
        LPTSTR lpSemiColon = StrChr(lpNext, CHAR_SEMICOLON);

        if (!lpSemiColon)
        {
            lpSemiColon = lpNext + lstrlen(lpNext);
        }

        TCHAR cTemp = *lpSemiColon;
        *lpSemiColon = CHAR_NULL;

        LPTSTR lpDot = StrChr(lpNext, CHAR_DOT);

        //
        //  See if there is an extension that is not wild.
        //
        if (lpDot && *(lpDot + 1) && !IsWild(lpDot))
        {
            //
            //  Tack on a star.
            //  We know there is still enough room because nLeft > 0.
            //
            if (cTemp != CHAR_NULL)
            {
                MoveMemory(lpSemiColon + 2,
                            lpSemiColon + 1,
                            (lstrlen(lpSemiColon + 1) + 1) * sizeof(TCHAR)); // plus 1 for terminating NULL
            }
            *lpSemiColon = CHAR_STAR;

            ++lpSemiColon;
            --nLeft;
        }

        *lpSemiColon = cTemp;
        if (cTemp == CHAR_NULL)
        {
            break;
        }
        else
        {
            lpNext = lpSemiColon + 1;
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SwitchView
//
//  Switch the view control to a new container.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CFileOpenBrowser::SwitchView(
    IShellFolder *psfNew,
    LPCITEMIDLIST pidlNew,
    FOLDERSETTINGS *pfs,
    SHELLVIEWID  const *pvid,
    BOOL fUseDefaultView)
{
    IShellView *psvNew;
    IShellView2 *psv2New;
    RECT rc;

    if (!psfNew)
    {
        return (E_INVALIDARG);
    }

    GetControlRect(_hwndDlg, lst1, &rc);

    if (_bEnableSizing)
    {
        if (_hwndView)
        {
            //
            //  Don't directly use the rect but instead use the size as
            //  applications like VB may move the window off the screen.
            //
            RECT rcView;

            GetWindowRect(_hwndView, &rcView);
            _sizeView.cx = rcView.right - rcView.left;
            _sizeView.cy = rcView.bottom - rcView.top;
            rc.right = rc.left + _sizeView.cx;
            rc.bottom = rc.top + _sizeView.cy;
        }
        else if (_bUseSizeView && _sizeView.cx)
        {
            //
            //  If we previously failed then use cached size.
            //
            rc.right = rc.left + _sizeView.cx;
            rc.bottom = rc.top + _sizeView.cy;
        }
    }

    HRESULT hres = psfNew->CreateViewObject(_hwndDlg, IID_PPV_ARG(IShellView, &psvNew));
    if (FAILED(hres))
    {
        return hres;
    }

    IShellView *psvOld;
    HWND hwndNew;

    WAIT_CURSOR w(this);
    
    //
    //  The view window itself won't take the focus.  But we can set
    //  focus there and see if it bounces to the same place it is
    //  currently.  If that's the case, we want the new view window
    //  to get the focus;  otherwise, we put it back where it was.
    //
    BOOL bViewFocus = (GetFocusedChild(_hwndDlg, NULL) == _hwndView);

    psvOld = _psv;

    //
    //  We attempt to blow off drawing on the main dialog.  Note that
    //  we should leave in SETREDRAW stuff to minimize flicker in case
    //  this fails.
    //

    BOOL bLocked = LockWindowUpdate(_hwndDlg);

    //
    //  We need to kill the current _psv before creating the new one in case
    //  the current one has a background thread going that is trying to
    //  call us back (IncludeObject).
    //
    if (psvOld)
    {
        SendMessage(_hwndView, WM_SETREDRAW, FALSE, 0);
        psvOld->DestroyViewWindow();
        _hwndView = NULL;
        _psv = NULL;

        //
        //  Don't release yet.  We will pass this to CreateViewWindow().
        //
    }

    //
    //  At this point, there should be no background processing happening.
    //
    _psfCurrent = psfNew;
    SHGetPathFromIDList(pidlNew, _szCurDir);

    //
    //  New windows (like the view window about to be created) show up at
    //  the bottom of the Z order, so I need to disable drawing of the
    //  subdialog while creating the view window; drawing will be enabled
    //  after the Z-order has been set properly.
    //
    if (_hSubDlg)
    {
        SendMessage(_hSubDlg, WM_SETREDRAW, FALSE, 0);
    }

    //
    //  _psv must be set before creating the view window since we
    //  validate it on the IncludeObject callback.
    //
    _psv = psvNew;

    if ((pvid || fUseDefaultView) && SUCCEEDED(psvNew->QueryInterface(IID_PPV_ARG(IShellView2, &psv2New))))
    {

        SV2CVW2_PARAMS cParams;
        SHELLVIEWID  vidCurrent = {0};

        cParams.cbSize   = SIZEOF(SV2CVW2_PARAMS);
        cParams.psvPrev  = psvOld;
        cParams.pfs      = pfs;
        cParams.psbOwner = this;
        cParams.prcView  = &rc;
        if (pvid)
            cParams.pvid     = pvid;   // View id; for example, &CLSID_ThumbnailViewExt;
        else
        {
            psv2New->GetView(&vidCurrent, SV2GV_DEFAULTVIEW);

            // We don't want filmstrip view in fileopen, so we'll switch that to thumbnail.
            if (IsEqualIID(VID_ThumbStrip, vidCurrent))
                cParams.pvid = &VID_Thumbnails;
            else
                cParams.pvid = &vidCurrent;
        }

        hres = psv2New->CreateViewWindow2(&cParams);

        hwndNew = cParams.hwndView;

        psv2New->Release();
    }
    else
        hres = _psv->CreateViewWindow(psvOld, pfs, this, &rc, &hwndNew);

    _bUseSizeView = FAILED(hres);

    if (SUCCEEDED(hres))
    {
        hres = psvNew->UIActivate(SVUIA_INPLACEACTIVATE);
    }

    if (psvOld)
    {
        psvOld->Release();
    }

    if (_hSubDlg)
    {
        //
        //  Turn REDRAW back on before changing the focus in case the
        //  SubDlg has the focus.
        //
        SendMessage(_hSubDlg, WM_SETREDRAW, TRUE, 0);
    }

    if (SUCCEEDED(hres))
    {
        DWORD dwAttr = SFGAO_STORAGE | SFGAO_READONLY;
        SHGetAttributesOf(pidlNew, &dwAttr);
        BOOL bNewFolder = (dwAttr & SFGAO_STORAGE) && !(dwAttr & SFGAO_READONLY);
        ::SendMessage(_hwndToolbar, TB_ENABLEBUTTON, IDC_NEWFOLDER,   bNewFolder);

        _hwndView = hwndNew;

    
        //
        //  Move the view window to the right spot in the Z (tab) order.
        //
        SetWindowPos(hwndNew,
                      GetDlgItem(_hwndDlg, lst1),
                      0,
                      0,
                      0,
                      0,
                      SWP_NOMOVE | SWP_NOSIZE);


        //
        //  Give it the right window ID for WinHelp.
        //
        SetWindowLong(hwndNew, GWL_ID, lst2);

        ::RedrawWindow(_hwndView,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_ALLCHILDREN | RDW_UPDATENOW);

        if (bViewFocus)
        {
            ::SetFocus(_hwndView);
        }
    }
    else
    {
        _psv = NULL;
        psvNew->Release();
    }

    //
    //  Let's draw again!
    //

    if (bLocked)
    {
        LockWindowUpdate(NULL);
    }

    return hres;
}

void CFileOpenBrowser::_WaitCursor(BOOL fWait)
{
    if (fWait)
        _cWaitCursor++;
    else
        _cWaitCursor--;
        
    SetCursor(LoadCursor(NULL, _cWaitCursor ? IDC_WAIT : IDC_ARROW));
}

BOOL CFileOpenBrowser::OnSetCursor()
{
    if (_cWaitCursor)
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;
    }
    return FALSE;
}
    
////////////////////////////////////////////////////////////////////////////
//
//  JustGetToolTipText
//
////////////////////////////////////////////////////////////////////////////

void JustGetToolTipText(
    UINT idCommand,
    LPTOOLTIPTEXT pTtt)
{
    if (!CDLoadString(::g_hinst,
                     idCommand + MH_TOOLTIPBASE,
                     pTtt->szText,
                     ARRAYSIZE(pTtt->szText)))
    {
        *pTtt->lpszText = 0;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnNotify
//
//  Process notify messages from the view -- for tooltips.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CFileOpenBrowser::OnNotify(
    LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->code)
    {
        case (TTN_NEEDTEXT) :
        {
            HWND hCtrl = GetDlgItem(_hwndDlg, cmb2);
            LPTOOLTIPTEXT lptt = (LPTOOLTIPTEXT)pnm;
            int iTemp;

            //
            //  If this is the combo control which shows the current drive,
            //  then convert this into a suitable tool-tip message giving
            //  the 'full' path to this object.
            //
            if (pnm->idFrom == (UINT_PTR)hCtrl)
            {
                //
                //  iTemp will contain index of first path element.
                //
                GetDirectoryFromLB(_szTipBuf, &iTemp);

                lptt->lpszText = _szTipBuf;
                lptt->szText[0] = CHAR_NULL;
                lptt->hinst = NULL;              // no instance needed
            }
            else if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
            {
                if (_hwndView)
                {
                    lres = ::SendMessage(_hwndView, WM_NOTIFY, 0, (LPARAM)pnm);
                }
            }
            else if (IsInRange(pnm->idFrom, IDC_PLACESBAR_BASE, IDC_PLACESBAR_BASE + _iCommandID))
            {
                _GetPlacesBarItemToolTip((int)pnm->idFrom, _szTipBuf, ARRAYSIZE(_szTipBuf));
                lptt->lpszText = _szTipBuf;
            }
            else
            {
                JustGetToolTipText((UINT) pnm->idFrom, lptt);
            }
            lres = TRUE;
            break;
        }
        case (NM_STARTWAIT) :
        case (NM_ENDWAIT) :
        {
            //
            //  What we really want is for the user to simulate a mouse
            //  move/setcursor.
            //
            _WaitCursor(pnm->code == NM_STARTWAIT);
            break;
        }
        case (TBN_DROPDOWN) :
        {
            RECT r;
            VARIANT v = {VT_INT_PTR};
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            DFVCMDDATA cd;

        //  v.vt = VT_I4;
            v.byref = &r;

            SendMessage(_hwndToolbar, TB_GETRECT, ptbn->iItem, (LPARAM)&r);
            MapWindowRect(_hwndToolbar, HWND_DESKTOP, &r);

            cd.pva = &v;
            cd.hwnd = _hwndToolbar;
            cd.nCmdIDTranslated = 0;
            SendMessage(_hwndView, WM_COMMAND, SFVIDM_VIEW_VIEWMENU, (LONG_PTR)&cd);

            break;
        }

        case (NM_CUSTOMDRAW) :
        if (!IsAppThemed())
        {
            LPNMTBCUSTOMDRAW lpcust = (LPNMTBCUSTOMDRAW)pnm;

            //Make sure its from places bar
            if (lpcust->nmcd.hdr.hwndFrom == _hwndPlacesbar)
            {
                switch (lpcust->nmcd.dwDrawStage)
                {
                    case  (CDDS_PREERASE) :
                    {
                        HDC hdc = (HDC)lpcust->nmcd.hdc;
                        RECT rc;
                        GetClientRect(_hwndPlacesbar, &rc);
                        SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
                        lres = CDRF_SKIPDEFAULT;
                        SetDlgMsgResult(_hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                    case  (CDDS_PREPAINT) :
                    {
                        lres = CDRF_NOTIFYITEMDRAW;
                        SetDlgMsgResult(_hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                    case (CDDS_ITEMPREPAINT) :
                    {
                        //Set the text color to window
                        lpcust->clrText    = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        lpcust->clrBtnFace = GetSysColor(COLOR_BTNSHADOW);
                        lpcust->nStringBkMode = TRANSPARENT;
                        lres = CDRF_DODEFAULT;

                        if (lpcust->nmcd.uItemState & CDIS_CHECKED)
                        {
                            lpcust->hbrMonoDither = NULL;
                        }
                        SetDlgMsgResult(_hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                }
            }
        }
    }

    return (lres);
}


//  Get the display name of a shell object.

void GetViewItemText(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pBuf, UINT cchBuf, DWORD flags = SHGDN_INFOLDER | SHGDN_FORPARSING)
{
    DisplayNameOf(psf, pidl, flags, pBuf, cchBuf);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetListboxItem
//
//  Get a MYLISTBOXITEM object out of the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

MYLISTBOXITEM *GetListboxItem(
    HWND hCtrl,
    WPARAM iItem)
{
    MYLISTBOXITEM *p = (MYLISTBOXITEM *)SendMessage(hCtrl,
                                                     CB_GETITEMDATA,
                                                     iItem,
                                                     NULL);
    if (p == (MYLISTBOXITEM *)CB_ERR)
    {
        return NULL;
    }
    else
    {
        return p;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  _ReleaseStgMedium
//
////////////////////////////////////////////////////////////////////////////

HRESULT _ReleaseStgMedium(
    LPSTGMEDIUM pmedium)
{
    if (pmedium->pUnkForRelease)
    {
        pmedium->pUnkForRelease->Release();
    }
    else
    {
        switch (pmedium->tymed)
        {
            case (TYMED_HGLOBAL) :
            {
                GlobalFree(pmedium->hGlobal);
                break;
            }
            default :
            {
                //
                //  Not fully implemented.
                //
                MessageBeep(0);
                break;
            }
        }
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetSaveButton
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SetSaveButton(
    UINT idSaveButton)
{
    PostMessage(_hwndDlg, CDM_SETSAVEBUTTON, idSaveButton, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RealSetSaveButton
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RealSetSaveButton(
    UINT idSaveButton)
{
    MSG msg;

    if (PeekMessage(&msg,
                     _hwndDlg,
                     CDM_SETSAVEBUTTON,
                     CDM_SETSAVEBUTTON,
                     PM_NOREMOVE))
    {
        //
        //  There is another SETSAVEBUTTON message in the queue, so blow off
        //  this one.
        //
        return;
    }

    if (_bSave)
    {
        TCHAR szTemp[40];
        LPTSTR pszTemp = _tszDefSave;

        //
        //  Load the string if not the "Save" string or there is no
        //  app-specified default.
        //
        if ((idSaveButton != iszFileSaveButton) || !pszTemp)
        {
            CDLoadString(g_hinst, idSaveButton, szTemp, ARRAYSIZE(szTemp));
            pszTemp = szTemp;
        }

        GetDlgItemText(_hwndDlg, IDOK, _szBuf, ARRAYSIZE(_szBuf));
        if (lstrcmp(_szBuf, pszTemp))
        {
            //
            //  Avoid some flicker.
            //
            SetDlgItemText(_hwndDlg, IDOK, pszTemp);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetEditFile
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SetEditFile(
    LPCTSTR pszFile,
    LPCTSTR pszFriendlyName,
    BOOL bShowExt,
    BOOL bSaveNullExt)
{
    BOOL bHasHiddenExt = FALSE;

    //
    //  Save the whole file name.
    //
    if (!_pszHideExt.StrCpy(pszFile))
    {
        _pszHideExt.StrCpy(NULL);
        bShowExt = TRUE;
    }

    //
    //  FEATURE: This is bogus -- we only want to hide KNOWN extensions,
    //          not all extensions.
    //
    if (!bShowExt && !IsWild(pszFile) && !pszFriendlyName)
    {
        LPTSTR pszExt = PathFindExtension(pszFile);
        if (*pszExt)
        {
            //
            //  If there was an extension, hide it.
            //
            *pszExt = 0;

            bHasHiddenExt = TRUE;
        }
    }
    else if (pszFriendlyName)
    {
        // A friendly name was provided. Use it.
        pszFile = pszFriendlyName;

        // Not technically true, but this bit indicates that an app sends a CDM_GETSPEC, we give the for-parsing
        // value in _pszHideExt, not the "friendly name" in the edit box
        bHasHiddenExt = TRUE;
    }

    if (_bUseCombo)
    {
        HWND hwndEdit = (HWND)SendMessage(GetDlgItem(_hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        SetWindowText(hwndEdit, pszFile);
    }
    else
    {
        SetDlgItemText(_hwndDlg, edt1, pszFile);
    }

    //
    //  If the initial file name has no extension, we want to do our normal
    //  extension finding stuff.  Any other time we get a file with no
    //  extension, we should not do this.
    //
    _bUseHideExt = (LPTSTR)_pszHideExt
                      ? (bSaveNullExt ? TRUE : bHasHiddenExt)
                      : FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  FindEOF
//
////////////////////////////////////////////////////////////////////////////

LPTSTR FindEOF(
    LPTSTR pszFiles)
{
    BOOL bQuoted;
    LPTSTR pszBegin = pszFiles;

    while (*pszBegin == CHAR_SPACE)
    {
        ++pszBegin;
    }

    //
    //  Note that we always assume a quoted string, even if no quotes exist,
    //  so the only file delimiters are '"' and '\0'.  This allows somebody to
    //  type <Start Menu> or <My Document> in the edit control and the right
    //  thing happens.
    //
    bQuoted = TRUE;

    if (*pszBegin == CHAR_QUOTE)
    {
        ++pszBegin;
    }

    //Remove the quote from the file list if one exist
    lstrcpy(pszFiles, pszBegin);

    //
    //  Find the end of the filename (first quote or unquoted space).
    //
    for (; ; pszFiles = CharNext(pszFiles))
    {
        switch (*pszFiles)
        {
            case (CHAR_NULL) :
            {
                return (pszFiles);
            }
            case (CHAR_SPACE) :
            {
                if (!bQuoted)
                {
                    return (pszFiles);
                }
                break;
            }
            case (CHAR_QUOTE) :
            {
                //
                //  Note we only support '"' at the very beginning and very
                //  end of a file name.
                //
                return (pszFiles);
            }
            default :
            {
                break;
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertToNULLTerm
//
////////////////////////////////////////////////////////////////////////////

DWORD ConvertToNULLTerm(
    LPTSTR pchRead)
{
    LPTSTR pchWrite = pchRead;
    DWORD cFiles = 0;

    //  The input string is of  the form "file1.ext" "file2.ext" ... "filen.ext"
    //  convert this string of this form into doubly null terminated string
    //  ie file1.ext\0file2.ext\0....filen.ext\0\0
    for (; ;)
    {
        // Finds the end of the first file name in the list of
        // remaining file names.Also this function removes the initial
        // quote character
        LPTSTR pchEnd = FindEOF(pchRead);

        //
        //  Mark the end of the filename with a NULL.
        //
        if (*pchEnd)
        {
            *pchEnd = NULL;
            cFiles++;

            lstrcpy(pchWrite, pchRead);
            pchWrite += pchEnd - pchRead + 1;
        }
        else
        {
            //
            //  Found EOL.  Make sure we did not end with spaces.
            //
            if (*pchRead)
            {
                lstrcpy(pchWrite, pchRead);
                pchWrite += pchEnd - pchRead + 1;
                cFiles++;
            }

            break;
        }

        pchRead = pchEnd + 1;
    }

    //
    //  Double-NULL terminate.
    //
    *pchWrite = CHAR_NULL;

    return (cFiles);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelFocusEnumCB
//
////////////////////////////////////////////////////////////////////////////

typedef struct _SELFOCUS
{
    BOOL    bSelChange;
    UINT    idSaveButton;
    int     nSel;
    TEMPSTR sHidden;
    TEMPSTR sDisplayed;
} SELFOCUS;

BOOL SelFocusEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    if (!pidl)
    {
        return TRUE;
    }

    SELFOCUS *psf = (SELFOCUS *)lParam;
    TCHAR szBuf[MAX_PATH + 1];
    TCHAR szBufFriendly[MAX_PATH + 1];
    DWORD dwAttrs = SHGetAttributes(that->_psfCurrent, pidl, SFGAO_STORAGECAPMASK);

    if (dwAttrs)
    {
        if (_IsOpenContainer(dwAttrs))
        {
            psf->idSaveButton = iszFileOpenButton;
        }
        else
        {
            if (psf->bSelChange && (((that->_pOFN->Flags & OFN_ENABLEINCLUDENOTIFY) &&
                                     (that->_bSelIsObject =
                                      CD_SendIncludeItemNotify(that->_hSubDlg,
                                                                that->_hwndDlg,
                                                                that->_psfCurrent,
                                                                pidl,
                                                                that->_pOFN,
                                                                that->_pOFI))) ||
                                    (_IsStream(dwAttrs))))
            {
                ++psf->nSel;

                if (that->_pOFN->Flags & OFN_ALLOWMULTISELECT)
                {
                    //
                    //  Mark if this is an OBJECT we just selected.
                    //
                    if (that->_bSelIsObject)
                    {
                        ITEMIDLIST idl;

                        idl.mkid.cb = 0;

                        //
                        //  Get full path to this folder.
                        //
                        GetViewItemText(that->_psfCurrent, &idl, szBuf, ARRAYSIZE(szBuf), SHGDN_FORPARSING);
                        if (szBuf[0])
                        {
                            that->_pszObjectCurDir.StrCpy(szBuf);
                        }

                        //
                        //  Get full path to this item (in case we only get one
                        //  selection).
                        //
                        GetViewItemText(that->_psfCurrent, pidl, szBuf, ARRAYSIZE(szBuf), SHGDN_FORPARSING);
                        that->_pszObjectPath.StrCpy(szBuf);
                    }

                    *szBuf = CHAR_QUOTE;
                    GetViewItemText(that->_psfCurrent, pidl, szBuf + 1, ARRAYSIZE(szBuf) - 3);
                    lstrcat(szBuf, TEXT("\" "));

                    if (!psf->sHidden.StrCat(szBuf))
                    {
                        psf->nSel = -1;
                        return FALSE;
                    }

                    if (!that->_fShowExtensions)
                    {
                        LPTSTR pszExt = PathFindExtension(szBuf + 1);
                        if (*pszExt)
                        {
                            *pszExt = 0;
                            lstrcat(szBuf, TEXT("\" "));
                        }
                    }

                    if (!psf->sDisplayed.StrCat(szBuf))
                    {
                        psf->nSel = -1;
                        return FALSE;
                    }
                }
                else
                {
                    SHTCUTINFO info;

                    info.dwAttr      = SFGAO_FOLDER;
                    info.fReSolve    = FALSE;
                    info.pszLinkFile = NULL;
                    info.cchFile     = 0;
                    info.ppidl       = NULL; 

                    if ((that->GetLinkStatus(pidl, &info)) &&
                         (info.dwAttr & SFGAO_FOLDER))
                    {
                        // This means that the pidl is a link and the link points to a folder
                        // in this case  We Should not update the edit box and treat the link like 
                        // a directory
                        psf->idSaveButton = iszFileOpenButton;
                    }
                    else
                    {
                        TCHAR *pszFriendlyName = NULL;
                        GetViewItemText(that->_psfCurrent, pidl, szBuf, ARRAYSIZE(szBuf));

                        // Special case WIA folders. They want friendly names. Might want to do this for all
                        // folders, but that might cause app compat nightmare.
                        if (that->_IsWIAFolder(that->_psfCurrent))
                        {
                            GetViewItemText(that->_psfCurrent, pidl, szBufFriendly, ARRAYSIZE(szBufFriendly), SHGDN_INFOLDER);
                            pszFriendlyName = szBufFriendly;
                        }
                        else
                        {
                            IShellFolder *psfItem;
                            if (SUCCEEDED(that->_psfCurrent->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfItem))))
                            {
                                if (that->_IsWIAFolder(psfItem))
                                {
                                    GetViewItemText(that->_psfCurrent, pidl, szBufFriendly, ARRAYSIZE(szBufFriendly), SHGDN_INFOLDER);
                                    pszFriendlyName = szBufFriendly;
                                }
                                psfItem->Release();
                            }
                        }

                        that->SetEditFile(szBuf, pszFriendlyName, that->_fShowExtensions);
                        if (that->_bSelIsObject)
                        {
                            GetViewItemText(that->_psfCurrent, pidl, szBuf, ARRAYSIZE(szBuf), SHGDN_FORPARSING);
                            that->_pszObjectPath.StrCpy(szBuf);
                        }
                    }
                }
            }
        }
    }

    //if there is an item selected then cache that items pidl 
    Pidl_Set(&that->_pidlSelection,pidl);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SelFocusChange
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SelFocusChange(
    BOOL bSelChange)
{
    SELFOCUS sf;

    sf.bSelChange = bSelChange;
    sf.idSaveButton = iszFileSaveButton;
    sf.nSel = 0;

    _bSelIsObject = FALSE;

    EnumItemObjects(SVGIO_SELECTION, SelFocusEnumCB, (LPARAM)&sf);

    if (_pOFN->Flags & OFN_ALLOWMULTISELECT)
    {
        switch (sf.nSel)
        {
            case (-1) :
            {
                //
                //  Oops! We ran out of memory.
                //
                MessageBeep(0);
                return;
            }
            case (0) :
            {
                //
                //  No files selected; do not change edit control.
                //
                break;
            }
            case (1) :
            {
                //
                //  Strip off quotes so the single file case looks OK.
                //
                ConvertToNULLTerm(sf.sHidden);
                LPITEMIDLIST pidlSel = ILClone(_pidlSelection);
                SetEditFile(sf.sHidden, NULL, _fShowExtensions);
                if (pidlSel)
                {
                    // The SetEditFile above will nuke any _pidlSelection that was set as a result
                    // of EnumItemObjects, by causing a CBN_EDITCHANGE notification (edit box changed, so we
                    // think we should nuked the _pidlSelection - doh!).
                    // So here we restore it, if there was one set.
                    Pidl_Set(&_pidlSelection, pidlSel);

                    ILFree(pidlSel);
                }

                sf.idSaveButton = iszFileSaveButton;
                break;
            }
            default :
            {
                SetEditFile(sf.sDisplayed, NULL, TRUE);
                _pszHideExt.StrCpy(sf.sHidden);

                sf.idSaveButton = iszFileSaveButton;

                //More than one item selected so free selected item pidl
                Pidl_Set(&_pidlSelection,NULL);;

                break;
            }
        }
    }

    SetSaveButton(sf.idSaveButton);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelRenameCB
//
////////////////////////////////////////////////////////////////////////////

BOOL SelRenameCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    if (!pidl)
    {
        return TRUE;
    }

    Pidl_Set(&that->_pidlSelection, pidl);

    if (!SHGetAttributes(that->_psfCurrent, pidl, SFGAO_FOLDER))
    {
        //
        //  If it is not a folder then set the selection to nothing
        //  so that whatever is in the edit box will be used.
        //
        that->_psv->SelectItem(NULL, SVSI_DESELECTOTHERS);
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SelRename
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SelRename(void)
{
    EnumItemObjects(SVGIO_SELECTION, SelRenameCB, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnStateChange
//
//  Process selection change in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnStateChange(
    struct IShellView *ppshv,
    ULONG uChange)
{
    if (ppshv != _psv)
    {
        return (E_INVALIDARG);
    }

    switch (uChange)
    {
        case (CDBOSC_SETFOCUS) :
        {
            if (_bSave)
            {
                SelFocusChange(FALSE);
            }
            break;
        }
        case (CDBOSC_KILLFOCUS) :
        {
            SetSaveButton(iszFileSaveButton);
            break;
        }
        case (CDBOSC_SELCHANGE) :
        {
            //
            //  Post one of these messages, since we seem to get a whole bunch
            //  of them.
            //
            if (!_fSelChangedPending)
            {
                _fSelChangedPending = TRUE;
                PostMessage(_hwndDlg, CDM_SELCHANGE, 0, 0);
            }
            break;
        }
        case (CDBOSC_RENAME) :
        {
            SelRename();
            break;
        }
        default :
        {
            return (E_NOTIMPL);
        }
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::IncludeObject
//
//  Tell the view control which objects to include in its enumerations.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::IncludeObject(
    struct IShellView *ppshv,
    LPCITEMIDLIST pidl)
{
    if (ppshv != _psv)
    {
        return (E_INVALIDARG);
    }

    BOOL bIncludeItem = FALSE;

    //
    //  See if the callback is enabled.
    //
    if (_pOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        //
        //  See what the callback says.
        //
        bIncludeItem = BOOLFROMPTR(CD_SendIncludeItemNotify(_hSubDlg,
                                                        _hwndDlg,
                                                        _psfCurrent,
                                                        pidl,
                                                        _pOFN,
                                                        _pOFI));
    }

    if (!bIncludeItem)
    {
        DWORD dwAttrs = SHGetAttributes(_psfCurrent, pidl, SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STREAM | SFGAO_FILESYSTEM | SFGAO_FOLDER);
        bIncludeItem = _bSave ? _IncludeSaveItem(dwAttrs) : _IncludeOpenItem(dwAttrs);

        if (!bIncludeItem)
        {
            return (S_FALSE);
        }

        // Apply filter if this thing is filesystem or canmoniker, except:
        //  If it is an item that contains filesystem items (SFGAO_STORAGEANCESTOR - typical folder)
        //  OR if it is a folder that canmoniker (ftp folder)
        if (bIncludeItem && *_szLastFilter)
        {
            BOOL fContainer = _bSave ? _IsSaveContainer(dwAttrs) : _IsOpenContainer(dwAttrs);
            if (!fContainer)
            {
                GetViewItemText(_psfCurrent, (LPITEMIDLIST)pidl, _szBuf, ARRAYSIZE(_szBuf));

                if (!LinkMatchSpec(pidl, _szLastFilter) &&
                    !PathMatchSpec(_szBuf, _szLastFilter))
                {
                    return (S_FALSE);
                }
            }
        }
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::Notify
//
//  Notification to decide whether or not a printer should be selected.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::Notify(
    struct IShellView *ppshv,
    DWORD dwNotify)
{
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetDefaultMenuText
//
//  Returns the default menu text.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetDefaultMenuText(
    struct IShellView *ppshv,
    WCHAR *pszText,
    INT cchMax)
{
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetViewFlags
//
//  Returns Flags to customize the view .
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetViewFlags(DWORD *pdwFlags)
{
    DWORD dwFlags = 0;
    if (pdwFlags)
    {
        if (_pOFN->Flags & OFN_FORCESHOWHIDDEN)
        {
            dwFlags |= CDB2GVF_SHOWALLFILES;
        }
        
        *pdwFlags = dwFlags;
    }
    return S_OK;
}

//  Insert a single item into the location dropdown.

BOOL InsertItem(HWND hCtrl, int iItem, MYLISTBOXITEM *pItem, TCHAR *pszName)
{
    LPTSTR pszChar;

    for (pszChar = pszName; *pszChar != CHAR_NULL; pszChar = CharNext(pszChar))
    {
        if (pszChar - pszName >= MAX_DRIVELIST_STRING_LEN - 1)
        {
            *pszChar = CHAR_NULL;
            break;
        }
    }

    if (SendMessage(hCtrl, CB_INSERTSTRING, iItem, (LPARAM)(LPCTSTR)pszName) == CB_ERR)
    {
        return FALSE;
    }

    SendMessage(hCtrl, CB_SETITEMDATA, iItem, (LPARAM)pItem);
    return TRUE;
}

int CALLBACK LBItemCompareProc(void * p1, void * p2, LPARAM lParam)
{
    IShellFolder *psfParent = (IShellFolder *)lParam;
    MYLISTBOXITEM *pItem1 = (MYLISTBOXITEM *)p1;
    MYLISTBOXITEM *pItem2 = (MYLISTBOXITEM *)p2;
    HRESULT hres = psfParent->CompareIDs(0, pItem1->pidlThis, pItem2->pidlThis);
    return (short)SCODE_CODE(GetScode(hres));
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateLevel
//
//  Insert the contents of a shell container into the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::UpdateLevel(
    HWND hwndLB,
    int iInsert,
    MYLISTBOXITEM *pParentItem)
{
    if (!pParentItem)
    {
        return;
    }

    LPENUMIDLIST penum;
    HDPA hdpa;
    DWORD cIndent = pParentItem->cIndent + 1;
    IShellFolder *psfParent = pParentItem->GetShellFolder();
    if (!psfParent)
    {
        return;
    }

    hdpa = DPA_Create(4);
    if (!hdpa)
    {
        //
        //  No memory: Cannot enum this level.
        //
        return;
    }

    if (S_OK == psfParent->EnumObjects(hwndLB, SHCONTF_FOLDERS, &penum))
    {
        ULONG celt;
        LPITEMIDLIST pidl;

        while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
        {
            //
            //  Note: We need to avoid creation of pItem if this is not
            //  a file system object (or ancestor) to avoid extra
            //  bindings.
            //
            if (ShouldIncludeObject(this, psfParent, pidl, _pOFN->Flags))
            {
                MYLISTBOXITEM *pItem = new MYLISTBOXITEM();
                if (pItem)
                {
                    if (pItem->Init(GetDlgItem(_hwndDlg, cmb2), pParentItem, psfParent, pidl, cIndent, MLBI_PERMANENT | MLBI_PSFFROMPARENT, _pScheduler) &&
                        (DPA_AppendPtr(hdpa, pItem) >= 0))
                    {
                        //empty body
                    }
                    else
                    {
                        pItem->Release();
                    }
                }
            }
            SHFree(pidl);
        }
        penum->Release();
    }

    DPA_Sort(hdpa, LBItemCompareProc, (LPARAM)psfParent);

    int nLBIndex, nDPAIndex, nDPAItems;
    BOOL bCurItemGone;

    nDPAItems = DPA_GetPtrCount(hdpa);
    nLBIndex = iInsert;

    bCurItemGone = FALSE;

    //
    //  Make sure the user is not playing with the selection right now.
    //
    ComboBox_ShowDropdown(hwndLB, FALSE);

    //
    //  We're all sorted, so now we can do a merge.
    //
    for (nDPAIndex = 0; ; ++nDPAIndex)
    {
        MYLISTBOXITEM *pNewItem;
        TCHAR szBuf[MAX_DRIVELIST_STRING_LEN];
        MYLISTBOXITEM *pOldItem;

        if (nDPAIndex < nDPAItems)
        {
            pNewItem = (MYLISTBOXITEM *)DPA_FastGetPtr(hdpa, nDPAIndex);
        }
        else
        {
            //
            //  Signal that we got to the end of the list.
            //
            pNewItem = NULL;
        }

        for (pOldItem = GetListboxItem(hwndLB, nLBIndex);
             pOldItem != NULL;
             pOldItem = GetListboxItem(hwndLB, ++nLBIndex))
        {
            int nCmp;

            if (pOldItem->cIndent < cIndent)
            {
                //
                //  We went up a level, so insert here.
                //
                break;
            }
            else if (pOldItem->cIndent > cIndent)
            {
                //
                //  We went down a level so ignore this.
                //
                continue;
            }

            //
            //  Set this to 1 at the end of the DPA to clear out deleted items
            //  at the end.
            //
            nCmp = !pNewItem
                       ? 1
                       : LBItemCompareProc(pNewItem,
                                            pOldItem,
                                            (LPARAM)psfParent);
            if (nCmp < 0)
            {
                //
                //  We found the first item greater than the new item, so
                //  add it in.
                //
                break;
            }
            else if (nCmp > 0)
            {
                //
                //  Oops! It looks like this item no longer exists, so
                //  delete it.
                //
                for (; ;)
                {
                    if (pOldItem == _pCurrentLocation)
                    {
                        bCurItemGone = TRUE;
                        _pCurrentLocation = NULL;
                    }

                    pOldItem->Release();
                    SendMessage(hwndLB, CB_DELETESTRING, nLBIndex, NULL);

                    pOldItem = GetListboxItem(hwndLB, nLBIndex);

                    if (!pOldItem || pOldItem->cIndent <= cIndent)
                    {
                        break;
                    }
                }

                //
                //  We need to continue from the current position, not the
                //  next.
                //
                --nLBIndex;
            }
            else
            {
                //
                //  This item already exists, so no need to add it.
                //  Make sure we do not check this LB item again.
                //
                pOldItem->dwFlags |= MLBI_PERMANENT;
                ++nLBIndex;
                goto NotThisItem;
            }
        }

        if (!pNewItem)
        {
            //
            //  Got to the end of the list.
            //
            break;
        }

        GetViewItemText(psfParent, pNewItem->pidlThis, szBuf, ARRAYSIZE(szBuf), SHGDN_NORMAL);
        if (szBuf[0] && InsertItem(hwndLB, nLBIndex, pNewItem, szBuf))
        {
            ++nLBIndex;
        }
        else
        {
NotThisItem:
            pNewItem->Release();
        }
    }

    DPA_Destroy(hdpa);

    if (bCurItemGone)
    {
        //
        //  If we deleted the current selection, go back to the desktop.
        //
        ComboBox_SetCurSel(hwndLB, 0);
        OnSelChange(-1, TRUE);
    }

    _iCurrentLocation = ComboBox_GetCurSel(hwndLB);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClearListbox
//
//  Clear the location dropdown and delete all entries.
//
////////////////////////////////////////////////////////////////////////////

void ClearListbox(
    HWND hwndList)
{
    SendMessage(hwndList, WM_SETREDRAW, FALSE, NULL);
    int cItems = (int) SendMessage(hwndList, CB_GETCOUNT, NULL, NULL);
    while (cItems--)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndList, 0);
        if (pItem)
            pItem->Release();
        SendMessage(hwndList, CB_DELETESTRING, 0, NULL);
    }
    SendMessage(hwndList, WM_SETREDRAW, TRUE, NULL);
    InvalidateRect(hwndList, NULL, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitFilterBox
//
//  Places the double null terminated list of filters in the combo box.
//
//  The list consists of pairs of null terminated strings, with an
//  additional null terminating the list.
//
////////////////////////////////////////////////////////////////////////////

DWORD InitFilterBox(
    HWND hDlg,
    LPCTSTR lpszFilter)
{
    DWORD nIndex = 0;
    UINT nLen;
    HWND hCmb = GetDlgItem(hDlg, cmb1);

    if (hCmb)
    {
        while (*lpszFilter)
        {
            //
            //  First string put in as string to show.
            //
            nIndex = ComboBox_AddString(hCmb, lpszFilter);

            nLen = lstrlen(lpszFilter) + 1;
            lpszFilter += nLen;

            //
            //  Second string put in as itemdata.
            //
            ComboBox_SetItemData(hCmb, nIndex, lpszFilter);

            //
            //  Advance to next element.
            //
            nLen = lstrlen(lpszFilter) + 1;
            lpszFilter += nLen;
        }
    }

    //
    //  nIndex could be CB_ERR, which could cause problems.
    //
    if (nIndex == CB_ERR)
    {
        nIndex = 0;
    }

    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  MoveControls
//
////////////////////////////////////////////////////////////////////////////

void MoveControls(
    HWND hDlg,
    BOOL bBelow,
    int nStart,
    int nXMove,
    int nYMove)
{
    HWND hwnd;
    RECT rcWnd;

    if (nXMove == 0 && nYMove == 0)
    {
        //
        //  Quick out if nothing to do.
        //
        return;
    }

    for (hwnd = GetWindow(hDlg, GW_CHILD);
         hwnd;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        GetWindowRect(hwnd, &rcWnd);
        MapWindowRect(HWND_DESKTOP, hDlg, &rcWnd);

        if (bBelow)
        {
            if (rcWnd.top < nStart)
            {
                continue;
            }
        }
        else
        {
            if (rcWnd.left < nStart)
            {
                continue;
            }
        }

        SetWindowPos(hwnd,
                      NULL,
                      rcWnd.left + nXMove,
                      rcWnd.top + nYMove,
                      0,
                      0,
                      SWP_NOZORDER | SWP_NOSIZE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DummyDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK DummyDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case (WM_INITDIALOG) :
        {
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
                  --------
                 | Cancel |
                  --------    --
                                |
                  --------      |
x Open As Read   | Help   |     |  Height by which all controls below view needs to be moved
                  --------      |  and also height by which View window height should be increased.
                              --

*/

void CFileOpenBrowser::ReAdjustDialog()
{
    int iDelta = 0;
    RECT rc1,rc2;
    

    //Make sure all our assumptions  are valid    
    if ((_iVersion < OPENFILEVERSION_NT5) || //if this dialog version is less than NT5  or
        IsWindowEnabled(GetDlgItem(_hwndDlg, chx1))  || // if Open As Read Only is still enabled or
        IsWindowEnabled(GetDlgItem(_hwndDlg, pshHelp))) // If the Help button is still enabled  then
    {
        //Dont do anything
        return ;
    }

    GetWindowRect(GetDlgItem(_hwndDlg, pshHelp), &rc1);
    GetWindowRect(GetDlgItem(_hwndDlg, IDCANCEL), &rc2);

    //Add the height of the button
    iDelta +=  RECTHEIGHT(rc1);

    //Add the gap between buttons
    iDelta +=  rc1.top - rc2.bottom;

    RECT rcView;
    GetWindowRect(GetDlgItem(_hwndDlg, lst1), &rcView);
    MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcView);

    HDWP hdwp;
    hdwp = BeginDeferWindowPos(10);

    HWND hwnd;
    RECT rc;

    hwnd = ::GetWindow(_hwndDlg, GW_CHILD);
    
    while (hwnd && hdwp)
    {
        GetWindowRect(hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, _hwndDlg, &rc);

        switch (GetDlgCtrlID(hwnd))
        {
            case pshHelp:
            case chx1:
                break;

            default :
                //
                //  See if the control needs to be adjusted.
                //
                if (rc.top > rcView.bottom)
                {
                    //Move Y position of these controls
                    hdwp = DeferWindowPos(hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left,
                                           rc.top + iDelta,
                                           RECTWIDTH(rc),
                                           RECTHEIGHT(rc),
                                           SWP_NOZORDER);
                }
        }
        hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
   }

    //Adjust the size of the view window
    if (hdwp)
    {
            hdwp = DeferWindowPos(hdwp,
                                   GetDlgItem(_hwndDlg, lst1),
                                   NULL,
                                   rcView.left,
                                   rcView.top,
                                   RECTWIDTH(rcView),
                                   RECTHEIGHT(rcView) + iDelta,
                                   SWP_NOZORDER);

    }

    EndDeferWindowPos(hdwp);

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ResetDialogHeight
//
//  Hack for Borland JBuilder Professional (pah!)
//
//  These guys relied on a bug in Win95/NT4's Comdlg32 that we fixed in IE4.
//  So instead of reintroducing the bug, we detect that they are relying
//  on the bug and hack around them.
//
//  These guys do a SetWindowLong(GWL_STYLE) on the dialog box and
//  then reparent it!  Unfortunately, they didn't quite get their
//  bookkeeping right:  They forgot to do a RedrawWindow after removing
//  the WS_CAPTION style.  You see, just editing the style doesn't do
//  anything - the style changes don't take effect until the next
//  RedrawWindow.  When they scratched their heads ("Hey, why is
//  the caption still there?"), they decided to brute-force the
//  solution:  They slide the window so the caption goes "off the screen".
//
//  Problem:  We fixed a bug for IE4 where ResetDialogHeight would screw
//  up and not resize the dialog when it should've, if the app did a
//  SetWindowPos on the window to change its vertical position downward
//  by more than the amount we needed to grow.
//
//  So now when we resize it properly, this generates an internal
//  RedrawWindow, which means that Borland's brute-force hack tries
//  to fix a problem that no longer exists!
//
//  Therefore, ResetDialogHeight now checks if the app has
//
//      1. Changed the dialog window style,
//      2. Moved the dialog downward by more than we needed to grow,
//      3. Forgotten to call RedrawWindow.
//
//  If so, then we temporarily restore the original dialog window style,
//  do the (correct) resize, then restore the window style.  Reverting
//  the window style means that all the non-client stuff retains its old
//  (incorrect, but what the app is expecting) size.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ResetDialogHeight(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    int nCtlsBottom)
{
    POINT ptCurrent;
    int topNew;
    GetControlsArea(hDlg, hwndExclude, hwndGrip, &ptCurrent, &topNew);

    int nDiffBottom = nCtlsBottom - ptCurrent.y;

    if (nDiffBottom > 0)
    {
        RECT rcFull;
        int Height;

        GetWindowRect(hDlg, &rcFull);
        Height = RECTHEIGHT(rcFull) - nDiffBottom;
        if (Height >= ptCurrent.y)
        {
            // Borland JBuilder hack!  This SetWindowPos will generate
            // a RedrawWindow which the app might not be expecting.
            // Detect this case and create a set of temporary styles
            // which will neutralize the frame recalc implicit in the
            // RedrawWindow.
            //
            LONG lStylePrev;
            BOOL bBorlandHack = FALSE;
            if (!_bAppRedrawn &&            // App didn't call RedrawWindow
                _topOrig + nCtlsBottom <= topNew + ptCurrent.y) // Win95 didn't resize
            {
                // Since the app didn't call RedrawWindow, it still
                // thinks that there is a WS_CAPTION.  So put the caption
                // back while we do frame recalcs.
                bBorlandHack = TRUE;
                lStylePrev = GetWindowLong(hDlg, GWL_STYLE);
                SetWindowLong(hDlg, GWL_STYLE, lStylePrev | WS_CAPTION);
            }

            SetWindowPos(hDlg,
                          NULL,
                          0,
                          0,
                          RECTWIDTH(rcFull),
                          Height,
                          SWP_NOZORDER | SWP_NOMOVE);

            if (bBorlandHack)
            {
                // Restore the original style after we temporarily
                // messed with it.
                SetWindowLong(hDlg, GWL_STYLE, lStylePrev);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreateHookDialog
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::CreateHookDialog(
    POINT *pPtSize)
{
    DWORD Flags = _pOFN->Flags;
    BOOL bRet = FALSE;
    HANDLE hTemplate;
    HINSTANCE hinst;
    LPCTSTR lpDlg;
    HWND hCtlCmn;
    RECT rcReal, rcSub, rcToolbar, rcAppToolbar;
    int nXMove, nXRoom, nYMove, nYRoom, nXStart, nYStart;
    DWORD dwStyle;
    DLGPROC lpfnHookProc;

    if (!(Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        //
        //  No hook or template; nothing to do.
        //
        ResetDialogHeight(_hwndDlg, NULL, _hwndGrip, pPtSize->y);
        GetWindowRect(_hwndDlg, &rcReal);
        _ptLastSize.x = rcReal.right - rcReal.left;
        _ptLastSize.y = rcReal.bottom - rcReal.top;
        return TRUE;
    }

    if (Flags & OFN_ENABLETEMPLATEHANDLE)
    {
        hTemplate = _pOFN->hInstance;
        hinst = ::g_hinst;
    }
    else
    {
        if (Flags & OFN_ENABLETEMPLATE)
        {
            if (!_pOFN->lpTemplateName)
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
                return FALSE;
            }
            if (!_pOFN->hInstance)
            {
                StoreExtendedError(CDERR_NOHINSTANCE);
                return FALSE;
            }

            lpDlg = _pOFN->lpTemplateName;
            hinst = _pOFN->hInstance;
        }
        else
        {
            hinst = ::g_hinst;
            lpDlg = MAKEINTRESOURCE(DUMMYFILEOPENORD);
        }

        HRSRC hRes = FindResource(hinst, lpDlg, RT_DIALOG);

        if (hRes == NULL)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return FALSE;
        }
        if ((hTemplate = LoadResource(hinst, hRes)) == NULL)
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return FALSE;
        }
    }

    if (!LockResource(hTemplate))
    {
        StoreExtendedError(CDERR_LOADRESFAILURE);
        return FALSE;
    }

    dwStyle = ((LPDLGTEMPLATE)hTemplate)->style;
    if (!(dwStyle & WS_CHILD))
    {
        //
        //  I don't want to go poking in their template, and I don't want to
        //  make a copy, so I will just fail.  This also helps us weed out
        //  "old-style" templates that were accidentally used.
        //
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return FALSE;
    }

    if (Flags & OFN_ENABLEHOOK)
    {
        lpfnHookProc = (DLGPROC)GETHOOKFN(_pOFN);
    }
    else
    {
        lpfnHookProc = DummyDlgProc;
    }

    //
    //  WOW apps are not allowed to get the new explorer look, so there
    //  is no need to do any special WOW checking before calling the create
    //  dialog function.
    //

    if (_pOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameW2A(_pOFI);
        _hSubDlg = CreateDialogIndirectParamA(hinst,
                                              (LPDLGTEMPLATE)hTemplate,
                                              _hwndDlg,
                                              lpfnHookProc,
                                              (LPARAM)(_pOFI->pOFNA));
        ThunkOpenFileNameA2W(_pOFI);
    }
    else
    {
        _hSubDlg = CreateDialogIndirectParam(hinst,
                                             (LPDLGTEMPLATE)hTemplate,
                                             _hwndDlg,
                                             lpfnHookProc,
                                             (LPARAM)_pOFN);
    }

    if (!_hSubDlg)
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return FALSE;
    }

    //
    //  We reset the height of the dialog after creating the hook dialog so
    //  the hook can hide controls in its WM_INITDIALOG message.
    //
    ResetDialogHeight(_hwndDlg, _hSubDlg, _hwndGrip, pPtSize->y);

    //
    //  Now move all of the controls around.
    //
    GetClientRect(_hwndDlg, &rcReal);
    GetClientRect(_hSubDlg, &rcSub);

    hCtlCmn = GetDlgItem(_hSubDlg, stc32);
    if (hCtlCmn)
    {
        RECT rcCmn;

        GetWindowRect(hCtlCmn, &rcCmn);
        MapWindowRect(HWND_DESKTOP, _hSubDlg, &rcCmn);


        //
        //  Move the controls in our dialog to make room for the hook's
        //  controls above and to the left.
        //
        MoveControls(_hwndDlg, FALSE, 0, rcCmn.left, rcCmn.top);

        //
        //  Calculate how far sub dialog controls need to move, and how much
        //  more room our dialog needs.
        //
        nXStart = rcCmn.right;
        nYStart = rcCmn.bottom;

        //See how far part the cotrols are in the template
        nXMove = (rcReal.right - rcReal.left) - (rcCmn.right - rcCmn.left);
        nYMove = (rcReal.bottom - rcReal.top) - (rcCmn.bottom - rcCmn.top);

        //See how much room we need to leave at the bottom and right
        // for the sub dialog controls at the botton and right
        nXRoom = rcSub.right - (rcCmn.right - rcCmn.left);
        nYRoom = rcSub.bottom - (rcCmn.bottom - rcCmn.top);

        if (nXMove < 0)
        {
            //
            //  If the template size is too big, we need more room in the
            //  dialog.
            //
            nXRoom -= nXMove;
            nXMove = 0;
        }
        if (nYMove < 0)
        {
            //
            //  If the template size is too big, we need more room in the
            //  dialog.
            //
            nYRoom -= nYMove;
            nYMove = 0;
        }

        //
        //  Resize the "template" control so the hook knows the size of our
        //  stuff.
        //
        SetWindowPos(hCtlCmn,
                      NULL,
                      0,
                      0,
                      rcReal.right - rcReal.left,
                      rcReal.bottom - rcReal.top,
                      SWP_NOMOVE | SWP_NOZORDER);
    }
    else
    {
        //
        //  Extra controls go on the bottom by default.
        //
        nXStart = nYStart = nXMove = nXRoom = 0;

        nYMove = rcReal.bottom;
        nYRoom = rcSub.bottom;
    }

    MoveControls(_hSubDlg, FALSE, nXStart, nXMove, 0);
    MoveControls(_hSubDlg, TRUE, nYStart, 0, nYMove);

    //
    //  Resize our dialog and the sub dialog.
    //  FEATURE: We need to check whether part of the dialog is off screen.
    //
    GetWindowRect(_hwndDlg, &rcReal);

    _ptLastSize.x = (rcReal.right - rcReal.left) + nXRoom;
    _ptLastSize.y = (rcReal.bottom - rcReal.top) + nYRoom;

    SetWindowPos(_hwndDlg,
                  NULL,
                  0,
                  0,
                  _ptLastSize.x,
                  _ptLastSize.y,
                  SWP_NOZORDER | SWP_NOMOVE);

    //
    //  Note that we are moving this to (0,0) and the bottom of the Z order.
    //
    GetWindowRect(_hSubDlg, &rcReal);
    SetWindowPos(_hSubDlg,
                  HWND_BOTTOM,
                  0,
                  0,
                  (rcReal.right - rcReal.left) + nXMove,
                  (rcReal.bottom - rcReal.top) + nYMove,
                  0);

    ShowWindow(_hSubDlg, SW_SHOW);

    CD_SendInitDoneNotify(_hSubDlg, _hwndDlg, _pOFN, _pOFI);

    //
    //  Make sure the toolbar is still large enough.  Apps like Visio move
    //  the toolbar control and may make it too small now that we added the
    //  View Desktop toolbar button.
    //
    if (_hwndToolbar && IsVisible(_hwndToolbar))
    {
        LONG Width;

        //
        //  Get the default toolbar coordinates.
        //
        GetControlRect(_hwndDlg, stc1, &rcToolbar);

        //
        //  Get the app adjusted toolbar coordinates.
        //
        GetWindowRect(_hwndToolbar, &rcAppToolbar);
        MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcAppToolbar);

        //
        //  See if the default toolbar size is greater than the current
        //  toolbar size.
        //
        Width = rcToolbar.right - rcToolbar.left;
        if (Width > (rcAppToolbar.right - rcAppToolbar.left))
        {
            //
            //  Set rcToolbar to be the new toolbar rectangle.
            //
            rcToolbar.left   = rcAppToolbar.left;
            rcToolbar.top    = rcAppToolbar.top;
            rcToolbar.right  = rcAppToolbar.left + Width;
            rcToolbar.bottom = rcAppToolbar.bottom;

            //
            //  Get the dialog coordinates.
            //
            GetWindowRect(_hwndDlg, &rcReal);
            MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcReal);

            //
            //  Make sure the new toolbar doesn't go off the end of
            //  the dialog.
            //
            if (rcToolbar.right < rcReal.right)
            {
                //
                //  Make sure there are no controls to the right of the
                //  toolbar that overlap the new toolbar.
                //
                for (hCtlCmn = ::GetWindow(_hwndDlg, GW_CHILD);
                     hCtlCmn;
                     hCtlCmn = ::GetWindow(hCtlCmn, GW_HWNDNEXT))
                {
                    if ((hCtlCmn != _hwndToolbar) && IsVisible(hCtlCmn))
                    {
                        RECT rcTemp;

                        //
                        //  Get the coordinates of the window.
                        //
                        GetWindowRect(hCtlCmn, &rcSub);
                        MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcSub);

                        //
                        //  If the App's toolbar rectangle does not
                        //  intersect the window and the the new toolbar
                        //  does intersect the window, then we cannot
                        //  increase the size of the toolbar.
                        //
                        if (!IntersectRect(&rcTemp, &rcAppToolbar, &rcSub) &&
                            IntersectRect(&rcTemp, &rcToolbar, &rcSub))
                        {
                            break;
                        }
                    }
                }

                //
                //  Reset the size of the toolbar if there were no conflicts.
                //
                if (!hCtlCmn)
                {
                    ::SetWindowPos(_hwndToolbar,
                                    NULL,
                                    rcToolbar.left,
                                    rcToolbar.top,
                                    Width,
                                    rcToolbar.bottom - rcToolbar.top,
                                    SWP_NOACTIVATE | SWP_NOZORDER |
                                      SWP_SHOWWINDOW);
                }
            }
        }
    }

    bRet = TRUE;

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSaveAsControls
//
//  Change the captions of a bunch of controls to say saveas-like things.
//
////////////////////////////////////////////////////////////////////////////

const struct
{
    UINT idControl;
    UINT idString;
} aSaveAsControls[] =
{
    { (UINT)-1, iszFileSaveTitle },         // -1 means the dialog itself
    { stc2,     iszSaveAsType },
    { IDOK,     iszFileSaveButton },
    { stc4,     iszFileSaveIn }
};

void InitSaveAsControls(
    HWND hDlg)
{
    for (UINT iControl = 0; iControl < ARRAYSIZE(aSaveAsControls); iControl++)
    {
        HWND hwnd = hDlg;
        TCHAR szText[80];

        if (aSaveAsControls[iControl].idControl != -1)
        {
            hwnd = GetDlgItem(hDlg, aSaveAsControls[iControl].idControl);
        }

        CDLoadString(g_hinst,
                    aSaveAsControls[iControl].idString,
                    szText,
                    ARRAYSIZE(szText));
        SetWindowText(hwnd, szText);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetControlsArea
//
//  Returns the leftmost edge and bottom-most edge of the
//  controls farthest right and down (in screen coordinates).
//
////////////////////////////////////////////////////////////////////////////

void
GetControlsArea(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    POINT *pPtSize,
    LPINT pTop)
{
    RECT rc;
    HWND hwnd;
    int uBottom;
    int uRight;

    uBottom = 0x80000000;
    uRight  = 0x80000000;

    for (hwnd = GetWindow(hDlg, GW_CHILD);
         hwnd;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        //
        //  Note we cannot use IsWindowVisible, since the parent is not visible.
        //  We do not want the magic static to be included.
        //
        if (!IsVisible(hwnd) || (hwnd == hwndExclude) || (hwnd == hwndGrip))
        {
            continue;
        }

        GetWindowRect(hwnd, &rc);
        if (uRight < rc.right)
        {
            uRight = rc.right;
        }
        if (uBottom < rc.bottom)
        {
            uBottom = rc.bottom;
        }
    }

    GetWindowRect(hDlg, &rc);

    pPtSize->x = uRight - rc.left;
    pPtSize->y = uBottom - rc.top;

    if (pTop)
        *pTop = rc.top;
}

// Initializes the Look In Drop Down combobox

BOOL CFileOpenBrowser::InitLookIn(HWND hDlg)
{
    TCHAR szScratch[MAX_PATH];
    LPITEMIDLIST pidl;
    IShellFolder *psf;
    
    HWND hCtrl = GetDlgItem(hDlg, cmb2);
    
    // Add the History Location.
    
    if (_iVersion >= OPENFILEVERSION_NT5)
    {
        int iImage, iSelectedImage;
        
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_RECENT, &pidl)))
        {
            LPITEMIDLIST pidlLast;
            IShellFolder *psfParent;
            HRESULT hr = CDBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), (LPCITEMIDLIST *)&pidlLast);
            if (SUCCEEDED(hr))
            {
                DWORD dwAttribs = SHGetAttributes(psfParent, pidlLast, SFGAO_STORAGECAPMASK | SFGAO_SHARE);
                
                //Get the image corresponding to this pidl
                iImage = SHMapPIDLToSystemImageListIndex(psfParent, pidlLast, &iSelectedImage);
                
                hr = psfParent->BindToObject(pidlLast, NULL, IID_PPV_ARG(IShellFolder, &psf));
                if (SUCCEEDED(hr))
                {
                    MYLISTBOXITEM *pItem = new MYLISTBOXITEM();
                    if (pItem)
                    {
                        pItem->Init(GetDlgItem(_hwndDlg, cmb2), psf, pidl, 0, MLBI_PERMANENT, dwAttribs, iImage, iSelectedImage);
                        
                        DisplayNameOf(psfParent, pidlLast, SHGDN_INFOLDER, szScratch, ARRAYSIZE(szScratch));
                        
                        if (!InsertItem(hCtrl, 0, pItem, szScratch))
                        {
                            pItem->Release();
                        }
                        else
                        {
                            //Update the index of Desktop in Look In dropdown from 0 to 1
                            _iNodeDesktop = 1;
                        }
                    }
                    psf->Release();
                }
                psfParent->Release();
            }
            SHFree(pidl);
        }
    }
    
    BOOL bRet = FALSE;
    
    // Insert the Desktop in the Lookin dropdown
    
    if (SUCCEEDED(SHGetDesktopFolder(&psf)))
    {
        pidl = SHCloneSpecialIDList(hDlg, CSIDL_DESKTOP, FALSE);
        if (pidl)
        {
            // Add the desktop item
            MYLISTBOXITEM *pItem = new MYLISTBOXITEM();
            if (pItem)
            {
                if (pItem->Init(GetDlgItem(_hwndDlg, cmb2), NULL, psf, pidl, 0, MLBI_PERMANENT, _pScheduler))
                {
                    GetViewItemText(psf, NULL, szScratch, ARRAYSIZE(szScratch));
                    if (InsertItem(hCtrl, _iNodeDesktop, pItem, szScratch))
                    {
                        pItem->AddRef();
                        _pCurrentLocation = pItem;
                        bRet = TRUE;
                    }
                }
                pItem->Release();
            }
            SHFree(pidl);
        }
        psf->Release();
    }
    
    if (!bRet)
    {
        ClearListbox(hCtrl);
    }
    
    return bRet;
}

//  Main initialization (WM_INITDIALOG phase).

BOOL InitLocation(HWND hDlg, LPOFNINITINFO poii)
{
    HWND hCtrl = GetDlgItem(hDlg, cmb2);
    LPOPENFILENAME lpOFN = poii->lpOFI->pOFN;
    BOOL fIsSaveAs = poii->bSave;
    POINT ptSize;

    GetControlsArea(hDlg, NULL, NULL, &ptSize, NULL);

    CFileOpenBrowser *pDlgStruct = new CFileOpenBrowser(hDlg, FALSE);
    if (pDlgStruct == NULL)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return FALSE;
    }
    StoreBrowser(hDlg, pDlgStruct);

    if ((poii->lpOFI->iVersion < OPENFILEVERSION_NT5) &&
         (poii->lpOFI->pOFN->Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        pDlgStruct->_iVersion = OPENFILEVERSION_NT4;
    }
 

    //See if we need to use dropdown combobox or edit box for filename
    if (pDlgStruct->_iVersion >= OPENFILEVERSION_NT5)
    {
        pDlgStruct->EnableFileMRU(!IsRestricted(REST_NOFILEMRU));
    }
    else
    {
        pDlgStruct->EnableFileMRU(FALSE);
    }

    pDlgStruct->CreateToolbar();

    GetControlsArea(hDlg, NULL, NULL, &ptSize, &pDlgStruct->_topOrig);

    if (!pDlgStruct->InitLookIn(hDlg))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return FALSE;
    }
    pDlgStruct->_pOFN = lpOFN;
    pDlgStruct->_bSave = fIsSaveAs;

    pDlgStruct->_pOFI = poii->lpOFI;

    pDlgStruct->_pszDefExt.StrCpy(lpOFN->lpstrDefExt);

    //
    //  Here follows all the caller-parameter-based initialization.
    //
    pDlgStruct->_lpOKProc = (WNDPROC)::SetWindowLongPtr(::GetDlgItem(hDlg, IDOK),
                                           GWLP_WNDPROC,
                                           (LONG_PTR)OKSubclass);

    if (lpOFN->Flags & OFN_CREATEPROMPT)
    {
        lpOFN->Flags |= (OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);
    }
    else if (lpOFN->Flags & OFN_FILEMUSTEXIST)
    {
        lpOFN->Flags |= OFN_PATHMUSTEXIST;
    }

    //
    //  We need to make sure the Ansi flags are up to date.
    //
    if (poii->lpOFI->ApiType == COMDLG_ANSI)
    {
        poii->lpOFI->pOFNA->Flags = lpOFN->Flags;
    }

    //
    //  Limit the text to the maximum path length instead of limiting it to
    //  the buffer length.  This allows users to type ..\..\.. and move
    //  around when the app gives an extremely small buffer.
    //
    if (pDlgStruct->_bUseCombo)
    {
        SendDlgItemMessage(hDlg, cmb13, CB_LIMITTEXT, MAX_PATH -1, 0);
    }
    else
    {
        SendDlgItemMessage(hDlg, edt1, EM_LIMITTEXT, MAX_PATH - 1, 0);
    }

    SendDlgItemMessage(hDlg, cmb2, CB_SETEXTENDEDUI, 1, 0);
    SendDlgItemMessage(hDlg, cmb1, CB_SETEXTENDEDUI, 1, 0);

    //
    //  Save original directory for later restoration, if necessary.
    //
    pDlgStruct->_szStartDir[0] = TEXT('\0');
    GetCurrentDirectory(ARRAYSIZE(pDlgStruct->_szStartDir),
                         pDlgStruct->_szStartDir);

    //
    //  Initialize all provided filters.
    //
    if (lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter)
    {
        SendDlgItemMessage(hDlg,
                            cmb1,
                            CB_INSERTSTRING,
                            0,
                            (LONG_PTR)lpOFN->lpstrCustomFilter);
        SendDlgItemMessage(hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            0,
                            (LPARAM)(lpOFN->lpstrCustomFilter +
                                     lstrlen(lpOFN->lpstrCustomFilter) + 1));
        SendDlgItemMessage(hDlg,
                            cmb1,
                            CB_LIMITTEXT,
                            (WPARAM)(lpOFN->nMaxCustFilter),
                            0L);
    }
    else
    {
        //
        //  Given no custom filter, the index will be off by one.
        //
        if (lpOFN->nFilterIndex != 0)
        {
            lpOFN->nFilterIndex--;
        }
    }

    //
    //  Listed filters next.
    //
    if (lpOFN->lpstrFilter)
    {
        if (lpOFN->nFilterIndex > InitFilterBox(hDlg, lpOFN->lpstrFilter))
        {
            lpOFN->nFilterIndex = 0;
        }
    }
    else
    {
        lpOFN->nFilterIndex = 0;
    }

    //
    //  If an entry exists, select the one indicated by nFilterIndex.
    //
    if ((lpOFN->lpstrFilter) ||
        (lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter))
    {
        HWND hCmb1 = GetDlgItem(hDlg, cmb1);

        ComboBox_SetCurSel(hCmb1, lpOFN->nFilterIndex);

        pDlgStruct->RefreshFilter(hCmb1);
    }

    //Check if this Object Open Dialog
    if (lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        //Yes, change the text so that it looks like a object open
        TCHAR szTemp[256];

        //Change the File &Name:  to Object &Name:
        CDLoadString((HINSTANCE)g_hinst, iszObjectName, (LPTSTR)szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, stc3), szTemp);

        //Change the Files of &type:  to  Objects of &type:
        CDLoadString((HINSTANCE)g_hinst, iszObjectType, (LPTSTR)szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, stc2), szTemp);

    }


    //
    //  Make sure to do this before checking if there is a title specified.
    //
    if (fIsSaveAs)
    {
        //
        //  Note we can do this even if there is a hook/template.
        //
        InitSaveAsControls(hDlg);

        // In Save As Dialog there is no need for Open As Read Only. 
        HideControl(hDlg, chx1);
    }

    if (lpOFN->lpstrTitle && *lpOFN->lpstrTitle)
    {
        SetWindowText(hDlg, lpOFN->lpstrTitle);
    }

    // BOOL Variables to check whether both the Hide Read only and Help button 
    // are being hidden. if so we need to readjust the dialog to reclaim the space 
    // occupied by these two controls
    BOOL  fNoReadOnly = FALSE;
    BOOL  fNoHelp = FALSE;

    if (lpOFN->Flags & OFN_HIDEREADONLY)
    {
        HideControl(hDlg, chx1);
        fNoReadOnly = TRUE;
    }
    else
    {
        CheckDlgButton(hDlg, chx1, (lpOFN->Flags & OFN_READONLY) ? 1 : 0);        
    }

    if (!(lpOFN->Flags & OFN_SHOWHELP))
    {
        HideControl(hDlg, pshHelp);
        fNoHelp = TRUE;
    }

    if (fNoReadOnly && fNoHelp)
    {
        //Readjust the dialog to reclaim space occupied by the Open as Read Only and Help Button controls
        pDlgStruct->ReAdjustDialog();
    }
    RECT rc;

    ::GetClientRect(hDlg, &rc);

    //
    //  If sizing is enabled, then we need to create the sizing grip.
    //
    if (pDlgStruct->_bEnableSizing = poii->bEnableSizing)
    {
        pDlgStruct->_hwndGrip =
            CreateWindow(TEXT("Scrollbar"),
                          NULL,
                          WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_GROUP |
                            WS_CLIPCHILDREN | SBS_BOTTOMALIGN | SBS_SIZEGRIP |
                            SBS_SIZEBOXBOTTOMRIGHTALIGN,
                          rc.right - g_cxGrip,
                          rc.bottom - g_cyGrip,
                          g_cxGrip,
                          g_cyGrip,
                          hDlg,
                          (HMENU)-1,
                          g_hinst,
                          NULL);
    }

    if (!pDlgStruct->CreateHookDialog(&ptSize))
    {
        return FALSE;
    }

    // Create Placebar right after Creating Hook Dialog as we need to get information
    // from the Hook Procedure if any customization needs to be done
    if ((pDlgStruct->_iVersion >= OPENFILEVERSION_NT5) &&
        (!IsRestricted(REST_NOPLACESBAR)) && (!IS_NEW_OFN(lpOFN) || !(lpOFN->FlagsEx & OFN_EX_NOPLACESBAR))
      )
    {
        pDlgStruct->_hwndPlacesbar = pDlgStruct->CreatePlacesbar(pDlgStruct->_hwndDlg);
    }
    else
    {
        pDlgStruct->_hwndPlacesbar = NULL;
    }

    GetWindowRect(pDlgStruct->_hwndDlg, &rc);
    pDlgStruct->_ptMinTrack.x = rc.right - rc.left;
    pDlgStruct->_ptMinTrack.y = rc.bottom - rc.top;

    if (pDlgStruct->_bUseCombo)
    {
        HWND hwndComboBox = GetDlgItem(hDlg, cmb13);
        if (hwndComboBox)
        {
            HWND hwndEdit = (HWND)SendMessage(hwndComboBox, CBEM_GETEDITCONTROL, 0, 0L);
            AutoComplete(hwndEdit, &(pDlgStruct->_pcwd), 0);

            //
            //  Explicitly set the focus since this is no longer the first item
            //  in the dialog template and it will start AutoComplete.
            //
            SetFocus(hwndComboBox);
        }

    }
    else
    {
        HWND hwndEdit = GetDlgItem(hDlg, edt1);
        if (hwndEdit)
        {
            AutoComplete(hwndEdit, &(pDlgStruct->_pcwd), 0);

            //
            //  Explicitly set the focus since this is no longer the first item
            //  in the dialog template and it will start AutoComplete.
            //
            SetFocus(hwndEdit);
        }
    }

    // Before jumping to a particular directory, Create the travel log
    Create_TravelLog(&pDlgStruct->_ptlog);

    //  jump to the first ShellFolder
    LPCTSTR lpInitialText = pDlgStruct->JumpToInitialLocation(lpOFN->lpstrInitialDir, lpOFN->lpstrFile);

    //  make sure we jumped somewhere.
    if (!pDlgStruct->_psv)
    {
        //
        //  This would be very bad.
        //
        //  DO NOT CALL StoreExtendedError() here!  Corel Envoy relies
        //  on receiving exactly FNERR_INVALIDFILENAME when it passes
        //  an invalid filename.
        //
        ASSERT(GetStoredExtendedError());
        return FALSE;
    }

    //
    //  Read the cabinet state.  If the full title is enabled, then add
    //  the tooltip.  Otherwise, don't bother as they obviously don't care.
    //
    CABINETSTATE cCabState;

    //
    //  Will set defaults if cannot read registry.
    //
    ReadCabinetState(&cCabState, SIZEOF(cCabState));

    if (cCabState.fFullPathTitle)
    {
        pDlgStruct->_hwndTips = CreateWindow(TOOLTIPS_CLASS,
                                             NULL,
                                             WS_POPUP | WS_GROUP | TTS_NOPREFIX,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             hDlg,
                                             NULL,
                                             ::g_hinst,
                                             NULL);
        if (pDlgStruct->_hwndTips)
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR)hCtrl;
            ti.hinst = NULL;
            ti.lpszText = LPSTR_TEXTCALLBACK;

            SendMessage(pDlgStruct->_hwndTips,
                         TTM_ADDTOOL,
                         0,
                         (LPARAM)&ti);
        }
    }

    //
    //  Show the window after creating the ShellView so we do not get a
    //  big ugly gray spot.
    //  if we have cached in the size of previously opened  dialog then use
    //  the size and position of that window.

    if (pDlgStruct->_bEnableSizing && (g_rcDlg.right > g_rcDlg.left))
    {
        ::SetWindowPos(hDlg,
                        NULL,
                        g_rcDlg.left,
                        g_rcDlg.top,
                        g_rcDlg.right - g_rcDlg.left,
                        g_rcDlg.bottom - g_rcDlg.top,
                        0);
    }
    else
    {
        ::ShowWindow(hDlg, SW_SHOW);
        ::UpdateWindow(hDlg);
    }

    if (lpInitialText)
    {
        //
        //  This is the one time I will show a file spec, since it would be
        //  too strange to have "All Files" showing in the Type box, while
        //  only text files are in the view.
        //
        pDlgStruct->SetEditFile(lpInitialText, NULL, pDlgStruct->_fShowExtensions, FALSE);
        SelectEditText(hDlg);
    }

    return TRUE;
}

BOOL IsValidPath(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    lstrcpyn(szPath, pszPath, SIZECHARS(szPath));

    int nFileOffset = ParseFileNew(szPath, NULL, FALSE, TRUE);

    //
    //  Is the filename invalid?
    //
    if ((nFileOffset < 0) &&
         (nFileOffset != PARSE_EMPTYSTRING))
    {
    
        return FALSE;
    }

    return TRUE;
}


BOOL CFileOpenBrowser::_IsRestrictedDrive(LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    TCHAR szDrivePath[5]; // Don't need much... just want a drive letter.
    BOOL bRet = FALSE;

    DWORD dwRest = SHRestricted(REST_NOVIEWONDRIVE);
    if (dwRest)
    {
        // There are some drive restrictions.

        // Convert pidl, if supplied, to full path.
        if (pidl)
        {
            if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szDrivePath, ARRAYSIZE(szDrivePath), NULL)))
            {
                pszPath = szDrivePath;
            }
        }
        
        if (pszPath)
        {
            int iDrive = PathGetDriveNumber(pszPath);
            if (iDrive != -1)
            {
                // is the drive restricted
                if (dwRest & (1 << iDrive))
                {
                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}

// When the dialog first appears, we want to prevent the the pop message that appears from
// CFSFolder if you try to navigate to a drive that has been restricted due to group policy.
// So in these cases, we do the group policy check before attempting to navigate there.
void CFileOpenBrowser::JumpToLocationIfUnrestricted(LPCTSTR pszPath, LPCITEMIDLIST pidl, BOOL bTranslate)
{
    if (!_IsRestrictedDrive(pszPath, pidl))
    {
        if (pszPath)
        {
            JumpToPath(pszPath, bTranslate);
        }
        else if (pidl)
        {
            JumpToIDList(pidl, bTranslate);
        }
    }
}



LPCTSTR CFileOpenBrowser::JumpToInitialLocation(LPCTSTR pszDir, LPTSTR pszFile)
{
    //
    //  Check out if the filename contains a path.  If so, override whatever
    //  is contained in pszDir.  Chop off the path and put up only
    //  the filename.
    //
    TCHAR szDir[MAX_PATH];
    LPCTSTR pszRet = NULL;
    BOOL fFileIsTemp = PathIsTemporary(pszFile);

    szDir[0] = 0;

    //If we have  a Directory specified then use that Directory.
    if (pszDir)
    {
        ExpandEnvironmentStrings(pszDir, szDir, ARRAYSIZE(szDir));
    }

    //Check to see if the pszFile contains a Path.
    if (pszFile && *pszFile)
    {
        //  clean up the path a little
        PathRemoveBlanks(pszFile);

        //  WARNING - this must me some kind of APPCOMPAT thing - ZekeL - 13-AUG-98
        //  Apps that are not UNC-aware often pass <C:\\server\share> and
        //  we want to change it to the prettier <\\server\share>. - raymondc
        if (DBL_BSLASH(pszFile + 2) &&
             (*(pszFile + 1) == CHAR_COLON))
        {
            lstrcpy(pszFile, pszFile + 2);
        }

        pszRet = PathFindFileName(pszFile);
        if (IsValidPath(pszFile))
        {
            if (IsWild(pszRet))
            {
                SetCurrentFilter(pszRet);
            }

            if (!fFileIsTemp)
            {
                DWORD cch = pszRet ? (unsigned long) (pszRet-pszFile) : ARRAYSIZE(szDir);
                cch = min(cch, ARRAYSIZE(szDir));

                //  this will null terminate for us on
                //  the backslash if pszRet was true
                StrCpyN(szDir, pszFile, cch);
            }
        }
        else if (!(_pOFN->Flags & OFN_NOVALIDATE))
        {
            // Failed validation and app wanted validation
            StoreExtendedError(FNERR_INVALIDFILENAME);
            return NULL;
        }
        else
        {
            // Failed validation but app suppressed validation,
            // so continue onward with the "filename" part of the
            // pszFile (even though it's not valid).
        }
    }

    // if we have a directory  then use that directory
    if (*szDir)
    {
        JumpToLocationIfUnrestricted(szDir, NULL, TRUE);
    }

    // See if this application contains a entry in the registry for the last visited Directory
    if (!_psv)
    {
        // Change the return value to full incoming name.
        if (!fFileIsTemp)
            pszRet = pszFile;

        if (GetPathFromLastVisitedMRU(szDir, ARRAYSIZE(szDir)))
        {
           JumpToLocationIfUnrestricted(szDir, NULL, TRUE);
        }
    }

    // Try Current Directory
    if (!_psv)
    {
       //Does current directory contain any files that match the filter ?
       if (GetCurrentDirectory(ARRAYSIZE(szDir), szDir)
           && !PathIsTemporary(szDir) && FoundFilterMatch(_szLastFilter, IsVolumeLFN(NULL)))
       {
           //Yes. Jump to Current Directory.
           JumpToLocationIfUnrestricted(szDir, NULL, TRUE);
       }
    }

    // Try My Documents
    if (!_psv)
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl)))
        {
            JumpToLocationIfUnrestricted(NULL, pidl, FALSE);
            ILFree(pidl);
        }
    }

    //  finally try the desktop - don't check for restriction here.
    if (!_psv)
    {
        ITEMIDLIST idl = { 0 };

        //  Do not try to translate this.
        JumpToIDList(&idl, FALSE);
    }

    //  If nothing worked, then set the error code so our parent knows.
    if (!_psv)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
    }

    //Add the initial directory where we jumped to the travel log
    if (_ptlog && _pCurrentLocation && _pCurrentLocation->pidlFull)
    {
        _ptlog->AddEntry(_pCurrentLocation->pidlFull);
    }

    return pszRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  _CleanupDialog
//
//  Dialog cleanup, memory deallocation.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::_CleanupDialog(BOOL fRet)
{
    ASSERT(!_cRefCannotNavigate);
    if (_pOFN->lpstrCustomFilter)
    {
        UINT len = lstrlen(_pOFN->lpstrCustomFilter) + 1;
        UINT sCount = lstrlen(_szLastFilter);
        if (_pOFN->nMaxCustFilter > sCount + len)
        {
            lstrcpy(_pOFN->lpstrCustomFilter + len, _szLastFilter);
        }
    }

    if ((fRet == TRUE) && _hSubDlg &&
         (CD_SendOKNotify(_hSubDlg, _hwndDlg, _pOFN, _pOFI) ||
           CD_SendOKMsg(_hSubDlg, _pOFN, _pOFI)))
    {
        //  Give the hook a chance to validate the file name.
        return;
    }

    //  We need to make sure the IShellBrowser is still around during
    //  destruction.
    if (_psv)
    {
        _psv->DestroyViewWindow();
        ATOMICRELEASE(_psv);
    }

    if (((_pOFN->Flags & OFN_NOCHANGEDIR) || g_bUserPressedCancel) &&
        (*_szStartDir))
    {
        SetCurrentDirectory(_szStartDir);
    }


    ::EndDialog(_hwndDlg, fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetParentItem
//
//  Given an item index in the location dropdown, get its parent item.
//
////////////////////////////////////////////////////////////////////////////

MYLISTBOXITEM *GetParentItem(HWND hwndCombo, int *piItem)
{
    int iItem = *piItem;
    MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

    if (pItem)
    {
        for (--iItem; iItem >= 0; iItem--)
        {
            MYLISTBOXITEM *pPrev = GetListboxItem(hwndCombo, iItem);
            if (pPrev && pPrev->cIndent < pItem->cIndent)
            {
                *piItem = iItem;
                return (pPrev);
            }
        }
    }

    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFullPathEnumCB
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFullPathEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{

    if (pidl)
    {
        LPITEMIDLIST pidlFull = ILCombine(that->_pCurrentLocation->pidlFull, pidl);
        if (pidlFull)
        {
            SHGetPathFromIDList(pidlFull, (LPTSTR)lParam);
            ILFree(pidlFull);
        }
        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetFullPath
//
//  Calculate the full path to the selected object in the view.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::GetFullPath(
    LPTSTR pszBuf)
{
    *pszBuf = CHAR_NULL;

    EnumItemObjects(SVGIO_SELECTION, GetFullPathEnumCB, (LPARAM)pszBuf);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RemoveOldPath
//
//  Removes old path elements from the location dropdown.  *piNewSel is the
//  listbox index of the leaf item which the caller wants to save.  All non-
//  permanent items that are not ancestors of that item are deleted.  The
//  index is updated appropriately if any items before it are deleted.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RemoveOldPath(
    int *piNewSel)
{
    HWND hwndCombo = ::GetDlgItem(_hwndDlg, cmb2);
    int iStart = *piNewSel;
    int iItem;
    UINT cIndent = 0;
    int iSubOnDel = 0;

    //
    //  Flush all non-permanent non-ancestor items before this one.
    //
    for (iItem = ComboBox_GetCount(hwndCombo) - 1; iItem >= 0; --iItem)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

        if (iItem == iStart)
        {
            //
            //  Begin looking for ancestors and adjusting the sel position.
            //
            iSubOnDel = 1;
            cIndent = pItem->cIndent;
            continue;
        }

        if (pItem->cIndent < cIndent)
        {
            //
            //  We went back a level, so this must be an ancestor of the
            //  selected item.
            //
            cIndent = pItem->cIndent;
            continue;
        }

        //
        //  Make sure to check this after adjusting cIndent.
        //
        if (pItem->dwFlags & MLBI_PERMANENT)
        {
            continue;
        }

        SendMessage(hwndCombo, CB_DELETESTRING, iItem, NULL);
        pItem->Release();
        *piNewSel -= iSubOnDel;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FindLocation
//
//  Given a listbox item, find the index.
//  Just a linear search, but we shouldn't have more than ~10-20 items.
//
////////////////////////////////////////////////////////////////////////////

int FindLocation(
    HWND hwndCombo,
    MYLISTBOXITEM *pFindItem)
{
    int iItem;

    for (iItem = ComboBox_GetCount(hwndCombo) - 1; iItem >= 0; --iItem)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

        if (pItem == pFindItem)
        {
            break;
        }
    }

    return (iItem);
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnSelChange
//
//  Process the selection change in the location dropdown.
//
//  Chief useful feature is that it removes the items for the old path.
//  Returns TRUE only if it was possible to switch to the specified item.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OnSelChange(
    int iItem,
    BOOL bForceUpdate)
{
    HWND hwndCombo = GetDlgItem(_hwndDlg, cmb2);
    BOOL bRet = TRUE;

    if (iItem == -1)
    {
        iItem = (int) SendMessage(hwndCombo, CB_GETCURSEL, NULL, NULL);
    }

    MYLISTBOXITEM *pNewLocation = GetListboxItem(hwndCombo, iItem);
    MYLISTBOXITEM *pOldLocation = _pCurrentLocation;
    BOOL bFirstTry = TRUE;
    BOOL bSwitchedBack = FALSE;

    if (bForceUpdate || (pNewLocation != pOldLocation))
    {
        FOLDERSETTINGS fs;

        if (_psv)
        {
            _psv->GetCurrentInfo(&fs);
        }
        else
        {
            fs.ViewMode = FVM_LIST;
            fs.fFlags = _pOFN->Flags & OFN_ALLOWMULTISELECT ? 0 : FWF_SINGLESEL;
        }

        //  we always want the recent folder to come up
        //  in details mode
        //  We also want the My Pictures folder and it's subfolders to comeup in ThumbView.
        //  So, let's detect if the current and new locations are any of these special folders.
        LOCTYPE  NewLocType = (pNewLocation ? _GetLocationType(pNewLocation) : LOCTYPE_OTHERS);
        LOCTYPE  CurLocType = (_pCurrentLocation ? _GetLocationType(_pCurrentLocation) : LOCTYPE_OTHERS);

        const SHELLVIEWID *pvid = NULL; //Most of the time this will continue to be null;
        SHELLVIEWID  vidCurrent = {0};
        BOOL fUseDefaultView = FALSE;
        switch (NewLocType)
        {
            case LOCTYPE_MYPICTURES_FOLDER:
                if (CurLocType == LOCTYPE_MYPICTURES_FOLDER)
                {
                    IShellView2  *psv2;
                    //We need to get the current pvid
                    //Note: the end-user could have changed this view.
                    pvid = &VID_Thumbnails; //Assume this by default.
                    
                    if (SUCCEEDED(_psv->QueryInterface(IID_PPV_ARG(IShellView2, &psv2))))
                    {
                        if (SUCCEEDED(psv2->GetView(&vidCurrent, SV2GV_CURRENTVIEW)))
                            pvid = &vidCurrent;

                        psv2->Release();
                    }
                }
                else
                {
                    //We are moving to My pictures folder or sub-folder; set the thumb nail view.
                    pvid = &VID_Thumbnails;

                    //If we are moving from other folders, save the ViewMode.
                    if (CurLocType == LOCTYPE_OTHERS)
                    {
                        _CachedViewMode = fs.ViewMode;
                        _fCachedViewFlags = fs.fFlags;
                    }
                }
                break;

            case LOCTYPE_RECENT_FOLDER:
            
                //We are moving to Recent folder.
                if (CurLocType == LOCTYPE_OTHERS)
                {
                    _CachedViewMode = fs.ViewMode;
                    _fCachedViewFlags = fs.fFlags;
                }
                fs.ViewMode = FVM_DETAILS;
                
                break;

            case LOCTYPE_WIA_FOLDER:
                if (CurLocType == LOCTYPE_OTHERS)
                {
                    _CachedViewMode = fs.ViewMode;
                    _fCachedViewFlags = fs.fFlags;
                }

                // ask view for default view for WIA extentions
                fUseDefaultView = TRUE;
                break;

            case LOCTYPE_OTHERS:
                //Check if we are coming from Recent, My Pictures, or WIA folders,
                // and restore the viewmode we had before that.
                if (CurLocType != LOCTYPE_OTHERS)
                {
                    fs.ViewMode = _CachedViewMode;
                    fs.fFlags = _fCachedViewFlags;
                }
                    
                break;
        }
        
        _iCurrentLocation = iItem;
        _pCurrentLocation = pNewLocation;

OnSelChange_TryAgain:
        if (!_pCurrentLocation || FAILED(SwitchView(_pCurrentLocation->GetShellFolder(),
                                                   _pCurrentLocation->pidlFull,
                                                   &fs, 
                                                   pvid, 
                                                   fUseDefaultView)))
        {
            //
            //  We could not create the view for this location.
            //
            bRet = FALSE;

            //
            //  Try the previous folder.
            //
            if (bFirstTry)
            {
                bFirstTry = FALSE;
                _pCurrentLocation = pOldLocation;
                int iOldItem = FindLocation(hwndCombo, pOldLocation);
                if (iOldItem >= 0)
                {
                    _iCurrentLocation = iOldItem;
                    ComboBox_SetCurSel(hwndCombo, _iCurrentLocation);

                    if (_psv)
                    {
                        bSwitchedBack = TRUE;
                        goto SwitchedBack;
                    }
                    else
                    {
                        goto OnSelChange_TryAgain;
                    }
                }
            }

            //
            //  Try the parent of the old item.
            //
            if (_iCurrentLocation)
            {
                _pCurrentLocation = GetParentItem(hwndCombo, &_iCurrentLocation);
                if (_pCurrentLocation)
                {
                    ComboBox_SetCurSel(hwndCombo, _iCurrentLocation);
                    goto OnSelChange_TryAgain;
                }
            }

            //
            //  We cannot create the Desktop view.  I think we are in
            //  real trouble.  We had better bail out.
            //
            StoreExtendedError(CDERR_DIALOGFAILURE);
            _CleanupDialog(FALSE);
            return FALSE;
        }

        //if _iCurrentLocation is _iNodeDesktop then it means we are at Desktop so disable  the IDC_PARENT button
        ::SendMessage(_hwndToolbar,
                       TB_SETSTATE,
                       IDC_PARENT,
                       ((_iCurrentLocation == _iNodeDesktop) || (_iCurrentLocation == 0)) ? 0 :TBSTATE_ENABLED);

        if (_IsSaveContainer(_pCurrentLocation->dwAttrs))
        {
            _pCurrentLocation->SwitchCurrentDirectory(_pcwd);
        }


        TCHAR szFile[MAX_PATH + 1];
        int nFileOffset;

        //
        //  We've changed folders; we'd better strip whatever is in the edit
        //  box down to the file name.
        //
        if (_bUseCombo)
        {
            HWND hwndEdit = (HWND)SendMessage(GetDlgItem(_hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
            GetWindowText(hwndEdit, szFile, ARRAYSIZE(szFile));
        }
        else
        {
            GetDlgItemText(_hwndDlg, edt1, szFile, ARRAYSIZE(szFile));
        }

        nFileOffset = ParseFileNew(szFile, NULL, FALSE, TRUE);

        if (nFileOffset > 0 && !IsDirectory(szFile))
        {
            //
            //  The user may have typed an extension, so make sure to show it.
            //
            SetEditFile(szFile + nFileOffset, NULL, TRUE);
        }

        SetSaveButton(iszFileSaveButton);

SwitchedBack:
        RemoveOldPath(&_iCurrentLocation);
    }

    if (!bSwitchedBack && _hSubDlg)
    {
        CD_SendFolderChangeNotify(_hSubDlg, _hwndDlg, _pOFN, _pOFI);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDotDot
//
//  Process the open-parent-folder button on the toolbar.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnDotDot()
{
    HWND hwndCombo = GetDlgItem(_hwndDlg, cmb2);

    int iItem = ComboBox_GetCurSel(hwndCombo);

    MYLISTBOXITEM *pItem = GetParentItem(hwndCombo, &iItem);

    SendMessage(hwndCombo, CB_SETCURSEL, iItem, NULL);

    //
    //  Delete old path from combo.
    //
    OnSelChange();
    UpdateNavigation();
}

////////////////////////////////////////////////////////////////////////////
//
//  DblClkEnumCB
//
////////////////////////////////////////////////////////////////////////////

#define PIDL_NOTHINGSEL      (LPCITEMIDLIST)0
#define PIDL_MULTIPLESEL     (LPCITEMIDLIST)-1
#define PIDL_FOLDERSEL       (LPCITEMIDLIST)-2

BOOL DblClkEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    MYLISTBOXITEM *pLoc = that->_pCurrentLocation;
    LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)lParam;

    if (!pidl)
    {
        pidl = *ppidl;

        if (pidl == PIDL_NOTHINGSEL)
        {
            //
            //  Nothing selected.
            //
            return FALSE;
        }

        if (pidl == PIDL_MULTIPLESEL)
        {
            //
            //  More than one thing selected.
            //
            return FALSE;
        }

        // check if the pidl is a container (ie, a folder)
        if (IsContainer(that->_psfCurrent, pidl))
        {
            LPITEMIDLIST pidlDest =  ILCombine(pLoc->pidlFull,pidl);

            if (pidlDest)
            {
                that->JumpToIDList(pidlDest);
                SHFree(pidlDest);
            }

            *ppidl = PIDL_FOLDERSEL;
        }
        else if (IsLink(that->_psfCurrent,pidl))
        {
            //
            // This link might be pointing to a folder in which case 
            // we want to go ahead and open it. If the link points
            // to a file then its taken care of in ProcessEdit command.
            //
            SHTCUTINFO info;
            LPITEMIDLIST  pidlLinkTarget = NULL;
            
            info.dwAttr      = SFGAO_FOLDER;
            info.fReSolve    = FALSE;
            info.pszLinkFile = NULL;
            info.cchFile     = 0;
            info.ppidl       = &pidlLinkTarget;
             
             //psf can be NULL in which case ResolveLink uses _psfCurrent IShellFolder
             if (SUCCEEDED(that->ResolveLink(pidl, &info, that->_psfCurrent)))
             {
                 if (info.dwAttr & SFGAO_FOLDER)
                 {
                     that->JumpToIDList(pidlLinkTarget);
                     *ppidl = PIDL_FOLDERSEL;
                 }
                 Pidl_Set(&pidlLinkTarget, NULL);
             }
            
        }

        return FALSE;
    }

    if (*ppidl)
    {
        //
        //  More than one thing selected.
        //
        *ppidl = PIDL_MULTIPLESEL;
        return FALSE;
    }

    *ppidl = pidl;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDblClick
//
//  Process a double-click in the view control, either by choosing the
//  selected non-container object or by opening the selected container.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnDblClick(
    BOOL bFromOKButton)
{
    LPCITEMIDLIST pidlFirst = PIDL_NOTHINGSEL;

    //if we have a saved pidl then use it instead
    if (_pidlSelection && _ProcessPidlSelection())
    {
        return;
    }

    if (_psv)
    {
        EnumItemObjects(SVGIO_SELECTION, DblClkEnumCB, (LPARAM)&pidlFirst);
    }

    if (pidlFirst == PIDL_NOTHINGSEL)
    {
        //
        //  Nothing selected.
        //
        if (bFromOKButton)
        {
            //
            //  This means we got an IDOK when the focus was in the view,
            //  but nothing was selected.  Let's get the edit text and go
            //  from there.
            //
            ProcessEdit();
        }
    }
    else if (pidlFirst != PIDL_FOLDERSEL)
    {
        //
        //  This will change the edit box, but that's OK, since it probably
        //  already has.  This should take care of files with no extension.
        //
        SelFocusChange(TRUE);

        //
        //  This part will take care of resolving links.
        //
        ProcessEdit();
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::JumpToPath
//
//  Refocus the entire dialog on a different directory.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::JumpToPath(LPCTSTR pszDirectory, BOOL bTranslate)
{
    TCHAR szTemp[MAX_PATH + 1];
    TCHAR szCurDir[MAX_PATH + 1];

    //
    //  This should do the whole job of canonicalizing the directory.
    //
    GetCurrentDirectory(ARRAYSIZE(szCurDir), szCurDir);
    PathCombine(szTemp, szCurDir, pszDirectory);

    LPITEMIDLIST pidlNew = ILCreateFromPath(szTemp);

    if (pidlNew == NULL)
    {
        return FALSE;
    }

    //
    //  Need to make sure the pidl points to a folder. If not, then remove
    //  items from the end until we find one that is.
    //  This must be done before the translation.
    //    
    DWORD dwAttrib;
    do
    {
        dwAttrib = SFGAO_FOLDER;

        SHGetAttributesOf(pidlNew, &dwAttrib);

        if (!(dwAttrib & SFGAO_FOLDER))
        {
           ILRemoveLastID(pidlNew);
        }

    } while(!(dwAttrib & SFGAO_FOLDER) && !ILIsEmpty(pidlNew));

    if (!(dwAttrib & SFGAO_FOLDER))
    {
        SHFree(pidlNew);
        return FALSE;
    }

    BOOL bRet = JumpToIDList(pidlNew, bTranslate);

    SHFree(pidlNew);

    return bRet;
}



////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::JumpTOIDList
//
//  Refocus the entire dialog on a different IDList.
//
//  Parameter:
//    bTranslate        specifies whether the given pidl should be translated to
//                      logical pidl
//    bAddToNavStack    specifies whether the pidl given for jumping should be
//                      added to the back/forward navigation stack
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::JumpToIDList(
    LPCITEMIDLIST pidlNew,
    BOOL bTranslate,
    BOOL bAddToNavStack)
{
    LPITEMIDLIST pidlLog = NULL;

    if (bTranslate)
    {
        //
        //  Translate IDList's on the Desktop into the appropriate
        //  logical IDList.
        //
        pidlLog = SHLogILFromFSIL(pidlNew);
        if (pidlLog)
        {
            pidlNew = pidlLog;
        }
    }

    //
    //  Find the entry in the location dropdown that is the closest parent
    //  to the new location.
    //
    HWND hwndCombo = ::GetDlgItem(_hwndDlg, cmb2);
    MYLISTBOXITEM *pBestParent = GetListboxItem(hwndCombo, 0);
    int iBestParent = 0;
    LPCITEMIDLIST pidlRelative = pidlNew;

    UINT cIndent = 0;
    BOOL fExact = FALSE;

    for (UINT iItem = 0; ; iItem++)
    {
        MYLISTBOXITEM *pNextItem = GetListboxItem(hwndCombo, iItem);
        if (pNextItem == NULL)
        {
            break;
        }
        if (pNextItem->cIndent != cIndent)
        {
            //
            //  Not the depth we want.
            //
            continue;
        }

        if (ILIsEqual(pNextItem->pidlFull, pidlNew))
        {
            // Never treat FTP Pidls as Equal because the username/password may
            // have changed so we need to do the navigation.  The two pidls
            // still pass ILIsEqual() because the server name is the same.
            // This is required for a different back compat bug.
            if (!ILIsFTP(pidlNew))
                fExact = TRUE;

            break;
        }
        LPCITEMIDLIST pidlChild = ILFindChild(pNextItem->pidlFull, pidlNew);
        if (pidlChild != NULL)
        {
            pBestParent = pNextItem;
            iBestParent = iItem;
            cIndent++;
            pidlRelative = pidlChild;
        }
    }

    //
    //  The path provided might have matched an existing item exactly.  In
    //  that case, just select the item.
    //
    if (fExact)
    {
        goto FoundIDList;
    }

    //
    //  Now, pBestParent is the closest parent to the item, iBestParent is
    //  its index, and cIndent is the next appropriate indent level.  Begin
    //  creating new items for the rest of the path.
    //
    iBestParent++;                // begin inserting after parent item
    for (; ;)
    {
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidlRelative);
        if (pidlFirst == NULL)
        {
            break;
        }

        MYLISTBOXITEM *pNewItem = new MYLISTBOXITEM();
        if (pNewItem)
        {
            if (!pNewItem->Init(GetDlgItem(_hwndDlg, cmb2),
                                pBestParent,
                                pBestParent->GetShellFolder(),
                                pidlFirst,
                                cIndent,
                                MLBI_PSFFROMPARENT,
                                _pScheduler))
            {
                pNewItem->Release();
                pNewItem = NULL;
                //iBestParent is off by 1 in error case . Correct it
                iBestParent--;
                break;
            }
        }
        else
        {
            //iBestParent is off by 1 in error case . Correct it
            iBestParent--;
            break;
        }

        GetViewItemText(pBestParent->psfSub, pidlFirst, _szBuf, ARRAYSIZE(_szBuf), SHGDN_NORMAL);
        InsertItem(hwndCombo, iBestParent, pNewItem, _szBuf);
        SHFree(pidlFirst);
        pidlRelative = ILGetNext(pidlRelative);
        if (ILIsEmpty(pidlRelative))
        {
            break;
        }
        cIndent++;                // next one is indented one more level
        iBestParent++;            // and inserted after this one
        pBestParent = pNewItem;   // and is a child of the one we just inserted
    }

    iItem = iBestParent;

FoundIDList:
    if (pidlLog)
    {
        SHFree(pidlLog);
    }

    SendMessage(hwndCombo, CB_SETCURSEL, iItem, NULL);
    BOOL bRet = OnSelChange(iItem, TRUE);

    //Update our Navigation stack
    if (bRet && bAddToNavStack)
    {
        UpdateNavigation();
    }

    //We naviagated to a new location so invalidate the cached Pidl
    Pidl_Set(&_pidlSelection,NULL);

    return bRet;

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ViewCommand
//
//  Process the new-folder button on the toolbar.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ViewCommand(
    UINT uIndex)
{
    IContextMenu *pcm;

    if (SUCCEEDED(_psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm))))
    {
        CMINVOKECOMMANDINFOEX ici = {0};

        ici.cbSize = sizeof(ici);
        ici.fMask = 0L;
        ici.hwnd = _hwndDlg;
        ici.lpVerb = ::c_szCommandsA[uIndex];
        ici.lpParameters = NULL;
        ici.lpDirectory = NULL;
        ici.nShow = SW_NORMAL;
        ici.lpParametersW = NULL;
        ici.lpDirectoryW = NULL;
        ici.lpVerbW = ::c_szCommandsW[uIndex];
        ici.fMask |= CMIC_MASK_UNICODE;

        IObjectWithSite *pObjSite = NULL;

        if (SUCCEEDED(pcm->QueryInterface(IID_IObjectWithSite, (void**)&pObjSite)))
        {
            pObjSite->SetSite(SAFECAST(_psv,IShellView*));
        }


        HMENU hmContext = CreatePopupMenu();
        pcm->QueryContextMenu(hmContext, 0, 1, 256, 0);
        pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));

        if (pObjSite)
        {
            pObjSite->SetSite(NULL);
            pObjSite->Release();
        }

        DestroyMenu(hmContext);
        pcm->Release();

    }
}


//

HRESULT CFileOpenBrowser::ResolveLink(LPCITEMIDLIST pidl, PSHTCUTINFO pinfo, IShellFolder *psf)
{
    BOOL fSetPidl = TRUE;

    //Do we have IShellFolder passed to us ?
    if (!psf)
    {
        //No use our current shell folder.
        psf =  _psfCurrent;
    }

    //Get the IShellLink interface pointer corresponding to given file
    IShellLink *psl;
    HRESULT hres = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLink, 0, &psl));
    if (SUCCEEDED(hres))
    {
        //Resolve the link
        if (pinfo->fReSolve)
        {
            hres = psl->Resolve(_hwndDlg, 0);

            //If the resolve failed then we can't get correct pidl
            if (hres == S_FALSE)
            {
                fSetPidl = FALSE;
            }
        }
        
        if (SUCCEEDED(hres))
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(psl->GetIDList(&pidl)) && pidl)
            {
                if (pinfo->dwAttr)
                    hres = SHGetAttributesOf(pidl, &pinfo->dwAttr);

                if (SUCCEEDED(hres) && pinfo->pszLinkFile)
                {
                    // caller wants the path, this may be empty
                    hres = psl->GetPath(pinfo->pszLinkFile, pinfo->cchFile, 0, 0);
                }

                if (pinfo->ppidl && fSetPidl)
                    *(pinfo->ppidl) = pidl;
                else
                    ILFree(pidl);
            }
            else
                hres = E_FAIL;      // gota have a pidl
        }
        psl->Release();
    }

    if (FAILED(hres))
    {
        if (pinfo->pszLinkFile)
            *pinfo->pszLinkFile = 0;

        if (pinfo->ppidl && *pinfo->ppidl)
        {
            ILFree(*pinfo->ppidl);
            *pinfo->ppidl = NULL;
        }

        pinfo->dwAttr = 0;
    }

    return hres;
}

//
//      This function checks to see if the pidl given is a link and if so resolves the 
//      link 
//  PARAMETERS :
// 
//      LPCITEMIDLIST pidl -  the pidl which we want to check for link
//      LPTSTR   pszLinkFile - if the pidl points to a link then this contains the  resolved file 
//                             name
//      UINT     cchFile -  size of the buffer pointed by the  pszLinkFile
//
//  RETURN VALUE :
//      returns  TRUE    if the pidl is link  and was able to resolve the link successfully
//      returns  FALSE   if the pidl is not link  or if the link was not able to resolve successfully.
//                       In this case pszLinkFile  and pfd are not valid.

BOOL CFileOpenBrowser::GetLinkStatus(LPCITEMIDLIST pidl, PSHTCUTINFO pinfo)
{
    if (IsLink(_psfCurrent, pidl))
    {
        return SUCCEEDED(ResolveLink(pidl, pinfo));
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::LinkMatchSpec
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::LinkMatchSpec(LPCITEMIDLIST pidl, LPCTSTR pszSpec)
{
    TCHAR szFile[MAX_PATH];
    SHTCUTINFO info;

    info.dwAttr       = SFGAO_FOLDER;
    info.fReSolve     = FALSE;
    info.pszLinkFile  = szFile;
    info.cchFile      = ARRAYSIZE(szFile);
    info.ppidl        = NULL; 

    if (GetLinkStatus(pidl, &info))
    {
        if ((info.dwAttr & SFGAO_FOLDER) ||
            (szFile[0] && PathMatchSpec(szFile, pszSpec)))
        {
            return TRUE;
        }
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  MeasureDriveItems
//
//  Standard owner-draw code for the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

#define MINIDRIVE_MARGIN     4
#define MINIDRIVE_WIDTH      (g_cxSmIcon)
#define MINIDRIVE_HEIGHT     (g_cySmIcon)
#define DRIVELIST_BORDER     3

void MeasureDriveItems(
    HWND hwndDlg,
    MEASUREITEMSTRUCT *lpmi)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = (HFONT)SelectObject(hdc,
                                    (HFONT)SendMessage(hwndDlg,
                                                        WM_GETFONT,
                                                        0,
                                                        0));

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
    ReleaseDC(NULL, hdc);

    dyDriveItem += DRIVELIST_BORDER;
    if (dyDriveItem < MINIDRIVE_HEIGHT)
    {
        dyDriveItem = MINIDRIVE_HEIGHT;
    }

    lpmi->itemHeight = dyDriveItem;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::PaintDriveLine
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::PaintDriveLine(
    DRAWITEMSTRUCT *lpdis)
{
    HDC hdc = lpdis->hDC;
    RECT rc = lpdis->rcItem;
    TCHAR szText[MAX_DRIVELIST_STRING_LEN];
    int offset = 0;
    int xString, yString, xMiniDrive, dyString;
    SIZE siz;

    if ((int)lpdis->itemID < 0)
    {
        return;
    }

    MYLISTBOXITEM *pItem = GetListboxItem(lpdis->hwndItem, lpdis->itemID);

    if (pItem)
    {
        ::SendDlgItemMessage(_hwndDlg,
                              cmb2,
                              CB_GETLBTEXT,
                              lpdis->itemID,
                              (LPARAM)szText);

        //
        //  Before doing anything, calculate the actual rectangle for the text.
        //
        if (!(lpdis->itemState & ODS_COMBOBOXEDIT))
        {
            offset = 10 * pItem->cIndent;
        }

        xMiniDrive = rc.left + DRIVELIST_BORDER + offset;
        rc.left = xString = xMiniDrive + MINIDRIVE_WIDTH + MINIDRIVE_MARGIN;
        GetTextExtentPoint(hdc, szText, lstrlen(szText), &siz);

        dyString = siz.cy;
        rc.right = rc.left + siz.cx;
        rc.left--;
        rc.right++;

        if (lpdis->itemAction != ODA_FOCUS)
        {
            FillRect(hdc, &lpdis->rcItem, GetSysColorBrush(COLOR_WINDOW));

            yString = rc.top + (rc.bottom - rc.top - dyString) / 2;

            SetBkColor(hdc,
                        GetSysColor((lpdis->itemState & ODS_SELECTED)
                                         ? COLOR_HIGHLIGHT
                                         : COLOR_WINDOW));
            SetTextColor(hdc,
                          GetSysColor((lpdis->itemState & ODS_SELECTED)
                                           ? COLOR_HIGHLIGHTTEXT
                                           : COLOR_WINDOWTEXT));

            if ((lpdis->itemState & ODS_COMBOBOXEDIT) &&
                (rc.right > lpdis->rcItem.right))
            {
                //
                //  Need to clip as user does not!
                //
                rc.right = lpdis->rcItem.right;
                ExtTextOut(hdc,
                            xString,
                            yString,
                            ETO_OPAQUE | ETO_CLIPPED,
                            &rc,
                            szText,
                            lstrlen(szText),
                            NULL);
            }
            else
            {
                ExtTextOut(hdc,
                            xString,
                            yString,
                            ETO_OPAQUE,
                            &rc,
                            szText,
                            lstrlen(szText),
                            NULL);
            }

            ImageList_Draw(_himl,
                            (lpdis->itemID == (UINT)_iCurrentLocation)
                                ? pItem->iSelectedImage
                                : pItem->iImage,
                            hdc,
                            xMiniDrive,
                            rc.top + (rc.bottom - rc.top - MINIDRIVE_HEIGHT) / 2,
                            (pItem->IsShared()
                                ? INDEXTOOVERLAYMASK(IDOI_SHARE)
                                : 0) |
                            ((lpdis->itemState & ODS_SELECTED)
                                ? (ILD_SELECTED | ILD_FOCUS | ILD_TRANSPARENT)
                                : ILD_TRANSPARENT));
        }
    }

    if (lpdis->itemAction == ODA_FOCUS ||
        (lpdis->itemState & ODS_FOCUS))
    {
        DrawFocusRect(hdc, &rc);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RefreshFilter
//
//  Refresh the view given any change in the user's choice of wildcard
//  filter.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RefreshFilter(
    HWND hwndFilter)
{
    WAIT_CURSOR w(this);

    _pOFN->Flags &= ~OFN_FILTERDOWN;

    short nIndex = (short) SendMessage(hwndFilter, CB_GETCURSEL, 0, 0L);
    if (nIndex < 0)
    {
        //
        //  No current selection.
        //
        return;
    }

    BOOL bCustomFilter = _pOFN->lpstrCustomFilter && *_pOFN->lpstrCustomFilter;

    _pOFN->nFilterIndex = nIndex;
    if (!bCustomFilter)
    {
        _pOFN->nFilterIndex++;
    }

    LPTSTR lpFilter;

    //
    //  Must also check if filter contains anything.
    //
    lpFilter = (LPTSTR)ComboBox_GetItemData(hwndFilter, nIndex);

    if (*lpFilter)
    {
        SetCurrentFilter(lpFilter);

        //
        //  Provide dynamic _pszDefExt updating when lpstrDefExt is app
        //  initialized.
        //
        if (!_bNoInferDefExt && _pOFN->lpstrDefExt)
        {
            //
            //  We are looking for "foo*.ext[;...]".  We will grab ext as the
            //  default extension.  If not of this form, use the default
            //  extension passed in.
            //
            LPTSTR lpDot = StrChr(lpFilter, CHAR_DOT);

            //
            //  Skip past the CHAR_DOT.
            //
            if (lpDot && _pszDefExt.StrCpy(lpDot + 1))
            {
                LPTSTR lpSemiColon = StrChr(_pszDefExt, CHAR_SEMICOLON);
                if (lpSemiColon)
                {
                    *lpSemiColon = CHAR_NULL;
                }

                if (IsWild(_pszDefExt))
                {
                    _pszDefExt.StrCpy(_pOFN->lpstrDefExt);
                }
            }
            else
            {
                _pszDefExt.StrCpy(_pOFN->lpstrDefExt);
            }
        }

        if (_bUseCombo)
        {
            HWND hwndEdit = (HWND)SendMessage(GetDlgItem(_hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
            GetWindowText(hwndEdit, _szBuf, ARRAYSIZE(_szBuf));
        }
        else
        {
            GetDlgItemText(_hwndDlg, edt1, _szBuf, ARRAYSIZE(_szBuf));
        }

        if (IsWild(_szBuf))
        {
            //
            //  We should not show a filter that we are not using.
            //
            *_szBuf = CHAR_NULL;
            SetEditFile(_szBuf, NULL, TRUE);
        }

        if (_psv)
        {
            _psv->Refresh();
        }
    }

    if (_hSubDlg)
    {
        if (!CD_SendTypeChangeNotify(_hSubDlg, _hwndDlg, _pOFN, _pOFI))
        {
            CD_SendLBChangeMsg(_hSubDlg, cmb1, nIndex, CD_LBSELCHANGE, _pOFI->ApiType);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetDirectoryFromLB
//
//  Return the dropdown's directory and its length.
//  Set *pichRoot to the start of the path (C:\ or \\server\share\).
//
////////////////////////////////////////////////////////////////////////////

UINT CFileOpenBrowser::GetDirectoryFromLB(
    LPTSTR pszBuf,
    int *pichRoot)
{
    *pszBuf = 0;
    if (_pCurrentLocation->pidlFull != NULL)
    {
        GetPathFromLocation(_pCurrentLocation, pszBuf);
    }

    if (*pszBuf)
    {
        PathAddBackslash(pszBuf);
        LPTSTR pszBackslash = StrChr(pszBuf + 2, CHAR_BSLASH);
        if (pszBackslash != NULL)
        {
            //
            //  For UNC paths, the "root" is on the next backslash.
            //
            if (DBL_BSLASH(pszBuf))
            {
                pszBackslash = StrChr(pszBackslash + 1, CHAR_BSLASH);
            }
            UINT cchRet = lstrlen(pszBuf);
            *pichRoot = (pszBackslash != NULL) ? (int)(pszBackslash - pszBuf) : cchRet;
            return (cchRet);
        }
    }
    *pichRoot = 0;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnumItemObjects
//
////////////////////////////////////////////////////////////////////////////

typedef BOOL (*EIOCALLBACK)(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam);

BOOL CFileOpenBrowser::EnumItemObjects(
    UINT uItem,
    EIOCALLBACK pfnCallBack,
    LPARAM lParam)
{
    FORMATETC fmte = { (CLIPFORMAT) g_cfCIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    BOOL bRet = FALSE;
    LPCITEMIDLIST pidl;
    LPIDA pida;
    int cItems, i;
    IDataObject *pdtobj;
    STGMEDIUM medium;

    if (!_psv || FAILED(_psv->GetItemObject(uItem,
                                           IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        goto Error0;
    }

    if (FAILED(pdtobj->GetData(&fmte, &medium)))
    {
        goto Error1;
    }

    pida = (LPIDA)GlobalLock(medium.hGlobal);
    cItems = pida->cidl;

    for (i = 1; ; ++i)
    {
        if (i > cItems)
        {
            //
            //  We got to the end of the list without a failure.
            //  Call back one last time with NULL.
            //
            bRet = pfnCallBack(this, NULL, lParam);
            break;
        }

        pidl = LPIDL_GetIDList(pida, i);

        if (!pfnCallBack(this, pidl, lParam))
        {
            break;
        }
    }

    GlobalUnlock(medium.hGlobal);

    _ReleaseStgMedium(&medium);

Error1:
    pdtobj->Release();
Error0:
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindNameEnumCB
//
////////////////////////////////////////////////////////////////////////////

#define FE_INVALID_VALUE     0x0000
#define FE_OUTOFMEM          0x0001
#define FE_TOOMANY           0x0002
#define FE_CHANGEDDIR        0x0003
#define FE_FILEERR           0x0004
#define FE_FOUNDNAME         0x0005

typedef struct _FINDNAMESTRUCT
{
    LPTSTR        pszFile;
    UINT          uRet;
    LPCITEMIDLIST pidlFound;
} FINDNAMESTRUCT;


BOOL FindNameEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    SHFILEINFO sfi;
    FINDNAMESTRUCT *pfns = (FINDNAMESTRUCT *)lParam;

    if (!pidl)
    {
        if (!pfns->pidlFound)
        {
            return FALSE;
        }

        GetViewItemText(that->_psfCurrent, pfns->pidlFound, pfns->pszFile, MAX_PATH);

        if (IsContainer(that->_psfCurrent, pfns->pidlFound))
        {
            LPITEMIDLIST pidlFull = ILCombine(that->_pCurrentLocation->pidlFull,
                                               pfns->pidlFound);

            if (pidlFull)
            {
                if (that->JumpToIDList(pidlFull))
                {
                    pfns->uRet = FE_CHANGEDDIR;
                }
                else if (!that->_psv)
                {
                    pfns->uRet = FE_OUTOFMEM;
                }
                SHFree(pidlFull);

                if (pfns->uRet != FE_INVALID_VALUE)
                {
                    return TRUE;
                }
            }
        }

        pfns->uRet = FE_FOUNDNAME;
        return TRUE;
    }

    if (!SHGetFileInfo((LPCTSTR)pidl,
                        0,
                        &sfi,
                        sizeof(sfi),
                        SHGFI_DISPLAYNAME | SHGFI_PIDL))
    {
        //
        //  This will never happen, right?
        //
        return TRUE;
    }

    if (lstrcmpi(sfi.szDisplayName, pfns->pszFile) != 0)
    {
        //
        //  Continue the enumeration.
        //
        return TRUE;
    }

    if (!pfns->pidlFound)
    {
        pfns->pidlFound = pidl;

        //
        //  Continue looking for more matches.
        //
        return TRUE;
    }

    //
    //  We already found a match, so select the first one and stop the search.
    //
    //  The focus must be set to _hwndView before changing selection or
    //  the GetItemObject may not work.
    //
    FORWARD_WM_NEXTDLGCTL(that->_hwndDlg, that->_hwndView, 1, SendMessage);
    that->_psv->SelectItem(pfns->pidlFound,
                           SVSI_SELECT | SVSI_DESELECTOTHERS |
                               SVSI_ENSUREVISIBLE | SVSI_FOCUSED);

    pfns->pidlFound = NULL;
    pfns->uRet = FE_TOOMANY;

    //
    //  Stop enumerating.
    //
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CDPathQualify
//
////////////////////////////////////////////////////////////////////////////

void CDPathQualify(
    LPCTSTR lpFile,
    LPTSTR pszPathName)
{
    TCHAR szCurDir[MAX_PATH + 1];

    lstrcpy(pszPathName, lpFile);

    //
    //  This should do the whole job of canonicalizing the directory.
    //
    GetCurrentDirectory(ARRAYSIZE(szCurDir), szCurDir);
    PathCombine(pszPathName, szCurDir, pszPathName);
}


////////////////////////////////////////////////////////////////////////////
//
//  VerifyOpen
//
//  Returns:   0    success
//             !0   dos error code
//
////////////////////////////////////////////////////////////////////////////

int VerifyOpen(
    LPCTSTR lpFile,
    LPTSTR pszPathName)
{
    HANDLE hf;

    CDPathQualify(lpFile, pszPathName);

    hf = CreateFile(pszPathName,
                     GENERIC_READ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }
    else
    {
        CloseHandle(hf);
        return (0);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::IsKnownExtension
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::IsKnownExtension(
    LPCTSTR pszExtension)
{
    if ((LPTSTR)_pszDefExt && lstrcmpi(pszExtension + 1, _pszDefExt) == 0)
    {
        //
        //  It's the default extension, so no need to add it again.
        //
        return TRUE;
    }


    if (lstrcmp(_szLastFilter, szStarDotStar) == 0)
    {
        //Current Filter is *.*, so allow whatever extension user enters.
        return TRUE;
    }

    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExtension, NULL, 0) == ERROR_SUCCESS)
    {
        //
        //  It's a registered extension, so the user is trying to force
        //  the type.
        //
        return TRUE;
    }

    if (_pOFN->lpstrFilter)
    {
        LPCTSTR pFilter = _pOFN->lpstrFilter;

        while (*pFilter)
        {
            //
            //  Skip visual.
            //
            pFilter = pFilter + lstrlen(pFilter) + 1;

            //
            //  Search extension list.
            //
            while (*pFilter)
            {
                //
                //  Check extensions of the form '*.ext' only.
                //
                if (*pFilter == CHAR_STAR && *(++pFilter) == CHAR_DOT)
                {
                    LPCTSTR pExt = pszExtension + 1;

                    pFilter++;

                    while (*pExt && *pExt == *pFilter)
                    {
                        pExt++;
                        pFilter++;
                    }

                    if (!*pExt && (*pFilter == CHAR_SEMICOLON || !*pFilter))
                    {
                        //
                        //  We have a match.
                        //
                        return TRUE;
                    }
                }

                //
                //  Skip to next extension.
                //
                while (*pFilter)
                {
                    TCHAR ch = *pFilter;
                    pFilter = CharNext(pFilter);
                    if (ch == CHAR_SEMICOLON)
                    {
                        break;
                    }
                }
            }

            //
            //  Skip extension string's terminator.
            //
            pFilter++;
        }
    }

    return FALSE;
}

BOOL CFileOpenBrowser::_IsNoDereferenceLinks(LPCWSTR pszFile, IShellItem *psi)
{
    if (_pOFN->Flags & OFN_NODEREFERENCELINKS) 
        return TRUE;

    LPWSTR psz = NULL;
    if (!pszFile)
    {
        psi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &psz);
        pszFile = psz;
    }

    //  if the filter equals what ever we are looking at
    //  we assume the caller is actually looking for
    //  this file.
    BOOL fRet = (NULL == StrStr(_szLastFilter, TEXT(".*"))) && PathMatchSpec(pszFile, _szLastFilter);

    if (psz)
        CoTaskMemFree(psz);

    return fRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::FindNameInView
//
//  We will only resolve a link once.  If you have a link to a link, then
//  we will return the second link.
//
//  If nExtOffset is non-zero, it is the offset to the character following
//  the dot.
//
////////////////////////////////////////////////////////////////////////////

#define NUM_LINKLOOPS 1

UINT CFileOpenBrowser::FindNameInView(
    LPTSTR pszFile,
    OKBUTTONFLAGS Flags,
    LPTSTR pszPathName,
    int nFileOffset,
    int nExtOffset,
    int *pnErrCode,
    BOOL bTryAsDir)
{
    UINT uRet;
    FINDNAMESTRUCT fns =
    {
        pszFile,
        FE_INVALID_VALUE,
        NULL,
    };
    BOOL bGetOut = TRUE;
    BOOL bAddExt = FALSE;
    BOOL bHasExt = nExtOffset;
    TCHAR szTemp[MAX_PATH + 1];

    int nNewExt = lstrlen(pszFile);

    //
    //  If no extension, point at the end of the file name.
    //
    if (!nExtOffset)
    {
        nExtOffset = nNewExt;
    }

    //
    //  HACK: We could have a link that points to another link that points to
    //  another link, ..., that points back to the original file.  We will not
    //  loop more than NUM_LINKLOOPS times before giving up.

    int nLoop = NUM_LINKLOOPS;

    if (Flags & (OKBUTTON_NODEFEXT | OKBUTTON_QUOTED))
    {
        goto VerifyTheName;
    }

    if (bHasExt)
    {
        if (IsKnownExtension(pszFile + nExtOffset))
        {
            goto VerifyTheName;
        }

        //
        //  Don't attempt 2 extensions on SFN volume.
        //
        CDPathQualify(pszFile, pszPathName);
        if (!IsLFNDrive(pszPathName))
        {
            goto VerifyTheName;
        }
    }

    bGetOut = FALSE;

    if ((LPTSTR)_pszDefExt &&
        ((DWORD)nNewExt + lstrlen(_pszDefExt) < _pOFN->nMaxFile))
    {
        bAddExt = TRUE;

        //
        //  Note that we check lpstrDefExt to see if they want an automatic
        //  extension, but actually copy _pszDefExt.
        //
        AppendExt(pszFile, _pszDefExt, FALSE);

        //
        //  So we've added the default extension.  If there's a directory
        //  that matches this name, all attempts to open/create the file
        //  will fail, so simply change to the directory as if they had
        //  typed it in.  Note that by putting this test here, if there
        //  was a directory without the extension, we would have already
        //  switched to it.
        //

VerifyTheName:
        //
        //  Note that this also works for a UNC name, even on a net that
        //  does not support using UNC's directly.  It will also do the
        //  right thing for links to things.  We do not validate if we
        //  have not dereferenced any links, since that should have
        //  already been done.
        //
        if (bTryAsDir && SetDirRetry(pszFile, nLoop == NUM_LINKLOOPS))
        {
            return (FE_CHANGEDDIR);
        }

        *pnErrCode = VerifyOpen(pszFile, pszPathName);

        if (*pnErrCode == 0 || *pnErrCode == OF_SHARINGVIOLATION)
        {
            //
            //  This may be a link to something, so we should try to
            //  resolve it.
            //
            if (!_IsNoDereferenceLinks(pszFile, NULL) && nLoop > 0)
            {
                --nLoop;

                LPITEMIDLIST pidl;
                IShellFolder *psf = NULL;
                DWORD dwAttr = SFGAO_LINK;
                HRESULT hRes;

                //
                //  ILCreateFromPath is slow (especially on a Net path),
                //  so just try to parse the name in the current folder if
                //  possible.
                //
                if (nFileOffset || nLoop < NUM_LINKLOOPS - 1)
                {
                    LPITEMIDLIST pidlTemp;
                    hRes = SHILCreateFromPath(pszPathName, &pidlTemp, &dwAttr);
                    
                    //We are getting a pidl corresponding to a path. Get the IShellFolder corresponding to this pidl
                    // to pass it to ResolveLink
                    if (SUCCEEDED(hRes))
                    {
                        LPCITEMIDLIST pidlLast;
                        hRes = CDBindToIDListParent(pidlTemp, IID_PPV_ARG(IShellFolder, &psf), (LPCITEMIDLIST *)&pidlLast);
                        if (SUCCEEDED(hRes))
                        {
                            //Get the child pidl relative to the IShellFolder
                            pidl = ILClone(pidlLast);
                        }
                        ILFree(pidlTemp);
                    }
                }
                else
                {
                    WCHAR wszDisplayName[MAX_PATH + 1];
                    ULONG chEaten;

                    SHTCharToUnicode(pszFile, wszDisplayName , ARRAYSIZE(wszDisplayName));

                    hRes = _psfCurrent->ParseDisplayName(NULL,
                                                         NULL,
                                                         wszDisplayName,
                                                         &chEaten,
                                                         &pidl,
                                                         &dwAttr);
                }

                if (SUCCEEDED(hRes))
                {

                    if (dwAttr & SFGAO_LINK)
                    {
                        SHTCUTINFO info;

                        info.dwAttr      = 0;
                        info.fReSolve    = FALSE;
                        info.pszLinkFile = szTemp;
                        info.cchFile     = ARRAYSIZE(szTemp);
                        info.ppidl       = NULL; 
                        
                        //psf can be NULL in which case ResolveLink uses _psfCurrent IShellFolder
                        if (SUCCEEDED(ResolveLink(pidl, &info, psf)) && szTemp[0])
                        {
                            //
                            //  It was a link, and it "dereferenced" to something,
                            //  so we should try again with that new file.
                            //
                            lstrcpy(pszFile, szTemp);

                            if (pidl)
                            {
                                SHFree(pidl);
                            }

                            if (psf)
                            {
                                psf->Release();
                                psf = NULL;
                            }

                            goto VerifyTheName;
                        }
                    }

                    if (pidl)
                    {
                        SHFree(pidl);
                    }

                    if (psf)
                    {
                        psf->Release();
                        psf = NULL;
                    }
                }
            }

            return (FE_FOUNDNAME);
        }

        if (bGetOut ||
            (*pnErrCode != OF_FILENOTFOUND && *pnErrCode != OF_PATHNOTFOUND))
        {
            return (FE_FILEERR);
        }

        if (_bSave)
        {
            //
            //  Do no more work if creating a new file.
            //
            return (FE_FOUNDNAME);
        }
    }

    //
    //  Make sure we do not loop forever.
    //
    bGetOut = TRUE;

    if (_bSave)
    {
        //
        //  Do no more work if creating a new file.
        //
        goto VerifyTheName;
    }

    pszFile[nNewExt] = CHAR_NULL;

    if (bTryAsDir && (nFileOffset > 0))
    {
        TCHAR cSave = *(pszFile + nFileOffset);
        *(pszFile + nFileOffset) = CHAR_NULL;

        //
        //  We need to have the view on the dir with the file to do the
        //  next steps.
        //
        BOOL bOK = JumpToPath(pszFile);
        *(pszFile + nFileOffset) = cSave;

        if (!_psv)
        {
            //
            //  We're dead.
            //
            return (FE_OUTOFMEM);
        }

        if (bOK)
        {
            lstrcpy(pszFile, pszFile + nFileOffset);
            nNewExt -= nFileOffset;
            SetEditFile(pszFile, NULL, TRUE);
        }
        else
        {
            *pnErrCode = OF_PATHNOTFOUND;
            return (FE_FILEERR);
        }
    }

    EnumItemObjects(SVGIO_ALLVIEW, FindNameEnumCB, (LPARAM)&fns);
    switch (fns.uRet)
    {
        case (FE_INVALID_VALUE) :
        {
            break;
        }
        case (FE_FOUNDNAME) :
        {
            goto VerifyTheName;
        }
        default :
        {
            uRet = fns.uRet;
            goto VerifyAndRet;
        }
    }

    if (bAddExt)
    {
        //
        //  Before we fail, check to see if the file typed sans default
        //  extension exists.
        //
        *pnErrCode = VerifyOpen(pszFile, pszPathName);
        if (*pnErrCode == 0 || *pnErrCode == OF_SHARINGVIOLATION)
        {
            //
            //  We will never hit this case for links (because they
            //  have registered extensions), so we don't need
            //  to goto VerifyTheName (which also calls VerifyOpen again).
            //
            return (FE_FOUNDNAME);
        }

        //
        //  I still can't find it?  Try adding the default extension and
        //  return failure.
        //
        AppendExt(pszFile, _pszDefExt, FALSE);
    }

    uRet = FE_FILEERR;

VerifyAndRet:
    *pnErrCode = VerifyOpen(pszFile, pszPathName);
    return (uRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetDirRetry
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::SetDirRetry(
    LPTSTR pszDir,
    BOOL bNoValidate)
{
    if (SetCurrentDirectory(pszDir))
    {
JumpThere:
        JumpToPath(TEXT("."));
        return TRUE;
    }

    if (bNoValidate || !IsUNC(pszDir))
    {
        return FALSE;
    }


    //
    //  It may have been a password problem, so try to add the connection.
    //  Note that if we are on a net that does not support CD'ing to UNC's
    //  directly, this call will connect it to a drive letter.
    //
    if (!SHValidateUNC(_hwndDlg, pszDir, 0))
    {
        switch (GetLastError())
        {
            case ERROR_CANCELLED:
            {
                //
                //  We don't want to put up an error message if they
                //  canceled the password dialog.
                //
                return TRUE;
            }

            case ERROR_NETWORK_UNREACHABLE:
            {
                LPTSTR lpMsgBuf;
                TCHAR szTitle[MAX_PATH];
                FormatMessage(    
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,    
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &lpMsgBuf,    
                    0,    
                    NULL);
                    
                GetWindowText(_hwndDlg, szTitle, ARRAYSIZE(szTitle));
                MessageBox(NULL, lpMsgBuf, szTitle, MB_OK | MB_ICONINFORMATION);
                // Free the buffer.
                LocalFree(lpMsgBuf);
                return TRUE;
            }

            default:
            {
                //
                //  Some other error we don't know about.
                //
                return FALSE;
            }
        }
    }

    //
    //  We connected to it, so try to switch to it again.
    //
    if (SetCurrentDirectory(pszDir))
    {
        goto JumpThere;
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::MultiSelectOKButton
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::MultiSelectOKButton(
    LPCTSTR pszFiles,
    OKBUTTONFLAGS Flags)
{
    TCHAR szPathName[MAX_PATH];
    int nErrCode;
    LPTSTR pchRead, pchWrite, lpCurDir;
    UINT cch, cchCurDir, cchFiles;
    WAIT_CURSOR w(this);

    //
    //  This doesn't really mean anything for multiselection.
    //
    _pOFN->nFileExtension = 0;

    if (!_pOFN->lpstrFile)
    {
        return TRUE;
    }


    //
    //  Check for space for first full path element.
    //
    if ((_pOFN->Flags & OFN_ENABLEINCLUDENOTIFY) && lstrlen(_pszObjectCurDir))
    {
        lpCurDir = _pszObjectCurDir;
    }
    else
    {
        lpCurDir = _szCurDir;
    }
    cchCurDir = lstrlen(lpCurDir) + 1;
    cchFiles = lstrlen(pszFiles) + 1;
    cch = cchCurDir + cchFiles;

    if (cch > (UINT)_pOFN->nMaxFile)
    {
        //
        //  Buffer is too small, so return the size of the buffer
        //  required to hold the string.
        //
        //  cch is not really the number of characters needed, but it
        //  should be close.
        //
        StoreLengthInString((LPTSTR)_pOFN->lpstrFile, (UINT)_pOFN->nMaxFile, (UINT)cch);
        return TRUE;
    }

    TEMPSTR psFiles(cchFiles + FILE_PADDING);
    pchRead = psFiles;
    if (!pchRead)
    {
        //
        //  Out of memory.
        //  FEATURE There should be some sort of error message here.
        //
        return FALSE;
    }

    //
    //  Copy in the full path as the first element.
    //
    lstrcpy(_pOFN->lpstrFile, lpCurDir);

    //
    //  Set nFileOffset to 1st file.
    //
    _pOFN->nFileOffset = (WORD) cchCurDir;
    pchWrite = _pOFN->lpstrFile + cchCurDir;

    //
    //  We know there is enough room for the whole string.
    //
    lstrcpy(pchRead, pszFiles);

    //
    //  This should only compact the string.
    //
    if (!ConvertToNULLTerm(pchRead))
    {
        return FALSE;
    }

    for (; *pchRead; pchRead += lstrlen(pchRead) + 1)
    {
        int nFileOffset, nExtOffset;
        TCHAR szBasicPath[MAX_PATH];

        lstrcpy(szBasicPath, pchRead);

        nFileOffset = ParseFileNew(szBasicPath, &nExtOffset, FALSE, TRUE);

        if (nFileOffset < 0)
        {
            InvalidFileWarningNew(_hwndDlg, pchRead, nFileOffset);
            return FALSE;
        }

        //
        //  Pass in 0 for the file offset to make sure we do not switch
        //  to another folder.
        //
        switch (FindNameInView(szBasicPath,
                                Flags,
                                szPathName,
                                nFileOffset,
                                nExtOffset,
                                &nErrCode,
                                FALSE))
        {
            case (FE_OUTOFMEM) :
            case (FE_CHANGEDDIR) :
            {
                return FALSE;
            }
            case (FE_TOOMANY) :
            {
                CDMessageBox(_hwndDlg,
                              iszTooManyFiles,
                              MB_OK | MB_ICONEXCLAMATION,
                              pchRead);
                return FALSE;
            }
            default :
            {
                break;
            }
        }

        if (nErrCode &&
             ((_pOFN->Flags & OFN_FILEMUSTEXIST) ||
               (nErrCode != OF_FILENOTFOUND)) &&
             ((_pOFN->Flags & OFN_PATHMUSTEXIST) ||
               (nErrCode != OF_PATHNOTFOUND)) &&
             (!(_pOFN->Flags & OFN_SHAREAWARE) ||
               (nErrCode != OF_SHARINGVIOLATION)))
        {
            if ((nErrCode == OF_SHARINGVIOLATION) && _hSubDlg)
            {
                int nShareCode = CD_SendShareNotify(_hSubDlg,
                                                     _hwndDlg,
                                                     szPathName,
                                                     _pOFN,
                                                     _pOFI);

                if (nShareCode == OFN_SHARENOWARN)
                {
                    return FALSE;
                }
                else if (nShareCode == OFN_SHAREFALLTHROUGH)
                {
                    goto EscapedThroughShare;
                }
                else
                {
                    //
                    //  They might not have handled the notification, so try
                    //  the registered message.
                    //
                    nShareCode = CD_SendShareMsg(_hSubDlg, szPathName, _pOFI->ApiType);

                    if (nShareCode == OFN_SHARENOWARN)
                    {
                        return FALSE;
                    }
                    else if (nShareCode == OFN_SHAREFALLTHROUGH)
                    {
                        goto EscapedThroughShare;
                    }
                }
            }
            else if (nErrCode == OF_ACCESSDENIED)
            {
                szPathName[0] |= 0x60;
                if (GetDriveType(szPathName) != DRIVE_REMOVABLE)
                {
                    nErrCode = OF_NETACCESSDENIED;
                }
            }

            //
            //  These will never be set.
            //
            if ((nErrCode == OF_WRITEPROTECTION) ||
                (nErrCode == OF_DISKFULL)        ||
                (nErrCode == OF_DISKFULL2)       ||
                (nErrCode == OF_ACCESSDENIED))
            {
                *pchRead = szPathName[0];
            }

MultiWarning:
            InvalidFileWarningNew(_hwndDlg, pchRead, nErrCode);
            return FALSE;
        }

EscapedThroughShare:
        if (nErrCode == 0)
        {
            if (!_ValidateSelectedFile(szPathName, &nErrCode))
            {
                if (nErrCode)
                {
                    goto MultiWarning;
                }
                else
                {
                    return FALSE;
                }
            }            
        }

        //
        //  Add some more in case the file name got larger.
        //
        cch += lstrlen(szBasicPath) - lstrlen(pchRead);
        if (cch > (UINT)_pOFN->nMaxFile)
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            StoreLengthInString((LPTSTR)_pOFN->lpstrFile, (UINT)_pOFN->nMaxFile, (UINT)cch);
            return TRUE;
        }

        //
        //  We already know we have anough room.
        //
        lstrcpy(pchWrite, szBasicPath);
        pchWrite += lstrlen(pchWrite) + 1;
    }

    //
    //  double-NULL terminate.
    //
    *pchWrite = CHAR_NULL;
  
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  StoreLengthInString
//
////////////////////////////////////////////////////////////////////////////

void StoreLengthInString(
    LPTSTR lpStr,
    UINT cchLen,
    UINT cchStore)
{
    if (cchLen >= 3)
    {
        //
        //  For single file requests, we will never go over 64K
        //  because the filesystem is limited to 256.
        //
        lpStr[0] = (TCHAR)LOWORD(cchStore);
        lpStr[1] = CHAR_NULL;
    }
    else
    {
        lpStr[0] = (TCHAR)LOWORD(cchStore);
        if (cchLen == 2)
        {
            lpStr[1] = (TCHAR)HIWORD(cchStore);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CheckForRestrictedFolder
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::CheckForRestrictedFolder(LPCTSTR lpszPath, int nFileOffset)
{  
    TCHAR szPath[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    LPITEMIDLIST pidl;
    BOOL bPidlAllocated = FALSE;
    BOOL bRet = FALSE;
    DWORD dwAttrib = SFGAO_FILESYSTEM;
    HRESULT hr = S_OK;

    if (nFileOffset > 0)
    {
        //There's a path in the given filename. Get the directory part of the filename.
        lstrcpy(szTemp, lpszPath);                
        szTemp[nFileOffset] = 0;

        //The directory path might be a relative path. Resolve it to get fully qualified path.
        CDPathQualify(szTemp, szPath);

        //Create the pidl for this path as well as get the attributes.
        hr = SHILCreateFromPath(szPath, &pidl, &dwAttrib);
        if (SUCCEEDED(hr))
        {
            bPidlAllocated = TRUE;
        }
        else
        {
            // WE are failing b'cos the user might have typed some path which doesn't exist.
            // if the path doesn't exist then it can't be one of the directory we are trying restrict.
            // let's bail out and let the code that checks for valid path take care of it
            return bRet;
        }
    }
    else
    {
        IShellLink *psl;
        pidl = _pCurrentLocation->pidlFull;  

        if (SUCCEEDED(CDGetUIObjectFromFullPIDL(pidl,_hwndDlg, IID_PPV_ARG(IShellLink, &psl))))
        {
            LPITEMIDLIST pidlTarget;
            if (S_OK == psl->GetIDList(&pidlTarget))
            {
                SHGetAttributesOf(pidlTarget, &dwAttrib);
                ILFree(pidlTarget);
            }
            psl->Release();
        }
        else
        {
            SHGetAttributesOf(pidl, &dwAttrib);
        }
    }

    
    // 1. We cannot save to the non file system folders.
    // 2. We should not allow user to save in recent files folder as the file might get deleted.
    if (!(dwAttrib & SFGAO_FILESYSTEM) || _IsRecentFolder(pidl))
    {   
        int iMessage =  UrlIs(lpszPath, URLIS_URL) ? iszNoSaveToURL : iszSaveRestricted;
        HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_ARROW));
        CDMessageBox(_hwndDlg, iMessage, MB_OK | MB_ICONEXCLAMATION);
        SetCursor(hcurOld);
        bRet = TRUE;
     }

    if (bPidlAllocated)
    {
        ILFree(pidl);
    }
    
    return bRet;
}

STDAPI_(LPITEMIDLIST) GetIDListFromFolder(IShellFolder *psf)
{
    LPITEMIDLIST pidl = NULL;

    IPersistFolder2 *ppf;
    if (psf && SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistFolder2, &ppf))))
    {
        ppf->GetCurFolder(&pidl);
        ppf->Release();
    }
    return pidl;
}



////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OKButtonPressed
//
//  Process the OK button being pressed.  This may involve jumping to a path,
//  changing the filter, actually choosing a file to open or save as, or who
//  knows what else.
//
//  Note:  There are 4 cases for validation of a file name:
//    1) OFN_NOVALIDATE        Allows invalid characters
//    2) No validation flags   No invalid characters, but path need not exist
//    3) OFN_PATHMUSTEXIST     No invalid characters, path must exist
//    4) OFN_FILEMUSTEXIST     No invalid characters, path & file must exist
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OKButtonPressed(
    LPCTSTR pszFile,
    OKBUTTONFLAGS Flags)
{
    TCHAR szExpFile[MAX_PATH];
    TCHAR szPathName[MAX_PATH];
    TCHAR szBasicPath[MAX_PATH];
    LPTSTR pExpFile = NULL;
    int nErrCode;
    ECODE eCode = ECODE_S_OK;
    DWORD cch;
    int nFileOffset, nExtOffset, nOldExt;
    TCHAR ch;
    BOOL bAddExt = FALSE;
    BOOL bUNCName = FALSE;
    int nTempOffset;
    BOOL bIsDir;
    BOOL bRet = FALSE;
    WAIT_CURSOR w(this);
    EnableModelessSB(FALSE);

    if (_bSelIsObject)
    {
        if ((INT)(lstrlen(_pszObjectPath) + 1) <= (INT)_pOFN->nMaxFile)
        {
            lstrcpy((LPTSTR)_pOFN->lpstrFile, (LPTSTR)_pszObjectPath);
        }
        else
        {
            StoreLengthInString(_pOFN->lpstrFile,
                                 _pOFN->nMaxFile,
                                 lstrlen(_pszObjectPath) + 1);
        }
    }

    //
    //  Expand any environment variables.
    //
    cch = _pOFN->nMaxFile;
    if (cch > MAX_PATH)
    {
        pExpFile = (LPTSTR)LocalAlloc(LPTR, (cch * sizeof(TCHAR)));
    }

    if (!pExpFile)
    {
        pExpFile = szExpFile;
        cch = MAX_PATH;
    }

    pExpFile[0] = 0;
    ExpandEnvironmentStrings(pszFile, pExpFile, cch);
    pExpFile[cch - 1] = 0;

    //
    //  See if we're in Multi Select mode.
    //
    if (StrChr(pExpFile, CHAR_QUOTE) && (_pOFN->Flags & OFN_ALLOWMULTISELECT))
    {
        bRet = MultiSelectOKButton(pExpFile, Flags);
        goto ReturnFromOKButtonPressed;
    }

    //
    //  We've only got a single selection...if we're in
    //  multi-select mode & it's an object, we need to do a little
    //  work before continuing...
    //
    if ((_pOFN->Flags & OFN_ALLOWMULTISELECT) && _bSelIsObject)
    {
        if (pExpFile != szExpFile)  // since szExpFile is stack memory.
        {
            LocalFree(pExpFile);
        }
        pExpFile = _pszObjectPath;
    }

    if ((pExpFile[1] == CHAR_COLON) || DBL_BSLASH(pExpFile))
    {
        //
        //  If a drive or UNC was specified, use it.
        //
        lstrcpyn(szBasicPath, pExpFile, ARRAYSIZE(szBasicPath) - 1);
        nTempOffset = 0;
    }
    else
    {
        //
        //  Grab the directory from the listbox.
        //
        cch = GetDirectoryFromLB(szBasicPath, &nTempOffset);

        if (pExpFile[0] == CHAR_BSLASH)
        {
            //
            //  If a directory from the root was given, put it
            //  immediately off the root (\\server\share or a:).
            //
            lstrcpyn(szBasicPath + nTempOffset,
                      pExpFile,
                      ARRAYSIZE(szBasicPath) - nTempOffset - 1);
        }
        else
        {
            //
            //  Tack the file to the end of the path.
            //
            lstrcpyn(szBasicPath + cch, pExpFile, ARRAYSIZE(szBasicPath) - cch - 1);
        }
    }

    nFileOffset = ParseFileOld(szBasicPath, &nExtOffset, &nOldExt, FALSE, TRUE);

    if (nFileOffset == PARSE_EMPTYSTRING)
    {
        if (_psv)
        {
            _psv->Refresh();
        }
        goto ReturnFromOKButtonPressed;
    }
    else if ((nFileOffset != PARSE_DIRECTORYNAME) &&
             (_pOFN->Flags & OFN_NOVALIDATE))
    {
        if (_bSelIsObject)
        {
            _pOFN->nFileOffset = _pOFN->nFileExtension = 0;
        }
        else
        {
            _pOFN->nFileOffset = (WORD) nFileOffset;
            _pOFN->nFileExtension = (WORD) nOldExt;
        }

        if (_pOFN->lpstrFile)
        {
            cch = lstrlen(szBasicPath);
            if (cch <= LOWORD(_pOFN->nMaxFile))
            {
                lstrcpy(_pOFN->lpstrFile, szBasicPath);
            }
            else
            {
                //
                //  Buffer is too small, so return the size of the buffer
                //  required to hold the string.
                //
                StoreLengthInString(_pOFN->lpstrFile, _pOFN->nMaxFile, cch);
            }
        }
        bRet = TRUE;
        goto ReturnFromOKButtonPressed;
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        //
        //  See if it ends in slash.
        //
        if (nExtOffset > 0)
        {
            if (ISBACKSLASH(szBasicPath, nExtOffset - 1))
            {
                //
                //  "\\server\share\" and "c:\" keep the trailing backslash,
                //  all other paths remove the trailing backslash. Note that
                //  we don't remove the slash if the user typed the path directly
                //  (nTempOffset is 0 in that case).
                //
                if ((nExtOffset != 1) &&
                    (szBasicPath[nExtOffset - 2] != CHAR_COLON) &&
                    (nExtOffset != nTempOffset + 1))
                {
                    szBasicPath[nExtOffset - 1] = CHAR_NULL;
                }
            }
            else if ((szBasicPath[nExtOffset - 1] == CHAR_DOT) &&
                      ((szBasicPath[nExtOffset - 2] == CHAR_DOT) ||
                        ISBACKSLASH(szBasicPath, nExtOffset - 2)) &&
                      IsUNC(szBasicPath))
            {
                //
                //  Add a trailing slash to UNC paths ending with ".." or "\."
                //
                szBasicPath[nExtOffset] = CHAR_BSLASH;
                szBasicPath[nExtOffset + 1] = CHAR_NULL;
            }
        }

        //
        //  Fall through to Directory Checking.
        //
    }
    else if (nFileOffset < 0)
    {
        nErrCode = nFileOffset;

        //
        //  I don't recognize this, so try to jump there.
        //  This is where servers get processed.
        //
        if (JumpToPath(szBasicPath))
        {
            goto ReturnFromOKButtonPressed;
        }

        //
        //  Fall through to the rest of the processing to warn the user.
        //

Warning:
        if (bUNCName)
        {
            cch = lstrlen(szBasicPath) - 1;
            if ((szBasicPath[cch] == CHAR_BSLASH) &&
                (szBasicPath[cch - 1] == CHAR_DOT) &&
                (ISBACKSLASH(szBasicPath, cch - 2)))
            {
                szBasicPath[cch - 2] = CHAR_NULL;
            }
        }

        // For file names of form c:filename.txt , we hacked and changed it to c:.\filename.txt
        // check for that hack and if so change the file name back as it was given by user.        
        else if ((nFileOffset == 2) && (szBasicPath[2] == CHAR_DOT))
        {
            lstrcpy(szBasicPath + 2, szBasicPath + 4);
        }

        //  If the disk is not a floppy and they tell me there's no
        //  disk in the drive, don't believe them.  Instead, put up the
        //  error message that they should have given us.  (Note that the
        //  error message is checked first since checking the drive type
        //  is slower.)
        //

        //
        //  I will assume that if we get error 0 or 1 or removable
        //  that we will assume removable.
        //
        if (nErrCode == OF_ACCESSDENIED)
        {
            TCHAR szD[4];

            szPathName[0] |= 0x60;
            szD[0] = *szBasicPath;
            szD[1] = CHAR_COLON;
            szD[2] = CHAR_BSLASH;
            szD[3] = 0;
            if (bUNCName || GetDriveType(szD) <= DRIVE_REMOVABLE)
            {
                nErrCode = OF_NETACCESSDENIED;
            }
        }

        if ((nErrCode == OF_WRITEPROTECTION) ||
            (nErrCode == OF_DISKFULL)        ||
            (nErrCode == OF_DISKFULL2)       ||
            (nErrCode == OF_ACCESSDENIED))
        {
            szBasicPath[0] = szPathName[0];
        }

        HRESULT hr = E_FAIL;
        if (_bSave)
        {
            hr = CheckForRestrictedFolder(pszFile, 0) ? S_FALSE : E_FAIL;
        }

        //  we might only want use ShellItem's for some errors
        if (FAILED(hr)/*&& (nErrCode == OF_FILENOTFOUND || (nErrCode == OF_PATHNOTFOUND))*/)
        {
            IShellItem *psi;
            hr = _ParseShellItem(pszFile, &psi, TRUE);
            if (S_OK == hr)
            {
                hr = _ProcessItemAsFile(psi);
                psi->Release();
            }
        }

        if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            // Special case
            // If the error was ACCESS_DENIED in a save dialog.
            if (_bSave && (nErrCode == OF_ACCESSDENIED))
            {
                // Ask if the user wants to switch to My Documents.
                _SaveAccessDenied(pszFile);
            }
            else
            {
                InvalidFileWarningNew(_hwndDlg, pszFile, nErrCode);
            }
        }
        else if (S_OK == hr)
        {
            bRet = TRUE;
        }

        goto ReturnFromOKButtonPressed;
    }

    //
    //  We either have a file pattern or a real file.
    //    If it's a UNC name
    //        (1) Fall through to file name testing
    //    Else if it's a directory
    //        (1) Add on default pattern
    //        (2) Act like it's a pattern (goto pattern (1))
    //    Else if it's a pattern
    //        (1) Update everything
    //        (2) display files in whatever dir we're now in
    //    Else if it's a file name!
    //        (1) Check out the syntax
    //        (2) End the dialog given OK
    //        (3) Beep/message otherwise
    //

    //
    //  Directory ?? this must succeed for relative paths.
    //  NOTE: It won't succeed for relative paths that walk off the root.
    //
    bIsDir = SetDirRetry(szBasicPath);

    //
    //  We need to parse again in case SetDirRetry changed a UNC path to use
    //  a drive letter.
    //
    nFileOffset = ParseFileOld(szBasicPath, &nExtOffset, &nOldExt, FALSE, TRUE);

    nTempOffset = nFileOffset;

    if (bIsDir)
    {
        goto ReturnFromOKButtonPressed;
    }
    else if (IsUNC(szBasicPath))
    {
        //
        //  UNC Name.
        //
        bUNCName = TRUE;
    }
    else if (nFileOffset > 0)
    {
        TCHAR szBuf[MAX_PATH];
        //
        //  There is a path in the string.
        //
        if ((nFileOffset > 1) &&
            (szBasicPath[nFileOffset - 1] != CHAR_COLON) &&
            (szBasicPath[nFileOffset - 2] != CHAR_COLON))
        {
            nTempOffset--;
        }
        GetCurrentDirectory(ARRAYSIZE(szBuf), szBuf);
        ch = szBasicPath[nTempOffset];
        szBasicPath[nTempOffset] = 0;

        if (SetCurrentDirectory(szBasicPath))
        {
            SetCurrentDirectory(szBuf);
        }
        else
        {
            switch (GetLastError())
            {
                case (ERROR_NOT_READY) :
                {
                    eCode = ECODE_BADDRIVE;
                    break;
                }
                default :
                {
                    eCode = ECODE_BADPATH;
                    break;
                }
            }
        }
        szBasicPath[nTempOffset] = ch;
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        TCHAR szD[4];

        szD[0] = *szBasicPath;
        szD[1] = CHAR_COLON;
        szD[2] = CHAR_BSLASH;
        szD[3] = 0;
        if (PathFileExists(szD))
        {
            eCode = ECODE_BADPATH;
        }
        else
        {
            eCode = ECODE_BADDRIVE;
        }
    }

    //
    //  Was there a path and did it fail?
    //
    if (!bUNCName &&
         nFileOffset &&
         eCode != ECODE_S_OK &&
         (_pOFN->Flags & OFN_PATHMUSTEXIST))
    {
        if (eCode == ECODE_BADPATH)
        {
            nErrCode = OF_PATHNOTFOUND;
        }
        else if (eCode == ECODE_BADDRIVE)
        {
            TCHAR szD[4];

            //
            //  We can get here without performing an OpenFile call.  As
            //  such the szPathName can be filled with random garbage.
            //  Since we only need one character for the error message,
            //  set szPathName[0] to the drive letter.
            //
            szPathName[0] = szD[0] = *szBasicPath;
            szD[1] = CHAR_COLON;
            szD[2] = CHAR_BSLASH;
            szD[3] = 0;
            switch (GetDriveType(szD))
            {
                case (DRIVE_REMOVABLE) :
                {
                    nErrCode = ERROR_NOT_READY;
                    break;
                }
                case (1) :
                {
                    //
                    //  Drive does not exist.
                    //
                    nErrCode = OF_NODRIVE;
                    break;
                }
                default :
                {
                    nErrCode = OF_PATHNOTFOUND;
                }
            }
        }
        else
        {
            nErrCode = OF_FILENOTFOUND;
        }
        goto Warning;
    }

    //
    //  Full pattern?
    //
    if (IsWild(szBasicPath + nFileOffset))
    {
        if (!bUNCName)
        {
            SetCurrentFilter(szBasicPath + nFileOffset, Flags);
            if (nTempOffset)
            {
                szBasicPath[nTempOffset] = 0;
                JumpToPath(szBasicPath, TRUE);
            }
            else if (_psv)
            {
                _psv->Refresh();
            }
            goto ReturnFromOKButtonPressed;
        }
        else
        {
            SetCurrentFilter(szBasicPath + nFileOffset, Flags);

            szBasicPath[nFileOffset] = CHAR_NULL;
            JumpToPath(szBasicPath);

            goto ReturnFromOKButtonPressed;
        }
    }

    if (PortName(szBasicPath + nFileOffset))
    {
        nErrCode = OF_PORTNAME;
        goto Warning;
    }

    // In save as dialog check to see if the folder user trying to save a file is 
    // a restricted folder (Network Folder). if so bail out
    if (_bSave && CheckForRestrictedFolder(szBasicPath, nFileOffset))
    {
        goto ReturnFromOKButtonPressed;
    }


    //
    //  Check if we've received a string in the form "C:filename.ext".
    //  If we have, convert it to the form "C:.\filename.ext".  This is done
    //  because the kernel will search the entire path, ignoring the drive
    //  specification after the initial search.  Making it include a slash
    //  causes kernel to only search at that location.
    //
    //  Note:  Only increment nExtOffset, not nFileOffset.  This is done
    //  because only nExtOffset is used later, and nFileOffset can then be
    //  used at the Warning: label to determine if this hack has occurred,
    //  and thus it can strip out the ".\" when putting up the error.
    //
    if ((nFileOffset == 2) && (szBasicPath[1] == CHAR_COLON))
    {
        lstrcpy(_szBuf, szBasicPath + 2);
        lstrcpy(szBasicPath + 4, _szBuf);
        szBasicPath[2] = CHAR_DOT;
        szBasicPath[3] = CHAR_BSLASH;
        nExtOffset += 2;
    }

    //
    //  Add the default extension unless filename ends with period or no
    //  default extension exists.  If the file exists, consider asking
    //  permission to overwrite the file.
    //
    //  NOTE: When no extension given, default extension is tried 1st.
    //  FindNameInView calls VerifyOpen before returning.
    //
    szPathName[0] = 0;
    switch (FindNameInView(szBasicPath,
                            Flags,
                            szPathName,
                            nFileOffset,
                            nExtOffset,
                            &nErrCode))
    {
        case (FE_OUTOFMEM) :
        case (FE_CHANGEDDIR) :
        {
            goto ReturnFromOKButtonPressed;
        }
        case (FE_TOOMANY) :
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            CDMessageBox(_hwndDlg,
                          iszTooManyFiles,
                          MB_OK | MB_ICONEXCLAMATION,
                          szBasicPath);
            goto ReturnFromOKButtonPressed;
        }
        default :
        {
            break;
        }
    }

    switch (nErrCode)
    {
        case (0) :
        {
            if (!_ValidateSelectedFile(szPathName, &nErrCode))
            {
                if (nErrCode)
                {
                    goto Warning;
                }
                else
                {
                    goto ReturnFromOKButtonPressed;
                }
            }            
            break;
        }
        case (OF_SHARINGVIOLATION) :
        {
            //
            //  If the app is "share aware", fall through.
            //  Otherwise, ask the hook function.
            //
            if (!(_pOFN->Flags & OFN_SHAREAWARE))
            {
                if (_hSubDlg)
                {
                    int nShareCode = CD_SendShareNotify(_hSubDlg,
                                                         _hwndDlg,
                                                         szPathName,
                                                         _pOFN,
                                                         _pOFI);
                    if (nShareCode == OFN_SHARENOWARN)
                    {
                        goto ReturnFromOKButtonPressed;
                    }
                    else if (nShareCode != OFN_SHAREFALLTHROUGH)
                    {
                        //
                        //  They might not have handled the notification,
                        //  so try the registered message.
                        //
                        nShareCode = CD_SendShareMsg(_hSubDlg, szPathName, _pOFI->ApiType);
                        if (nShareCode == OFN_SHARENOWARN)
                        {
                            goto ReturnFromOKButtonPressed;
                        }
                        else if (nShareCode != OFN_SHAREFALLTHROUGH)
                        {
                            goto Warning;
                        }
                    }
                }
                else
                {
                    goto Warning;
                }
            }
            break;
        }
        case (OF_FILENOTFOUND) :
        case (OF_PATHNOTFOUND) :
        {
            if (!_bSave)
            {
                //
                //  The file or path wasn't found.
                //  If this is a save dialog, we're ok, but if it's not,
                //  we're toast.
                //
                if (_pOFN->Flags & OFN_FILEMUSTEXIST)
                {
                    if (_pOFN->Flags & OFN_CREATEPROMPT)
                    {
                        int nCreateCode = CreateFileDlg(_hwndDlg, szBasicPath);
                        if (nCreateCode != IDYES)
                        {
                            goto ReturnFromOKButtonPressed;
                        }
                    }
                    else
                    {
                        goto Warning;
                    }
                }
            }
            goto VerifyPath;
        }
        default :
        {
            if (!_bSave)
            {
                goto Warning;
            }


            //
            //  The file doesn't exist.  Can it be created?  This is needed
            //  because there are many extended characters which are invalid
            //  which won't be caught by ParseFile.
            //
            //  Two more good reasons:  Write-protected disks & full disks.
            //
            //  BUT, if they don't want the test creation, they can request
            //  that we not do it using the OFN_NOTESTFILECREATE flag.  If
            //  they want to create files on a share that has
            //  create-but-no-modify privileges, they should set this flag
            //  but be ready for failures that couldn't be caught, such as
            //  no create privileges, invalid extended characters, a full
            //  disk, etc.
            //

VerifyPath:
            //
            //  Verify the path.
            //
            if (_pOFN->Flags & OFN_PATHMUSTEXIST)
            {
                if (!(_pOFN->Flags & OFN_NOTESTFILECREATE))
                {
                    HANDLE hf = CreateFile(szBasicPath,
                                            GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,
                                            CREATE_NEW,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL);
                    if (hf != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hf);

                        //
                        //  This test is here to see if we were able to
                        //  create it, but couldn't delete it.  If so,
                        //  warn the user that the network admin has given
                        //  him create-but-no-modify privileges.  As such,
                        //  the file has just been created, but we can't
                        //  do anything with it, it's of 0 size.
                        //
                        if (!DeleteFile(szBasicPath))
                        {
                            nErrCode = OF_CREATENOMODIFY;
                            goto Warning;
                        }
                    }
                    else
                    {
                        //
                        //  Unable to create it.
                        //
                        //  If it's not write-protection, a full disk,
                        //  network protection, or the user popping the
                        //  drive door open, assume that the filename is
                        //  invalid.
                        //
                        nErrCode = GetLastError();
                        switch (nErrCode)
                        {
                            case (OF_WRITEPROTECTION) :
                            case (OF_DISKFULL) :
                            case (OF_DISKFULL2) :
                            case (OF_NETACCESSDENIED) :
                            case (OF_ACCESSDENIED) :
                            {
                                break;
                            }
                            default :
                            {
                                nErrCode = 0;
                                break;
                            }
                        }

                        goto Warning;
                    }
                }
            }
        }
    }

    nFileOffset = _CopyFileNameToOFN(szPathName, NULL);

    _CopyTitleToOFN(szPathName + nFileOffset);

    _PostProcess(szPathName);

    bRet = TRUE;

ReturnFromOKButtonPressed:

    EnableModelessSB(TRUE);

    if ((pExpFile != szExpFile) && (pExpFile != _pszObjectPath))
    {
        LocalFree(pExpFile);
    }

    return (bRet);
}


void CFileOpenBrowser::_CopyTitleToOFN(LPCTSTR pszTitle)
{
    //
    //  File Title.
    //  Note that it's cut off at whatever the buffer length
    //    is, so if the buffer's too small, no notice is given.
    //
    if (_pOFN->lpstrFileTitle)
    {
        StrCpyN(_pOFN->lpstrFileTitle, pszTitle, _pOFN->nMaxFileTitle);
    }
}

int CFileOpenBrowser::_CopyFileNameToOFN(LPTSTR pszFile, DWORD *pdwError)
{
    int nExtOffset, nOldExt, nFileOffset = ParseFileOld(pszFile, &nExtOffset, &nOldExt, FALSE, TRUE);

    //NULL can be passed in to this function if we don't care about the error condition!
    if (pdwError)
        *pdwError = 0; //Assume no error.

    _pOFN->nFileOffset = (WORD) (nFileOffset == -1? lstrlen(pszFile) : nFileOffset);
    _pOFN->nFileExtension = (WORD) nOldExt;

    _pOFN->Flags &= ~OFN_EXTENSIONDIFFERENT;
    if (_pOFN->lpstrDefExt && _pOFN->nFileExtension)
    {
        TCHAR szPrivateExt[MIN_DEFEXT_LEN];

        //
        //  Check against _pOFN->lpstrDefExt, not _pszDefExt.
        //
        lstrcpyn(szPrivateExt, _pOFN->lpstrDefExt, MIN_DEFEXT_LEN);
        if (lstrcmpi(szPrivateExt, pszFile + nOldExt))
        {
            _pOFN->Flags |= OFN_EXTENSIONDIFFERENT;
        }
    }

    if (_pOFN->lpstrFile)
    {
        DWORD cch = lstrlen(pszFile) + 1;
        if (_pOFN->Flags & OFN_ALLOWMULTISELECT)
        {
            //
            //  Extra room for double-NULL.
            //
            ++cch;
        }

        if (cch <= LOWORD(_pOFN->nMaxFile))
        {
            lstrcpy(_pOFN->lpstrFile, pszFile);
            if (_pOFN->Flags & OFN_ALLOWMULTISELECT)
            {
                //
                //  Double-NULL terminate.
                //
                *(_pOFN->lpstrFile + cch - 1) = CHAR_NULL;
            }

            if (!(_pOFN->Flags & OFN_NOCHANGEDIR) && !PathIsUNC(pszFile) && nFileOffset)
            {
                TCHAR ch = _pOFN->lpstrFile[nFileOffset];
                _pOFN->lpstrFile[nFileOffset] = CHAR_NULL;
                SetCurrentDirectory(_pOFN->lpstrFile);
                _pOFN->lpstrFile[nFileOffset] = ch;
            }
        }
        else
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            StoreLengthInString((LPTSTR)_pOFN->lpstrFile, (UINT)_pOFN->nMaxFile, (UINT)cch);

            if (pdwError)
                *pdwError = FNERR_BUFFERTOOSMALL; //This is an error!
        }
    }

    return nFileOffset;
}

HRESULT CFileOpenBrowser::_MakeFakeCopy(IShellItem *psi, LPWSTR *ppszPath)
{
    //
    //  now we have to create a temp file
    //  to pass back to the client.  
    //  we will do this in the internet cache.
    //
    //  FEATURE - this should be a service in shell32 - zekel 11-AUG-98
    //  we should create a dependancy  on wininet from 
    //  comdlg32.  this should really be some sort of 
    //  service in shell32 that we call.  CreateShellItemTempFile()..
    //

    ILocalCopy *plc;
    HRESULT hr = psi->BindToHandler(NULL, BHID_LocalCopyHelper, IID_PPV_ARG(ILocalCopy, &plc));

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc = NULL;
        //  hr = SIAddBindCtxOfProgressUI(_hwndDlg, NULL, NULL, &pbc);
        
        if (SUCCEEDED(hr))
        {
            hr = plc->Download(LCDOWN_READONLY, pbc, ppszPath);

        }
        plc->Release();
    }

    return hr;
}

class CAsyncParseHelper
{
public:
    CAsyncParseHelper(IUnknown *punkSite, IBindCtx *pbc);

    STDMETHODIMP_(ULONG) AddRef()
        {
            return InterlockedIncrement(&_cRef);
        }

    STDMETHODIMP_(ULONG) Release()
        {
            if (InterlockedDecrement(&_cRef))
                return _cRef;

            delete this;
            return 0;
        }

    HRESULT ParseAsync(IShellFolder *psf, LPCWSTR pszName, LPITEMIDLIST *ppidl, ULONG *pdwAttribs);

protected:  //  methods
    ~CAsyncParseHelper();
    static DWORD WINAPI CAsyncParseHelper::s_ThreadProc(void *pv);
    HRESULT _Prepare(IShellFolder *psf, LPCWSTR pszName);
    HRESULT _GetFolder(IShellFolder **ppsf);
    void _Parse();
    HRESULT _Pump();

protected:  //  members
    LONG _cRef;
    IUnknown *_punkSite;
    IBindCtx *_pbc;
    LPWSTR _pszName;
    DWORD _dwAttribs;
    HWND _hwnd;
    HANDLE _hEvent;
    LPITEMIDLIST _pidl;
    HRESULT _hrParse;

    IShellFolder *_psfFree;  //  is alright dropping between threads
    LPITEMIDLIST _pidlFolder;   //  bind to it in the right thread
};

CAsyncParseHelper::~CAsyncParseHelper()
{
    if (_pszName)
        LocalFree(_pszName);

    if (_punkSite)
        _punkSite->Release();

    if (_psfFree)
        _psfFree->Release();

    if (_pbc)
        _pbc->Release();

    if (_hEvent)
        CloseHandle(_hEvent);

    ILFree(_pidl);
    ILFree(_pidlFolder);
}
    
CAsyncParseHelper::CAsyncParseHelper(IUnknown *punkSite, IBindCtx *pbc)
    : _cRef(1), _hrParse(E_UNEXPECTED)
{
    if (punkSite)
    {
        _punkSite = punkSite;
        punkSite->AddRef();
        IUnknown_GetWindow(_punkSite, &_hwnd);
    }

    if (pbc)
    {
        _pbc = pbc;
        pbc->AddRef();
    }
}

HRESULT CAsyncParseHelper::_GetFolder(IShellFolder **ppsf)
{
    HRESULT hr;
    if (_psfFree)
    {
        _psfFree->AddRef();
        *ppsf = _psfFree;
        hr = S_OK;
    }
    else if (_pidlFolder)
    {
        hr = SHBindToObjectEx(NULL, _pidlFolder, NULL, IID_PPV_ARG(IShellFolder, ppsf));
    }
    else
        hr = SHGetDesktopFolder(ppsf);

    return hr;
}
 
void CAsyncParseHelper::_Parse()
{
    IShellFolder *psf;
    _hrParse = _GetFolder(&psf);

    if (SUCCEEDED(_hrParse))
    {
        _hrParse = IShellFolder_ParseDisplayName(psf, _hwnd, _pbc, _pszName, NULL, &_pidl, _dwAttribs ? &_dwAttribs : NULL);
        psf->Release();
    }
    
    SetEvent(_hEvent);
}
    
DWORD WINAPI CAsyncParseHelper::s_ThreadProc(void *pv)
{
    CAsyncParseHelper *paph = (CAsyncParseHelper *)pv;
    paph->_Parse();
    paph->Release();
    return 0;
}

HRESULT CAsyncParseHelper::_Prepare(IShellFolder *psf, LPCWSTR pszName)
{
    _pszName = StrDupW(pszName);
    _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    HRESULT hr = _pszName && _hEvent ? S_OK : E_OUTOFMEMORY;
    
    if (SUCCEEDED(hr) && psf)
    {
        IPersistFreeThreadedObject *pfto;
        hr = psf->QueryInterface(IID_PPV_ARG(IPersistFreeThreadedObject, &pfto));

        if (SUCCEEDED(hr))
        {
            _psfFree = psf;
            psf->AddRef();
            pfto->Release();
            
        }
        else
        {
            hr = SHGetIDListFromUnk(psf, &_pidlFolder);
        }
    }

    return hr;
}

HRESULT CAsyncParseHelper::ParseAsync(IShellFolder *psf, LPCWSTR pszName, LPITEMIDLIST *ppidl, ULONG *pdwAttribs)
{
    HRESULT hr = _Prepare(psf, pszName);

    if (pdwAttribs)
        _dwAttribs = *pdwAttribs;

    //  take one for the thread
    AddRef();
    if (SUCCEEDED(hr) && SHCreateThread(CAsyncParseHelper::s_ThreadProc, this, CTF_COINIT, NULL))
    {
        //  lets go modal
        IUnknown_EnableModeless(_punkSite, FALSE);
        hr = _Pump();
        IUnknown_EnableModeless(_punkSite, TRUE);

        if (SUCCEEDED(hr))
        {
            ASSERT(_pidl);
            *ppidl = _pidl;
            _pidl = NULL;

            if (pdwAttribs)
                *pdwAttribs = _dwAttribs;
        }
        else
        {
            ASSERT(!_pidl);
        }
    }
    else
    {
        //  release because the thread wont
        Release();
        //  hr = IShellFolder_ParseDisplayName(_psf, _hwnd, _pbc, pszName, NULL, ppidl, pdwAttribs);
    }

    if (FAILED(hr))
        *ppidl = NULL;

    return hr;
}
    
HRESULT CAsyncParseHelper::_Pump()
{
    BOOL fCancelled = FALSE;
    while (!fCancelled)
    {
        DWORD dwWaitResult = MsgWaitForMultipleObjects(1, &_hEvent, FALSE,
                INFINITE, QS_ALLINPUT);
        if (dwWaitResult != (DWORD)-1)
        {
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                //  our event was triggered
                //  that means that we have finished
                break;
            }
            else
            {
                //  there is a message
                MSG msg;
                // There was some message put in our queue, so we need to dispose
                // of it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    //  maybe there should be a flag to allow this??
                    if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
                    {
                        fCancelled = TRUE;
                        break;
                    }
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }

                    if (g_bUserPressedCancel)
                    {
                        fCancelled = TRUE;
                        break;
                    }
                }

            } 
        }
        else
        {
            ASSERT(FAILED(_hrParse));
            break;
        }
    }

    if (fCancelled)
    {
        // Better NULL the pidl out. ParseAsync expects a NULL _pidl if _Pump returns an error code.
        ILFree(_pidl);
        _pidl = NULL;
        // clear this for the parse
        g_bUserPressedCancel = FALSE; 
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else
        return _hrParse;
}

STDAPI SHParseNameAsync(IShellFolder *psf, IBindCtx *pbc, LPCWSTR pszName, IUnknown *punkSite, LPITEMIDLIST *ppidl, DWORD *pdwAttribs)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAsyncParseHelper *paph = new CAsyncParseHelper(punkSite, pbc);

    if (paph)
    {
        hr = paph->ParseAsync(psf, pszName, ppidl, pdwAttribs);
        paph->Release();
    }
    return hr;
}

//
//  _ParseName()
//  psf  =  the shell folder to bind/parse with  if NULL, use desktop
//  pszIn=  the string that should parsed into a ppmk
//  ppmk =  the IShellItem * that is returned with S_OK
//
//  WARNING:  this will jumpto a folder if that was what was passed in...
//
//  returns S_OK     if it got an IShellItem for the item with the specified folder
//          S_FALSE  if it was the wrong shellfolder; try again with a different one
//          ERROR    for any problems
//
HRESULT CFileOpenBrowser::_ParseName(LPCITEMIDLIST pidlParent, IShellFolder *psf, IBindCtx *pbc, LPCOLESTR psz, IShellItem **ppsi)
{
    IBindCtx *pbcLocal;
    HRESULT hr = BindCtx_RegisterObjectParam(pbc, STR_PARSE_PREFER_FOLDER_BROWSING, SAFECAST(this, IShellBrowser *), &pbcLocal);
    *ppsi = NULL;
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = NULL;

        hr = SHParseNameAsync(psf, pbcLocal, psz, SAFECAST(this, IShellBrowser *), &pidl, NULL);
        if (SUCCEEDED(hr))
        {
            ASSERT(pidl);

            hr = SHCreateShellItem(pidlParent, pidlParent ? psf : NULL, pidl, ppsi);

            ILFree(pidl);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            hr = S_FALSE;
        }
        else if (psf && !pbc)
        {
            if (SUCCEEDED(pbcLocal->RegisterObjectParam(STR_DONT_PARSE_RELATIVE, psf)))
            {
                //  try to hit it from the desktop
                HRESULT hrNew = _ParseName(NULL, NULL, pbcLocal, psz, ppsi);
                // else prop back the original error
                hr = SUCCEEDED(hrNew) ? hrNew : hr;
            }
        }
        pbcLocal->Release();
    }

    return hr;
}

BOOL CFileOpenBrowser::_OpenAsContainer(IShellItem *psi, SFGAOF sfgao)
{
    BOOL fRet = _bSave ? _IsSaveContainer(sfgao) : _IsOpenContainer(sfgao);

    if (fRet && (sfgao & SFGAO_STREAM))
    {
        //  this is really both a folder and a file
        //  we guess which the caller wants by looking 
        //  at the extension
        LPWSTR psz;
        if (SUCCEEDED(psi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &psz)))
        {
            //  if the filter equals what ever we are looking at
            //  we assume the caller is actually looking for
            //  this file.
            fRet = !PathMatchSpec(psz, _szLastFilter);
            CoTaskMemFree(psz);
        }
    }

    return fRet;
}

HRESULT CFileOpenBrowser::_TestShellItem(IShellItem *psi, BOOL fAllowJump, IShellItem **ppsiReal)
{
    SFGAOF flags;
    psi->GetAttributes(SFGAO_STORAGECAPMASK, &flags);

    HRESULT hr = E_ACCESSDENIED;
    *ppsiReal = NULL;
    if (_OpenAsContainer(psi, flags))
    {
        //  we have a subfolder that has been selected.
        //  jumpto it instead
        if (fAllowJump)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetIDListFromUnk(psi, &pidl)))
            {
                JumpToIDList(pidl);
                ILFree(pidl);
            }
        }
        hr = S_FALSE;
    }
    else if ((flags & SFGAO_LINK) && ((flags & SFGAO_FOLDER) || !_IsNoDereferenceLinks(NULL, psi)))
    {
        // If this is a link, and (we should dereference links, or it's also a folder [folder shortcut])
        IShellItem *psiTarget;
        if (SUCCEEDED(psi->BindToHandler(NULL, BHID_LinkTargetItem, IID_PPV_ARG(IShellItem, &psiTarget))))
        {
            hr = _TestShellItem(psiTarget, fAllowJump, ppsiReal);
            psiTarget->Release();
        }
    }
    else if (_IsStream(flags))
    {
        *ppsiReal = psi;
        psi->AddRef();
        hr = S_OK;
    }

    return hr;
}


HRESULT CFileOpenBrowser::_ParseNameAndTest(LPCOLESTR pszIn, IBindCtx *pbc, IShellItem **ppsi, BOOL fAllowJump)
{
    IShellItem *psi;
    HRESULT hr = _ParseName(_pCurrentLocation->pidlFull, _psfCurrent, pbc, pszIn, &psi);
    
    if (S_OK == hr)
    {
        hr = _TestShellItem(psi, fAllowJump, ppsi);

        psi->Release();
    }
        
    return hr;
}

BOOL _FailedBadPath(HRESULT hr)
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
    case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
        return TRUE;
    }
    return FALSE;
}

    
#define STR_ACTIONPROGRESS L"ActionProgress"

STDAPI BindCtx_BeginActionProgress(IBindCtx *pbc, SPACTION action, SPBEGINF flags, IActionProgress **ppap)
{
    HRESULT hr = E_NOINTERFACE; // default to no
    IUnknown *punk;
    *ppap = NULL;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_ACTIONPROGRESS, &punk)))
    {
        IActionProgress *pap;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IActionProgress, &pap))))
        {
            hr = pap->Begin(action, flags);

            if (SUCCEEDED(hr))
                *ppap = pap;
            else
                pap->Release();
        }
        punk->Release();
    }
    return hr;
}

HRESULT CFileOpenBrowser::_ParseShellItem(LPCOLESTR pszIn, IShellItem **ppsi, BOOL fAllowJump)
{
    WAIT_CURSOR w(this);
    EnableModelessSB(FALSE);
    HRESULT hr = _ParseNameAndTest(pszIn, NULL, ppsi, fAllowJump);

    if (_FailedBadPath(hr))
    {
        //  try again with a better string
        SHSTR str;
        if ((LPTSTR)_pszDefExt && (0 == *(PathFindExtension(pszIn)))
        && SUCCEEDED(str.SetSize(lstrlen(pszIn) + lstrlen(_pszDefExt) + 2)))
        {
            str.SetStr(pszIn);
            AppendExt(str.GetInplaceStr(), _pszDefExt, FALSE);
            pszIn = str.GetStr();
            hr = _ParseNameAndTest(pszIn, NULL, ppsi, fAllowJump);
        }

        if (_FailedBadPath(hr) && _bSave)
        {
            // when we are saving, then we 
            // try to force the creation of this item
            IBindCtx *pbc;
            if (SUCCEEDED(CreateBindCtx(0, &pbc)))
            {
                BIND_OPTS bo = {0};
                bo.cbStruct = SIZEOF(bo);
                bo.grfMode = STGM_CREATE;
                pbc->SetBindOptions(&bo);
                hr = _ParseNameAndTest(pszIn, pbc, ppsi, fAllowJump);
                pbc->Release();
            }
        }
    }

    EnableModelessSB(TRUE);
    return hr;
}

class CShellItemList : IEnumShellItems
{
public:
    CShellItemList() : _cRef(1) {}
    
    //  IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumShellItems **ppenum);

    HRESULT Add(IShellItem *psi);

private: // methods
    ~CShellItemList();

    BOOL _NextOne(IShellItem **ppsi);
    
private: // members
    LONG _cRef;
    CDPA<IShellItem> _dpaItems;
    int _iItem;
};

STDMETHODIMP CShellItemList::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItemList, IEnumShellItems),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItemList::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItemList::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellItemList::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    ULONG cFetched = 0;
    while (celt-- && SUCCEEDED(hr))
    {
        if (_NextOne(&rgelt[cFetched]))
            cFetched++;
        else
            break;
    }

    if (cFetched)
    {
        *pceltFetched = cFetched;
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP CShellItemList::Skip(ULONG celt)
{
    _iItem += celt;
    return S_OK;
}

STDMETHODIMP CShellItemList::Reset()
{
    _iItem = 0;
    return S_OK;
}

STDMETHODIMP CShellItemList::Clone(IEnumShellItems **ppenum)
{
    return E_NOTIMPL;
}

HRESULT  CShellItemList::Add(IShellItem *psi)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (!_dpaItems)
    {
        _dpaItems.Create(4);
    }

    if (_dpaItems)
    {
        if (-1 != _dpaItems.AppendPtr(psi))
        {
            psi->AddRef();
            hr = S_OK;
        }
    }

    return hr;
}

 CShellItemList::~CShellItemList()
 {
    if (_dpaItems)
    {
        for (int i = 0; i < _dpaItems.GetPtrCount(); i++)
        {
            _dpaItems.FastGetPtr(i)->Release();
        }
        _dpaItems.Destroy();
    }
}

BOOL CShellItemList::_NextOne(IShellItem **ppsi)
{
    if (_dpaItems && _iItem < _dpaItems.GetPtrCount())
    {
        *ppsi = _dpaItems.GetPtr(_iItem);

        if (*ppsi)
        {
            (*ppsi)->AddRef();
            _iItem++;
            return TRUE;
        }
    }

    return FALSE;
}

#ifdef RETURN_SHELLITEMS
HRESULT CFileOpenBrowser::_ItemOKButtonPressed(LPCWSTR pszFile, OKBUTTONFLAGS Flags)
{
    CShellItemList *psil = new CShellItemList();
    HRESULT hr = psil ? S_OK : E_OUTOFMEMORY;

    ASSERT(IS_NEW_OFN(_pOFN));

    if (SUCCEEDED(hr))
    {
        SHSTR str;
        hr = str.SetSize(lstrlen(pszFile) * 2);

        if (SUCCEEDED(hr))
        {
            WAIT_CURSOR w(this);
            DWORD cFiles = 1;
            SHExpandEnvironmentStrings(pszFile, str, str.GetSize());

            if ((_pOFN->Flags & OFN_ALLOWMULTISELECT) && StrChr(str, CHAR_QUOTE))
            {
                //  need to handle MULTISEL here...
                //  str points to a bunch of quoted strings.
                //  alloc enough for the strings and an extra NULL terminator
                hr = str.SetSize(str.GetLen() + 1);

                if (SUCCEEDED(hr))
                {
                    cFiles = ConvertToNULLTerm(str);
                }
            }

            if (SUCCEEDED(hr))
            {
                BOOL fSingle = cFiles == 1;
                LPTSTR pch = str;

                for (; cFiles; cFiles--)
                {
                    IShellItem *psi;
                    hr = _ParseShellItem(pch, &psi, fSingle);
                    //  go to the next item
                    if (S_OK == hr)
                    {
                        hr = psil->Add(psi);
                        psi->Release();
                    }
                    else  // S_FALSE or failure we stop parsing
                    {
                        if (FAILED(hr))
                            InvalidFileWarningNew(_hwndDlg, pch, OFErrFromHresult(hr));

                        break;
                    }

                    //  goto the next string
                    pch += lstrlen(pch) + 1;
                }

                //  we have added everything to our list
                if (hr == S_OK)
                {
                    hr = psil->QueryInterface(IID_PPV_ARG(IEnumShellItems, &(_pOFN->penum)));
                }
            }
            
        }

        psil->Release();
    }

    return hr;
}
#endif RETURN_SHELLITEMS

////////////////////////////////////////////////////////////////////////////
//
//  DriveList_OpenClose
//
//  Change the state of a drive list.
//
////////////////////////////////////////////////////////////////////////////

#define OCDL_TOGGLE     0x0000
#define OCDL_OPEN       0x0001
#define OCDL_CLOSE      0x0002

void DriveList_OpenClose(
    UINT uAction,
    HWND hwndDriveList)
{
    if (!hwndDriveList || !IsWindowVisible(hwndDriveList))
    {
        return;
    }

OpenClose_TryAgain:
    switch (uAction)
    {
        case (OCDL_TOGGLE) :
        {
            uAction = SendMessage(hwndDriveList, CB_GETDROPPEDSTATE, 0, 0L)
                          ? OCDL_CLOSE
                          : OCDL_OPEN;
            goto OpenClose_TryAgain;
            break;
        }
        case (OCDL_OPEN) :
        {
            SetFocus(hwndDriveList);
            SendMessage(hwndDriveList, CB_SHOWDROPDOWN, TRUE, 0);
            break;
        }
        case (OCDL_CLOSE) :
        {
            if (SHIsChildOrSelf(hwndDriveList,GetFocus()) == S_OK)
            {
                SendMessage(hwndDriveList, CB_SHOWDROPDOWN, FALSE, 0);
            }
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetFullEditName
//
//  Returns the number of characters needed to get the full path, including
//  the NULL.
//
////////////////////////////////////////////////////////////////////////////

UINT CFileOpenBrowser::GetFullEditName(
    LPTSTR pszBuf,
    UINT cLen,
    TEMPSTR *pTempStr,
    BOOL *pbNoDefExt)
{
    UINT cTotalLen;
    HWND hwndEdit;

    if (_bUseHideExt)
    {
        cTotalLen = lstrlen(_pszHideExt) + 1;
    }
    else
    {
        if (_bUseCombo)
        {
            hwndEdit = (HWND)SendMessage(GetDlgItem(_hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        }
        else
        {

            hwndEdit = GetDlgItem(_hwndDlg, edt1);
        }

        cTotalLen = GetWindowTextLength(hwndEdit) + 1;
    }

    if (pTempStr)
    {
        if (!pTempStr->StrSize(cTotalLen))
        {
            return ((UINT)-1);
        }

        pszBuf = *pTempStr;
        cLen = cTotalLen;
    }

    if (_bUseHideExt)
    {
        lstrcpyn(pszBuf, _pszHideExt, cLen);
    }
    else
    {
        GetWindowText(hwndEdit, pszBuf, cLen);
    }

    if (pbNoDefExt)
    {
        *pbNoDefExt = _bUseHideExt;
    }

    return (cTotalLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ProcessEdit
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ProcessEdit()
{
    TEMPSTR pMultiSel;
    LPTSTR pszFile;
    BOOL bNoDefExt = TRUE;
    OKBUTTONFLAGS Flags = OKBUTTON_NONE;
    TCHAR szBuf[MAX_PATH + 4];

    //if we have a saved pidl then use it instead
    if (_pidlSelection && _ProcessPidlSelection())
    {
        return;
    }

    if (_pOFN->Flags & OFN_ALLOWMULTISELECT)
    {
        if (GetFullEditName(szBuf,
                             ARRAYSIZE(szBuf),
                             &pMultiSel,
                             &bNoDefExt) == (UINT)-1)
        {
            //
            //  FEATURE There should be some error message here.
            //
            return;
        }
        pszFile = pMultiSel;
    }
    else
    {
        if (_bSelIsObject)
        {
            pszFile = _pszObjectPath;
        }
        else
        {
            GetFullEditName(szBuf, ARRAYSIZE(szBuf), NULL, &bNoDefExt);
            pszFile = szBuf;

            PathRemoveBlanks(pszFile);

            int nLen = lstrlen(pszFile);

            if (*pszFile == CHAR_QUOTE)
            {
                LPTSTR pPrev = CharPrev(pszFile, pszFile + nLen);
                if (*pPrev == CHAR_QUOTE && pszFile != pPrev)
                {
                    Flags |= OKBUTTON_QUOTED;

                    //
                    //  Strip the quotes.
                    //
                    *pPrev = CHAR_NULL;
                    lstrcpy(pszFile, pszFile + 1);
                }
            }
        }
    }

    if (bNoDefExt)
    {
        Flags |= OKBUTTON_NODEFEXT;
    }

    //
    //  Visual Basic passes in an uninitialized lpDefExts string.
    //  Since we only have to use it in OKButtonPressed, update
    //  lpstrDefExts here along with whatever else is only needed
    //  in OKButtonPressed.
    //
    if (_pOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameA2WDelayed(_pOFI);
    }

    //  handle special case parsing right here.
    //  our current folder and the desktop both failed
    //  to figure out what this is.
    if (PathIsDotOrDotDot(pszFile))
    {
        if (pszFile[1] == CHAR_DOT)
        {
            // this is ".."
            LPITEMIDLIST pidl = GetIDListFromFolder(_psfCurrent);
            if (pidl)
            {
                ILRemoveLastID(pidl);
                JumpToIDList(pidl);
                ILFree(pidl);
            }
        }
    }
    else if (OKButtonPressed(pszFile, Flags))
    {
        BOOL bReturn = TRUE;

        if (_pOFN->lpstrFile)
        {
            if (!(_pOFN->Flags & OFN_NOVALIDATE))
            {
                if (_pOFN->nMaxFile >= 3)
                {
                    if ((_pOFN->lpstrFile[0] == 0) ||
                        (_pOFN->lpstrFile[1] == 0) ||
                        (_pOFN->lpstrFile[2] == 0))
                    {
                        bReturn = FALSE;
                        StoreExtendedError(FNERR_BUFFERTOOSMALL);
                    }
                }
                else
                {
                    bReturn = FALSE;
                    StoreExtendedError(FNERR_BUFFERTOOSMALL);
                }
            }
        }

        _CleanupDialog(bReturn);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::InitializeDropDown
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::InitializeDropDown(HWND hwndCtl)
{
    if (!_bDropped)
    {
        MYLISTBOXITEM *pParentItem;
        SHChangeNotifyEntry fsne[2];

        //
        //  Expand the Desktop item.
        //
        pParentItem = GetListboxItem(hwndCtl, _iNodeDesktop);

        if (pParentItem)
        {
            UpdateLevel(hwndCtl, _iNodeDesktop + 1, pParentItem);

            fsne[0].pidl = pParentItem->pidlFull;
            fsne[0].fRecursive = FALSE;

            //
            //  Look for the My Computer item, since it may not necessarily
            //  be the next one after the Desktop.
            //
            LPITEMIDLIST pidlDrives;
            if (SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidlDrives) == S_OK)
            {
                int iNode = _iNodeDesktop;
                while (pParentItem = GetListboxItem(hwndCtl, iNode))
                {
                    if (ILIsEqual(pParentItem->pidlFull, pidlDrives))
                    {
                        _iNodeDrives = iNode;
                        break;
                    }
                    iNode++;
                }
                ILFree(pidlDrives);
            }

            //
            //  Make sure My Computer was found.  If not, then just assume it's
            //  in the first spot after the desktop (this shouldn't happen).
            //
            if (pParentItem == NULL)
            {
                pParentItem = GetListboxItem(hwndCtl, _iNodeDesktop + 1);
                _iNodeDrives = _iNodeDesktop +1;
            }

            if (pParentItem)
            {
                //
                //  Expand the My Computer item.
                //
                UpdateLevel(hwndCtl, _iNodeDrives + 1, pParentItem);

                _bDropped = TRUE;

                fsne[1].pidl = pParentItem->pidlFull;
                fsne[1].fRecursive = FALSE;
            }

            _uRegister = SHChangeNotifyRegister(
                            _hwndDlg,
                            SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_NewDelivery,
                            SHCNE_ALLEVENTS &
                                ~(SHCNE_CREATE | SHCNE_DELETE | SHCNE_RENAMEITEM),
                                CDM_FSNOTIFY, pParentItem ? ARRAYSIZE(fsne) : ARRAYSIZE(fsne) - 1,
                                fsne);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnCommandMessage
//
//  Process a WM_COMMAND message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CFileOpenBrowser::OnCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{
    int idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCmd)
    {
        case (edt1) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case (EN_CHANGE) :
                {
                    _bUseHideExt = FALSE;

                    Pidl_Set(&_pidlSelection,NULL);;
                    break;
                }
            }
            break;
        }

        case (cmb13) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case (CBN_EDITCHANGE) :
                {
                    _bUseHideExt = FALSE;
                    Pidl_Set(&_pidlSelection,NULL);;
                    break;
                }

                case (CBN_DROPDOWN) :
                {
                    LoadMRU(_szLastFilter,
                             GET_WM_COMMAND_HWND(wParam, lParam),
                             MAX_MRU);
                    break;

                }

                case (CBN_SETFOCUS) :
                {
                    SetModeBias(MODEBIASMODE_FILENAME);
                    break;
                }

                case (CBN_KILLFOCUS) :
                {
                    SetModeBias(MODEBIASMODE_DEFAULT);
                    break;
                }
            }
            break;
        }

        case (cmb2) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case (CBN_CLOSEUP) :
                {
                    OnSelChange();
                    UpdateNavigation();
                    SelectEditText(_hwndDlg);
                    return TRUE;
                }
                case (CBN_DROPDOWN) :
                {
                    InitializeDropDown(GET_WM_COMMAND_HWND(wParam, lParam));
                    break;
                }
            }
            break;
        }

        case (cmb1) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case (CBN_DROPDOWN) :
                {
                    _iComboIndex = (int) SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                                      CB_GETCURSEL,
                                                      NULL,
                                                      NULL);
                    break;
                }
                //
                //  We're trying to see if anything changed after
                //  (and only after) the user is done scrolling through the
                //  drop down. When the user tabs away from the combobox, we
                //  do not get a CBN_SELENDOK.
                //  Why not just use CBN_SELCHANGE? Because then we'd refresh
                //  the view (very slow) as the user scrolls through the
                //  combobox.
                //
                case (CBN_CLOSEUP) :
                case (CBN_SELENDOK) :
                {
                    //
                    //  Did anything change?
                    //
                    if (_iComboIndex >= 0 &&
                        _iComboIndex == SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                                     CB_GETCURSEL,
                                                     NULL,
                                                     NULL))
                    {
                        break;
                    }
                }
                case (MYCBN_DRAW) :
                {
                    RefreshFilter(GET_WM_COMMAND_HWND(wParam, lParam));
                    _iComboIndex = -1;
                    return TRUE;
                }
                default :
                {
                    break;
                }
            }
            break;
        }
        case (IDC_PARENT) :
        {
            OnDotDot();
            SelectEditText(_hwndDlg);
            break;
        }
        case (IDC_NEWFOLDER) :
        {
            ViewCommand(VC_NEWFOLDER);
            break;
        }

        case (IDC_VIEWLIST) :
        {
            
            SendMessage(_hwndView, WM_COMMAND, (WPARAM)SFVIDM_VIEW_LIST, 0);
            break;
        }

        case (IDC_VIEWDETAILS) :
        {

            SendMessage(_hwndView, WM_COMMAND, (WPARAM)SFVIDM_VIEW_DETAILS,0);
            break;
        }


        case (IDC_VIEWMENU) :
        {
            //
            //  Pass off the nCmdID to the view for processing / translation.
            //
            DFVCMDDATA cd;

            cd.pva = NULL;
            cd.hwnd = _hwndDlg;
            cd.nCmdIDTranslated = 0;
            SendMessage(_hwndView, WM_COMMAND, SFVIDM_VIEW_VIEWMENU, (LONG_PTR)&cd);

            break;
        }
        
        case (IDOK) :
        {
            HWND hwndFocus = ::GetFocus();

            if (hwndFocus == ::GetDlgItem(_hwndDlg, IDOK))
            {
                hwndFocus = _hwndLastFocus;
            }

            hwndFocus = GetFocusedChild(_hwndDlg, hwndFocus);

            if (hwndFocus == _hwndView)
            {
                OnDblClick(TRUE);
            }
            else if (_hwndPlacesbar && (hwndFocus == _hwndPlacesbar))
            {
                //Places bar has the focus. Get the current hot item.
                INT_PTR i = SendMessage(_hwndPlacesbar, TB_GETHOTITEM, 0,0);
                if (i >= 0)
                {
                    //Get the Pidl for this button.
                    TBBUTTONINFO tbbi;

                    tbbi.cbSize = SIZEOF(tbbi);
                    tbbi.lParam = 0;
                    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
                    if (SendMessage(_hwndPlacesbar, TB_GETBUTTONINFO, i, (LPARAM)&tbbi) >= 0)
                    {
                        LPITEMIDLIST pidl= (LPITEMIDLIST)tbbi.lParam;

                        if (pidl)
                        {
                            //Jump to the location corresponding to this Button
                            JumpToIDList(pidl, FALSE, TRUE);
                        }
                    }

                }

            }
            else
            {
                ProcessEdit();
            }

            SelectEditText(_hwndDlg);
            break;
        }
        case (IDCANCEL) :
        {
            //  the parse async can listen for this
            g_bUserPressedCancel = TRUE;
            _hwndModelessFocus = NULL;           
           
            if (!_cRefCannotNavigate)
            {
                _CleanupDialog(FALSE);
            }
               
            return TRUE;
        }
        case (pshHelp) :
        {
            if (_hSubDlg)
            {
                CD_SendHelpNotify(_hSubDlg, _hwndDlg, _pOFN, _pOFI);
            }

            if (_pOFN->hwndOwner)
            {
                CD_SendHelpMsg(_pOFN, _hwndDlg, _pOFI->ApiType);
            }
            break;
        }
        case (IDC_DROPDRIVLIST) :         // VK_F4
        {
            //
            //  If focus is on the "File of type" combobox,
            //  then F4 should open that combobox, not the "Look in" one.
            //
            HWND hwnd = GetFocus();

            if (_bUseCombo &&
                (SHIsChildOrSelf(GetDlgItem(_hwndDlg, cmb13), hwnd) == S_OK)
              )
            {
                hwnd = GetDlgItem(_hwndDlg, cmb13);
            }

            if ((hwnd != GetDlgItem(_hwndDlg, cmb1)) &&
                (hwnd != GetDlgItem(_hwndDlg, cmb13))
              )
            {
                //
                //  We shipped Win95 where F4 *always* opens the "Look in"
                //  combobox, so keep F4 opening that even when it shouldn't.
                //
                hwnd = GetDlgItem(_hwndDlg, cmb2);
            }
            DriveList_OpenClose(OCDL_TOGGLE, hwnd);
            break;
        }
        case (IDC_REFRESH) :
        {
            if (_psv)
            {
                _psv->Refresh();
            }
            break;
        }
        case (IDC_PREVIOUSFOLDER) :
        {
            OnDotDot();
            break;
        }

         //Back Navigation
        case (IDC_BACK) :
            // Try to travel in the directtion
            if (_ptlog && SUCCEEDED(_ptlog->Travel(TRAVEL_BACK)))
            {
                LPITEMIDLIST pidl;
                //Able to travel in the given direction.
                //Now Get the new pidl
                _ptlog->GetCurrent(&pidl);
                //Update the UI to reflect the current state
                UpdateUI(pidl);

                //Jump to the new location
                // second paremeter is whether to translate to logical pidl
                // and third parameter is whether to add to the navigation stack
                // since this pidl comes from the stack , we should not add this to
                // the navigation stack
                JumpToIDList(pidl, FALSE, FALSE);
                ILFree(pidl);
            }
            break;


    }

    if ((idCmd >= IDC_PLACESBAR_BASE)  && (idCmd <= (IDC_PLACESBAR_BASE + _iCommandID)))
    {
        TBBUTTONINFO tbbi;
        LPITEMIDLIST pidl;

        tbbi.cbSize = SIZEOF(tbbi);
        tbbi.lParam = 0;
        tbbi.dwMask = TBIF_LPARAM;
        if (SendMessage(_hwndPlacesbar, TB_GETBUTTONINFO, idCmd, (LPARAM)&tbbi) >= 0)
        {
            pidl = (LPITEMIDLIST)tbbi.lParam;

            if (pidl)
            {
                JumpToIDList(pidl, FALSE, TRUE);
            }
        }
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnCDMessage
//
//  Process a special CommDlg message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OnCDMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LONG lResult = -1;
    LPCITEMIDLIST pidl;
    LPTSTR pBuf = (LPTSTR)lParam;
    LPWSTR pBufW = NULL;
    int cbLen;

    //  we should make some better thunk wrappers for COMDLG_ANSI
    //  like OnCDMessageAorW() calls OnCDMessage()
    switch (uMsg)
    {
        case (CDM_GETSPEC) :
        case (CDM_GETFILEPATH) :
        case (CDM_GETFOLDERPATH) :
        {
            if (_pOFI->ApiType == COMDLG_ANSI)
            {
                if (pBufW = (LPWSTR)LocalAlloc(LPTR,
                                                (int)wParam * sizeof(WCHAR)))
                {
                    pBuf = pBufW;
                }
                else
                {
                    break;
                }
            }
            if (uMsg == CDM_GETSPEC)
            {
                lResult = GetFullEditName(pBuf, (UINT) wParam, NULL, NULL);
                break;
            }

            // else, fall thru...
        }
        case (CDM_GETFOLDERIDLIST) :
        {
            TCHAR szDir[MAX_PATH];

            pidl = _pCurrentLocation->pidlFull;

            if (uMsg == CDM_GETFILEPATH)
            {
                // We can't necessarily use the (current folder) + (edit box name) thing in this case
                // because the (current folder) could be incorrect, for example in the case
                // where the current folder is the desktop folder.  Items _could_ be in the
                // All Users desktop folder - in which case we want to return All Users\Desktop\file, not
                // <username>\Desktop\file
                // So we'll key off _pidlSelection... if that doesn't work, we fall back to the old
                // behaviour, which could be incorrect in some cases.
                if (pidl && _pidlSelection)
                {
                    LPITEMIDLIST pidlFull = ILCombine(pidl, _pidlSelection);
                    if (pidlFull)
                    {
                        if (SHGetPathFromIDList(pidlFull, szDir))
                        {
                            goto CopyAndReturn;
                        }

                        ILFree(pidlFull);
                    }

                }
            }

            lResult = ILGetSize(pidl);

            if (uMsg == CDM_GETFOLDERIDLIST)
            {
                if ((LONG)wParam < lResult)
                {
                    break;
                }

                CopyMemory((LPBYTE)pBuf, (LPBYTE)pidl, lResult);
                break;
            }



            if (!SHGetPathFromIDList(pidl, szDir))
            {
                *szDir = 0;
            }

            if (!*szDir)
            {
                lResult = -1;
                break;
            }


            if (uMsg == CDM_GETFOLDERPATH)
            {
CopyAndReturn:
                lResult = lstrlen(szDir) + 1;
                if ((LONG)wParam >= lResult)
                {
                    lstrcpyn(pBuf, szDir, lResult);
                }
                if (_pOFI->ApiType == COMDLG_ANSI)
                {
                    lResult = WideCharToMultiByte(CP_ACP,
                                                   0,
                                                   szDir,
                                                   -1,
                                                   NULL,
                                                   0,
                                                   NULL,
                                                   NULL);
                }
                if ((int)wParam > lResult)
                {
                    wParam = lResult;
                }
                break;
            }

            //
            //  We'll just fall through to the error case for now, since
            //  doing the full combine is not an easy thing.
            //
            TCHAR szFile[MAX_PATH];

            if (GetFullEditName(szFile, ARRAYSIZE(szFile), NULL, NULL) >
                 ARRAYSIZE(szFile) - 5)
            {
                //
                //  Oops!  It looks like we filled our buffer!
                //
                lResult = -1;
                break;
            }

            PathCombine(szDir, szDir, szFile);
            goto CopyAndReturn;
        }
        case (CDM_SETCONTROLTEXT) :
        {
            if (_pOFI->ApiType == COMDLG_ANSI)
            {
                //
                //  Need to convert pBuf (lParam) to Unicode.
                //
                cbLen = lstrlenA((LPSTR)pBuf) + 1;
                if (pBufW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR))))
                {
                    SHAnsiToUnicode((LPSTR)pBuf,pBufW,cbLen);
                    pBuf = pBufW;
                }
            }
            //Are we using combobox and the control they are setting is edit box?
            if (_bUseCombo && wParam == edt1)
            {
                //Change it to combo box.
                wParam = cmb13;
            }

            if (_bSave && wParam == IDOK)
            {
                _tszDefSave.StrCpy(pBuf);

                //
                //  Do this to set the OK button correctly.
                //
                SelFocusChange(TRUE);
            }
            else
            {
                SetDlgItemText(_hwndDlg, (int) wParam, pBuf);
            }

            break;
        }
        case (CDM_HIDECONTROL) :
        {
            //Make sure the control id is not zero (0 is child dialog)
            if ((int)wParam != 0)
            {
                ShowWindow(GetDlgItem(_hwndDlg, (int) wParam), SW_HIDE);
            }
            break;
        }
        case (CDM_SETDEFEXT) :
        {
            if (_pOFI->ApiType == COMDLG_ANSI)
            {
                //
                //  Need to convert pBuf (lParam) to Unicode.
                //
                cbLen = lstrlenA((LPSTR)pBuf) + 1;
                if (pBufW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR))))
                {
                    SHAnsiToUnicode((LPSTR)pBuf,pBufW,cbLen);
                    pBuf = pBufW;
                }
            }
            _pszDefExt.StrCpy(pBuf);
            _bNoInferDefExt = TRUE;

            break;
        }
        default:
        {
            lResult = -1;
            break;
        }
    }

    SetWindowLongPtr(_hwndDlg, DWLP_MSGRESULT, lResult);

    if (_pOFI->ApiType == COMDLG_ANSI)
    {
        switch (uMsg)
        {
            case (CDM_GETSPEC) :
            case (CDM_GETFILEPATH) :
            case (CDM_GETFOLDERPATH) :
            {
                //
                //  Need to convert pBuf (pBufW) to Ansi and store in lParam.
                //
                if (wParam && lParam)
                {
                    SHUnicodeToAnsi(pBuf,(LPSTR)lParam,(int) wParam);
                }
                break;
            }
        }

        if (pBufW)
        {
            LocalFree(pBufW);
        }
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  OKSubclass
//
//  Subclass window proc for the OK button.
//
//  The OK button is subclassed so we know which control had focus before
//  the user clicked OK.  This in turn lets us know whether to process OK
//  based on the current selection in the listview, or the current text
//  in the edit control.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndDlg = ::GetParent(hOK);
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hwndDlg);
    WNDPROC pOKProc = pDlgStruct ? pDlgStruct->_lpOKProc : NULL;

    if (pDlgStruct)
    {
        switch (msg)
        {
        case WM_SETFOCUS:
            pDlgStruct->_hwndLastFocus = (HWND)wParam;
            break;
        }
    }

    return ::CallWindowProc(pOKProc, hOK, msg, wParam, lParam);   
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetNodeFromIDList
//
////////////////////////////////////////////////////////////////////////////

int CFileOpenBrowser::GetNodeFromIDList(
    LPCITEMIDLIST pidl)
{
    int i;
    HWND hwndCB = GetDlgItem(_hwndDlg, cmb2);

    Assert(this->_bDropped);

    //
    //  Just check DRIVES and DESKTOP.
    //
    for (i = _iNodeDrives; i >= NODE_DESKTOP; --i)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCB, i);

        if (pItem && ILIsEqual(pidl, pItem->pidlFull))
        {
            break;
        }
    }

    return (i);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::FSChange
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::FSChange(
    LONG lNotification,
    LPCITEMIDLIST *ppidl)
{
    int iNode = -1;
    LPCITEMIDLIST pidl = ppidl[0];

    switch (lNotification)
    {
        case (SHCNE_RENAMEFOLDER) :
        {
            LPCITEMIDLIST pidlExtra = ppidl[1];

            //
            //  Rename is special.  We need to invalidate both
            //  the pidl and the pidlExtra, so we call ourselves.
            //
            FSChange(0, &pidlExtra);
        }
        case (0) :
        case (SHCNE_MKDIR) :
        case (SHCNE_RMDIR) :
        {
            LPITEMIDLIST pidlClone = ILClone(pidl);

            if (!pidlClone)
            {
                break;
            }
            ILRemoveLastID(pidlClone);

            iNode = GetNodeFromIDList(pidlClone);
            ILFree(pidlClone);
            break;
        }
        case (SHCNE_UPDATEITEM) :
        case (SHCNE_NETSHARE) :
        case (SHCNE_NETUNSHARE) :
        case (SHCNE_UPDATEDIR) :
        {
            iNode = GetNodeFromIDList(pidl);
            break;
        }
        case (SHCNE_DRIVEREMOVED) :
        case (SHCNE_DRIVEADD) :
        case (SHCNE_MEDIAINSERTED) :
        case (SHCNE_MEDIAREMOVED) :
        case (SHCNE_DRIVEADDGUI) :
        {
            iNode = _iNodeDrives;
            break;
        }
    }

    if (iNode >= 0)
    {
        //
        //  We want to delay the processing a little because we always do
        //  a full update, so we should accumulate.
        //
        SetTimer(_hwndDlg, TIMER_FSCHANGE + iNode, 100, NULL);
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::Timer
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::Timer(
    WPARAM wID)
{
    KillTimer(_hwndDlg, (UINT) wID);

    wID -= TIMER_FSCHANGE;

    ASSERT(this->_bDropped);

    HWND hwndCB;
    MYLISTBOXITEM *pParentItem;

    hwndCB = GetDlgItem(_hwndDlg, cmb2);

    pParentItem = GetListboxItem(hwndCB, wID);

    UpdateLevel(hwndCB, (int) wID + 1, pParentItem);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnGetMinMax
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnGetMinMax(
    LPMINMAXINFO pmmi)
{
    if ((_ptMinTrack.x != 0) || (_ptMinTrack.y != 0))
    {
        pmmi->ptMinTrackSize = _ptMinTrack;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnSize
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnSize(
    int width,
    int height)
{
    RECT rcMaster;
    RECT rcView;
    RECT rc;
    HWND hwnd;
    HDWP hdwp;
    int dx;
    int dy;

    //
    //  Set the sizing grip to the correct location.
    //
    SetWindowPos(_hwndGrip,
                  NULL,
                  width - g_cxGrip,
                  height - g_cyGrip,
                  g_cxGrip,
                  g_cyGrip,
                  SWP_NOZORDER | SWP_NOACTIVATE);

    //
    //  Ignore sizing until we are initialized.
    //
    if ((_ptLastSize.x == 0) && (_ptLastSize.y == 0))
    {
        return;
    }

    GetWindowRect(_hwndDlg, &rcMaster);

    //
    //  Calculate the deltas in the x and y positions that we need to move
    //  each of the child controls.
    //
    dx = (rcMaster.right - rcMaster.left) - _ptLastSize.x;
    dy = (rcMaster.bottom - rcMaster.top) - _ptLastSize.y;


    //Dont do anything if the size remains the same
    if ((dx == 0) && (dy == 0))
    {
        return;
    }

    //
    //  Update the new size.
    //
    _ptLastSize.x = rcMaster.right - rcMaster.left;
    _ptLastSize.y = rcMaster.bottom - rcMaster.top;

    //
    //  Size the view.
    //
    GetWindowRect(_hwndView, &rcView);
    MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcView);

    hdwp = BeginDeferWindowPos(10);
    if (hdwp)
    {
        hdwp = DeferWindowPos(hdwp,
                               _hwndGrip,
                               NULL,
                               width - g_cxGrip,
                               height - g_cyGrip,
                               g_cxGrip,
                               g_cyGrip,
                               SWP_NOZORDER | SWP_NOACTIVATE);

        if (hdwp)
        {
            hdwp = DeferWindowPos(hdwp,
                                   _hwndView,
                                   NULL,
                                   0,
                                   0,
                                   rcView.right - rcView.left + dx,  // resize x
                                   rcView.bottom - rcView.top + dy,  // resize y
                                   SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
#if 0
        //
        //  Can't do this because some sub-dialogs are dependent on the
        //  original size of this control.  Instead we just try to rely on
        //  the size of the _hwndView above.
        //
        hwnd = GetDlgItem(_hwndDlg, lst1);
        if (hdwp)
        {
            hdwp = DeferWindowPos(hdwp,
                                   hwnd,
                                   NULL,
                                   0,
                                   0,
                                   rcView.right - rcView.left + dx,  // resize x
                                   rcView.bottom - rcView.top + dy,  // resize y
                                   SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
#endif
    }

    //
    //  Move the controls.
    //
    hwnd = ::GetWindow(_hwndDlg, GW_CHILD);
    while (hwnd && hdwp)
    {
        if ((hwnd != _hSubDlg) && (hwnd != _hwndGrip) && (hdwp))
        {
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, _hwndDlg, &rc);

            //
            //  See if the control needs to be adjusted.
            //
            if (rc.top > rcView.bottom)
            {
                switch (GetDlgCtrlID(hwnd))
                {
                    case (edt1) :
                    case (cmb13) :
                    case (cmb1) :
                    {
                        //Increase the width of these controls
                        hdwp = DeferWindowPos(hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left,
                                               rc.top + dy,
                                               RECTWIDTH(rc) + dx,
                                               RECTHEIGHT(rc),
                                               SWP_NOZORDER);
                        break;

                    }

                    case (IDOK):
                    case (IDCANCEL):
                    case (pshHelp):
                    {
                        //Move these controls to  the right
                        hdwp = DeferWindowPos(hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left + dx,
                                               rc.top  + dy,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE);
                        break;

                    }

                    default :
                    {
                        //
                        //  The control is below the view, so adjust the y
                        //  coordinate appropriately.
                        //
                        hdwp = DeferWindowPos(hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left,
                                               rc.top + dy,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE);

                    }
                }
            }
            else if (rc.left > rcView.right)
            {
                //
                //  The control is to the right of the view, so adjust the
                //  x coordinate appropriately.
                //
                hdwp = DeferWindowPos(hdwp,
                                       hwnd,
                                       NULL,
                                       rc.left + dx,
                                       rc.top,
                                       0,
                                       0,
                                       SWP_NOZORDER | SWP_NOSIZE);
            }
            else
            {
                int id = GetDlgCtrlID(hwnd);

                switch (id)
                {
                    case (cmb2) :
                    {
                        //
                        //  Size this one larger.
                        //
                        hdwp = DeferWindowPos(hdwp,
                                               hwnd,
                                               NULL,
                                               0,
                                               0,
                                               RECTWIDTH(rc) + dx,
                                               RECTHEIGHT(rc),
                                               SWP_NOZORDER | SWP_NOMOVE);
                        break;
                    }

                    case ( IDOK) :
                        if ((SHGetAppCompatFlags(ACF_FILEOPENBOGUSCTRLID) & ACF_FILEOPENBOGUSCTRLID) == 0)
                            break;
                        // else continue through - toolbar bar has ctrlid == IDOK, so we will resize that.
                    case ( stc1 ) :
                        //
                        //  Move the toolbar right by dx.
                        //
                        hdwp = DeferWindowPos(hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left + dx,
                                               rc.top,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE);
                        break;



                    case ( ctl1 ) :
                    {
                        // Size the places bar vertically
                        hdwp = DeferWindowPos(hdwp,
                                              hwnd,
                                              NULL,
                                              0,
                                              0,
                                              RECTWIDTH(rc),
                                              RECTHEIGHT(rc) + dy,
                                              SWP_NOZORDER | SWP_NOMOVE);
                        break;
                    }
                }
            }
        }
        hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
    }

    if (!hdwp)
    {
        return;
    }
    EndDeferWindowPos(hdwp);

    if (_hSubDlg)
    {
        hdwp = NULL;

        hwnd = ::GetWindow(_hSubDlg, GW_CHILD);

        while (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, _hSubDlg, &rc);

            //
            //  See if the control needs to be adjusted.
            //
            if (rc.top > rcView.bottom)
            {
                //
                //  The control is below the view, so adjust the y
                //  coordinate appropriately.
                //

                if (hdwp == NULL)
                {
                    hdwp = BeginDeferWindowPos(10);
                }
                if (hdwp)
                {
                    hdwp = DeferWindowPos(hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left,
                                           rc.top + dy,
                                           0,
                                           0,
                                           SWP_NOZORDER | SWP_NOSIZE);
                }
            }
            else if (rc.left > rcView.right)
            {
                //
                //  The control is to the right of the view, so adjust the
                //  x coordinate appropriately.
                //

                if (hdwp == NULL)
                {
                    hdwp = BeginDeferWindowPos(10);
                }
                if (hdwp)
                {
                    hdwp = DeferWindowPos(hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left + dx,
                                           rc.top,
                                           0,
                                           0,
                                           SWP_NOZORDER | SWP_NOSIZE);
                }
            }
            hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
        }
        if (hdwp)
        {
            EndDeferWindowPos(hdwp);

            //
            //  Size the sub dialog.
            //
            SetWindowPos(_hSubDlg,
                          NULL,
                          0,
                          0,
                          _ptLastSize.x,         // make it the same
                          _ptLastSize.y,         // make it the same
                          SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::VerifyListViewPosition
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::VerifyListViewPosition()
{
    RECT rcList, rcView;
    FOLDERSETTINGS fs;

    //
    //  Get the rectangle for both the list view and the hidden list box.
    //
    GetControlRect(_hwndDlg, lst1, &rcList);
    rcView.left = 0;
    if ((!GetWindowRect(_hwndView, &rcView)) ||
        (!MapWindowRect(HWND_DESKTOP, _hwndDlg, &rcView)))
    {
        return;
    }

    //
    //  See if the list view is off the screen and the list box is not.
    //
    if ((rcView.left < 0) && (rcList.left >= 0))
    {
        //
        //  Reset the list view to the list box position.
        //
        if (_pCurrentLocation)
        {
            if (_psv)
            {
                _psv->GetCurrentInfo(&fs);
            }
            else
            {
                fs.ViewMode = FVM_LIST;
                fs.fFlags = _pOFN->Flags & OFN_ALLOWMULTISELECT ? 0 : FWF_SINGLESEL;
            }

            SwitchView(_pCurrentLocation->GetShellFolder(),
                        _pCurrentLocation->pidlFull,
                        &fs,
                        NULL,
                        FALSE);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateNavigation
//      This function updates the navigation stack by adding the current
//       pidl to the stack
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::UpdateNavigation()
{
    WPARAM iItem;
    HWND hwndCombo  = GetDlgItem(_hwndDlg, cmb2);
    iItem = SendMessage(hwndCombo, CB_GETCURSEL, NULL, NULL);
    MYLISTBOXITEM *pNewLocation = GetListboxItem(hwndCombo, iItem);

    if (_ptlog && pNewLocation && pNewLocation->pidlFull)
    {
        LPITEMIDLIST pidl;
        _ptlog->GetCurrent(&pidl);

        if (pidl && (!ILIsEqual(pNewLocation->pidlFull, pidl)))
        {
            _ptlog->AddEntry(pNewLocation->pidlFull);
        }

        if (pidl)
        {
            ILFree(pidl);
        }
    }

    //Update the UI
    UpdateUI(_pCurrentLocation ? _pCurrentLocation->pidlFull : NULL);

}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateUI
//
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::UpdateUI(LPITEMIDLIST pidlNew)
{
    TBBUTTONINFO tbbi;
    LPITEMIDLIST pidl;

    ::SendMessage(_hwndToolbar, TB_ENABLEBUTTON, IDC_BACK,    _ptlog ? _ptlog->CanTravel(TRAVEL_BACK)    : 0);

    if (_iCheckedButton >= 0)
    {
        //Reset the Hot Button
        ::SendMessage(_hwndPlacesbar, TB_CHECKBUTTON, (WPARAM)_iCheckedButton, MAKELONG(FALSE,0));
        _iCheckedButton = -1;
    }

   if (pidlNew)
   {

        //Get Each Toolbar Buttons pidl and see if the current pidl  matches 
        for (int i=0; i < MAXPLACESBARITEMS; i++)
        {

            tbbi.cbSize = SIZEOF(tbbi);
            tbbi.lParam = 0;
            tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX | TBIF_COMMAND;
            if (SendMessage(_hwndPlacesbar, TB_GETBUTTONINFO, i, (LPARAM)&tbbi) >= 0)
            {
                pidl = (LPITEMIDLIST)tbbi.lParam;

                if (pidl && ILIsEqual(pidlNew, pidl))
                {
                    _iCheckedButton = tbbi.idCommand;
                    break;
                }
            }
        }

        if (_iCheckedButton >= 0)
        {
            ::SendMessage(_hwndPlacesbar, TB_CHECKBUTTON, (WPARAM)_iCheckedButton, MAKELONG(TRUE,0));
        }

   }

}

////////////////////////////////////////////////////////////////////////////
//
//  OpenDlgProc
//
//  Main dialog procedure for file open dialogs.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK OpenDlgProc(
    HWND hDlg,               // window handle of the dialog box
    UINT message,            // type of message
    WPARAM wParam,           // message-specific information
    LPARAM lParam)
{
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hDlg);

    // we divide the message processing into two switch statments:
    // those who don't use pDlgStruct first and then those who do.

    switch (message)
    {
        case WM_INITDIALOG:
        {
            //
            //  Initialize dialog box.
            //
            LPOFNINITINFO poii = (LPOFNINITINFO)lParam;

            if (CDGetAppCompatFlags()  & CDACF_MATHCAD)
            {
                if (FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)))
                    ::EndDialog(hDlg, FALSE);
            }

            poii->hrOleInit = SHOleInitialize(0);
            
            
            if (!InitLocation(hDlg, poii))
            {
                ::EndDialog(hDlg, FALSE);
            }
            
            if (!gp_uQueryCancelAutoPlay)
            {
                // try to register for autoplay messages
                gp_uQueryCancelAutoPlay =  RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
            }

            //
            //  Always return FALSE to indicate we have already set the focus.
            //
            return FALSE;
        }
        break;

        case WM_DESTROY:
        {
            RECT r;            
            //Cache in this dialogs size and position so that new
            //dialog are created at this location and size

            GetWindowRect(hDlg, &r);

            if (pDlgStruct && (pDlgStruct->_bEnableSizing))
            {
                g_rcDlg = r;
            }

            //
            //  Make sure we do not respond to any more messages.
            //
            StoreBrowser(hDlg, NULL);
            ClearListbox(GetDlgItem(hDlg, cmb2));

            if (pDlgStruct)
            {
                pDlgStruct->Release();
            }

            return FALSE;
        }
        break;

        case WM_ACTIVATE:
        {
            if (wParam == WA_INACTIVE)
            {
                //
                //  Make sure some other Open dialog has not already grabbed
                //  the focus.  This is a process global, so it should not
                //  need to be protected.
                //
                if (gp_hwndActiveOpen == hDlg)
                {
                    gp_hwndActiveOpen = NULL;
                }
            }
            else
            {
                gp_hwndActiveOpen = hDlg;
            }

            return FALSE;
        }
        break;

        case WM_MEASUREITEM:
        {
            if (!g_cxSmIcon && !g_cySmIcon)
            {
                HIMAGELIST himl;
                Shell_GetImageLists(NULL, &himl);
                ImageList_GetIconSize(himl, &g_cxSmIcon, &g_cySmIcon);
            }

            MeasureDriveItems(hDlg, (MEASUREITEMSTRUCT*)lParam);
            return TRUE;
        }
        break;

        case CWM_GETISHELLBROWSER:
        {
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LRESULT)pDlgStruct);
            return TRUE;
        }
        break;

        case WM_DEVICECHANGE:
        {
            if (DBT_DEVICEARRIVAL == wParam)
            {
                // and refresh our view in case this was a notification for the folder
                // we are viewing. avoids making the user do a manual refresh
                DEV_BROADCAST_VOLUME *pbv = (DEV_BROADCAST_VOLUME *)lParam;
                if (pbv->dbcv_flags & DBTF_MEDIA)
                {
                    int chRoot;
                    TCHAR szPath[MAX_PATH];
                    if (pDlgStruct->GetDirectoryFromLB(szPath, &chRoot))
                    {
                        int iDrive = PathGetDriveNumber(szPath);

                        if (iDrive != -1 && ((1 << iDrive) & pbv->dbcv_unitmask))
                        {
                            // refresh incase this was this folder
                            PostMessage(hDlg, WM_COMMAND, IDC_REFRESH, 0);
                        }
                    }
                }
            }
            return TRUE;
        }
        break;

        default:
        if (message == gp_uQueryCancelAutoPlay)
        {
            // cancel the autoplay
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
            return TRUE;
        }
        break;
    }

    // NOTE:
    // all of the messages below require that we have a valid pDlgStruct. if you
    // don't refrence pDlgStruct, then add your msg to the switch statement above.
    if (pDlgStruct)
    {
        switch (message)
        {
            case WM_COMMAND:
            {
                return ((BOOL_PTR)pDlgStruct->OnCommandMessage(wParam, lParam));
            }
            break;

            case WM_DRAWITEM:
            {
                pDlgStruct->PaintDriveLine((DRAWITEMSTRUCT *)lParam);

                //
                //  Make sure the list view is in the same place as the
                //  list box.  Apps like VB move the list box off of the
                //  dialog.  If the list view is placed on the list box
                //  before the list box gets moved back to the dialog, we
                //  end up with an ugly gray spot.
                //
                pDlgStruct->VerifyListViewPosition();
                return TRUE;
            }
            break;

            case WM_NOTIFY:
            {
                
                return (BOOL_PTR)pDlgStruct->OnNotify((LPNMHDR)lParam);
            }
            break;

            case WM_SETCURSOR:
            {
                if (pDlgStruct->OnSetCursor())
                {
                    SetDlgMsgResult(hDlg, message, (LRESULT)TRUE);
                    return TRUE;
                }
            }
            break;

            case WM_HELP:
            {
                HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
                if (hwndItem != pDlgStruct->_hwndToolbar)
                {
                    HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;

                    //  We assume that the defview has one child window that
                    //  covers the entire defview window.
                    HWND hwndDefView = GetDlgItem(hDlg, lst2);
                    if (GetParent(hwndItem) == hwndDefView)
                    {
                        hwndItem = hwndDefView;
                    }

                    WinHelp(hwndItem,
                            NULL,
                            HELP_WM_HELP,
                            (ULONG_PTR)(LPTSTR)(pDlgStruct->_bSave ? aFileSaveHelpIDs : aFileOpenHelpIDs));
                }
                return TRUE;
            }
            break;

            case WM_CONTEXTMENU:
            {
                if ((HWND)wParam != pDlgStruct->_hwndToolbar)
                {
                    WinHelp((HWND)wParam,
                            NULL,
                            HELP_CONTEXTMENU,
                            (ULONG_PTR)(void *)(pDlgStruct->_bSave ? aFileSaveHelpIDs : aFileOpenHelpIDs));
                }
                return TRUE;
            }
            break;

            case CDM_SETSAVEBUTTON:
            {
                pDlgStruct->RealSetSaveButton((UINT)wParam);
            }
            break;

            case CDM_FSNOTIFY:
            {
                LPITEMIDLIST *ppidl;
                LONG lEvent;
                BOOL bRet;
                LPSHChangeNotificationLock pLock;

                //  Get the change notification info from the shared memory
                //  block identified by the handle passed in the wParam.
                pLock = SHChangeNotification_Lock((HANDLE)wParam,
                                                  (DWORD)lParam,
                                                  &ppidl,
                                                  &lEvent);
                if (pLock == NULL)
                {
                    pDlgStruct->_bDropped = FALSE;
                    return FALSE;
                }

                bRet = pDlgStruct->FSChange(lEvent, (LPCITEMIDLIST *)ppidl);

                //  Release the shared block.
                SHChangeNotification_Unlock(pLock);

                return bRet;
            }
            break;

            case CDM_SELCHANGE:
            {
                pDlgStruct->_fSelChangedPending = FALSE;
                pDlgStruct->SelFocusChange(TRUE);
                if (pDlgStruct->_hSubDlg)
                {
                    CD_SendSelChangeNotify(pDlgStruct->_hSubDlg,
                                            hDlg,
                                            pDlgStruct->_pOFN,
                                            pDlgStruct->_pOFI);
                }
            }
            break;
            
            case WM_TIMER:
            {
                pDlgStruct->Timer(wParam);
            }
            break;

            case WM_GETMINMAXINFO:
            {
                if (pDlgStruct->_bEnableSizing)
                {
                    pDlgStruct->OnGetMinMax((LPMINMAXINFO)lParam);
                    return FALSE;
                }
            }
            break;

            case WM_SIZE:
            {
                if (pDlgStruct->_bEnableSizing)
                {
                    pDlgStruct->OnSize(LOWORD(lParam), HIWORD(lParam));
                    return TRUE;
                }
            }
            break;

            case WM_NCCALCSIZE:
            {
                // AppHack for Borland JBuilder:  Need to keep track of whether
                // any redraw requests have come in.
                pDlgStruct->_bAppRedrawn = TRUE;
            }
            break;

            case WM_THEMECHANGED:
            {
                // Need to change some parameters on the placesbar for this.
                pDlgStruct->OnThemeActive(hDlg, IsAppThemed());
                return TRUE;
            }
            break;

            case WM_SETTINGCHANGE:
            {
                // If icon size has changed, we need to regenerate the places bar.
                pDlgStruct->_RecreatePlacesbar();
                return FALSE;
            }
            break;
            default:
            {
                if (IsInRange(message, CDM_FIRST, CDM_LAST) && pDlgStruct)
                {
                    return pDlgStruct->OnCDMessage(message, wParam, lParam);
                }
            }
        }
    }

    //  Did not process the message.
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenFileHookProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OpenFileHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    MSG *lpMsg;

    if (nCode < 0)
    {
        return (DefHookProc(nCode, wParam, lParam, &gp_hHook));
    }

    if (nCode != MSGF_DIALOGBOX)
    {
        return (0);
    }

    lpMsg = (MSG *)lParam;

    //
    //  Check if this message is for the last active OpenDialog in this
    //  process.
    //
    //  Note: This is only done for WM_KEY* messages so that we do not slow
    //        down this window too much.
    //
    if (IsInRange(lpMsg->message, WM_KEYFIRST, WM_KEYLAST))
    {
        HWND hwndActiveOpen = gp_hwndActiveOpen;
        HWND hwndFocus = GetFocusedChild(hwndActiveOpen, lpMsg->hwnd);
        CFileOpenBrowser *pDlgStruct;

        if (hwndFocus &&
            (pDlgStruct = HwndToBrowser(hwndActiveOpen)) != NULL)
        {
            if (pDlgStruct->_psv && (hwndFocus == pDlgStruct->_hwndView))
            {
                if (pDlgStruct->_psv->TranslateAccelerator(lpMsg) == S_OK)
                {
                    return (1);
                }

                if (gp_haccOpenView &&
                    TranslateAccelerator(hwndActiveOpen, gp_haccOpenView, lpMsg))
                {
                    return (1);
                }
            }
            else
            {
                if (gp_haccOpen &&
                    TranslateAccelerator(hwndActiveOpen, gp_haccOpen, lpMsg))
                {
                    return (1);
                }

                //
                //  Note that the view won't be allowed to translate when the
                //  focus is not there.
                //
            }
        }
    }

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NewGetFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetFileName(
    LPOPENFILEINFO lpOFI,
    BOOL bSave)
{
    OFNINITINFO oii = { lpOFI, bSave, FALSE, -1};
    LPOPENFILENAME lpOFN = lpOFI->pOFN;
    BOOL bHooked = FALSE;
    WORD wErrorMode;
    HRSRC hResInfo;
    HGLOBAL hDlgTemplate;
    LPDLGTEMPLATE pDlgTemplate;
    int nRet;
    LANGID LangID;

    //Initialize the common controls
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_USEREX_CLASSES;  //ComboBoxEx class
    InitCommonControlsEx(&icc);
    if ((lpOFN->lStructSize != sizeof(OPENFILENAME)) &&
        (lpOFN->lStructSize != OPENFILENAME_SIZE_VERSION_400)
      )
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return FALSE;
    }

    //
    //  OFN_ENABLEINCLUDENOTIFY requires OFN_EXPLORER and OFN_ENABLEHOOK.
    //
    if (lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        if ((!(lpOFN->Flags & OFN_EXPLORER)) ||
            (!(lpOFN->Flags & OFN_ENABLEHOOK)))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            return FALSE;
        }
    }

    wErrorMode = (WORD)SetErrorMode(SEM_NOERROR);
    SetErrorMode(SEM_NOERROR | wErrorMode);

    //
    //  There ought to be a better way.  I am compelled to keep the hHook in a
    //  global because my callback needs it, but I have no lData where I could
    //  possibly store it.
    //  Note that we initialize nHookRef to -1 so we know when the first
    //  increment is.
    //
    if (InterlockedIncrement((LPLONG)&gp_nHookRef) == 0)
    {
        gp_hHook = SetWindowsHookEx(WH_MSGFILTER,
                                     OpenFileHookProc,
                                     0,
                                     GetCurrentThreadId());
        if (gp_hHook)
        {
            bHooked = TRUE;
        }
        else
        {
            --gp_nHookRef;
        }
    }
    else
    {
        bHooked = TRUE;
    }

    if (!gp_haccOpen)
    {
        gp_haccOpen = LoadAccelerators(g_hinst,
                                        MAKEINTRESOURCE(IDA_OPENFILE));
    }
    if (!gp_haccOpenView)
    {
        gp_haccOpenView = LoadAccelerators(g_hinst,
                                            MAKEINTRESOURCE(IDA_OPENFILEVIEW));
    }

    g_cxGrip = GetSystemMetrics(SM_CXVSCROLL);
    g_cyGrip = GetSystemMetrics(SM_CYHSCROLL);

    //
    //  Get the dialog resource and load it.
    //
    nRet = FALSE;
    WORD wResID;

    // if the version of the structure passed is older than the current version and the application 
    // has specified hook or template or template handle then use template corresponding to that version
    // else use the new file open template
    if (((lpOFI->iVersion < OPENFILEVERSION) &&
          (lpOFI->pOFN->Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE))) ||
         (IsRestricted(REST_NOPLACESBAR)) || (IS_NEW_OFN(lpOFI->pOFN) && (lpOFI->pOFN->FlagsEx & OFN_EX_NOPLACESBAR))
         
      )
    {
        wResID = NEWFILEOPENORD;
    }
    else
    {
        wResID = NEWFILEOPENV2ORD;
    }

    LangID = GetDialogLanguage(lpOFN->hwndOwner, NULL);
    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (void *) LangID);
    
    if ((hResInfo = FindResourceExFallback(::g_hinst,
                                  RT_DIALOG,
                                  MAKEINTRESOURCE(wResID),
                                  LangID)) &&
        (hDlgTemplate = LoadResource(::g_hinst, hResInfo)) &&
        (pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate)))
    {
        ULONG cbTemplate = SizeofResource(::g_hinst, hResInfo);
        LPDLGTEMPLATE pDTCopy = (LPDLGTEMPLATE)LocalAlloc(LPTR, cbTemplate);

        if (pDTCopy)
        {
            CopyMemory(pDTCopy, pDlgTemplate, cbTemplate);
            UnlockResource(hDlgTemplate);
            FreeResource(hDlgTemplate);

            if ((lpOFN->Flags & OFN_ENABLESIZING) ||
                 (!(lpOFN->Flags & (OFN_ENABLEHOOK |
                                    OFN_ENABLETEMPLATE |

                                    OFN_ENABLETEMPLATEHANDLE))))
            {
                                if (((LPDLGTEMPLATE2)pDTCopy)->wSignature == 0xFFFF)
                                {
                                        //This is a dialogex template
                                        ((LPDLGTEMPLATE2)pDTCopy)->style |= WS_SIZEBOX;
                                }
                                else
                                {
                                        //This is a dialog template
                                        ((LPDLGTEMPLATE)pDTCopy)->style |= WS_SIZEBOX;
                                }
                oii.bEnableSizing = TRUE;
            }

            
            oii.hrOleInit = E_FAIL;

            nRet = (BOOL)DialogBoxIndirectParam(::g_hinst,
                                           pDTCopy,
                                           lpOFN->hwndOwner,
                                           OpenDlgProc,
                                           (LPARAM)(LPOFNINITINFO)&oii);

            //Unintialize OLE
            SHOleUninitialize(oii.hrOleInit);

            if (CDGetAppCompatFlags()  & CDACF_MATHCAD)
            {
                CoUninitialize();
            }

            LocalFree(pDTCopy);
        }
    }

    if (bHooked)
    {
        //
        //  Put this in a local so we don't need a critical section.
        //
        HHOOK hHook = gp_hHook;

        if (InterlockedDecrement((LPLONG)&gp_nHookRef) < 0)
        {
            UnhookWindowsHookEx(hHook);
        }
    }

    switch (nRet)
    {
        case (TRUE) :
        {
            break;
        }
        case (FALSE) :
        {
            if ((!g_bUserPressedCancel) && (!GetStoredExtendedError()))
            {
                StoreExtendedError(CDERR_DIALOGFAILURE);
            }
            break;
        }
        default :
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
            nRet = FALSE;
            break;
        }
    }

    //
    //  
    //  There is a race condition here where we free dlls but a thread
    //  using this stuff still hasn't terminated so we page fault.
    //  FreeImports();

    SetErrorMode(wErrorMode);

    return (nRet);
}


extern "C" {

////////////////////////////////////////////////////////////////////////////
//
//  NewGetOpenFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetOpenFileName(
    LPOPENFILEINFO lpOFI)
{
    return (NewGetFileName(lpOFI, FALSE));
}


////////////////////////////////////////////////////////////////////////////
//
//  NewGetSaveFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetSaveFileName(
    LPOPENFILEINFO lpOFI)
{
    return (NewGetFileName(lpOFI, TRUE));
}

}   // extern "C"


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_ValidateSelectedFile
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_ValidateSelectedFile(LPCTSTR pszFile, int *pErrCode)
{
    //
    //  Successfully opened.
    //

    // Note: (pfortier) If/when IShellItem is removed from this version of comdlg, the
    // following if statement should probably revert to
    // if ((_pOFN->Flags & OFN_NOREADONLYRETURN) &&
    // and the next one to 
    // if (_bSave || (_pOFN->Flags & OFN_NOREADONLYRETURN))
    // 
    // These were changed in order to be consistent with w2k behaviour regarding
    // message box errors that appear when OFN_NOREADONLYRETURN is specified and
    // the user selects a readonly file - the point of contention is that errors were
    // not shown in win2k when it was an OpenFile dialog. IShellItem changes modified
    // the codepath such that errors were now produced when in an OpenFile dialog.
    // To compensate, the logic has been changed here.
    DWORD dwAttrib = GetFileAttributes(pszFile);
    if ((_pOFN->Flags & OFN_NOREADONLYRETURN) && _bSave &&
        (0xFFFFFFFF != dwAttrib) && (dwAttrib & FILE_ATTRIBUTE_READONLY))
    {
        *pErrCode = OF_LAZYREADONLY;
        return FALSE;
    }
    
    if (_bSave)
    {
        *pErrCode = WriteProtectedDirCheck((LPTSTR)pszFile);
        if (*pErrCode)
        {
            return FALSE;
        }
    }

    if (_pOFN->Flags & OFN_OVERWRITEPROMPT)
    {
        if (_bSave && PathFileExists(pszFile) && !FOkToWriteOver(_hwndDlg, (LPTSTR)pszFile))
        {
            if (_bUseCombo)
            {
                PostMessage(_hwndDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(_hwndDlg, cmb13), 1);
            }
            else
            {
                PostMessage(_hwndDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(_hwndDlg, edt1), 1);
            }
            return FALSE;
        }
    }
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_ProcessPidlSelection
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_ProcessPidlSelection()
{
    IShellItem *psi;
    if (SUCCEEDED(SHCreateShellItem(_pCurrentLocation->pidlFull, _psfCurrent, _pidlSelection, &psi)))
    {
        IShellItem *psiReal;
        HRESULT hr = _TestShellItem(psi, TRUE, &psiReal);
        if (S_OK == hr)
        {
            hr = _ProcessItemAsFile(psiReal);
            psiReal->Release();
        }
        psi->Release();

        //  if there was any kind of error then we fall back
        //  to the old code to show errors and the like
        return SUCCEEDED(hr);
    }


    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_ProcessItemAsFile
//
////////////////////////////////////////////////////////////////////////////
HRESULT CFileOpenBrowser::_ProcessItemAsFile(IShellItem *psi)
{
    LPTSTR pszPath;
    HRESULT hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &pszPath);

    if (FAILED(hr))
    {
        hr = _MakeFakeCopy(psi, &pszPath);
    }

    if (SUCCEEDED(hr))
    {
        int nErrCode;
        hr = E_FAIL;

        if (_ValidateSelectedFile(pszPath, &nErrCode))
        {
            DWORD dwError = 0;
            int nFileOffset = _CopyFileNameToOFN(pszPath, &dwError);
            _CopyTitleToOFN(pszPath+nFileOffset);
            _PostProcess(pszPath);
            if (dwError)
                StoreExtendedError(dwError);

            _CleanupDialog((dwError == NOERROR));
            hr = S_OK;
        }
        else
        {
            //Check to see if there is an error in the file or user pressed no for overwrite prompt
            // if user pressed no to overwritte prompt then return true
            if (nErrCode == 0)
                hr = S_FALSE; // Otherwise, return failure.
        }
        
        CoTaskMemFree(pszPath);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_ProcessPidlAsShellItem
//
////////////////////////////////////////////////////////////////////////////
#ifdef RETURN_SHELLITEMS
HRESULT CFileOpenBrowser::_ProcessShellItem(IShellItem *psi)
{
    CShellItemList *psil = new CShellItemList();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(IS_NEW_OFN(_pOFN));

    if (psil)
    {
        hr = psil->Add(psi);
        //  we have added everything to our list
        if (SUCCEEDED(hr))
        {
            hr = psil->QueryInterface(IID_PPV_ARG(IEnumShellItems, &(_pOFN->penum)));
        }

        psil->Release();
    }

  return hr;
}
#endif RETURN_SHELLITEMS

///////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::_PostProcess
//
//      This functions does all the bookkeeping  operations that needs to be
//  done when  File Open/Save Dialog closes.
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::_PostProcess(LPTSTR pszFile)
{
    int nFileOffset = ParseFileNew(pszFile, NULL, FALSE, TRUE);

    //Set the last visited directory for this application. 
    //We should this all the time regardless of how we opened b'cos app may specify an initial
    //directory(many apps do this in Save As case) but the user might decide to save it in a differnt directory 
    //in this case we need to save the directory where user saved.
    
    AddToLastVisitedMRU(pszFile, nFileOffset);

    //Add to recent documents.
    if (!(_pOFN->Flags & OFN_DONTADDTORECENT))
    {
        SHAddToRecentDocs(SHARD_PATH, pszFile);

        //Add to the file mru 
        AddToMRU(_pOFN);
    }

    // Check to see if we need to set Read only bit or not   
    if (!(_pOFN->Flags & OFN_HIDEREADONLY))
    {
        //
        //  Read-only checkbox visible?
        //
        if (IsDlgButtonChecked(_hwndDlg, chx1))
        {
            _pOFN->Flags |=  OFN_READONLY;
        }
        else
        {
            _pOFN->Flags &= ~OFN_READONLY;
        }
    }


    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\dlgs.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    dlgs.c

Abstract:

    This module contains the common functions for the Win32 common dialogs.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "util.h"
//
//  Global Variables.
//

extern BOOL bInitializing;
extern DWORD g_tlsiExtError;

//
//  Function Prototypes.
//

LONG
RgbInvertRgb(
    LONG rgbOld);

const struct _ERRORMAP
{
    DWORD dwCommDlgError;
    DWORD dwWin32Error;
} ERRORMAP[] =
{
    { CDERR_INITIALIZATION  , ERROR_INVALID_PARAMETER},  
    { PDERR_INITFAILURE     , ERROR_INVALID_PARAMETER},
    { CDERR_STRUCTSIZE      , ERROR_INVALID_PARAMETER},      
    { CDERR_NOTEMPLATE      , ERROR_INVALID_PARAMETER},      
    { CDERR_NOHINSTANCE     , ERROR_INVALID_PARAMETER},
    { CDERR_NOHOOK          , ERROR_INVALID_PARAMETER},
    { CDERR_MEMALLOCFAILURE , ERROR_OUTOFMEMORY},
    { CDERR_LOCKRESFAILURE  , ERROR_INVALID_HANDLE},
    { CDERR_DIALOGFAILURE   , E_FAIL},
    { PDERR_SETUPFAILURE    , ERROR_INVALID_PARAMETER},
    { PDERR_RETDEFFAILURE   , ERROR_INVALID_PARAMETER},
    { FNERR_BUFFERTOOSMALL  , ERROR_INSUFFICIENT_BUFFER},
    { FRERR_BUFFERLENGTHZERO, ERROR_INSUFFICIENT_BUFFER},
    { FNERR_INVALIDFILENAME , ERROR_INVALID_NAME},
    { PDERR_NODEFAULTPRN    , E_FAIL},
    { CFERR_NOFONTS         , E_FAIL},
    { CFERR_MAXLESSTHANMIN  , ERROR_INVALID_PARAMETER},
};

////////////////////////////////////////////////////////////////////////////
//
//  StoreExtendedError
//
//  Stores an extended error code for the next call to
//  CommDlgExtendedError.
//
////////////////////////////////////////////////////////////////////////////

void StoreExtendedError(
    DWORD dwError)
{ 
    int i;
    for (i=0; i < ARRAYSIZE(ERRORMAP); i++)
    {
        if (ERRORMAP[i].dwCommDlgError == dwError)
        {
            SetLastError(ERRORMAP[i].dwWin32Error);
            break;
        }
    }
    TlsSetValue(g_tlsiExtError, UlongToPtr(dwError));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStoredExtendedError
//
//  Retieves the stored extended error code.
//
////////////////////////////////////////////////////////////////////////////

DWORD GetStoredExtendedError(void)
{
    DWORD dwError;

    dwError = PtrToUlong(TlsGetValue(g_tlsiExtError));

    return (dwError);
}


////////////////////////////////////////////////////////////////////////////
//
//  CommDlgExtendedError
//
//  Provides additional information about dialog failure.
//  This should be called immediately after failure.
//
//  Returns:   LO word - error code
//             HI word - error specific info
//
////////////////////////////////////////////////////////////////////////////

DWORD WINAPI CommDlgExtendedError()
{
    return (GetStoredExtendedError());
}





////////////////////////////////////////////////////////////////////////////
//
//  HourGlass
//
//  Turn hourglass on or off.
//
//  bOn - specifies ON or OFF
//
////////////////////////////////////////////////////////////////////////////

VOID HourGlass(
    BOOL bOn)
{
    //
    //  Change cursor to hourglass.
    //
    if (!bInitializing)
    {
        if (!bMouse)
        {
            ShowCursor(bCursorLock = bOn);
        }
        SetCursor(LoadCursor(NULL, bOn ? IDC_WAIT : IDC_ARROW));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadAlterBitmap
//
//  Loads a bitmap given its name and gives all the pixels that are
//  a certain color a new color.
//
//  Returns:   NULL - failed
//             handle to the bitmap loaded - success
//
////////////////////////////////////////////////////////////////////////////

HBITMAP WINAPI LoadAlterBitmap(
    int id,
    DWORD rgbReplace,
    DWORD rgbInstead)
{
    LPBITMAPINFOHEADER qbihInfo;
    HDC hdcScreen;
    BOOL fFound;
    HANDLE hresLoad;
    HANDLE hres;
    LPLONG qlng;
    DWORD *qlngReplace;       // points to bits that are replaced
    LPBYTE qbBits;
    HANDLE hbmp;
    LPBITMAPINFOHEADER lpBitmapInfo;
    UINT cbBitmapSize;

    hresLoad = FindResource(g_hinst, MAKEINTRESOURCE(id), RT_BITMAP);
    if (hresLoad == HNULL)
    {
        return (HNULL);
    }
    hres = LoadResource(g_hinst, hresLoad);
    if (hres == HNULL)
    {
        return (HNULL);
    }

    //
    //  Lock the bitmap data and make a copy of it for the mask and the
    //  bitmap.
    //
    cbBitmapSize = SizeofResource(g_hinst, hresLoad);
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hres);

    qbihInfo = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbBitmapSize);

    if ((lpBitmapInfo == NULL) || (qbihInfo == NULL))
    {
        return (NULL);
    }

    memcpy((TCHAR *)qbihInfo, (TCHAR *)lpBitmapInfo, cbBitmapSize);

    //
    //  Get a pointer into the color table of the bitmaps, cache the
    //  number of bits per pixel.
    //
    rgbReplace = RgbInvertRgb(rgbReplace);
    rgbInstead = RgbInvertRgb(rgbInstead);

    qlng = (LPLONG)((LPSTR)(qbihInfo) + qbihInfo->biSize);

    fFound = FALSE;
    while (!fFound)
    {
        if (*qlng == (LONG)rgbReplace)
        {
            fFound = TRUE;
            qlngReplace = (DWORD *)qlng;
            *qlng = (LONG)rgbInstead;
        }
        qlng++;
    }

    //
    //  First skip over the header structure.
    //
    qbBits = (LPBYTE)(qbihInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    qbBits += (1 << (qbihInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdcScreen = GetDC(HNULL);
    if (hdcScreen != HNULL)
    {
        hbmp = CreateDIBitmap( hdcScreen,
                               qbihInfo,
                               (LONG)CBM_INIT,
                               qbBits,
                               (LPBITMAPINFO)qbihInfo,
                               DIB_RGB_COLORS );
        ReleaseDC(HNULL, hdcScreen);
    }

    //
    //  Reset color bits to original value.
    //
    *qlngReplace = (LONG)rgbReplace;

    LocalFree(qbihInfo);
    return (hbmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  RgbInvertRgb
//
//  Reverses the byte order of the RGB value (for file format).
//
//  Returns the new color value (RGB to BGR).
//
////////////////////////////////////////////////////////////////////////////

LONG RgbInvertRgb(
    LONG rgbOld)
{
    LONG lRet;
    BYTE R, G, B;

    R = GetRValue(rgbOld);
    G = GetGValue(rgbOld);
    B = GetBValue(rgbOld);

    lRet = (LONG)RGB(B, G, R);

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  HbmpLoadBmp
//
//  Loads in a bitmap.
//
//  Returns:   Bitmap handle - success
//             HNULL         - failure
//
////////////////////////////////////////////////////////////////////////////

#if 0
HBITMAP HbmpLoadBmp(
    WORD bmp)
{
    HBITMAP hbmp;
    CHAR szBitmap[cbResNameMax];

    hbmp = HNULL;
    if (LoadString(g_hinst, bmp, (LPTSTR)szBitmap, cbResNameMax - 1))
    {
        hbmp = LoadBitmap(g_hinst, (LPCTSTR)szBitmap);
    }
    return (hbmp);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  AddNetButton
//
//  Attempts to add a network button to the open, save, or print dialogs.
//
//  hDlg           - dialog to add button to
//  hInstance      - instance handle for dlg
//  dyBottomMargin - DUs to bottom edge
//
////////////////////////////////////////////////////////////////////////////

#define xDUsToPels(DUs, lDlgBaseUnits) \
   (int)(((DUs) * (int)LOWORD((lDlgBaseUnits))) / 4)

#define yDUsToPels(DUs, lDlgBaseUnits) \
   (int)(((DUs) * (int)HIWORD((lDlgBaseUnits))) / 8)

VOID AddNetButton(
    HWND hDlg,
    HANDLE hInstance,
    int dyBottomMargin,
    BOOL bAddAccel,
    BOOL bTryLowerRight,
    BOOL bTryLowerLeft)
{
    LONG lDlgBaseUnits;
    RECT rcDlg, rcCtrl, rcTmp;
    LONG xButton, yButton;
    LONG dxButton, dyButton;
    LONG dxDlgFrame, dyDlgFrame;
    LONG yDlgHeight, xDlgWidth;
    HWND hwndButton, hCtrl, hLastCtrl, hTmp, hSave;
    HFONT hFont;
    POINT ptTopLeft, ptTopRight, ptCenter, ptBtmLeft, ptBtmRight, ptTopLeftTmp;
    TCHAR szNetwork[MAX_PATH];

    //
    //  Make sure a network button (psh14) doesn't already exist in
    //  the dialog.
    //
    if (GetDlgItem(hDlg, psh14))
    {
        return;
    }

    //
    //  Get dialog coordinate info.
    //
    lDlgBaseUnits = GetDialogBaseUnits();

    dxDlgFrame = GetSystemMetrics(SM_CXDLGFRAME);
    dyDlgFrame = GetSystemMetrics(SM_CYDLGFRAME);

    GetWindowRect(hDlg, &rcDlg);

    rcDlg.left += dxDlgFrame;
    rcDlg.right -= dxDlgFrame;
    rcDlg.top += dyDlgFrame + GetSystemMetrics(SM_CYCAPTION);
    rcDlg.bottom -= dyDlgFrame;

    //
    //  Get the OK button.
    //
    if (!(hCtrl = GetDlgItem(hDlg, IDOK)))
    {
        return;
    }

    GetWindowRect(hCtrl, &rcCtrl);

    ptTopLeft.x = rcCtrl.left;
    ptTopLeft.y = rcCtrl.top;

    //
    //  Make sure the OK button isn't outside the dialog.
    //
    if (!PtInRect(&rcDlg, ptTopLeft))
    {
        //
        //  Try the CANCEL button.
        //
        if (!(hCtrl = GetDlgItem(hDlg, IDCANCEL)))
        {
           //
           //  Both OK and CANCEL do not exist, so return.
           //
           return;
        }

        //
        //  The check for the Cancel button outside the dialog is handled
        //  below.
        //
        GetWindowRect(hCtrl, &rcCtrl);
    }
    hSave = hCtrl;

#ifdef UNICODE
    //
    //  Get the full hDlg value if coming from WOW.
    //
    if (IS_INTRESOURCE(hDlg))
    {
        HWND hNewDlg = GetParent(hCtrl);

        if (hDlg == (HWND)LOWORD(hNewDlg))
        {
            hDlg = hNewDlg;
        }
    }
#endif

    //
    //  Save the coordinate info of the button.
    //
    dxButton = rcCtrl.right - rcCtrl.left;
    dyButton = rcCtrl.bottom - rcCtrl.top;

    xButton = rcCtrl.left;
    yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);

    yDlgHeight = rcDlg.bottom - yDUsToPels(dyBottomMargin, lDlgBaseUnits);

    //
    //  Try to insert the network button in the lower right corner
    //  of dialog box.
    //
    if (bTryLowerRight && (hTmp = GetDlgItem(hDlg, cmb2)))
    {
        //
        //  See if the network button can be inserted in the
        //  lower right corner of the dialog box.
        //
        hLastCtrl = hCtrl;
        GetWindowRect(hTmp, &rcTmp);
        yButton = rcTmp.top;

        //
        //  Set the coordinates of the new button.
        //
        ptTopLeft.x = ptBtmLeft.x = xButton;
        ptTopLeft.y = ptTopRight.y = yButton;
        ptTopRight.x = ptBtmRight.x = xButton + dxButton;
        ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
        ptCenter.x = xButton + dxButton / 2;
        ptCenter.y = yButton + dyButton / 2;
        ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
        ScreenToClient(hDlg, (LPPOINT)&ptCenter);

        //
        //  See if the new button is over any other buttons.
        //
        if (((yButton + dyButton) < yDlgHeight) &&
            ((ChildWindowFromPoint(hDlg, ptTopLeft)  == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptTopRight) == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptCenter)   == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptBtmLeft)  == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptBtmRight) == hDlg)))
        {
            //
            //  If the last control is the OK button and there is a
            //  HELP button, then the last control should be the
            //  HELP button.
            //
            if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                (hCtrl = GetDlgItem(hDlg, pshHelp)))
            {
                GetWindowRect(hCtrl, &rcCtrl);
                ptTopLeftTmp.x = rcCtrl.left;
                ptTopLeftTmp.y = rcCtrl.top;

                //
                //  Make sure the HELP button isn't outside the dialog
                //  and then set the last control to be the HELP button.
                //
                if (PtInRect(&rcDlg, ptTopLeftTmp))
                {
                    hLastCtrl = hCtrl;
                }
            }

            //
            //  If the last control is still the OK button and there is a
            //  CANCEL button, then the last control should be the
            //  CANCEL button.
            //
            if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                (hCtrl = GetDlgItem(hDlg, IDCANCEL)))
            {
                GetWindowRect(hCtrl, &rcCtrl);
                ptTopLeftTmp.x = rcCtrl.left;
                ptTopLeftTmp.y = rcCtrl.top;

                //
                //  Make sure the CANCEL button isn't outside the dialog
                //  and then set the last control to be the CANCEL button.
                //
                if (PtInRect(&rcDlg, ptTopLeftTmp))
                {
                    hLastCtrl = hCtrl;
                }
            }

            goto FoundPlace;
        }

        //
        //  Reset yButton.
        //
        yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);
    }

    //
    //  Try to insert the network button vertically below the other
    //  control buttons.
    //
    while (hCtrl != NULL)
    {
        //
        //  Move vertically down and see if there is space.
        //
        hLastCtrl = hCtrl;
        GetWindowRect(hCtrl, &rcCtrl);
        yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);

        //
        //  Make sure there is still room in the dialog.
        //
        if ((yButton + dyButton) > yDlgHeight)
        {
            //
            //  No space.
            //
            break;
        }

        //
        //  Set the coordinates of the new button.
        //
        ptTopLeft.x = ptBtmLeft.x = xButton;
        ptTopLeft.y = ptTopRight.y = yButton;
        ptTopRight.x = ptBtmRight.x = xButton + dxButton;
        ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
        ptCenter.x = xButton + dxButton / 2;
        ptCenter.y = yButton + dyButton / 2;
        ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
        ScreenToClient(hDlg, (LPPOINT)&ptCenter);

        //
        //  See if the new button is over any other buttons.
        //
        if (((hCtrl = ChildWindowFromPoint(hDlg, ptTopLeft))  == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptTopRight)) == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptCenter))   == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmLeft))  == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmRight)) == hDlg))
        {
            goto FoundPlace;
        }
    }

    //
    //  Try to insert the network button in the lower left corner of
    //  the dialog box.
    //
    if (bTryLowerLeft)
    {
        //
        //  Get the width of the dialog to make sure the button doesn't
        //  go off the side of the dialog.
        //
        xDlgWidth = rcDlg.right - xDUsToPels(FILE_RIGHT_MARGIN, lDlgBaseUnits);

        //
        //  Use the OK or CANCEL button saved earlier to get the size of
        //  the buttons.
        //
        hCtrl = hSave;

        //
        //  Start at the far left of the dialog.
        //
        //  NOTE: We know that hCtrl is not NULL at this point because
        //        otherwise we would have returned earlier.
        //
        //        The print dialogs have a left margin of 8.
        //
        GetWindowRect(hCtrl, &rcCtrl);
        xButton = rcDlg.left + xDUsToPels(FILE_LEFT_MARGIN + 3, lDlgBaseUnits);
        yButton = rcCtrl.top;

        while (1)
        {
            hLastCtrl = hCtrl;

            //
            //  Make sure there is still room in the dialog.
            //
            if ((xButton + dxButton) > xDlgWidth)
            {
                //
                //  No space.
                //
                break;
            }

            //
            //  Set the coordinates of the new button.
            //
            ptTopLeft.x = ptBtmLeft.x = xButton;
            ptTopLeft.y = ptTopRight.y = yButton;
            ptTopRight.x = ptBtmRight.x = xButton + dxButton;
            ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
            ptCenter.x = xButton + dxButton / 2;
            ptCenter.y = yButton + dyButton / 2;
            ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
            ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
            ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
            ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
            ScreenToClient(hDlg, (LPPOINT)&ptCenter);

            //
            //  See if the new button is over any other buttons.
            //
            if ( ( ((hCtrl = ChildWindowFromPoint(hDlg, ptTopLeft))  == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptTopRight)) == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptCenter))   == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmLeft))  == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmRight)) == hDlg) ) )
            {
                //
                //  If the last control is the OK button and there is a
                //  HELP button, then the last control should be the
                //  HELP button.
                //
                if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                    (hCtrl = GetDlgItem(hDlg, pshHelp)))
                {
                    GetWindowRect(hCtrl, &rcCtrl);
                    ptTopLeftTmp.x = rcCtrl.left;
                    ptTopLeftTmp.y = rcCtrl.top;

                    //
                    //  Make sure the HELP button isn't outside the dialog
                    //  and then set the last control to be the HELP button.
                    //
                    if (PtInRect(&rcDlg, ptTopLeftTmp))
                    {
                        hLastCtrl = hCtrl;
                    }
                }

                //
                //  If the last control is still the OK button and there is a
                //  CANCEL button, then the last control should be the
                //  CANCEL button.
                //
                if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                    (hCtrl = GetDlgItem(hDlg, IDCANCEL)))
                {
                    GetWindowRect(hCtrl, &rcCtrl);
                    ptTopLeftTmp.x = rcCtrl.left;
                    ptTopLeftTmp.y = rcCtrl.top;

                    //
                    //  Make sure the CANCEL button isn't outside the dialog
                    //  and then set the last control to be the CANCEL button.
                    //
                    if (PtInRect(&rcDlg, ptTopLeftTmp))
                    {
                        hLastCtrl = hCtrl;
                    }
                }

                goto FoundPlace;
            }

            //
            //  Make sure we encountered another control and that we
            //  didn't go off the end of the dialog.
            //
            if (!hCtrl)
            {
                break;
            }

            //
            //  Move over to the right and see if there is space.
            //
            GetWindowRect(hCtrl, &rcCtrl);
            xButton = rcCtrl.right + xDUsToPels(4, lDlgBaseUnits);
        }
    }

    return;

FoundPlace:

    xButton = ptTopLeft.x;
    yButton = ptTopLeft.y;

    //If it a mirrored Dlg then the direction will be to the right.
    if (IS_WINDOW_RTL_MIRRORED(hDlg))
        xButton -= dxButton;

#ifndef UNICODE
    //
    //  For non-localized apps that don't include the network button as part
    //  of their template, don't add a Far East one because the characters
    //  will not be displayed correctly.
    //
    {
        #define NetworkButtonText        TEXT("Network...")
        #define NetworkButtonTextAccel   TEXT("Net&work...")

        CPINFO cpinfo;

        if ((GetCPInfo(CP_ACP, &cpinfo)) && (cpinfo.MaxCharSize > 1))
        {
            TEXTMETRIC tm;
            HFONT hPrevFont;
            HWND hIDOK = GetDlgItem(hDlg, IDOK);
            HDC hDC = GetDC(hIDOK);

            hFont = (HFONT)SendMessage(hIDOK, WM_GETFONT, 0, 0L);
            if (hFont != NULL)
            {
                hPrevFont = SelectObject(hDC, hFont);
                GetTextMetrics(hDC, &tm);
                SelectObject(hDC, hPrevFont);
                ReleaseDC(hIDOK, hDC);

                if (tm.tmCharSet == ANSI_CHARSET)
                {
                    lstrcpy( szNetwork,
                             bAddAccel ? NetworkButtonTextAccel : NetworkButtonText );
                    goto CreateNetworkButton;
                }
            }
        }
    }
#endif

    if (CDLoadString( g_hinst,
                    (bAddAccel ? iszNetworkButtonTextAccel : iszNetworkButtonText),
                    (LPTSTR)szNetwork,
                    MAX_PATH ))
    {
#ifndef UNICODE
CreateNetworkButton:
#endif
        hwndButton = CreateWindow( TEXT("button"),
                                   szNetwork,
                                   WS_VISIBLE | WS_CHILD | WS_GROUP |
                                       WS_TABSTOP | BS_PUSHBUTTON,
                                   xButton,
                                   yButton,
                                   dxButton,
                                   dyButton,
                                   hDlg,
                                   NULL,
                                   hInstance,
                                   NULL );

        if (hwndButton != NULL)
        {
            SetWindowLong(hwndButton, GWL_ID, psh14);
            SetWindowPos( hwndButton,
                          hLastCtrl,
                          0, 0, 0, 0,
                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE );
            hFont = (HFONT)SendDlgItemMessage(hDlg, IDOK, WM_GETFONT, 0, 0L);
            SendMessage(hwndButton, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE,0));
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsNetworkInstalled
//
////////////////////////////////////////////////////////////////////////////

BOOL IsNetworkInstalled()
{
    if (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS)
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}



#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_Struct_For_WOW (This is exported for WOW)
//
//  For WOW support on NT only.
//
//  When a 16-bit app calls one of the comdlg API's, WOW thunks the 16-bit
//  comdlg struct passed by the app to a 32-bit ANSI struct.  Comdlg32 code
//  then thunks the 32-bit ANSI struct into a UNICODE struct.  This scheme
//  creates a problem for WOW apps because on Win3.1, the app and comdlg16
//  share the same structure.  When either updates the struct, the other is
//  aware of the change.
//
//  This function allows us to sychronize the UNICODE struct with the app's
//  16-bit struct & vice versa from WOW.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_Struct_For_WOW(
    HWND hDlg,
    BOOL fDirection,
    DWORD dwID)
{
    switch (dwID)
    {
        case ( WOW_CHOOSECOLOR ) :
        {
            Ssync_ANSI_UNICODE_CC_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_CHOOSEFONT ) :
        {
            Ssync_ANSI_UNICODE_CF_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_OPENFILENAME ) :
        {
            Ssync_ANSI_UNICODE_OFN_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_PRINTDLG ) :
        {
            Ssync_ANSI_UNICODE_PD_For_WOW(hDlg, fDirection);
            break;
        }

        // case not needed for FINDREPLACE
    }
}

#endif


#ifdef WX86

////////////////////////////////////////////////////////////////////////////
//
//  Wx86GetX86Callback
//
//  Creates a RISC-callable alias for a x86 hook function pointer.
//
//  lpfnHook - x86 address of hook
//
//  Returns a function pointer which can be called from RISC.
//
////////////////////////////////////////////////////////////////////////////

PVOID Wx86GetX86Callback(
    PVOID lpfnHook)
{
    if (!lpfnHook)
    {
        return (NULL);
    }

    if (!pfnAllocCallBx86)
    {
        HMODULE hMod;

        if (!Wx86CurrentTib())
        {
            //
            //  Wx86 is not running in this thread.  Assume a RISC app has
            //  passed a bad flag value and that lpfnHook is already a RISC
            //  function pointer.
            //
            return (lpfnHook);
        }

        hMod = GetModuleHandle(TEXT("wx86.dll"));
        if (hMod == NULL)
        {
            //
            //  Wx86 is running, but wx86.dll is not loaded!  This should
            //  never happen, but if it does, assume lpfnHook is already a
            //  RISC pointer.
            //
            return (lpfnHook);
        }
        pfnAllocCallBx86 = (PALLOCCALLBX86)GetProcAddress( hMod,
                                                           "AllocCallBx86" );
        if (!pfnAllocCallBx86)
        {
            //
            //  Something has gone terribly wrong!
            //
            return (lpfnHook);
        }
    }

    //
    //  Call into Wx86.dll to create a RISC-to-x86 callback which takes
    //  4 parameters and has no logging.
    //
    return (*pfnAllocCallBx86)(lpfnHook, 4, NULL, NULL);
}

#endif

////////////////////////////////////////////////////////////////////////////
//
//  CDLoadString
//
////////////////////////////////////////////////////////////////////////////
int CDLoadString(HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer, int nBufferMax)
{
    return CDLoadStringEx(CP_ACP, hInstance, uID, lpBuffer, nBufferMax);
}

// CDLoadStringEx takes a codepage, so we can store unicode strings in the resource file

int CDLoadStringEx(UINT cp, HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer, int nBufferMax)
{
    HRSRC   hResInfo;
    int     cch = 0;
    LPWSTR  lpwsz;
    LANGID  LangID;

    if (!GET_BIDI_LOCALIZED_SYSTEM_LANGID(NULL)) {
#ifdef WINNT
        return LoadString(hInstance, uID, lpBuffer, nBufferMax);
#else
        lpwsz = (LPWSTR) LocalAlloc(NONZEROLPTR, nBufferMax * sizeof(WCHAR));
        if (lpwsz)
        {
            int iRet;
            LoadStringWrapW(hInstance, uID, lpwsz, nBufferMax);
            iRet = WideCharToMultiByte(cp, 0, lpwsz, -1, lpBuffer, nBufferMax, NULL, NULL);
            LocalFree(lpwsz);
            return iRet;
        }
        return 0;
        
#endif
    }

    LangID = (LANGID)TlsGetValue(g_tlsLangID);

    if (!LangID || MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) == LangID) {
        return LoadString(hInstance, uID, lpBuffer, nBufferMax);
    }

    if (!lpBuffer || (nBufferMax-- == 0))
        return 0;

    // String Tables are broken up into 16 string resources.  Find the resource
    // containing the string we are interested in.
    if (hResInfo = FindResourceExFallback(hInstance, RT_STRING, MAKEINTRESOURCE((uID>>4)+1), LangID)) {

        // Load the resource.  Note LoadResource returns an address.
        if (lpwsz = (LPWSTR)LoadResource(hInstance, hResInfo)) {
            // Move past the other strings in this resource.
            // (16 strings in a segment -> & 0x0F)
            for (uID %= 16; uID; uID--) {
                lpwsz += *lpwsz + 1;
            }
            cch = min(*lpwsz, nBufferMax - 1);
#ifdef UNICODE
            // Copy the string into the buffer;
            memcpy(lpBuffer, lpwsz+1, cch*sizeof(WCHAR));
#else 
            // Copy the string into the buffer, converting to Ansi.
            cch= WideCharToMultiByte(  CP_ACP, 0, lpwsz+1, cch, lpBuffer, cch, NULL, NULL);
#endif
        }
    }

    lpBuffer[cch] = 0;
    return cch;
}

#define ENGLISH_APP     0
#define MIRRORED_APP    1
#define BIDI_APP        2

DWORD GetAppType(HWND hWnd) {
    DWORD dwExStyle = 0;
    HWND  hWndT     = hWnd;
    DWORD dwAppType = ENGLISH_APP;

#ifdef CHECK_OWNER
    //Check the window and its owners.
    while (!dwExStyle && hWndT) {
       dwExStyle = GetWindowLongA(hWndT, GWL_EXSTYLE) & (WS_EX_RIGHT | WS_EX_RTLREADING | RTL_MIRRORED_WINDOW);
        hWndT = GetWindow(hWndT, GW_OWNER);
    }

    if (!dwExStyle) {
#endif
        //If we still did not find then check the parents.
        hWndT = hWnd;
        while (!dwExStyle && hWndT) {
            dwExStyle = GetWindowLongA(hWndT, GWL_EXSTYLE) & (WS_EX_RIGHT | WS_EX_RTLREADING | RTL_MIRRORED_WINDOW);
            hWndT = GetParent(hWndT);
        }
#ifdef CHECK_OWNER
    }
#endif

    if (dwExStyle & RTL_MIRRORED_WINDOW) {
       dwAppType = MIRRORED_APP;
    } else if (dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING)) {
       dwAppType = BIDI_APP;
    }

    return dwAppType;
}

DWORD GetTemplateType(HANDLE hDlgTemplate)
{
    DWORD dwExStyle = 0;
    DWORD dwAppType = ENGLISH_APP;
    LPDLGTEMPLATE pDlgTemplate;

    pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
    if (pDlgTemplate) {
        if (((LPDLGTEMPLATEEX) pDlgTemplate)->wSignature == 0xFFFF) {
            dwExStyle = ((LPDLGTEMPLATEEX) pDlgTemplate)->dwExStyle;
        } else {
            dwExStyle = pDlgTemplate->dwExtendedStyle;
        }
    }

    if (dwExStyle & RTL_MIRRORED_WINDOW) {
       dwAppType = MIRRORED_APP;
    } else if (dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING)) {
       dwAppType = BIDI_APP;
    }

    return dwAppType;
}

LANGID GetDialogLanguage(HWND hwndOwner, HANDLE hDlgTemplate)
{
   LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
   DWORD  dwType;

   if (GET_BIDI_LOCALIZED_SYSTEM_LANGID(&LangID)) {
       if (hDlgTemplate == NULL) {
           dwType = GetAppType(hwndOwner);
       } else {
           dwType = GetTemplateType(hDlgTemplate);
       }

       switch (dwType) {
           case ENGLISH_APP :
               LangID =  MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
               break;

           case MIRRORED_APP:
               LangID =  MAKELANGID(PRIMARYLANGID(LangID), SUBLANG_DEFAULT);
               break;

           case BIDI_APP    :
               LangID =  MAKELANGID(PRIMARYLANGID(LangID), SUBLANG_SYS_DEFAULT);
               break;
       }
   }
   return LangID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\find.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    find.h

Abstract:

    This module contains the header information for the Win32 find dialog.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

//
//  Length of "Close" string in chars.
//
#define CCHCLOSE        9

//
//  Dialog Box PROPERTY slots defined.
//
//  Note: If each app does indeed have a copy of the dll's global
//        variable space, then there is no reason to stick properties
//        onto the window like this.
//
#define FINDREPLACEPROP (LPCTSTR) 0xA000L

//
//  Overload Dialog Type.
//
#define DLGT_FIND       0x0
#define DLGT_REPLACE    0x1

#define cbFindMax       1024




//
//  Typedef Declarations.
//

typedef struct {
   UINT           ApiType;
   UINT           DlgType;
   LPFINDREPLACE  pFR;
} FINDREPLACEINFO;

typedef FINDREPLACEINFO *PFINDREPLACEINFO;




//
//  Global Variables.
//

static UINT wFRMessage;
static UINT wHelpMessage;
static TCHAR szClose [CCHCLOSE];

LPFRHOOKPROC glpfnFindHook = 0;




//
//  Context Help IDs.
//

const static DWORD aFindReplaceHelpIDs[] =       // Context Help IDs
{
    edt1,    IDH_FIND_SEARCHTEXT,
    edt2,    IDH_REPLACE_REPLACEWITH,
    chx1,    IDH_FIND_WHOLE,
    chx2,    IDH_FIND_CASE,
    IDOK,    IDH_FIND_NEXT_BUTTON,
    psh1,    IDH_REPLACE_REPLACE,
    psh2,    IDH_REPLACE_REPLACE_ALL,
    pshHelp, IDH_HELP,
    grp1,    IDH_FIND_DIRECTION,
    rad1,    IDH_FIND_DIRECTION,
    rad2,    IDH_FIND_DIRECTION,

    0, 0
};




//
//  Function Prototypes.
//

HWND
CreateFindReplaceDlg(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType);

BOOL
SetupOK(
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType);

HANDLE
GetDlgTemplate(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType);

BOOL_PTR CALLBACK
FindReplaceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

VOID
EndDlgSession(
   HWND hDlg,
   LPFINDREPLACE pFR);

VOID
InitControlsWithFlags(
   HWND hDlg,
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType);

VOID
UpdateTextAndFlags(
    HWND hDlg,
    LPFINDREPLACE pFR,
    DWORD dwActionFlag,
    UINT DlgType,
    UINT ApiType);

LRESULT
NotifyUpdateTextAndFlags(
    LPFINDREPLACE pFR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\find.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    find.c

Abstract:

    This module implements the Win32 find dialog.

Revision History:

--*/


// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "find.h"
#include "util.h"

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  FindTextA
//
//  ANSI entry point for FindText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_FIND, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  FindTextW
//
//  Stub UNICODE function for FindText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  FindText
//
//  The FindText function creates a system-defined modeless dialog box
//  that enables the user to find text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_FIND, COMDLG_WIDE) );
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextA
//
//  ANSI entry point for ReplaceText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_REPLACE, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextW
//
//  Stub UNICODE function for ReplaceText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  ReplaceText
//
//  The ReplaceText function creates a system-defined modeless dialog box
//  that enables the user to find and replace text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_REPLACE, COMDLG_WIDE) );
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFindReplaceDlg
//
//  Creates FindText modeless dialog.
//
//  pFR     - ptr to FINDREPLACE structure set up by user
//  DlgType - type of dialog to create (DLGT_FIND, DLGT_REPLACE)
//  ApiType - type of FINDREPLACE ptr (COMDLG_ANSI or COMDLG_WIDE)
//
//  Returns   success => HANDLE to created dlg
//            failure => HNULL = ((HANDLE) 0)
//
////////////////////////////////////////////////////////////////////////////

HWND CreateFindReplaceDlg(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HWND hWndDlg;                      // handle to created modeless dialog
    HANDLE hDlgTemplate;               // handle to loaded dialog resource
    LPCDLGTEMPLATE lpDlgTemplate;      // pointer to loaded resource block
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif

    if (!pFR)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (!SetupOK(pFR, DlgType, ApiType))
    {
        return (HNULL);
    }

    if (!(hDlgTemplate = GetDlgTemplate(pFR, DlgType, ApiType)))
    {
        return (FALSE);
    }

    if (lpDlgTemplate = (LPCDLGTEMPLATE)LockResource(hDlgTemplate))
    {
        PFINDREPLACEINFO pFRI;

        if (pFRI = (PFINDREPLACEINFO)LocalAlloc(LPTR, sizeof(FINDREPLACEINFO)))
        {
            //
            //  CLEAR extended error on new instantiation.
            //
            StoreExtendedError(0);

            if (pFR->Flags & FR_ENABLEHOOK)
            {
                glpfnFindHook = GETHOOKFN(pFR);
            }

            pFRI->pFR = pFR;
            pFRI->ApiType = ApiType;
            pFRI->DlgType = DlgType;

#ifdef UNICODE
            if (IS16BITWOWAPP(pFR))
            {
                uiWOWFlag = SCDLG_16BIT;
            }

            hWndDlg = CreateDialogIndirectParamAorW( g_hinst,
                                                     lpDlgTemplate,
                                                     pFR->hwndOwner,
                                                     FindReplaceDlgProc,
                                                     (LPARAM)pFRI,
                                                     uiWOWFlag );
#else
            hWndDlg = CreateDialogIndirectParam( g_hinst,
                                                 lpDlgTemplate,
                                                 pFR->hwndOwner,
                                                 FindReplaceDlgProc,
                                                 (LPARAM)pFRI );
#endif
            if (!hWndDlg)
            {
                glpfnFindHook = 0;
                LocalFree(pFRI);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (NULL);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
        return (HNULL);
    }

    return (hWndDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetupOK
//
//  Checks setup for unmet preconditions.
//
//  pFR       ptr to FINDREPLACE structure
//  DlgType   dialog type (either FIND or REPLACE)
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   TRUE   - success
//            FALSE  - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL SetupOK(
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    //
    //  Sanity
    //
    if (!pFR)
    {
        return (FALSE);
    }

    if (pFR->lStructSize != sizeof(FINDREPLACE))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  Verify window handle and text pointers.
    //
    if (!IsWindow(pFR->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    if (!pFR->lpstrFindWhat ||
        ((DlgType == DLGT_REPLACE) && !pFR->lpstrReplaceWith) ||
        !pFR->wFindWhatLen)
    {
        StoreExtendedError(FRERR_BUFFERLENGTHZERO);
        return (FALSE);
    }

    //
    //  Verify lpfnHook has a ptr if ENABLED.
    //
    if (pFR->Flags & FR_ENABLEHOOK)
    {
        if (!pFR->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pFR->lpfnHook = 0;
    }

    //
    // Get LangID 
    //
    if (
        !(pFR->Flags & FR_ENABLETEMPLATE) &&
        !(pFR->Flags & FR_ENABLETEMPLATEHANDLE) )
    {
        LangID = GetDialogLanguage(pFR->hwndOwner, NULL);
    }

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) LangID);

    //
    //  Load "CLOSE" text for Replace.
    //
    if ((DlgType == DLGT_REPLACE) &&
        !CDLoadString(g_hinst, iszClose, (LPTSTR)szClose, CCHCLOSE))
    {
        StoreExtendedError(CDERR_LOADSTRFAILURE);
        return (FALSE);
    }


    //
    //  Setup unique msg# for talking to hwndOwner.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        if (!(wFRMessage = RegisterWindowMessageA((LPCSTR)FINDMSGSTRINGA)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }
    else
#endif
    {
        if (!(wFRMessage = RegisterWindowMessage((LPCTSTR)FINDMSGSTRING)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDlgTemplate
//
//  Finds and loads the dialog template.
//
//  pFR       ptr to FINDREPLACE structure
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   handle to dialog template   - success
//            HNULL = ((HANDLE) 0)        - failure
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetDlgTemplate(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HANDLE hRes;                 // handle of res. block with dialog
    HANDLE hDlgTemplate;         // handle to loaded dialog resource
    LANGID LangID;

    if (pFR->Flags & FR_ENABLETEMPLATE)
    {
        //
        //  Find/Load TEMP NAME and INSTANCE from pFR.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            hRes = FindResourceA( (HMODULE)pFR->hInstance,
                                  (LPCSTR)pFR->lpTemplateName,
                                  (LPCSTR)RT_DIALOG );
        }
        else
#endif
        {
            hRes = FindResource( pFR->hInstance,
                                 (LPCTSTR)pFR->lpTemplateName,
                                 (LPCTSTR)RT_DIALOG );
        }
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(pFR->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }
    else if (pFR->Flags & FR_ENABLETEMPLATEHANDLE)
    {
        //
        //  Get whole PRELOADED resource handle from user.
        //
        if (!(hDlgTemplate = pFR->hInstance))
        {
            StoreExtendedError(CDERR_NOHINSTANCE);
            return (HNULL);
        }
    }
    else
    {
        //
        //  Get STANDARD dialog from DLL instance block.
        //
        LangID = (LANGID) TlsGetValue(g_tlsLangID);

        if (DlgType == DLGT_FIND)
        {
            hRes = FindResourceExFallback( g_hinst,
                                   RT_DIALOG, 
                                   MAKEINTRESOURCE(FINDDLGORD),
                                   LangID);
        }
        else
        {
            hRes = FindResourceExFallback( g_hinst,
                                   RT_DIALOG, 
                                   MAKEINTRESOURCE(REPLACEDLGORD),
                                   LangID);
        }

        //
        //  !!!!!  definitely ORD here?
        //
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }

    return (hDlgTemplate);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindReplaceDlgProc
//
//  Handles messages to FindText/ReplaceText dialogs.
//
//  hDlg   -  handle to dialog
//  wMsg   -  window message
//  wParam -  w parameter of message
//  lParam -  l parameter of message
//
//  Note: lparam contains ptr to FINDREPLACEINITPROC upon
//        initialization from CreateDialogIndirectParam...
//
//  Returns:   TRUE (or dlg fcn return vals) - success
//             FALSE                         - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FindReplaceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PFINDREPLACEINFO pFRI;
    LPFINDREPLACE pFR;
    BOOL_PTR bRet;

    //
    //  If a hook exists, let hook function do procing.
    //
    if (pFRI = (PFINDREPLACEINFO)GetProp(hDlg, FINDREPLACEPROP))
    {
        if ((pFR = (LPFINDREPLACE)pFRI->pFR) &&
            (pFR->Flags & FR_ENABLEHOOK))
        {
            LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

            if ((bRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam)))
            {
                return (bRet);
            }
        }
    }
    else if (glpfnFindHook &&
             (wMsg != WM_INITDIALOG) &&
             (bRet = (* glpfnFindHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bRet);
    }

    //
    //  Dispatch MSG to appropriate HANDLER.
    //
    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Set Up P-Slot.
            //
            pFRI = (PFINDREPLACEINFO)lParam;
            SetProp(hDlg, FINDREPLACEPROP, (HANDLE)pFRI);

            glpfnFindHook = 0;

            //
            //  Init dlg controls accordingly.
            //
            pFR = pFRI->pFR;
            InitControlsWithFlags(hDlg, pFR, pFRI->DlgType, pFRI->ApiType);

            //
            //  If Hook function, do extra processing.
            //
            if (pFR->Flags & FR_ENABLEHOOK)
            {
                LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

                bRet = (*lpfnHook)(hDlg, wMsg, wParam, (LPARAM)pFR);
            }
            else
            {
                bRet = TRUE;
            }

            if (bRet)
            {
                //
                //  If the hook function returns FALSE, then we must call
                //  these functions here.
                //
                ShowWindow(hDlg, SW_SHOWNORMAL);
                UpdateWindow(hDlg);
            }

            return (bRet);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pFRI || !pFR)
            {
                return (FALSE);
            }

            switch (GET_WM_COMMAND_ID (wParam, lParam))
            {
                //
                //  FIND NEXT button clicked.
                //
                case ( IDOK ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        FR_FINDNEXT,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    NotifyUpdateTextAndFlags(pFR);
                    break;
                }
                case ( IDCANCEL ) :
                case ( IDABORT ) :
                {
                    EndDlgSession(hDlg, pFR);
                    LocalFree(pFRI);
                    break;
                }
                case ( psh1 ) :
                case ( psh2 ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        (wParam == psh1)
                                            ? FR_REPLACE
                                            : FR_REPLACEALL,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    if (NotifyUpdateTextAndFlags(pFR) == TRUE)
                    {
                        //
                        //  Change <Cancel> button to <Close> if function
                        //  returns TRUE.
                        //  IDCANCEL instead of psh1.
                        SetWindowText( GetDlgItem(hDlg, IDCANCEL),
                                       (LPTSTR)szClose );
                    }
                    break;
                }
                case ( pshHelp ) :
                {
                    //
                    //  Call HELP app.
                    //
#ifdef UNICODE
                    if (pFRI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    break;
                }
                case ( edt1 ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        BOOL fAnythingToFind =
                            (BOOL)SendDlgItemMessage( hDlg,
                                                      edt1,
                                                      WM_GETTEXTLENGTH,
                                                      0,
                                                      0L );
                        EnableWindow(GetDlgItem(hDlg, IDOK), fAnythingToFind);
                        if (pFRI->DlgType == DLGT_REPLACE)
                        {
                            EnableWindow(GetDlgItem(hDlg, psh1), fAnythingToFind);
                            EnableWindow(GetDlgItem(hDlg, psh2), fAnythingToFind);
                        }
                    }

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK),
                                      (BOOL)SendDlgItemMessage(
                                                   hDlg,
                                                   edt1,
                                                   WM_GETTEXTLENGTH,
                                                   0,
                                                   0L ));
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CLOSE ) :
        {
            SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDCANCEL, 0, 0));
            return (TRUE);
            break;
        }
        default:
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EndDlgSession
//
//  Cleans up upon destroying the dialog.
//
////////////////////////////////////////////////////////////////////////////

VOID EndDlgSession(
   HWND hDlg,
   LPFINDREPLACE pFR)
{
    //
    //  Need to terminate regardless of app testing order ... so:
    //

    //
    //  No SUCCESS on termination.
    //
    pFR->Flags &= ~((DWORD)(FR_REPLACE | FR_FINDNEXT | FR_REPLACEALL));

    //
    //  Tell caller dialog is about to terminate.
    //
    pFR->Flags |= FR_DIALOGTERM;
    NotifyUpdateTextAndFlags(pFR);

    if (IS16BITWOWAPP(pFR))
    {
        if ((pFR->Flags & FR_ENABLEHOOK) && (pFR->lpfnHook))
        {
            (*pFR->lpfnHook)(hDlg, WM_DESTROY, 0, 0);
        }
    }

    //
    //  Free property slots.
    //
    RemoveProp(hDlg, FINDREPLACEPROP);
    DestroyWindow(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitControlsWithFlags
//
////////////////////////////////////////////////////////////////////////////

VOID InitControlsWithFlags(
   HWND hDlg,
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    HWND hCtl;

    //
    //  Set EDIT control to FindText.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        SetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat);
    }
    else
#endif
    {
        SetDlgItemText(hDlg, edt1, (LPTSTR)pFR->lpstrFindWhat);
    }
    SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(edt1, 0, EN_CHANGE));

    //
    //  Set HELP push button state.
    //
    if (!(pFR->Flags & FR_SHOWHELP))
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, pshHelp), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }

    //
    //  Dis/Enable check state of WHOLE WORD control.
    //
    if (pFR->Flags & FR_HIDEWHOLEWORD)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOWHOLEWORD)
    {
        EnableWindow(GetDlgItem(hDlg, chx1), FALSE);
    }
    CheckDlgButton(hDlg, chx1, (pFR->Flags & FR_WHOLEWORD) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of MATCH CASE control.
    //
    if (pFR->Flags & FR_HIDEMATCHCASE)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOMATCHCASE)
    {
        EnableWindow(GetDlgItem(hDlg, chx2), FALSE);
    }
    CheckDlgButton(hDlg, chx2, (pFR->Flags & FR_MATCHCASE) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of UP/DOWN buttons.
    //
    if (pFR->Flags & FR_HIDEUPDOWN)
    {
        ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOUPDOWN)
    {
        EnableWindow(GetDlgItem(hDlg, rad1), FALSE);
        EnableWindow(GetDlgItem(hDlg, rad2), FALSE);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Find Text only search direction setup.
        //
        CheckRadioButton( hDlg,
                          rad1,
                          rad2,
                          (pFR->Flags & FR_DOWN ? rad2 : rad1) );
    }
    else
    {
        //
        //  Replace Text only operations.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
             SetDlgItemTextA(hDlg, edt2, (LPSTR)pFR->lpstrReplaceWith);
        }
        else
#endif
        {
             SetDlgItemText(hDlg, edt2, pFR->lpstrReplaceWith);
        }
        SendMessage( hDlg,
                     WM_COMMAND,
                     GET_WM_COMMAND_MPS(edt2, 0, EN_CHANGE) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateTextAndFlags
//
//  chx1 is whether or not to match entire words
//  chx2 is whether or not case is relevant
//  chx3 is whether or not to wrap scans
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateTextAndFlags(
    HWND hDlg,
    LPFINDREPLACE pFR,
    DWORD dwActionFlag,
    UINT DlgType,
    UINT ApiType)
{
    //
    //  Only clear flags that this routine sets.  The hook and template
    //  flags should not be anded off here.
    //
    pFR->Flags &= ~((DWORD)(FR_WHOLEWORD | FR_MATCHCASE | FR_REPLACE |
                            FR_FINDNEXT | FR_REPLACEALL | FR_DOWN));
    if (IsDlgButtonChecked(hDlg, chx1))
    {
        pFR->Flags |= FR_WHOLEWORD;
    }

    if (IsDlgButtonChecked(hDlg, chx2))
    {
        pFR->Flags |= FR_MATCHCASE;
    }

    //
    //  Set ACTION flag FR_{REPLACE,FINDNEXT,REPLACEALL}.
    //
    pFR->Flags |= dwActionFlag;

#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        GetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }
    else
#endif
    {
        GetDlgItemText(hDlg, edt1, pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Assume searching down.  Check if UP button is NOT pressed, rather
        //  than if DOWN button IS.  So, if buttons have been hidden or
        //  disabled, FR_DOWN flag will be set correctly.
        //
        if (!IsDlgButtonChecked(hDlg, rad1))
        {
            pFR->Flags |= FR_DOWN;
        }
    }
    else
    {
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            GetDlgItemTextA( hDlg,
                             edt2,
                             (LPSTR)pFR->lpstrReplaceWith,
                             pFR->wReplaceWithLen );
        }
        else
#endif
        {
            GetDlgItemText( hDlg,
                            edt2,
                            pFR->lpstrReplaceWith,
                            pFR->wReplaceWithLen );
        }
        pFR->Flags |= FR_DOWN;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NotifyUpdateTextAndFlags
//
////////////////////////////////////////////////////////////////////////////

LRESULT NotifyUpdateTextAndFlags(
    LPFINDREPLACE pFR)
{
    if (IS16BITWOWAPP(pFR))
    {
        return ( SendMessage( pFR->hwndOwner,
                              WM_NOTIFYWOW,
                              WMNW_UPDATEFINDREPLACE,
                              (DWORD_PTR)pFR ) );
    }
    return ( SendMessage(pFR->hwndOwner, wFRMessage, 0, (DWORD_PTR)pFR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\fileopen.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    fileopen.h

Abstract:

    This module contains the header information for the Win32 fileopen
    dialogs.

Revision History:

--*/



#ifdef __cplusplus
extern "C" {
#endif



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

#define MAX_DISKNAME                   260
#define TOOLONGLIMIT                   MAX_PATH
#define MAX_FULLPATHNAME               520                 // 260 + 260
#define WARNINGMSGLENGTH               MAX_FULLPATHNAME

#define ERROR_NO_DISK_IN_CDROM         92L
#define ERROR_NO_DISK_IN_DRIVE         93L
#define ERROR_DIR_ACCESS_DENIED        94L
#define ERROR_FILE_ACCESS_DENIED       95L
#define ERROR_CREATE_NO_MODIFY         96L
#define ERROR_NO_DRIVE                 97L
#define ERROR_PORTNAME                 98L
#define ERROR_LAZY_READONLY            99L

//
//  Internal Flags.
//
//  Be sure to update OFN_ALL_INTERNAL_FLAGS if more internal flags are
//  added.
//
#define OFN_ALL_INTERNAL_FLAGS         0xf8000000     // Keep this in sync
#define OFN_PREFIXMATCH                0x80000000     // Internal
#define OFN_DIRSELCHANGED              0x40000000     // Internal
#define OFN_DRIVEDOWN                  0x20000000     // Internal
#define OFN_FILTERDOWN                 0x10000000     // Internal
// CD_WX86APP is                       0x08000000     // Internal

//
//  Used with OFN_COMBODOWN.
//
#define MYCBN_DRAW                     0x8000
#define MYCBN_LIST                     0x8001
#define MYCBN_REPAINT                  0x8002
#define MYCBN_CHANGEDIR                0x8003

#define OFN_OFFSETTAG                  0x0001

#define FILEPROP (LPCTSTR)             0xA000L

#define CHANGEDIR_FAILED               -1

#define ADDDISK_NOCHANGE               -1
#define ADDDISK_INVALIDPARMS           -2
#define ADDDISK_MAXNUMDISKS            -3
#define ADDDISK_NETFORMATFAILED        -4
#define ADDDISK_ALLOCFAILED            -5

#define ATTR_READONLY                  0x0000001      // GetFileAttributes flag

#define mskFile                        0x0000         // List files
#define mskDirectory                   0x0010         // List directories
#define mskUNCName                     0x0020         // Note UNC directory

#define mskDrives                      0xC000         // List drives ONLY

#define rgbSolidGreen                  0x0000FF00
#define rgbSolidBlue                   0x00FF0000

#define dxSpace                        4

#define cbCaption                      64

#define SUCCESS                        0x0
#define FAILURE                        0x1

#define DBL_BSLASH(sz) \
   (*(TCHAR *)(sz)       == CHAR_BSLASH) && \
   (*(TCHAR *)((sz) + 1) == CHAR_BSLASH)

#ifdef UNICODE
  #define ISBACKSLASH(szPath, nOffset) (szPath[nOffset] == CHAR_BSLASH)
  #define ISBACKSLASH_P(szPath, pPos)  (*pPos == CHAR_BSLASH)
#else
  #define ISBACKSLASH(szPath, nOffset) (IsBackSlash(szPath, szPath + nOffset))
  #define ISBACKSLASH_P(szPath, pPos)  (IsBackSlash(szPath, pPos))
#endif


//
//  Constant used in FILEOPENINFO to specify the version of
//  the structure passed by the application.//
#define OPENFILEVERSION_NT4                   0x0004
#define OPENFILEVERSION_NT5                   0x0005
#define OPENFILEVERSION                       0x0005  //Current Version if NT5




//
//  Typedef Declarations.
//

typedef struct _OFN_ANSI_STRING {
    ULONG Length;
    ULONG MaximumLength;
    LPSTR Buffer;
} OFN_ANSI_STRING;

typedef OFN_ANSI_STRING *POFN_ANSI_STRING;

typedef struct _OFN_UNICODE_STRING {
    ULONG  Length;
    ULONG  MaximumLength;
    LPWSTR Buffer;
} OFN_UNICODE_STRING;

typedef OFN_UNICODE_STRING *POFN_UNICODE_STRING;

typedef struct {
    UINT                ApiType;
    LPOPENFILENAME      pOFN;
    TCHAR               szCurDir[MAX_FULLPATHNAME + 1];
    TCHAR               szPath[MAX_FULLPATHNAME];
    TCHAR               szSpecCur[MAX_FULLPATHNAME];
    TCHAR               szLastFilter[MAX_FULLPATHNAME + 1];
    DWORD               idirSub;
	//Version of structure.
    DWORD               iVersion;
#ifdef UNICODE
    LPOPENFILENAMEA     pOFNA;
    POFN_UNICODE_STRING pusCustomFilter;
    POFN_ANSI_STRING    pasCustomFilter;
    BOOL                bUseNewDialog;
#endif

} OPENFILEINFO;

typedef OPENFILEINFO * POPENFILEINFO;
typedef OPENFILEINFO * LPOPENFILEINFO;



//
//  Function Prototypes.
//

BOOL NewGetOpenFileName(LPOPENFILEINFO lpOFI);

BOOL NewGetSaveFileName(LPOPENFILEINFO lpOFI);

STDAPI_(void) GetAppOpenDir(LPCTSTR pszDir,LPTSTR pszOut, LPITEMIDLIST *ppidl);
STDAPI_(BOOL) FoundFilterMatch(LPCTSTR pszIn, BOOL bLFN);

#ifdef UNICODE
  VOID
  ThunkOpenFileNameA2WDelayed(
      POPENFILEINFO pOFI);

  BOOL
  ThunkOpenFileNameA2W(
      POPENFILEINFO pOFI);

  BOOL
  ThunkOpenFileNameW2A(
      POPENFILEINFO pOFI);
#else
  VOID
  EliminateString(
      LPSTR lpStr,
      int nLen);

  BOOL
  IsBackSlash(
      LPSTR lpStart,
      LPSTR lpChar);
#endif


#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\font.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    font.h

Abstract:

    This module contains the header information for the Win32 font dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>

#ifdef  MM_DESIGNVECTOR_DEFINED

// new flag that for NT 5.0/IE 5.0 is used for testing purpose only
#define CF_MM_DESIGNVECTOR             0x02000000L

#if (_WIN32_WINNT < 0x0500)
//
// new NT 5.0 definitions related to MultipleMaster desing vector, from WinGdi.h
//
#define STAMP_DESIGNVECTOR  (0x8000000 + 'd' + ('v' << 8))
#define STAMP_AXESLIST      (0x8000000 + 'a' + ('l' << 8))
#define MM_MAX_NUMAXES      16



typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[MM_MAX_NUMAXES];
} DESIGNVECTOR, *PDESIGNVECTOR, FAR *LPDESIGNVECTOR;

typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, FAR *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, FAR *LPENUMLOGFONTEXDVW;
#ifdef UNICODE
typedef ENUMLOGFONTEXDVW ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVW PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVW LPENUMLOGFONTEXDV;
#else
typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
#endif // UNICODE


#define MM_MAX_AXES_NAMELEN 16

typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[MM_MAX_AXES_NAMELEN];
} AXISINFOA, *PAXISINFOA, FAR *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[MM_MAX_AXES_NAMELEN];
} AXISINFOW, *PAXISINFOW, FAR *LPAXISINFOW;
#ifdef UNICODE
typedef AXISINFOW AXISINFO;
typedef PAXISINFOW PAXISINFO;
typedef LPAXISINFOW LPAXISINFO;
#else
typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
#endif // UNICODE

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[MM_MAX_NUMAXES];
} AXESLISTA, *PAXESLISTA, FAR *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[MM_MAX_NUMAXES];
} AXESLISTW, *PAXESLISTW, FAR *LPAXESLISTW;
#ifdef UNICODE
typedef AXESLISTW AXESLIST;
typedef PAXESLISTW PAXESLIST;
typedef LPAXESLISTW LPAXESLIST;
#else
typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
#endif // UNICODE

typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, FAR *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, FAR *LPENUMTEXTMETRICW;

#ifdef UNICODE
typedef ENUMTEXTMETRICW ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICW PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICW LPENUMTEXTMETRIC;
#else
typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
#endif // UNICODE

#endif // (_WIN32_WINNT < 0x0500)
#endif //  MM_DESIGNVECTOR_DEFINED

//
//  Constant Declarations.
//

// Finnish needs 17 chars (18 w/ NULL) -- let's give them 20.
#define CCHCOLORNAMEMAX      20        // max length of color name text
#define CCHCOLORS            16        // max # of pure colors in color combo

#define POINTS_PER_INCH      72
#define FFMASK               0xf0      // pitch and family mask
#define CCHSTDSTRING         12        // max length of sample text string

#define FONTPROP   (LPCTSTR) 0xA000L

#define CBN_MYEDITUPDATE     (WM_USER + 501)
#define KEY_FONT_SUBS TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes")

#define DEF_POINT_SIZE       10

//If you add a bitmaps to the font bitmap you should modify this constant.
#define NUM_OF_BITMAP        5
#define DX_BITMAP            20
#define DY_BITMAP            12

#define FONT_INVALID_CHARSET 0x100




//
//  Typedef Declarations.
//

#ifdef  MM_DESIGNVECTOR_DEFINED
// CreateFontIndirectEx
typedef HFONT (WINAPI *PFNCREATEFONTINDIRECTEX)( IN CONST ENUMLOGFONTEXDV *);
#endif //  MM_DESIGNVECTOR_DEFINED

typedef struct {
    UINT            ApiType;
    LPCHOOSEFONT    pCF;
    UINT            iCharset;
    RECT            rcText;
    DWORD           nLastFontType;
    DWORD           ProcessVersion;

#ifdef  MM_DESIGNVECTOR_DEFINED
    PFNCREATEFONTINDIRECTEX pfnCreateFontIndirectEx;
    DESIGNVECTOR   DefaultDesignVector;
#endif //  MM_DESIGNVECTOR_DEFINED

#ifdef UNICODE
    LPCHOOSEFONTA   pCFA;
    PUNICODE_STRING pusStyle;
    PANSI_STRING    pasStyle;
#endif
} FONTINFO;

typedef FONTINFO *PFONTINFO;


typedef struct {
    HWND hwndFamily;
    HWND hwndStyle;
    HWND hwndSizes;
    HWND hwndScript;
    UINT iCharset;                // returned for enumerating scripts
    UINT cfdCharset;              // ChooseFontData charset passed in here
    HDC hDC;
    DWORD dwFlags;
    DWORD nFontType;
    BOOL bFillSize;
    BOOL bPrinterFont;
    LPCHOOSEFONT lpcf;
#ifdef  MM_DESIGNVECTOR_DEFINED
    HWND hwndParent;             // to extend the dialog for MM
    PDESIGNVECTOR   pDefaultDesignVector;
#endif //  MM_DESIGNVECTOR_DEFINED
} ENUM_FONT_DATA, *LPENUM_FONT_DATA;


typedef struct _ITEMDATA {
    PLOGFONT pLogFont;
    DWORD nFontType;
} ITEMDATA, *LPITEMDATA;


//
//  Chinese font numbers (zihao).
//
typedef struct {
    TCHAR name[5];
    int size;
    int sizeFr;
} ZIHAO;

#define NUM_ZIHAO  16

#ifdef UNICODE

ZIHAO stZihao[NUM_ZIHAO] =
{
    { L"\x516b\x53f7",  5, 0 }, { L"\x4e03\x53f7",  5, 5 },
    { L"\x5c0f\x516d",  6, 5 }, { L"\x516d\x53f7",  7, 5 },
    { L"\x5c0f\x4e94",  9, 0 }, { L"\x4e94\x53f7", 10, 5 },
    { L"\x5c0f\x56db", 12, 0 }, { L"\x56db\x53f7", 14, 0 },
    { L"\x5c0f\x4e09", 15, 0 }, { L"\x4e09\x53f7", 16, 0 },
    { L"\x5c0f\x4e8c", 18, 0 }, { L"\x4e8c\x53f7", 22, 0 },
    { L"\x5c0f\x4e00", 24, 0 }, { L"\x4e00\x53f7", 26, 0 },
    { L"\x5c0f\x521d", 36, 0 }, { L"\x521d\x53f7", 42, 0 }
};

#else

ZIHAO stZihao[NUM_ZIHAO] =
{
    { "\xb0\xcb\xba\xc5",  5, 0 }, { "\xc6\xdf\xba\xc5",  5, 5 },
    { "\xd0\xa1\xc1\xf9",  6, 5 }, { "\xc1\xf9\xba\xc5",  7, 5 },
    { "\xd0\xa1\xce\xe5",  9, 0 }, { "\xce\xe5\xba\xc5", 10, 5 },
    { "\xd0\xa1\xcb\xc4", 12, 0 }, { "\xcb\xc4\xba\xc5", 14, 0 },
    { "\xd0\xa1\xc8\xfd", 15, 0 }, { "\xc8\xfd\xba\xc5", 16, 0 },
    { "\xd0\xa1\xb6\xfe", 18, 0 }, { "\xb6\xfe\xba\xc5", 22, 0 },
    { "\xd0\xa1\xd2\xbb", 24, 0 }, { "\xd2\xbb\xba\xc5", 26, 0 },
    { "\xd0\xa1\xb3\xf5", 36, 0 }, { "\xb3\xf5\xba\xc5", 42, 0 }
};

#endif

//
//  Global Variables.
//

UINT msgWOWLFCHANGE;
UINT msgWOWCHOOSEFONT_GETLOGFONT;

//
//  Color tables for color combo box.
//  Order of values must match names in sz.src.
//
DWORD rgbColors[CCHCOLORS] =
{
        RGB(  0,   0, 0),       // Black
        RGB(128,   0, 0),       // Dark red
        RGB(  0, 128, 0),       // Dark green
        RGB(128, 128, 0),       // Dark yellow
        RGB(  0,   0, 128),     // Dark blue
        RGB(128,   0, 128),     // Dark purple
        RGB(  0, 128, 128),     // Dark aqua
        RGB(128, 128, 128),     // Dark grey
        RGB(192, 192, 192),     // Light grey
        RGB(255,   0, 0),       // Light red
        RGB(  0, 255, 0),       // Light green
        RGB(255, 255, 0),       // Light yellow
        RGB(  0,   0, 255),     // Light blue
        RGB(255,   0, 255),     // Light purple
        RGB(  0, 255, 255),     // Light aqua
        RGB(255, 255, 255),     // White
};

HBITMAP hbmFont = NULL;
HFONT hDlgFont = NULL;

UINT DefaultCharset;

TCHAR szRegular[CCHSTYLE];
TCHAR szBold[CCHSTYLE];
TCHAR szItalic[CCHSTYLE];
TCHAR szBoldItalic[CCHSTYLE];

TCHAR szPtFormat[] = TEXT("%d");

TCHAR c_szRegular[]    = TEXT("Regular");
TCHAR c_szBold[]       = TEXT("Bold");
TCHAR c_szItalic[]     = TEXT("Italic");
TCHAR c_szBoldItalic[] = TEXT("Bold Italic");

LPCFHOOKPROC glpfnFontHook = 0;

BOOL g_bIsSimplifiedChineseUI = FALSE;




//
//  Context Help IDs.
//

const static DWORD aFontHelpIDs[] =              // Context Help IDs
{
    stc1,    IDH_FONT_FONT,
    cmb1,    IDH_FONT_FONT,
    stc2,    IDH_FONT_STYLE,
    cmb2,    IDH_FONT_STYLE,
    stc3,    IDH_FONT_SIZE,
    cmb3,    IDH_FONT_SIZE,
    psh3,    IDH_COMM_APPLYNOW,
    grp1,    IDH_FONT_EFFECTS,
    chx1,    IDH_FONT_EFFECTS,
    chx2,    IDH_FONT_EFFECTS,
    stc4,    IDH_FONT_COLOR,
    cmb4,    IDH_FONT_COLOR,
    grp2,    IDH_FONT_SAMPLE,
    stc5,    IDH_FONT_SAMPLE,
    stc6,    NO_HELP,
    stc7,    IDH_FONT_SCRIPT,
    cmb5,    IDH_FONT_SCRIPT,

    0, 0
};

//
//  Function Prototypes.
//

#ifdef  MM_DESIGNVECTOR_DEFINED
/* flag used for ChooseFontExA, ChooseFontExW and ChooseFontX : */
   
#define CHF_DESIGNVECTOR  0x0001
/* give the MM result into DESIGNVECTOR,
   default is to convert the axis into the name for backwards compatibility */


/* ChooseFontExA and ChooseFontExW must be called with lpLogFont of size ENUMLOGFONTEXDV */
BOOL APIENTRY ChooseFontExA(LPCHOOSEFONTA, DWORD fl);
BOOL APIENTRY ChooseFontExW(LPCHOOSEFONTW, DWORD fl);
#ifdef UNICODE
#define ChooseFontEx  ChooseFontExW
#else
#define ChooseFontEx  ChooseFontExA
#endif // !UNICODE

#endif //  MM_DESIGNVECTOR_DEFINED

BOOL
ChooseFontX(
#ifdef  MM_DESIGNVECTOR_DEFINED
    PFONTINFO pFI, DWORD fl);
#else
    PFONTINFO pFI);
#endif //  MM_DESIGNVECTOR_DEFINED

VOID
SetStyleSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    BOOL bInit);

#ifdef MM_DESIGNVECTOR_DEFINED
VOID 
SetMMAxesSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf);
#endif // MM_DESIGNVECTOR_DEFINED

VOID
HideDlgItem(
    HWND hDlg,
    int id);

VOID
FixComboHeights(
    HWND hDlg);

BOOL_PTR CALLBACK
FormatCharDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

void
SelectStyleFromLF(
    HWND hwnd,
    LPLOGFONT lplf);

int
CBSetTextFromSel(
    HWND hwnd);

int
CBSetSelFromText(
    HWND hwnd,
    LPTSTR lpszString);

int
CBGetTextAndData(
    HWND hwnd,
    LPTSTR lpszString,
    int iSize,
    PULONG_PTR lpdw);

int
CBFindString(
    HWND hwnd,
    LPTSTR lpszString);

BOOL
GetPointSizeInRange(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPINT pts,
    WORD wFlags);

BOOL
ResetSampleFromScript(
    HWND hdlg,
    HWND hwndScript,
    PFONTINFO pFI);

BOOL ProcessDlgCtrlCommand(HWND hDlg, PFONTINFO pFI, WORD wId, WORD wCmd, HWND hwnd);


int
CmpFontType(
    DWORD ft1,
    DWORD ft2);

int
FontFamilyEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);

BOOL
GetFontFamily(
    HWND hDlg,
    HDC hDC,
    DWORD dwEnumCode,
    UINT iCharset);

VOID
CBAddSize(
    HWND hwnd,
    int pts,
    LPCHOOSEFONT lpcf);

int
InsertStyleSorted(
    HWND hwnd,
    LPTSTR lpszStyle,
    LPLOGFONT lplf);

PLOGFONT
CBAddStyle(
    HWND hwnd,
    LPTSTR lpszStyle,
    DWORD nFontType,
    LPLOGFONT lplf);

int
CBAddScript(
    HWND hwnd,
    LPTSTR lpszScript,
    UINT iCharset);

VOID
FillInMissingStyles(
    HWND hwnd);

VOID
FillScalableSizes(
    HWND hwnd,
    LPCHOOSEFONT lpcf);

int
FontStyleEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);

VOID
FreeFonts(
    HWND hwnd);

VOID
FreeAllItemData(
    HWND hDlg,
    PFONTINFO pFI);

VOID
InitLF(
    LPLOGFONT lplf);

#ifdef MM_DESIGNVECTOR_DEFINED
int
FontMMAxesEnumProc(
    LPENUMLOGFONTEXDV lplf,
    LPENUMTEXTMETRIC lpetm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);
#endif // MM_DESIGNVECTOR_DEFINED

int
FontScriptEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);


BOOL
GetFontStylesAndSizes(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    BOOL bForceSizeFill);

VOID
FillColorCombo(
    HWND hDlg);

BOOL
DrawSizeComboItem(
    LPDRAWITEMSTRUCT lpdis);

BOOL
DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis);

BOOL
DrawColorComboItem(
    LPDRAWITEMSTRUCT lpdis);

VOID
DrawSampleText(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    HDC hDC);

BOOL
FillInFont(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf,
    BOOL bSetBits);

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL
FillInFontEx(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf,
    BOOL bSetBits);

BOOL
SetLogFontEx(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf);

#endif // MM_DESIGNVECTOR_DEFINED

BOOL
SetLogFont(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf);

VOID
TermFont();

int
GetPointString(
    LPTSTR buf,
    HDC hDC,
    int height);

DWORD
FlipColor(
    DWORD rgb);

HBITMAP
LoadBitmaps(
    int id);

BOOL LookUpFontSubs(LPCTSTR lpSubFontName, LPTSTR lpRealFontName);

BOOL GetUnicodeSampleText(HDC hdc, LPTSTR lpString, int nMaxCount);

#ifdef UNICODE
  void
  ThunkChooseFontA2W(
      PFONTINFO pFI);

  void
  ThunkChooseFontW2A(
      PFONTINFO pFI);

#ifdef MM_DESIGNVECTOR_DEFINED
  VOID
  ThunkEnumLogFontExDvA2W(
      LPENUMLOGFONTEXDVA lpLFA,
      LPENUMLOGFONTEXDVW lpLFW);

  VOID
  ThunkEnumLogFontExDvW2A(
      LPENUMLOGFONTEXDVW lpLFW,
      LPENUMLOGFONTEXDVA lpLFA);
#endif // MM_DESIGNVECTOR_DEFINED

  VOID
  ThunkLogFontA2W(
      LPLOGFONTA lpLFA,
      LPLOGFONTW lpLFW);

  VOID
  ThunkLogFontW2A(
      LPLOGFONTW lpLFW,
      LPLOGFONTA lpLFA);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\font.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    font.c

Abstract:

    This module implements the Win32 font dialog.

Revision History:

--*/

// ClaudeBe 10/12/98, to enable Multiple Master Axis selection in the
// font selection dialog, uncomment the following three lines and make sure
// you use the new font.dlg (from \nt\private\ntos\w32\ntgdi\test\fonttest.nt\comdlg32mm)
// as of 10/12/98, this is not a NT 5.0/IE 5.0 feature
// 

// arulk- MM_DESIGNVECTOR is not feature for windows 2000 so dont uncomment the following lines for
// windows 2000
//#ifdef WINNT
//#define  MM_DESIGNVECTOR_DEFINED
//#endif


// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "font.h"
#include "cdids.h"
#include "util.h"

#ifdef MM_DESIGNVECTOR_DEFINED
#define MAX_NUM_AXES  6

VOID GetCannonicalNameW(
    WCHAR        *pwsz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
);

VOID AddDesignVectorToNameW(
    WCHAR        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
);

VOID GetCannonicalNameA(
    char        *pasz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
);

VOID AddDesignVectorToNameA(
    char        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
);

#ifdef UNICODE
#define GetCannonicalName(A,B) GetCannonicalNameW(A,B);
#define AddDesignVectorToName(A,B) AddDesignVectorToNameW(A,B);
#else
#define GetCannonicalName(A,B) GetCannonicalNameA(A,B);
#define AddDesignVectorToName(A,B) AddDesignVectorToNameA(A,B);
#endif // UNICODE

#ifdef UNICODE

#define IS_DIGITW(x)   (((x) >= L'0') && ((x) <= L'9'))
#define GET_DIGITW(X)  ((X) - L'0')
#define WC_UNDERSCORE L'_'

VOID GetCannonicalNameW(
    WCHAR        *pwsz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// modified from GreGetCannonicalName
//
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.
//

    WCHAR *pwc;
    ULONG cAxes = 0;
    ULONG cwc;

    /* if we already have a DESIGNVECTOR information, we don't want to erase it */
    if (pdv->dvNumAxes != 0)
        return;

    for
    (
        pwc = pwsz ;
        (*pwc) && !((*pwc == WC_UNDERSCORE) && IS_DIGITW(pwc[1]));
        pwc++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cwc = (ULONG)(pwc - pwsz);

// If we found at least one WC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pwc == WC_UNDERSCORE) && IS_DIGITW(pwc[1]))
    {
    // step to the next character behind undescore

        pwc++;

        while (*pwc)
        {
        // go until you hit the first digit

            for ( ; *pwc && !IS_DIGITW(*pwc) ; pwc++)
            {
                // do nothing
            }


            if (*pwc)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGITW(*pwc);

            // go until you hit first nondigit or the terminator

                pwc++;

                for ( ; *pwc && IS_DIGITW(*pwc); pwc++)
                {
                    dvValue = dvValue * 10 + GET_DIGITW(*pwc);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;

    /* we do that at the end allowing to pass the same buffer as in and out */
    pwsz[cwc] = L'\0';

}

VOID AddDesignVectorToNameW(
    WCHAR        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
)
{
    if (pdv->dvNumAxes != 0)
    {
        UINT i;
        PWCHAR endOfBaseName;
        WCHAR pszValue[20]; // temp buffer used to convert long to string

        for (i=0; i<pdv->dvNumAxes; i++)
        {
                    _itow(pdv->dvValues[i], pszValue, 10);

                    if ((wcslen(pFaceName) + wcslen(pszValue) + 1) >= (UINT)LF_FACESIZE)
                            return;

            endOfBaseName = pFaceName + wcslen(pFaceName);
                        *endOfBaseName = WC_UNDERSCORE;
                    endOfBaseName++;
                    *endOfBaseName = 0; 
                    wcscat(endOfBaseName, pszValue);
        }

    }

}
#else
#define IS_DIGITA(x)   (((x) >= '0') && ((x) <= '9'))
#define GET_DIGITA(X)  ((X) - '0')
#define AC_UNDERSCORE '_'

VOID GetCannonicalNameA(
    char        *pasz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// modified from GreGetCannonicalName
//
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.
//

    char *pac;
    ULONG cAxes = 0;
    ULONG cac;

    /* if we already have a DESIGNVECTOR information, we don't want to erase it */
    if (pdv->dvNumAxes != 0)
        return;

    for
    (
        pac = pasz ;
        (*pac) && !((*pac == AC_UNDERSCORE) && IS_DIGITA(pac[1]));
        pac++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cac = (ULONG)(pac - pasz);

// If we found at least one AC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pac == AC_UNDERSCORE) && IS_DIGITA(pac[1]))
    {
    // step to the next character behind undescore

        pac++;

        while (*pac)
        {
        // go until you hit the first digit

            for ( ; *pac && !IS_DIGITA(*pac) ; pac++)
            {
                // do nothing
            }


            if (*pac)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGITA(*pac);

            // go until you hit first nondigit or the terminator

                pac++;

                for ( ; *pac && IS_DIGITA(*pac); pac++)
                {
                    dvValue = dvValue * 10 + GET_DIGITA(*pac);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;

    /* we do that at the end allowing to pass the same buffer as in and out */
    pasz[cac] = L'\0';

}

VOID AddDesignVectorToNameA(
    char        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
)
{
    if (pdv->dvNumAxes != 0)
    {
        UINT i;
        char *endOfBaseName;
        char pszValue[20]; // temp buffer used to convert long to string

        for (i=0; i<pdv->dvNumAxes; i++)
        {
                    _itoa(pdv->dvValues[i], pszValue, 10);

                    if ((strlen(pFaceName) + strlen(pszValue) + 1) >= (UINT)LF_FACESIZE)
                            return;

            endOfBaseName = pFaceName + strlen(pFaceName);
                        *endOfBaseName = AC_UNDERSCORE;
                    endOfBaseName++;
                    *endOfBaseName = 0; 
                    strcat(endOfBaseName, pszValue);
        }

    }

}
#endif // UNICODE

#endif // MM_DESIGNVECTOR_DEFINED

BOOL IsSimplifiedChineseUI(void)
{
    BOOL bRet = FALSE;
    
    if (staticIsOS(OS_WIN2000ORGREATER))     // If NT5 or higher, we use system UI Language
    {
        static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

        if (pfnGetUserDefaultUILanguage == NULL)
        {
            HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

            if (hmod)
                pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
        }
        if (pfnGetUserDefaultUILanguage)
        {
            LANGID LangID = pfnGetUserDefaultUILanguage();

            if (LangID == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED))
                bRet = TRUE;
        }
    }    
    else                        // If Win9x and NT4, we use CP_ACP
    {
        if (936 == GetACP())
            bRet = TRUE;
    }

    return bRet;
}

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontA
//
//  ANSI entry point for ChooseFont when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontA(
    LPCHOOSEFONTA pCFA)
{
    BOOL result;

    ENUMLOGFONTEXDVA LogFontDV;
    LPLOGFONTA lpLogFont = NULL;

    if (!pCFA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }


    if (pCFA->lpLogFont)
    {
        /* we ned space in lpLogFont for the DESIGNVECTOR */
        lpLogFont = pCFA->lpLogFont;

        pCFA->lpLogFont = (LPLOGFONTA)&LogFontDV; 

        *pCFA->lpLogFont = *lpLogFont;

        ((LPENUMLOGFONTEXDVA)pCFA->lpLogFont)->elfDesignVector.dvNumAxes = 0;  // set number of axis to zero
        ((LPENUMLOGFONTEXDVA)pCFA->lpLogFont)->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  
    }

    result = ChooseFontExA(pCFA, 0);

    if (lpLogFont)
    {
        /* copy back lpLogFont */

        *lpLogFont = *pCFA->lpLogFont;

        pCFA->lpLogFont = lpLogFont;
    }

    return result;
}
#endif // MM_DESIGNVECTOR_DEFINED

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontExA(
    LPCHOOSEFONTA pCFA, DWORD fl)
#else
BOOL WINAPI ChooseFontA(
    LPCHOOSEFONTA pCFA)
#endif // MM_DESIGNVECTOR_DEFINED
{
    LPCHOOSEFONTW pCFW;
    BOOL result;
    LPBYTE pStrMem;
    UNICODE_STRING usStyle;
    ANSI_STRING asStyle;
    int cchTemplateName = 0;
    FONTINFO FI;

    ZeroMemory(&FI, sizeof(FONTINFO));

    if (!pCFA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCFA->lStructSize != sizeof(CHOOSEFONTA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  Setup and allocate CHOOSEFONTW structure.
    //
    if (!pCFA->lpLogFont && (pCFA->Flags & CF_INITTOLOGFONTSTRUCT))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (!(pCFW = (LPCHOOSEFONTW)LocalAlloc(
                                LPTR,
#ifdef MM_DESIGNVECTOR_DEFINED
                                sizeof(CHOOSEFONTW) + sizeof(ENUMLOGFONTEXDVW) )))
#else
                                sizeof(CHOOSEFONTW) + sizeof(LOGFONTW) )))
#endif // MM_DESIGNVECTOR_DEFINED

    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    pCFW->lStructSize = sizeof(CHOOSEFONTW);

    pCFW->lpLogFont = (LPLOGFONTW)((LPCHOOSEFONTW)pCFW + 1);

    if (pCFA->Flags & CF_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pCFA->lpTemplateName))
        {
            cchTemplateName = (lstrlenA(pCFA->lpTemplateName) + 1) *
                              sizeof(WCHAR);
            if (!(pCFW->lpTemplateName = (LPWSTR)LocalAlloc( LPTR,
                                                             cchTemplateName)))
            {
                LocalFree(pCFW);
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                SHAnsiToUnicode(pCFA->lpTemplateName,(LPWSTR)pCFW->lpTemplateName,cchTemplateName);
            }
        }
        else
        {
            (DWORD_PTR)pCFW->lpTemplateName = (DWORD_PTR)pCFA->lpTemplateName;
        }
    }
    else
    {
        pCFW->lpTemplateName = NULL;
    }

    if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
    {
        asStyle.MaximumLength = LF_FACESIZE;
        asStyle.Length = (USHORT) (lstrlenA(pCFA->lpszStyle));
        if (asStyle.Length >= asStyle.MaximumLength)
        {
            asStyle.MaximumLength = asStyle.Length;
        }
    }
    else
    {
        asStyle.Length = usStyle.Length = 0;
        asStyle.MaximumLength = LF_FACESIZE;
    }
    usStyle.MaximumLength = asStyle.MaximumLength * sizeof(WCHAR);
    usStyle.Length = asStyle.Length * sizeof(WCHAR);

    if (!(pStrMem = (LPBYTE)LocalAlloc( LPTR,
                                        asStyle.MaximumLength +
                                            usStyle.MaximumLength )))
    {
        if (cchTemplateName)
        {
            LocalFree((LPWSTR)(pCFW->lpTemplateName));
        }
        LocalFree(pCFW);
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    asStyle.Buffer = pStrMem;
    pCFW->lpszStyle = usStyle.Buffer =
        (LPWSTR)(asStyle.Buffer + asStyle.MaximumLength);

    if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
    {
        lstrcpyA(asStyle.Buffer, pCFA->lpszStyle);
    }

    FI.pCF = pCFW;
    FI.pCFA = pCFA;
    FI.ApiType = COMDLG_ANSI;
    FI.pasStyle = &asStyle;
    FI.pusStyle = &usStyle;

    ThunkChooseFontA2W(&FI);

#ifdef MM_DESIGNVECTOR_DEFINED
    if (result = ChooseFontX(&FI, fl))
#else
    if (result = ChooseFontX(&FI))
#endif // MM_DESIGNVECTOR_DEFINED
    {
        ThunkChooseFontW2A(&FI);

        //
        //  Doesn't say how many characters there are here.
        //
        if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
        {
            LPSTR psz = pCFA->lpszStyle;
            LPSTR pszT = asStyle.Buffer;

            try
            {
                while (*psz++ = *pszT++);
            }
            except (EXCEPTION_ACCESS_VIOLATION)
            {
                //
                //  Not enough space in the passed in string.
                //
                *--psz = '\0';
            }
        }
    }

    if (cchTemplateName)
    {
        LocalFree((LPWSTR)(pCFW->lpTemplateName));
    }
    LocalFree(pCFW);
    LocalFree(pStrMem);

    return (result);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontW
//
//  Stub UNICODE function for ChooseFont when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseFontW(
   LPCHOOSEFONTW lpCFW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontExW(
   LPCHOOSEFONTW lpCFW, DWORD fl)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}
#endif // MM_DESIGNVECTOR_DEFINED

#endif


////////////////////////////////////////////////////////////////////////////
//
//  ChooseFont
//
//  The ChooseFont function creates a system-defined dialog box from which
//  the user can select a font, a font style (such as bold or italic), a
//  point size, an effect (such as strikeout or underline), and a text
//  color.
//
////////////////////////////////////////////////////////////////////////////

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFont(
   LPCHOOSEFONT lpCF)
{
    BOOL result;

    ENUMLOGFONTEXDV LogFontDV;
    LPLOGFONT lpLogFont = NULL;

    if (!lpCF)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (lpCF->lpLogFont)
    {
        /* we ned space in lpLogFont for the DESIGNVECTOR */
        lpLogFont = lpCF->lpLogFont;

        lpCF->lpLogFont = (LPLOGFONT)&LogFontDV; 

        *lpCF->lpLogFont = *lpLogFont;

        ((LPENUMLOGFONTEXDV)lpCF->lpLogFont)->elfDesignVector.dvNumAxes = 0;  // set number of axis to zero
        ((LPENUMLOGFONTEXDV)lpCF->lpLogFont)->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  
    }

    result = ChooseFontEx(lpCF, 0);


    if (lpLogFont)
    {
        /* copy back lpLogFont */

        *lpLogFont = *lpCF->lpLogFont;

        lpCF->lpLogFont = lpLogFont;
    }

    return result;
}
#endif // MM_DESIGNVECTOR_DEFINED

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontEx(
   LPCHOOSEFONT lpCF, DWORD fl)
#else
BOOL WINAPI ChooseFont(
   LPCHOOSEFONT lpCF)
#endif // MM_DESIGNVECTOR_DEFINED
{
    FONTINFO FI;

    ZeroMemory(&FI, sizeof(FONTINFO));

    FI.pCF = lpCF;
    FI.ApiType = COMDLG_WIDE;

#ifdef MM_DESIGNVECTOR_DEFINED
    return ( ChooseFontX(&FI, fl) );
#else
    return ( ChooseFontX(&FI) );
#endif // MM_DESIGNVECTOR_DEFINED
}


////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontX
//
//  Invokes the font picker dialog, which lets the user specify common
//  character format attributes: facename, point size, text color and
//  attributes (bold, italic, strikeout or underline).
//
//  lpCF    - ptr to structure that will hold character attributes
//  ApiType - api type (COMDLG_WIDE or COMDLG_ANSI) so that the dialog
//            can remember which message to send to the user.
//
//  Returns:   TRUE  - user pressed IDOK
//             FALSE - user pressed IDCANCEL
//
////////////////////////////////////////////////////////////////////////////

BOOL ChooseFontX(
#ifdef MM_DESIGNVECTOR_DEFINED
    PFONTINFO pFI, DWORD fl)
#else
    PFONTINFO pFI)
#endif // MM_DESIGNVECTOR_DEFINED
{
    INT_PTR iRet;                // font picker dialog return value
    HANDLE hDlgTemplate;         // handle to loaded dialog resource
    HANDLE hRes;                 // handle of res. block with dialog
    int id;
    LPCHOOSEFONT lpCF = pFI->pCF;
    BOOL fAllocLogFont = FALSE;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif
    LANGID LangID;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    StoreExtendedError(0);
    g_bUserPressedCancel = FALSE;

    if (!lpCF)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (lpCF->lStructSize != sizeof(CHOOSEFONT))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!lpCF->lpLogFont)
    {
#ifdef MM_DESIGNVECTOR_DEFINED
        if (!(lpCF->lpLogFont = (LPLOGFONT)LocalAlloc(LPTR, sizeof(ENUMLOGFONTEXDV))))
#else
        if (!(lpCF->lpLogFont = (LPLOGFONT)LocalAlloc(LPTR, sizeof(LOGFONT))))
#endif // MM_DESIGNVECTOR_DEFINED
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }

        fAllocLogFont = TRUE;
    } 
#ifdef MM_DESIGNVECTOR_DEFINED
    else 
    {
        GetCannonicalName(lpCF->lpLogFont->lfFaceName, 
            &((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector);
    }

    // GetProcAddress for CreateFontIndirectEx, if this function exist, it's safe
    // to access DESIGNVECTOR information

    
    pFI->pfnCreateFontIndirectEx = NULL;

    if ( (lpCF->Flags & CF_MM_DESIGNVECTOR) &&  
         !(lpCF->Flags & CF_ENABLETEMPLATE) && !(lpCF->Flags & CF_ENABLETEMPLATEHANDLE))
    {
        HINSTANCE hinst = GetModuleHandleA("GDI32.DLL");

        if (hinst)
        {
#ifdef UNICODE
            pFI->pfnCreateFontIndirectEx = (PFNCREATEFONTINDIRECTEX)GetProcAddress(hinst, "CreateFontIndirectExW");
#else
            pFI->pfnCreateFontIndirectEx = (PFNCREATEFONTINDIRECTEX)GetProcAddress(hinst, "CreateFontIndirectExA");
#endif
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED
    //
    //  Get the process version of the app for later use.
    //
    pFI->ProcessVersion = GetProcessVersion(0);

    //
    //  Get the default user language id for later use.
    //
    g_bIsSimplifiedChineseUI = IsSimplifiedChineseUI();


    //
    //  Verify that lpfnHook is not null if CF_ENABLEHOOK is specified.
    //
    if (lpCF->Flags & CF_ENABLEHOOK)
    {
        if (!lpCF->lpfnHook)
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        lpCF->lpfnHook = NULL;
    }

    if (lpCF->Flags & CF_ENABLETEMPLATE)
    {
        //
        //  Both custom instance handle and the dialog template name are
        //  user specified. Locate the dialog resource in the specified
        //  instance block and load it.
        //
        if (!(hRes = FindResource(lpCF->hInstance, lpCF->lpTemplateName, RT_DIALOG)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(lpCF->hInstance, hRes)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
        LangID = GetDialogLanguage(lpCF->hwndOwner, hDlgTemplate);
    }
    else if (lpCF->Flags & CF_ENABLETEMPLATEHANDLE)
    {
        //
        //  A handle to the pre-loaded resource has been specified.
        //
        hDlgTemplate = lpCF->hInstance;
        LangID = GetDialogLanguage(lpCF->hwndOwner, hDlgTemplate);
    }
    else
    {

#ifdef MM_DESIGNVECTOR_DEFINED
        if (!(lpCF->Flags & CF_MM_DESIGNVECTOR))
        {
            id = FORMATDLGORD31;
        }
        else
        {
            id = FONTDLGMMAXES;
        }
#else
        id = FORMATDLGORD31;
#endif
        LangID = GetDialogLanguage(lpCF->hwndOwner, NULL);

        if (!(hRes = FindResourceExFallback(g_hinst, RT_DIALOG, MAKEINTRESOURCE(id), LangID)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) LangID);

    if (LockResource(hDlgTemplate))
    {
        if (lpCF->Flags & CF_ENABLEHOOK)
        {
            glpfnFontHook = GETHOOKFN(lpCF);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(lpCF))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           lpCF->hwndOwner,
                                           FormatCharDlgProc,
                                           (LPARAM)pFI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       lpCF->hwndOwner,
                                       FormatCharDlgProc,
                                       (LPARAM)pFI );
#endif

        glpfnFontHook = 0;

        if (iRet == -1 || ((iRet == 0) && (!g_bUserPressedCancel) && (!GetStoredExtendedError())))
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        iRet = -1;
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    if (fAllocLogFont)
    {
        LocalFree(lpCF->lpLogFont);
        lpCF->lpLogFont = NULL;
    } 
#ifdef MM_DESIGNVECTOR_DEFINED
    else
    {
        if (lpCF->lpLogFont && !(fl & CHF_DESIGNVECTOR))
        {
            UINT i;
            BOOL bDefaultAxis = TRUE;
            if (pFI->DefaultDesignVector.dvNumAxes != ((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector.dvNumAxes)
            {
                bDefaultAxis = FALSE;
            }
            else
            {
                for (i=0; i<pFI->DefaultDesignVector.dvNumAxes; i++)
                {
                    if (pFI->DefaultDesignVector.dvValues[i] != ((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector.dvValues[i])
                    {
                        bDefaultAxis = FALSE;
                    }
                }
            }

            if (!bDefaultAxis)
            {
                AddDesignVectorToName(lpCF->lpLogFont->lfFaceName, 
                    &((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector);
            }
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED

    return (iRet == IDOK);
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  SetMMAxesSelection
//
////////////////////////////////////////////////////////////////////////////

VOID SetMMAxesSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf)
{
    UINT i;
    SCROLLINFO scri;

    if (MAX_NUM_AXES < ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes)
    {
        ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes = 0; // for safety, set NumAxis to zero
//        MessageBox (hDlg, TEXT("Cannot support so many axes"), TEXT("Error"), MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    for (i=0; i<((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes; i++)
    {
            // setting the positions of scroll bars according to MM Axes values
            scri.nPos   = ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvValues[i];
            scri.fMask  = SIF_POS;
            SetScrollInfo(GetDlgItem(hDlg, scr1 + i), SB_CTL, &scri, TRUE);
            SetDlgItemInt ( hDlg, edt1 + i, scri.nPos, TRUE);
    }

}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  SetStyleSelection
//
////////////////////////////////////////////////////////////////////////////

VOID SetStyleSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    BOOL bInit)
{
    if (!(lpcf->Flags & CF_NOSTYLESEL))
    {
        if (bInit && (lpcf->Flags & CF_USESTYLE))
        {
            PLOGFONT plf;
            int iSel;

            iSel = CBSetSelFromText(GetDlgItem(hDlg, cmb2), lpcf->lpszStyle);
            if (iSel >= 0)
            {
                LPITEMDATA lpItemData =
                     (LPITEMDATA)SendDlgItemMessage( hDlg,
                                                     cmb2,
                                                     CB_GETITEMDATA,
                                                     iSel,
                                                     0L );
                if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
                {
                    plf = lpItemData->pLogFont;

                    lpcf->lpLogFont->lfWeight = plf->lfWeight;
                    lpcf->lpLogFont->lfItalic = plf->lfItalic;
                }
                else
                {
                    lpcf->lpLogFont->lfWeight = FW_NORMAL;
                    lpcf->lpLogFont->lfItalic = 0;
                }
            }
            else
            {
                lpcf->lpLogFont->lfWeight = FW_NORMAL;
                lpcf->lpLogFont->lfItalic = 0;
            }
        }
        else
        {
            SelectStyleFromLF(GetDlgItem(hDlg, cmb2), lpcf->lpLogFont);
        }

        CBSetTextFromSel(GetDlgItem(hDlg, cmb2));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HideDlgItem
//
////////////////////////////////////////////////////////////////////////////

VOID HideDlgItem(
    HWND hDlg,
    int id)
{
    EnableWindow(GetDlgItem(hDlg, id), FALSE);
    ShowWindow(GetDlgItem(hDlg, id), SW_HIDE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FixComboHeights
//
//  Fixes the ownerdraw combo boxes to match the height of the non
//  ownerdraw combo boxes.
//
////////////////////////////////////////////////////////////////////////////

VOID FixComboHeights(
    HWND hDlg)
{
    LPARAM height;

    height = SendDlgItemMessage(hDlg, cmb2, CB_GETITEMHEIGHT, (WPARAM)-1, 0L);
    SendDlgItemMessage(hDlg, cmb1, CB_SETITEMHEIGHT, (WPARAM)-1, height);
    SendDlgItemMessage(hDlg, cmb3, CB_SETITEMHEIGHT, (WPARAM)-1, height);
}

BOOL_PTR HandleFontDlgInitialize(FONTINFO *pFI, HWND hDlg, WPARAM wParam)
{
    TCHAR szPoints[20];
    HDC hdc;
    HWND hWndHelp;                // handle to Help... pushbutton
    LPCHOOSEFONT pCF;

    if (!CDLoadString(g_hinst, iszRegular, (LPTSTR)szRegular, CCHSTYLE) ||
        !CDLoadString(g_hinst, iszBold, (LPTSTR)szBold, CCHSTYLE)       ||
        !CDLoadString(g_hinst, iszItalic, (LPTSTR)szItalic, CCHSTYLE)   ||
        !CDLoadString(g_hinst, iszBoldItalic, (LPTSTR)szBoldItalic, CCHSTYLE))
    {
        StoreExtendedError(CDERR_LOADSTRFAILURE);
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    pCF = pFI->pCF;
    if ((pCF->Flags & CF_LIMITSIZE) &&
        (pCF->nSizeMax < pCF->nSizeMin))
    {
        StoreExtendedError(CFERR_MAXLESSTHANMIN);
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    //
    //  Save ptr to CHOOSEFONT struct in the dialog's prop list.
    //  Alloc a temp LOGFONT struct to be used for the length of
    //  the dialog session, the contents of which will be copied
    //  over to the final LOGFONT (pointed to by CHOOSEFONT)
    //  only if <OK> is selected.
    //
    SetProp(hDlg, FONTPROP, (HANDLE)pFI);
    glpfnFontHook = 0;

    hDlgFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);

    if (!hbmFont)
    {
        hbmFont = LoadBitmaps(BMFONT);
    }

    if (!(pCF->Flags & CF_APPLY))
    {
        HideDlgItem(hDlg, psh3);
    }

    if (!(pCF->Flags & CF_EFFECTS))
    {
        HideDlgItem(hDlg, stc4);
        HideDlgItem(hDlg, cmb4);
    }
    else
    {
        short nIndex;

        //  Fill color list.
        FillColorCombo(hDlg);
        for (nIndex = CCHCOLORS - 1; nIndex > 0; nIndex--)
        {
            DWORD dw = (DWORD) SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, nIndex, 0);
            if (pCF->rgbColors == dw)
            {
                break;
            }
        }
        SendDlgItemMessage(hDlg, cmb4, CB_SETCURSEL, nIndex, 0);
    }

    GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
    MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
    FixComboHeights(hDlg);

    //  Init our LOGFONT.
    if (!(pCF->Flags & CF_INITTOLOGFONTSTRUCT))
    {
        InitLF(pCF->lpLogFont);
    }

    //  Init effects.
    if (!(pCF->Flags & CF_EFFECTS))
    {
        HideDlgItem(hDlg, grp1);
        HideDlgItem(hDlg, chx1);
        HideDlgItem(hDlg, chx2);
    }
    else
    {
        CheckDlgButton(hDlg, chx1, pCF->lpLogFont->lfStrikeOut);
        CheckDlgButton(hDlg, chx2, pCF->lpLogFont->lfUnderline);
    }

    pFI->nLastFontType = 0;

    if (!GetFontFamily( hDlg,
                        pCF->hDC,
                        pCF->Flags,
                        pCF->lpLogFont->lfCharSet ))
    {
        StoreExtendedError(CFERR_NOFONTS);
        if (pCF->Flags & CF_ENABLEHOOK)
        {
            glpfnFontHook = GETHOOKFN(pCF);
        }
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    if (!(pCF->Flags & CF_NOFACESEL) && *pCF->lpLogFont->lfFaceName)
    {
        BOOL bContinueChecking;
        LPTSTR lpRealFontName, lpSubFontName;

        //  We want to select the font the user has requested.
        int iResult = CBSetSelFromText(GetDlgItem(hDlg, cmb1), pCF->lpLogFont->lfFaceName);

        //  If iResult == CB_ERR, then we could be working with a
        //  font subsitution name (eg: MS Shell Dlg).
        if (iResult == CB_ERR)
        {
            lpSubFontName = pCF->lpLogFont->lfFaceName;
        }

        //  Allocate a buffer to store the real font name in.
        lpRealFontName = GlobalAlloc(GPTR, MAX_PATH * sizeof(TCHAR));

        if (!lpRealFontName)
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            EndDialog(hDlg, FALSE);
            return (FALSE);
        }

        //  The while loop is necessary in order to resolve
        //  substitions pointing to subsitutions.
        //     eg:  Helv->MS Shell Dlg->MS Sans Serif
        bContinueChecking = TRUE;
        while ((iResult == CB_ERR) && bContinueChecking)
        {
            bContinueChecking = LookUpFontSubs(lpSubFontName, lpRealFontName);

            //  If bContinueChecking is TRUE, then we have a font
            //  name.  Try to select that in the list.
            if (bContinueChecking)
            {
                iResult = CBSetSelFromText(GetDlgItem(hDlg, cmb1), lpRealFontName );
            }

            lpSubFontName = lpRealFontName;
        }

        //
        //  Free our buffer.
        //
        GlobalFree(lpRealFontName);

        //
        //  Set the edit control text if appropriate.
        //
        if (iResult != CB_ERR)
        {
            CBSetTextFromSel(GetDlgItem(hDlg, cmb1));
        }
    }

    hdc = GetDC(NULL);

    if (pCF->Flags & CF_NOSCRIPTSEL)
    {
        hWndHelp = GetDlgItem(hDlg, cmb5);
        if (hWndHelp)
        {
            CDLoadString( g_hinst,
                        iszNoScript,
                        szPoints,
                        ARRAYSIZE(szPoints));
            CBAddScript(hWndHelp, szPoints, DEFAULT_CHARSET);
            EnableWindow(hWndHelp, FALSE);
        }
        DefaultCharset = DEFAULT_CHARSET;
        pFI->iCharset = DEFAULT_CHARSET;
    }
    else if (pCF->Flags & (CF_SELECTSCRIPT | CF_INITTOLOGFONTSTRUCT))
    {
        //
        //  We could come in here with a bogus value, if the app is
        //  NOT 4.0, that would result in the bogus charset not
        //  being found for the facename, and the default would be
        //  put back again anyway.
        //
        pFI->iCharset = pCF->lpLogFont->lfCharSet;
    }
    else
    {
        DefaultCharset = GetTextCharset(hdc);
        pFI->iCharset = DefaultCharset;
    }

    GetFontStylesAndSizes(hDlg, pFI, pCF, TRUE);

    if (!(pCF->Flags & CF_NOSTYLESEL))
    {
        SetStyleSelection(hDlg, pCF, TRUE);
    }

    if (!(pCF->Flags & CF_NOSIZESEL) && pCF->lpLogFont->lfHeight)
    {
        GetPointString(szPoints, hdc, pCF->lpLogFont->lfHeight);
        CBSetSelFromText(GetDlgItem(hDlg, cmb3), szPoints);
        SetDlgItemText(hDlg, cmb3, szPoints);
    }

#ifdef MM_DESIGNVECTOR_DEFINED
    SetMMAxesSelection(hDlg, pCF);
#endif // MM_DESIGNVECTOR_DEFINED

    ReleaseDC(NULL, hdc);

    //
    //  Hide the help button if it isn't needed.
    //
    if (!(pCF->Flags & CF_SHOWHELP))
    {
        ShowWindow(hWndHelp = GetDlgItem(hDlg, pshHelp), SW_HIDE);
        EnableWindow(hWndHelp, FALSE);
    }

    SendDlgItemMessage(hDlg, cmb1, CB_LIMITTEXT, LF_FACESIZE - 1, 0L);
    SendDlgItemMessage(hDlg, cmb2, CB_LIMITTEXT, LF_FACESIZE - 1, 0L);
    SendDlgItemMessage(hDlg, cmb3, CB_LIMITTEXT, 5, 0L);

    //
    //  If hook function has been specified, let it do any additional
    //  processing of this message.
    //
    if (pCF->lpfnHook)
    {
        BOOL_PTR bRet;
        LPCFHOOKPROC lpfnHook = GETHOOKFN(pCF);
#ifdef UNICODE
        if (pFI->ApiType == COMDLG_ANSI)
        {
            ThunkChooseFontW2A(pFI);
            bRet = (*lpfnHook)(hDlg, WM_INITDIALOG, wParam, (LPARAM)pFI->pCFA);
            ThunkChooseFontA2W(pFI);
        }
        else
#endif
        {
            bRet = (*lpfnHook)(hDlg, WM_INITDIALOG, wParam, (LPARAM)pCF);
        }
        return (bRet);
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return TRUE;

}


////////////////////////////////////////////////////////////////////////////
//
//  FormatCharDlgProc
//
//  Message handler for font dlg
//
//  chx1 - "underline" checkbox
//  chx2 - "strikeout" checkbox
//  psh4 - "help" pushbutton
//
//  On WM_INITDIALOG message, the choosefont is accessed via lParam,
//  and stored in the window's prop list.  If a hook function has been
//  specified, it is invoked AFTER the current function has processed
//  WM_INITDIALOG.
//
//  For all other messages, control is passed directly to the hook
//  function first.  Depending on the latter's return value, the message
//  is processed by this function.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FormatCharDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PFONTINFO pFI;
    LPCHOOSEFONT pCF = NULL;      // ptr to struct passed to ChooseFont()
    BOOL_PTR bRet;

#ifdef MM_DESIGNVECTOR_DEFINED
    int i, nCode, nPos, oldPos;
    HWND hwndScr;
#endif // MM_DESIGNVECTOR_DEFINED

    //
    //  If CHOOSEFONT struct has already been accessed and if a hook
    //  function is specified, let it do the processing first.
    //
    if (pFI = (PFONTINFO)GetProp(hDlg, FONTPROP))
    {
        if ((pCF = (LPCHOOSEFONT)pFI->pCF) &&
            (pCF->lpfnHook))
        {
            LPCFHOOKPROC lpfnHook = GETHOOKFN(pCF);

            if ((bRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam)))
            {
                if ((wMsg == WM_COMMAND) &&
                    (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL))
                {
                    //
                    //  Set global flag stating that the user pressed cancel.
                    //
                    g_bUserPressedCancel = TRUE;
                }
                return (bRet);
            }
        }
    }
    else
    {
        if (glpfnFontHook &&
            (wMsg != WM_INITDIALOG) &&
            (bRet = (* glpfnFontHook)(hDlg, wMsg, wParam, lParam)))
        {
            return (bRet);
        }
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            return HandleFontDlgInitialize((PFONTINFO)lParam, hDlg, wParam);
        }
        case ( WM_DESTROY ) :
        {
            if (pCF)
            {
                RemoveProp(hDlg, FONTPROP);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            PAINTSTRUCT ps;
            
            if (!pFI)
            {
                return (FALSE);
            }

            if (BeginPaint(hDlg, &ps))
            {
                DrawSampleText(hDlg, pFI, pCF, ps.hdc);
                EndPaint(hDlg, &ps);
            }
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            TEXTMETRIC tm;

            HDC hDC = GetDC(hDlg);
            HFONT hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(hDlg, hDC);

            if (((LPMEASUREITEMSTRUCT)lParam)->itemID != -1)
            {
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight =
                       max(tm.tmHeight, DY_BITMAP);
            }
            else
            {
                //
                //  This is for 3.0 only.  In 3.1, the CB_SETITEMHEIGHT
                //  will fix this.  Note, this is off by one on 8514.
                //
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = tm.tmHeight + 1;
            }

            break;
        }
        case ( WM_DRAWITEM ) :
        {
#define lpdis ((LPDRAWITEMSTRUCT)lParam)

            if (lpdis->itemID == (UINT)-1)
            {
                break;
            }

            if (lpdis->CtlID == cmb4)
            {
                DrawColorComboItem(lpdis);
            }
            else if (lpdis->CtlID == cmb1)
            {
                DrawFamilyComboItem(lpdis);
            }
            else
            {
                DrawSizeComboItem(lpdis);
            }
            break;

#undef lpdis
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            DeleteObject(hbmFont);
            hbmFont = LoadBitmaps(BMFONT);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pFI)
            {
                return (FALSE);
            }

            return (ProcessDlgCtrlCommand(hDlg, pFI, 
                GET_WM_COMMAND_ID(wParam, lParam),
                GET_WM_COMMAND_CMD(wParam, lParam),
                GET_WM_COMMAND_HWND(wParam, lParam)));
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPVOID)aFontHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFontHelpIDs );
            }
            break;
        }
        case ( WM_CHOOSEFONT_GETLOGFONT ) :
        {
Handle_WM_CHOOSEFONT_GETLOGFONT:
            if (!pFI)
            {
                return (FALSE);
            }

#ifdef UNICODE
            if (pFI->ApiType == COMDLG_ANSI)
            {
                BOOL bRet;
                LOGFONT lf;

                bRet = FillInFont(hDlg, pFI, pCF, &lf, TRUE);

                ThunkLogFontW2A(&lf, (LPLOGFONTA)lParam);

                return (bRet);
            }
            else
#endif
            {
                return (FillInFont(hDlg, pFI, pCF, (LPLOGFONT)lParam, TRUE));
            }
        }
        case ( WM_CHOOSEFONT_SETLOGFONT ) :
        {
            if (!pFI)
            {
                return (FALSE);
            }

#ifdef UNICODE
            if (pFI->ApiType == COMDLG_ANSI)
            {
                LOGFONT lf;

                ThunkLogFontA2W((LPLOGFONTA)lParam, &lf);

                return (SetLogFont(hDlg, pCF, &lf));
            }
            else
#endif
            {
                return (SetLogFont(hDlg, pCF, (LPLOGFONT)lParam));
            }
            break;
        }

        case ( WM_CHOOSEFONT_SETFLAGS ) :
        {
            if (pCF)
            {
                DWORD dwFlags = pCF->Flags;

                pCF->Flags = (DWORD) lParam;
                SetDlgMsgResult(hDlg, WM_CHOOSEFONT_SETFLAGS, dwFlags);
            }
            return (TRUE);
        }
#ifdef MM_DESIGNVECTOR_DEFINED
        case ( WM_HSCROLL ) :
        {
             nCode = (int) LOWORD(wParam);  // scroll bar value 
             nPos = (short int) HIWORD(wParam);   // scroll box position 
             hwndScr = (HWND) lParam;       // handle to scroll bar               

             i = 0;
             while ((GetDlgItem(hDlg, scr1 + i) != hwndScr) && (i < MAX_NUM_AXES))
                 i++;
             if (i >= MAX_NUM_AXES)
                 return (FALSE);

             if (nCode == SB_THUMBPOSITION)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, nPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, nPos, (LPARAM)TRUE);

                 // redraw sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }

             if (nCode == SB_THUMBTRACK)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, nPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, nPos, (LPARAM)TRUE);

                 // redraw sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }

             oldPos = (int)SendMessage(hwndScr, SBM_GETPOS, 0, 0);
             if (nCode == SB_LINELEFT)
                 oldPos -= 1;
             if (nCode == SB_LINERIGHT)
                 oldPos += 1;
             if (nCode == SB_PAGELEFT)
                 oldPos -= 10;
             if (nCode == SB_PAGERIGHT)
                 oldPos += 10;
             if (nCode == SB_LINELEFT || nCode == SB_LINERIGHT || nCode == SB_PAGELEFT || nCode == SB_PAGERIGHT)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, oldPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, oldPos, (LPARAM)TRUE);

                 // redraw the sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }
             return (TRUE);
        }
#endif // MM_DESIGNVECTOR_DEFINED
        default :
        {
            if (wMsg == msgWOWCHOOSEFONT_GETLOGFONT)
            {
                goto Handle_WM_CHOOSEFONT_GETLOGFONT;
            }
            return (FALSE);
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectStyleFromLF
//
//  Given a logfont, selects the closest match in the style list.
//
////////////////////////////////////////////////////////////////////////////

void SelectStyleFromLF(
    HWND hwnd,
    LPLOGFONT lplf)
{
    int ctr, count, iSel;
    PLOGFONT plf;
    int weight_delta, best_weight_delta = 1000;
    BOOL bIgnoreItalic;
    LPITEMDATA lpItemData;


    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    iSel = 0;
    bIgnoreItalic = FALSE;

TryAgain:
    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);

        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;

            if (bIgnoreItalic ||
                (plf->lfItalic && lplf->lfItalic) ||
                (!plf->lfItalic && !lplf->lfItalic))
            {
                weight_delta = lplf->lfWeight - plf->lfWeight;
                if (weight_delta < 0)
                {
                    weight_delta = -weight_delta;
                }

                if (weight_delta < best_weight_delta)
                {
                    best_weight_delta = weight_delta;
                    iSel = ctr;
                }
            }
        }
    }
    if (!bIgnoreItalic && iSel == 0)
    {
        bIgnoreItalic = TRUE;
        goto TryAgain;
    }

    SendMessage(hwnd, CB_SETCURSEL, iSel, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBSetTextFromSel
//
//  Makes the currently selected item the edit text for a combo box.
//
////////////////////////////////////////////////////////////////////////////

int CBSetTextFromSel(
    HWND hwnd)
{
    int iSel;
    TCHAR szFace[LF_FACESIZE];

    iSel = (int)SendMessage(hwnd, CB_GETCURSEL, 0, 0L);
    if (iSel >= 0)
    {
        SendMessage(hwnd, CB_GETLBTEXT, iSel, (LONG_PTR)(LPTSTR)szFace);
        SetWindowText(hwnd, szFace);
    }
    return (iSel);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBSetSelFromText
//
//  Sets the selection based on lpszString.  Sends notification messages
//  if bNotify is TRUE.
//
////////////////////////////////////////////////////////////////////////////

int CBSetSelFromText(
    HWND hwnd,
    LPTSTR lpszString)
{
    int iInd;

    iInd = CBFindString(hwnd, lpszString);

    if (iInd >= 0)
    {
        SendMessage(hwnd, CB_SETCURSEL, iInd, 0L);
    }
    return (iInd);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBGetTextAndData
//
//  Returns the text and item data for a combo box based on the current
//  edit text.  If the current edit text does not match anything in the
//  listbox, then CB_ERR is returned.
//
////////////////////////////////////////////////////////////////////////////

int CBGetTextAndData(
    HWND hwnd,
    LPTSTR lpszString,
    int iSize,
    PULONG_PTR lpdw)
{
    LRESULT Result;
    int iSel;

    if (lpszString == NULL)
    {
        if ((Result = SendMessage(hwnd, CB_GETITEMDATA, 0, 0L)) < 0)
        {
            return ((int) Result);
        }
        else
        {
            *lpdw = Result;
            return (0);
        }
    }

    GetWindowText(hwnd, lpszString, iSize);
    iSel = CBFindString(hwnd, lpszString);
    if (iSel < 0)
    {
        return (iSel);
    }

    *lpdw = SendMessage(hwnd, CB_GETITEMDATA, iSel, 0L);
    return (iSel);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBFindString
//
//  Does an exact string find and returns the index.
//
////////////////////////////////////////////////////////////////////////////

int CBFindString(
    HWND hwnd,
    LPTSTR lpszString)
{
    return ((int)SendMessage( hwnd,
                              CB_FINDSTRINGEXACT,
                              (WPARAM)-1,
                              (LPARAM)(LPCSTR)lpszString ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPointSizeInRange
//
//  Ensures that the point size edit field is in range.
//
//  Returns:  Point Size - of the edit field limitted by MIN/MAX size
//            0          - if the field is empty
//
////////////////////////////////////////////////////////////////////////////

#define GPS_COMPLAIN    0x0001
#define GPS_SETDEFSIZE  0x0002

BOOL GetPointSizeInRange(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPINT pts,
    WORD wFlags)
{
    TCHAR szBuffer[90];
    TCHAR szTitle[90];
    int nTmp;
    int nTmpFr = 0;
    BOOL bOK;

    *pts = 0;

    if (GetDlgItemText(hDlg, cmb3, szBuffer, sizeof(szBuffer) / sizeof(TCHAR)))
    {
        nTmp = GetDlgItemInt(hDlg, cmb3, &bOK, TRUE);

        if (!bOK && g_bIsSimplifiedChineseUI)
        {
            int ctr;
            LPTSTR lpsz = szBuffer;

            //
            //  Skip leading white space.
            //
            while (*lpsz == TEXT(' '))
            {
                lpsz++;
            }
            for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
            {
                if (!lstrcmpi(lpsz, stZihao[ctr].name))
                {
                    bOK = TRUE;
                    nTmp = stZihao[ctr].size;
                    nTmpFr = stZihao[ctr].sizeFr;
                    break;
                }
            }
        }

        if (!bOK)
        {
            nTmp = 0;
        }
    }
    else if (wFlags & GPS_SETDEFSIZE)
    {
        nTmp = DEF_POINT_SIZE;
        bOK = TRUE;
    }
    else
    {
        //
        //  We're just returning with 0 in *pts.
        //
        return (FALSE);
    }

    //
    //  Check that we got a number in range.
    //
    if (wFlags & GPS_COMPLAIN)
    {
        if ((lpcf->Flags & CF_LIMITSIZE) &&
            (!bOK || (nTmp > lpcf->nSizeMax) || (nTmp < lpcf->nSizeMin)))
        {
            bOK = FALSE;
            CDLoadString( g_hinst,
                        iszSizeRange,
                        szTitle,
                        sizeof(szTitle) / sizeof(TCHAR) );

            wsprintf( (LPTSTR)szBuffer,
                      (LPTSTR)szTitle,
                      lpcf->nSizeMin,
                      lpcf->nSizeMax );
        }
        else if (!bOK)
        {
            CDLoadString( g_hinst,
                        iszSizeNumber,
                        szBuffer,
                        sizeof(szBuffer) / sizeof(TCHAR) );
        }

        if (!bOK)
        {
            GetWindowText(hDlg, szTitle, sizeof(szTitle) / sizeof(TCHAR));
            MessageBox(hDlg, szBuffer, szTitle, MB_OK | MB_ICONINFORMATION);
            return (FALSE);
        }
    }

    *pts = nTmp * 10 + nTmpFr;
    return (TRUE);
}

const struct {
    int         nCharSet;
    UINT        uCodePage;
} g_CharSetTransTable[] = 
{
    ANSI_CHARSET,        1252,
    EASTEUROPE_CHARSET,  1250,
    RUSSIAN_CHARSET,     1251,
    GREEK_CHARSET,       1253,
    TURKISH_CHARSET,     1254,
    HEBREW_CHARSET,      1255,
    ARABIC_CHARSET,      1256,
    BALTIC_CHARSET,      1257,
    VIETNAMESE_CHARSET,  1258,
    THAI_CHARSET,         874,
    SHIFTJIS_CHARSET,     932,
    GB2312_CHARSET,       936,
    HANGEUL_CHARSET,      949, 
    CHINESEBIG5_CHARSET,  950, 
    JOHAB_CHARSET,       1361, 
    DEFAULT_CHARSET,        0,
};

UINT CharsetToCodepage(int iCharset)
{
    int i;
    for (i=0;i<ARRAYSIZE(g_CharSetTransTable);i++)
        if (iCharset == g_CharSetTransTable[i].nCharSet)
            return g_CharSetTransTable[i].uCodePage;

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  ResetSampleFromScript
//
////////////////////////////////////////////////////////////////////////////

BOOL ResetSampleFromScript(HWND hDlg, HWND hwndScript, PFONTINFO pFI)
{
    int iSel;
    TCHAR szScript[LF_FACESIZE];
    LPITEMDATA lpItemData;

    if (IsWindow(hwndScript) && IsWindowEnabled(hwndScript))
    {
        iSel = (int)SendMessage(hwndScript, CB_GETCURSEL, 0, 0L);
        if (iSel >= 0)
        {
            lpItemData = (LPITEMDATA)SendMessage( hwndScript,
                                                  CB_GETITEMDATA,
                                                  iSel,
                                                  0L );
            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
            {
                pFI->iCharset = lpItemData->nFontType;
            }
        }
    }

    if (!CDLoadStringEx(CharsetToCodepage(pFI->iCharset), g_hinst, 
            pFI->iCharset+iszFontSample, szScript, ARRAYSIZE(szScript)))
    {
        return (FALSE);
    }

    SetDlgItemText(hDlg, stc5, szScript);

    return (TRUE);
}

BOOL DoKoreanHack(HWND hwnd)
{
    // HACK: This is only for Korean input. Because Korean Edit control has
    //       level 3 implementation for DBCS input, we may have a problem if 
    //       focus is moving like below with interim character.
    //       0xE0000412 is Korean IME layout id.
    if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
    {
        HIMC hIMC = ImmGetContext(hwnd);
        LONG cb = ImmGetCompositionString(hIMC, GCS_COMPSTR, NULL, 0);
        ImmReleaseContext(hwnd, hIMC);
        if (cb > 0)
            return TRUE;
    }
    return FALSE;

}

////////////////////////////////////////////////////////////////////////////
//
//  ProcessDlgCtrlCommand
//
//  Handles all WM_COMMAND messages for the font dialog.
//
//  cmb1 - ID of font facename combobox
//  cmb2 - style
//  cmb3 - size
//  chx1 - "Underline" checkbox
//  chx2 - "Strikeout" checkbox
//  stc5 - frame around text preview area
//  psh4 - button that invokes the Help application
//  IDOK - OK button to end dialog, retaining information
//  IDCANCEL - button to cancel dialog, not doing anything
//
//  Returns:   TRUE    - if message is processed successfully
//             FALSE   - otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL ProcessDlgCtrlCommand(HWND hDlg, PFONTINFO pFI, WORD wId, WORD wCmd, HWND hwnd)
{
    int iSel;
    LPCHOOSEFONT pCF = (pFI ? pFI->pCF : NULL);
    TCHAR szStyle[LF_FACESIZE];
    LPITEMDATA lpItemData;

    if (pCF)
    {
        switch (wId)
        {
            case ( IDABORT ) :
            {
                //
                //  This is how a hook can cause the dialog to go away.
                //
                FreeAllItemData(hDlg, pFI);
                if (pCF->Flags & CF_ENABLEHOOK)
                {
                    glpfnFontHook = GETHOOKFN(pCF);
                }
                
                // FEATURE: ARULK Why are we returning an HWND anyway?  
                // The caller (ChooseFontX) expects us to return a BOOL

                EndDialog(hDlg, BOOLFROMPTR(hwnd));
                break;
            }
            case ( IDOK ) :
            {
                WORD wCmbId;

                //  Make sure the focus is set to the OK button.  Must do
                //  this so that when the user presses Enter from one of
                //  the combo boxes, the kill focus processing is done
                //  before the data is captured.
                SetFocus(GetDlgItem(hDlg, IDOK));

                if (!GetPointSizeInRange(hDlg, pCF, &iSel, GPS_COMPLAIN | GPS_SETDEFSIZE ))
                {
                    PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, cmb3), 1L);
                    break;
                }
                pCF->iPointSize = iSel;

#ifdef MM_DESIGNVECTOR_DEFINED
                FillInFontEx(hDlg, pFI, pCF, (LPENUMLOGFONTEXDV)pCF->lpLogFont, TRUE);
#else
                FillInFont(hDlg, pFI, pCF, pCF->lpLogFont, TRUE);
#endif // MM_DESIGNVECTOR_DEFINED

                if (pCF->Flags & CF_FORCEFONTEXIST)
                {
                    if (pCF->Flags & CF_NOFACESEL)
                    {
                        wCmbId = cmb1;
                    }
                    else if (pCF->Flags & CF_NOSTYLESEL)
                    {
                        wCmbId = cmb2;
                    }
                    else
                    {
                        wCmbId = 0;
                    }

                    //  Error found.
                    if (wCmbId)
                    {
                        TCHAR szMsg[160], szTitle[160];

                        CDLoadString(g_hinst,
                                    (wCmbId == cmb1) ? iszNoFaceSel: iszNoStyleSel,
                                    szMsg, ARRAYSIZE(szMsg));

                        GetWindowText(hDlg, szTitle, ARRAYSIZE(szTitle));
                        MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_ICONINFORMATION );
                        PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, wCmbId), 1);
                        break;
                    }
                }

                if (pCF->Flags & CF_EFFECTS)
                {
                    //
                    //  Get currently selected item in color combo box and
                    //  the 32 bit color rgb value associated with it.
                    //
                    iSel = (int)SendDlgItemMessage(hDlg, cmb4, CB_GETCURSEL, 0, 0);
                    pCF->rgbColors = (DWORD) SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, iSel, 0);
                }

                //
                //  Get a valid nFontType.
                //
                iSel = CBGetTextAndData(GetDlgItem(hDlg, cmb2), szStyle, ARRAYSIZE(szStyle), (PULONG_PTR)&lpItemData );
                if (iSel < 0)
                {
                    lpItemData = 0;
                    iSel = CBGetTextAndData(GetDlgItem(hDlg, cmb2), (LPTSTR)NULL, 0, (PULONG_PTR)&lpItemData);
                }

                if (iSel >= 0 && lpItemData)
                {
                    pCF->nFontType = (WORD)lpItemData->nFontType;
                }
                else
                {
                    pCF->nFontType = 0;
                }

                if (pCF->Flags & CF_USESTYLE)
                {
                    lstrcpy(pCF->lpszStyle, szStyle);
                }

                goto LeaveDialog;
            }
            case ( IDCANCEL ) :
            {
                g_bUserPressedCancel = TRUE;

LeaveDialog:
                FreeAllItemData(hDlg, pFI);
                if (pCF->Flags & CF_ENABLEHOOK)
                {
                    glpfnFontHook = GETHOOKFN(pCF);
                }
                EndDialog(hDlg, wId == IDOK);
                break;
            }
            case ( cmb1 ) :                 // facenames combobox
            {
                switch (wCmd)
                {
                    case ( CBN_SELCHANGE ) :
                    {
                        TCHAR szPoints[10];

                        CBSetTextFromSel(hwnd);
FillStyles:
                        //
                        //  Try to maintain the current point size and style.
                        //
                        GetDlgItemText( hDlg, cmb3, szPoints, ARRAYSIZE(szPoints));
                        GetFontStylesAndSizes(hDlg, pFI, pCF, FALSE);
                        SetStyleSelection(hDlg, pCF, FALSE);

                        //
                        //  Preserve the point size selection or put it in
                        //  the edit control if it is not in the list for
                        //  this font.
                        //
                        iSel = CBFindString(GetDlgItem(hDlg, cmb3), szPoints);
                        if (iSel < 0)
                        {
                            SetDlgItemText(hDlg, cmb3, szPoints);
                        }
                        else
                        {
                            SendDlgItemMessage(hDlg, cmb3, CB_SETCURSEL, iSel, 0);
                        }

                        goto DrawSample;
                        break;
                    }
                    case ( CBN_EDITUPDATE ) :
                    {
                        PostMessage( hDlg,
                                     WM_COMMAND,
                                     GET_WM_COMMAND_MPS(wId, hwnd, CBN_MYEDITUPDATE));
                        break;
                    }
                    case ( CBN_MYEDITUPDATE ) :
                    {
                        GetWindowText(hwnd, szStyle, ARRAYSIZE(szStyle));
                        iSel = CBFindString(hwnd, szStyle);
                        if (iSel >= 0)
                        {
                            if (DoKoreanHack(hwnd))
                                break;

                            SendMessage(hwnd, CB_SETCURSEL, (WPARAM)iSel, 0);
                            SendMessage(hwnd, CB_SETEDITSEL, 0, 0x0000FFFF);
                            goto FillStyles;
                        }
                        break;
                    }
                }
                break;
            }
            case ( cmb2 ) :                 // styles combobox
            case ( cmb3 ) :                 // point sizes combobox
            {
                switch (wCmd)
                {
                    case ( CBN_EDITUPDATE ) :
                    {
                        PostMessage( hDlg,
                                     WM_COMMAND,
                                     GET_WM_COMMAND_MPS(wId,hwnd,CBN_MYEDITUPDATE) );
                        break;
                    }
                    case ( CBN_MYEDITUPDATE ) :
                    {
                        GetWindowText(hwnd, szStyle, ARRAYSIZE(szStyle));
                        iSel = CBFindString(hwnd, szStyle);
                        if (iSel >= 0)
                        {
                            if (DoKoreanHack(hwnd))
                                break;

                            SendMessage(hwnd, CB_SETCURSEL, iSel, 0);
                            SendMessage(hwnd, CB_SETEDITSEL, 0, 0x0000FFFF);
                            goto DrawSample;
                        }
                        break;
                    }
                    case ( CBN_SELCHANGE ) :
                    {
                        iSel = CBSetTextFromSel(hwnd);

                        //
                        //  Make the style selection stick.
                        //
                        if ((iSel >= 0) && (wId == cmb2))
                        {
                            LPITEMDATA lpItemData;
                            PLOGFONT plf;

                            lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, iSel, 0);

                            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
                            {
                                plf = lpItemData->pLogFont;
                                pCF->lpLogFont->lfWeight = plf->lfWeight;
                                pCF->lpLogFont->lfItalic = plf->lfItalic;
                            }
                            else
                            {
                                pCF->lpLogFont->lfWeight = FW_NORMAL;
                                pCF->lpLogFont->lfItalic = 0;
                            }
                        }

                        goto DrawSample;
                    }
                    case ( CBN_KILLFOCUS ) :
                    {
DrawSample:
#ifdef UNICODE
                        if (pFI->ApiType == COMDLG_ANSI)
                        {
                            //
                            //  Send special WOW message to indicate the
                            //  font style has changed.
                            //
                            LOGFONT lf;

                            if (FillInFont(hDlg, pFI, pCF, &lf, TRUE))
                            {
                                memcpy(pCF->lpLogFont, &lf, sizeof(LOGFONT));
                                ThunkLogFontW2A(pCF->lpLogFont, pFI->pCFA->lpLogFont);
                                SendMessage(hDlg, msgWOWLFCHANGE, 0, (LPARAM)(LPLOGFONT)pFI->pCFA->lpLogFont);
                            }
                        }
#endif

                        //
                        //  Force redraw of preview text for any size change.
                        //
                        InvalidateRect(hDlg, &pFI->rcText, FALSE);
                        UpdateWindow(hDlg);
                    }
                }
                break;
            }
            case ( cmb5 ) :                 // script combobox
            {
                //
                //  Need to change the sample text to reflect the new script.
                //
                if (wCmd != CBN_SELCHANGE)
                {
                    break;
                }
                if (pFI->ProcessVersion < 0x40000)
                {
                    //  Enabled template also has a cmb5!
                    return (FALSE);
                }
                if (ResetSampleFromScript(hDlg, hwnd, pFI ))
                {
                    goto FillStyles;
                }
                else
                {
                    break;
                }
            }
            case ( cmb4 ) :
            {
                if (wCmd != CBN_SELCHANGE)
                {
                    break;
                }

                // fall thru...
            }
            case ( chx1 ) :                 // bold
            case ( chx2 ) :                 // italic
            {
                goto DrawSample;
            }
            case ( pshHelp ) :              // help
            {
#ifdef UNICODE
                if (pFI->ApiType == COMDLG_ANSI)
                {
                    if (msgHELPA && pCF->hwndOwner)
                    {
                        SendMessage(pCF->hwndOwner, msgHELPA, (WPARAM)hDlg, (LPARAM)pCF);
                    }
                }
                else
#endif
                {
                    if (msgHELPW && pCF->hwndOwner)
                    {
                        SendMessage(pCF->hwndOwner, msgHELPW, (WPARAM)hDlg, (LPARAM)pCF);
                    }
                }
                break;
            }
            default :
            {
                return (FALSE);
            }
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CmpFontType
//
//  Compares two font types.  The values of the font type bits are
//  monotonic except the low bit (RASTER_FONTTYPE).  After flipping
//  that bit the words can be compared directly.
//
//  Returns the best of the two.
//
////////////////////////////////////////////////////////////////////////////

int CmpFontType(
    DWORD ft1,
    DWORD ft2)
{
    ft1 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);
    ft2 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);

    //
    //  Flip the RASTER_FONTTYPE bit so we can compare.
    //
    ft1 ^= RASTER_FONTTYPE;
    ft2 ^= RASTER_FONTTYPE;

    return ( (int)ft1 - (int)ft2 );
}


////////////////////////////////////////////////////////////////////////////
//
//  FontFamilyEnumProc
//
//  nFontType bits
//
//  SCALABLE DEVICE RASTER
//     (TT)  (not GDI) (not scalable)
//      0       0       0       vector, ATM screen
//      0       0       1       GDI raster font
//      0       1       0       PS/LJ III, ATM printer, ATI/LaserMaster
//      0       1       1       non scalable device font
//      1       0       x       TT screen font
//      1       1       x       TT dev font
//
////////////////////////////////////////////////////////////////////////////

int FontFamilyEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int iItem;
    DWORD nOldType, nNewType;
    LPITEMDATA lpItemData;
    LPITEMDATA lpOldItemData = NULL;

    //
    //  Bounce non TT fonts.
    //
    if ((lpData->dwFlags & CF_TTONLY) &&
        !(nFontType & TRUETYPE_FONTTYPE))
    {
        return (TRUE);
    }

    //
    //  Bounce non scalable fonts.
    //
    if ((lpData->dwFlags & CF_SCALABLEONLY) &&
        (nFontType & RASTER_FONTTYPE))
    {
        return (TRUE);
    }

    //
    //  Bounce non ANSI fonts.
    //
    if ((lpData->dwFlags & CF_SCRIPTSONLY) &&
        ((lplf->elfLogFont.lfCharSet == OEM_CHARSET) ||
         (lplf->elfLogFont.lfCharSet == SYMBOL_CHARSET)))
    {
        return (TRUE);
    }

    //
    //  Bounce vertical fonts.
    //
    if ((lpData->dwFlags & CF_NOVERTFONTS) &&
        (lplf->elfLogFont.lfFaceName[0] == TEXT('@'))
       )
    {
        return (TRUE);
    }

    //
    //  Bounce proportional fonts.
    //
    if ((lpData->dwFlags & CF_FIXEDPITCHONLY) &&
        (lplf->elfLogFont.lfPitchAndFamily & VARIABLE_PITCH))
    {
        return (TRUE);
    }

    //
    //  Bounce vector fonts.
    //
    if ((lpData->dwFlags & CF_NOVECTORFONTS) &&
        (lplf->elfLogFont.lfCharSet == OEM_CHARSET))
    {
        return (TRUE);
    }

    if (lpData->bPrinterFont)
    {
        nFontType |= PRINTER_FONTTYPE;
    }
    else
    {
        nFontType |= SCREEN_FONTTYPE;
    }

    //
    //  Test for a name collision.
    //
    iItem = CBFindString(lpData->hwndFamily, lplf->elfLogFont.lfFaceName);
    if (iItem >= 0)
    {
        lpItemData = (LPITEMDATA)SendMessage( lpData->hwndFamily,
                                              CB_GETITEMDATA,
                                              iItem,
                                              0L );
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            nOldType = lpItemData->nFontType;
            lpOldItemData = lpItemData;
        }
        else
        {
            nOldType = 0;
        }

        //
        //  If we don't want screen fonts, but do want printer fonts,
        //  the old font is a screen font and the new font is a
        //  printer font, take the new font regardless of other flags.
        //  Note that this means if a printer wants TRUETYPE fonts, it
        //  should enumerate them.
        //
        if (!(lpData->dwFlags & CF_SCREENFONTS)  &&
             (lpData->dwFlags & CF_PRINTERFONTS) &&
             (nFontType & PRINTER_FONTTYPE)      &&
             (nOldType & SCREEN_FONTTYPE))
        {
            nOldType = 0;                   // for setting nNewType below
            goto SetNewType;
        }

        if (CmpFontType(nFontType, nOldType) > 0)
        {
SetNewType:
            nNewType = nFontType;
            SendMessage( lpData->hwndFamily,
                         CB_INSERTSTRING,
                         iItem,
                         (LONG_PTR)(LPTSTR)lplf->elfLogFont.lfFaceName );
            SendMessage( lpData->hwndFamily,
                         CB_DELETESTRING,
                         iItem + 1,
                         0L );
        }
        else
        {
            nNewType = nOldType;
        }

        //
        //  Accumulate the printer/screen ness of these fonts.
        //
        nNewType |= (nFontType | nOldType) &
                    (SCREEN_FONTTYPE | PRINTER_FONTTYPE);

        lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
        if (!lpItemData)
        {
            return (FALSE);
        }
        lpItemData->pLogFont = 0L;

        lpItemData->nFontType = nNewType;
        SendMessage( lpData->hwndFamily,
                     CB_SETITEMDATA,
                     iItem,
                     (LONG_PTR)lpItemData );

        if (lpOldItemData)
        {
            LocalFree(lpOldItemData);
        }

        return (TRUE);
    }

    iItem = (int)SendMessage( lpData->hwndFamily,
                              CB_ADDSTRING,
                              0,
                              (LONG_PTR)(LPTSTR)lplf->elfLogFont.lfFaceName );
    if (iItem < 0)
    {
        return (FALSE);
    }

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        return (FALSE);
    }
    lpItemData->pLogFont = 0L;

#ifdef WINNT
    if (lptm->ntmFlags & NTM_PS_OPENTYPE)
        nFontType |= PS_OPENTYPE_FONTTYPE;
    if (lptm->ntmFlags & NTM_TYPE1)
        nFontType |= TYPE1_FONTTYPE;
    if (lptm->ntmFlags & NTM_TT_OPENTYPE)
        nFontType |= TT_OPENTYPE_FONTTYPE;
#endif // WINNT

    lpItemData->nFontType = nFontType;

    SendMessage(lpData->hwndFamily, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    lptm;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFontFamily
//
//  Fills the screen and/or printer font facenames into the font facenames
//  combobox depending on the CF_?? flags passed in.
//
//  cmb1 is the ID for the font facename combobox
//
//  Both screen and printer fonts are listed into the same combobox
//
//  Returns:   TRUE    if successful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFontFamily(
    HWND hDlg,
    HDC hDC,
    DWORD dwEnumCode,
    UINT iCharset)
{
    ENUM_FONT_DATA data;
    int iItem, iCount;
    DWORD nFontType;
    TCHAR szMsg[200], szTitle[40];
    LPITEMDATA lpItemData;
    LOGFONT lf;

    data.hwndFamily = GetDlgItem(hDlg, cmb1);
    data.dwFlags = dwEnumCode;

    //
    //  This is a bit strange.  We have to get all the screen fonts
    //  so if they ask for the printer fonts we can tell which
    //  are really printer fonts.  This is so we don't list the
    //  vector and raster fonts as printer device fonts.
    //
    data.hDC = GetDC(NULL);
    data.bPrinterFont = FALSE;
    lf.lfFaceName[0] = CHAR_NULL;
    lf.lfCharSet = (dwEnumCode & CF_SELECTSCRIPT) ? iCharset : DEFAULT_CHARSET;
    EnumFontFamiliesEx( data.hDC,
                        &lf,
                        (FONTENUMPROC)FontFamilyEnumProc,
                        (LPARAM)&data,
                        0L );
    ReleaseDC(NULL, data.hDC);

    //
    //  List out printer font facenames.
    //
    if (dwEnumCode & CF_PRINTERFONTS)
    {
        data.hDC = hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( hDC,
                            &lf,
                            (FONTENUMPROC)FontFamilyEnumProc,
                            (LPARAM)&data,
                            0L );
    }

    //
    //  Now we have to remove those screen fonts if they didn't
    //  ask for them.
    //
    if (!(dwEnumCode & CF_SCREENFONTS))
    {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--)
        {
            lpItemData = (LPITEMDATA)SendMessage( data.hwndFamily,
                                                  CB_GETITEMDATA,
                                                  iItem,
                                                  0L );
            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
            {
                nFontType = lpItemData->nFontType;
            }
            else
            {
                nFontType = 0;
            }

            if ((nFontType & (SCREEN_FONTTYPE |
                              PRINTER_FONTTYPE)) == SCREEN_FONTTYPE)
            {
                SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
            }
        }
    }

    //
    //  For WYSIWYG mode we delete all the fonts that don't exist
    //  on the screen and the printer.
    //
    if (dwEnumCode & CF_WYSIWYG)
    {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--)
        {
            nFontType = ((LPITEMDATA)SendMessage( data.hwndFamily,
                                                  CB_GETITEMDATA,
                                                  iItem,
                                                  0L ))->nFontType;

            if ((nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE)) !=
                (SCREEN_FONTTYPE | PRINTER_FONTTYPE))
            {
                SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
            }
        }
    }

    if ((int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L) <= 0)
    {
        CDLoadString( g_hinst,
                    iszNoFontsTitle,
                    szTitle,
                    sizeof(szTitle) / sizeof(TCHAR));
        CDLoadString( g_hinst,
                    iszNoFontsMsg,
                    szMsg,
                    sizeof(szMsg) / sizeof(TCHAR));
        MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_ICONINFORMATION);

        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddSize
//
////////////////////////////////////////////////////////////////////////////

VOID CBAddSize(
    HWND hwnd,
    int pts,
    LPCHOOSEFONT lpcf)
{
    int iInd;
    TCHAR szSize[10];
    int count, test_size;
    LPITEMDATA lpItemData;

    //
    //  See if the size is limited.
    //
    if ((lpcf->Flags & CF_LIMITSIZE) &&
        ((pts > lpcf->nSizeMax) || (pts < lpcf->nSizeMin)))
    {
        return;
    }

    //
    //  Convert the point size to a string.
    //
    wsprintf(szSize, szPtFormat, pts);

    //
    //  Figure out where in the list the item should be added.
    //  All values should be in increasing order in the list box.
    //
    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    test_size = -1;
    for (iInd = 0; iInd < count; iInd++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, iInd, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            test_size = (int)lpItemData->nFontType;
        }
        else
        {
            test_size = 0;
        }

        if (pts <= test_size)
        {
            break;
        }
    }

    //
    //  Don't add duplicates.
    //
    if (pts == test_size)
    {
        return;
    }

    //
    //  Add the string and the associated item data to the list box.
    //
    iInd = (int) SendMessage(hwnd, CB_INSERTSTRING, iInd, (LPARAM)szSize);
    if (iInd >= 0)
    {
        lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
        if (!lpItemData)
        {
            return;
        }

        lpItemData->pLogFont = 0L;
        lpItemData->nFontType = (DWORD)pts;
        SendMessage(hwnd, CB_SETITEMDATA, iInd, (LONG_PTR)lpItemData);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddChineseSize
//
////////////////////////////////////////////////////////////////////////////

VOID CBAddChineseSize(
    HWND hwnd,
    LPCHOOSEFONT lpcf)
{
    int ctr, iInd = 0;
    TCHAR szSize[10];
    LPITEMDATA lpItemData;

    //
    //  Look at each item in the Zihao structure to see if it should be
    //  added.
    //
    for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
    {
        //
        //  See if the size is limited.
        //
        if ((lpcf->Flags & CF_LIMITSIZE) &&
            ((stZihao[ctr].size > lpcf->nSizeMax) ||
             (stZihao[ctr].size < lpcf->nSizeMin)))
        {
            continue;
        }

        //
        //  Convert the point size to a string.
        //
        wsprintf(szSize, TEXT("%s"), stZihao[ctr].name);

        //
        //  Add the string and the associated item data to the list box.
        //
        iInd = (int) SendMessage(hwnd, CB_INSERTSTRING, iInd, (LPARAM)szSize);
        if (iInd >= 0)
        {
            lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
            if (!lpItemData)
            {
                return;
            }

            lpItemData->pLogFont = 0L;
            lpItemData->nFontType = (DWORD)(stZihao[ctr].size * 10 +
                                            stZihao[ctr].sizeFr);
            SendMessage(hwnd, CB_SETITEMDATA, iInd, (LONG_PTR)lpItemData);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertStyleSorted
//
//  Sort styles by weight first, then by italics.
//
//  Returns the index of the place this was inserted.
//
////////////////////////////////////////////////////////////////////////////

int InsertStyleSorted(
    HWND hwnd,
    LPTSTR lpszStyle,
    LPLOGFONT lplf)
{
    int count, ctr;
    PLOGFONT plf;
    LPITEMDATA lpItemData;

    count = (int) SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;

            if (lplf->lfWeight < plf->lfWeight)
            {
                break;
            }
            else if (lplf->lfWeight == plf->lfWeight)
            {
                if (lplf->lfItalic && !plf->lfItalic)
                {
                    ctr++;
                }
                break;
            }
        }
    }

    return ((int)SendMessage(hwnd, CB_INSERTSTRING, ctr, (LONG_PTR)lpszStyle));
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddStyle
//
////////////////////////////////////////////////////////////////////////////

PLOGFONT CBAddStyle(
    HWND hwnd,
    LPTSTR lpszStyle,
    DWORD nFontType,
    LPLOGFONT lplf)
{
    int iItem;
    PLOGFONT plf;
    LPITEMDATA lpItemData;

    //
    //  Don't add duplicates.
    //
    if (CBFindString(hwnd, lpszStyle) >= 0)
    {
        return (NULL);
    }

    iItem = (int)InsertStyleSorted(hwnd, lpszStyle, lplf);
    if (iItem < 0)
    {
        return (NULL);
    }

    plf = (PLOGFONT)LocalAlloc(LMEM_FIXED, sizeof(LOGFONT));
    if (!plf)
    {
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (NULL);
    }

    *plf = *lplf;

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        LocalFree(plf);
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (NULL);
    }

    lpItemData->pLogFont = plf;
    lpItemData->nFontType = nFontType;
    SendMessage(hwnd, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    return (plf);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddScript
//
////////////////////////////////////////////////////////////////////////////

int CBAddScript(
    HWND hwnd,
    LPTSTR lpszScript,
    UINT iCharset)
{
    int iItem;
    LPITEMDATA lpItemData;

    //
    //  Don't add duplicates or empty strings.
    //
    if (!IsWindow(hwnd) || !IsWindowEnabled(hwnd) || (!*lpszScript) ||
        (CBFindString(hwnd, lpszScript) >= 0))
    {
        return (-1);
    }

    iItem = (int)SendMessage(hwnd, CB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)lpszScript);
    if (iItem < 0)
    {
        return (-1);
    }

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (-1);
    }

    lpItemData->pLogFont = 0L;
    lpItemData->nFontType = (DWORD)iCharset;
    SendMessage(hwnd, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    return (iItem);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillInMissingStyles
//
//  Generates simulated forms from those that we have.
//
//  reg -> bold
//  reg -> italic
//  bold || italic || reg -> bold italic
//
////////////////////////////////////////////////////////////////////////////

VOID FillInMissingStyles(
    HWND hwnd)
{
    PLOGFONT plf, plf_reg, plf_bold, plf_italic;
    DWORD nFontType;
    int ctr, count;
    BOOL bBold, bItalic, bBoldItalic;
    LPITEMDATA lpItemData;
    LOGFONT lf;

    bBold = bItalic = bBoldItalic = FALSE;
    plf_reg = plf_bold = plf_italic = NULL;

    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;
            nFontType = lpItemData->nFontType;
        }
        else
        {
            plf = NULL;
            nFontType = 0;
        }

        if ((nFontType & BOLD_FONTTYPE) && (nFontType & ITALIC_FONTTYPE))
        {
            bBoldItalic = TRUE;
        }
        else if (nFontType & BOLD_FONTTYPE)
        {
            bBold = TRUE;
            plf_bold = plf;
        }
        else if (nFontType & ITALIC_FONTTYPE)
        {
            bItalic = TRUE;
            plf_italic = plf;
        }
        else
        {
            plf_reg = plf;
        }
    }

    nFontType |= SIMULATED_FONTTYPE;

    if (!bBold && plf_reg)
    {
        lf = *plf_reg;
        lf.lfWeight = FW_BOLD;
        CBAddStyle(hwnd, szBold, (nFontType | BOLD_FONTTYPE), &lf);
    }

    if (!bItalic && plf_reg)
    {
        lf = *plf_reg;
        lf.lfItalic = TRUE;
        CBAddStyle(hwnd, szItalic, (nFontType | ITALIC_FONTTYPE), &lf);
    }
    if (!bBoldItalic && (plf_bold || plf_italic || plf_reg))
    {
        if (plf_italic)
        {
            plf = plf_italic;
        }
        else if (plf_bold)
        {
            plf = plf_bold;
        }
        else
        {
            plf = plf_reg;
        }

        lf = *plf;
        lf.lfItalic = (BYTE)TRUE;
        lf.lfWeight = FW_BOLD;
        CBAddStyle(hwnd, szBoldItalic, (nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE), &lf);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FillScalableSizes
//
////////////////////////////////////////////////////////////////////////////

VOID FillScalableSizes(
    HWND hwnd,
    LPCHOOSEFONT lpcf)
{
    if (g_bIsSimplifiedChineseUI)
    {
        CBAddChineseSize(hwnd, lpcf);
    }

    CBAddSize(hwnd, 8,  lpcf);
    CBAddSize(hwnd, 9,  lpcf);
    CBAddSize(hwnd, 10, lpcf);
    CBAddSize(hwnd, 11, lpcf);
    CBAddSize(hwnd, 12, lpcf);
    CBAddSize(hwnd, 14, lpcf);
    CBAddSize(hwnd, 16, lpcf);
    CBAddSize(hwnd, 18, lpcf);
    CBAddSize(hwnd, 20, lpcf);
    CBAddSize(hwnd, 22, lpcf);
    CBAddSize(hwnd, 24, lpcf);
    CBAddSize(hwnd, 26, lpcf);
    CBAddSize(hwnd, 28, lpcf);
    CBAddSize(hwnd, 36, lpcf);
    CBAddSize(hwnd, 48, lpcf);
    CBAddSize(hwnd, 72, lpcf);
}


////////////////////////////////////////////////////////////////////////////
//
//  FontStyleEnumProc
//
////////////////////////////////////////////////////////////////////////////
int FontStyleEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int height, pts;
    TCHAR buf[10];


    if (!(nFontType & RASTER_FONTTYPE))
    {
        //
        //  Vector or TT font.
        //
        if (lpData->bFillSize &&
            (int)SendMessage(lpData->hwndSizes, CB_GETCOUNT, 0, 0L) == 0)
        {
            FillScalableSizes(lpData->hwndSizes, lpData->lpcf);
        }
    }
    else
    {
        height = lptm->tmHeight - lptm->tmInternalLeading;
        pts = GetPointString(buf, lpData->hDC, height);

        //
        //  Filter devices same size of multiple styles.
        //
        if (CBFindString(lpData->hwndSizes, buf) < 0)
        {
            CBAddSize(lpData->hwndSizes, pts, lpData->lpcf);
        }
    }

    //
    //  Keep the printer/screen bits from the family list here too.
    //
    nFontType |= (lpData->nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE));

#ifdef WINNT
    if (lptm->ntmFlags & NTM_PS_OPENTYPE)
        nFontType |= PS_OPENTYPE_FONTTYPE;
    if (lptm->ntmFlags & NTM_TYPE1)
        nFontType |= TYPE1_FONTTYPE;
    if (lptm->ntmFlags & NTM_TT_OPENTYPE)
        nFontType |= TT_OPENTYPE_FONTTYPE;
#endif // WINNT

    if (nFontType & TRUETYPE_FONTTYPE)
    {
        //
        //  If (lptm->ntmFlags & NTM_REGULAR)
        //
        if (!(lptm->ntmFlags & (NTM_BOLD | NTM_ITALIC)))
        {
            nFontType |= REGULAR_FONTTYPE;
        }

        if (lptm->ntmFlags & NTM_ITALIC)
        {
            nFontType |= ITALIC_FONTTYPE;
        }

        if (lptm->ntmFlags & NTM_BOLD)
        {
            nFontType |= BOLD_FONTTYPE;
        }

        //
        //  After the LOGFONT.lfFaceName there are 2 more names
        //     lfFullName[LF_FACESIZE * 2]
        //     lfStyle[LF_FACESIZE]
        //
        //  If the font has one of the standard style strings in English,
        //  use the localized string instead.
        //
        if (!lstrcmp(c_szBoldItalic, lplf->elfStyle) ||
            ((nFontType & BOLD_FONTTYPE) && (nFontType & ITALIC_FONTTYPE)))
        {
            CBAddStyle( lpData->hwndStyle,
                        szBoldItalic,
                        nFontType,
                        &lplf->elfLogFont);
        }
        else if (!lstrcmp(c_szRegular, lplf->elfStyle) ||
                 (nFontType & REGULAR_FONTTYPE))
        {
            CBAddStyle( lpData->hwndStyle,
                        szRegular,
                        nFontType,
                        &lplf->elfLogFont );
        }
        else if (!lstrcmp(c_szBold, lplf->elfStyle) ||
                  (nFontType & BOLD_FONTTYPE))
        {
            CBAddStyle( lpData->hwndStyle,
                        szBold,
                        nFontType,
                        &lplf->elfLogFont );
        }
        else if (!lstrcmp(c_szItalic, lplf->elfStyle) ||
                  (nFontType & ITALIC_FONTTYPE))
        {
            CBAddStyle( lpData->hwndStyle,
                        szItalic,
                        nFontType,
                        &lplf->elfLogFont);
        }
    }
    else
    {
        if ((lplf->elfLogFont.lfWeight >= FW_BOLD) && lplf->elfLogFont.lfItalic)
        {
            CBAddStyle( lpData->hwndStyle,
                        szBoldItalic,
                        (nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else if (lplf->elfLogFont.lfWeight >= FW_BOLD)
        {
            CBAddStyle( lpData->hwndStyle,
                        szBold,
                        (nFontType | BOLD_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else if (lplf->elfLogFont.lfItalic)
        {
            CBAddStyle( lpData->hwndStyle,
                        szItalic,
                        (nFontType | ITALIC_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else
        {
            CBAddStyle( lpData->hwndStyle,
                        szRegular,
                        (nFontType | REGULAR_FONTTYPE),
                        &lplf->elfLogFont );
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeFonts
//
////////////////////////////////////////////////////////////////////////////

VOID FreeFonts(
    HWND hwnd)
{
    int ctr, count;
    LPITEMDATA lpItemData;

    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (!IS_INTRESOURCE(lpItemData) && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            if (!IS_INTRESOURCE(lpItemData->pLogFont))
            {
                LocalFree((HANDLE)lpItemData->pLogFont);
            }
            LocalFree((HANDLE)lpItemData);
        }
        SendMessage(hwnd, CB_SETITEMDATA, ctr, 0L);
    }

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeAllItemData
//
////////////////////////////////////////////////////////////////////////////

VOID FreeAllItemData(
    HWND hDlg,
    PFONTINFO pFI)
{
    HWND hwndTemp;

    if (hwndTemp = GetDlgItem(hDlg, cmb1))
    {
        FreeFonts(hwndTemp);
    }
    if (hwndTemp = GetDlgItem(hDlg, cmb2))
    {
        FreeFonts(hwndTemp);
    }
    if (hwndTemp = GetDlgItem(hDlg, cmb3))
    {
        FreeFonts(hwndTemp);
    }
    if (((pFI->ProcessVersion >= 0x40000) ||
         (pFI->pCF->Flags & CF_NOSCRIPTSEL)) &&
        (hwndTemp = GetDlgItem(hDlg, cmb5)))
    {
        FreeFonts(hwndTemp);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitLF
//
//  Initalize a LOGFONT structure to some base generic regular type font.
//
////////////////////////////////////////////////////////////////////////////

VOID InitLF(
    LPLOGFONT lplf)
{
    HDC hdc;

    hdc = GetDC(NULL);
    lplf->lfEscapement = 0;
    lplf->lfOrientation = 0;
    lplf->lfCharSet = (BYTE) GetTextCharset(hdc);
    lplf->lfOutPrecision = OUT_DEFAULT_PRECIS;
    lplf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lplf->lfQuality = DEFAULT_QUALITY;
    lplf->lfPitchAndFamily = DEFAULT_PITCH;
    lplf->lfItalic = 0;
    lplf->lfWeight = FW_NORMAL;
    lplf->lfStrikeOut = 0;
    lplf->lfUnderline = 0;
    lplf->lfWidth = 0;            // otherwise we get independant x-y scaling
    lplf->lfFaceName[0] = 0;
    lplf->lfHeight = -MulDiv( DEF_POINT_SIZE,
                              GetDeviceCaps(hdc, LOGPIXELSY),
                              POINTS_PER_INCH );
    ReleaseDC(NULL, hdc);
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  FontMMAxesEnumProc
//
//  Gets all of the lower and upper bounds and default values of MM axes 
//  for the face we are enumerating. Sets the scrollbar parameters as well as
//  static controls and edit boxes accordingly.
//
////////////////////////////////////////////////////////////////////////////

int FontMMAxesEnumProc(
    LPENUMLOGFONTEXDV lplf,
    LPENUMTEXTMETRIC lpetm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    UINT i;
    SCROLLINFO scri;
    RECT rcCtl;

        lpData->pDefaultDesignVector->dvNumAxes = (lpetm)->etmAxesList.axlNumAxes;
        lpData->pDefaultDesignVector->dvReserved = STAMP_DESIGNVECTOR;

    if (MAX_NUM_AXES < lpData->pDefaultDesignVector->dvNumAxes)
    {
//        MessageBox(lpData->hwndParent, TEXT("Cannot support so many axes"), TEXT("Error"), MB_OK | MB_ICONEXCLAMATION);
        lpData->pDefaultDesignVector->dvNumAxes = 0;  // this will get rid of all scroll bars
    }


    scri.cbSize = sizeof(SCROLLINFO);
    scri.fMask  = SIF_RANGE | SIF_POS | SIF_PAGE;
    scri.nTrackPos = 0;

    rcCtl.left   = 0;
    rcCtl.top    = 0;
    rcCtl.right  = 287;
    rcCtl.bottom = (lpData->pDefaultDesignVector->dvNumAxes == 0)? 216 : 225+20+20*lpData->pDefaultDesignVector->dvNumAxes;
    MapDialogRect( lpData->hwndParent, &rcCtl);
    SetWindowPos ( lpData->hwndParent, NULL, 
                   0, 0, 
                   rcCtl.right, rcCtl.bottom,
                   SWP_NOMOVE | SWP_NOZORDER );

    rcCtl.left   = 0;
    rcCtl.top    = 0;
    rcCtl.right  = 205;
    rcCtl.bottom = 15+20*(lpetm)->etmAxesList.axlNumAxes;
    MapDialogRect( lpData->hwndParent, &rcCtl);
    SetWindowPos ( GetDlgItem(lpData->hwndParent, grp3), NULL, 
                   0, 0, 
                   rcCtl.right, rcCtl.bottom,
                   SWP_NOMOVE | SWP_NOZORDER );

    for (i=0; i<lpData->pDefaultDesignVector->dvNumAxes; i++)
    {
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc11 + i), SW_SHOW); // axName
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc18 + i), SW_SHOW); // axMin
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc25 + i), SW_SHOW); // axMax
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  edt1 + i), SW_SHOW); // dvVal
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  scr1 + i), SW_SHOW); // scrollbar
            //EnableScrollBar ( GetDlgItem(lpData->hwndParent,  scr1 + i), SB_CTL, ESB_ENABLE_BOTH);

            lpData->pDefaultDesignVector->dvValues[i] = (lplf)->elfDesignVector.dvValues[i];

            scri.nMin   = (lpetm)->etmAxesList.axlAxisInfo[i].axMinValue;
            scri.nPage  = 10;
            scri.nMax   = (lpetm)->etmAxesList.axlAxisInfo[i].axMaxValue + scri.nPage - 1;
            scri.nPos   = (lplf)->elfDesignVector.dvValues[i];
            SetScrollInfo(GetDlgItem(lpData->hwndParent, scr1 + i), SB_CTL, &scri, TRUE);

            SetDlgItemText( lpData->hwndParent, 
                            stc11 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axAxisName);
            SetDlgItemInt ( lpData->hwndParent, 
                            stc18 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axMinValue, 
                            TRUE);
            SetDlgItemInt ( lpData->hwndParent, 
                            stc25 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axMaxValue, 
                            TRUE);
            SetDlgItemInt ( lpData->hwndParent, 
                            edt1 + i, 
                            (lplf)->elfDesignVector.dvValues[i], 
                            TRUE);
    }

    for (i=lpData->pDefaultDesignVector->dvNumAxes; i<MAX_NUM_AXES; i++)
    {
        HideDlgItem(lpData->hwndParent, stc11 + i); // axName
        HideDlgItem(lpData->hwndParent, stc18 + i); // axMin
        HideDlgItem(lpData->hwndParent, stc25 + i); // axMax
        HideDlgItem(lpData->hwndParent, edt1 + i);  // dvVal
        HideDlgItem(lpData->hwndParent, scr1 + i);  // scrollbar
        // EnableScrollBar ( GetDlgItem(lpData->hwndParent, scr1 + i), SB_CTL, ESB_DISABLE_BOTH);
    }       

    return TRUE;
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  FontScriptEnumProc
//
//  Gets all of the charsets for the face we are enumerating.
//
//  Fills in the script window if any, and sets the script property to
//  the correct charset.  If there is no window, then the first value
//  enumerated is set into the script, and contol returned.  If there is a
//  window, then the scripts will all be filled in.  If the correct value
//  is found, then that will be filled in. If its not found, such as when
//  the user changes from TimesNewRoman to WingDings, then the caller will
//  fill in the property to be the first one.
//
////////////////////////////////////////////////////////////////////////////

int FontScriptEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int script = -1;

    //
    //  Need to check the charsets again as we have a face and are checking
    //  the family.
    //
    //  Bounce non WANSI fonts.
    //
    if ( (lpData->dwFlags & CF_SCRIPTSONLY) &&
         ((lplf->elfLogFont.lfCharSet == OEM_CHARSET) ||
          (lplf->elfLogFont.lfCharSet == SYMBOL_CHARSET)) )
    {
        return (TRUE);
    }

    if (lpData->hwndScript)
    {
        script = CBAddScript( lpData->hwndScript,
                              lplf->elfScript,
                              lplf->elfLogFont.lfCharSet );
    }
    else if (lpData->iCharset == FONT_INVALID_CHARSET)
    {
        lpData->iCharset = lplf->elfLogFont.lfCharSet;
    }

    if (lplf->elfLogFont.lfCharSet == lpData->cfdCharset)
    {
        lpData->iCharset = lplf->elfLogFont.lfCharSet;
        if (script >= 0)
        {
            SendMessage(lpData->hwndScript, CB_SETCURSEL, script, 0L);
        }
        else if (!(lpData->hwndScript))
        {
            return (FALSE);
        }
    }

    if (lpData->lpcf->Flags & CF_SELECTSCRIPT)
    {
        //
        //  We just wanted the first one to fill in the script box, now stop.
        //
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFontStylesAndSizes
//
//  Fills the point sizes combo box with the point sizes for the current
//  selection in the facenames combobox.
//
//  cmb1 is the ID for the font facename combobox.
//
//  Returns:   TRUE    if successful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFontStylesAndSizes(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    BOOL bForceSizeFill)
{
    ENUM_FONT_DATA data;
    TCHAR szFace[LF_FACESIZE];
    int iSel;
    int iMapMode;
    SIZE ViewportExt, WindowExt;
    LOGFONT lf;
    LPITEMDATA lpItemData;

    FreeFonts(GetDlgItem(hDlg, cmb2));

    data.hwndStyle  = GetDlgItem(hDlg, cmb2);
    data.hwndSizes  = GetDlgItem(hDlg, cmb3);
    data.hwndScript = (pFI->ProcessVersion >= 0x40000)
                          ? GetDlgItem(hDlg, cmb5)
                          : NULL;
    data.dwFlags    = lpcf->Flags;
    data.lpcf       = lpcf;

    if (!IsWindow(data.hwndScript) || !IsWindowEnabled(data.hwndScript))
    {
        data.hwndScript = NULL;
    }

    iSel = (int)SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);
    if (iSel < 0)
    {
        //
        //  If we don't have a face name selected we will synthisize
        //  the standard font styles...
        //
        InitLF(&lf);
        CBAddStyle(data.hwndStyle, szRegular, REGULAR_FONTTYPE, &lf);
        lf.lfWeight = FW_BOLD;
        CBAddStyle(data.hwndStyle, szBold, BOLD_FONTTYPE, &lf);
        lf.lfWeight = FW_NORMAL;
        lf.lfItalic = TRUE;
        CBAddStyle(data.hwndStyle, szItalic, ITALIC_FONTTYPE, &lf);
        lf.lfWeight = FW_BOLD;
        CBAddStyle(data.hwndStyle, szBoldItalic, BOLD_FONTTYPE | ITALIC_FONTTYPE, &lf);
        FillScalableSizes(data.hwndSizes, lpcf);

        return (TRUE);
    }

    lpItemData = (LPITEMDATA)SendDlgItemMessage( hDlg,
                                                 cmb1,
                                                 CB_GETITEMDATA,
                                                 iSel,
                                                 0L );
    if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
    {
        data.nFontType  = lpItemData->nFontType;
    }
    else
    {
        data.nFontType  = 0;
    }

    data.bFillSize = TRUE;

    //
    // Free existing contents of font size combo box.
    // Also sends CB_RESETCONTENT to control.
    //
    FreeFonts(data.hwndSizes);

    SendMessage(data.hwndStyle, WM_SETREDRAW, FALSE, 0L);

    GetDlgItemText(hDlg, cmb1, szFace, ARRAYSIZE(szFace));
    lstrcpy(lf.lfFaceName, szFace);

    //
    //  Fill in the script box FIRST. That way we have something to play with.
    //
    if (data.hwndScript)
    {
        SendMessage(data.hwndScript, CB_RESETCONTENT, 0, 0L);
    }
    data.iCharset   = FONT_INVALID_CHARSET;      // impossible charset value.
    data.cfdCharset = pFI->iCharset;             // pass into enum procs

    //
    //  If no script box exists, then we must get the appropriate charset
    //  based on the default ansi code page.
    //
    if (!data.hwndScript)
    {
        CHARSETINFO csi;
        DWORD dwCodePage = GetACP();

        if (TranslateCharsetInfo(IntToPtr_(DWORD*, dwCodePage), &csi, TCI_SRCCODEPAGE))
        {
            data.cfdCharset = csi.ciCharset;
        }
    }

    lf.lfCharSet = (lpcf->Flags & CF_SELECTSCRIPT)
                       ? pFI->iCharset
                       : DEFAULT_CHARSET;

    if (lpcf->Flags & CF_SCREENFONTS)
    {
        data.hDC = GetDC(NULL);
        data.bPrinterFont = FALSE;
        EnumFontFamiliesEx( data.hDC,
                            &lf,
                            (FONTENUMPROC)FontScriptEnumProc,
                            (LPARAM)&data,
                            0L );
        ReleaseDC(NULL, data.hDC);
    }

    if (lpcf->Flags & CF_PRINTERFONTS)
    {
        data.hDC = lpcf->hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( lpcf->hDC,
                            &lf,
                            (FONTENUMPROC)FontScriptEnumProc,
                            (LPARAM)&data,
                            0L );
    }

    //
    //  Put it back into the main structure.
    //
    if ((data.iCharset == FONT_INVALID_CHARSET) && (data.hwndScript))
    {
        //
        //  There MUST be a script window, and we didn't find the charset
        //  we were looking for.
        //
        SendMessage(data.hwndScript, CB_SETCURSEL, 0, 0L);
        lpItemData = (LPITEMDATA)SendMessage( data.hwndScript,
                                              CB_GETITEMDATA,
                                              0,
                                              0L );
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            data.iCharset = lpItemData->nFontType;
        }
        else
        {
            data.iCharset = DEFAULT_CHARSET;
        }
    }
    lf.lfCharSet = pFI->iCharset = data.iCharset;

    if (lpcf->Flags & CF_SCREENFONTS)
    {
        data.hDC = GetDC(NULL);
        data.bPrinterFont = FALSE;
        EnumFontFamiliesEx( data.hDC,
                            &lf,
                            (FONTENUMPROC)FontStyleEnumProc,
                            (LPARAM)&data,
                            0L );
        ReleaseDC(NULL, data.hDC);
    }

    if (lpcf->Flags & CF_PRINTERFONTS)
    {
        //
        //  Save and restore the DC's mapping mode (and extents if needed)
        //  if it's been set by the app to something other than MM_TEXT.
        //
        if ((iMapMode = GetMapMode(lpcf->hDC)) != MM_TEXT)
        {
            if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
            {
                GetViewportExtEx(lpcf->hDC, &ViewportExt);
                GetWindowExtEx(lpcf->hDC, &WindowExt);
            }
            SetMapMode(lpcf->hDC, MM_TEXT);
        }

        data.hDC = lpcf->hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( lpcf->hDC,
                            &lf,
                            (FONTENUMPROC)FontStyleEnumProc,
                            (LPARAM)&data,
                            0L );

        if (iMapMode != MM_TEXT)
        {
            SetMapMode(lpcf->hDC, iMapMode);
            if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
            {
                SetWindowExtEx( lpcf->hDC,
                                WindowExt.cx,
                                WindowExt.cy,
                                &WindowExt );
                SetViewportExtEx( lpcf->hDC,
                                  ViewportExt.cx,
                                  ViewportExt.cy,
                                  &ViewportExt );
            }
        }
    }

    if (!(lpcf->Flags & CF_NOSIMULATIONS))
    {
        FillInMissingStyles(data.hwndStyle);
    }

    SendMessage(data.hwndStyle, WM_SETREDRAW, TRUE, 0L);
    if (wWinVer < 0x030A)
    {
        InvalidateRect(data.hwndStyle, NULL, TRUE);
    }

    if (data.bFillSize)
    {
        SendMessage(data.hwndSizes, WM_SETREDRAW, TRUE, 0L);
        if (wWinVer < 0x030A)
        {
            InvalidateRect(data.hwndSizes, NULL, TRUE);
        }
    }

#ifdef MM_DESIGNVECTOR_DEFINED
    if (pFI->pfnCreateFontIndirectEx !=NULL)
    /* it's not safe to access the MM Axis information on a system where CreateFontIndirectEx is not defined */
    {
        if (lpcf->Flags & CF_SCREENFONTS)
        {
            data.hDC = GetDC(NULL);
            data.bPrinterFont = FALSE;
            data.hwndParent = hDlg;
            data.pDefaultDesignVector = &pFI->DefaultDesignVector;
            EnumFontFamiliesEx( data.hDC,
                                &lf,
                                (FONTENUMPROC)FontMMAxesEnumProc,
                                (LPARAM)&data,
                                0L );
            ReleaseDC(NULL, data.hDC);
        }

        if (lpcf->Flags & CF_PRINTERFONTS)
        {
            data.hDC = lpcf->hDC;
            data.bPrinterFont = TRUE;
            EnumFontFamiliesEx( lpcf->hDC,
                                &lf,
                                (FONTENUMPROC)FontMMAxesEnumProc,
                                (LPARAM)&data,
                                0L );
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED

    ResetSampleFromScript(hDlg, data.hwndScript, pFI);

    if (lpcf->Flags & CF_NOSCRIPTSEL)
    {
        pFI->iCharset = DEFAULT_CHARSET;
    }

    bForceSizeFill;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillColorCombo
//
//  Adds the color name strings to the colors combobox.
//
//  cmb4 is the ID for the color combobox.
//
//  The color rectangles are drawn later in response to a WM_DRAWITEM msg.
//
////////////////////////////////////////////////////////////////////////////

VOID FillColorCombo(
    HWND hDlg)
{
    int iT, item;
    TCHAR szT[CCHCOLORNAMEMAX];

    for (iT = 0; iT < CCHCOLORS; ++iT)
    {
        *szT = 0;
        CDLoadString(g_hinst, iszBlack + iT, szT, ARRAYSIZE(szT));
        item = (int) SendDlgItemMessage( hDlg,
                                         cmb4,
                                         CB_INSERTSTRING,
                                         iT,
                                         (LPARAM)szT );
        if (item >= 0)
        {
            SendDlgItemMessage(hDlg, cmb4, CB_SETITEMDATA, item, rgbColors[iT]);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSizeComboItem
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawSizeComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE + 10];
    HFONT hFont;

    hDC = lpdis->hDC;

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szFace );

    ExtTextOut( hDC,
                lpdis->rcItem.left + GetSystemMetrics(SM_CXBORDER),
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );
    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE + 10];
    HBITMAP hOld;
    int dy, x;
    HFONT hFont;

    hDC = lpdis->hDC;

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    // wsprintf(szFace, "%4.4X", LOWORD(lpdis->itemData));

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );
    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        if (hbmFont)
        {
            LPITEMDATA lpItemData = (LPITEMDATA)lpdis->itemData;

            hOld = SelectObject(hdcMem, hbmFont);

            if (!lpItemData)
            {
                goto SkipBlt;
            }

            if (lpItemData->nFontType & TRUETYPE_FONTTYPE)
            {
#ifdef WINNT
                if (lpItemData->nFontType & TT_OPENTYPE_FONTTYPE)
                    x = 2 * DX_BITMAP;
                else
#endif
                    x = 0;
            }
#ifdef WINNT
            else if (lpItemData->nFontType & PS_OPENTYPE_FONTTYPE)
            {
                x = 3 * DX_BITMAP;
            }
            else if (lpItemData->nFontType & TYPE1_FONTTYPE)
            {
                x = 4 * DX_BITMAP;
            }
#endif
            else
            {
                if ((lpItemData->nFontType & (PRINTER_FONTTYPE |
                                              DEVICE_FONTTYPE))
                  == (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
                {
                    //
                    //  This may be a screen and printer font but
                    //  we will call it a printer font here.
                    //
                    x = DX_BITMAP;
                }
                else
                {
                    goto SkipBlt;
                }
            }

            //If it a mirrored DC then the bitmaps are order from right to left.
            if (IS_DC_RTL_MIRRORED(hdcMem)) {
                x = ((NUM_OF_BITMAP - 1) - (x / DX_BITMAP)) * DX_BITMAP;
            }

            dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

            BitBlt( hDC,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top + dy,
                    DX_BITMAP,
                    DY_BITMAP,
                    hdcMem,
                    x,
                    lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                    SRCCOPY );

SkipBlt:
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawColorComboItem
//
//  Computes and draws the color combo items.
//  Called by main dialog function in response to a WM_DRAWITEM msg.
//
//  All color name strings have already been loaded and filled into
//  the combobox.
//
//  Returns:   TRUE    if succesful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawColorComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC;
    HBRUSH hbr;
    int dx, dy;
    RECT rc;
    TCHAR szColor[CCHCOLORNAMEMAX];
    DWORD rgbBack, rgbText, dw;
    HFONT hFont;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }
    ExtTextOut( hDC,
                lpdis->rcItem.left,
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                NULL,
                0,
                NULL );

    //
    //  Compute coordinates of color rectangle and draw it.
    //
    dx = GetSystemMetrics(SM_CXBORDER);
    dy = GetSystemMetrics(SM_CYBORDER);
    rc.top    = lpdis->rcItem.top + dy;
    rc.bottom = lpdis->rcItem.bottom - dy;
    rc.left   = lpdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    dw = (DWORD) SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0L);

    hbr = CreateSolidBrush(dw);
    if (!hbr)
    {
        return (FALSE);
    }

    hbr = SelectObject(hDC, hbr);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    DeleteObject(SelectObject(hDC, hbr));

    //
    //  Shift the color text right by the width of the color rectangle.
    //
    *szColor = 0;
    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szColor );

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    TextOut( hDC,
             2 * dx + rc.right,
             lpdis->rcItem.top,
             szColor,
             lstrlen(szColor) );

    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSampleText
//
//  Displays sample text with given attributes.  Assumes rcText holds the
//  coordinates of the area within the frame (relative to dialog client)
//  which text should be drawn in.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSampleText(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    HDC hDC)
{
    DWORD rgbText;
    DWORD rgbBack;
    int iItem;
    HFONT hFont, hTemp;
    TCHAR szSample[50];
#ifdef MM_DESIGNVECTOR_DEFINED
    ENUMLOGFONTEXDV elfdv;
#else
    LOGFONT lf;
#endif // MM_DESIGNVECTOR_DEFINED
    SIZE TextExtent;
    int len, x, y;
    TEXTMETRIC tm;
    BOOL bCompleteFont;
    RECT rcText;

#ifdef MM_DESIGNVECTOR_DEFINED
    bCompleteFont = FillInFontEx(hDlg, pFI, lpcf, &elfdv, FALSE);
    elfdv.elfEnumLogfontEx.elfLogFont.lfEscapement = 0;
    elfdv.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;

    if (pFI->pfnCreateFontIndirectEx != NULL)
    {
        hFont = pFI->pfnCreateFontIndirectEx(&elfdv);
    }
    else
    {
        hFont = CreateFontIndirect((LPLOGFONT)&elfdv);
    }
#else
    bCompleteFont = FillInFont(hDlg, pFI, lpcf, &lf, FALSE);
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;

    hFont = CreateFontIndirect(&lf);
#endif // MM_DESIGNVECTOR_DEFINED
    if (!hFont)
    {
        return;
    }

    hTemp = SelectObject(hDC, hFont);

    rgbBack = SetBkColor(hDC, GetSysColor((pFI->ProcessVersion < 0x40000)
                                          ? COLOR_WINDOW
                                          : COLOR_3DFACE));

    if (lpcf->Flags & CF_EFFECTS)
    {
        iItem = (int)SendDlgItemMessage(hDlg, cmb4, CB_GETCURSEL, 0, 0L);
        if (iItem != CB_ERR)
        {
            rgbText = (DWORD) SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, iItem, 0L);
        }
        else
        {
            goto GetWindowTextColor;
        }
    }
    else
    {
GetWindowTextColor:
        rgbText = GetSysColor(COLOR_WINDOWTEXT);
    }

    rgbText = SetTextColor(hDC, rgbText);
 
    if (bCompleteFont)
    {
        if (GetUnicodeSampleText(hDC, szSample, ARRAYSIZE(szSample)))           
        {
            //Empty Body
        }
        else
        {
            GetDlgItemText(hDlg, stc5, szSample, ARRAYSIZE(szSample));
        }
    }
    else
    {
        szSample[0] = 0;
    }

    GetTextMetrics(hDC, &tm);

    len = lstrlen(szSample);
    GetTextExtentPoint(hDC, szSample, len, &TextExtent);
    TextExtent.cy = tm.tmAscent - tm.tmInternalLeading;

    rcText = pFI->rcText;

    if (pFI->ProcessVersion >= 0x40000)
    {
#ifdef UNICODE
        if (!IS16BITWOWAPP(lpcf) || !(lpcf->Flags & CF_ENABLEHOOK))
#endif
        {
            DrawEdge(hDC, &rcText, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        }
    }
#ifndef WINNT
    else
    {
        //
        //  We only care about conforming if we have no border.
        //
        FORWARD_WM_CTLCOLORSTATIC(hDlg, hDC, NULL, SendMessage);
    }
#endif

    if ((TextExtent.cx >= (rcText.right - rcText.left)) ||
        (TextExtent.cx <= 0))
    {
        x = rcText.left;
    }
    else
    {
        x = rcText.left + ((rcText.right - rcText.left) - TextExtent.cx) / 2;
    }

    y = min( rcText.bottom,
             rcText.bottom - ((rcText.bottom - rcText.top) - TextExtent.cy) / 2);

    ExtTextOut( hDC,
                x,
                y - (tm.tmAscent),
                ETO_OPAQUE | ETO_CLIPPED,
                &rcText,
                szSample,
                len,
                NULL );

    SetBkColor(hDC, rgbBack);
    SetTextColor(hDC, rgbText);

    if (hTemp)
    {
        DeleteObject(SelectObject(hDC, hTemp));
    }
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  FillInFontEx
//
//  Fills in the ENUMLOGFONTEXDV structure based on the current selection.
//
//  bSetBits - if TRUE the Flags fields in the lpcf are set to indicate
//             what parts (face, style, size) are not selected
//
//  lpelfdv  - ENUMLOGFONTEXDV filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the ENUMLOGFONTEXDV is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the ENUMLOGFONTEXDV with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL FillInFontEx(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lpelfdv,
    BOOL bSetBits)
{
    UINT i;
    BOOL bTranslated;

    ZeroMemory(lpelfdv, sizeof(ENUMLOGFONTEXDV));

    lpelfdv->elfDesignVector.dvNumAxes = pFI->DefaultDesignVector.dvNumAxes;
    lpelfdv->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  

    for (i=0; i<lpelfdv->elfDesignVector.dvNumAxes; i++)
           lpelfdv->elfDesignVector.dvValues[i] = GetDlgItemInt(hDlg, edt1 + i, &bTranslated, TRUE);

    return FillInFont(hDlg, pFI, lpcf, &lpelfdv->elfEnumLogfontEx.elfLogFont, bSetBits);
    // memcpy (&lpelfdv->elfEnumLogfontEx.elfLogFont, &lf, sizeof(LOGFONT));
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  FillInFont
//
//  Fills in the LOGFONT structure based on the current selection.
//
//  bSetBits - if TRUE the Flags fields in the lpcf are set to indicate
//             what parts (face, style, size) are not selected
//
//  lplf     - LOGFONT filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the LOGFONT is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the LOGFONT with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL FillInFont(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf,
    BOOL bSetBits)
{
    HDC hdc;
    int iSel, id, pts;
    LPITEMDATA lpItemData;
    DWORD nFontType;
    PLOGFONT plf;
    TCHAR szStyle[LF_FACESIZE];
    TCHAR szMessage[128];
    BOOL bFontComplete = TRUE;
    CHARSETINFO csi;
    DWORD dwCodePage = GetACP();

    if (!TranslateCharsetInfo(IntToPtr_(DWORD*, dwCodePage), &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }

    InitLF(lplf);

    GetDlgItemText( hDlg,
                    cmb1,
                    lplf->lfFaceName,
                    sizeof(lplf->lfFaceName) / sizeof(TCHAR) );
    if (CBFindString(GetDlgItem(hDlg, cmb1), lplf->lfFaceName) >= 0)
    {
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOFACESEL;
        }
    }
    else
    {
        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOFACESEL;
        }
    }

    iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                             szStyle,
                             sizeof(szStyle) / sizeof(TCHAR),
                             (PULONG_PTR)&lpItemData );
    if ((iSel >= 0) && lpItemData)
    {
        nFontType = lpItemData->nFontType;
        plf = lpItemData->pLogFont;
        *lplf = *plf;                       // copy the LOGFONT
        lplf->lfWidth = 0;                  // 1:1 x-y scaling
        if (!lstrcmp(lplf->lfFaceName, TEXT("Small Fonts")))
        {
            lplf->lfCharSet = (BYTE) csi.ciCharset;
        }
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOSTYLESEL;
        }
    }
    else
    {
        //
        //  Even if the style is invalid, we still need the charset.
        //
        iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                                 (LPTSTR)NULL,
                                 0,
                                 (PULONG_PTR)&lpItemData );
        if ((iSel >= 0) && lpItemData)
        {
            nFontType = lpItemData->nFontType;
            plf = lpItemData->pLogFont;
            *lplf = *plf;                   // copy the LOGFONT
            lplf->lfWidth = 0;              // 1:1 x-y scaling
            if (!lstrcmp(lplf->lfFaceName, TEXT("Small Fonts")) ||
                !lstrcmp(lplf->lfFaceName, TEXT("Lucida Sans Unicode")))
            {
                lplf->lfCharSet = (BYTE) csi.ciCharset;
            }
        }

        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOSTYLESEL;
        }
        nFontType = 0;
    }

    //
    //  Now make sure the size is in range; pts will be 0 if not.
    //
    GetPointSizeInRange(hDlg, lpcf, &pts, 0);

    hdc = GetDC(NULL);
    if (pts)
    {
        if (g_bIsSimplifiedChineseUI)
        {
            UINT iHeight;
            int iLogPixY = GetDeviceCaps(hdc, LOGPIXELSY);
            int ptsfr = pts % 10;          // fractional point size

            pts /= 10;                     // real point size
            iHeight = pts * iLogPixY;
            if (ptsfr)
            {
                iHeight += MulDiv(ptsfr, iLogPixY, 10);
            }
            lplf->lfHeight = -((int)((iHeight + POINTS_PER_INCH / 2) /
                                     POINTS_PER_INCH));
        }
        else
        {
            pts /= 10;
            lplf->lfHeight = -MulDiv( pts,
                                      GetDeviceCaps(hdc, LOGPIXELSY),
                                      POINTS_PER_INCH );
        }
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOSIZESEL;
        }
    }
    else
    {
        lplf->lfHeight = -MulDiv( DEF_POINT_SIZE,
                                  GetDeviceCaps(hdc, LOGPIXELSY),
                                  POINTS_PER_INCH );
        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOSIZESEL;
        }
    }
    ReleaseDC(NULL, hdc);

    //
    //  And the attributes we control.
    //
    lplf->lfStrikeOut = (BYTE)IsDlgButtonChecked(hDlg, chx1);
    lplf->lfUnderline = (BYTE)IsDlgButtonChecked(hDlg, chx2);
    lplf->lfCharSet   = (BYTE) pFI->iCharset;

    if (nFontType != pFI->nLastFontType)
    {
        if (lpcf->Flags & CF_PRINTERFONTS)
        {
            if (nFontType & SIMULATED_FONTTYPE)
            {
                id = iszSynth;
            }
#ifdef WINNT
            else if (nFontType & TT_OPENTYPE_FONTTYPE)
            {
                id = iszTTOpenType;
            }
            else if (nFontType & PS_OPENTYPE_FONTTYPE)
            {
                id = iszPSOpenType;
            }
            else if (nFontType & TYPE1_FONTTYPE)
            {
                id = iszType1;
            }
#endif
            else if (nFontType & TRUETYPE_FONTTYPE)
            {
                id = iszTrueType;
            }
            else if ((nFontType & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) ==
                     (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
            {
                //
                //  May be both screen and printer (ATM) but we'll just
                //  call this a printer font.
                //
                id = iszPrinterFont;
            }
            else if ((nFontType & (PRINTER_FONTTYPE | SCREEN_FONTTYPE)) ==
                     SCREEN_FONTTYPE)
            {
                id = iszGDIFont;
            }
            else
            {
                szMessage[0] = 0;
                goto SetText;
            }
            CDLoadString( g_hinst,
                        id,
                        szMessage,
                        sizeof(szMessage) / sizeof(TCHAR) );
SetText:
            SetDlgItemText(hDlg, stc6, szMessage);
        }
    }

    pFI->nLastFontType = nFontType;

    return (bFontComplete);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLogFont
//
//  Sets the current selection based on the LOGFONT structure passed in.
//
//  lpcf     - CHOOSEFONT structure for the current dialog
//  lplf     - LOGFONT filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the LOGFONT is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the LOGFONT with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL SetLogFont(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf)
{
    *(lpcf->lpLogFont) = *lplf;        // Copies data & FaceName

    FORWARD_WM_COMMAND( hDlg,
                        cmb1,
                        GetDlgItem(hDlg, cmb1),
                        CBN_SELCHANGE,
                        SendMessage );
    return (TRUE);
}

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL SetLogFontEx(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf)
{
    memcpy(lpcf->lpLogFont, lplf, sizeof(ENUMLOGFONTEXDV));

    FORWARD_WM_COMMAND( hDlg,
                        cmb1,
                        GetDlgItem(hDlg, cmb1),
                        CBN_SELCHANGE,
                        SendMessage );
    return (TRUE);
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  TermFont
//
//  Release any data required by functions in this module.
//
////////////////////////////////////////////////////////////////////////////

VOID TermFont()
{
    if (hbmFont)
    {
        DeleteObject(hbmFont);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPointString
//
//  Converts font height into a string of digits representing point size.
//
//  Returns:   Size in points and fills in buffer with string
//
////////////////////////////////////////////////////////////////////////////

int GetPointString(
    LPTSTR buf,
    HDC hDC,
    int height)
{
    int pts;

    if (g_bIsSimplifiedChineseUI)
    {
        int ptsfr, iLogPixY, ctr;
        long lpts;
        BOOL IsZihao = FALSE;

        lpts = ((height < 0) ? -height : height) * 72;

        //
        //  Get real point size.
        //
        pts = (int)(lpts / (iLogPixY = GetDeviceCaps(hDC, LOGPIXELSY)));

        //
        //  Get fractional point size.
        //
        ptsfr = MulDiv((int)(lpts % iLogPixY), 10, iLogPixY);

        //
        //  See if it's Zihao.
        //
        for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
        {
            if ((pts == stZihao[ctr].size) &&
                (abs(ptsfr - stZihao[ctr].sizeFr) <= 3))
            {
                IsZihao = TRUE;
                wsprintf(buf, TEXT("%s"), stZihao[ctr].name);
                break;
            }
        }
        if (!IsZihao)
        {
            pts = MulDiv((height < 0) ? -height : height, 72, iLogPixY);
            for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
            {
                if ((pts == stZihao[ctr].size) && (!stZihao[ctr].sizeFr))
                {
                    IsZihao = TRUE;
                    wsprintf(buf, TEXT("%s"), stZihao[ctr].name);
                    break;
                }
            }
        }
        if (!IsZihao)
        {
            wsprintf(buf, szPtFormat, pts);
        }
    }
    else
    {
        pts = MulDiv( (height < 0) ? -height : height,
                      72,
                      GetDeviceCaps(hDC, LOGPIXELSY) );
        wsprintf(buf, szPtFormat, pts);
    }

    return (pts);
}


////////////////////////////////////////////////////////////////////////////
//
//  FlipColor
//
////////////////////////////////////////////////////////////////////////////

DWORD FlipColor(
    DWORD rgb)
{
    return ( RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)) );
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  This routine loads DIB bitmaps, and "fixes up" their color tables
//  so that we get the desired result for the device we are on.
//
//  This routine requires:
//      the DIB is a 16 color DIB authored with the standard windows colors
//      bright blue (00 00 FF) is converted to the background color
//      light grey  (C0 C0 C0) is replaced with the button face color
//      dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

#define BACKGROUND      0x000000FF          // bright blue
#define BACKGROUNDSEL   0x00FF00FF          // bright blue
#define BUTTONFACE      0x00C0C0C0          // bright grey
#define BUTTONSHADOW    0x00808080          // dark grey

HBITMAP LoadBitmaps(
    int id)
{
    HDC hdc;
    HANDLE h;
    DWORD *p;
    BYTE *lpBits;
    HANDLE hRes;
    LPBITMAPINFOHEADER lpBitmapInfo;
    int numcolors;
    DWORD rgbSelected;
    DWORD rgbUnselected;
    HBITMAP hbm;
    UINT cbBitmapSize;
    LPBITMAPINFOHEADER lpBitmapData;

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(g_hinst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(g_hinst, h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    //
    //  Lock the bitmap data and make a copy of it for the mask and the
    //  bitmap.
    //
    cbBitmapSize = SizeofResource(g_hinst, h);

    lpBitmapData = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbBitmapSize);

    if (!lpBitmapData)
    {
        return (NULL);
    }

    memcpy((TCHAR *)lpBitmapData, (TCHAR *)lpBitmapInfo, cbBitmapSize);

    p = (DWORD *)((LPTSTR)(lpBitmapData) + lpBitmapData->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //
    numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
#if 0
        else if (*p == BUTTONFACE)
        {
            *p = FlipColor(GetSysColor(COLOR_BTNFACE));
        }
        else if (*p == BUTTONSHADOW)
        {
            *p = FlipColor(GetSysColor(COLOR_BTNSHADOW));
        }
#endif
        p++;
    }

    //
    //  First skip over the header structure.
    //
    lpBits = (BYTE *)(lpBitmapData + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapData->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapData,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapData,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    LocalFree(lpBitmapData);

    return (hbm);
}


////////////////////////////////////////////////////////////////////////////
//
//  LookUpFontSubs
//
//  Looks in the font substitute list for a real font name.
//
//  lpSubFontName  - substitute font name
//  lpRealFontName - real font name buffer
//
//  Returns:   TRUE    if lpRealFontName is filled in
//             FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL LookUpFontSubs(LPCTSTR lpSubFontName, LPTSTR lpRealFontName)
{
    LONG lResult;
    HKEY hKey;
    TCHAR szValueName[MAX_PATH];
    TCHAR szValueData[MAX_PATH];
    DWORD dwValueSize;
    DWORD dwIndex = 0;
    DWORD dwType, dwSize;


    //
    //  Open the font substitution's key.
    //
    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            KEY_FONT_SUBS,
                            0,
                            KEY_READ,
                            &hKey );

    if (lResult != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Loop through the values in the key
    //
    dwValueSize = MAX_PATH;
    dwSize = MAX_PATH;
    while (RegEnumValue( hKey,
                         dwIndex,
                         szValueName,
                         &dwValueSize,
                         NULL,
                         &dwType,
                         (LPBYTE)szValueData,
                         &dwSize ) == ERROR_SUCCESS)
    {
        //
        //  If the value name matches the requested font name, then
        //  copy the real font name to the output buffer.
        //
        if (!lstrcmpi(szValueName, lpSubFontName))
        {
            lstrcpy(lpRealFontName, szValueData);
            RegCloseKey(hKey);
            return (TRUE);
        }

        //
        //  Re-initialize for the next time through the loop.
        //
        dwValueSize = MAX_PATH;
        dwSize = MAX_PATH;
        dwIndex++;
    }

    //
    //  Clean up.
    //
    *lpRealFontName = CHAR_NULL;
    RegCloseKey(hKey);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUnicodeSampleText
//
//  Gets the sample text for the font selected in the HDC
//
////////////////////////////////////////////////////////////////////////////
BOOL GetUnicodeSampleText(HDC hdc, LPTSTR lpString, int nMaxCount)
{

    FONTSIGNATURE sig;
    int i, j;
    int iLang = 0;
    int base = 0;
    int mask;


    if (!lpString || !nMaxCount)
    {
        return FALSE;
    }

    //Make sure return value is nulled
    lpString[0] = 0;


    //First Get the Font Signature
    GetTextCharsetInfo(hdc, &sig, 0);

    //Select the first unicode range supported by this font

    //For each of Unicode dwords
    for (i=0; i < 4; i++)
    {
        // See if a particular bit is set
        for (j=0; j < sizeof(DWORD) * 8 ; j++)
        {
             mask =  1 << j;

            if (sig.fsUsb[i] & mask)
            {
                //if set the get the language id for that bit
                iLang = base + j;
                goto LoadString;
            }
        }    
        base +=32;
    }

LoadString:
    //Do we have lang id and  string for that language ?
    if (iLang && LoadString(g_hinst, iszUnicode + iLang, lpString, nMaxCount))
    {
        return TRUE;
    }

    return FALSE;
}

/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseFontA2W
//
////////////////////////////////////////////////////////////////////////////

void ThunkChooseFontA2W(
    PFONTINFO pFI)
{
    LPCHOOSEFONTW pCFW = pFI->pCF;
    LPCHOOSEFONTA pCFA = pFI->pCFA;

    pCFW->hwndOwner = pCFA->hwndOwner;
    pCFW->lCustData = pCFA->lCustData;

    pCFW->Flags = pCFA->Flags;

    //
    //  !!! hack, should not be based on flag value, since this could happen
    //  at any time.
    //
    if (pCFA->Flags & CF_INITTOLOGFONTSTRUCT)
    {
#ifdef MM_DESIGNVECTOR_DEFINED
        if (pFI->pfnCreateFontIndirectEx !=NULL)
        {
            ThunkEnumLogFontExDvA2W( (LPENUMLOGFONTEXDVA)pCFA->lpLogFont, 
                                    (LPENUMLOGFONTEXDVW)pCFW->lpLogFont);
        }
        else
        {
            ThunkLogFontA2W( pCFA->lpLogFont, pCFW->lpLogFont);
        }
#else
        ThunkLogFontA2W( pCFA->lpLogFont, pCFW->lpLogFont);
#endif // MM_DESIGNVECTOR_DEFINED
    }

    pCFW->hInstance = pCFA->hInstance;
    pCFW->lpfnHook = pCFA->lpfnHook;

    if (pCFW->Flags & CF_PRINTERFONTS)
    {
        pCFW->hDC = pCFA->hDC;
    }

    if (pCFW->Flags & CF_USESTYLE)
    {
        RtlAnsiStringToUnicodeString(pFI->pusStyle, pFI->pasStyle, FALSE);
    }

    pCFW->nSizeMin = pCFA->nSizeMin;
    pCFW->nSizeMax = pCFA->nSizeMax;
    pCFW->rgbColors = pCFA->rgbColors;

    pCFW->iPointSize = pCFA->iPointSize;
    pCFW->nFontType = pCFA->nFontType;

}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseFontW2A
//
////////////////////////////////////////////////////////////////////////////

void ThunkChooseFontW2A(
    PFONTINFO pFI)
{
    LPCHOOSEFONTA pCFA = pFI->pCFA;
    LPCHOOSEFONTW pCFW = pFI->pCF;

#ifdef MM_DESIGNVECTOR_DEFINED
    if (pFI->pfnCreateFontIndirectEx !=NULL)
    {
        ThunkEnumLogFontExDvW2A( (LPENUMLOGFONTEXDVW)pCFW->lpLogFont, 
                                (LPENUMLOGFONTEXDVA)pCFA->lpLogFont);
    } 
    else
    {
        ThunkLogFontW2A( pCFW->lpLogFont, pCFA->lpLogFont);
    }
#else
    ThunkLogFontW2A( pCFW->lpLogFont, pCFA->lpLogFont);
#endif // MM_DESIGNVECTOR_DEFINED

    pCFA->hInstance = pCFW->hInstance;
    pCFA->lpfnHook = pCFW->lpfnHook;

    if (pCFA->Flags & CF_USESTYLE)
    {
        pFI->pusStyle->Length = (USHORT)((lstrlen(pFI->pusStyle->Buffer) + 1) * sizeof(WCHAR));
        RtlUnicodeStringToAnsiString(pFI->pasStyle, pFI->pusStyle, FALSE);
    }

    pCFA->Flags = pCFW->Flags;
    pCFA->nSizeMin = pCFW->nSizeMin;
    pCFA->nSizeMax = pCFW->nSizeMax;
    pCFA->rgbColors = pCFW->rgbColors;

    pCFA->iPointSize = pCFW->iPointSize;
    pCFA->nFontType = pCFW->nFontType;
    pCFA->lCustData = pCFW->lCustData;

}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  ThunkEnumLogFontExDvA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkEnumLogFontExDvA2W(
    LPENUMLOGFONTEXDVA lpELFDVA,
    LPENUMLOGFONTEXDVW lpELFDVW)
{
    UINT i;

    ThunkLogFontA2W(&lpELFDVA->elfEnumLogfontEx.elfLogFont,
                    &lpELFDVW->elfEnumLogfontEx.elfLogFont);

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfFullName,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfFullName,
                         LF_FULLFACESIZE );

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfScript,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfScript,
                         LF_FACESIZE );

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfStyle,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfStyle,
                         LF_FACESIZE );

    lpELFDVW->elfDesignVector.dvNumAxes = lpELFDVA->elfDesignVector.dvNumAxes;
    lpELFDVW->elfDesignVector.dvReserved = lpELFDVA->elfDesignVector.dvReserved;

    for (i=0; i<lpELFDVA->elfDesignVector.dvNumAxes; i++)
         lpELFDVW->elfDesignVector.dvValues[i] = lpELFDVA->elfDesignVector.dvValues[i];

}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkEnumLogFontExDvW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkEnumLogFontExDvW2A(
    LPENUMLOGFONTEXDVW lpELFDVW,
    LPENUMLOGFONTEXDVA lpELFDVA)
{
    BOOL fDefCharUsed;
    UINT i;

    if (lpELFDVW && lpELFDVA)
    {
        ThunkLogFontW2A(&lpELFDVW->elfEnumLogfontEx.elfLogFont,
                        &lpELFDVA->elfEnumLogfontEx.elfLogFont);

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfFullName,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfFullName,
                             LF_FULLFACESIZE,
                             NULL,
                             &fDefCharUsed );

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfScript,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfScript,
                             LF_FACESIZE,
                             NULL,
                             &fDefCharUsed );

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfStyle,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfStyle,
                             LF_FACESIZE,
                             NULL,
                             &fDefCharUsed );

        lpELFDVA->elfDesignVector.dvNumAxes = lpELFDVW->elfDesignVector.dvNumAxes;
        lpELFDVA->elfDesignVector.dvReserved = lpELFDVW->elfDesignVector.dvReserved;

        for (i=0; i<lpELFDVW->elfDesignVector.dvNumAxes; i++)
             lpELFDVA->elfDesignVector.dvValues[i] = lpELFDVW->elfDesignVector.dvValues[i];

    }
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  ThunkLogFontA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkLogFontA2W(
    LPLOGFONTA lpLFA,
    LPLOGFONTW lpLFW)
{
    lpLFW->lfHeight = lpLFA->lfHeight;
    lpLFW->lfWidth = lpLFA->lfWidth;
    lpLFW->lfEscapement = lpLFA->lfEscapement;
    lpLFW->lfOrientation = lpLFA->lfOrientation;
    lpLFW->lfWeight = lpLFA->lfWeight;
    lpLFW->lfItalic = lpLFA->lfItalic;
    lpLFW->lfUnderline = lpLFA->lfUnderline;
    lpLFW->lfStrikeOut = lpLFA->lfStrikeOut;
    lpLFW->lfCharSet = lpLFA->lfCharSet;
    lpLFW->lfOutPrecision = lpLFA->lfOutPrecision;
    lpLFW->lfClipPrecision = lpLFA->lfClipPrecision;
    lpLFW->lfQuality = lpLFA->lfQuality;
    lpLFW->lfPitchAndFamily = lpLFA->lfPitchAndFamily;

    SHAnsiToUnicode(lpLFA->lfFaceName,lpLFW->lfFaceName,LF_FACESIZE );
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkLogFontW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkLogFontW2A(
    LPLOGFONTW lpLFW,
    LPLOGFONTA lpLFA)
{

    if (lpLFW && lpLFA)
    {
        lpLFA->lfHeight = lpLFW->lfHeight;
        lpLFA->lfWidth = lpLFW->lfWidth;
        lpLFA->lfEscapement = lpLFW->lfEscapement;
        lpLFA->lfOrientation = lpLFW->lfOrientation;
        lpLFA->lfWeight = lpLFW->lfWeight;
        lpLFA->lfItalic = lpLFW->lfItalic;
        lpLFA->lfUnderline = lpLFW->lfUnderline;
        lpLFA->lfStrikeOut = lpLFW->lfStrikeOut;
        lpLFA->lfCharSet = lpLFW->lfCharSet;
        lpLFA->lfOutPrecision = lpLFW->lfOutPrecision;
        lpLFA->lfClipPrecision = lpLFW->lfClipPrecision;
        lpLFA->lfQuality = lpLFW->lfQuality;
        lpLFA->lfPitchAndFamily = lpLFW->lfPitchAndFamily;

        SHUnicodeToAnsi(lpLFW->lfFaceName,lpLFA->lfFaceName,LF_FACESIZE);
    }
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_CF_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_CF_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PFONTINFO pFI;

    if (pFI = (PFONTINFO)GetProp(hDlg, FONTPROP))
    {
        if (pFI->pCF && pFI->pCFA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkChooseFontA2W(pFI);
            }
            else
            {
                ThunkChooseFontW2A(pFI);
            }
        }
    }
}

#endif // WINNT

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\precomp.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Revision History:

    Lazar Ivanov (LazarI) - created 2/21/2001

--*/

#define _COMDLG32_                     // We are Comdlg32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <lm.h>
#include <winnetwk.h>
#include <winnetp.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellp.h>
#include <shellapi.h>
#include <commctrl.h>
#include <shsemip.h>
#include <coguid.h>
#include <shlguid.h>
#include <shdguid.h>
#include <shguidp.h>
#include <ieguidp.h>
#include <oleguid.h>
#include <commdlg.h>
#include <ole2.h>
#include <dbt.h>
#include <inetreg.h>
#include <sfview.h>
#include <tchar.h>
#include <msprintx.h>
#include <imm.h>
#include <wingdip.h>                    // for IS_ANY_DBCS_CHARSET macro
#include <winspool.h>
#include <commctrl.h>
#include <dlgs.h>
#include <wowcmndg.h>
#include <winuserp.h>
#include <npapi.h>
#include <platform.h>
#include <port32.h>
#include <ccstock.h>
#include <wininet.h>

#ifdef __cplusplus                      // C++ headers
#include <dpa.h>
#include <shstr.h>
#endif

#include "comdlg32.h"                   // some private common definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\isz.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    isz.h

Abstract:

    This module contains the string resource IDs for the common dialogs.

Revision History:

--*/



//
//  0x0000 - 0x00ff Error codes.
//


//
//  MESSAGES:  0x0100 to 0x01ff.
//
#define iszOverwriteCaption       0x0100
#define iszOverwriteQuestion      0x0101
#define iszDefExitCaption         0x0102
#define iszDefExitText            0x0103

#define iszDefaultPitch           0x0104
#define iszFixedPitch             0x0105
#define iszVariablePitch          0x0106
#define iszAnsiCharset            0x0107
#define iszOemCharset             0x0108
#define iszSymbolCharset          0x0109
#define iszDecorativeFamily       0x010a
#define iszUnknownFamily          0x010b
#define iszModernFamily           0x010c
#define iszRomanFamily            0x010d
#define iszScriptFamily           0x010e
#define iszSwissFamily            0x010f

#define iszSystemFont             0x0110
#define iszHelvFont               0x0111
#define iszCourierFont            0x0112
#define iszTmsRmnFont             0x0113
#define iszSymbolFont             0x0114
#define iszRomanFont              0x0115
#define iszScriptFont             0x0116
#define iszModernFont             0x0117
#define iszLastFont               iszModernFont

#define iszFileSaveIn             0x0170
#define iszFileSaveButton         0x0171
#define iszFileOpenButton         0x0172
#define iszPrintButton            0x0173

#define iszFileOpenTitle          0x0180
#define iszFileSaveTitle          0x0181
#define iszSaveFileAsType         0x0182
#define iszDriveDoesNotExist      0x0183
#define iszNoDiskInDrive          0x0184
#define iszWrongDiskInDrive       0x0185
#define iszUnformatedDisk         0x0186
#define iszFileNotFound           0x0187
#define iszPathNotFound           0x0188
#define iszInvalidFileName        0x0189
#define iszSharingViolation       0x018A
#define iszNetworkAccessDenied    0x018B
#define iszReadOnly               0x018C
#define iszInt24Error             0x018D
#define iszPortName               0x018E
#define iszWriteProtection        0x018F
#define iszDiskFull               0x0190
#define iszNoFileHandles          0x0191
#define iszCreatePrompt           0x0192
#define iszCreateNoModify         0x0193
#define iszSelectDriveTrouble     0x0194
#define iszNoNetButtonResponse    0x0195
#define iszFileAccessDenied       0x0196
#define iszDirAccessDenied        0x0197
#define iszNoDiskInCDRom          0x0198
#define iszNetworkButtonText      0x0199
#define iszNetworkButtonTextAccel 0x019A
#define iszTooManyFiles           0x019B
#define iszSaveAsType             0x019C

#define iszObjectName             0x01A2
#define iszObjectType             0x01A3
#define iszSaveRestricted         0x01A4
#define iszNoSaveToURL            0x01A5
#define iszPrinterDeleted         0x01A6
#define iszDirSaveAccessDenied    0x01A7

//
//  RESOURCES:  0x0200 to 0x020f.
//
//     Menus:           0x0200 to 0x020f
//     Icons:           0x0210 to 0x021f
//     Cursors:         0x0220 to 0x022f
//     Accelerators:    0x0230 to 0x023f
//     Bitmaps:         0x0240 to 0x024f
//     Private:         0x0250 to 0x025f
//
#define ICO_PORTRAIT              0x0210
#define ICO_LANDSCAPE             0x0211
#define ICO_P_NONE                0x0212
#define ICO_L_NONE                0x0213
#define ICO_P_HORIZ               0x0214
#define ICO_L_HORIZ               0x0215
#define ICO_P_VERT                0x0216
#define ICO_L_VERT                0x0217
#define ICO_COLLATE               0x0218
#define ICO_NO_COLLATE            0x0219
#define ICO_P_PSSTAMP             0x021a
#define ICO_L_PSSTAMP             0x021b
#define ICO_PRINTER               0x021c

#define bmpDirDrive               576


//
//  DIALOGS:  0x0300 to 0x03ff.
//
#define dlgFileOpen               0x0300
#define dlgFileSave               0x0301
#define dlgExitChanges            0x0302
#define dlgChooseColor            0x0303
#define dlgFindText               0x0304
#define dlgReplaceText            0x0305
#define dlgFormatChar             0x0306
#define dlgFontInfo               0x0307
#define dlgPrintDlg               0x0308
#define dlgPrintSetupDlg          0x0309
#define dlgMultiFileOpen          0x030a


//
//  MISC:  0x0400 to 0x06ff.
//
#define BMFONT                    38

#define iszClose                  0x040d   // "Close" text for find/replace


#define iszBlack                  0x0410
#define iszDkRed                  0x0411
#define iszDkGreen                0x0412
#define iszDkYellow               0x0413
#define iszDkBlue                 0x0414
#define iszDkPurple               0x0415
#define iszDkAqua                 0x0416
#define iszDkGrey                 0x0417
#define iszLtGrey                 0x0418
#define iszLtRed                  0x0419
#define iszLtGreen                0x041a
#define iszLtYellow               0x041b
#define iszLtBlue                 0x041c
#define iszLtPurple               0x041d
#define iszLtAqua                 0x041e
#define iszWhite                  0x041f

#define iszHighPrnQ               0x0430
#define iszMedPrnQ                0x0431
#define iszLowPrnQ                0x0432
#define iszDraftPrnQ              0x0433

#define iszPrinter                0x0440
#define iszSysPrn                 0x0441
#define iszPrnOnPort              0x0442
#define iszDefCurOn               0x0443

#define iszSizeNumber             0x044A
#define iszSizeRange              0x044B
#define iszSynth                  0x044C
#define iszTrueType               0x044D
#define iszPrinterFont            0x044E
#define iszGDIFont                0x044F

#ifdef WINNT
#define iszTTOpenType             0x0470
#define iszPSOpenType             0x0471
#define iszType1                  0x0472
#endif

#define iszPageRangeError         0x0450
#define iszFromToError            0x0451
#define iszPageFromError          0x0452
#define iszPageToError            0x0453
#define iszBadMarginError         0x0454
#define iszCopiesZero             0x0455
#define iszTooManyCopies          0x0456
#define iszWarningTitle           0x0457
#define iszNoPrnsInstalled        0x0458
#define iszPrnNotFound            0x0459
#define iszMemoryError            0x045A
#define iszGeneralWarning         0x045B
#define iszUnknownDriver          0x045C
#define iszBadPageRange           0x045D
#define iszTooManyPageRanges      0x045E
#define iszBadPageRangeSyntaxOld  0x045F
#define iszBadPageRangeSyntaxNew  0x0460
#define iszNoPrinters             0x0461
//  Empty                         0x0462
#define iszNoPrinterSelected      0x0463
#define iszDefaultMenuText        0x0464
#define iszNoPrinterAccess        0x0465

#define iszNoFontsTitle           0x0500
#define iszNoFontsMsg             0x0501
#define iszNoFaceSel              0x0502
#define iszNoStyleSel             0x0503
#define iszRegular                0x0504
#define iszBold                   0x0505
#define iszItalic                 0x0506
#define iszBoldItalic             0x0507
#define iszNoScript               0x0508

//
//  CCHSTYLE is the max allowed length of iszRegular to iszBoldItalic strings
//
#define CCHSTYLE                  32


#define iszStatusReady            0x0600

#define iszStatusPaused           0x0601
#define iszStatusError            0x0602
#define iszStatusPendingDeletion  0x0603
#define iszStatusPaperJam         0x0604
#define iszStatusPaperOut         0x0605
#define iszStatusManualFeed       0x0606
#define iszStatusPaperProblem     0x0607
#define iszStatusOffline          0x0608
#define iszStatusIOActive         0x0609
#define iszStatusBusy             0x060A
#define iszStatusPrinting         0x060B
#define iszStatusOutputBinFull    0x060C
#define iszStatusNotAvailable     0x060D
#define iszStatusWaiting          0x060E
#define iszStatusProcessing       0x060F
#define iszStatusInitializing     0x0610
#define iszStatusWarmingUp        0x0611
#define iszStatusTonerLow         0x0612
#define iszStatusNoToner          0x0613
#define iszStatusPagePunt         0x0614
#define iszStatusUserIntervention 0x0615
#define iszStatusOutOfMemory      0x0616
#define iszStatusDoorOpen         0x0617

#define iszStatusDocumentsWaiting 0x062F
#define iszStatusDefaultPrinter   0x062E

#define iszPrintRangeAll          0x0630

#define iszMarginsInches          0x0631
#define iszMarginsMillimeters     0x0632
#define iszInches                 0x0633
#define iszMillimeters            0x0634
#define iszDefaultSource          0x0635

#define iszGeneralPage            0x0640
#define iszPrintCaption           0x0641


//
//  FONT SAMPLES:  0x0700 to 0x07ff.
//
#define iszFontSample               0x0700

//Unicode Font Samples
#define iszUnicode                  0x0800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\printnew.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.cpp

Abstract:

    This module implements the Win32 property sheet print dialogs.

Revision History:

    11-04-97    JulieB    Created.
    Feb-2000    LazarI    major redesign (not to use printui anymore)
    Oct-2000    LazarI    messages cleanup & redesign

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "prnsetup.h"
#include "printnew.h"
#include "util.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif // ARRAYSIZE

inline static HRESULT CreateError()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

//
//  Constant Declarations.
//

#define CDM_SELCHANGE             (CDM_LAST + 102)
#define CDM_PRINTNOTIFY           (CDM_LAST + 103)
#define CDM_NOPRINTERS            (CDM_LAST + 104)
#define CDM_INITDONE              (CDM_LAST + 105)

#define PRINTERS_ICOL_NAME        0
#define PRINTERS_ICOL_QUEUESIZE   1
#define PRINTERS_ICOL_STATUS      2
#define PRINTERS_ICOL_COMMENT     3
#define PRINTERS_ICOL_LOCATION    4
#define PRINTERS_ICOL_MODEL       5

#define SZ_PRINTUI                TEXT("printui.dll")

//
// Default view mode value
//
#define VIEW_MODE_DEFAULT         (UINT )(-1)

//
//  Macro Definitions.
//

#define Print_HwndToBrowser(hwnd)      ((CPrintBrowser *)GetWindowLongPtr(hwnd, DWLP_USER))
#define Print_StoreBrowser(hwnd, pbrs) (SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pbrs))
#define Print_IsInRange(id, idFirst, idLast) \
    ((UINT)((id) - idFirst) <= (UINT)(idLast - idFirst))




//
//  Global Variables.
//

HWND g_hwndActivePrint = NULL;
HACCEL g_haccPrint = NULL;
HHOOK g_hHook = NULL;
int g_nHookRef = -1;



//
//  Extern Declarations.
//

extern HWND
GetFocusedChild(
    HWND hwndDlg,
    HWND hwndFocus);

extern void
GetViewItemText(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPTSTR pBuf,
    UINT cchBuf,
    DWORD dwFlags);


// Frees up the PIDL using the shell allocator
static void FreePIDL(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        LPMALLOC pShellMalloc;
        if (SUCCEEDED(SHGetMalloc(&pShellMalloc)))
        {
            pShellMalloc->Free(pidl);
            pShellMalloc->Release();
        }
    }
}

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExA
//
//  ANSI entry point for PrintDlgEx when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgExA(
    LPPRINTDLGEXA pPDA)
{
#ifdef WINNT
    PRINTINFOEX PI;
    HRESULT hResult;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    hResult = ThunkPrintDlgEx(&PI, pPDA);
    if (SUCCEEDED(hResult))
    {
        ThunkPrintDlgExA2W(&PI);

        hResult = PrintDlgExX(&PI);

        ThunkPrintDlgExW2A(&PI);
    }
    FreeThunkPrintDlgEx(&PI);

    return (hResult);
#else
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
#endif
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExW
//
//  Stub UNICODE function for PrintDlgEx when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgExW(
    LPPRINTDLGEXW pPDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgEx
//
//  The PrintDlgEx function displays a Print dialog that enables the
//  user to specify the properties of a particular print job.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgEx(
    LPPRINTDLGEX pPD)
{
#ifdef WINNT
    PRINTINFOEX PI;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgExX(&PI) );
#else
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
#endif
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExX
//
//  Worker routine for the PrintDlgEx api.
//
////////////////////////////////////////////////////////////////////////////

HRESULT PrintDlgExX(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    BOOL hResult;
    DWORD dwFlags;
    DWORD nCopies;
    LPPRINTPAGERANGE pPageRanges;
    DWORD nFromPage, nToPage;
    UINT Ctr;
    BOOL bHooked = FALSE;

    //
    //  Make sure the print dlg structure exists and that we're not being
    //  called from a wow app.
    //
    if ((!pPD) || (IS16BITWOWAPP(pPD)))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the size of the print dlg structure is valid.
    //
    if (pPD->lStructSize != sizeof(PRINTDLGEX))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the owner window exists and  is valid.
    //
    if (!pPD->hwndOwner || !IsWindow(pPD->hwndOwner))
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure only valid flags are passed into this routine.
    //
    if ((pPD->Flags & ~(PD_ALLPAGES                   |
                        PD_SELECTION                  |
                        PD_PAGENUMS                   |
                        PD_NOSELECTION                |
                        PD_NOPAGENUMS                 |
                        PD_COLLATE                    |
                        PD_PRINTTOFILE                |
                        PD_NOWARNING                  |
                        PD_RETURNDC                   |
                        PD_RETURNIC                   |
                        PD_RETURNDEFAULT              |
                        PD_ENABLEPRINTTEMPLATE        |
                        PD_ENABLEPRINTTEMPLATEHANDLE  |
                        PD_USEDEVMODECOPIESANDCOLLATE |
                        PD_DISABLEPRINTTOFILE         |
                        PD_HIDEPRINTTOFILE            |
                        PD_CURRENTPAGE                |
                        PD_NOCURRENTPAGE              |
                        PD_EXCLUSIONFLAGS             |
                        PD_USELARGETEMPLATE           |
                        CD_WX86APP)) ||
        (pPD->Flags2 != 0) ||
        (pPD->ExclusionFlags & ~(PD_EXCL_COPIESANDCOLLATE)) ||
        (pPD->dwResultAction != 0))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the template settings as much as we can here.
    //
    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
    {
        if (!pPD->lpPrintTemplateName)
        {
            pPI->dwExtendedError = CDERR_NOTEMPLATE;
            return (E_POINTER);
        }
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else
    {
        if (pPD->lpPrintTemplateName || pPD->hInstance)
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }
    }

    //
    //  Check the application property pages and the start page value.
    //
    if ((pPD->nPropertyPages && (pPD->lphPropertyPages == NULL)) ||
        ((pPD->nStartPage != START_PAGE_GENERAL) &&
         (pPD->nStartPage >= pPD->nPropertyPages)))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the page range boundaries if the PD_NOPAGENUMS flag is
    //  not set.
    //
    if (!(pPD->Flags & PD_NOPAGENUMS))
    {
        if ((pPD->nMinPage > pPD->nMaxPage) ||
            (pPD->nPageRanges > pPD->nMaxPageRanges) ||
            (pPD->nMaxPageRanges == 0) ||
            ((pPD->nMaxPageRanges) && (!pPD->lpPageRanges)))
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }

        //
        //  Check each of the given ranges.
        //
        pPageRanges = pPD->lpPageRanges;
        for (Ctr = 0; Ctr < pPD->nPageRanges; Ctr++)
        {
            //
            //  Get the range.
            //
            nFromPage = pPageRanges[Ctr].nFromPage;
            nToPage   = pPageRanges[Ctr].nToPage;

            //
            //  Make sure the range is valid.
            //
            if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
                (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                return (E_INVALIDARG);
            }
        }
    }

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

    //
    //  Init hDC.
    //
    pPD->hDC = 0;

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        return (Print_ReturnDefault(pPI));
    }

    //
    //  Load the necessary libraries.
    //
    if (!Print_LoadLibraries())
    {
        pPI->dwExtendedError = PDERR_LOADDRVFAILURE;
        hResult = CreateError();
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Load the necessary icons.
    //
    if (!Print_LoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        pPI->dwExtendedError = PDERR_SETUPFAILURE;
        hResult = CreateError();
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Make sure the page ranges info is valid.
    //
    if ((!(pPD->Flags & PD_NOPAGENUMS)) &&
        ((pPD->nMinPage > pPD->nMaxPage) ||
         (pPD->nPageRanges > pPD->nMaxPageRanges) ||
         (pPD->nMaxPageRanges == 0) ||
         ((pPD->nMaxPageRanges) && (!(pPD->lpPageRanges)))))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Save the original information passed in by the app in case the
    //  user hits cancel.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be saved.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    pPI->dwFlags = dwFlags;

    //
    //  Set up the hook proc for input event messages.
    //
    if (InterlockedIncrement((LPLONG)&g_nHookRef) == 0)
    {
        g_hHook = SetWindowsHookEx( WH_MSGFILTER,
                                    Print_MessageHookProc,
                                    0,
                                    GetCurrentThreadId() );
        if (g_hHook)
        {
            bHooked = TRUE;
        }
        else
        {
            --g_nHookRef;
        }
    }
    else
    {
        bHooked = TRUE;
    }

    //
    //  Load the print folder accelerators.
    //
    if (!g_haccPrint)
    {
        g_haccPrint = LoadAccelerators( g_hinst,
                                        MAKEINTRESOURCE(IDA_PRINTFOLDER) );
    }

    //
    //  Initialize the error codes to failure in case we die before we
    //  actually bring up the property pages.
    //
    pPI->dwExtendedError = CDERR_INITIALIZATION;
    pPI->hResult = E_FAIL;
    pPI->hrOleInit = E_FAIL;

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    //
    //  Bring up the dialog.
    //
    Print_InvokePropertySheets(pPI, pPD);

    hResult = pPI->hResult;


    //Ole Would have been initialized during the WM_INITDIALOG processing. 
    // Uninitialize Ole Now

    SHOleUninitialize(pPI->hrOleInit);

    //
    //  Unhook the input event messages.
    //
    if (bHooked)
    {
        //
        //  Put this in a local so we don't need a critical section.
        //
        HHOOK hHook = g_hHook;

        if (InterlockedDecrement((LPLONG)&g_nHookRef) < 0)
        {
            UnhookWindowsHookEx(hHook);
        }
    }

    //
    //  If the user hit cancel or if there was an error, restore the original
    //  values passed in by the app.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be restored here.
    //
    if ((pPI->FinalResult == 0) && (!pPI->fApply))
    {
        pPD->Flags   = dwFlags;
        pPD->nCopies = nCopies;
    }

    //
    //  See if we need to fill in the dwResultAction member field.
    //
    if (SUCCEEDED(hResult))
    {
        if (pPI->FinalResult != 0)
        {
            pPD->dwResultAction = PD_RESULT_PRINT;
        }
        else if (pPI->fApply)
        {
            pPD->dwResultAction = PD_RESULT_APPLY;
        }
        else
        {
            pPD->dwResultAction = PD_RESULT_CANCEL;
        }
    }

    //
    //  Display any error messages.
    //
PrintDlgExX_DisplayWarning:

    if ((!(dwFlags & PD_NOWARNING)) && FAILED(hResult) &&
        (pPI->ProcessVersion >= 0x40000))
    {
        TCHAR szWarning[SCRATCHBUF_SIZE];
        TCHAR szTitle[SCRATCHBUF_SIZE];
        int iszWarning;

        szTitle[0] = TEXT('\0');
        if (pPD->hwndOwner)
        {
            GetWindowText(pPD->hwndOwner, szTitle, SCRATCHBUF_SIZE);
        }
        if (!szTitle[0])
        {
            CDLoadString(g_hinst, iszWarningTitle, szTitle, SCRATCHBUF_SIZE);
        }

        switch (hResult)
        {
            case ( E_OUTOFMEMORY ) :
            {
                iszWarning = iszMemoryError;
                break;
            }
            default :
            {
                iszWarning = iszGeneralWarning;
                break;
            }
        }

        CDLoadString(g_hinst, iszWarning, szWarning, SCRATCHBUF_SIZE);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox( pPD->hwndOwner,
                    szWarning,
                    szTitle,
                    MB_ICONEXCLAMATION | MB_OK );
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ReturnDefault
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ReturnDefault(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    TCHAR szPrinterName[MAX_PATH];
    LPDEVNAMES pDN;
    LPDEVMODE pDM;

    //
    //  Initialize the error code to 0.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;

    //
    //  Make sure the hDevMode and hDevNames fields are NULL.
    //
    if (pPD->hDevMode || pPD->hDevNames)
    {
        pPI->dwExtendedError = PDERR_RETDEFFAILURE;
        return (E_HANDLE);
    }

    //
    //  Get the default printer name.
    //
    szPrinterName[0] = 0;
    PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
    if (szPrinterName[0] == 0)
    {
        pPI->dwExtendedError = PDERR_NODEFAULTPRN;
        return (E_FAIL);
    }

    //
    //  Allocate and fill in the DevNames structure.
    //
    if (!Print_SaveDevNames(szPrinterName, pPD))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return CreateError();
    }

    //
    //  Allocate and fill in the DevMode structure.
    //
    pPD->hDevMode = Print_GetDevModeWrapper(szPrinterName, NULL);

    //
    //  Get the device or information context, depending on which one
    //  was requested (if any).
    //
    if ((pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (S_OK);
        }
        else
        {
            GlobalUnlock(pPD->hDevNames);
        }
    }

    //
    //  Make sure the pointers are NULL since we failed.
    //
    if (pPD->hDevNames)
    {
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Return failure.
    //
    pPI->dwExtendedError = PDERR_NODEFAULTPRN;
    return (E_FAIL);
}

typedef BOOL (*PFN_bPrinterSetup)(
    HWND hwnd,                  // handle to parent window 
    UINT uAction,               // setup action
    UINT cchPrinterName,        // size of pszPrinterName buffer in characters
    LPTSTR pszPrinterName,      // in/out buffer for the printer name
    UINT *pcchPrinterName,      // out buffer where we put the required number of characters
    LPCTSTR  pszServerName      // server name
    );

typedef LONG (*PFN_DocumentPropertiesWrap)(
    HWND hwnd,                  // handle to parent window 
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    );

EXTERN_C CRITICAL_SECTION g_csLocal;
static HINSTANCE hPrintUI = NULL;
static PFN_bPrinterSetup g_pfnPrinterSetup = NULL;
static PFN_DocumentPropertiesWrap g_pfnDocumentPropertiesWrap = NULL;

////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadLibraries
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadLibraries()
{
    //
    // Make sure we hold the global CS while initializing 
    // the global variables.
    //
    EnterCriticalSection(&g_csLocal);

    //
    //  Load PrintUI.
    //
    if (!hPrintUI)
    {
        if ((hPrintUI = LoadLibrary(SZ_PRINTUI)))
        {
            //
            // Get the proc addresses of bPrinterSetup private API.
            //
            g_pfnPrinterSetup = (PFN_bPrinterSetup)GetProcAddress(hPrintUI, "bPrinterSetup");
            g_pfnDocumentPropertiesWrap = (PFN_DocumentPropertiesWrap)GetProcAddress(hPrintUI, "DocumentPropertiesWrap");

            if (NULL == g_pfnPrinterSetup || NULL == g_pfnDocumentPropertiesWrap)
            {
                // failed to get addresses of core printui APIs
                FreeLibrary(hPrintUI);
                hPrintUI = NULL;
            }
        }
    }

    //
    //  Leave the global CS.
    //
    LeaveCriticalSection(&g_csLocal);

    //
    //  Return the result.
    //
    return (hPrintUI != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_UnloadLibraries
//
////////////////////////////////////////////////////////////////////////////

VOID Print_UnloadLibraries()
{
    if (hPrintUI)
    {
        FreeLibrary(hPrintUI);
        hPrintUI = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadIcons()
{
    //
    //  Load the collation images.
    //
    hIconCollate = LoadImage( g_hinst,
                              MAKEINTRESOURCE(ICO_COLLATE),
                              IMAGE_ICON,
                              0,
                              0,
                              LR_SHARED);
    hIconNoCollate = LoadImage( g_hinst,
                                MAKEINTRESOURCE(ICO_NO_COLLATE),
                                IMAGE_ICON,
                                0,
                                0,
                               LR_SHARED);

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (hIconCollate && hIconNoCollate);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InvokePropertySheets
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD)
{
    BOOL bResult = FALSE;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszCaption[MAX_PATH];
    DWORD dwExclusionFlags;
    HANDLE hTemplate = NULL;
    HRSRC hRes;
    LANGID LangID;

    if (GET_BIDI_LOCALIZED_SYSTEM_LANGID(NULL)) {

        if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
        {
            hTemplate = pPD->hInstance;
        }
        else
        {
            if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
            {
                hRes = FindResource(pPD->hInstance, pPD->lpPrintTemplateName, RT_DIALOG);
                if (hRes) {
                    hTemplate = LoadResource(pPD->hInstance, hRes);
                }
            }
        }
        //
        // Warning! Warning! Warning!
        //
        // We have to set g_tlsLangID before any call for CDLoadString
        //
        TlsSetValue(g_tlsLangID, (LPVOID) GetDialogLanguage(pPD->hwndOwner, hTemplate));
    }

    //
    //  Load all of the necessary strings.
    //
    CDLoadString(g_hinst, iszGeneralPage, pszTitle, ARRAYSIZE(pszTitle));
    CDLoadString(g_hinst, iszPrintCaption, pszCaption, ARRAYSIZE(pszCaption));

    //
    //  See if the exclusion flags are set properly.
    //
    if (!(pPD->Flags & PD_EXCLUSIONFLAGS))
    {
        pPD->ExclusionFlags = PD_EXCL_COPIESANDCOLLATE;
    }
    dwExclusionFlags = pPD->ExclusionFlags;

    //
    //  Set up the General page.
    //
    PROPSHEETPAGE genPage = {0};

    genPage.dwSize      = sizeof(PROPSHEETPAGE);
    genPage.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    genPage.hInstance   = g_hinst;
    genPage.pszTemplate = (pPD->Flags & PD_USELARGETEMPLATE) ? MAKEINTRESOURCE(IDD_PRINT_GENERAL_LARGE)
                                                               : MAKEINTRESOURCE(IDD_PRINT_GENERAL);
    LangID = (LANGID)TlsGetValue(g_tlsLangID);
    if (LangID) {
        hRes = FindResourceExFallback(g_hinst, RT_DIALOG, genPage.pszTemplate, LangID);
        if (hRes) {
            if ((hTemplate = LoadResource(g_hinst, hRes)) &&
                LockResource(hTemplate)) {
                genPage.dwFlags   |= PSP_DLGINDIRECT;
                genPage.pResource  = (LPCDLGTEMPLATE)hTemplate;
            }
        }
    }

    genPage.pszIcon     = NULL;
    genPage.pszTitle    = pszTitle;
    genPage.pfnDlgProc  = Print_GeneralDlgProc;
    genPage.lParam      = (LPARAM)pPI;
    genPage.pfnCallback = NULL;
    genPage.pcRefParent = NULL;

    HPROPSHEETPAGE hGenPage = CreatePropertySheetPage( &genPage );

    if( hGenPage )
    {
        //
        //  Initialize the property sheet header.
        //
        PROPSHEETHEADER psh = {0};
        psh.dwSize          = sizeof(psh);

        psh.dwFlags         = pPI->fOld ? PSH_USEICONID | PSH_NOAPPLYNOW  : PSH_USEICONID;
        psh.hwndParent      = pPD->hwndOwner;
        psh.hInstance       = g_hinst;
        psh.pszIcon         = MAKEINTRESOURCE(ICO_PRINTER);
        psh.pszCaption      = pszCaption;
        psh.nPages          = pPD->nPropertyPages + 1;

        psh.phpage          = new HPROPSHEETPAGE[ psh.nPages ];

        if( psh.phpage )
        {
            psh.phpage[0] = hGenPage;
            memcpy( psh.phpage+1, pPD->lphPropertyPages, pPD->nPropertyPages * sizeof(psh.phpage[0]) );

            //
            // Bring up the property sheet pages.
            //
            bResult = (-1 != PropertySheet(&psh));
        }
        else
        {
            pPI->hResult = E_OUTOFMEMORY;
        }
    }
    else
    {
        pPI->hResult = CreateError();
    }

    //
    //  Return the result.
    //
    return (bResult);
}


LRESULT CALLBACK PrshtSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LRESULT lres;


    switch (wm)
    {
        case WM_NCDESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hwnd, PrshtSubclassProc, 0);
            lres = DefSubclassProc(hwnd, wm, wp, lp);
            break;

        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lp)->hItemHandle;

            if (hwndItem == GetDlgItem(hwnd, IDOK))
            {
                WinHelp( hwndItem,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aPrintExHelpIDs );

                lres = TRUE;
            }
            else
            {
                lres = DefSubclassProc(hwnd, wm, wp, lp);
            }

            break;

        }

        case ( WM_CONTEXTMENU ) :
        {
            if ((HWND)wp == GetDlgItem(hwnd, IDOK))
            {
                WinHelp( (HWND)wp,
                         NULL,
                         HELP_CONTEXTMENU,
                        (ULONG_PTR)(LPVOID)aPrintExHelpIDs );

                lres = TRUE;
            }
            else
            {
                lres = DefSubclassProc(hwnd, wm, wp, lp);
            }
            break;
        }

        default:
            lres = DefSubclassProc(hwnd, wm, wp, lp);
            break;
    }

    return lres;
}

////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CPrintBrowser *pDlgStruct = NULL;

    if (uMsg != WM_INITDIALOG)
    {
        pDlgStruct = Print_HwndToBrowser(hDlg);
    }

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Print_InitDialog(hDlg, wParam, lParam))
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
            g_hwndActivePrint = hDlg;

            //Subclass the Main Property sheet for Help Messages
            SetWindowSubclass(GetParent(hDlg), PrshtSubclassProc, 0, 0);
            break;
        }
        case ( WM_NCDESTROY ) :
        {
            Print_StoreBrowser(hDlg, NULL);

            if (pDlgStruct)
            {
                pDlgStruct->OnDestroyMessage();
                pDlgStruct->Release();
            }
            break;
        }
        case ( WM_ERASEBKGND ) :
        {
            //
            // This code is to workaround: Windows NT Bugs#344991
            //
            HWND hwndView = GetDlgItem(hDlg, IDC_PRINTER_LISTVIEW);
            if (hwndView)
            {
                //
                //  Get the printer folder view rect.
                //
                RECT rcView;
                if (GetWindowRect(hwndView, &rcView))
                {
                    MapWindowRect(HWND_DESKTOP, hDlg, &rcView);

                    //
                    // Exclude the printer folder view rect from the cliping region.
                    //
                    if (ERROR == ExcludeClipRect(reinterpret_cast<HDC>(wParam),
                        rcView.left, rcView.top, rcView.right, rcView.bottom))
                    {
                        ASSERT(FALSE);
                    }
                }
            }
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (wParam == WA_INACTIVE)
            {
                //
                //  Make sure some other Print dialog has not already grabbed
                //  the focus.  This is a process global, so it should not
                //  need to be protected.
                //
                if (g_hwndActivePrint == hDlg)
                {
                    g_hwndActivePrint = NULL;
                }
            }
            else
            {
                g_hwndActivePrint = hDlg;
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnNotifyMessage(wParam, (LPNMHDR)lParam));
            }
            break;
        }
        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;

            //
            //  We assume that the defview has one child window that
            //  covers the entire defview window.
            //
            HWND hwndDefView = GetDlgItem(hDlg, IDC_PRINTER_LISTVIEW);
            if (GetParent(hwndItem) == hwndDefView)
            {
                hwndItem = hwndDefView;
            }

            WinHelp( hwndItem,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( CWM_GETISHELLBROWSER ) :
        {
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LRESULT)pDlgStruct);
            return (TRUE);
        }
        case ( CDM_SELCHANGE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnSelChange();
            }
            break;
        }
        case ( CDM_PRINTNOTIFY ) :
        {
            if (pDlgStruct)
            {
                LPITEMIDLIST *ppidl;
                LONG lEvent;
                BOOL bRet = FALSE;
                LPSHChangeNotificationLock pLock;

                //
                //  Get the change notification info from the shared memory
                //  block identified by the handle passed in the wParam.
                //
                pLock = SHChangeNotification_Lock( (HANDLE)wParam,
                                                   (DWORD)lParam,
                                                   &ppidl,
                                                   &lEvent );
                if (pLock == NULL)
                {
                    return (FALSE);
                }

                //
                //  Handle the change notification.
                //
                bRet = pDlgStruct->OnChangeNotify( lEvent,
                                                   (LPCITEMIDLIST *)ppidl );

                //
                //  Release the shared block.
                //
                SHChangeNotification_Unlock(pLock);

                //
                //  Return the result.
                //
                return (bRet);
            }
            break;
        }
        case ( CDM_NOPRINTERS ) :
        {
            //
            //  There are no printers, so bring up the dialog telling the
            //  user that they need to install a printer.
            //
            if (pDlgStruct)
            {
                pDlgStruct->OnNoPrinters((HWND)wParam, (UINT)lParam);
            }
        }
        case ( CDM_INITDONE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnInitDone();
            }
            break;
        }

        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralChildDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lResult = FALSE;
    CPrintBrowser *pDlgStruct = Print_HwndToBrowser(GetParent(hDlg));

    //
    //  See if we need to call an application callback to handle the
    //  message.
    //
    if (pDlgStruct)
    {
        if (pDlgStruct->HandleMessage(hDlg, uMsg, wParam, lParam, &lResult) != S_FALSE)
        {
            if (uMsg == WM_INITDIALOG)
            {
                PostMessage(GetParent(hDlg), CDM_INITDONE, 0, 0);
            }

            // 
            // BUGBUG: The return from a dlgproc is different than a winproc.
            //

            return (BOOLFROMPTR(lResult));

        }
    }

    //
    //  If we get to this point, we need to handle the message.
    //
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (pDlgStruct)
            {
                if (!pDlgStruct->OnChildInitDialog(hDlg, wParam, lParam))
                {
                    PropSheet_PressButton( GetParent(GetParent(hDlg)),
                                           PSBTN_CANCEL );
                }
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnChildCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExChildHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExChildHelpIDs );

            return (TRUE);
        }
        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_MessageHookProc
//
//  Handles the input event messages.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    PMSG pMsg;

    //
    //  See if the nCode is negative.  If so, call the default hook proc.
    //
    if (nCode < 0)
    {
        return (DefHookProc(nCode, wParam, lParam, &g_hHook));
    }

    //
    //  Make sure we only handle dialog box messages.
    //
    if (nCode != MSGF_DIALOGBOX)
    {
        return (0);
    }

    //
    //  Get the msg structure.
    //
    pMsg = (PMSG)lParam;

    //
    //  Make sure the message is one of the WM_KEY* messages.
    //
    if (Print_IsInRange(pMsg->message, WM_KEYFIRST, WM_KEYLAST))
    {
        HWND hwndActivePrint = g_hwndActivePrint;
        HWND hwndFocus = GetFocusedChild(hwndActivePrint, pMsg->hwnd);
        CPrintBrowser *pDlgStruct;

        if (hwndFocus &&
            (pDlgStruct = Print_HwndToBrowser(hwndActivePrint)) != NULL)
        {
            return (pDlgStruct->OnAccelerator( hwndActivePrint,
                                               hwndFocus,
                                               g_haccPrint,
                                               pMsg ));
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InitDialog
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    //  Create the CPrintBrowser object and store it in DWL_USER.
    //
    CPrintBrowser *pDlgStruct = new CPrintBrowser(hDlg);
    if (pDlgStruct == NULL)
    {
        return (FALSE);
    }
    Print_StoreBrowser(hDlg, pDlgStruct);

    //
    //  Let the class function do the work.
    //
    return (pDlgStruct->OnInitDialog(wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ICoCreateInstance
//
//  Create an instance of the specified shell class.
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPCITEMIDLIST pidl,
    LPVOID *ppv)
{
    LPSHELLFOLDER pshf = NULL;
    HRESULT hres = E_FAIL;

    //
    //  Initialize the pointer to the shell view.
    //
    *ppv = NULL;

    //
    //  Get the IShellFolder interface to the desktop folder and then
    //  bind to it.  This is equivalent to calling CoCreateInstance
    //  with CLSID_ShellDesktop.
    //
    hres = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hres))
    {
        hres = pshf->BindToObject(pidl, NULL, riid, ppv);
        pshf->Release();
    }

    //
    //  Return the result.
    //
    return (hres);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_SaveDevNames
//
//  Saves the current devnames in the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD)
{
    TCHAR szPortName[MAX_PATH];
    TCHAR szPrinterName[MAX_PATH];
    DWORD cbDevNames;
    LPDEVNAMES pDN;

    //
    //  Get the port name.
    //
    szPortName[0] = 0;
    Print_GetPortName(pCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  Compute the size of the DevNames structure.
    //
    cbDevNames = lstrlen(szDriver) + 1 +
                 lstrlen(szPortName) + 1 +
                 lstrlen(pCurPrinter) + 1 +
                 DN_PADDINGCHARS;

    cbDevNames *= sizeof(TCHAR);
    cbDevNames += sizeof(DEVNAMES);

    //
    //  Allocate the new DevNames structure.
    //
    pDN = NULL;
    if (pPD->hDevNames)
    {
        HANDLE handle;

        handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

        //Check that realloc succeeded.
        if (handle)
        {
            pPD->hDevNames  = handle;
        }
        else
        {
            //Realloc didn't succeed. Free the memory occupied.
            GlobalFree(pPD->hDevNames);
            pPD->hDevNames = NULL;
        }
    }
    else
    {
        pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
    }

    //
    //  Fill in the DevNames structure with the appropriate information.
    //
    if ( (pPD->hDevNames) &&
         (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)) )
    {
        //
        //  Save the driver name - winspool.
        //
        pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
        lstrcpy((LPTSTR)pDN + pDN->wDriverOffset, szDriver);

        //
        //  Save the printer name.
        //
        pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wDeviceOffset, pCurPrinter);

        //
        //  Save the port name.
        //
        pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pCurPrinter) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, szPortName);

        //
        //  Save whether or not it's the default printer.
        //
        if (pPD->Flags & PD_RETURNDEFAULT)
        {
            pDN->wDefault = DN_DEFAULTPRN;
        }
        else
        {
            szPrinterName[0] = 0;
            PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
            if (szPrinterName[0] && !lstrcmp(pCurPrinter, szPrinterName))
            {
                pDN->wDefault = DN_DEFAULTPRN;
            }
            else
            {
                pDN->wDefault = 0;
            }
        }

        //
        //  Unlock it.
        //
        GlobalUnlock(pPD->hDevNames);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetPortName
//
//  Gets the port name for the given printer and stores it in the
//  given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer)
{
    HANDLE hPrinter;
    DWORD cbPrinter = 0;
    PRINTER_INFO_2 *pPrinter = NULL;

    //
    //  Initialize the buffer.
    //
    if (!cchBuffer)
    {
        return;
    }
    pBuffer[0] = 0;

    //
    //  Open the current printer.
    //
    if (OpenPrinter(pCurPrinter, &hPrinter, NULL))
    {
        //
        //  Get the size of the buffer needed to hold the printer info 2
        //  information.
        //
        if (!GetPrinter( hPrinter,
                         2,
                         (LPBYTE)pPrinter,
                         cbPrinter,
                         &cbPrinter ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                //  Allocate a buffer to hold the printer info 2 information.
                //
                if (pPrinter = (PRINTER_INFO_2 *)LocalAlloc(LPTR, cbPrinter))
                {
                    //
                    //  Get the printer info 2 information.
                    //
                    if (GetPrinter( hPrinter,
                                    2,
                                    (LPBYTE)pPrinter,
                                    cbPrinter,
                                    &cbPrinter ))
                    {
                        //
                        //  Save the port name in the given buffer.
                        //
                        lstrcpyn(pBuffer, pPrinter->pPortName, cchBuffer);
                        pBuffer[cchBuffer - 1] = 0;
                    }
                }
            }
        }

        //
        //  Close the printer.
        //
        ClosePrinter(hPrinter);
    }

    //
    //  Free the printer info 2 information for the current printer.
    //
    if (pPrinter)
    {
        LocalFree(pPrinter);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetDevModeWrapper
//
//  Calls PrintGetDevMode.
//
////////////////////////////////////////////////////////////////////////////

HANDLE Print_GetDevModeWrapper(
    LPTSTR pszDeviceName,
    HANDLE hDevMode)
{
#ifdef WINNT
    //
    //  On Win9x, the hPrinter parameter to DocumentProperties can be
    //  NULL.  On NT, it cannot be NULL.
    //
    HANDLE hPrinter;

    if (OpenPrinter(pszDeviceName, &hPrinter, NULL))
    {
        hDevMode = PrintGetDevMode(0, hPrinter, pszDeviceName, NULL);
        ClosePrinter(hPrinter);
    }
#else
    hDevMode = PrintGetDevMode(0, NULL, pszDeviceName, NULL);
#endif

    //
    //  Return the handle to the devmode.
    //
    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_NewPrintDlg
//
//  Converts the old style pPD structure to the new one and then calls
//  the PrintDlgEx function.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_NewPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    PRINTINFOEX PIEx;
    PRINTDLGEX PDEx;
    PRINTPAGERANGE PageRange;
    HRESULT hResult;

    // PrintDlg did the following for the page ranges. Do the same thing for PrintDlgEx
    if (!(pPD->Flags & PD_PAGENUMS))
    {
        if (pPD->nFromPage != 0xFFFF)
        {
            if (pPD->nFromPage < pPD->nMinPage)
            {
                pPD->nFromPage = pPD->nMinPage;
            }
            else if (pPD->nFromPage > pPD->nMaxPage)
            {
                pPD->nFromPage = pPD->nMaxPage;
            }
        }
        if (pPD->nToPage != 0xFFFF)
        {
            if (pPD->nToPage < pPD->nMinPage)
            {
                pPD->nToPage = pPD->nMinPage;
            }
            else if (pPD->nToPage > pPD->nMaxPage)
            {
                pPD->nToPage = pPD->nMaxPage;
            }
        }
    }



    //
    //  Set up the PRINTINFOEX structure.
    //
    PIEx.ApiType = pPI->ApiType;
    PIEx.pPD     = &PDEx;
    PIEx.fOld    = TRUE;

    //
    //  Copy the page range.
    //
    PageRange.nFromPage = pPD->nFromPage;
    PageRange.nToPage   = pPD->nToPage;

    //
    //  Set up the PRINTDLGEX structure with the appropriate values from
    //  the PRINTDLG structure.
    //
    PDEx.lStructSize         = sizeof(PRINTDLGEX);
    PDEx.hwndOwner           = pPD->hwndOwner;
    PDEx.hDevMode            = pPD->hDevMode;
    PDEx.hDevNames           = pPD->hDevNames;
    PDEx.hDC                 = pPD->hDC;
    PDEx.Flags               = (pPD->Flags & ~(PD_SHOWHELP | PD_NONETWORKBUTTON)) |
                               (PD_NOCURRENTPAGE);
    PDEx.Flags2              = 0;
    PDEx.ExclusionFlags      = 0;
    PDEx.nPageRanges         = 1;
    PDEx.nMaxPageRanges      = 1;
    PDEx.lpPageRanges        = &PageRange;
    PDEx.nMinPage            = pPD->nMinPage;
    PDEx.nMaxPage            = pPD->nMaxPage;
    PDEx.nCopies             = pPD->nCopies;
    PDEx.hInstance           = pPD->hInstance;
    PDEx.lpCallback          = NULL;
    PDEx.lpPrintTemplateName = NULL;
    PDEx.nPropertyPages      = 0;
    PDEx.lphPropertyPages    = NULL;
    PDEx.nStartPage          = START_PAGE_GENERAL;
    PDEx.dwResultAction      = 0;

    //
    //  Since we're in the old dialog, allow the the hInstance to be
    //  non-NULL even if there is not a template.
    //
    if (!(pPD->Flags & (PD_ENABLEPRINTTEMPLATE | PD_ENABLEPRINTTEMPLATEHANDLE)))
    {
        PDEx.hInstance = NULL;
    }
    
    //
    //  Initialize the error code to 0.
    //
    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Call PrintDlgExX to bring up the dialog.
    //
    hResult = PrintDlgExX(&PIEx);

    //
    //  See if the call failed.  If so, store the error and return FALSE.
    //
    if (FAILED(hResult))
    {
        StoreExtendedError(PIEx.dwExtendedError);
        return (FALSE);
    }

    //
    //  The call succeeded, so convert the PRINTDLGEX structure back to
    //  the PRINTDLG structure if PD_RESULT_CANCEL is not set.
    //
    if (PDEx.dwResultAction != PD_RESULT_CANCEL)
    {
        pPD->hDevMode  = PDEx.hDevMode;
        pPD->hDevNames = PDEx.hDevNames;
        pPD->hDC       = PDEx.hDC;
        pPD->Flags     = PDEx.Flags & ~(PD_NOCURRENTPAGE);
        pPD->nFromPage = (WORD)PageRange.nFromPage;
        pPD->nToPage   = (WORD)PageRange.nToPage;
        pPD->nCopies   = (WORD)PDEx.nCopies;
    }

    //
    //  Return TRUE if the user hit Print.
    //
    if (PDEx.dwResultAction == PD_RESULT_PRINT)
    {
        return (TRUE);
    }

    //
    //  Return FALSE for cancel.
    //
    return (FALSE);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CPrintBrowser
//
//  CPrintBrowser constructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::CPrintBrowser(
    HWND hDlg)
    : cRef(1),
      hwndDlg(hDlg),
      hSubDlg(NULL),
      hwndView(NULL),
      hwndUpDown(NULL),
      psv(NULL),
      psfv(NULL),
      psfRoot(NULL),
      pidlRoot(NULL),
      ppf(NULL),
      pPI(NULL),
      pPD(NULL),
      pCallback(NULL),
      pSite(NULL),
      pDMInit(NULL),
      pDMCur(NULL),
      cchCurPrinter(0),
      pszCurPrinter(NULL),
      nCopies(1),
      nMaxCopies(1),
      nPageRanges(0),
      nMaxPageRanges(0),
      pPageRanges(NULL),
      fSelChangePending(FALSE),
      fFirstSel(1),
      fCollateRequested(FALSE),
      fAPWSelected(FALSE),
      fNoAccessPrinterSelected(FALSE),
      fDirtyDevmode(FALSE),
      fDevmodeEdit(FALSE),
      fAllowCollate(FALSE),
      nInitDone(0),
      nListSep(0),
      uRegister(0),
      uDefViewMode(VIEW_MODE_DEFAULT),
      pInternalDevMode(NULL),
      hPrinter(NULL)
{
    HMENU hMenu;

    hMenu = GetSystemMenu(hDlg, FALSE);
    DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_RESTORE,  MF_BYCOMMAND);

    szListSep[0] = 0;
    szScratch[0] = 0;
    szPrinter[0] = 0;

    pDMSave = (LPDEVMODE)GlobalAlloc(GPTR, sizeof(DEVMODE));

    Shell_GetImageLists(NULL, &himl);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::~CPrintBrowser
//
//  CPrintBrowser destructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::~CPrintBrowser()
{
    //
    //  Deregister notifications.
    //
    if (uRegister)
    {
        SHChangeNotifyDeregister(uRegister);
        uRegister = 0;
    }

    //
    //  Release the printer folder private interface.
    //
    if (ppf != NULL)
    {
        ppf->Release();
        ppf = NULL;
    }

    //
    //  Release the printer shell folder.
    //
    if (psfRoot != NULL)
    {
        psfRoot->Release();
        psfRoot = NULL;
    }

    //
    //  Free the pidl.
    //
    if (pidlRoot != NULL)
    {
        SHFree(pidlRoot);
        pidlRoot = NULL;
    }

    //
    //  Free the devmodes.
    //
    if (pDMInit)
    {
        GlobalFree(pDMInit);
        pDMInit = NULL;
    }
    if (pDMSave)
    {
        GlobalFree(pDMSave);
        pDMSave = NULL;
    }

    //
    //  Free the current printer buffer.
    //
    cchCurPrinter = 0;
    if (pszCurPrinter)
    {
        GlobalFree(pszCurPrinter);
        pszCurPrinter = NULL;
    }

    //
    //  Free the page range.
    //
    nPageRanges = 0;
    nMaxPageRanges = 0;
    if (pPageRanges)
    {
        GlobalFree(pPageRanges);
        pPageRanges = NULL;
    }

    if (pInternalDevMode)
    {
        GlobalFree(pInternalDevMode);
        pInternalDevMode = NULL;
    }

    if (hPrinter)
    {
        ClosePrinter(hPrinter);
        hPrinter = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryInterface
//
//  Standard OLE2 style methods for this object.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IShellBrowser) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellBrowser *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser2))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_IPrintDialogServices))
    {
        *ppvObj = (IPrintDialogServices *)this;
        ++cRef;
        return (S_OK);
    }

    *ppvObj = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::AddRef
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::AddRef()
{
    return (++cRef);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Release
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::Release()
{
    cRef--;
    if (cRef > 0)
    {
        return (cRef);
    }

    delete this;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetWindow(
    HWND *phwnd)
{
    *phwnd = hwndDlg;
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ContextSensitiveHelp
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::ContextSensitiveHelp(
    BOOL fEnable)
{
    //
    //  Shouldn't need in a common dialog.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InsertMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::InsertMenusSB(
    HMENU hmenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetMenuSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetMenuSB(
    HMENU hmenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::RemoveMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::RemoveMenusSB(
    HMENU hmenuShared)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetStatusTextSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetStatusTextSB(
    LPCOLESTR pwch)
{
    //
    //  We don't have any status bar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::EnableModelessSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::EnableModelessSB(
    BOOL fEnable)
{
    //
    //  We don't have any modeless window to be enabled/disabled.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::TranslateAcceleratorSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::TranslateAcceleratorSB(
    LPMSG pmsg,
    WORD wID)
{
    //
    //  We don't use the  Key Stroke.
    //
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::BrowseObject
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::BrowseObject(
    LPCITEMIDLIST pidl,
    UINT wFlags)
{
    //
    //  We don't support browsing, or more precisely, CDefView doesn't.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewStateStream
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewStateStream(
    DWORD grfMode,
    LPSTREAM *pStrm)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetControlWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetControlWindow(
    UINT id,
    HWND *lphwnd)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SendControlMsg
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SendControlMsg(
    UINT id,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pret)
{
    LRESULT lres = 0;

    if (pret)
    {
        *pret = lres;
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryActiveShellView
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::QueryActiveShellView(
    LPSHELLVIEW *ppsv)
{
    if (psv)
    {
        *ppsv = psv;
        psv->AddRef();
        return (S_OK);
    }

    *ppsv = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnViewWindowActive
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnViewWindowActive(
    LPSHELLVIEW psv)
{
    //
    //  No need to process this. We don't do menus.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetToolbarItems
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetToolbarItems(
    LPTBBUTTON lpButtons,
    UINT nButtons,
    UINT uFlags)
{
    //
    //  We don't let containers customize our toolbar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDefaultCommand
//
//  Process a double-click or Enter keystroke in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnDefaultCommand(
    struct IShellView *ppshv)
{
    //
    //  Make sure it's the correct shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  See if the Add Printer Wizard is selected.
    //
    if (fAPWSelected)
    {
        //
        //  Invoke the Add Printer Wizard (modeless).
        //
        InvokeAddPrinterWizardModal(hwndDlg, NULL);
    }
    else if (fNoAccessPrinterSelected)
    {
        //
        // Display error message indicated we do not have access.
        //
        ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterAccess);
    }
    else
    {
        //
        //  Simulate the pressing of the OK button.
        //
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
    }

    //
    //  Tell the shell that the action has been processed.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnStateChange
//
//  Process selection change in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnStateChange(
    struct IShellView *ppshv,
    ULONG uChange)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (uChange)
    {
        case ( CDBOSC_SETFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_KILLFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_SELCHANGE ) :
        {
            //
            //  Post one of these messages, since we seem to get a whole
            //  bunch of them.
            //
            if (!fSelChangePending)
            {
                fSelChangePending = TRUE;
                PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
            }

            break;
        }
        case ( CDBOSC_RENAME ) :
        {
            break;
        }
        default :
        {
            return (E_NOTIMPL);
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IncludeObject
//
//  Tell the view control which objects to include in its enumerations.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::IncludeObject(
    struct IShellView *ppshv,
    LPCITEMIDLIST pidl)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If we have the printer folder private interface, return ok only
    //  if it's a printer.
    //
    if (ppf)
    {
        return (ppf->IsPrinter(pidl) ? S_OK : S_FALSE);
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Notify
//
//  Notification to decide whether or not a printer should be selected.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::Notify(
    struct IShellView *ppshv,
    DWORD dwNotify)
{
    HRESULT hr = S_OK;

    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (dwNotify)
    {
        case (CDB2N_CONTEXTMENU_DONE):
        {
            HWND hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);
            if (hwndListView)
            {
                HWND hwndEdit = ListView_GetEditControl(hwndListView);
                if (NULL == hwndEdit)
                {
                    // if not in edit mode then re-select the current item
                    SelectSVItem();
                }
            }
            break;
        }

        default:
        {
            hr = S_FALSE;
            break;
        }
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (hr);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetDefaultMenuText
//
//  Returns the default menu text.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetDefaultMenuText(
    struct IShellView *ppshv,
    WCHAR *pszText,
    INT cchMax)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If the add printer wizard is the selected item, do not change
    //  the default menu text.
    //
    if (fAPWSelected)
    {
        return (S_FALSE);
    }

    //
    //  Change the default menu text from 'Select' to 'Print'.
    //
    if (!CDLoadString(g_hinst, iszDefaultMenuText, szScratch, ARRAYSIZE(szScratch)))
    {
        return (E_FAIL);
    }

#ifdef UNICODE
    //
    //  Just copy the default menu text to the provided buffer if there
    //  is room.
    //
    if (lstrlen(szScratch) < cchMax)
    {
        lstrcpyn(pszText, szScratch, cchMax);
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
#else
    //
    //  The shell only accepts the default menu text as a Unicode string,
    //  so we have to convert it from an Ansi string to a Unicode string.
    //
    if (!MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             szScratch,
                             -1,
                             pszText,
                             cchMax ))
    {
        return (E_FAIL);
    }
#endif

    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewFlags
//
//  Returns Flags to customize the view .
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewFlags(DWORD *pdwFlags)
{
    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return S_OK;
}




////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitDone
//
//  Notifies the sub dialog that initialization of the General page is
//  complete.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::InitDone()
{
    HRESULT hResult = S_FALSE;

    //
    //  Notify the sub dialog that initialization is complete.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->InitDone();

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectionChange
//
//  Notifies the sub dialog that a selection change has taken place.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::SelectionChange()
{
    HRESULT hResult = S_FALSE;

    //
    //  Handle the Print To File here.
    //
    InitPrintToFile();

    //
    //  Notify the sub dialog that a selection change has taken place.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->SelectionChange();

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Handle the selection change.
    //
    if (hResult == S_FALSE)
    {
        //
        //  Handle copies and collate.
        //
        InitCopiesAndCollate();

        //
        //  Handle the page ranges.
        //
        InitPageRangeGroup();

        //
        //  Return success.
        //
        hResult = S_OK;
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::HandleMessage
//
//  Process a message for the child window by calling the application
//  callback function.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::HandleMessage(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pResult)
{
    HRESULT hResult = S_FALSE;
    BOOL bTest;
    UINT nRet, ErrorId;
    DWORD nTmpCopies;

    //
    //  Initialize the return value.
    //
    *pResult = FALSE;

    //
    //  See if the message should be handled.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->HandleMessage(hDlg, uMsg, wParam, lParam, pResult);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Handle the message.
    //
    if ((hResult == S_FALSE) && (uMsg == WM_NOTIFY))
    {
        switch (((LPNMHDR)lParam)->code)
        {
            case ( PSN_KILLACTIVE ) :
            {
                //
                //  Make sure the page has valid entries.
                //  If invalid entries are found, then set the DWL_MSGRESULT
                //  of the General page to be TRUE and return TRUE in order
                //  to prevent the page from losing the activation.
                //

                //
                //  Validate the number of copies and store it in the
                //  nCopies member.
                //
                if ((GetDlgItem(hSubDlg, IDC_COPIES)) &&
                    (fAPWSelected == FALSE))
                {
                    nTmpCopies = nCopies;
                    nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                    if (!bTest || !nCopies)
                    {
                        nCopies = nTmpCopies;
                        ShowError(hSubDlg, IDC_COPIES, iszCopiesZero);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Validate the page range and store it in the pRange member.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES) &&
                    GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                {
                    nRet = GetDlgItemText( hSubDlg,
                                           IDC_RANGE_EDIT,
                                           szScratch,
                                           ARRAYSIZE(szScratch) );
                    ErrorId = iszBadPageRange;
                    if (!nRet || !IsValidPageRange(szScratch, &ErrorId))
                    {
                        ShowError(hSubDlg,
                                  IDC_RANGE_EDIT,
                                  ErrorId,
                                  (ErrorId == iszTooManyPageRanges)
                                    ? nMaxPageRanges
                                    : pPD->nMinPage,
                                  pPD->nMaxPage);

                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
            case ( PSN_APPLY ) :
            {
                //
                //  Clear the flags that need to be set based on the
                //  contents of the General page.
                //
                pPD->Flags &= ~((DWORD)( PD_PAGENUMS    |
                                         PD_SELECTION   |
                                         PD_CURRENTPAGE ));

                //
                //  Save the page range information.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_SELECTION))
                {
                    pPD->Flags |= PD_SELECTION;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_CURRENT))
                {
                    pPD->Flags |= PD_CURRENTPAGE;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES))
                {
                    pPD->Flags |= PD_PAGENUMS;

                    //
                    //  Copy the page ranges to the pPageRanges structure
                    //  in the PrintDlg structure.
                    //
                    if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                    {
                        pPD->nPageRanges = nPageRanges;
                        CopyMemory( pPD->lpPageRanges,
                                    pPageRanges,
                                    nPageRanges * sizeof(PRINTPAGERANGE) );
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
        }
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentDevMode
//
//  Returns the current devmode structure.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentDevMode(
    LPDEVMODE pDevMode,
    UINT *pcbSize)
{
    UINT cbSize;

    //
    //  Make sure pcbSize is valid.
    //
    if ((pcbSize == NULL) || (*pcbSize && !pDevMode))
    {
        return (E_INVALIDARG);
    }

    //
    //  When there is no current devmode, set the size to zero and return
    //  TRUE.
    //
    if (!pDMCur)
    {
        *pcbSize = 0;
        return (S_OK);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //

    GetCurrentPrinter();

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcbSize == 0)
    {
        //
        //  Return the size of the buffer needed.
        //
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
        }
        else
#endif
        {
            *pcbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
        }
    }
    else
    {
        //
        //  Make sure the copies and collate information is up to date.
        //
        SaveCopiesAndCollateInDevMode(pDMCur, pszCurPrinter);

        //
        //  Return the devmode information as well as the size of the
        //  buffer.
        //
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            cbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            ThunkDevModeW2A(pDMCur, (LPDEVMODEA)pDevMode);
            *pcbSize = cbSize;
        }
        else
#endif
        {
            cbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            CopyMemory(pDevMode, pDMCur, cbSize);
            *pcbSize = cbSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinterName
//
//  Returns the current printer name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPrinterName(
    LPTSTR pPrinterName,
    UINT *pcchSize)
{
    UINT cchSize;

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPrinterName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             pszCurPrinter,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
#endif
        {
            *pcchSize = lstrlen(pszCurPrinter) + 1;
        }
    }
    else
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = SHUnicodeToAnsi(pszCurPrinter,(LPSTR)pPrinterName,*pcchSize);

            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
#endif
        {
            cchSize = lstrlen(pszCurPrinter) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            lstrcpy(pPrinterName, pszCurPrinter);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPortName
//
//  Returns the current port name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPortName(
    LPTSTR pPortName,
    UINT *pcchSize)
{
    UINT cchSize;
    TCHAR szPortName[MAX_PATH];

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPortName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  Get the port name for the current printer.
    //
    szPortName[0] = 0;
    Print_GetPortName(pszCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             szPortName,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
#endif
        {
            *pcchSize = lstrlen(szPortName) + 1;
        }
    }
    else
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = SHUnicodeToAnsi(szPortName,(LPSTR)pPortName,*pcchSize);

            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
#endif
        {
            cchSize = lstrlen(szPortName) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            lstrcpy(pPortName, szPortName);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDialog
//
//  Process a WM_INITDIALOG message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnInitDialog(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    UINT Result;
    HRESULT hResult;
    SHChangeNotifyEntry fsne;

    // 
    // If disable printer addition policy is set then 
    // then disable find button on the print dialog
    //
    if( SHRestricted(REST_NOPRINTERADD) )
    {
        EnableWindow( GetDlgItem( hwndDlg, IDC_FIND_PRINTER ), FALSE );
    }

    //
    // Always disable the preferences button in the begining
    //
    EnableWindow( GetDlgItem( hwndDlg, IDC_DRIVER ), FALSE );

    //
    //  Get the pointer to the PRINTINFOEX structure from the lParam of
    //  the property sheet structure.
    //
    pPI = (PPRINTINFOEX)((LPPROPSHEETPAGE)lParam)->lParam;
    pPD = pPI->pPD;

    //Initialize Ole Before doing anything
    pPI->hrOleInit = SHOleInitialize(0);

    DEBUG_CODE(GdiSetBatchLimit(1));
    //
    //  Initialize the error codes to success now that we have the
    //  pPI structure.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;
    pPI->hResult = S_OK;

    //
    //  Create the printer folder shell view.
    //
    hResult = CreatePrintShellView();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Insert the device pages for the appropriate printer.
    //
    //  First:  Try the printer in the DevMode.
    //  Second: Try the printer in the DevNames.
    //  Third:  Use the default by passing in NULLs.
    //
    Result = kError;
    if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
    {
        DWORD cbSize = (DWORD)(pDM->dmSize + pDM->dmDriverExtra);

        if (cbSize >= sizeof(DEVMODE) && (pDMInit = (LPDEVMODE)GlobalAlloc(GPTR, cbSize)))
        {
            CopyMemory(pDMInit, pDM, cbSize);
            Result = InstallDevMode((LPTSTR)pDM->dmDeviceName, pDMInit);
        }

        GlobalUnlock(pPD->hDevMode);
    }

    if ((Result != kSuccess) &&
        (pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        LPTSTR pPrinter = (LPTSTR)pDN + pDN->wDeviceOffset;

        Result = InstallDevMode(pPrinter, pDMInit);
        GlobalUnlock(pPD->hDevNames);
    }

    if (Result != kSuccess)
    {
        Result = InstallDevMode(NULL, pDMInit);
    }

    //
    //  Get the current printer name and the current devmode.
    //
    GetCurrentPrinter();

    //
    //  Initialize the "Print to file" check box appropriately.
    //
    if (hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hwndDlg, IDC_PRINT_TO_FILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    //
    //  Set the number of copies and the collation correctly.
    //
    pDM = pDMInit ? pDMInit : pDMCur;

    if (pDMCur && (pDMCur->dmFields & DM_COPIES))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            pPD->nCopies = (DWORD)pDM->dmCopies;
        }
        else if (pPD->nCopies)
        {
            pDMCur->dmCopies = (short)pPD->nCopies;
        }
    }

    if (pDMCur && (pDMCur->dmFields & DM_COLLATE))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            if (pDM->dmCollate == DMCOLLATE_FALSE)
            {
                pPD->Flags &= ~PD_COLLATE;
            }
            else
            {
                pPD->Flags |= PD_COLLATE;
            }
        }
        else
        {
            pDMCur->dmCollate = (pPD->Flags & PD_COLLATE)
                                    ? DMCOLLATE_TRUE
                                    : DMCOLLATE_FALSE;
        }
    }
    if (pPD->Flags & PD_COLLATE)
    {
        fCollateRequested = TRUE;
    }

    //
    //  Create the hook dialog.
    //
    hResult = CreateHookDialog();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Set the ClipChildren style bit on the main dialog so that we get
    //  proper repainting of the various children in the General page.
    //
    SetWindowLong( GetParent(hwndDlg),
                   GWL_STYLE,
                   GetWindowLong(GetParent(hwndDlg), GWL_STYLE) | WS_CLIPCHILDREN );

    //
    //  Set the OK button to Print.
    //
    CDLoadString(g_hinst, iszPrintButton, szScratch, ARRAYSIZE(szScratch));
    SetDlgItemText(GetParent(hwndDlg), IDOK, szScratch);

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Register change notifications.
    //
    if (pidlRoot)
    {
        fsne.pidl = pidlRoot;
        fsne.fRecursive = FALSE;

        uRegister = SHChangeNotifyRegister(
                        hwndDlg,
                        SHCNRF_NewDelivery | SHCNRF_ShellLevel |
                            SHCNRF_InterruptLevel,
                        SHCNE_ATTRIBUTES | SHCNE_UPDATEITEM | SHCNE_CREATE |
                            SHCNE_DELETE | SHCNE_RENAMEITEM,
                        CDM_PRINTNOTIFY,
                        1,
                        &fsne );
    }

    //
    // If we failed to insert the device page then tell the 
    // user what is wrong.  Basically two messages, either there isn't
    // a printer installed or they do not have access to the selected
    // printer.
    //
    if (Result != kSuccess || !pDMCur )
    {
        if( (Result == kAccessDenied) || (Result == kInvalidDevMode) ) 
        {
            PostMessage(hwndDlg, CDM_NOPRINTERS, (WPARAM)hwndDlg, iszNoPrinterAccess );
        }
        else
        {
            PostMessage(hwndDlg, CDM_NOPRINTERS, (WPARAM)hwndDlg, iszNoPrinters );
        }
    }

    //
    //  Give the application the pointer to the IPrintDialogServices
    //  interface.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pSite);
        if (pSite)
        {
            pSite->SetSite((IPrintDialogServices *)this);
        }
    }

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildInitDialog
//
//  Process a WM_INITDIALOG message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD wCheckID;
    HWND hCtl;

    //
    //  Save the handle to the child window.
    //
    hSubDlg = hDlg;

    //
    //  Get the list separator for the current user locale.
    //
    nListSep = GetLocaleInfo( LOCALE_USER_DEFAULT,
                              LOCALE_SLIST,
                              szListSep,
                              ARRAYSIZE(szListSep) );
    if (nListSep == 0)
    {
        szListSep[0] = TEXT(',');
        szListSep[1] = 0;
        nListSep = 2;
    }
    nListSep--;

    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, MAX_COPIES);
    SetDlgItemInt(hSubDlg, IDC_COPIES, pPD->nCopies, FALSE);
    nCopies = pPD->nCopies;

    if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
        (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE))
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        hwndUpDown = CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hSubDlg,
                             IDC_COPIES_UDARROW,
                             g_hinst,
                             hCtl,
                             MAX_COPIES,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the 
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth(hSubDlg, hCtl);
    }

    //
    //  Make sure the collate icon is centered.  Only want to do this once.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    //
    //  Initialize the copies and collate info.
    //
    InitCopiesAndCollate();

    //
    //  Set the page range.
    //
    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT1), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT2), FALSE);

        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  See if the page range only consists of one page.  If so,
        //  disable the Pages radio button and the associated edit control
        //  and disable and hide the collate check box.
        //
        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);

            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            fCollateRequested = FALSE;
            EnableWindow(GetDlgItem(hSubDlg, IDC_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hSubDlg, IDC_COLLATE), SW_HIDE);
        }
        else
        {
            //
            //  Initialize the page range members.
            //
            nPageRanges = pPD->nPageRanges;
            nMaxPageRanges = pPD->nMaxPageRanges;
            pPageRanges = (LPPRINTPAGERANGE)
                          GlobalAlloc(GPTR, nMaxPageRanges * sizeof(PRINTPAGERANGE));
            if (!pPageRanges)
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = E_OUTOFMEMORY;
                return (FALSE);
            }
            CopyMemory( pPageRanges,
                        pPD->lpPageRanges,
                        nPageRanges * sizeof(PRINTPAGERANGE) );

            //
            //  See if we should only accept a single page range.
            //
            if (nMaxPageRanges == 1)
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }
            else
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }

            //
            //  Validate the page ranges.
            //
            if (!ConvertPageRangesToString(szScratch, ARRAYSIZE(szScratch)))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                pPI->hResult = E_INVALIDARG;
                return (FALSE);
            }

            //
            //  Put the page range string in the edit control.
            //
            if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
            {
                SetDlgItemText(hSubDlg, IDC_RANGE_EDIT, szScratch);
            }
        }
    }

    //
    //  See if we should disable the Selection radio button.
    //
    if (pPD->Flags & PD_NOSELECTION)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_SELECTION))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    //
    //  See if we should disable the Current Page radio button.
    //
    if (pPD->Flags & PD_NOCURRENTPAGE)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_CURRENT))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_CURRENTPAGE);
    }

    //
    //  Choose one of the page range radio buttons.
    //
    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = IDC_RANGE_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = IDC_RANGE_SELECTION;
    }
    else if (pPD->Flags & PD_CURRENTPAGE)
    {
        wCheckID = IDC_RANGE_CURRENT;
    }
    else    // PD_ALL
    {
        wCheckID = IDC_RANGE_ALL;
    }
    CheckRadioButton(hSubDlg, IDC_RANGE_ALL, IDC_RANGE_PAGES, (int)wCheckID);

    //
    //  See if the collate check box should be checked or not.
    //
    if (pPD->Flags & PD_COLLATE)
    {
        CheckDlgButton(hSubDlg, IDC_COLLATE, TRUE);
    }

    //
    //  Display the appropriate collate icon.
    //
    if ((GetWindowLong( GetDlgItem(hSubDlg, IDC_COLLATE),
                        GWL_STYLE ) & WS_VISIBLE) &&
        (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)))
    {
        ShowWindow(hCtl, SW_HIDE);
        SendMessage( hCtl,
                     STM_SETICON,
                     IsDlgButtonChecked(hSubDlg, IDC_COLLATE)
                         ? (LONG_PTR)hIconCollate
                         : (LONG_PTR)hIconNoCollate,
                     0L );
        ShowWindow(hCtl, SW_SHOW);
    }

    //
    //  Save the flags as they are now so I know what to enable
    //  when the selection changes from the Add Printer Wizard icon.
    //
    pPI->dwFlags = pPD->Flags;
    if (pPD->nMinPage == pPD->nMaxPage)
    {
        pPI->dwFlags |= PD_NOPAGENUMS;
    }

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDestroyMessage
//
//  Process a WM_DESTROY message for the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnDestroyMessage()
{
    if (psfv)
    {
        psfv->Release();
        psfv = NULL;
    }
    if (psv)
    {
        psv->DestroyViewWindow();
        psv->Release();
        psv = NULL;
    }
    if (pCallback)
    {
        pCallback->Release();
        pCallback = NULL;
    }
    if (pSite)
    {
        pSite->SetSite(NULL);
        pSite->Release();
        pSite = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnCommandMessage
//
//  Process a WM_COMMAND message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case ( IDC_DRIVER ) :
        {
            //
            //  Show the driver UI calling DocumentProperties API.
            //
            if (pInternalDevMode)
            {
                DWORD dwSize = pInternalDevMode->dmSize + pInternalDevMode->dmDriverExtra;

                //
                // Allocate memory for the in/out devmodes and open separate temp printer handle.
                //
                LPDEVMODE pDevModeIn = (LPDEVMODE)GlobalAlloc(GPTR, dwSize);
                LPDEVMODE pDevModeOut = (LPDEVMODE)GlobalAlloc(GPTR, dwSize);
                HANDLE hTempPrinter = NULL;

                if (pDevModeIn && pDevModeOut && OpenPrinter((LPTSTR)szPrinter, &hTempPrinter, NULL))
                {
                    //
                    // Call DocumentProperties API to allow the user to edit the devmode.
                    //
                    fDirtyDevmode = FALSE;
                    memcpy(pDevModeIn, pInternalDevMode, dwSize);
                    memcpy(pDevModeOut, pInternalDevMode, dwSize);

                    //
                    // Update current copy and collation settings to DEVMODE before calling DocumentProperties()
                    //
                    pDevModeIn->dmCopies = nCopies;
                    pDevModeIn->dmCollate = fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE;

                    fDevmodeEdit = TRUE;
                    LONG lResult = g_pfnDocumentPropertiesWrap(hwndDlg, hTempPrinter, szPrinter, pDevModeOut, 
                        pDevModeIn, DM_IN_BUFFER|DM_OUT_BUFFER|DM_IN_PROMPT|DM_OUT_DEFAULT, pPD->ExclusionFlags);
                    fDevmodeEdit = FALSE;

                    if (IDOK == lResult)
                    {
                        //
                        // Check if there is a change after the editing.
                        //
                        if (!fDirtyDevmode && pInternalDevMode && memcmp(pDevModeOut, pInternalDevMode, dwSize))
                        {
                            //
                            // Refresh the copies and collation in case of change in Preferences...
                            // We simulate a BN_CLICKED message since we need to refresh the collation icon
                            // when we change the collation settings.
                            //
                            if (nCopies != pDevModeOut->dmCopies)
                            {
                                SetDlgItemInt(hSubDlg, IDC_COPIES, pDevModeOut->dmCopies, FALSE);
                            }

                            if ((fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE) ^ pDevModeOut->dmCollate)
                            {
                                CheckDlgButton(hSubDlg, IDC_COLLATE, pDevModeOut->dmCollate ? BST_CHECKED : BST_UNCHECKED);
                                SendMessage(hSubDlg, WM_COMMAND, MAKEWPARAM(IDC_COLLATE ,BN_CLICKED), (LPARAM)GetDlgItem(hSubDlg, IDC_COLLATE));
                            }
                            
                            //
                            // The internal devmode has been changed. Update it and enable the "Apply" button.
                            //
                            memcpy(pInternalDevMode, pDevModeOut, dwSize);
                            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                        }
                    }
                }

                //
                // Release the allocated resources.
                //
                if (pDevModeIn)
                {
                    GlobalFree((HANDLE)pDevModeIn);
                }

                if (pDevModeOut)
                {
                    GlobalFree((HANDLE)pDevModeOut);
                }

                if (hTempPrinter)
                {
                    ClosePrinter(hTempPrinter);
                }

                // select the printer's list control
                SendMessage(hwndDlg, WM_NEXTDLGCTL, 
                    reinterpret_cast<WPARAM>(GetDlgItem(hwndDlg, IDC_PRINTER_LISTVIEW)), 1);
            }

            break;
        }
        case ( IDC_FIND_PRINTER ) :
        {
            //
            //  Turn on the hour glass.
            //
            HourGlass(TRUE);

            //
            //  Bring up the Find Printer dialog.
            //
            szScratch[0] = 0;
            if (FindPrinter(hwndDlg, szScratch, ARRAYSIZE(szScratch)) && (szScratch[0] != 0))
            {
                //
                //  Add the appropriate device pages and select the
                //  newly found printer.
                //
                if (!MergeDevMode(szScratch))
                {
                    InstallDevMode(szScratch, NULL);
                }
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }

            //
            //  Turn off the hour glass.
            //
            HourGlass(FALSE);

            break;
        }
        case ( IDC_PRINT_TO_FILE ) :
        {
            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_REFRESH ) :
        {
            if (psv)
            {
                psv->Refresh();
            }

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildCommandMessage
//
//  Process a WM_COMMAND message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    RECT rc;
    DWORD nTmpCopies;
    BOOL bTest;

    switch (LOWORD(wParam))
    {
        case ( IDC_RANGE_ALL ) :            // Print Range - All
        case ( IDC_RANGE_SELECTION ) :      // Print Range - Selection
        case ( IDC_RANGE_CURRENT ) :        // Print Range - Current Page
        case ( IDC_RANGE_PAGES ) :          // Print Range - Pages
        {
            CheckRadioButton( hSubDlg,
                              IDC_RANGE_ALL,
                              IDC_RANGE_PAGES,
                              GET_WM_COMMAND_ID(wParam, lParam) );

            //
            //  Only move the focus to the "Pages" edit control when
            //  the up/down arrow is NOT used.
            //
            if ( !IS_KEY_PRESSED(VK_UP) &&
                 !IS_KEY_PRESSED(VK_DOWN) &&
                 ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == IDC_RANGE_PAGES)) )
            {
                SendMessage( hSubDlg,
                             WM_NEXTDLGCTL,
                             (WPARAM)GetDlgItem(hSubDlg, IDC_RANGE_EDIT),
                             1L );
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_RANGE_EDIT ) :           // Print Range - Pages edit control
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                CheckRadioButton( hSubDlg,
                                  IDC_RANGE_ALL,
                                  IDC_RANGE_PAGES,
                                  IDC_RANGE_PAGES );

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COPIES ) :
        {
            if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) &&
                (fAPWSelected == FALSE))
            {
                //
                //  Save the number of copies.
                //
                nTmpCopies = nCopies;
                nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                if (!bTest || !nCopies)
                {
                    nCopies = nTmpCopies;
                }

                //
                //  If the printer can support collate and copy count > 1, enable collate.
                //  Otherwise, disable it.
                //
                if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
                {
                    EnableWindow( hCtl, (fAllowCollate && (nCopies > 1) ? TRUE : FALSE) );
                }

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COLLATE ) :
        {
            fCollateRequested = (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                                    ? TRUE
                                    : FALSE;

            if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             fCollateRequested
                                 ? (LONG_PTR)hIconCollate
                                 : (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNotifyMessage
//
//  Process WM_NOTIFY messages for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnNotifyMessage(
    WPARAM wParam,
    LPNMHDR pnm)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    LRESULT lResult;

    switch (pnm->code)
    {
        case ( PSN_SETACTIVE ) :
        {
            break;
        }
        case ( PSN_KILLACTIVE ) :
        {
            //
            //  Validation of the copies and page range values is done
            //  in the HandleMessage function for the sub dialog.
            //
            break;
        }
        case ( PSN_APPLY ) :
        {
            //
            //  Save the current printer information.
            //
            if (!GetCurrentPrinter() || !pDMCur)
            {
                ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return (TRUE);
            }

            //
            //  Clear the flags that need to be set based on the contents
            //  of the General page.
            //
            pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                     PD_COLLATE     |
                                     PD_PAGENUMS    |
                                     PD_SELECTION   |
                                     PD_CURRENTPAGE ));

            //
            //  Save the collate information.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COLLATE)) &&
                (fAPWSelected == FALSE))
            {
                if (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                {
                    pPD->Flags |= PD_COLLATE;
                }
                else
                {
                    pPD->Flags &= ~PD_COLLATE;
                }
            }

            //
            //  Save the info that the user hit OK.
            //
            pPI->FinalResult = 1;
            pPI->fApply = TRUE;
            //
            //  Save the print to file information.
            //
            if (IsDlgButtonChecked(hwndDlg, IDC_PRINT_TO_FILE))
            {
                pPD->Flags |= PD_PRINTTOFILE;
            }

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            //
            //  Disable the Apply button.
            //
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            break;

        }

        case PSN_LASTCHANCEAPPLY:
        {
            //
            //  Save the current printer information.
            //
            if (!GetCurrentPrinter() || !pDMCur)
            {
                ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
                return (TRUE);
            }
           
            //
            //  Save the number of copies.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
                (fAPWSelected == FALSE))
            {
                pPD->nCopies = nCopies;
                if(!SetCopiesOnApply())
                {
                    nCopies = pPD->nCopies;
                    SetDlgItemInt(hSubDlg, IDC_COPIES, nCopies, FALSE);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return (TRUE);
                }
            }

            //
            //  Save the DevMode information.
            //
            SaveDevMode();

            //
            //  Save the DevNames information.
            //
            if (!Print_SaveDevNames(pszCurPrinter, pPD))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = CreateError();
                pPI->FinalResult = 0;
            }

            //
            //  Save the hDC or hIC, depending on which flag is set.
            //
            if (pPI->FinalResult)
            {
                pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode);
                pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames);
                if (pDM && pDN)
                {
                    PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);
                }
                if (pDM)
                {
                    GlobalUnlock(pPD->hDevMode);
                }
                if (pDN)
                {
                    GlobalUnlock(pPD->hDevNames);
                }
            }
            break;
        }

        case ( PSN_QUERYCANCEL ) :
        {
            break;
        }

        case ( PSN_RESET ) :
        {
            //
            //  Save the info that the user hit CANCEL.
            //
            pPI->FinalResult = 0;

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Notify the sub dialog.
    //
    if (Print_IsInRange(pnm->code, PSN_LAST, PSN_FIRST) &&
        (HandleMessage(hSubDlg, WM_NOTIFY, wParam, (LPARAM)pnm, &lResult) !=
             S_FALSE))
    {
        // 
        // BUGBUG: The return from a dlgproc is different than a winproc.

        return (BOOLFROMPTR(lResult) );
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnSelChange
//
//  Process a CDM_SELCHANGE message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnSelChange()
{
    HRESULT hres;
    LPCITEMIDLIST *ppidlSel = NULL;
    UINT uItems = 0;
    UINT uCount = 0;
    TCHAR szPrinterNameBuf[kPrinterBufMax];
    BOOL bChanged = FALSE;
    UINT rc = kSuccess;

    //
    //  We get this message during init, so use it to set the
    //  initial selection.
    //
    if (fFirstSel)
    {
        //
        //  Select the appropriate item in the list view.
        //
        //  If an item cannot be selected, it probably means that the
        //  printer that was passed in has been deleted.  In this case,
        //  insert the driver pages and select the default printer.
        //
        if (!SelectSVItem())
        {
            //
            //  Insert the device page for the default printer.
            //
            if (InstallDevMode(NULL, NULL) != kSuccess)
            {
                UninstallDevMode();
            }

            //
            //  Get the current printer and select the appropriate item
            //  in the list view.
            //
            SelectSVItem();
        }

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();

        //
        //  Disable the Apply button if it's the very first time
        //  (during initialization).
        //
        if (fFirstSel == 1)
        {
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
        }

        //
        //  Reset the flags.
        //
        fFirstSel = 0;
        fSelChangePending = FALSE;

        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Reset the flag.
    //
    fSelChangePending = FALSE;

    //
    //  Make sure we have the shell folder view interface.
    //
    if (!psfv)
    {
        return (FALSE);
    }

    //
    //  Get the selected object in the print folder.
    //
    hres = psfv->GetSelectedObjects(&ppidlSel, &uItems);
    if (SUCCEEDED(hres) && (uItems > 0) && ppidlSel && *ppidlSel)
    {
        //
        //  Get the printer name.
        //
        szPrinterNameBuf[0] = 0;
        GetViewItemText( psfRoot,
                         *ppidlSel,
                         szPrinterNameBuf,
                         ARRAYSIZE(szPrinterNameBuf),
                         SHGDN_FORPARSING);

        // if the selection is same as current printer
        if (pszCurPrinter && (lstrcmpi(szPrinterNameBuf, pszCurPrinter) == 0))
        {
            //Dont do anything.
            LocalFree(ppidlSel);
            return TRUE;

        }


        //
        //  See if it's the Add Printer Wizard.
        //
        if (lstrcmpi(szPrinterNameBuf, TEXT("WinUtils_NewObject")) == 0)
        {
            //
            //  It's the Add Printer Wizard.
            //
            fAPWSelected = TRUE;

            //
            //  Disable the OK and Apply buttons.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            //  Remove the device pages, since no printer is selected.
            //
            if (UninstallDevMode() == kSuccess)
            {
                bChanged = TRUE;
            }

            //
            //  Update the current printer information and the printer
            //  status text (all should be empty).
            //
            GetCurrentPrinter();
            UpdateStatus(NULL);

            //
            //  Notify the sub dialog that the selection changed.
            //
            if (bChanged)
            {
                SelectionChange();
                bChanged = FALSE;
            }
        }
        else
        {
            //
            //  It's not the Add Printer Wizard.
            //
            fAPWSelected = FALSE;

            if (!MergeDevMode(szPrinterNameBuf))
            {
                rc = InstallDevMode(szPrinterNameBuf, NULL);
            }
            if (rc == kSuccess)
            {
                bChanged = TRUE;
            }
            else if (UninstallDevMode() == kSuccess)
            {
                bChanged = TRUE;
            }

            //
            //  Get the current printer name and the current devmode and
            //  update the printer status text.
            //
            GetCurrentPrinter();

            if( rc == kSuccess )
            {
                //
                // Clear the no access printer flag.
                //
                fNoAccessPrinterSelected = FALSE;

                //
                //  Make sure the OK button is enabled.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);

                //
                // Update the printer status.
                //
                UpdateStatus(*ppidlSel);
            }
            else
            {
                //
                // Save the fact we do not have access to this printer.
                //
                if( (rc == kAccessDenied) || (rc == kInvalidDevMode) )
                {
                    fNoAccessPrinterSelected = TRUE;
                }

                //
                //  Disable the OK and Apply buttons.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
                PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

                //
                // Nuke the status.
                //
                UpdateStatus(NULL);
            }
        }

        //
        //  Free the pidl.
        //
        LocalFree(ppidlSel);
    }
    //
    //  See if anything changed.
    //
    if (bChanged)
    {
        //
        //  Enable the Apply button.
        //
        PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();
    }

    //
    //  Return success.
    //
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsCurrentPrinter
//
//  Checks whether the given pidl represents the current printer
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsCurrentPrinter(LPCITEMIDLIST pidl)
{
    TCHAR szPrinterBufName[kPrinterBufMax];
    if (pszCurPrinter)
    {
        szPrinterBufName[0] = 0;
        GetViewItemText( psfRoot,
                         pidl,
                         szPrinterBufName,
                         ARRAYSIZE(szPrinterBufName),
                         SHGDN_FORPARSING);
        if (lstrcmpi(szPrinterBufName, pszCurPrinter) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnRename
//
//  Handles the Rename Notification
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnRename(LPCITEMIDLIST *ppidl)
{
    TCHAR szPrinterBufName[kPrinterBufMax];
    LPITEMIDLIST pidl;
    TCHAR szNewPrinter[kPrinterBufMax];

    pidl = ILFindLastID(ppidl[0]);

    szNewPrinter[0] = 0;
    GetViewItemText( psfRoot,
                     ILFindLastID(ppidl[1]),
                     szNewPrinter,
                     ARRAYSIZE(szNewPrinter),
                     SHGDN_FORPARSING);

    //Has user clicked on Apply and saved any printer information ?
    if (pPI->fApply)
    {                
        //Yes. Check if the printer that is renamed is the one that is saved.
        LPDEVNAMES pDN;
        
        if ((pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
        {
            //Get the saved  printer name from the DEVNAMES structure.
            szPrinterBufName[0] = 0;
            GetViewItemText( psfRoot,
                             pidl,
                             szPrinterBufName,
                             ARRAYSIZE(szPrinterBufName),
                             SHGDN_FORPARSING);

            //Is the saved printer and renamed printer the same ?
            if (!lstrcmpi(szPrinterBufName, ((LPTSTR)pDN + pDN->wDeviceOffset)))
            {
                //Yes. Updated the saved DEVMODE and DEVNAMES Structure.
                LPDEVMODE pDM;


                //Update the dev names struture with the new printer name.
                Print_SaveDevNames(szNewPrinter, pPD);
        
                //Update the device name in the devmode to new name 
                if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
                {
                    lstrcpyn(pDM->dmDeviceName, szNewPrinter, CCHDEVICENAME);
                    GlobalUnlock(pPD->hDevMode);
                }                        
            }
           
            GlobalUnlock(pPD->hDevNames);
        }
    }

    if (IsCurrentPrinter(pidl))
    {
        if (!MergeDevMode(szNewPrinter))
        {
            InstallDevMode(szNewPrinter, NULL);
        }        
    }

    return TRUE;

}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChangeNotify
//
//  Handle the change notification message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChangeNotify(
    LONG lNotification,
    LPCITEMIDLIST *ppidl)
{
    LPCITEMIDLIST pidl;
    UINT uRes = 0;
    TCHAR szPrinterBufName[kPrinterBufMax];

    //
    //  Get the pidl for the object.
    //
    pidl = ILFindLastID(ppidl[0]);

    //
    //  Handle the notification.
    //
    switch (lNotification)
    {
        case ( SHCNE_ATTRIBUTES ) :
        case ( SHCNE_UPDATEITEM ) :
        {
            if (NULL == pidl || ILIsEqual(ppidl[0], pidlRoot))
            {
                // pidl is NULL or equal to the local PF which means that full refresh 
                // has been requested. if the current object is the APW then try to select 
                // a printer.
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }
            else
            {
                //
                //  If the selected object is the one that changed, then
                //  update the status text.
                if (IsCurrentPrinter(pidl))
                {
                    UpdateStatus(pidl);

                    //
                    //  Reinit the copies and collate because these attributes may be changed
                    //
                    InitCopiesAndCollate();
                }
            }
            break;
        }

        case ( SHCNE_RENAMEITEM ) :
        {
            OnRename(ppidl);
            break;
        }


        case ( SHCNE_CREATE ) :
        {
            //
            //  If the Add Printer Wizard is selected when we get this
            //  message, then select the newly created object.
            //
            if (fAPWSelected == TRUE)
            {
                //
                //  Get the printer name.
                //
                szPrinterBufName[0] = 0;
                GetViewItemText( psfRoot,
                                 pidl,
                                 szPrinterBufName,
                                 ARRAYSIZE(szPrinterBufName),
                                 SHGDN_FORPARSING);

                //
                //  Add the appropriate device pages and select the
                //  new printer.
                //
                if (!MergeDevMode(szPrinterBufName))
                {
                    InstallDevMode(szPrinterBufName, NULL);
                }
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }
            break;
        }
        case ( SHCNE_DELETE ) :
        {
            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            // Check if the current printer has just been deleted.
            // If so - set appropriate flag and disable the print button.
            if (IsCurrentPrinter(pidl))
            {
                TCHAR szSavePrinterName[kPrinterBufMax];
                _tcsncpy(szSavePrinterName, szPrinter, ARRAYSIZE(szPrinter));
                szSavePrinterName[ARRAYSIZE(szPrinter)-1] = 0;

                //
                // Uninstall the current devmode and select the new default 
                // printer if any.
                //
                UninstallDevMode();
                InstallDevMode(NULL, NULL);
                SelectSVItem();

                //
                // If the devmode editor is open, we need to notify the user
                // that the printer has just been deleted.
                //
                if (fDevmodeEdit)
                {
                    //
                    // Display error message which indicates that the printer you are currently 
                    // editing properties for has just been deleted. Ask the user to close the
                    // driver UI dialog and select another printer.
                    //
                    fDirtyDevmode = TRUE;
                    ShowError(hwndDlg, 0, iszPrinterDeleted, szSavePrinterName);
                }
            }

            break;
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnAccelerator
//
//  Handles an input event message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnAccelerator(
    HWND hwndActivePrint,
    HWND hwndFocus,
    HACCEL haccPrint,
    PMSG pMsg)
{
    if (psv && (hwndFocus == hwndView))
    {
        if (psv->TranslateAccelerator(pMsg) == S_OK)
        {
            return (1);
        }

        if (haccPrint &&
            TranslateAccelerator(hwndActivePrint, haccPrint, pMsg))
        {
            return (1);
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNoPrinters
//
//  Displays a message box telling the user that they have no printers
//  installed.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnNoPrinters(HWND hDlg, UINT uID)
{
    if( iszNoPrinters == uID )
    {
        if (IDYES == ShowMessage(hDlg, IDC_PRINTER_LISTVIEW, uID, MB_YESNO|MB_ICONQUESTION, FALSE))
        {
            //
            // invoke the add printer wizard here
            //
            InvokeAddPrinterWizardModal(hwndDlg, NULL);
        }
    }
    else
    {
        ShowError(hDlg, IDC_PRINTER_LISTVIEW, uID);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDone
//
//  Handle the CDM_INITDONE message.  Initialization is complete, so
//  call IPrintDialogCallback::InitDone and then switch to the chosen
//  start page if it's not the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnInitDone()
{
    //
    //  See if we need to do this anymore.  This routine shouldn't be
    //  entered more than twice, but just in case.
    //
    if (nInitDone != -1)
    {
        //
        //  Make sure we have seen the CDM_INITDONE message for the
        //  completion of both the main dialog and the sub dialog.
        //
        if (nInitDone < 1)
        {
            //
            //  We only want to go through this code once.
            //
            nInitDone = -1;

            //
            //  Tell the sub dialog that initialization is complete.
            //
            InitDone();

            //
            //  Switch to the appropriate start page.
            //
            if (pPD->nStartPage != START_PAGE_GENERAL)
            {
                PropSheet_SetCurSel( GetParent(hwndDlg),
                                     NULL,
                                     pPD->nStartPage + 1 );
            }
        }
        else
        {
            nInitDone++;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreatePrintShellView
//
//  Creates the shell view window for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreatePrintShellView()
{
    RECT rcView;
    FOLDERSETTINGS fs;
    HRESULT hResult;
    HWND    hHiddenText;

    //
    //  Get the Printer Folder pidl.
    //
    pidlRoot = SHCloneSpecialIDList(hwndDlg, CSIDL_PRINTERS, TRUE);
    if (!pidlRoot)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_FAIL);
    }

    //
    //  Create an instance of IShellFolder and store it in the CPrintBrowser
    //  class.
    //
    hResult = Print_ICoCreateInstance( CLSID_CPrinters,
                                       IID_IShellFolder2,
                                       pidlRoot,
                                       (LPVOID *)&psfRoot );
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Get the private printer folder interface.
    //
    hResult = psfRoot->QueryInterface(IID_IPrinterFolder, (LPVOID *)&ppf);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Create the printer folder view.
    //
    GetWindowRect(GetDlgItem(hwndDlg, IDC_PRINTER_LIST), &rcView);
    MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView);

    fs.ViewMode = GetViewMode();
    fs.fFlags = FWF_AUTOARRANGE | FWF_SINGLESEL | FWF_ALIGNLEFT |
                FWF_SHOWSELALWAYS;

    hResult = psfRoot->CreateViewObject(hwndDlg, IID_IShellView, (LPVOID *)&psv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }
    hResult = psv->CreateViewWindow(NULL, &fs, this, &rcView, &hwndView);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    hResult = psv->UIActivate(SVUIA_INPLACEACTIVATE);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }
    //
    //  Get the shell folder view interface.
    //
    hResult = psv->QueryInterface(IID_IShellFolderView, (LPVOID *)&psfv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Move the view window to the right spot in the Z (tab) order.
    //
    SetWindowPos( hwndView,
                  HWND_TOP,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE );

    //
    //  Give it the right window ID for WinHelp and error selection.
    //
    SetWindowLong(hwndView, GWL_ID, IDC_PRINTER_LISTVIEW);

    //
    //  Move the hidden text ahead of the list view, thus the parent name of  
    //  the list view in MSAA is "Select Printer"
    //
    if (hHiddenText = GetDlgItem(hwndDlg, IDC_HIDDEN_TEXT))
    {
        SetParent(hHiddenText, hwndView);
        SetWindowPos(hHiddenText,
                     HWND_TOP,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW | SWP_NOACTIVATE);
    }

    //
    //  Show the window after creating the ShellView so we do not get a
    //  big ugly gray spot.
    //
    ShowWindow(hwndDlg, SW_SHOW);
    UpdateWindow(hwndDlg);

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::GetViewMode()
{
    HKEY hKey;
    UINT ViewMode = FVM_ICON;
    DWORD cbData;

    //
    //  Open the Printers\Settings registry key and read the information
    //  from the ViewMode value entry.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szSettings,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        cbData = sizeof(ViewMode);

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_szViewMode, NULL, NULL, (LPBYTE)&ViewMode, &cbData))
        {
            //
            // A "real" mode exist in the registry. Don't make
            // smart decisions for the view mode thereafter.
            //
            uDefViewMode = ViewMode;
        }

        RegCloseKey(hKey);
    }

    //
    //  Make sure it's in the correct range.
    //
    if (ViewMode > FVM_DETAILS)
    {
        ViewMode = FVM_ICON;
    }

    //
    //  Return the view mode.
    //
    return (ViewMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SetViewMode()
{
    HWND hwndListView;
    HKEY hKey;
    UINT ViewMode = VIEW_MODE_DEFAULT;
    DWORD cbData;

    //
    //  Get the current view mode.
    //
    if (psv && (hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL)))
    {
        FOLDERSETTINGS fs;
        psv->GetCurrentInfo(&fs);

        ViewMode = fs.ViewMode;
    }

    //
    // Check if the user changed the view mode
    //
    if( uDefViewMode != ViewMode )
    {
        //
        //  Open the Printers\Settings registry key and save the information
        //  to the ViewMode value entry.
        //
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szSettings,
                          0L,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            cbData = sizeof(ViewMode);
            RegSetValueEx(hKey, c_szViewMode, 0L, REG_DWORD, (LPBYTE)&ViewMode, cbData);
            RegCloseKey(hKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreateHookDialog
//
//  Creates the child window for the application specific area of the
//  General page.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreateHookDialog()
{
    DWORD Flags = pPD->Flags;
    HANDLE hTemplate;
    HINSTANCE hinst;
    LPCTSTR pDlg;
    RECT rcChild;
    DWORD dwStyle;
    LANGID LangID = (LANGID)TlsGetValue(g_tlsLangID);

    //
    //  See if there is a template.
    //
    if (Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        hTemplate = pPD->hInstance;
        hinst = ::g_hinst;
    }
    else
    {
        if (Flags & PD_ENABLEPRINTTEMPLATE)
        {
            pDlg = pPD->lpPrintTemplateName;
            hinst = pPD->hInstance;
            LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        }
        else
        {
            hinst = ::g_hinst;
            pDlg = MAKEINTRESOURCE(PRINTDLGEXORD);
        }

        HRSRC hRes = FindResourceExFallback(hinst, RT_DIALOG, pDlg, LangID);
        if (hRes == NULL)
        {
            pPI->dwExtendedError = CDERR_FINDRESFAILURE;
            return (E_HANDLE);
        }
        if ((hTemplate = LoadResource(hinst, hRes)) == NULL)
        {
            pPI->dwExtendedError = CDERR_LOADRESFAILURE;
            return (E_HANDLE);
        }
    }

    //
    //  Lock the resource.
    //
    if (!LockResource(hTemplate))
    {
        pPI->dwExtendedError = CDERR_LOADRESFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure the template is a child window.
    //
    dwStyle = ((LPDLGTEMPLATE)hTemplate)->style;
    if (!(dwStyle & WS_CHILD))
    {
        //
        //  I don't want to go poking in their template, and I don't want to
        //  make a copy, so I will just fail.  This also helps us weed out
        //  "old-style" templates that were accidentally used.
        //
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Get the callback interface pointer, if necessary.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface( IID_IPrintDialogCallback,
                                         (LPVOID *)&pCallback );
    }

    //
    //  Create the child dialog.
    //
    hSubDlg = CreateDialogIndirectParam( hinst,
                                         (LPDLGTEMPLATE)hTemplate,
                                         hwndDlg,
                                         Print_GeneralChildDlgProc,
                                         (LPARAM)pPD );
    if (!hSubDlg)
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Put the window in the designated spot on the General property page.
    //
    GetWindowRect(GetDlgItem(hwndDlg, grp2), &rcChild);
    MapWindowRect(NULL, hwndDlg, &rcChild);
    SetWindowPos( hSubDlg,
                  HWND_BOTTOM,
                  rcChild.left,
                  rcChild.top,
                  rcChild.right - rcChild.left,
                  rcChild.bottom - rcChild.top,
                  SWP_SHOWWINDOW );

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::UpdateStatus
//
//  Updates the static text for the currently selected printer.
//  The fields that are set are Status, Location, and Comment.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::UpdateStatus(
    LPCITEMIDLIST pidl)
{
    HRESULT hres;
    SHELLDETAILS Details;
    TCHAR szText[MAX_PATH];

    //
    //  If the pidl is NULL, then reset all of the static text to null
    //  strings.
    //
    if (!pidl)
    {
        szText[0] = 0;

        SetDlgItemText(hwndDlg, IDC_STATUS, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

        SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

        SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

        return (TRUE);
    }

    //
    //  Get the STATUS details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_STATUS, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_STATUS, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

    //
    //  Get the LOCATION details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_LOCATION, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

    //
    //  Get the COMMENT details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_COMMENT, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectSVItem
//
//  Selects the item in the shell view with the given printer name.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SelectSVItem()
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlItem = NULL;
    BOOL bPrinterSelected = FALSE;

    //  Make sure we have a shell view and a shell folder view.
    if (psv && psfv)
    {
        //  Make sure we have the current printer information.
        GetCurrentPrinter();

        if (!pDMCur || !pszCurPrinter || !pszCurPrinter[0])
        {
            //  If there is no current printer then we just select the add printer
            //  wizard object.
            hr = psfRoot->ParseDisplayName(hwndDlg, NULL, TEXT("WinUtils_NewObject"), NULL, &pidlItem, NULL);
            if (SUCCEEDED(hr) && pidlItem)
            {
                // just select the APW special object
                SelectPrinterItem(pidlItem);
            
                // Free up the PIDL using the shell allocator
                FreePIDL(pidlItem);

                //  It's the Add Printer Wizard.
                fAPWSelected = TRUE;

                //  Disable the OK and Apply buttons.
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
                PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
            }
        }
        else
        {
            //  there is a current printer then we just select it
            hr = psfRoot->ParseDisplayName(hwndDlg, NULL, pszCurPrinter, NULL, &pidlItem, NULL);
            if (SUCCEEDED(hr) && pidlItem)
            {
                // select the printer and update the status
                SelectPrinterItem(pidlItem);
                UpdateStatus(pidlItem);

                // Free up the PIDL using the shell allocator
                FreePIDL(pidlItem);

                //  It's not the Add Printer Wizard.
                fAPWSelected = FALSE;

                //  Enable the OK and Apply buttons.
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                // A printer object has been selected
                bPrinterSelected = TRUE;
            }
        }
    }

    return SUCCEEDED(hr) ? bPrinterSelected : FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinter
//
//  Saves the current printer name and the current devmode in the class.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetCurrentPrinter()
{
    DWORD dwSize = cchCurPrinter;

    //
    //  Reset the devmode and the current printer string.
    //
    pDMCur = NULL;
    if (pszCurPrinter && cchCurPrinter)
    {
        pszCurPrinter[0] = 0;
    }

    //
    //  Get the name of the current printer.
    //
    if (!GetInternalPrinterName(pszCurPrinter, &dwSize))
    {
        //
        //  Allocate a buffer large enough to hold the name of the
        //  current printer.
        //
        if (dwSize > cchCurPrinter)
        {
            if (pszCurPrinter)
            {
                LPTSTR pTemp = pszCurPrinter;
                pszCurPrinter = NULL;
                cchCurPrinter = 0;
                GlobalFree(pTemp);
            }
            pszCurPrinter = (LPTSTR)GlobalAlloc(GPTR, dwSize * sizeof(TCHAR));
            if (!pszCurPrinter)
            {
                return (FALSE);
            }
            cchCurPrinter = dwSize;
            if (cchCurPrinter)
            {
                pszCurPrinter[0] = 0;
            }
        }

        //
        //  Try to get the name of the current printer again.
        //
        if (!GetInternalPrinterName(pszCurPrinter,&dwSize))
        {
            return (FALSE);
        }
    }

    //
    //  Get the current devmode.
    //
    pDMCur = GetCurrentDevMode();
    if (!pDMCur)
    {
        pszCurPrinter[0] = 0;
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPrintToFile
//
//  Initializes the print to file on a selection change.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPrintToFile()
{
    HWND hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE);

    //
    //  See if there is a Print To File control.
    //
    if (hCtl)
    {
        //
        //  See if a printer is selected.
        //
        if (pDMCur)
        {
            //
            //  A printer is selected, so enable the print to file if
            //  appropriate.
            //
            if (!(pPI->dwFlags & (PD_HIDEPRINTTOFILE | PD_DISABLEPRINTTOFILE)))
            {
                EnableWindow(hCtl, TRUE);
            }
        }
        else
        {
            //
            //  A printer is not selected, so disable it.
            //
            EnableWindow(hCtl, FALSE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPageRangeGroup
//
//  Initializes the page range group on a selection change.  It decides
//  which controls should be enabled when a selection change occurs from
//  the Add Printer Wizard.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPageRangeGroup()
{
    //
    //  See if a printer is selected.
    //
    if (pDMCur)
    {
        //
        //  A printer is selected, so enable the appropriate page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), TRUE);
        if (!(pPI->dwFlags & PD_NOSELECTION))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOCURRENTPAGE))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOPAGENUMS))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), TRUE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), TRUE);
        }
    }
    else
    {
        //
        //  A printer is not selected, so disable all of the page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitCopiesAndCollate
//
//  Initializes the copies and collate information in the devmode and the
//  print dialog structure.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitCopiesAndCollate()
{
    HWND hCtl;
    UINT IsCollate = FALSE;
    RECT rc;
    BOOL bEnabledCopies = TRUE;

    //
    //  Save the collate state so that the collate icon doesn't flicker on
    //  a selection change.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
    {
        IsCollate = IsDlgButtonChecked(hSubDlg, IDC_COLLATE);
    }

    //
    //  See what the printer driver can do and what the app requested
    //  and set the copies and collate accordingly.
    //
    if (pDMCur)
    {
        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            //
            // Modify the edit control and up-down arrow if needed
            //
            WORD    cDigits;

            //
            // If the calling application handles copies and collate, we
            // set max copies as 9999, else, we get the max copies from driver
            //
            if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
            {
                szScratch[0] = 0;
                Print_GetPortName(pszCurPrinter, szScratch, ARRAYSIZE(szScratch));
                nMaxCopies = DeviceCapabilities( pszCurPrinter,
                                                 szScratch,
                                                 DC_COPIES,
                                                 NULL,
                                                 NULL );
                //
                // If DeviceCapabilities() returns error, disable the controls
                //
                if ((nMaxCopies < 1) || (nMaxCopies == (DWORD)(-1)))
                {
                    nMaxCopies = 1;
                    nCopies = 1;
                    bEnabledCopies = FALSE;
                }
            }
            else
            {
                //
                // Assume the calling app will take care of multi-copies
                //
                nMaxCopies = MAX_COPIES;
            }

            if (nMaxCopies < nCopies)
            {
                nCopies = nMaxCopies;
            }

            cDigits = CountDigits(nMaxCopies);
            Edit_LimitText(hCtl, cDigits);

            SendMessage(GetDlgItem(hSubDlg, IDC_COPIES_UDARROW), UDM_SETRANGE, 
                0, MAKELONG(nMaxCopies, 1));
            InvalidateRect(GetDlgItem(hSubDlg, IDC_COPIES_UDARROW), NULL, FALSE);
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            DWORD   dwCollate;
            BOOL    bEnabled = TRUE;

            if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
            {
                szScratch[0] = 0;
                Print_GetPortName(pszCurPrinter, szScratch, ARRAYSIZE(szScratch));
                dwCollate = DeviceCapabilities(  pszCurPrinter,
                                                 szScratch,
                                                 DC_COLLATE,
                                                 NULL,
                                                 NULL );
                fAllowCollate = ((dwCollate < 1) || (dwCollate == (DWORD)-1)) ? FALSE : TRUE;
            }
            else 
            {
                //
                // Assume the calling app will take care of collation
                //
                fAllowCollate = TRUE;
            }

            if ( fAllowCollate )
            {
                EnableWindow(hCtl, (nCopies > 1));
                CheckDlgButton( hSubDlg,
                                IDC_COLLATE,
                                fCollateRequested ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);
            }

            //
            //  Display the appropriate collate icon if it changed.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) &&
                (IsCollate != IsDlgButtonChecked(hSubDlg, IDC_COLLATE)))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             IsCollate
                                 ? (LONG_PTR)hIconNoCollate
                                 : (LONG_PTR)hIconCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }

        //
        // We have to do it here because after setting the text, fAllowCollate
        // will be used
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            SetDlgItemInt(hSubDlg, IDC_COPIES, nCopies, FALSE);
            EnableWindow(hCtl, bEnabledCopies);
            EnableWindow(hwndUpDown, bEnabledCopies);
        }
    }
    else if (fNoAccessPrinterSelected)
    {
        // if No Access Printer is selected merely disable the Copies and Collate
        // Dont change any information user entered.

        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            EnableWindow(hCtl, FALSE);
            EnableWindow(hwndUpDown, FALSE);
        }
        
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
        }

        //
        //  Disable the Apply button It gets turned back on when the copies and collate values are
        //  disabled.
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    }
    else
    {
        //
        //  A printer is not selected, so disable copies and collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            SetDlgItemInt(hSubDlg, IDC_COPIES, 1, FALSE);
            EnableWindow(hCtl, FALSE);
            EnableWindow(hwndUpDown, FALSE);
        }
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
            CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);

            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) && IsCollate)
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }

        //
        //  Disable the Apply button since a printer is not selected.
        //  It gets turned back on when the copies and collate values are
        //  disabled.
        //
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveCopiesAndCollateInDevMode
//
//  Saves the copies and collate information in the given devmode.  This
//  routine does not affect the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SaveCopiesAndCollateInDevMode(
    LPDEVMODE pDM,
    LPTSTR pszPrinter)
{
    //
    //  Make sure we have a devmode and a printer name.
    //
    if (!pDM || !pszPrinter || !(pszPrinter[0]))
    {
        return (FALSE);
    }

    //
    // verify number of copies is less than max value
    //
    if( nMaxCopies < nCopies )
    {
        return (FALSE);
    }

    //
    //  Move the info to the devmode.
    //
    pDM->dmCopies = (short)nCopies;
    SetField(pDM, dmCollate, (fAllowCollate && fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetCopiesOnApply
//
//  Sets the appropriate number of copies in the PrintDlgEx structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SetCopiesOnApply()
{
    if (pDMCur)
    {
        if (!(pDMCur->dmFields & DM_COPIES))
        {
Print_LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the copy/collate
            //  info in the pPD.
            //
            pDMCur->dmCopies = 1;
            SetField(pDMCur, dmCollate, DMCOLLATE_FALSE);
        }
        else if ((pDMCur->dmSpecVersion < 0x0400) ||
                 (!(pDMCur->dmFields & DM_COLLATE)))
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto Print_LeaveInfoInPD;
            }
            else
            {
                goto Print_PutInfoInDevMode;
            }
        }
        else
        {
Print_PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pszCurPrinter)
            {
                goto Print_LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number of copies
            //  requested.
            //
            if (nMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
                {
                    ShowError(hSubDlg, IDC_COPIES, iszTooManyCopies, nMaxCopies);
                    pPD->nCopies = nMaxCopies;
                    return (FALSE);
                }
                else
                {

                    goto Print_LeaveInfoInPD;
                }
            }

            //
            //  The driver can do both copies and collate, so move the info
            //  to the devmode.
            //
            pDMCur->dmCopies = (short)pPD->nCopies;
            SetField( pDMCur,
                      dmCollate,
                      (fAllowCollate && (pPD->Flags & PD_COLLATE)) 
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveDevMode
//
//  Saves the current devmode in the pPD structure on Apply.
//  Assumes pDMCur has the current information.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SaveDevMode()
{
    DWORD cbSize;
    HANDLE hDevMode = NULL;
    LPDEVMODE pDM;

    //
    //  Allocate the space for the new DevMode and copy the
    //  information.
    //
    if (pDMCur)
    {
        cbSize = (DWORD)(pDMCur->dmSize + pDMCur->dmDriverExtra);
        hDevMode = GlobalAlloc(GHND, cbSize);
        if (hDevMode)
        {
            pDM = (LPDEVMODE)GlobalLock(hDevMode);
            if (pDM)
            {
                CopyMemory(pDM, pDMCur, cbSize);
                GlobalUnlock(hDevMode);
            }
            else
            {
                GlobalFree(hDevMode);
                hDevMode = NULL;
            }
        }
    }
    if (!hDevMode)
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        pPI->hResult = E_OUTOFMEMORY;
        pPI->FinalResult = 0;
    }

    //
    //  Free the copy of the DevMode handle passed in by the app.
    //
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Save the new DevMode in the pPD structure.
    //
    pPD->hDevMode = hDevMode;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::MergeDevMode
//
//  Merges the current devmode with the default devmode of the newly
//  selected printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::MergeDevMode(
    LPTSTR pszPrinterName)
{
    HANDLE  hDevMode = NULL;
    LPDEVMODE pDMNew  = NULL;
    LPDEVMODE pDMOld = NULL;
    BOOL bRet = TRUE;
    DWORD dmFields;
    short dmDefaultSource;

    //
    //  See if the printer name is NULL.  If so, we need to get the default
    //  printer loaded.  This happens when a printer is deleted.
    //
    if (!pszPrinterName)
    {
        ASSERT(0);
        return FALSE;
    }
    else
    {
        //
        //  Get the devmode for the old (current driver pages) printer.
        //
        GetCurrentPrinter();
        pDMOld = pDMCur ? pDMCur : pDMSave;
        if (!pDMOld)
        {
            return (FALSE);
        }

        hDevMode = Print_GetDevModeWrapper(pszPrinterName, NULL);

        if (hDevMode)
        {
            pDMNew = (LPDEVMODE)GlobalLock(hDevMode);
        }
        else
        {
            return FALSE;
        }

        if (!pDMNew)
        {
            GlobalFree(hDevMode);
            return FALSE;
        }

        dmFields = 0;
        dmDefaultSource = pDMNew->dmDefaultSource;

        if (pDMNew->dmFields & DM_DEFAULTSOURCE)
        {
            dmFields = DM_DEFAULTSOURCE;
        }

        //Check if the old devmode has any info to copy
        if (pDMOld->dmFields)
        {
            CopyMemory(&(pDMNew->dmFields), 
                       &(pDMOld->dmFields), 
                       sizeof(DEVMODE) - FIELD_OFFSET(DEVMODE, dmFields));
        }

        pDMNew->dmFields |= dmFields;
        pDMNew->dmDefaultSource = dmDefaultSource;

        pDMNew->dmFields = pDMNew->dmFields & ( DM_ORIENTATION  | DM_PAPERSIZE    |
                                                DM_PAPERLENGTH  | DM_PAPERWIDTH   |
                                                DM_SCALE        | DM_COPIES       |
                                                DM_COLLATE      | DM_FORMNAME     |
                                                DM_DEFAULTSOURCE);

        //
        //  Insert the device pages - this call will yield a proper devmode.
        //
        if (UninstallDevMode() != kSuccess || InstallDevMode(pszPrinterName, pDMNew) != kSuccess)
        {
            bRet = FALSE;
        }

        //Free the new devmode that was allocated

        if (hDevMode)
        {
            GlobalUnlock(hDevMode);
            GlobalFree(hDevMode);
        }
    }


    //
    //  Return the result.
    //
    return (bRet);

}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsValidPageRange
//
//  Checks the validity of the page range string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsValidPageRange(
    LPTSTR pszString,
    UINT *pErrorId)
{
    LPTSTR pStr = pszString;
    BOOL bDigit = FALSE;
    BOOL bOld;
    UINT Number, Ctr;
    DWORD nNumRanges = 0;
    BOOL bFrom = TRUE;

    //
    //  Initially set the error id to 0.
    //
    *pErrorId = 0;

    //
    //  See if we can only have a single page range.
    //
    bOld = (nMaxPageRanges == 1);

    //
    //  Go through the string and validate the entries.
    //
    while (*pStr)
    {
        if (ISDIGIT(*pStr))
        {
            //
            //  Make sure there is room for another range.
            //
            if (nNumRanges >= nMaxPageRanges)
            {
                break;
            }

            //
            //  Found a digit.
            //
            bDigit = TRUE;

            //
            //  Make sure the page number is in the given page range.
            //
            Number = 0;
            while (ISDIGIT(*pStr))
            {
                Number *= 10;
                Number += *pStr - TEXT('0');
                pStr++;
            }
            pStr--;

            if ((Number < pPD->nMinPage) || (Number > pPD->nMaxPage))
            {
                *pErrorId = iszBadPageRange;
                return (FALSE);
            }

            //
            //  Save the value in the page range structure.
            //
            if (bFrom)
            {
                pPageRanges[nNumRanges].nFromPage = Number;
                bFrom = FALSE;
            }
            else
            {
                pPageRanges[nNumRanges].nToPage = Number;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else if (*pStr == TEXT('-'))
        {
            //
            //  Found a hyphen.  Make sure there is a digit preceding it
            //  and following it.  Also, make sure there isn't something
            //  like 1-2-3.
            //
            if (!bDigit || bFrom || !ISDIGIT(*(pStr + 1)))
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;
        }
        else if ((*pStr == szListSep[0]) || (*pStr == TEXT(',')))
        {
            //
            //  Found a list separator.  Make sure there is a digit
            //  preceding it.
            //
            if (!bDigit)
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;

            //
            //  If it's the list separator string instead of the simple
            //  comma, then make sure the entire list separator string
            //  is there.
            //  This will advance the string up to the last character
            //  of the list separator string.
            //
            if ((*pStr == szListSep[0]) &&
                ((szListSep[0] != TEXT(',')) || (!ISDIGIT(*(pStr + 1)))))
            {
                for (Ctr = 1; Ctr < nListSep; Ctr++)
                {
                    pStr++;
                    if (*pStr != szListSep[Ctr])
                    {
                        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                         : iszBadPageRangeSyntaxNew;
                        return (FALSE);
                    }
                }
            }

            //
            //  Make sure the From/To page range is complete.
            //
            if (!bFrom)
            {
                pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else
        {
            //
            //  Found an invalid character.
            //
            *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                             : iszBadPageRangeSyntaxNew;
            return (FALSE);
        }

        //
        //  Advance the string pointer.
        //
        pStr++;
    }

    //
    //  Make sure we reached the end of the string.
    //
    if (*pStr)
    {
        *pErrorId = iszTooManyPageRanges;
        return (FALSE);
    }

    //
    //  Make sure the last thing in the string was a digit.
    //
    if (!bDigit)
    {
        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                         : iszBadPageRangeSyntaxNew;
        return (FALSE);
    }

    //
    //  Make sure the last From/To page range is complete.
    //
    if (!bFrom)
    {
        pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
        bFrom = TRUE;
        nNumRanges++;
    }

    //
    //  Save the number of page ranges.
    //
    nPageRanges = nNumRanges;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ConvertPageRangesToString
//
//  Converts the page ranges to a string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::ConvertPageRangesToString(
    LPTSTR pszString,
    UINT cchLen)
{
    LPTSTR pStr = pszString;
    DWORD nFromPage, nToPage;
    UINT cch = cchLen - 1;
    UINT Ctr, Ctr2, Count;

    //
    //  Initialize the string.
    //
    if (cchLen)
    {
        pszString[0] = 0;
    }

    //
    //  Validate the ranges and create the string.
    //
    for (Ctr = 0; Ctr < nPageRanges; Ctr++)
    {
        //
        //  Get the range.
        //
        nFromPage = pPageRanges[Ctr].nFromPage;
        nToPage   = pPageRanges[Ctr].nToPage;

        //
        //  Make sure the range is valid.
        //
        if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
            (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
        {
            return (FALSE);
        }

        //
        //  Make sure it's not 0xFFFFFFFF.
        //
        if (nFromPage == 0xFFFFFFFF)
        {
            continue;
        }

        //
        //  Put it in the string.
        //
        Count = IntegerToString(nFromPage, pStr, cch);
        if (!Count)
        {
            return (FALSE);
        }
        pStr += Count;
        cch -= Count;

        if ((nFromPage == nToPage) || (nToPage == 0xFFFFFFFF))
        {
            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
        else
        {
            if (!cch)
            {
                return (FALSE);
            }
            *pStr = TEXT('-');
            pStr++;
            cch--;

            Count = IntegerToString(nToPage, pStr, cch);
            if (!Count)
            {
                return (FALSE);
            }
            pStr += Count;
            cch -= Count;

            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
    }

    *pStr = '\0';

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IntegerToString
//
//  Converts an integer to a string and returns the number of characters
//  written to the buffer (not including the null).
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::IntegerToString(
    DWORD Value,
    LPTSTR pszString,
    UINT cchLen)
{
    DWORD TempValue = Value;
    UINT NumChars = 1;
    UINT Ctr;

    //
    //  Get the number of characters needed.
    //
    while (TempValue = TempValue / 10)
    {
        NumChars++;
    }

    //
    //  Make sure there is enough room in the buffer.
    //
    if (NumChars > cchLen)
    {
        return (0);
    }

    //
    //  Make the string.
    //
    TempValue = Value;
    for (Ctr = NumChars; Ctr > 0; Ctr--)
    {
        pszString[Ctr - 1] = ((WORD)(TempValue % 10)) + TEXT('0');
        TempValue = TempValue / 10;
    }

    //
    //  Return the number of characters written to the buffer.
    //
    return (NumChars);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ShowError
//
//  Shows up an error message box
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::ShowError(HWND hDlg, UINT uCtrlID, UINT uMsgID, ...)
{
    va_list args;
    va_start(args, uMsgID);

    InternalShowMessage(hDlg, uCtrlID, uMsgID, MB_ICONEXCLAMATION|MB_OK, TRUE, args);

    va_end(args);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ShowMessage
//
//  Shows up a message box with the specified flags & parameters
//
////////////////////////////////////////////////////////////////////////////
int CPrintBrowser::ShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, ...)
{
    va_list args;
    va_start(args, bBeep);

    int iRet = InternalShowMessage(hDlg, uCtrlID, uMsgID, uType, bBeep, args);

    va_end(args);
    
    return iRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InternalShowMessage
//
//  Shows up a message box with the specified flags & parameters
//  Internal version
//
//  Assumes the control is not disabled.
//
////////////////////////////////////////////////////////////////////////////
int CPrintBrowser::InternalShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, va_list args)
{
    int iRet = IDCANCEL;

    if (!(pPI->dwFlags & PD_NOWARNING))
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szFormat[MAX_PATH];
        TCHAR szMessage[MAX_PATH];
        
        //
        // Get msg box title & load the format string
        //
        if ( GetWindowText(GetParent(hwndDlg), szTitle, ARRAYSIZE(szTitle)) &&
             CDLoadString(g_hinst, uMsgID, szFormat, ARRAYSIZE(szFormat)) )
        {
            if (bBeep)
            {
                MessageBeep(MB_ICONEXCLAMATION);
            }

            //
            // format the message to be shown and call MessageBox over
            // the last active popup
            //
            wvnsprintf(szMessage, ARRAYSIZE(szMessage), szFormat, args);
            HWND hWndOwner = ::GetWindow(GetParent(hwndDlg), GW_OWNER);
            HWND hWndLastPopup = GetLastActivePopup(hWndOwner);
            
            iRet = MessageBox(hWndLastPopup, szMessage, szTitle, uType);
        }
        
        HWND hCtrl = ((0 == uCtrlID) ? NULL : GetDlgItem(hDlg, uCtrlID)); 
        if (hCtrl)
        {
            //
            // select & highlight the invalid value. we assume it 
            // is an edit box, if it isn't then EM_SETSEL won't be
            // processed and it's OK.
            //
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hCtrl, 1L);
            SendMessage(hCtrl, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        }
    }

    return iRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::FitViewModeBest
//
//  Adjust the view mode if the mini printers folder, so the printer names
//  fit best. This i8s necessary mainly because of accessibility problems.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::FitViewModeBest(HWND hwndListView)
{
    BOOL bResult = FALSE;

    if (VIEW_MODE_DEFAULT == uDefViewMode)
    {
        //
        // Asssume icon view by default.
        //
        uDefViewMode = FVM_ICON;

        //
        // If we are in a large icons view then check if something 
        // doesn't fit vertically - the only reliable way to do this
        // is to check if we scrolled the view (origin.y > 0)
        //
        if (LVS_ICON == (GetWindowLong(hwndListView, GWL_STYLE) & LVS_TYPEMASK))
        {
            POINT ptOrg;
            ListView_GetOrigin(hwndListView, &ptOrg);

            if (ptOrg.y > 0)
            {
                //
                // Switch the defview to List mode.
                //
                SendMessage(hwndView, WM_COMMAND, (WPARAM)SFVIDM_VIEW_LIST,0);

                uDefViewMode = FVM_LIST;
                bResult = TRUE;
            }
        }
    }

    return bResult;
}

VOID CPrintBrowser::SelectPrinterItem(LPITEMIDLIST pidlItem)
{
    BOOL bLocked = FALSE;
    HWND hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);

    if (hwndListView)
    {
        //
        // Disable the window update to prevent flickers
        //
        bLocked = LockWindowUpdate(hwndListView);
    }

    //
    // Try to make the printer item visible first
    //
    psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED | SVSI_ENSUREVISIBLE);

    //
    // Check to see if the view mode need to be changed
    //
    if (hwndListView && FitViewModeBest(hwndListView))
    {
        //
        // The view mode has been changed - call select item again
        // to ensure the visibility of the slected item in the new 
        // view mode.
        //
        psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED | SVSI_ENSUREVISIBLE);
    }

    if (hwndListView && bLocked)
    {
        //
        // Enable the window update
        //
        LockWindowUpdate(NULL);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::FindPrinter
//
//  Invokes the find in the DS ui using printui!bPrinterSetup interface
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::FindPrinter(HWND hwnd, LPTSTR pszBuffer, UINT cchSize)
{ 
    BOOL bReturn = FALSE;
    if (g_pfnPrinterSetup)
    {
        //
        // Invoke the DSUI to find a printer
        //
        bReturn = g_pfnPrinterSetup(hwnd, MSP_FINDPRINTER, cchSize, pszBuffer, &cchSize, NULL);

        // select the printer's list control
        SendMessage(hwndDlg, WM_NEXTDLGCTL, 
            reinterpret_cast<WPARAM>(GetDlgItem(hwndDlg, IDC_PRINTER_LISTVIEW)), 1);
    }
    return bReturn; 
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetInternalPrinterName
//
//  Returns the current printer name
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetInternalPrinterName(LPTSTR pszBuffer, DWORD *pdwSize)
{ 
    BOOL bReturn = FALSE;

    if (pdwSize)
    {
        //
        // If a buffer was provided and it is large enough, then copy the printer name.
        //
        DWORD iLen = _tcslen(szPrinter);
        if (pszBuffer && *pdwSize > iLen)
        {
            _tcsncpy(pszBuffer, szPrinter, *pdwSize);
            bReturn = TRUE;
        }
        else
        {
            //
            // Set the required length and the last error code.
            //
            *pdwSize = iLen + 1;
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
        }
    }

    return bReturn;
} 

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentDevMode
//
//  Returns the current internal devmode
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODE CPrintBrowser::GetCurrentDevMode()
{ 
    return pInternalDevMode; 
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetDefaultDevMode
//
//  Retrieve the default devmode for the specified printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetDefaultDevMode(HANDLE hPrinter, LPCTSTR pszPrinterName, PDEVMODE *ppDevMode, BOOL bFillWithDefault)
{
    LONG lResult = 0;
    PDEVMODE pDevMode = NULL;

    //
    // Call document properties to get the size of the devmode.
    //
    lResult = DocumentProperties(NULL, hPrinter, (LPTSTR)pszPrinterName, NULL, NULL, 0);

    //
    // If the size of the devmode was returned then allocate memory.
    //
    if( lResult > 0 )
    {
        // GPTR initializes the memory with zeros.
        pDevMode = (PDEVMODE)GlobalAlloc(GPTR, lResult);
    }

    //
    // If allocated then copy back the pointer.
    //
    if( pDevMode )
    {
        if( bFillWithDefault )
        {
            //
            // Call document properties to get the default dev mode.
            //
            lResult = DocumentProperties(NULL, hPrinter, (LPTSTR)pszPrinterName, pDevMode, NULL, DM_OUT_BUFFER);
        }

        if( lResult >= 0 )
        {
            *ppDevMode = pDevMode;
        }
        else
        {
            GlobalFree((HANDLE)pDevMode);
        }
    }

    return (*ppDevMode != NULL);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::WrapEnumPrinters
//
//  Wraps EnumPrinters API into more friendly interface
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::WrapEnumPrinters(DWORD dwFlags, LPCTSTR pszServer, DWORD dwLevel, PVOID* ppvBuffer, PDWORD pcbBuffer, PDWORD pcPrinters)
{
    BOOL bResult = FALSE;

    if (ppvBuffer && pcbBuffer && pcPrinters)
    {
        DWORD cbNeeded;

        //
        // Pre-initialize *pcbPrinter if it's not set.
        //
        if (!*pcbBuffer)
        {
            *pcbBuffer = kInitialPrinterHint;
        }

        do
        {
            if (!*ppvBuffer)
            {
                *ppvBuffer = (PVOID)GlobalAlloc(GPTR, *pcbBuffer);

                if (!*ppvBuffer)
                {
                    *pcbBuffer = 0;
                    *pcPrinters = 0;
                    return FALSE;
                }
            }

            if (EnumPrinters( dwFlags, (LPTSTR)pszServer, dwLevel, (PBYTE)*ppvBuffer, *pcbBuffer, &cbNeeded, pcPrinters))
            {
                //
                // Everything went fine
                //
                bResult = TRUE;
                break;
            }

            //
            // Check to see whether the buffer is too small.
            //
            GlobalFree((HANDLE)(*ppvBuffer));
            *ppvBuffer = NULL;

            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                *pcbBuffer = cbNeeded;
                continue;
            }

            //
            // Something else (not the buffer) went wrong. Return FALSE.
            //
            *pcbBuffer = 0;
            *pcPrinters = 0;
            break;

        } while(1);
    }

    return bResult;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetUsablePrinter
//
//  Try to find a usable printer
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetUsablePrinter(LPTSTR szPrinterNameBuf, DWORD *pcchBuf)
{
    BOOL bStatus = FALSE;
    DWORD cchBuf = *pcchBuf;
    HANDLE hPrinter = NULL;

    if (szPrinterNameBuf && pcchBuf)
    {
        //
        // Attempt to the get the default printer.
        //
        bStatus = GetDefaultPrinter(szPrinterNameBuf, pcchBuf);

        //
        // Lets just try and open the printer to see if we have access to
        // the default printer.
        //
        if (bStatus)
        {
            bStatus = OpenPrinter(szPrinterNameBuf, &hPrinter, NULL);

            if( bStatus )
            {
                ClosePrinter( hPrinter );
                hPrinter = NULL;
                bStatus = TRUE;
            }
        }

        if (!bStatus)
        {
            PRINTER_INFO_4 *pInfo4      = NULL;
            DWORD           cInfo4      = 0;
            DWORD           cbInfo4     = 0;

            //
            // Enumerate the current printers.
            //
            bStatus = WrapEnumPrinters( 
                PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                NULL,
                4,
                reinterpret_cast<PVOID *>( &pInfo4 ),
                &cbInfo4,
                &cInfo4 );

            if( bStatus )
            {
                //
                // Assume failure.
                //
                bStatus = FALSE;

                //
                // Open the printers until we find one we have access to.
                //
                for( UINT i = 0; i < cInfo4; i++ )
                {
                    bStatus = OpenPrinter(pInfo4[i].pPrinterName, &hPrinter, NULL);

                    if (bStatus)
                    {
                        //
                        // Found a usable printer
                        //
                        _tcsncpy(szPrinterNameBuf, pInfo4[i].pPrinterName, cchBuf);
                        ClosePrinter( hPrinter );
                        bStatus = TRUE;
                        break;
                    }
                }
            }

            if( pInfo4 )
            {
                GlobalFree((HANDLE)pInfo4);
            }
        }
    }

    return bStatus;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetInternalDevMode
//
//  Get the internal devmode for this printer and merge with pInDevMode
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetInternalDevMode(PDEVMODE *ppOutDevMode, LPCTSTR pszPrinter, HANDLE hPrinter, PDEVMODE pInDevMode)
{
    BOOL bStatus = FALSE;

    if (ppOutDevMode)
    {
        *ppOutDevMode = NULL;

        //
        // Get the default devmode for this printer.
        //
        bStatus = GetDefaultDevMode(hPrinter, pszPrinter, ppOutDevMode, TRUE);

        //
        // If fetched a default devmode and we were passed a devmode
        // then call the driver to merge the devmodes for us.
        //
        if (bStatus)
        {
            if (pInDevMode)
            {
                //
                // Call document properties to get a merged copy of the devmode.
                //
                bStatus = DocumentProperties( NULL,
                    hPrinter,
                    const_cast<LPTSTR>( pszPrinter ),
                    *ppOutDevMode,
                    pInDevMode,
                    DM_IN_BUFFER|DM_OUT_BUFFER ) >= 0;

                //
                // If something failed release any allocated memory.
                //
                if (!bStatus)
                {
                    GlobalFree((HANDLE)(*ppOutDevMode));
                    *ppOutDevMode = NULL;
                }
            }
        }
    }

    return bStatus;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InstallDevMode
//
//  Install a new internal devmode
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::InstallDevMode(LPCTSTR pszPrinterName, PDEVMODE pDevModeToMerge) 
{ 
    UINT uResult = kError;
    TCHAR szBuffer[kPrinterBufMax];
    HANDLE hTempPrinter = NULL;
    PDEVMODE pTempDevMode = NULL;

    //
    // If a null printer name was specified use the default printer.
    //
    if (!pszPrinterName || !*pszPrinterName)
    {
        DWORD dwSize = ARRAYSIZE(szBuffer);
        
        if (GetUsablePrinter(szBuffer, &dwSize))
        {
            pszPrinterName = szBuffer;
        }
        else
        {
            //
            // If a usable printer was not found then use the default
            // printer, we do this because we want to select at least
            // one printer even though we may not have access to it.
            //
            dwSize = ARRAYSIZE(szBuffer);

            if (GetDefaultPrinter(szBuffer, &dwSize))
            {
                pszPrinterName = szBuffer;
            }
        }
    }

    if (pszPrinterName && _tcsicmp(pszPrinterName, szPrinter))
    {
        if (OpenPrinter((LPTSTR)pszPrinterName, &hTempPrinter, NULL))
        {
            if (GetInternalDevMode(&pTempDevMode, pszPrinterName, hTempPrinter, pDevModeToMerge))
            {
                if (hPrinter)
                {
                    ClosePrinter(hPrinter);
                    hPrinter = NULL;
                }

                if (pInternalDevMode)
                {
                    GlobalFree((HANDLE)pInternalDevMode);
                    pInternalDevMode = NULL;
                }

                _tcsncpy(szPrinter, pszPrinterName, ARRAYSIZE(szPrinter));
                hPrinter = hTempPrinter;
                pInternalDevMode = pTempDevMode;
                
                //
                // Prevent deleting these at the end of the function
                //
                hTempPrinter = NULL;
                pTempDevMode = NULL;

                uResult = kSuccess;
            }
            else
            {
                uResult = kInvalidDevMode;
            }
        }
        else
        {
            if (ERROR_ACCESS_DENIED == GetLastError())
            {
                uResult = kAccessDenied;
            }
            else
            {
                uResult = kInvalidPrinterName;
            }        
        }
    }
    else
    {
        //
        // Attemting to install the same printer/devmode - success.
        //
        uResult = kSuccess;
    }

    //
    // Release the open printer handle.
    //
    if (hTempPrinter)
    {
        ClosePrinter(hTempPrinter);
    }

    //
    // Release the temp devmode.
    //
    if (pTempDevMode)
    {
        GlobalFree((HANDLE)pTempDevMode);
    }


    if (pInternalDevMode && kSuccess == uResult)
    {
        //
        // Enable the driver UI button
        //
        EnableWindow( GetDlgItem( hwndDlg, IDC_DRIVER ), TRUE );
    }

    return uResult; 
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InstallDevMode
//
//  Unintall the current devmode
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::UninstallDevMode()
{ 
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
        hPrinter = NULL;
    }

    if (pInternalDevMode)
    {
        GlobalFree((HANDLE)pInternalDevMode);
        pInternalDevMode = NULL;
    }

    //
    // Clear the internal printer name.
    //
    szPrinter[0] = 0;

    //
    // Disable the driver UI button
    //
    EnableWindow( GetDlgItem( hwndDlg, IDC_DRIVER ), FALSE );

    return kSuccess;
}

////////////////////////////////////////////////////////////////////////////
//
//  InvokeAddPrinterWizardModal
//
//  This is a global API declared in comdlg32.h
//
////////////////////////////////////////////////////////////////////////////

HRESULT 
InvokeAddPrinterWizardModal(
    IN  HWND hwnd,
    OUT BOOL *pbPrinterAdded
    )
{
    HRESULT hr = S_OK;
    if (Print_LoadLibraries() && g_pfnPrinterSetup)
    {
        BOOL bPrinterAdded = FALSE;
        TCHAR szBuffer[kPrinterBufMax];
        UINT uSize = ARRAYSIZE(szBuffer);
        szBuffer[0] = 0;

        //
        // Invoke the Add Printer Wizard here
        //
        bPrinterAdded = g_pfnPrinterSetup(hwnd, MSP_NEWPRINTER, uSize, szBuffer, &uSize, NULL);

        if (pbPrinterAdded)
        {
            *pbPrinterAdded = bPrinterAdded;
        }
    }
    else
    {
        hr = CreateError();
    }
    return hr;
}

/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

HRESULT ThunkPrintDlgEx(
    PPRINTINFOEX pPI,
    LPPRINTDLGEXA pPDA)
{
    LPPRINTDLGEXW pPDW;
    LPDEVMODEA pDMA;
    DWORD cbLen;

    if (!pPDA)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGEXA))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    if (!(pPDW = (LPPRINTDLGEXW)GlobalAlloc(GPTR, sizeof(PRINTDLGEXW))))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return (E_OUTOFMEMORY);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize      = sizeof(PRINTDLGEXW);
    pPDW->hwndOwner        = pPDA->hwndOwner;
    pPDW->ExclusionFlags   = pPDA->ExclusionFlags;
    pPDW->hInstance        = pPDA->hInstance;
    pPDW->lpCallback       = pPDA->lpCallback;
    pPDW->nPropertyPages   = pPDA->nPropertyPages;
    pPDW->lphPropertyPages = pPDA->lphPropertyPages;
    pPDW->nStartPage       = pPDA->nStartPage;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA((LPCSTR)pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    //
    //  Thunk Device Names A => W
    //
    pPDW->hDevNames = NULL;
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName = (LPCWSTR)
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                return (E_OUTOFMEMORY);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpPrintTemplateName,(LPWSTR)pPDW->lpPrintTemplateName,cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            pPDW->lpPrintTemplateName = (LPCWSTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Store the info in the PRINTINFOEX structure.
    //
    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlgEx(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;

    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExA2W(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;
    LPPRINTDLGEXA pPDA = pPI->pPDA;

    //
    //  Copy info A => W
    //
    pPDW->hDC            = pPDA->hDC;
    pPDW->Flags          = pPDA->Flags;
    pPDW->Flags2         = pPDA->Flags2;
    pPDW->nPageRanges    = pPDA->nPageRanges;
    pPDW->nMaxPageRanges = pPDA->nMaxPageRanges;
    pPDW->lpPageRanges   = pPDA->lpPageRanges;
    pPDW->nMinPage       = pPDA->nMinPage;
    pPDW->nMaxPage       = pPDA->nMaxPage;
    pPDW->nCopies        = pPDA->nCopies;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExW2A(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXA pPDA = pPI->pPDA;
    LPPRINTDLGEXW pPDW = pPI->pPD;

    //
    //  Copy info W => A
    //
    pPDA->hDC            = pPDW->hDC;
    pPDA->Flags          = pPDW->Flags;
    pPDA->Flags2         = pPDW->Flags2;
    pPDA->nPageRanges    = pPDW->nPageRanges;
    pPDA->nMaxPageRanges = pPDW->nMaxPageRanges;
    pPDA->lpPageRanges   = pPDW->lpPageRanges;
    pPDA->nMinPage       = pPDW->nMinPage;
    pPDA->nMaxPage       = pPDW->nMaxPage;
    pPDA->nCopies        = pPDW->nCopies;
    pPDA->dwResultAction = pPDW->dwResultAction;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesW2A(pPDW->hDevNames, &pPDA->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Check that realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode  = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied.
                pPDA->hDevMode = GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}
#endif   // UNICODE
#endif   // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\init.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    init.c

Abstract:

    This module contains the init routines for the Win32 common dialogs.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

//
//  External Declarations.
//

extern HDC hdcMemory;
extern HBITMAP hbmpOrigMemBmp;

extern CRITICAL_SECTION g_csLocal;
extern CRITICAL_SECTION g_csNetThread;

// TLS index to get current dlg info for the current thread
extern DWORD g_tlsiCurDlg;   

// TLS index to get most recent ExtError for the current thread
extern DWORD g_tlsiExtError; 

// TLS index to get LangID used for the current thread
extern DWORD g_tlsLangID;

extern HANDLE hMPR;
extern HANDLE hMPRUI;
extern HANDLE hLNDEvent;

extern DWORD dwNumDisks;
extern OFN_DISKINFO gaDiskInfo[MAX_DISKS];

extern DWORD cbNetEnumBuf;
extern LPTSTR gpcNetEnumBuf;

extern RECT g_rcDlg;

extern TCHAR g_szInitialCurDir[MAX_PATH];

//
//  Global Variables.
//

WCHAR szmsgLBCHANGEW[]          = LBSELCHSTRINGW;
WCHAR szmsgSHAREVIOLATIONW[]    = SHAREVISTRINGW;
WCHAR szmsgFILEOKW[]            = FILEOKSTRINGW;
WCHAR szmsgCOLOROKW[]           = COLOROKSTRINGW;
WCHAR szmsgSETRGBW[]            = SETRGBSTRINGW;
WCHAR szCommdlgHelpW[]          = HELPMSGSTRINGW;

TCHAR szShellIDList[]           = CFSTR_SHELLIDLIST;

BOOL g_bMirroredOS              = FALSE;
//
//  Private message for WOW to indicate 32-bit logfont
//  needs to be thunked back to 16-bit log font.
//
CHAR szmsgWOWLFCHANGE[]         = "WOWLFChange";

//
//  Private message for WOW to indicate 32-bit directory needs to be
//  thunked back to 16-bit task directory.
//
CHAR szmsgWOWDIRCHANGE[]        = "WOWDirChange";
CHAR szmsgWOWCHOOSEFONT_GETLOGFONT[]  = "WOWCHOOSEFONT_GETLOGFONT";

CHAR szmsgLBCHANGEA[]           = LBSELCHSTRINGA;
CHAR szmsgSHAREVIOLATIONA[]     = SHAREVISTRINGA;
CHAR szmsgFILEOKA[]             = FILEOKSTRINGA;
CHAR szmsgCOLOROKA[]            = COLOROKSTRINGA;
CHAR szmsgSETRGBA[]             = SETRGBSTRINGA;
CHAR szCommdlgHelpA[]           = HELPMSGSTRINGA;

UINT g_cfCIDA;





////////////////////////////////////////////////////////////////////////////
//
//  FInitColor
//
////////////////////////////////////////////////////////////////////////////

extern DWORD rgbClient;
extern HBITMAP hRainbowBitmap;

int FInitColor(
    HANDLE hInst)
{
    cyCaption = (short)GetSystemMetrics(SM_CYCAPTION);
    cyBorder = (short)GetSystemMetrics(SM_CYBORDER);
    cxBorder = (short)GetSystemMetrics(SM_CXBORDER);
    cyVScroll = (short)GetSystemMetrics(SM_CYVSCROLL);
    cxVScroll = (short)GetSystemMetrics(SM_CXVSCROLL);
    cxSize = (short)GetSystemMetrics(SM_CXSIZE);

    rgbClient = GetSysColor(COLOR_3DFACE);

    hRainbowBitmap = 0;

    return (TRUE);
    hInst;
}


////////////////////////////////////////////////////////////////////////////
//
//  FInitFile
//
////////////////////////////////////////////////////////////////////////////

BOOL FInitFile(
    HANDLE hins)
{
    bMouse = GetSystemMetrics(SM_MOUSEPRESENT);

    wWinVer = 0x0A0A;

    //
    //  Initialize these to reality.
    //
#if DPMICDROMCHECK
    wCDROMIndex = InitCDROMIndex((LPWORD)&wNumCDROMDrives);
#endif

    //
    // special WOW messages
    //
    msgWOWLFCHANGE       = RegisterWindowMessageA((LPSTR)szmsgWOWLFCHANGE);
    msgWOWDIRCHANGE      = RegisterWindowMessageA((LPSTR)szmsgWOWDIRCHANGE);
    msgWOWCHOOSEFONT_GETLOGFONT = RegisterWindowMessageA((LPSTR)szmsgWOWCHOOSEFONT_GETLOGFONT);

    msgLBCHANGEA         = RegisterWindowMessageA((LPSTR)szmsgLBCHANGEA);
    msgSHAREVIOLATIONA   = RegisterWindowMessageA((LPSTR)szmsgSHAREVIOLATIONA);
    msgFILEOKA           = RegisterWindowMessageA((LPSTR)szmsgFILEOKA);
    msgCOLOROKA          = RegisterWindowMessageA((LPSTR)szmsgCOLOROKA);
    msgSETRGBA           = RegisterWindowMessageA((LPSTR)szmsgSETRGBA);

#ifdef UNICODE
    msgLBCHANGEW         = RegisterWindowMessageW((LPWSTR)szmsgLBCHANGEW);
    msgSHAREVIOLATIONW   = RegisterWindowMessageW((LPWSTR)szmsgSHAREVIOLATIONW);
    msgFILEOKW           = RegisterWindowMessageW((LPWSTR)szmsgFILEOKW);
    msgCOLOROKW          = RegisterWindowMessageW((LPWSTR)szmsgCOLOROKW);
    msgSETRGBW           = RegisterWindowMessageW((LPWSTR)szmsgSETRGBW);
#else
    msgLBCHANGEW         = msgLBCHANGEA;
    msgSHAREVIOLATIONW   = msgSHAREVIOLATIONA;
    msgFILEOKW           = msgFILEOKA;
    msgCOLOROKW          = msgCOLOROKA;
    msgSETRGBW           = msgSETRGBA;
#endif

    g_cfCIDA             = RegisterClipboardFormat(szShellIDList);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  Initializes any instance specific data needed by functions in the
//  common dialogs.
//
//  Returns:   TRUE    - success
//             FALSE   - failure
//
////////////////////////////////////////////////////////////////////////////

// ccover needs to link to C-runtime, so we rename LibMain to DllMain
#ifdef CCOVER 
#define LibMain DllMain
#endif

BOOL LibMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            //
            //  Threads can only enter and leave the comdlg32 dll from the
            //  Get{Open,Save}FileName apis, so the TLS lpCurDlg alloc is
            //  done inside the InitFileDlg routine in fileopen.c
            //
            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hinst = (HANDLE)hModule;

            if (!FInitColor(g_hinst) || !FInitFile(g_hinst))
            {
                goto CantInit;
            }

            DisableThreadLibraryCalls(hModule);

            //
            //  msgHELP is sent whenever a help button is pressed in one of
            //  the common dialogs (provided an owner was declared and the
            //  call to RegisterWindowMessage doesn't fail).
            //
            msgHELPA = RegisterWindowMessageA((LPSTR)szCommdlgHelpA);
#ifdef UNICODE
            msgHELPW = RegisterWindowMessageW((LPWSTR)szCommdlgHelpW);
#else
            msgHELPW = msgHELPA;
#endif

            //
            //  Need a semaphore locally for managing array of disk info.
            //
            InitializeCriticalSection(&g_csLocal);

            //
            //  Need a semaphore for control access to CreateThread.
            //
            InitializeCriticalSection(&g_csNetThread);

            //
            //  Allocate a tls index for curdlg so we can make it per-thread.
            //
            if ((g_tlsiCurDlg = TlsAlloc()) != 0xFFFFFFFF)
            {
                // mark the list as empty
                TlsSetValue(g_tlsiCurDlg, (LPVOID) 0);
            }
            else
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Store the current directory on process attach.
            //
            GetCurrentDirectory(ARRAYSIZE(g_szInitialCurDir), g_szInitialCurDir);

            //
            //  Allocate a tls index for extended error.
            //
            if ((g_tlsiExtError = TlsAlloc()) == 0xFFFFFFFF)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Allocate a tls index for LangID so we can make it per-thread.
            //  it heavily used by CDLoadString.
            //
            if ((g_tlsLangID = TlsAlloc()) != 0xFFFFFFFF)
            {
                // mark the list as Neutral
                TlsSetValue(g_tlsLangID, (LPVOID) MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
            }
            else
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }



            dwNumDisks = 0;
            gpcNetEnumBuf = NULL;

            //
            //  NetEnumBuf allocated in ListNetDrivesHandler.
            //
            cbNetEnumBuf = WNETENUM_BUFFSIZE;

            hMPR = NULL;
            hMPRUI = NULL;

            hLNDEvent = NULL;

            //
            //  For file open dialog.
            //
            g_rcDlg.left = g_rcDlg.right = g_rcDlg.top = g_rcDlg.bottom = 0;

            g_bMirroredOS = IS_MIRRORING_ENABLED();
            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            //
            //  We only want to do our clean up work if we are being called
            //  with freelibrary, not if the process is ending.
            //
            if (lpRes == NULL)
            {
                TermFile();
                TermPrint();
                TermColor();
                TermFont();

                TlsFree(g_tlsiCurDlg);
                TlsFree(g_tlsiExtError);
                TlsFree(g_tlsLangID);

                DeleteCriticalSection(&g_csLocal);
                DeleteCriticalSection(&g_csNetThread);
            }

            return (TRUE);
            break;
        }
    }

CantInit:
    return (FALSE);
    lpRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\parse.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    parse.c

Abstract:

    This module contains the parse routines for the Win32 common dialogs.

Revision History:

--*/


// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "fileopen.h"

//
//  Global Variables.
//
extern TCHAR szCaption[];
extern TCHAR szWarning[];




////////////////////////////////////////////////////////////////////////////
//
//  ParseFileNew
//
//  On the return, pnExtOffset is the offset to the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileNew(
    LPTSTR pszPath,
    int *pnExtOffset,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    if (pnExtOffset)
    {
        int nExt;

        nExt = (int)(SHORT)HIWORD(lRet);
        *pnExtOffset = ((nExt) && *(pszPath + nExt)) ? nExt : 0;
    }

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFileOld
//
//  On return, pnExtOffset is the offset to the the dot and
//  pnOldExt is the offset to the character following the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileOld(
    LPTSTR pszPath,
    int *pnExtOffset,
    int *pnOldExt,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    int nExt = (int)(SHORT)HIWORD(lRet);
    *pnExtOffset = nExt;
    *pnOldExt = ((nExt) && *(pszPath + nExt)) ? nExt + 1 : 0;

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFile
//
//  Determines if the filename is a legal dos name.
//
//  Circumstances checked:
//      1) Valid as directory name, but not as file name
//      2) Empty String
//      3) Illegal Drive label
//      4) Period in invalid location (in extension, 1st in file name)
//      5) Missing directory character
//      6) Illegal character
//      7) Wildcard in directory name
//      8) Double slash beyond 1st 2 characters
//      9) Space character in the middle of the name (trailing spaces OK)
//         -->> no longer applies : spaces are allowed in LFN
//      10) Filename greater than 8 characters : NOT APPLICABLE TO LONG FILE NAMES
//      11) Extension greater than 3 characters: NOT APPLICABLE TO LONG FILE NAMES
//
//  lpstrFileName - ptr to a single file name
//
//  Returns:
//      LONG - LOWORD = char offset to filename,
//             HIWORD = char offset to extension (dot),
//      LONG - LOWORD is error code (<0), HIWORD is approx. place of problem
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseFile(
    LPTSTR lpstrFileName,
    BOOL bLFNFileSystem,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    SHORT nFile, nExt, nFileOffset, nExtOffset = 0;
    BOOL bExt;
    BOOL bWildcard;
    SHORT nNetwork = 0;
    BOOL bUNCPath = FALSE;
    LPTSTR lpstr = lpstrFileName;

    //Check if the string is empty
    if (!*lpstr)
    {
        nFileOffset = PARSE_EMPTYSTRING;
        goto ParseFile_Failure;
    }

    //Check if the string is of form  c:\foo1\foo2
    if (*(lpstr + 1) == CHAR_COLON)
    {
        //Yes. Get the drive letter
        TCHAR cDrive = CharLowerChar(*lpstr);

        //
        //  Test to see if the drive is legal.
        //
        //  Note: Does not test that drive exists.
        //
        if ((cDrive < CHAR_A) || (cDrive > CHAR_Z))
        {
            nFileOffset = PARSE_INVALIDDRIVE;
            goto ParseFile_Failure;
        }

        //Move string past drive letter and ':'
        lpstr = CharNext(CharNext(lpstr));
    }

    if ((*lpstr == CHAR_BSLASH) || (*lpstr == CHAR_SLASH && !bNewStyle))
    {
        //
        //  Cannot have "c:\."
        //
        if (*++lpstr == CHAR_DOT)
        {
            //
            //  Except that "c:\.\" is allowed.
            //
            if ((*++lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
            {
                //
                //  It's the root directory.
                //
                if (!*lpstr)
                {
                    goto MustBeDir;
                }
                else
                {
                    lpstr--;
                }
            }
            else
            {
                //
                //  It's saying top dir (once again), thus allowed.
                //
                ++lpstr;
            }
        }
        else if ((*lpstr == CHAR_BSLASH) && (*(lpstr - 1) == CHAR_BSLASH))
        {
            //
            //  It seems that for a full network path, whether a drive is
            //  declared or not is insignificant, though if a drive is given,
            //  it must be valid (hence the code above should remain there).
            //

            //
            //  ...since it's the first slash, 2 are allowed.
            //
            ++lpstr;

            //
            //  Must receive server and share to be real.
            //
            nNetwork = -1;

            //
            //  No wildcards allowed if UNC name.
            //
            bUNCPath = TRUE;
        }
        else if (*lpstr == CHAR_SLASH && !bNewStyle)
        {
            nFileOffset = PARSE_INVALIDDIRCHAR;
            goto ParseFile_Failure;
        }
    }
    else if (*lpstr == CHAR_DOT)
    {
        //
        //  Up one directory.
        //
        if (*++lpstr == CHAR_DOT)
        {
            ++lpstr;
        }

        if (!*lpstr)
        {
            goto MustBeDir;
        }
        if ((*lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
        {
            //
            //  Jumping to Failure here will skip the parsing that causes
            //  ".xxx.txt" to return with nFileOffset = 2.
            //
            nFileOffset = 0;
            goto ParseFile_Failure;
        }
        else
        {
            //
            //  Allow directory.
            //
            ++lpstr;
        }
    }

    if (!*lpstr)
    {
        goto MustBeDir;
    }

    //
    //  Should point to first char in filename by now.
    //
    nFileOffset = nExtOffset = nFile = nExt = 0;
    bWildcard = bExt = FALSE;
    while (*lpstr)
    {
        //
        //  Anything below the "Space" character is invalid.
        //
#ifdef UNICODE
        if (*lpstr < CHAR_SPACE)
#else
        if (((UCHAR)*lpstr) < CHAR_SPACE)
#endif
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto ParseFile_Failure;
        }
        switch (*lpstr)
        {
            case ( CHAR_COLON ) :
            case ( CHAR_BAR ) :
            case ( CHAR_LTHAN ) :
            case ( CHAR_QUOTE ) :
            {
                //
                //  Invalid characters for all file systems.
                //
                nFileOffset = PARSE_INVALIDCHAR;
                goto ParseFile_Failure;
            }
            case ( CHAR_SEMICOLON ) :
            case ( CHAR_COMMA ) :
            case ( CHAR_PLUS ) :
            case ( CHAR_LBRACKET ) :
            case ( CHAR_RBRACKET ) :
            case ( CHAR_EQUAL ) :
            {
                if (!bLFNFileSystem)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    goto RegularCharacter;
                }
            }
            case ( CHAR_SLASH ) :
            {
                if (bNewStyle)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }

                // fall thru...
            }
            case ( CHAR_BSLASH ) :
            {
                //
                //  Subdir indicators.
                //
                nNetwork++;
                if (bWildcard)
                {
                    nFileOffset = PARSE_WILDCARDINDIR;
                    goto ParseFile_Failure;
                }

                //
                // if nFile==0 means that we are seeing this backslash right next to a backslash  
                // which is not allowed.
                if (nFile == 0)
                {
                    nFileOffset = PARSE_INVALIDDIRCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    //Move over the BSLASH/SLASH character.
                    ++lpstr;

                    //Check if the path is valid network path name
                    if (!nNetwork && !*lpstr)
                    {
                        nFileOffset = PARSE_INVALIDNETPATH;
                        goto ParseFile_Failure;
                    }

                    
                    //We assume that the  characters we are seeing are filename characters. This BSLASH/SLASH
                    //character tells that characters we have seen so far specifies the name of a directory in the
                    //path. Reset flags so that we can start looking for filename again.
                    nFile = nExt = 0;
                    nExtOffset = 0;
                    bExt = FALSE;
                }
                break;
            }
            case ( CHAR_SPACE ) :
            {
                LPTSTR lpSpace = lpstr;

                if (bLFNFileSystem)
                {
                    // In Long file name file system space characters  are O.K
                    goto RegularCharacter;
                }



                //We are not interested in the trailing spaces so null terminate it.
                *lpSpace = CHAR_NULL;


                // In non long file name file systems, space characters are OK at the end of file
                // name. Check to see if all the characters that follows are spaces. if thats the case
                // then its valid. if we have any non space character after the first space then its a 
                // invalid file name.
                
                while (*++lpSpace)
                {
                    if (*lpSpace != CHAR_SPACE)
                    {
                        *lpstr = CHAR_SPACE;
                        nFileOffset = PARSE_INVALIDSPACE;
                        goto ParseFile_Failure;
                    }
                }

                break;
            }
            
            case ( CHAR_DOT ) :
            {

                // In newstyle nExtOffset points to the dot and not to the first character of extension.
                if (bNewStyle)
                {
                    nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    goto RegularCharacter;
                }
                
                if (nFile == 0)
                {
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                    if (*++lpstr == CHAR_DOT)
                    {
                        ++lpstr;
                    }
                    if (!*lpstr)
                    {
                        goto MustBeDir;
                    }

                    //
                    //  Flags already set.
                    //
                    nFile++;
                    ++lpstr;
                }
                else
                {
                    nExtOffset = 0;
                    ++lpstr;
                    bExt = TRUE;
                }
                break;
            }
            case ( CHAR_STAR ) :
            case ( CHAR_QMARK ) :
            {
                bWildcard = TRUE;

                //  Fall thru...
            }
            default :
            {
RegularCharacter:

                //Are we in extension part ?
                if (bExt)
                {
                    //Is this first character in extension part
                    if (++nExt == 1)
                    {
                        //Yes, then get the Extension offset
                        nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    }
                }

                //We are still in file name part. 
                //Is this the first character in filename part ?
                else if (++nFile == 1)
                {
                    //Yes. Get the filename offset
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                }

                //Move to the next character
                lpstr = CharNext(lpstr);
                break;
            }
        }
    }

    if (nNetwork == -1)
    {
        nFileOffset = PARSE_INVALIDNETPATH;
        goto ParseFile_Failure;
    }
    else if (bUNCPath)
    {
        if (!nNetwork)
        {
            //
            //  Server and share only.(e.g \\server\foo)
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
        else if ((nNetwork == 1) && !nFile)
        {
            //
            //  Server and share root.(e.g \\server\foo\)
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
    }

    if (!nFile)
    {
MustBeDir:
        nFileOffset = PARSE_DIRECTORYNAME;
        goto ParseFile_Failure;
    }

    //
    //  If bNewStyle is true, no ext. wanted.
    //
    if (!bNewStyle)
    {
        if ((bWowApp) &&
            (*(lpstr - 1) == CHAR_DOT) &&
            (*CharNext(lpstr - 2) == CHAR_DOT))
        {
            //
            //  Remove terminating period.
            //
            *(lpstr - 1) = CHAR_NULL;
        }
        else if (!nExt)
        {
ParseFile_Failure:
            //
            //  Need to recheck bNewStyle since we can jump here.
            //
            if (!bNewStyle)
            {
                nExtOffset = (SHORT)(lpstr - lpstrFileName);
            }
        }
    }

    return (MAKELONG(nFileOffset, nExtOffset));
}


////////////////////////////////////////////////////////////////////////////
//
//  PathRemoveBslash
//
//  Removes a trailing backslash from the given path.
//
//  Returns:
//      Pointer to NULL that replaced the backslash   OR
//      Pointer to the last character if it isn't a backslash
//
////////////////////////////////////////////////////////////////////////////

LPTSTR PathRemoveBslash(
    LPTSTR lpszPath)
{
    int len = lstrlen(lpszPath) - 1;

#ifndef UNICODE
    if (IsDBCSLeadByte(*CharPrev(lpszPath, lpszPath + len + 1)))
    {
        len--;
    }
#endif

    if (!PathIsRoot(lpszPath) && (lpszPath[len] == CHAR_BSLASH))
    {
        lpszPath[len] = CHAR_NULL;
    }

    return (lpszPath + len);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsWild
//
////////////////////////////////////////////////////////////////////////////

BOOL IsWild(
    LPCTSTR lpsz)
{
    return (StrChr(lpsz, CHAR_STAR) || StrChr(lpsz, CHAR_QMARK));
}


////////////////////////////////////////////////////////////////////////////
//
//  AppendExt
//
//  Appends default extension onto path name.
//  It assumes the current path name doesn't already have an extension.
//  lpExtension does not need to be null terminated.
//
////////////////////////////////////////////////////////////////////////////

VOID AppendExt(
    LPTSTR lpszPath,
    LPCTSTR lpExtension,
    BOOL bWildcard)
{
    WORD wOffset;
    SHORT i;
    TCHAR szExt[MAX_PATH + 1];

    if (lpExtension && *lpExtension)
    {
        wOffset = (WORD)lstrlen(lpszPath);
        if (bWildcard)
        {
            *(lpszPath + wOffset++) = CHAR_STAR;
        }

        //
        //  Add a period.
        //
        *(lpszPath + wOffset++) = CHAR_DOT;
        for (i = 0; *(lpExtension + i) && i < MAX_PATH; i++)
        {
            szExt[i] = *(lpExtension + i);
        }
        szExt[i] = 0;

        //
        //  Remove leading / trailing blanks in the extension.
        //
        PathRemoveBlanks(szExt);

        //
        //  Add the rest.
        //
        lstrcpy(lpszPath + wOffset, szExt);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsUNC
//
//  Determines if the given path is a UNC path.
//
//  Returns:
//      TRUE    if path starts with "\\" or "X:\\"
//      FALSE   otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL IsUNC(
    LPCTSTR lpszPath)
{
    return ( DBL_BSLASH(lpszPath) ||
             ((lpszPath[1] == CHAR_COLON) && DBL_BSLASH(lpszPath + 2)) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PortName
//
////////////////////////////////////////////////////////////////////////////

#define PORTARRAY 14

BOOL PortName(
    LPTSTR lpszFileName)
{
    static TCHAR *szPorts[PORTARRAY] = { TEXT("LPT1"),
                                         TEXT("LPT2"),
                                         TEXT("LPT3"),
                                         TEXT("LPT4"),
                                         TEXT("COM1"),
                                         TEXT("COM2"),
                                         TEXT("COM3"),
                                         TEXT("COM4"),
                                         TEXT("EPT"),
                                         TEXT("NUL"),
                                         TEXT("PRN"),
                                         TEXT("CLOCK$"),
                                         TEXT("CON"),
                                         TEXT("AUX"),
                                       };
    short i;
    TCHAR cSave, cSave2;


    cSave = *(lpszFileName + 4);
    if (cSave == CHAR_DOT)
    {
        *(lpszFileName + 4) = CHAR_NULL;
    }

    //
    //  For "EPT".
    //
    cSave2 = *(lpszFileName + 3);
    if (cSave2 == CHAR_DOT)
    {
      *(lpszFileName + 3) = CHAR_NULL;
    }

    for (i = 0; i < PORTARRAY; i++)
    {
        if (!lstrcmpi(szPorts[i], lpszFileName))
        {
            break;
        }
    }
    *(lpszFileName + 4) = cSave;
    *(lpszFileName + 3) = cSave2;

    return (i != PORTARRAY);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDirectory
//
////////////////////////////////////////////////////////////////////////////

BOOL IsDirectory(
    LPTSTR pszPath)
{
    DWORD dwAttributes;

    //
    //  Clean up for GetFileAttributes.
    //
    PathRemoveBslash(pszPath);

    dwAttributes = GetFileAttributes(pszPath);
    return ( (dwAttributes != (DWORD)(-1)) &&
             (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) );
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteProtectedDirCheck
//
//  This function takes a full filename, strips the path, and creates
//  a temp file in that directory.  If it can't, the directory is probably
//  write protected.
//
//  Returns:
//      error code if writeprotected
//      0 if successful creation of file.
//
//  Assumptions:
//    Full Path name on input with space for full filename appended.
//
//  Note: Do NOT use this on a floppy, it's too slow!
//
////////////////////////////////////////////////////////////////////////////

int WriteProtectedDirCheck(
    LPCTSTR lpszFile)
{
    SHORT nFileOffset;
    TCHAR szFile[MAX_PATH + 1];
    TCHAR szBuf[MAX_PATH + 1];

    lstrcpyn(szFile, lpszFile, MAX_PATH + 1);
    nFileOffset = (SHORT)(int)LOWORD(ParseFile(szFile, TRUE, FALSE, TRUE));

    szFile[nFileOffset - 1] = CHAR_NULL;
    if (!GetTempFileName(szFile, TEXT("TMP"), 0, szBuf))
    {
        return (GetLastError());
    }
    else
    {
        DeleteFile(szBuf);
        return (0);               // success
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FOkToWriteOver
//
//  Verifies that the user really does want to destroy the file,
//  replacing its contents with new stuff.
//
////////////////////////////////////////////////////////////////////////////

BOOL FOkToWriteOver(
    HWND hDlg,
    LPTSTR szFileName)
{
    if (!CDLoadString( g_hinst,
                     iszOverwriteQuestion,
                     szCaption,
                     WARNINGMSGLENGTH - 1 ))
    {
        return (FALSE);
    }

    //
    //  Since we're passed in a valid filename, if the 3rd & 4th characters
    //  are both slashes, weve got a dummy drive as the 1st two characters.
    //
    if (DBL_BSLASH(szFileName + 2))
    {
        szFileName = szFileName + 2;
    }

    wsprintf(szWarning, szCaption, szFileName);

    GetWindowText(hDlg, szCaption, cbCaption);
    return (MessageBox( hDlg,
                        szWarning,
                        szCaption,
                        MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ) == IDYES);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFileDlg
//
////////////////////////////////////////////////////////////////////////////

int CreateFileDlg(
    HWND hDlg,
    LPTSTR szPath)
{
    //
    //  Since we're passed in a valid filename, if the 3rd & 4th
    //  characters are both slashes, we've got a dummy drive as the
    //  1st two characters.
    //
    if (DBL_BSLASH(szPath + 2))
    {
        szPath = szPath + 2;
    }

    if (!CDLoadString(g_hinst, iszCreatePrompt, szCaption, TOOLONGLIMIT))
    {
        return (IDNO);
    }
    if (lstrlen(szPath) > TOOLONGLIMIT)
    {
        *(szPath + TOOLONGLIMIT) = CHAR_NULL;
    }

    wsprintf(szWarning, szCaption, szPath);

    GetWindowText(hDlg, szCaption, TOOLONGLIMIT);

    return (MessageBox( hDlg,
                        szWarning,
                        szCaption,
                        MB_YESNO | MB_ICONQUESTION ));
}


#ifndef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  EliminateString
//
//  Chops the string by the specified length.  If a DBCS lead byte is
//  left as the last char, then it is removed as well.
//
//  NOTE: For non-Unicode strings only.
//
////////////////////////////////////////////////////////////////////////////

VOID EliminateString(
    LPSTR lpStr,
    int nLen)
{
    LPSTR lpChar;
    BOOL bFix = FALSE;

    *(lpStr + nLen) = CHAR_NULL;
    for (lpChar = lpStr + nLen - 1; lpChar >= lpStr; lpChar--)
    {
        if (!IsDBCSLeadByte(*lpChar))
        {
            break;
        }
        bFix = !bFix;
    }
    if (bFix)
    {
        *(lpStr + nLen - 1) = CHAR_NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsBackSlash
//
//  Decides whether a character is a '\' or a DBCS trail byte with the same
//  code point value.
//
//  NOTE: For non-Unicode strings only.
//
////////////////////////////////////////////////////////////////////////////

BOOL IsBackSlash(
    LPSTR lpStart,
    LPSTR lpChar)
{
    if (*lpChar == CHAR_BSLASH)
    {
        BOOL bRet = TRUE;

        while (--lpChar >= lpStart)
        {
            if (!IsDBCSLeadByte(*lpChar))
            {
                break;
            }
            bRet = !bRet;
        }
        return (bRet);
    }
    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\prnsetup.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.c

Abstract:

    This module implements the Win32 print dialogs.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "prnsetup.h"
#include "util.h"

//
//  The PrintDlgEx routines.
//
extern VOID Print_UnloadLibraries();
extern BOOL Print_NewPrintDlg(PPRINTINFO pPI);





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgA
//
//  ANSI entry point for PrintDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlgA(
    LPPRINTDLGA pPDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    DWORD Flags;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    if (bResult = ThunkPrintDlg(&PI, pPDA))
    {
        ThunkPrintDlgA2W(&PI);

        Flags = pPDA->Flags;

        bResult = PrintDlgX(&PI);

        if ((bResult) || (Flags & (PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK)))
        {
            ThunkPrintDlgW2A(&PI);
        }
    }
    FreeThunkPrintDlg(&PI);

    return (bResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgW
//
//  Stub UNICODE function for PrintDlg when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlgW(
    LPPRINTDLGW pPDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlg
//
//  The PrintDlg function displays a Print dialog box or a Print Setup
//  dialog box.  The Print dialog box enables the user to specify the
//  properties of a particular print job.  The Print Setup dialog box
//  allows the user to select additional job properties and to configure
//  the printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlg(
    LPPRINTDLG pPD)
{
    PRINTINFO PI;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgX(&PI) );
}

////////////////////////////////////////////////////////////////////////////
//
//  ShowErrorMessage
//
//  Shows an error message
//
////////////////////////////////////////////////////////////////////////////

static HRESULT ShowErrorMessage(
    IN  const PRINTDLG *pPD,
    IN  const PRINTINFO *pPI,
    OUT BOOL *pbTryAgain        OPTIONAL
    )
{
    HRESULT hr = S_OK;
    BOOL bTryAgain = FALSE;
    BOOL bPrinterAdded = FALSE;

    if (!(pPD->Flags & PD_NOWARNING))
    {
        DWORD dwErr = GetStoredExtendedError();

        //
        //  Only do this for new apps.
        //
        if ( (pPI->ProcessVersion >= 0x40000) ||
             (dwErr == PDERR_NODEFAULTPRN) ||
             (dwErr == PDERR_PRINTERNOTFOUND) )
        {
            TCHAR szWarning[SCRATCHBUF_SIZE];
            TCHAR szTitle[SCRATCHBUF_SIZE];
            int iszWarning;

            szTitle[0] = TEXT('\0');
            if (pPD->hwndOwner)
            {
                GetWindowText(pPD->hwndOwner, szTitle, SCRATCHBUF_SIZE);
            }
            if (!szTitle[0])
            {
                CDLoadString(g_hinst, iszWarningTitle, szTitle, SCRATCHBUF_SIZE);
            }

            switch (dwErr)
            {
                case ( PDERR_NODEFAULTPRN ) :
                {
                    //
                    //  Notes: if the app is a 16-bit app, we don't ask the user whether to install a
                    //  new printer. This is because some components may break if we do it.
                    //

                    if (IS16BITWOWAPP(pPD))
                    {
                        iszWarning = iszNoPrnsInstalled;
                    }
                    else
                    {
                        iszWarning = iszNoPrinters;
                    }
                    break;
                }
                case ( PDERR_PRINTERNOTFOUND ) :
                {
                    iszWarning = iszPrnNotFound;
                    break;
                }
                case ( CDERR_MEMLOCKFAILURE ) :
                case ( CDERR_MEMALLOCFAILURE ) :
                case ( PDERR_LOADDRVFAILURE ) :
                {
                    iszWarning = iszMemoryError;
                    break;
                }
                default :
                {
                    iszWarning = iszGeneralWarning;
                    break;
                }
            }

            if (iszWarning == iszNoPrnsInstalled)
            {
                FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    ERROR_PRINTER_NOT_FOUND,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR)szWarning,
                    sizeof(szWarning),
                    NULL);
            }
            else
            {
                CDLoadString(g_hinst, iszWarning, szWarning, SCRATCHBUF_SIZE);
            }

            MessageBeep(MB_ICONEXCLAMATION);

            if (iszWarning == iszNoPrinters)
            {
                //
                // If the problem is that there are no printers installed then ask the
                // user if he wants to add one, and then launch the add printer wizard.
                //
                if (IDYES == MessageBox( pPD->hwndOwner,
                                         szWarning,
                                         szTitle,
                                         MB_ICONQUESTION | MB_YESNO))
                {
                    hr = InvokeAddPrinterWizardModal(pPD->hwndOwner, &bPrinterAdded);

                    if (SUCCEEDED(hr) && bPrinterAdded)
                    {
                        //
                        // A printer was added successfully. Tell the caller to try again.
                        //
                        bTryAgain = TRUE;
                    }
                }
            }
            else
            {
                //
                // This is a fatal error. Just show an error message and bail.
                //
                MessageBox( pPD->hwndOwner,
                            szWarning,
                            szTitle,
                            MB_ICONEXCLAMATION | MB_OK );
            }
        }
    }

    if (pbTryAgain)
    {
        *pbTryAgain = bTryAgain;
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgX
//
//  Worker routine for the PrintDlg api.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintDlgX(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    BOOL nResult = -1;                      // <0==error, 0==CANCEL, >0==OK
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDevMode = NULL;
    LPDEVNAMES pDN = NULL;
    DWORD dwFlags;                          // old copy
    WORD nCopies, nFromPage, nToPage;       // old copy
    HGLOBAL hDevNames, hDevMode;            // old copy
    TCHAR szPrinterName[MAX_PRINTERNAME];   // old copy
    LONG cbNeeded;
#ifndef WINNT
    LPCTSTR pDN_Device = NULL;
    TCHAR szDev[2];
#endif
    DWORD dwResult = 0;
    BOOL bTryAgain = TRUE;


    if (!pPD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPD->lStructSize != sizeof(PRINTDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pPD->hwndOwner && !IsWindow(pPD->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

#ifdef WINNT
    //
    //  See if the application should get the new look.
    //
    //  Do not allow the new look if they have hooks, templates,
    //  Invalid hwndOwner,
    //  they want the setup dialog, or they just want to get the default
    //  printer.
    //
    //  Also don't allow the new look if we are in the context of
    //  a 16 bit process.
    //
    if ( (!(pPI->Status & PI_PRINTDLGX_RECURSE)) &&
         (!pPI->pPSD) &&
         ((!(pPD->Flags & (PD_PAGESETUP |
                           PD_PRINTSETUP |
                           PD_RETURNDEFAULT |
                           PD_ENABLEPRINTHOOK |
                           PD_ENABLESETUPHOOK |
                           PD_ENABLEPRINTTEMPLATE |
                           PD_ENABLESETUPTEMPLATE |
                           PD_ENABLEPRINTTEMPLATEHANDLE |
                           PD_ENABLESETUPTEMPLATEHANDLE)))) &&
         (pPD->hwndOwner && IsWindow(pPD->hwndOwner)) &&
         (!IS16BITWOWAPP(pPD)) )
    {
        //
        //  Show the new dialog.
        //
        StoreExtendedError(0);

        return Print_NewPrintDlg(pPI);
    }
#endif

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) GetDialogLanguage(pPD->hwndOwner, NULL));

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

#ifdef UNICODE
    //
    //  Check if we need to use ExtDeviceMode.  We use this
    //  mode only if a 16 bit app is calling us with a NULL
    //  devmode.
    //
    if ((pPD->Flags & CD_WOWAPP) && !pPD->hDevMode)
    {
        pPI->bUseExtDeviceMode = TRUE;
    }
    else
    {
        pPI->bUseExtDeviceMode = FALSE;
    }
#endif

#ifndef WINNT
    //
    //  This should NOT be in NT.  The device name cannot be longer than
    //  32 characters, so it may be truncated.  If we look for it in the
    //  registry and it's supposed to be larger than 32 characters, then
    //  we won't find it and we'll fail.
    //
    //  LATER: It probably shouldn't be in WIN95 either, but I'll leave
    //         it for now.
    //
    if (pPD->hDevMode)
    {
        if (!(pDM = GlobalLock(pPD->hDevMode)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pPD->hDevNames)
    {
        if (!(pDN = GlobalLock(pPD->hDevNames)))
        {
            if (pDM)
            {
                GlobalUnlock(pPD->hDevMode);
            }
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            goto PrintDlgX_DisplayWarning;
        }
        else
        {
            if (pDN->wDeviceOffset)
            {
                pDN_Device = (LPCTSTR)pDN + pDN->wDeviceOffset;
            }
        }
    }

    if (pDM && pDM->dmDeviceName[0])
    {
        pDM->dmDeviceName[CCHDEVICENAME - 1] = 0;
        GetProfileString(szTextDevices, pDM->dmDeviceName, szTextNull, szDev, 2);
        if (!szDev[0])
        {
            GlobalUnlock(pPD->hDevMode);
            if (pDN)
            {
                GlobalUnlock(pPD->hDevNames);
            }
            StoreExtendedError(PDERR_PRINTERNOTFOUND);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pDN_Device && pDN_Device[0])
    {
        GetProfileString(szTextDevices, pDN_Device, szTextNull, szDev, 2);
        if (!szDev[0])
        {
            if (pDM)
            {
                GlobalUnlock(pPD->hDevMode);
            }
            GlobalUnlock(pPD->hDevNames);
            StoreExtendedError(PDERR_PRINTERNOTFOUND);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pDM)
    {
        GlobalUnlock(pPD->hDevMode);
    }
    if (pDN)
    {
        GlobalUnlock(pPD->hDevNames);
    }
#endif

    pPD->hDC = 0;

    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        //
        //  Do not display a warning in this case if it fails.
        //  MFC 3.1 does not specify PD_NOWARNING, but that's what
        //  it really wants.
        //
        nResult = PrintReturnDefault(pPI);
        PrintClosePrinters(pPI);
        return (nResult);
    }

    if (!PrintLoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        StoreExtendedError(PDERR_SETUPFAILURE);
        goto PrintDlgX_DisplayWarning;
    }

    //
    //  Printer enumeration is delayed until the combobox is dropped down.
    //  However, if a printer is specified, we must force enumeration in
    //  order to find the printer so that the correct devmode can be created.
    //
    if ((pPD->hDevMode) &&
        (pPD->hDevNames) &&
        (pDM = GlobalLock(pPD->hDevMode)))
    {
        if (pDN = GlobalLock(pPD->hDevNames))
        {
            dwResult = lstrcmp((LPTSTR)pDM->dmDeviceName,
                               (LPTSTR)pDN + pDN->wDeviceOffset);
            GlobalUnlock(pPD->hDevNames);
        }
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  First : Try to open the printer in the DevMode.
    //
    //  Note: The printer name field in the DEVMODE struct is limited to
    //        32 chars which may cause this case to fail.
    //
    if ( (!dwResult) &&
         (!pPI->hCurPrinter) &&
         (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
        PrintOpenPrinter(pPI, pDM->dmDeviceName);
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  Second : Try to open the printer in the DevNames.
    //
    if ( (!pPI->hCurPrinter) &&
         (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintOpenPrinter(pPI, (LPTSTR)pDN + pDN->wDeviceOffset);
        GlobalUnlock(pPD->hDevNames);
    }

    for (;;)
    {
        //
        //  Third : Try to open the Default Printer.
        //
        PrintGetDefaultPrinterName(pPI->szDefaultPrinter, MAX_PRINTERNAME);
        if (!pPI->hCurPrinter)
        {
            if (pPI->szDefaultPrinter[0])
            {
                PrintOpenPrinter(pPI, pPI->szDefaultPrinter);
            }
        }

        //
        //  Fourth : Enumerate the Printers and try to open one of those.
        //
        if (!pPI->hCurPrinter)
        {
            if (!PrintEnumAndSelect(pPD->hwndOwner, 0, pPI, NULL, TRUE))
            {
                //
                //  There are no printers installed in the system.
                //
                if (SUCCEEDED(ShowErrorMessage(pPD, pPI, &bTryAgain)) && bTryAgain)
                {
                    //
                    // The user has installed a printer. Let's try again now.
                    //
                    continue;
                }
            }
        }

        break;
    }

    if (!bTryAgain && IS16BITWOWAPP(pPD))
    {
        //
        //  If it's a 16-bit app, we'll return immediately without showing
        //  warning message. This is because some 16-bit app will crash in
        //  the common print dialog.
        //
        return (FALSE);
    }

    //
    //  Save the original information passed in by the app in case the user
    //  hits cancel.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    nFromPage = pPD->nFromPage;
    nToPage = pPD->nToPage;
    hDevNames = pPD->hDevNames;
    hDevMode = pPD->hDevMode;
    if ((pPI->pCurPrinter) &&
        (lstrlen(pPI->pCurPrinter->pPrinterName) < MAX_PRINTERNAME))
    {
        lstrcpy(szPrinterName, pPI->pCurPrinter->pPrinterName);
    }
    else
    {
        szPrinterName[0] = 0;
    }

    pPD->hDevNames = NULL;
    pPD->hDevMode = NULL;

    //
    //  Build a copy of the DevNames.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the *correct* DevMode.
    //
    if (hDevMode)
    {
        pDevMode = GlobalLock(hDevMode);
    }

#ifdef UNICODE
    else
    {
        //
        //  If it's WOW and the app didn't specify a devmode, get the 16-bit
        //  devmode out of the registry (ie. win.ini [Windows] device section).
        //
        if (pPI->bUseExtDeviceMode && pPI->pCurPrinter)
        {
            pDevMode = (pPI->pCurPrinter)->pDevMode;
            if (pDevMode)
            {
                cbNeeded = sizeof(DEVMODEW) + pDevMode->dmDriverExtra;
                goto GotWOWDMSize;
            }

            //
            //  If a 16-bit devmode isn't available in the registry,
            //  drop through and get the system default devmode.
            //
        }
    }
#endif

    cbNeeded = DocumentProperties( pPD->hwndOwner,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );
#ifdef UNICODE
GotWOWDMSize:
#endif
    if ((cbNeeded > 0) &&
        (pPD->hDevMode = GlobalAlloc(GHND, cbNeeded)))
    {
        BOOL fSuccess = FALSE;

        if (pDM = GlobalLock(pPD->hDevMode))
        {
#ifdef UNICODE
            if (pPI->bUseExtDeviceMode && !hDevMode)
            {
                CopyMemory(pDM, pDevMode, cbNeeded);
                fSuccess = TRUE;
                goto GotNewWOWDM;
            }
#endif
            fSuccess = DocumentProperties( pPD->hwndOwner,
                                           pPI->hCurPrinter,
                                           (pPI->pCurPrinter)
                                               ? pPI->pCurPrinter->pPrinterName
                                               : NULL,
                                           pDM,            // out
                                           pDevMode,       // in
                                           DM_MODIFY | DM_COPY ) == IDOK;
#ifdef UNICODE
GotNewWOWDM:
#endif
            if (pDM->dmFields & DM_COPIES)
            {
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES))
                {
                    pPD->nCopies = pDM->dmCopies;
                }
                else if (pPD->nCopies)
                {
                    pDM->dmCopies = pPD->nCopies;
                }
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                //
                // if PD_COLLATE is not set, we also use the setting in
                // the returned DEVMODE structure
                //
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES) || !(pPD->Flags & PD_COLLATE))
                {
                    if (pDM->dmCollate == DMCOLLATE_FALSE)
                    {
                        pPD->Flags  &= ~PD_COLLATE;
                        pPI->Status &= ~PI_COLLATE_REQUESTED;
                    }
                    else
                    {
                        pPD->Flags  |= PD_COLLATE;
                        pPI->Status |= PI_COLLATE_REQUESTED;
                    }
                }
                else // in this case (pPD->Flags & PD_COLLATE) must be TRUE
                {
                    pDM->dmCollate = DMCOLLATE_TRUE;
                }
            }

            GlobalUnlock(pPD->hDevMode);
        }

        if (!fSuccess)
        {
            GlobalFree(pPD->hDevMode);
            pPD->hDevMode = NULL;
        }
    }

    if (hDevMode)
    {
        GlobalUnlock(hDevMode);
    }

    //
    //  Get the default source string.
    //
    CDLoadString(g_hinst, iszDefaultSource, szDefaultSrc, SCRATCHBUF_SIZE);

    //
    //  Call the appropriate dialog routine.
    //
    switch (pPD->Flags & (PD_PRINTSETUP | PD_PAGESETUP))
    {
        case ( 0 ) :
        {
            nResult = PrintDisplayPrintDlg(pPI);
            break;
        }
        case ( PD_PRINTSETUP ) :
        case ( PD_PAGESETUP ) :
        {
            nResult = PrintDisplaySetupDlg(pPI);
            break;
        }
        default :
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            break;
        }
    }

    if (nResult > 0)
    {
        //
        //  User hit OK, so free the copies of the handles passed in
        //  by the app.
        //
        if (hDevMode && (hDevMode != pPD->hDevMode))
        {
            GlobalFree(hDevMode);
            hDevMode = NULL;
        }
        if (hDevNames && (hDevNames != pPD->hDevNames))
        {
            GlobalFree(hDevNames);
            hDevNames = NULL;
        }

        if (pPD->hDevMode)
        {
            //
            //  Make sure the device name in the devmode is null
            //  terminated.
            //
            pDevMode = GlobalLock(pPD->hDevMode);
            pDevMode->dmDeviceName[CCHDEVICENAME - 1] = 0;
            GlobalUnlock(pPD->hDevMode);
        }
    }
    else
    {
        //
        //  User hit CANCEL or there was an error, so restore original
        //  values passed in by the app.
        //
        pPD->Flags = dwFlags;
        pPD->nCopies = nCopies;
        pPD->nFromPage = nFromPage;
        pPD->nToPage = nToPage;
        if (pPD->hDevMode && (pPD->hDevMode != hDevMode))
        {
            GlobalFree(pPD->hDevMode);
        }
        if (pPD->hDevNames && (pPD->hDevNames != hDevNames))
        {
            GlobalFree(pPD->hDevNames);
        }
        pPD->hDevNames = hDevNames;
        pPD->hDevMode = hDevMode;

        //
        //  If we've been called from Page Setup, then we need to reset
        //  the current printer.
        //
        if (pPI->Status & PI_PRINTDLGX_RECURSE)
        {
            PrintCancelPrinterChanged(pPI, szPrinterName);
        }
    }

    //
    //  Make sure that we are really supposed to be leaving this function
    //  before we start closing printers and displaying error messages.
    //
    if (pPI->Status & PI_PRINTDLGX_RECURSE)
    {
        return (nResult > 0);
    }

    //
    //  Close the printers that were opened.
    //
    PrintClosePrinters(pPI);

    //
    //  Display any error messages.
    //
PrintDlgX_DisplayWarning:

    if (nResult < 0)
    {
        //
        // Display an error message and ignore the return code
        // since we don't care.
        //
        ShowErrorMessage(pPD, pPI, NULL);
    }

    return (nResult > 0);
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgA
//
//  ANSI entry point for PageSetupDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlgA(
    LPPAGESETUPDLGA pPSDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    HANDLE hDevMode;
    HANDLE hDevNames;
    LPCSTR pTemplateName;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    //
    //  Get the pPDA structure from the pPSDA structure.
    //
    if (bResult = ThunkPageSetupDlg(&PI, pPSDA))
    {
        //
        //  Save the original devmode and devnames.
        //
        hDevMode = pPSDA->hDevMode;
        hDevNames = pPSDA->hDevNames;
        pTemplateName = pPSDA->lpPageSetupTemplateName;

        //
        //  Convert the pPDA structure to Unicode (pPI->pPD).
        //
        if (bResult = ThunkPrintDlg(&PI, PI.pPDA))
        {
            //
            //  Fill in the pPI->pPD structure.
            //
            ThunkPrintDlgA2W(&PI);

            //
            //  Copy the Unicode information from the pPD structure to
            //  the pPSD structure for the call to PageSetupDlgX.
            //
            (PI.pPSD)->hDevMode  = (PI.pPD)->hDevMode;
            (PI.pPSD)->hDevNames = (PI.pPD)->hDevNames;

            (PI.pPSD)->lpPageSetupTemplateName = (PI.pPD)->lpSetupTemplateName;

            //
            //  Call the PageSetupDlgX function to do the work.
            //
            if (bResult = PageSetupDlgX(&PI))
            {
                //
                //  Success.  Convert the Unicode pPD structure to
                //  its ANSI equivalent.
                //
                ThunkPrintDlgW2A(&PI);

                //
                //  Save the ANSI devmode and devnames in the
                //  pPSD structure to be returned to the caller.
                //
                pPSDA->hDevMode  = (PI.pPDA)->hDevMode;
                pPSDA->hDevNames = (PI.pPDA)->hDevNames;
            }
            else
            {
                //
                //  Failure.  Restore the old devmode and devnames.
                //
                pPSDA->hDevMode = hDevMode;
                pPSDA->hDevNames = hDevNames;
            }

            //
            //  Restore the old template name (always).
            //
            pPSDA->lpPageSetupTemplateName = pTemplateName;
        }
        FreeThunkPrintDlg(&PI);
    }
    FreeThunkPageSetupDlg(&PI);

    return (bResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgW
//
//  Stub UNICODE function for PageSetupDlg when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlgW(
    LPPAGESETUPDLGW pPSDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlg
//
//  The PageSetupDlg function displays a Page Setup dialog box.  This
//  dialog box enables the user to specify the page orientation, the
//  paper size, the paper source, and the margin settings.  The
//  appearance of the printed page is shown in the dialog's page preview.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlg(
    LPPAGESETUPDLG pPSD)
{
    PRINTINFO PI;
    BOOL bResult;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPSD = pPSD;
    PI.ApiType = COMDLG_WIDE;

    bResult = PageSetupDlgX(&PI);

    if (PI.pPD)
    {
        GlobalFree(PI.pPD);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgX
//
//  Worker routine for the PageSetupDlg api.
//
//  NOTE:  Caller of this routine must free pPI->pPD.
//
////////////////////////////////////////////////////////////////////////////

BOOL PageSetupDlgX(
    PPRINTINFO pPI)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    BOOL bResult = FALSE;
    LPPRINTDLG pPD;
    RECT rtMinMargin;
    RECT rtMargin;
    POINT ptPaperSize;
    DWORD Flags;


    if (!pPSD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSD->lStructSize != sizeof(PAGESETUPDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_RETURNDEFAULT) &&
        (pPSD->hDevNames || pPSD->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Make sure only the PSD_* bits are on.  Otherwise, bad things
    //  will happen.
    //
    if ((pPSD->Flags & ~(PSD_MINMARGINS |
                         PSD_MARGINS |
                         PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS |
                         PSD_DISABLEMARGINS |
                         PSD_DISABLEPRINTER |
                         PSD_NOWARNING |                     // must be same as PD_*
                         PSD_DISABLEORIENTATION |
                         PSD_DISABLEPAPER |
                         PSD_RETURNDEFAULT |                 // must be same as PD_*
                         PSD_SHOWHELP |                      // must be same as PD_*
                         PSD_ENABLEPAGESETUPHOOK |           // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATE |       // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE | // must be same as PD_*
                         PSD_ENABLEPAGEPAINTHOOK |
                         PSD_DISABLEPAGEPAINTING |
                         CD_WX86APP |
                         PSD_NONETWORKBUTTON))  ||           // must be same as PD_*
        ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS)) ==
         (PSD_INTHOUSANDTHSOFINCHES | PSD_INHUNDREDTHSOFMILLIMETERS)))
    {
        StoreExtendedError(PDERR_INITFAILURE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_MINMARGINS) && (pPSD->Flags & PSD_MARGINS))
    {
        if ( (pPSD->rtMargin.left   < pPSD->rtMinMargin.left)  ||
             (pPSD->rtMargin.top    < pPSD->rtMinMargin.top)   ||
             (pPSD->rtMargin.right  < pPSD->rtMinMargin.right) ||
             (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (FALSE);
        }
    }

    if (pPSD->Flags & PSD_ENABLEPAGESETUPHOOK)
    {
        if (!pPSD->lpfnPageSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPageSetupHook = NULL;
    }

    if (pPSD->Flags & PSD_ENABLEPAGEPAINTHOOK)
    {
        if (!pPSD->lpfnPagePaintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPagePaintHook = NULL;
    }

    if ((pPI->pPD) || (pPI->pPD = GlobalAlloc(GPTR, sizeof(PRINTDLG))))
    {
        pPD = pPI->pPD;

        pPD->lStructSize         = sizeof(PRINTDLG);
        pPD->hwndOwner           = pPSD->hwndOwner;
        pPD->Flags               = PD_PAGESETUP |
                                     (pPSD->Flags &
                                       (PSD_NOWARNING |
                                        PSD_SHOWHELP |
                                        PSD_ENABLEPAGESETUPHOOK |
                                        PSD_ENABLEPAGESETUPTEMPLATE |
                                        PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                        CD_WX86APP |
                                        PSD_NONETWORKBUTTON));
        pPD->hInstance           = pPSD->hInstance;
        pPD->lCustData           = pPSD->lCustData;
        pPD->lpfnSetupHook       = pPSD->lpfnPageSetupHook;
        pPD->lpSetupTemplateName = pPSD->lpPageSetupTemplateName;
        pPD->hSetupTemplate      = pPSD->hPageSetupTemplate;

        //
        //  Save original settings in case the user hits cancel.
        //
        rtMinMargin = pPSD->rtMinMargin;
        rtMargin    = pPSD->rtMargin;
        ptPaperSize = pPSD->ptPaperSize;
        Flags       = pPSD->Flags;

        //
        //  Make sure the measure choice is set.
        //
        if ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                            PSD_INHUNDREDTHSOFMILLIMETERS)) == 0)
        {
            TCHAR szIMeasure[2];

            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2);
            if (szIMeasure[0] == TEXT('1'))
            {
                pPSD->Flags |= PSD_INTHOUSANDTHSOFINCHES;
            }
            else
            {
                pPSD->Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
            }
        }

        //
        //  Set minimum margins to 0 if not passed in.
        //
        if (!(pPSD->Flags & PSD_MINMARGINS))
        {
            pPSD->rtMinMargin.left   = 0;
            pPSD->rtMinMargin.top    = 0;
            pPSD->rtMinMargin.right  = 0;
            pPSD->rtMinMargin.bottom = 0;
        }

        //
        //  Set margins to defaults if not passed in.
        //
        if (!(pPSD->Flags & PSD_MARGINS))
        {
            LONG MarginDefault = (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
                                     ? INCHES_DEFAULT
                                     : MMS_DEFAULT;

            pPSD->rtMargin.left   = MarginDefault;
            pPSD->rtMargin.top    = MarginDefault;
            pPSD->rtMargin.right  = MarginDefault;
            pPSD->rtMargin.bottom = MarginDefault;
        }

        TransferPSD2PD(pPI);

        bResult = PrintDlgX(pPI);

        TransferPD2PSD(pPI);

        if (!bResult)
        {
            //
            //  Restore original settings when the user hits cancel.
            //
            pPSD->rtMinMargin = rtMinMargin;
            pPSD->rtMargin    = rtMargin;
            pPSD->ptPaperSize = ptPaperSize;
            pPSD->Flags       = Flags;
        }
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintLoadIcons()
{
    //
    //  See if we need to load the icons.
    //
    if (bAllIconsLoaded == FALSE)
    {
        //
        //  Load the orientation icons.
        //
        hIconPortrait = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_PORTRAIT));
        hIconLandscape = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_LANDSCAPE));

        //
        //  Load the duplex icons.
        //
        hIconPDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_NONE));
        hIconLDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_NONE));
        hIconPDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_HORIZ));
        hIconLDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_VERT));
        hIconPDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_VERT));
        hIconLDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_HORIZ));

        //
        //  Load the page setup icons.
        //
        hIconPSStampP = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_PSSTAMP));
        hIconPSStampL = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_PSSTAMP));

        //
        //  Load the collation images.
        //
        hIconCollate = LoadImage( g_hinst,
                                  MAKEINTRESOURCE(ICO_COLLATE),
                                  IMAGE_ICON,
                                  0,
                                  0,
                                  LR_SHARED );
        hIconNoCollate = LoadImage( g_hinst,
                                    MAKEINTRESOURCE(ICO_NO_COLLATE),
                                    IMAGE_ICON,
                                    0,
                                    0,
                                    LR_SHARED );

        bAllIconsLoaded = ( hIconPortrait &&
                            hIconLandscape &&
                            hIconPDuplexNone &&
                            hIconLDuplexNone &&
                            hIconPDuplexTumble &&
                            hIconLDuplexTumble &&
                            hIconPDuplexNoTumble &&
                            hIconLDuplexNoTumble &&
                            hIconPSStampP &&
                            hIconPSStampL &&
                            hIconCollate &&
                            hIconNoCollate );
    }

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (bAllIconsLoaded);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplayPrintDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplayPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif


    //
    //  NOTE:  The print hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         PrintHook when calling Print Setup will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLEPRINTHOOK)
    {
        if (!pPD->lpfnPrintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnPrintHook = NULL;
    }

    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (pPD->hPrintTemplate)
        {
            hDlgTemplate = pPD->hPrintTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
        {
            if (pPD->lpPrintTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpPrintTemplateName;
                    hInstance = pPD->hInstance;

                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = MAKEINTRESOURCE(PRINTDLGORD);
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG);
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );
#else
        fGotInput = (BOOL)DialogBoxIndirectParam( hInstance,
                                            (LPDLGTEMPLATE)hDlgTemplate,
                                            pPD->hwndOwner,
                                            PrintDlgProc,
                                            (LPARAM)pPI );
#endif

        glpfnPrintHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplaySetupDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplaySetupDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif


    //
    //  NOTE:  The setup hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         SetupHook when calling Print will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLESETUPHOOK)
    {
        if (!pPD->lpfnSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnSetupHook = NULL;
    }

    if (pPD->Flags & PD_ENABLESETUPTEMPLATEHANDLE)
    {
        if (pPD->hSetupTemplate)
        {
            hDlgTemplate = pPD->hSetupTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLESETUPTEMPLATE)
        {
            if (pPD->lpSetupTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpSetupTemplateName;
                    hInstance = pPD->hInstance;
                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = ( (pPD->Flags & PD_PRINTSETUP)
                                 ? MAKEINTRESOURCE(PRNSETUPDLGORD)
                                 : MAKEINTRESOURCE(PAGESETUPDLGORD) );
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG);
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintSetupDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );
#else
        fGotInput = (BOOL)DialogBoxIndirectParam( hInstance,
                                            (LPDLGTEMPLATE)hDlgTemplate,
                                            pPD->hwndOwner,
                                            PrintSetupDlgProc,
                                            (LPARAM)pPI );
#endif

        glpfnSetupHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgProc
//
//  Print Dialog procedure.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD;
    HWND hCtl;
    BOOL bTest;
    BOOL_PTR bResult;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnPrintHook))
        {
            LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
            }
#endif
            if ((bResult = (*lpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
            {
#ifdef UNICODE
                if (pPI->ApiType == COMDLG_ANSI)
                {
                    ThunkPrintDlgA2W(pPI);
                }
#endif
                return (bResult);
            }
        }
    }
    else if (glpfnPrintHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
    {

        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            HourGlass(TRUE);
#ifndef WINNT
            msgHELPA = RegisterWindowMessage(szCommdlgHelp);
#endif
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            glpfnPrintHook = NULL;

            pPI = (PPRINTINFO)lParam;
            pPD = pPI->pPD;
            if (pPI->pPSD)
            {
                TCHAR szTitle[32];
                RECT aRtDlg;
                RECT aRtGrp;
                RECT aRtYep;
                RECT aRtCan;
                HWND hBtnYep = GetDlgItem(hDlg, IDOK);
                HWND hBtnCan = GetDlgItem(hDlg, IDCANCEL);
                RECT aRtWhere;
                RECT aRtCmmnt;
                LONG GapHeight, DlgTop;

                //
                //  Save the client coordinate for the top of the dialog.
                //  Also, save the height of the gap between the bottom of
                //  the original OK button and the bottom of the original
                //  dialog.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(hBtnYep, &aRtYep);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.left);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg, (LPPOINT)&aRtYep.right);
                DlgTop = aRtDlg.top;
                GapHeight = (aRtDlg.bottom - aRtYep.bottom > 0)
                               ? aRtDlg.bottom - aRtYep.bottom
                               : 15;

                //
                //  Display the title of the dialog box.
                //
                GetWindowText(GetParent(hDlg), szTitle, 32);
                SetWindowText(hDlg, szTitle);

                //
                //  Get the screen and client coordinates for the dialog,
                //  the Printer group box, the OK button, and the Cancel
                //  button.  These will be used to reposition the OK,
                //  Cancel, and Help buttons.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(GetDlgItem(hDlg, ID_PRINT_G_PRINTER), &aRtGrp);
                GetWindowRect(hBtnYep, &aRtYep);
                GetWindowRect(hBtnCan, &aRtCan);

                //
                //If we are in a mirrored Dlg the use the left side.
                //
                if (IS_WINDOW_RTL_MIRRORED(hDlg)) {
                    aRtDlg.right = aRtDlg.left;
                }
                ScreenToClient(hDlg   , (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg   , (LPPOINT)&aRtGrp.right);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtYep, 2);
                aRtYep.right -= aRtYep.left;
                aRtYep.bottom -= aRtYep.top;

                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtCan, 2);
                aRtCan.right -= aRtCan.left;
                aRtCan.bottom -= aRtCan.top;
#ifdef WINNT
                if (pPD->Flags & PD_SHOWHELP)
                {
                    HWND hBtnHlp = GetDlgItem(hDlg, ID_BOTH_P_HELP);
                    RECT aRtHlp;

                    //
                    //  Move the Help button up underneath the
                    //  Printer group box.
                    //
                    if (hBtnHlp)
                    {
                        GetWindowRect(hBtnHlp, &aRtHlp);
                        MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtHlp, 2);
                        aRtHlp.right -= aRtHlp.left;
                        aRtHlp.bottom -= aRtHlp.top;

                        MoveWindow( hBtnHlp,
                                    aRtHlp.left,
                                    aRtGrp.bottom + 2 * aRtHlp.bottom / 3,
                                    aRtHlp.right,
                                    aRtHlp.bottom,
                                    FALSE );
                    }
                }
#endif
                //
                //  Move the OK and Cancel buttons up underneath the
                //  Printer group box.
                //
                MoveWindow( hBtnYep,
                            aRtYep.left,
                            aRtGrp.bottom + 2 * aRtYep.bottom / 3,
                            aRtYep.right,
                            aRtYep.bottom,
                            FALSE );
                MoveWindow( hBtnCan,
                            aRtCan.left,
                            aRtGrp.bottom + 2 * aRtCan.bottom / 3,
                            aRtCan.right,
                            aRtCan.bottom,
                            FALSE );

                //
                //  Resize the dialog.
                //
                GetWindowRect(hBtnYep, &aRtYep);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtYep, 2);
                MoveWindow( hDlg,
                            aRtDlg.left,
                            aRtDlg.top,
                            aRtDlg.right,
                            (aRtYep.bottom - DlgTop) + GapHeight,
                            FALSE );

                //
                //  Hide all other print dlg items.
                //
                //  NOTE: Need to do a SetWindowPos to actually remove
                //        the window so that the AddNetButton call does
                //        not think it's there.
                //
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_TOFILE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_RANGE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_I_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_ALL),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_SELECTION),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_PAGES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );

                //
                //  Enlarge the comment edit control, since the
                //  "print to file" check box is hidden.
                //
                GetWindowRect(GetDlgItem(hDlg, ID_BOTH_S_WHERE), &aRtWhere);
                GetWindowRect( hCtl = GetDlgItem(hDlg, ID_BOTH_S_COMMENT),
                               &aRtCmmnt );
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtCmmnt, 2);
                MoveWindow( hCtl,
                            aRtCmmnt.left,
                            aRtCmmnt.top,
                            aRtWhere.right  - aRtWhere.left,
                            aRtWhere.bottom - aRtWhere.top,
                            FALSE );
#ifdef WINNT
                //
                //  Add or hide net button, if necessary.
                //
                if ((pPD->Flags & PD_NONETWORKBUTTON))
                {
                    if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
                    {
                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
                else
                {
                    AddNetButton( hDlg,
                                  g_hinst,
                                  FILE_BOTTOM_MARGIN,
                                  TRUE,
                                  FALSE,
                                  TRUE);

                    //
                    //  The button can be added in two ways -
                    //      statically (they have it predefined in their template) and
                    //      dynamically (successful call to AddNetButton).
                    //
                    if (!IsNetworkInstalled())
                    {
                        hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
#endif
            }
            else
            {
                if (pPD->Flags & PD_COLLATE)
                {
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            if (!PrintInitGeneral(hDlg, ID_PRINT_C_NAME, pPI) ||
                ((dwResult = PrintInitPrintDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, -2);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_PRINT_C_NAME ) :       // Printer Name combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                    }
                    else if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                              !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_PRINT_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_PRINT_C_NAME, pPI);

                    break;
                }
                case ( ID_PRINT_P_SETUP ) :      // Setup... button
                {
                    DWORD dwFlags = pPD->Flags;
                    HWND hwndOwner = pPD->hwndOwner;

                    pPD->Flags |= PD_PRINTSETUP;
                    pPD->Flags &= ~(PD_RETURNDC | PD_RETURNIC);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;
                    pPD->hwndOwner = hDlg;

                    if (PrintDlgX(pPI))
                    {
                        if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
                        {
                            StoreExtendedError(CDERR_GENERALCODES);
                        }
                    }

                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;
                    pPD->Flags = dwFlags;
                    pPD->hwndOwner = hwndOwner;

                    break;
                }
                case ( ID_PRINT_R_ALL ) :        // Print Range - All
                case ( ID_PRINT_R_SELECTION ) :  // Print Range - Selection
                case ( ID_PRINT_R_PAGES ) :      // Print Range - Pages (From, To)
                {
                    CheckRadioButton( hDlg,
                                      ID_PRINT_R_ALL,
                                      ID_PRINT_R_PAGES,
                                      GET_WM_COMMAND_ID(wParam, lParam) );

                    //
                    //  Only move the the focus to the "From" control when
                    //  the up/down arrow is NOT used.
                    //
                    if ( !IS_KEY_PRESSED(VK_UP) &&
                         !IS_KEY_PRESSED(VK_DOWN) &&
                         ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == ID_PRINT_R_PAGES)) )
                    {
                        SendMessage( hDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hDlg, ID_PRINT_E_FROM),
                                     1L );
                    }

                    break;
                }
                case ( ID_PRINT_E_FROM ) :       // From  (Print Range - Pages)
                {
                    //
                    //  Only enable the "To" control if the "From" control
                    //  contains a value.
                    //
                    GetDlgItemInt(hDlg, ID_PRINT_E_FROM, &bTest, FALSE);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), bTest);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), bTest);

                    //  FALL THRU...
                }
                case ( ID_PRINT_E_TO ) :         // To  (Print Range - Pages)
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        CheckRadioButton( hDlg,
                                          ID_PRINT_R_ALL,
                                          ID_PRINT_R_PAGES,
                                          ID_PRINT_R_PAGES );
                    }

                    break;
                }


                case (ID_PRINT_E_COPIES ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        BOOL bTest;
                        //
                        //  Save the number of copies.
                        //
                        DWORD nCopies = GetDlgItemInt(hDlg, ID_PRINT_E_COPIES, &bTest, FALSE);

                        //
                        //  If the copy count is > 1, enable collate.  Otherwise,
                        //  disable it.
                        //
                        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
                        {
                            EnableWindow(hCtl, (nCopies > 1));
                        }

                    }

                    break;
                }

                case ( ID_PRINT_X_COLLATE ) :    // Collate check box
                {
                    if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
                    {
                        ShowWindow(hCtl, SW_HIDE);
                        SendMessage( hCtl,
                                     STM_SETICON,
                                     IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                                         ? (LONG_PTR)hIconCollate
                                         : (LONG_PTR)hIconNoCollate,
                                     0L );
                        ShowWindow(hCtl, SW_SHOW);

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                        {
                            pPI->Status |= PI_COLLATE_REQUESTED;
                        }
                        else
                        {
                            pPI->Status &= ~PI_COLLATE_REQUESTED;
                        }
                    }

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
#ifdef WINNT
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_PRINT_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_PRINT_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
#else
                    WNetConnectionDialog(hDlg, RESOURCETYPE_PRINT);
#endif
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
#ifdef UNICODE
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPI->pPDA );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    bResult = TRUE;
                    if (!(pPI->pPSD))
                    {
                        pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                                 PD_PAGENUMS    |
                                                 PD_SELECTION   |
                                                 PD_COLLATE ));

                        pPD->nCopies = (WORD)GetDlgItemInt( hDlg,
                                                            ID_PRINT_E_COPIES,
                                                            &bTest,
                                                            FALSE );
                        if ((!bTest) || (!pPD->nCopies))
                        {
                            PrintEditError( hDlg,
                                            ID_PRINT_E_COPIES,
                                            iszCopiesZero );
                            return (TRUE);
                        }

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_R_SELECTION))
                        {
                            pPD->Flags |= PD_SELECTION;
                        }
                        else if (IsDlgButtonChecked(hDlg, ID_PRINT_R_PAGES))
                        {
                            //
                            //  Check the "From" and "To" values.
                            //
                            pPD->Flags |= PD_PAGENUMS;
                            pPD->nFromPage = (WORD)GetDlgItemInt( hDlg,
                                                                  ID_PRINT_E_FROM,
                                                                  &bTest,
                                                                  FALSE );
                            if (!bTest)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageFromError );
                                return (TRUE);
                            }

                            pPD->nToPage = (WORD)GetDlgItemInt( hDlg,
                                                                ID_PRINT_E_TO,
                                                                &bTest,
                                                                FALSE );
                            if (!bTest)
                            {
                                TCHAR szBuf[PAGE_EDIT_SIZE + 1];

                                if (GetDlgItemText( hDlg,
                                                    ID_PRINT_E_TO,
                                                    szBuf,
                                                    PAGE_EDIT_SIZE + 1 ))
                                {
                                    PrintEditError( hDlg,
                                                    ID_PRINT_E_TO,
                                                    iszPageToError );
                                    return (TRUE);
                                }
                                else
                                {
                                    pPD->nToPage = pPD->nFromPage;
                                }
                            }

                            if ( (pPD->nFromPage < pPD->nMinPage) ||
                                 (pPD->nFromPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if ( (pPD->nToPage < pPD->nMinPage) ||
                                 (pPD->nToPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_TO,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if (pPD->nFromPage > pPD->nToPage)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszFromToError );
                                return (TRUE);
                            }
                        }
                    }

                    HourGlass(TRUE);

                    if (IsDlgButtonChecked(hDlg, ID_PRINT_X_TOFILE))
                    {
                        pPD->Flags |= PD_PRINTTOFILE;
                    }

                    if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                         IsWindowEnabled(hCtl) &&
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE) )
                    {
                        pPD->Flags |= PD_COLLATE;
                    }

                    if (!PrintSetCopies(hDlg, pPI, ID_PRINT_C_NAME))
                    {
                        HourGlass(FALSE);
                        return (TRUE);
                    }

                    pDM = NULL;
                    pDN = NULL;
                    if (pPD->hDevMode)
                    {
                        pDM = GlobalLock(pPD->hDevMode);
                    }
                    if (pPD->hDevNames)
                    {
                        pDN = GlobalLock(pPD->hDevNames);
                    }
                    if (pDM && pDN)
                    {
                        DWORD nNum;

                        if ( GetDlgItem(hDlg, ID_PRINT_C_QUALITY) &&
                             (nNum = (DWORD) SendDlgItemMessage( hDlg,
                                                         ID_PRINT_C_QUALITY,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0L )) != CB_ERR )
                        {
                            pDM->dmPrintQuality =
                                (WORD)SendDlgItemMessage( hDlg,
                                                          ID_PRINT_C_QUALITY,
                                                          CB_GETITEMDATA,
                                                          (WPARAM)nNum,
                                                          0L );
                        }

                        PrintReturnICDC(pPD, pDN, pDM);
                    }
                    if (pDM)
                    {
                        GlobalUnlock(pPD->hDevMode);
                    }
                    if (pDN)
                    {
                        GlobalUnlock(pPD->hDevNames);
                    }

#ifdef UNICODE
                    if (pPD->Flags & CD_WOWAPP)
                    {
                        UpdateSpoolerInfo(pPI);
                    }
#endif

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    glpfnPrintHook = GETPRINTHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL_PTR) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupDlgProc
//
//  Print Setup Dialog proc.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD = NULL;
    BOOL_PTR bResult;
    UINT uCmdId;
    LPDEVMODE pDM;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnSetupHook))
        {
            LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
                TransferPDA2PSD(pPI);

                pPI->NestCtr++;
                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);
                pPI->NestCtr--;

                if (bResult)
                {
                    TransferPSD2PDA(pPI);
                    ThunkPrintDlgA2W(pPI);
                    if (pPI->NestCtr == 0)
                    {
                        TransferPD2PSD(pPI);
                    }
                    return (bResult);
                }
            }
            else
#endif
            {
                TransferPD2PSD(pPI);

                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);

                if (bResult)
                {
                    TransferPSD2PD(pPI);
                    return (bResult);
                }
            }
        }
    }
    else if (glpfnSetupHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnSetupHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            //
            // Disable RTL mirroring on the WHITE-SAMPLE
            //
            SetWindowLong(GetDlgItem(hDlg, ID_SETUP_W_SAMPLE),
                          GWL_EXSTYLE,
                          GetWindowLong(GetDlgItem(hDlg, ID_SETUP_W_SAMPLE), GWL_EXSTYLE) & ~RTL_MIRRORED_WINDOW);
            HourGlass(TRUE);
#ifndef WINNT
            msgHELPA = RegisterWindowMessage(szCommdlgHelp);
#endif
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            pPI = (PPRINTINFO)lParam;
            pPI->bKillFocus = FALSE;
            glpfnSetupHook = NULL;

            if (!PrintInitGeneral(hDlg, ID_SETUP_C_NAME, pPI) ||
                ((dwResult = PrintInitSetupDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, FALSE);
            }
            else if (pPI->pPSD && (pPI->pPSD->Flags & PSD_RETURNDEFAULT))
            {
                //
                //  PSD_RETURNDEFAULT goes through the entire initialization
                //  in order to set rtMinMargin, rtMargin, and ptPaperSize.
                //  Win95 Notepad relies on this behavior.
                //
                SendMessage(hDlg, WM_COMMAND, IDOK, 0);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (uCmdId = GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_SETUP_C_NAME ) :       // Printer Name combobox
                {
                    if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                         !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_SETUP_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                    {
                        break;
                    }
                    if ( !GetDlgItem(hDlg, ID_SETUP_R_SPECIFIC) ||
                         IsDlgButtonChecked(hDlg, ID_SETUP_R_SPECIFIC) )
                    {
                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        break;
                    }

                    uCmdId = ID_SETUP_R_SPECIFIC;

                    // FALL THRU...
                }
                case ( ID_SETUP_R_DEFAULT ) :    // Default printer
                case ( ID_SETUP_R_SPECIFIC ) :   // Specific printer
                {
                    //
                    //  Sanity check for Publisher bug where user tries to
                    //  set focus to ID_SETUP_R_DEFAULT on exit if the
                    //  dialog has no default printer.
                    //
                    if (pPI->hCurPrinter)
                    {
                        HWND hCmb;
                        DWORD dwStyle;

                        hCmb = GetDlgItem(hDlg, ID_SETUP_C_NAME);
                        if (hCmb && (uCmdId == ID_SETUP_R_DEFAULT))
                        {
                            if (!(pPI->Status & PI_PRINTERS_ENUMERATED))
                            {
                                //
                                //  Enumerate printers if this hasn't been
                                //  done yet.  Otherwise, the default printer
                                //  may not be found in the list box when
                                //  switching from Specific to Default.
                                //
                                PrintEnumAndSelect( hDlg,
                                                    ID_SETUP_C_NAME,
                                                    pPI,
                                                    NULL,
                                                    TRUE );
                            }

                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (WPARAM)SendMessage(
                                             hCmb,
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM)-1,
                                             (LPARAM)(pPI->szDefaultPrinter) ),
                                         (LPARAM)0 );
                        }

                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);

                        CheckRadioButton( hDlg,
                                          ID_SETUP_R_DEFAULT,
                                          ID_SETUP_R_SPECIFIC,
                                          uCmdId);

                        dwStyle = GetWindowLong(hCmb, GWL_STYLE);
                        if (uCmdId == ID_SETUP_R_DEFAULT)
                        {
                            dwStyle &= ~WS_TABSTOP;
                        }
                        else
                        {
                            dwStyle |= WS_TABSTOP;
                            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hCmb, 1L);
                        }
                        SetWindowLong(hCmb, GWL_STYLE, dwStyle);
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_SETUP_C_NAME, pPI);

                    break;
                }
                case ( ID_SETUP_P_MORE ) :      // More... button
                {
                    pDM = GlobalLock(pPD->hDevMode);

                    AdvancedDocumentProperties( hDlg,
                                                pPI->hCurPrinter,
                                                (pPI->pCurPrinter)
                                                  ? pPI->pCurPrinter->pPrinterName
                                                  : NULL,
                                                pDM,
                                                pDM );

                    GlobalUnlock(pPD->hDevMode);
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    break;
                }
                case ( ID_SETUP_R_PORTRAIT ) :   // Portrait
                case ( ID_SETUP_R_LANDSCAPE ) :  // Landscape
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetOrientation( hDlg,
                                             pPI,
                                             pDM,
                                             pPI->uiOrientationID,
                                             uCmdId );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //  FALL THRU ...
                }
                case ( ID_SETUP_R_NONE ) :       // None       (2-Sided)
                case ( ID_SETUP_R_LONG ) :       // Long Side  (2-Sided)
                case ( ID_SETUP_R_SHORT ) :      // Short Side (2-Sided)
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetDuplex(hDlg, pDM, uCmdId);
                        GlobalUnlock(pPD->hDevMode);
                    }

                    break;
                }
                case ( ID_SETUP_C_SIZE ) :       // Size combobox
                {
                    UINT Orientation;

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            Orientation =
                                IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                              ? ID_SETUP_R_PORTRAIT
                                              : ID_SETUP_R_LANDSCAPE;
                            PrintSetOrientation( hDlg,
                                                 pPI,
                                                 pDM,
                                                 Orientation,
                                                 Orientation );
                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_C_SOURCE ) :       // Source combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_E_LEFT ) :       // Left    (Margins)
                case ( ID_SETUP_E_TOP ) :        // Top     (Margins)
                case ( ID_SETUP_E_RIGHT ) :      // Right   (Margins)
                case ( ID_SETUP_E_BOTTOM ) :     // Bottom  (Margins)
                {
                    if (pPI->bKillFocus)
                    {
                        break;
                    }

                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_KILLFOCUS ) :
                        {
                            pPI->bKillFocus = TRUE;
                            PrintSetMargin( hDlg,
                                            pPI,
                                            uCmdId,
                                            *((LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT) );
                            pPI->bKillFocus = FALSE;

                            break;
                        }
                        case ( EN_CHANGE ) :
                        {
                            HWND hSample;

                            PrintGetMargin( GET_WM_COMMAND_HWND(wParam, lParam),
                                            pPI,
                                            *((LONG*)&pPI->pPSD->rtMinMargin +
                                              uCmdId - ID_SETUP_E_LEFT),
                                            (LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT,
                                            (LONG*)&pPI->RtMarginMMs +
                                              uCmdId - ID_SETUP_E_LEFT );

                            if (hSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
                            {
                                RECT rect;

                                GetClientRect(hSample, &rect);
                                InflateRect(&rect, -1, -1);
                                InvalidateRect(hSample, &rect, TRUE);
                            }

                            break;
                        }
                    }

                    break;
                }
                case ( ID_SETUP_P_PRINTER ) :    // Printer... button
                {
                    //
                    //  Save a copy of the original values.
                    //
                    HWND hwndOwner = pPD->hwndOwner;
                    DWORD dwFlags = pPD->Flags;
                    HINSTANCE hInstance = pPD->hInstance;
                    LPCTSTR lpPrintTemplateName = pPD->lpPrintTemplateName;

                    //
                    //  Set up pPI so that PrintDlgX can do all the work.
                    //
                    pPD->hwndOwner = hDlg;
                    pPD->Flags &= ~( PD_ENABLEPRINTTEMPLATEHANDLE |
                                     PD_RETURNIC |
                                     PD_RETURNDC |
                                     PD_PAGESETUP );
                    pPD->Flags |= PD_ENABLEPRINTTEMPLATE;
                    pPD->hInstance = g_hinst;
                    pPD->lpPrintTemplateName = MAKEINTRESOURCE(PRINTDLGORD);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;

                    if (PrintDlgX(pPI))
                    {
                        PrintUpdateSetupDlg( hDlg,
                                             pPI,
                                             GlobalLock(pPD->hDevMode),
                                             TRUE );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //
                    //  Restore the original values.
                    //
                    pPD->hwndOwner = hwndOwner;
                    pPD->Flags = dwFlags;
                    pPD->hInstance = hInstance;
                    pPD->lpPrintTemplateName = lpPrintTemplateName;
                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;

                    //
                    //  Set the keyboard focus to the OK button.
                    //
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    HourGlass(FALSE);

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
#ifdef WINNT
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_SETUP_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_SETUP_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
#else
                    WNetConnectionDialog(hDlg, RESOURCETYPE_PRINT);
#endif
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
#ifdef UNICODE
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPI->pPDA );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    LPPAGESETUPDLG pPSD = pPI->pPSD;
                    int i;

                    if (pPSD)
                    {
                        if ((pPSD->rtMinMargin.left + pPSD->rtMinMargin.right >
                                pPSD->ptPaperSize.x) ||
                            (pPSD->rtMinMargin.top + pPSD->rtMinMargin.bottom >
                                pPSD->ptPaperSize.y))
                        {
                            //
                            //  This is an unprintable case that can happen.
                            //  Let's assume that the driver is at fault
                            //  and accept whatever the user entered.
                            //
                        }
                        else if (pPSD->rtMargin.left + pPSD->rtMargin.right >
                                     pPSD->ptPaperSize.x)
                        {
                            i = (pPSD->rtMargin.left >= pPSD->rtMargin.right)
                                    ? ID_SETUP_E_LEFT
                                    : ID_SETUP_E_RIGHT;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                        else if (pPSD->rtMargin.top + pPSD->rtMargin.bottom >
                                     pPSD->ptPaperSize.y)
                        {
                            i = (pPSD->rtMargin.top >= pPSD->rtMargin.bottom)
                                    ? ID_SETUP_E_TOP
                                    : ID_SETUP_E_BOTTOM;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                    }
                    else
                    {
                        HourGlass(TRUE);
                        if (!PrintSetCopies(hDlg, pPI, ID_SETUP_C_NAME))
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }
                    }

                    bResult = TRUE;
                    SetFocus( GetDlgItem(hDlg, IDOK) );

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    if (bResult)
                    {
                        PrintGetSetupInfo(hDlg, pPD);
#ifdef UNICODE
                        if (pPD->Flags & CD_WOWAPP)
                        {
                            UpdateSpoolerInfo(pPI);
                        }
#endif
                    }
                    else
                    {
                        SetFocus( GetDlgItem(hDlg, IDCANCEL) );
                    }
                    pPI->bKillFocus = TRUE;

                    glpfnSetupHook = GETSETUPHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)( pPD && (pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)( pPD && (pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL_PTR) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditMarginProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    if ( (msg == WM_CHAR) &&
         (wP != BACKSPACE) &&
         (wP != CTRL_X_CUT) &&
         (wP != CTRL_C_COPY) &&
         (wP != CTRL_V_PASTE) &&
         (wP != (WPARAM)cIntlDecimal) &&
         ((wP < TEXT('0')) || (wP > TEXT('9'))) )
    {
        MessageBeep(0);
        return (FALSE);
    }

    return ( CallWindowProc(lpEditMarginProc, hWnd, msg, wP, lP) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintPageSetupPaintProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    LRESULT lResult;
    PPRINTINFO pPI;
    LPPAGESETUPDLG pPSD;
    HDC hDC;
    RECT aRt, aRtPage, aRtUser;
    PAINTSTRUCT aPs;
    HGDIOBJ hPen, hBr, hFont, hFontGreek;
    HRGN hRgn;
    TCHAR szGreekText[] = TEXT("Dheevaeilnorpoefdi lfaocr, \nMoiccsriocsnoafrtf \tbnya\nSFlr acnn IF iynnnaepgmaonc\n F&i nyneelglaanm 'Ox' Mnaalgleenyn i&f QCnoamgpeannnyi FI nxca.r\nFSoaynb  Ftrfaonscoirscciom,  \rCoafl idfeopronlieav\ne\n");
    LPTSTR psGreekText;
    int i;


    if (msg != WM_PAINT)
    {
        return ( CallWindowProc(lpStaticProc, hWnd, msg, wP, lP) );
    }

    hDC = BeginPaint(hWnd, &aPs);
    GetClientRect(hWnd, &aRt);
    FillRect(hDC, &aRt, (HBRUSH)GetStockObject(WHITE_BRUSH));
    EndPaint(hWnd, &aPs);
    lResult = 0;

    if ( (!(hDC = GetDC(hWnd))) ||
         (!(pPI = (PPRINTINFO)GetProp(GetParent(hWnd), PRNPROP))) )
    {
        return (0);
    }
    pPSD = pPI->pPSD;

    TransferPD2PSD(pPI);
    aRtPage = aRt;
    hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);

    // Rectangle() does not work here
    MoveToEx( hDC, 0            , 0             , NULL );
    LineTo(   hDC, aRt.right - 1, 0              );
    MoveToEx( hDC, 0            , 1             , NULL );
    LineTo(   hDC, 0            , aRt.bottom - 1 );
    DeleteObject(SelectObject(hDC, hPen));

    // Rectangle() does not work here
    MoveToEx( hDC, aRt.right - 1, 0             , NULL );
    LineTo(   hDC, aRt.right - 1, aRt.bottom - 1 );
    MoveToEx( hDC, 0            , aRt.bottom - 1, NULL );
    LineTo(   hDC, aRt.right    , aRt.bottom - 1 );

    SetBkMode(hDC, TRANSPARENT);
    hPen = (HGDIOBJ)CreatePen(PS_DOT, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);
    hBr  = (HGDIOBJ)GetStockObject(NULL_BRUSH);
    hBr  = SelectObject(hDC, hBr);

    hFont = hFontGreek = CreateFont( pPI->PtMargins.y,
                                     pPI->PtMargins.x,
                                     0,
                                     0,
                                     FW_DONTCARE,
                                     0,
                                     0,
                                     0,
                                     ANSI_CHARSET,
                                     OUT_DEFAULT_PRECIS,
                                     CLIP_DEFAULT_PRECIS,
                                     DEFAULT_QUALITY,
                                     VARIABLE_PITCH | FF_SWISS,
                                     NULL );
    hFont = SelectObject(hDC, hFont);

    InflateRect(&aRt, -1, -1);
    aRtUser = aRt;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);

    if (pPSD->lpfnPagePaintHook)
    {
        WORD wFlags;
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        switch (pPI->dwRotation)
        {
            default :
            {
                //
                //  Portrait mode only.
                //
                wFlags = 0x0000;
                break;
            }
            case ( ROTATE_LEFT ) :
            {
                //
                //  Dot-Matrix (270)
                //
                wFlags = 0x0001;
                break;
            }
            case ( ROTATE_RIGHT ) :
            {
                //
                //  HP PCL (90)
                //
                wFlags = 0x0003;
                break;
            }
        }
        if ( !wFlags ||
             IsDlgButtonChecked(GetParent(hWnd), ID_SETUP_R_PORTRAIT) )
        {
            //
            //  Paper in portrait.
            //
            wFlags |= 0x0004;
        }
        if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
        {
            wFlags |= 0x0008;
            if (aRt.right < aRt.bottom)
            {
                //
                //  Envelope in portrait.
                //
                wFlags |= 0x0010;
            }
        }
        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_PAGESETUPDLG,
                                  MAKELONG(pPI->wPaper, wFlags),
                                  (LPARAM)pPSD ) ||
            (*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_FULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }

        aRtUser = aRt;
        aRtUser.left   += aRtUser.right  * pPI->RtMinMarginMMs.left   / pPI->PtPaperSizeMMs.x;
        aRtUser.top    += aRtUser.bottom * pPI->RtMinMarginMMs.top    / pPI->PtPaperSizeMMs.y;
        aRtUser.right  -= aRtUser.right  * pPI->RtMinMarginMMs.right  / pPI->PtPaperSizeMMs.x;
        aRtUser.bottom -= aRtUser.bottom * pPI->RtMinMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

        if ((aRtUser.left   < aRtUser.right)  &&
            (aRtUser.top    < aRtUser.bottom) &&
            (aRtUser.left   > aRtPage.left)   &&
            (aRtUser.top    > aRtPage.top)    &&
            (aRtUser.right  < aRtPage.right)  &&
            (aRtUser.bottom < aRtPage.bottom))
        {
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MINMARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto NoMorePainting;
            }
        }
    }

    aRt.left   += aRt.right  * pPI->RtMarginMMs.left   / pPI->PtPaperSizeMMs.x;
    aRt.top    += aRt.bottom * pPI->RtMarginMMs.top    / pPI->PtPaperSizeMMs.y;
    aRt.right  -= aRt.right  * pPI->RtMarginMMs.right  / pPI->PtPaperSizeMMs.x;
    aRt.bottom -= aRt.bottom * pPI->RtMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

    if ( (aRt.left > aRtPage.left) && (aRt.left < aRtPage.right) &&
         (aRt.right < aRtPage.right) && (aRt.right > aRtPage.left) &&
         (aRt.top > aRtPage.top) && (aRt.top < aRtPage.bottom) &&
         (aRt.bottom < aRtPage.bottom) && (aRt.bottom > aRtPage.top) &&
         (aRt.left < aRt.right) &&
         (aRt.top < aRt.bottom) )
    {
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipMarginRectangle;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            Rectangle(hDC, aRt.left, aRt.top, aRt.right, aRt.bottom);
        }

SkipMarginRectangle:

        InflateRect(&aRt, -1, -1);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_GREEKTEXTRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipGreekText;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            psGreekText = LocalAlloc( LPTR,
                                      10 * (sizeof(szGreekText) + sizeof(TCHAR)) );
            for (i = 0; i < 10; i++)
            {
                CopyMemory( &(psGreekText[i * (sizeof(szGreekText) / sizeof(TCHAR))]),
                            szGreekText,
                            sizeof(szGreekText) );
            }
            aRt.left++;
            aRt.right--;
            aRt.bottom -= (aRt.bottom - aRt.top) % pPI->PtMargins.y;
            hFontGreek = SelectObject(hDC, hFontGreek);
            DrawText( hDC,
                      psGreekText,
                      10 * (sizeof(szGreekText) / sizeof(TCHAR)),
                      &aRt,
                      DT_NOPREFIX | DT_WORDBREAK );
            SelectObject(hDC, hFontGreek);
            LocalFree(psGreekText);
        }
    }

SkipGreekText:

    InflateRect(&aRtPage, -1, -1);
    if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
    {
        int iOrientation;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)     // portrait
        //  switch (pPI->dwRotation)
            {
        //      default :               // no landscape
        //      case ( ROTATE_LEFT ) :  // dot-matrix
        //      {
        //          aRt.left = aRt.right  - 16;
        //          aRt.top  = aRt.bottom - 32;
        //          iOrientation = 2;
        //          break;
        //      }
        //      case ( ROTATE_RIGHT ) : // HP PCL
        //      {
                    aRt.right  = aRt.left + 16;
                    aRt.bottom = aRt.top  + 32;
                    iOrientation = 1;
        //          break;
        //      }
            }
        else                            // landscape
        {
            aRt.left   = aRt.right - 32;
            aRt.bottom = aRt.top   + 16;
            iOrientation = 3;
        }
        hRgn = CreateRectRgnIndirect(&aRt);
        SelectClipRgn(hDC, hRgn);
        DeleteObject(hRgn);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_ENVSTAMPRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipEnvelopeStamp;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            switch (iOrientation)
            {
                default :          // HP PCL
            //  case ( 1 ) :
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampP);
                    break;
                }
            //  case ( 2 ) :       // dot-matrix
            //  {
            //      DrawIcon(hDC, aRt.left - 16, aRt.top, hIconPSStampP);
            //      break;
            //  }
                case ( 3 ) :       // landscape
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampL);
                    break;
                }
            }
        }
    }

SkipEnvelopeStamp:;

    aRtUser = aRtPage;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);
    if (pPSD->lpfnPagePaintHook)
    {
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_YAFULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }
    }

    //
    //  Draw the envelope lines.
    //
    if ( (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING)) &&
         (pPI->pPD->Flags & PI_WPAPER_ENVELOPE) )
    {
        int iRotation;
        HGDIOBJ hPenBlack;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)                     // portrait
        {
        //  if (pPI->dwRotation == ROTATE_LEFT )        // dot-matrix
        //      iRotation = 3;
        //  else            // ROTATE_RIGHT             // HP PCL
                iRotation = 2;
        }
        else                                            // landscape
        {
            iRotation = 1;                              // normal
        }

        switch (iRotation)
        {
            default :
        //  case ( 1 ) :      // normal
            {
                aRt.right  = aRt.left + 32;
                aRt.bottom = aRt.top  + 13;
                break;
            }
            case ( 2 ) :      // left
            {
                aRt.right = aRt.left   + 13;
                aRt.top   = aRt.bottom - 32;
                break;
            }
        //  case ( 3 ) :      // right
        //  {
        //      aRt.left   = aRt.right - 13;
        //      aRt.bottom = aRt.top   + 32;
        //      break;
        //  }
        }

        InflateRect(&aRt, -3, -3);
        hPenBlack = SelectObject(hDC, GetStockObject(BLACK_PEN));
        switch (iRotation)
        {
            case ( 1 ) :       // normal
            {
                MoveToEx(hDC, aRt.left , aRt.top    , NULL);
                LineTo(  hDC, aRt.right, aRt.top);
                MoveToEx(hDC, aRt.left , aRt.top + 3, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 3);
                MoveToEx(hDC, aRt.left , aRt.top + 6, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 6);

                break;
            }
        //  case ( 2 ) :       // left
        //  case ( 3 ) :       // right
            default :
            {
                MoveToEx( hDC, aRt.left      , aRt.top       , NULL );
                LineTo(   hDC, aRt.left      , aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 3, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 3, aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 6, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 6, aRt.bottom     );

                break;
            }
        }
        SelectObject(hDC, hPenBlack);
    }

NoMorePainting:

    DeleteObject(SelectObject(hDC, hPen));
    SelectObject(hDC, hBr);
    DeleteObject(SelectObject(hDC, hFont));
    TransferPSD2PD(pPI);
    ReleaseDC(hWnd, hDC);

    return (lResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadResource
//
//  This routine loads the resource with the given name and type.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType)
{
    HANDLE hResInfo, hRes;
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    //
    // If we are loading a resource from ComDlg32 then use the correct LangID.
    //
    if (hInst == g_hinst) {
        LangID = (LANGID) TlsGetValue(g_tlsLangID);
    }

    if (!(hResInfo = FindResourceExFallback(hInst, pType, pResName, LangID)))
    {
        StoreExtendedError(CDERR_FINDRESFAILURE);
        return (NULL);
    }

    if (!(hRes = LoadResource(hInst, hResInfo)))
    {
        StoreExtendedError(CDERR_LOADRESFAILURE);
        return (NULL);
    }

    return (hRes);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDefaultPrinterName
//
//  This routine gets the name of the default printer and stores it
//  in the given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize)
{
    DWORD dwSize;
    LPTSTR lpsz;


    if (pDefaultPrinter[0] != CHAR_NULL)
    {
        return;
    }

    //
    //  First, try to get the default printername from the win.ini file.
    //
    if (GetProfileString( szTextWindows,
                          szTextDevice,
                          szTextNull,
                          pDefaultPrinter,
                          cchSize ))
    {
        lpsz = pDefaultPrinter;

        while (*lpsz != CHAR_COMMA)
        {
            if (!*lpsz++)
            {
                pDefaultPrinter[0] = CHAR_NULL;
                goto GetDefaultFromRegistry;
            }
        }

        *lpsz = CHAR_NULL;
    }
    else
    {

GetDefaultFromRegistry:

        //
        //  Second, try to get it from the registry.
        //
        dwSize = cchSize * sizeof(TCHAR);

        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          szRegistryPrinter,
                          0,
                          KEY_READ,
                          &hPrinterKey ) == ERROR_SUCCESS)
        {
            RegQueryValueEx( hPrinterKey,
                             szRegistryDefaultValueName,
                             NULL,
                             NULL,
                             (LPBYTE)(pDefaultPrinter),
                             &dwSize );

            RegCloseKey(hPrinterKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnDefault
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintReturnDefault(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVNAMES pDN;
    LPDEVMODE pDM;


    StoreExtendedError(CDERR_GENERALCODES);

    if (pPD->hDevNames || pPD->hDevMode)
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    PrintBuildDevNames(pPI);

    if ((pPD->hDevNames) && (pDN = GlobalLock(pPD->hDevNames)))
    {
#ifdef WINNT
        //
        //  This is not needed in Win95.  An optimization was
        //  added to DocumentProperties that allows the caller to
        //  simply pass in the printer name without the printer
        //  handle.
        //
        LPTSTR pPrinterName;

        pPrinterName = (LPTSTR)pDN + pDN->wDeviceOffset;

        if (pPrinterName[0])
        {
            PrintOpenPrinter(pPI, pPrinterName);
        }

        pPD->hDevMode = PrintGetDevMode( 0,
                                         pPI->hCurPrinter,
                                         pPrinterName,
                                         NULL);
#else
        pPD->hDevMode = PrintGetDevMode( 0,
                                         NULL,
                                         (LPTSTR)pDN + pDN->wDeviceOffset,
                                         NULL );
#endif

        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC(pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (TRUE);
        }
        GlobalUnlock(pPD->hDevNames);
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }

    StoreExtendedError(PDERR_NODEFAULTPRN);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitGeneral
//
//  Initialize (enable/disable) dialog elements general to both PrintDlg
//  and SetupDlg.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HWND hCtl;


    SetWindowLong( hDlg,
                   GWL_STYLE,
                   GetWindowLong(hDlg, GWL_STYLE) | DS_CONTEXTHELP );

#ifndef WINNT
    if (!lpEditMarginProc)
    {
        WNDCLASSEX wc;

        wc.cbSize = sizeof(wc);

        GetClassInfoEx(NULL, TEXT("edit"), &wc);
        lpEditMarginProc = wc.lpfnWndProc;

        GetClassInfoEx(NULL, TEXT("static"), &wc);
        lpStaticProc = wc.lpfnWndProc;
    }
#endif

    //
    //  LATER: If we don't enumerate here, there will only be ONE item
    //         in the list box.  As a result, we won't catch the
    //         keyboard strokes within the list box (eg. arrow keys,
    //         pgup, pgdown, etc).  Need to subclass the combo boxes
    //         to catch these key strokes so that the printers can be
    //         enumerated.
    //
    if (!PrintEnumAndSelect( hDlg,
                             Id,
                             pPI,
                             (pPI->pCurPrinter)
                               ? pPI->pCurPrinter->pPrinterName
                               : NULL,
                             (!(pPI->Status & PI_PRINTERS_ENUMERATED)) ))
    {
        goto InitGeneral_ConstructFailure;
    }

    PrintUpdateStatus(hDlg, pPI);

    //
    //  See if the Help button should be hidden.
    //
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
#ifdef WINNT
            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
#endif
        }
    }

    return (TRUE);

InitGeneral_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPrintDlg
//
//  Initialize PRINT DLG-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    WORD wCheckID;
    HWND hCtl;


    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, MAX_COPIES);
    SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);

    if ( !(pPI->pPSD) &&
         (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES)) &&
         (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE) )
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hDlg,
                             IDC_COPIES_UDARROW,
                             g_hinst,
                             hCtl,
                             MAX_COPIES,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth(hDlg, hCtl);
    }

    if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
    {
        if (!GetStoredExtendedError())
        {
            StoreExtendedError(PDERR_INITFAILURE);
        }
        return (0xFFFFFFFF);
    }

#ifdef WINNT
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }
#endif

    if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_TOFILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hDlg, ID_PRINT_X_TOFILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  Some apps (marked 3.1) do not pass in valid ranges.
        //      (e.g. Corel Ventura)
        //
        if ((pPI->ProcessVersion < 0x40000) || (!(pPD->Flags & PD_PAGENUMS)))
        {
            if (pPD->nFromPage != 0xFFFF)
            {
                if (pPD->nFromPage < pPD->nMinPage)
                {
                    pPD->nFromPage = pPD->nMinPage;
                }
                else if (pPD->nFromPage > pPD->nMaxPage)
                {
                    pPD->nFromPage = pPD->nMaxPage;
                }
            }
            if (pPD->nToPage != 0xFFFF)
            {
                if (pPD->nToPage < pPD->nMinPage)
                {
                    pPD->nToPage = pPD->nMinPage;
                }
                else if (pPD->nToPage > pPD->nMaxPage)
                {
                    pPD->nToPage = pPD->nMaxPage;
                }
            }
        }

        if ( pPD->nMinPage > pPD->nMaxPage ||
             ( pPD->nFromPage != 0xFFFF &&
               ( pPD->nFromPage < pPD->nMinPage ||
                 pPD->nFromPage > pPD->nMaxPage ) ) ||
             ( pPD->nToPage != 0xFFFF &&
               ( pPD->nToPage < pPD->nMinPage ||
                 pPD->nToPage > pPD->nMaxPage ) ) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (0xFFFFFFFF);
        }

        if (pPD->nFromPage != 0xFFFF)
        {
            SetDlgItemInt(hDlg, ID_PRINT_E_FROM, pPD->nFromPage, FALSE);
            if (pPD->nToPage != 0xFFFF)
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_TO, pPD->nToPage, FALSE);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);
        }

        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

            //
            //  Don't allow disabled button checked.
            //
            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            pPI->Status &= ~PI_COLLATE_REQUESTED;
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), SW_HIDE);
        }
#ifndef WINNT
        //
        //  This is NOT desirable.  Most apps use a very high number for
        //  their max page, so it looks very strange.
        //
        else
        {
            TCHAR szAll[32];
            TCHAR szBuf[64];

            if (pPD->nMinPage != pPD->nMaxPage)
            {
                if (pPD->nMaxPage != 0xFFFF)
                {
                    if (CDLoadString(g_hinst, iszPrintRangeAll, szAll, 32))
                    {
                        wsprintf( szBuf,
                                  szAll,
                                  (DWORD)pPD->nMaxPage - (DWORD)pPD->nMinPage + 1 );
                        SetDlgItemText(hDlg, ID_PRINT_R_ALL, szBuf);
                    }
                    else
                    {
                        StoreExtendedError(CDERR_LOADSTRFAILURE);
                        return (0xFFFFFFFF);
                    }
                }
            }
        }
#endif
    }

    if (pPD->Flags & PD_NOSELECTION)
    {
        HWND hRad = GetDlgItem(hDlg, ID_PRINT_R_SELECTION);

        if (hRad)
        {
            EnableWindow(hRad, FALSE);
        }

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = ID_PRINT_R_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = ID_PRINT_R_SELECTION;
    }
    else
    {
        // PD_ALL
        wCheckID = ID_PRINT_R_ALL;
    }

    CheckRadioButton(hDlg, ID_PRINT_R_ALL, ID_PRINT_R_PAGES, (int)wCheckID);

    //
    //  Subclass the integer only edit controls.
    //
    if (!(pPI->pPSD))
    {
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_FROM))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_TO))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
    }

    if (pPD->lpfnPrintHook)
    {
        LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            DWORD dwHookRet;

            ThunkPrintDlgW2A(pPI);
            dwHookRet = (*lpfnPrintHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (LONG_PTR)pPI->pPDA ) != 0;
            if (dwHookRet)
            {
                ThunkPrintDlgA2W(pPI);
            }

            return (dwHookRet);
        }
        else
#endif
        {
            return ( (*lpfnPrintHook)( hDlg,
                                       WM_INITDIALOG,
                                       wParam,
                                       (LONG_PTR)pPD ) ) != 0;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitSetupDlg
//
//  Initialize SETUP-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM = NULL;
    HWND hCtl;
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    UINT Orientation;


    if (!pPD->hDevMode ||
        !(pDM = GlobalLock(pPD->hDevMode)))
    {
        StoreExtendedError(CDERR_MEMLOCKFAILURE);
        goto InitSetupDlg_ConstructFailure;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_PAPERNAMES,
                             CCHPAPERNAME,
                             DC_PAPERS );
    }

    //
    //  Provide backward compatibility for old-style-template sources
    //  ID_SETUP_C_SOURCE.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_BINNAMES,
                             CCHBINNAME,
                             DC_BINS );
    }

    //
    //  Set the edit field lengths and other setup stuff for margins.
    //  This must be called before PrintSetMargin, which is called in
    //  PrintSetOrientation.
    //
    PrintSetupMargins(hDlg, pPI);

    PrintInitOrientation(hDlg, pPI, pDM);
    Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
    PrintSetOrientation( hDlg,
                         pPI,
                         pDM,
                         Orientation,
                         Orientation );

    PrintInitDuplex(hDlg, pDM);
    PrintSetDuplex( hDlg,
                    pDM,
                    pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

    GlobalUnlock(pPD->hDevMode);

    if (pPSD)
    {
        if (pPSD->Flags & PSD_DISABLEORIENTATION)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPAPER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SOURCE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SOURCE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEMARGINS)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_LEFT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_LEFT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_RIGHT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_RIGHT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_TOP), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_TOP),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_BOTTOM), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_BOTTOM),  FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPRINTER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_P_PRINTER), FALSE );
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
    {
        lpStaticProc = (WNDPROC)SetWindowLongPtr( hCtl,
                                               GWLP_WNDPROC,
                                               (LONG_PTR)PrintPageSetupPaintProc );
    }

    if ((pPD->Flags & PD_NONETWORKBUTTON))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }
    else if (!(pPI->pPSD))
    {
#ifdef WINNT
        AddNetButton( hDlg,
                      ((pPD->Flags & PD_ENABLESETUPTEMPLATE)
                          ? pPD->hInstance : g_hinst),
                      FILE_BOTTOM_MARGIN,
                      (pPD->Flags & (PD_ENABLESETUPTEMPLATE |
                                     PD_ENABLESETUPTEMPLATEHANDLE))
                          ? FALSE : TRUE,
                      FALSE,
                      TRUE );
#endif
        //
        //  The button can be added in two ways -
        //      statically (they have it predefined in their template) and
        //      dynamically (successful call to AddNetButton).
        //
#ifdef WINNT
        if (!IsNetworkInstalled())
#else
        if (!GetSystemMetrics(SM_NETWORK))
#endif
        {
            hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }

#ifdef WINNT
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }
#endif

    //
    //  Provide backward compatibility for old-style-template radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        TCHAR szBuf[MAX_DEV_SECT];
        TCHAR szDefFormat[MAX_DEV_SECT];

        if (pPI->szDefaultPrinter[0])
        {
            if (!CDLoadString( g_hinst,
                             iszDefCurOn,
                             szDefFormat,
                             ARRAYSIZE(szDefFormat) ))
            {
                StoreExtendedError(CDERR_LOADSTRFAILURE);
                goto InitSetupDlg_ConstructFailure;
            }

            wnsprintf(szBuf, ARRAYSIZE(szBuf), szDefFormat, pPI->szDefaultPrinter);
        }
        else
        {
            szBuf[0] = CHAR_NULL;
            EnableWindow(hCtl, FALSE);
        }
        SetDlgItemText(hDlg, ID_SETUP_S_DEFAULT, szBuf);

        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }

    if (pPD->lpfnSetupHook)
    {
        DWORD dwHookRet;
        LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgW2A(pPI);
            TransferPDA2PSD(pPI);

            pPI->NestCtr++;
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPI->pPDA ) != 0;
            pPI->NestCtr--;

            if (dwHookRet)
            {
                TransferPSD2PDA(pPI);
                ThunkPrintDlgA2W(pPI);
                if (pPI->NestCtr == 0)
                {
                    TransferPD2PSD(pPI);
                }
            }
        }
        else
#endif
        {
            TransferPD2PSD(pPI);
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPD ) != 0;
            TransferPSD2PD(pPI);
        }


        return (dwHookRet);
    }

    return (TRUE);

InitSetupDlg_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateSetupDlg
//
//  Update the print setup and page setup dialogs with the new settings.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent)
{
    HWND hCtl;
    UINT Count;
    UINT Orientation = 0;


    //
    //  Update the Size combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_PAPERNAMES,
                                 CCHPAPERNAME,
                                 DC_PAPERS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmPaperSize == (SHORT)SendMessage( hCtl,
                                                            CB_GETITEMDATA,
                                                            Count,
                                                            0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Source combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_BINNAMES,
                                 CCHBINNAME,
                                 DC_BINS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmDefaultSource == (SHORT)SendMessage( hCtl,
                                                                CB_GETITEMDATA,
                                                                Count,
                                                                0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Orientation radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintSetOrientation( hDlg,
                             pPI,
                             pDM,
                             IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                 ? ID_SETUP_R_PORTRAIT
                                 : ID_SETUP_R_LANDSCAPE,
                             Orientation );
    }

    //
    //  Update the Duplex radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        PrintSetDuplex( hDlg,
                        pDM,
                        pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );
    }

    //
    //  Update the page setup sample picture.
    //
    if ((Orientation == 0) && (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintUpdatePageSetup( hDlg,
                              pPI,
                              pDM,
                              0,
                              Orientation );
    }

    //
    //  Update the Default/Specific Printer radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetCopies
//
//  Sets the appropriate number of copies in the PrintDlg structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    DWORD dwMaxCopies;
    DWORD dwCollate;
    BOOL bAllowCollate;


    if ( (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
#ifdef UNICODE
        //
        //  If we're coming from a WOW app, we need to only set
        //  the copies in the devmode if the PD_USEDEVMODECOPIES
        //  flag is set.
        //
        if (IS16BITWOWAPP(pPD))
        {
            if (pPD->Flags & PD_USEDEVMODECOPIES)
            {
                pDM->dmCopies = pPD->nCopies;
                pPD->nCopies = 1;
            }
            else
            {
                pDM->dmCopies = 1;
            }

            return (TRUE);
        }
#endif
        if ( (!(pDM->dmFields & DM_COPIES)) ||
             ((!(pPI->pPSD)) &&
              (pPI->ProcessVersion < 0x40000) &&
              (!(pPD->Flags & PD_USEDEVMODECOPIES))) )
        {
LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the
            //  copy/collate info in the pPD.
            //
            pDM->dmCopies = 1;
            SetField(pDM, dmCollate, DMCOLLATE_FALSE);
        }
        else if ( (pDM->dmSpecVersion < 0x0400) ||
                  (!(pDM->dmFields & DM_COLLATE)) )
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto LeaveInfoInPD;
            }
            else
            {
                goto PutInfoInDevMode;
            }
        }
        else
        {
PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pPI->pCurPrinter)
            {
                goto LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number
            //  of copies requested and collation.
            //
            dwMaxCopies = DeviceCapabilities(
                                     pPI->pCurPrinter->pPrinterName,
                                     pPI->pCurPrinter->pPortName,
                                     DC_COPIES,
                                     NULL,
                                     NULL );

            //
            // If DeviceCapabilities() returns error, set the copy number to 1
            //
            if ((dwMaxCopies < 1) || (dwMaxCopies == (DWORD)(-1)))
            {
                dwMaxCopies = 1;
            }
            if (dwMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIES)
                {
                    PrintEditError( hDlg,
                                    (Id == ID_PRINT_C_NAME)
                                        ? ID_PRINT_E_COPIES
                                        : ID_BOTH_P_PROPERTIES,
                                    iszTooManyCopies,
                                    dwMaxCopies );

                    GlobalUnlock(pPD->hDevMode);
                    return (FALSE);
                }

                goto LeaveInfoInPD;
            }

            dwCollate = DeviceCapabilities(
                                     pPI->pCurPrinter->pPrinterName,
                                     pPI->pCurPrinter->pPortName,
                                     DC_COLLATE,
                                     NULL,
                                     NULL );

            bAllowCollate = ((dwCollate < 1) || (dwCollate == (DWORD)-1)) ? FALSE : TRUE;

            //
            //  The driver can do both copies and collate,
            //  so move the info to the devmode.
            //
            pDM->dmCopies = pPD->nCopies;
            SetField( pDM,
                      dmCollate,
                      (bAllowCollate && (pPD->Flags & PD_COLLATE))
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }

        GlobalUnlock(pPD->hDevMode);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMinMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    HDC hDC;
    RECT rtMinMargin;


    if (!pPSD)
    {
        return;
    }

    if (pPSD->Flags & PSD_MINMARGINS)
    {
        //
        //  Convert passed in margins to 10th of MMs.
        //
        if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left / 10;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top / 10;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right / 10;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom / 10;
        }
        else           // PSD_INTHOUSANDTHSOFINCHES
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom * MMS_PER_INCH / 100;
        }
    }
    else
    {
        //
        //  Default to no minimum if we can't get the info.
        //
        pPI->RtMinMarginMMs.left   = 0;
        pPI->RtMinMarginMMs.top    = 0;
        pPI->RtMinMarginMMs.right  = 0;
        pPI->RtMinMarginMMs.bottom = 0;
        pPSD->rtMinMargin.left   = 0;
        pPSD->rtMinMargin.top    = 0;
        pPSD->rtMinMargin.right  = 0;
        pPSD->rtMinMargin.bottom = 0;

        //
        //  Calculate new min margins from driver.
        //
        if (hDC = CreateIC(NULL, pDM->dmDeviceName, NULL, pDM))
        {
            //
            //  These are in PIXELS.
            //
            int nPageWidth = GetDeviceCaps(hDC, PHYSICALWIDTH);
            int nPageHeight = GetDeviceCaps(hDC, PHYSICALHEIGHT);
            int nPrintWidth = GetDeviceCaps(hDC, HORZRES);
            int nPrintHeight = GetDeviceCaps(hDC, VERTRES);
            int nOffsetWidth = GetDeviceCaps(hDC, PHYSICALOFFSETX);
            int nOffsetHeight = GetDeviceCaps(hDC, PHYSICALOFFSETY);
            int nPerInchWidth = GetDeviceCaps(hDC, LOGPIXELSX);
            int nPerInchHeight = GetDeviceCaps(hDC, LOGPIXELSY);

            //
            //  Calculate min margins in PIXELS.
            //
            rtMinMargin.left   = nOffsetWidth;
            rtMinMargin.top    = nOffsetHeight;
            rtMinMargin.right  = nPageWidth - nPrintWidth - nOffsetWidth;
            rtMinMargin.bottom = nPageHeight - nPrintHeight - nOffsetHeight;

            //
            //  Convert to 10ths of MMs.
            //
            if (nPerInchWidth && nPerInchHeight)
            {
                pPI->RtMinMarginMMs.left   = rtMinMargin.left * MMS_PER_INCH / nPerInchWidth / 10;
                pPI->RtMinMarginMMs.top    = rtMinMargin.top * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.right  = rtMinMargin.right * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.bottom = rtMinMargin.bottom * MMS_PER_INCH / nPerInchHeight / 10;
            }

            if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
            {
                //
                //  Convert to 100ths of MMs.
                //
                pPSD->rtMinMargin.left   = pPI->RtMinMarginMMs.left / 10;
                pPSD->rtMinMargin.top    = pPI->RtMinMarginMMs.top / 10;
                pPSD->rtMinMargin.right  = pPI->RtMinMarginMMs.right / 10;
                pPSD->rtMinMargin.bottom = pPI->RtMinMarginMMs.bottom / 10;
            }
            else           // PSD_INTHOUSANDTHSOFINCHES
            {
                //
                //  Convert to 1000ths of inches.
                //
                if (nPerInchWidth && nPerInchHeight)
                {
                    pPSD->rtMinMargin.left   = rtMinMargin.left * 1000 / nPerInchWidth;
                    pPSD->rtMinMargin.top    = rtMinMargin.top * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.right  = rtMinMargin.right * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.bottom = rtMinMargin.bottom * 1000 / nPerInchHeight;
                }
            }

            DeleteDC(hDC);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szMars[32];
    TCHAR szText[16];
    int ids[4] = { ID_SETUP_E_LEFT,
                   ID_SETUP_E_TOP,
                   ID_SETUP_E_RIGHT,
                   ID_SETUP_E_BOTTOM };
    int i;
    HWND hEdt;


    //
    //  Margins are only available from the PageSetupDlg.
    //
    if (!(pPI->pPSD))
    {
        return;
    }

    for (i = 0; i < 4; i++)
    {
        if (hEdt = GetDlgItem(hDlg, ids[i]))
        {
            //
            //  "999999" is the maximum value.
            //
            SendMessage(hEdt, EM_LIMITTEXT, MARGIN_EDIT_SIZE, 0);

            lpEditMarginProc =
                (WNDPROC)SetWindowLongPtr( hEdt,
                                        GWLP_WNDPROC,
                                        (LONG_PTR)PrintEditMarginProc );

        }
    }

    if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SDECIMAL,
                        szText,
                        16 ))
    {
        cIntlDecimal = CHAR_DOT;
    }
    else
    {
        cIntlDecimal = szText[0];
    }

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            CDLoadString(g_hinst, iszMarginsMillimeters, szMars, 32);
            CDLoadString(g_hinst, iszMillimeters, cIntlMeasure, 5);

            break;
        }
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            CDLoadString(g_hinst, iszMarginsInches, szMars, 32);
            CDLoadString(g_hinst, iszInches, cIntlMeasure, 5);

            break;
        }
    }

    cchIntlMeasure = lstrlen(cIntlMeasure);

    SetWindowText(GetDlgItem(hDlg, ID_SETUP_G_MARGINS), szMars);
    pPI->PtMargins.x = 2 * (IS_KEY_PRESSED(pPI->PtMargins.x / 4) &&
                            IS_KEY_PRESSED(pPI->PtMargins.y / 4)
                                ? sizeof(WCHAR)
                                : sizeof(CHAR));
    pPI->PtMargins.y = 2 * pPI->PtMargins.x;
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue)
{
    HWND hEdt;
    TCHAR szText[32];
    TCHAR szILZero[2];
    LONG lFract;


    if (hEdt = GetDlgItem(hDlg, Id))
    {
        switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                    PSD_INHUNDREDTHSOFMILLIMETERS))
        {
            case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
            {
                lFract = lValue % 100;
                wsprintf( szText,
                          lFract ? TEXT("%lu%c%02lu") : TEXT("%lu"),
                          lValue / 100,
                          cIntlDecimal,
                          lFract );
                break;
            }
            case ( PSD_INTHOUSANDTHSOFINCHES ) :
            {
                lFract = lValue % 1000;
                wsprintf( szText,
                          lFract ? TEXT("%lu%c%03lu") : TEXT("%lu"),
                          lValue / 1000,
                          cIntlDecimal,
                          lFract );
                break;
            }
        }

        //
        //  Remove trailing zeros off of fraction.
        //
        if (lFract)
        {
            LPTSTR pStr = szText + lstrlen(szText) - 1;

            while (*pStr == TEXT('0'))
            {
                *pStr-- = TEXT('\0');
            }
        }

        //
        //  Determine if a leading zero is to be used and write the
        //  text to the edit window.
        //
        if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szILZero, 2))
        {
            szILZero[0] = TEXT('0');
        }
        SetWindowText( hEdt,
                       szText + (szText[0] == TEXT('0') &&
                                 szText[1] == cIntlDecimal &&
                                 szILZero[0] == TEXT('0')) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample)
{
    TCHAR szText[16];
    TCHAR *pText;
    TCHAR *pFrac;

    GetWindowText(hEdt, szText, ARRAYSIZE(szText));
    szText[ARRAYSIZE(szText)-1] = 0;

    *plMargin = ConvertStringToInteger(szText);

    for (pText = szText; *pText;)
    {
        if (*pText++ == cIntlDecimal)
        {
            break;
        }
    }

    for (pFrac = pText; *pFrac; pFrac++)
    {
        if (*pFrac == cIntlMeasure[0])
        {
            *pFrac = CHAR_NULL;
            break;
        }

        if (*pFrac == cIntlDecimal)
        {
            *pFrac = CHAR_NULL;
            break;
        }
    }

    StrCatBuff(szText, TEXT("000"), ARRAYSIZE(szText));

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            //
            //  In 1000ths of inches.
            //
            *plMargin *= 1000;
            pText[3] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin * MMS_PER_INCH / 1000;

            break;
        }
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            //
            //  In 100ths of MMs.
            //
            *plMargin *= 100 ;
            pText[2] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin / 10;

            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitBannerAndQuality
//
//  Reset PRINT DLG items dependent upon which printer was selected.
//  Assumes that pPD->hDevNames is non-NULL.  pPD->hDevMode non-NULL.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD)
{
    HWND hCtl;
    BOOL bResult = TRUE;
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    TCHAR szText[MAX_DEV_SECT];


    //
    //  ID_PRINT_S_DEFAULT is from one of the old templates.
    //
    if (GetDlgItem(hDlg, ID_PRINT_S_DEFAULT))
    {
        if (!pPD->hDevNames ||
            !(pDN = GlobalLock(pPD->hDevNames)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        if (PrintCreateBanner(hDlg, pDN, szText, MAX_DEV_SECT))
        {
            SetDlgItemText(hDlg, ID_PRINT_S_DEFAULT, szText);
        }
        else
        {
            //
            //  PrintCreateBanner sets the extended error.
            //
            bResult = FALSE;
        }

        GlobalUnlock(pPD->hDevNames);
    }

    //
    //  If the driver says it can do copies, pay attention to what the
    //  app requested.  If it cannot do copies, check & disable the
    //  checkbox.
    //
    if (pPD->hDevMode)
    {
        if (!(pDM = GlobalLock(pPD->hDevMode)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        //
        //  Enable print quality, if it exists.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, TRUE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, TRUE);

            PrintInitQuality( hCtl,
                              pDM->dmSpecVersion <= 0x0300 ? 0L : pPD,
                              pDM->dmPrintQuality );
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            if ( pDM->dmFields & DM_COLLATE ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                EnableWindow(hCtl, TRUE);
                CheckDlgButton( hDlg,
                                ID_PRINT_X_COLLATE,
                                (pPI->Status & PI_COLLATE_REQUESTED)
                                    ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hDlg, ID_PRINT_X_COLLATE, FALSE);
            }
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            if ( pDM->dmFields & DM_COPIES ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);
                EnableWindow(hCtl, TRUE);
            }
            else
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, 1, FALSE);
                EnableWindow(hCtl, FALSE);
            }
        }

        //
        //  Display the appropriate collate icon.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
        {
            SetWindowLong( hCtl,
                           GWL_STYLE,
                           GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
            ShowWindow(hCtl, SW_HIDE);
            SendMessage( hCtl,
                         STM_SETICON,
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                             ? (LONG_PTR)hIconCollate
                             : (LONG_PTR)hIconNoCollate,
                         0L );
            ShowWindow(hCtl, SW_SHOW);
        }

        GlobalUnlock(pPD->hDevMode);
    }
    else
    {
        //
        //  Disable the print quality, collate, and copies.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCreateBanner
//
//  Create "Printer: Prn on Port" or "Printer:  System Printer (Prn)".
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner)
{
    if (GetDlgItem(hDlg, ID_BOTH_S_PRINTER))
    {
        psBanner[0] = CHAR_NULL;
    }
    else if (!CDLoadString( g_hinst,
                          iszPrinter,
                          psBanner,
                          cchBanner ))
    {
        goto LoadStrFailure;
    }

    if (pDN->wDefault & DN_DEFAULTPRN)
    {
        TCHAR szSysPrn[MAX_DEV_SECT];

        if (!CDLoadString(g_hinst, iszSysPrn, szSysPrn, MAX_DEV_SECT))
        {
            goto LoadStrFailure;
        }
        StrCatBuff(psBanner, (LPTSTR)szSysPrn, cchBanner);
        StrCatBuff(psBanner, (LPTSTR)pDN + pDN->wDeviceOffset, cchBanner);
        StrCatBuff(psBanner, (LPTSTR)TEXT(")"), cchBanner);
    }
    else
    {
        TCHAR szPrnOnPort[64];

        if (!CDLoadString(g_hinst, iszPrnOnPort, szPrnOnPort, 64))
        {
            goto LoadStrFailure;
        }
        StrCatBuff(psBanner, (LPTSTR)pDN + pDN->wDeviceOffset, cchBanner);
        StrCatBuff(psBanner, (LPTSTR)szPrnOnPort, cchBanner);
        StrCatBuff(psBanner, (LPTSTR)pDN + pDN->wOutputOffset, cchBanner);
    }

    return (TRUE);

LoadStrFailure:

    StoreExtendedError(CDERR_LOADSTRFAILURE);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitQuality
//
//  Initializes the Printer Quality Combobox.
//
//  Assumes pPD structure filled by caller.  If non-NULL, it's a 3.1 or
//  later driver.  If NULL, fill with default for 3.0.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality)
{
    SHORT nStringID;
    SHORT i;
    TCHAR szBuf[64];
    LPDEVMODE  pDM = NULL;
    LPDEVNAMES pDN = NULL;


    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    //
    //  Enum print qualities.
    //
    if (pPD && pPD->hDevMode && pPD->hDevNames)
    {
        HANDLE hPrnQ;                  // Memory handle for print qualities
        DWORD dw;                      // return from DC_ENUMRESOLUTIONS
        LPLONG pLong;                  // Pointer to pairs of longs
        LPTSTR psDevice;
        LPTSTR psPort;

        pDM = GlobalLock(pPD->hDevMode);
        pDN = GlobalLock(pPD->hDevNames);

        if (pDM->dmSpecVersion < 0x030A)
        {
            goto EnumResNotSupported;
        }

        psDevice = (LPTSTR)pDN + pDN->wDeviceOffset;
        psPort   = (LPTSTR)pDN + pDN->wOutputOffset;

        dw = DeviceCapabilities( psDevice,
                                 psPort,
                                 DC_ENUMRESOLUTIONS,
                                 NULL,
                                 NULL );
        if (!dw || (dw == (DWORD)(-1)))
        {
            goto EnumResNotSupported;
        }

        hPrnQ = GlobalAlloc(GHND, dw * 2 * sizeof(LONG));
        if (!hPrnQ)
        {
            goto EnumResNotSupported;
        }

        if (pLong = GlobalLock(hPrnQ))
        {
            dw = DeviceCapabilities( psDevice,
                                     psPort,
                                     DC_ENUMRESOLUTIONS,
                                     (LPTSTR)pLong,
                                     0 );

            for (nStringID = 0, i = (SHORT)(LOWORD(dw) - 1); i >= 0; i--)
            {
                DWORD xRes, yRes;

                if ((xRes = pLong[i * 2]) != (yRes = pLong[i * 2 + 1]) )
                {
                    wsprintf(szBuf, TEXT("%ld dpi x %ld dpi"), xRes, yRes);
                }
                else
                {
                    wsprintf(szBuf, TEXT("%ld dpi"), yRes);
                }

                SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
                SendMessage(hCmb, CB_SETITEMDATA, 0, xRes);

                if ( ((SHORT)xRes == nQuality) &&
                     ( (wWinVer < 0x030A) ||
                       !pDM->dmYResolution ||
                       (pDM->dmYResolution == (SHORT)yRes) ) )
                {
                    nStringID = i;
                }
            }
            GlobalUnlock(hPrnQ);
        }
        GlobalFree(hPrnQ);

        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)nStringID, 0L);
    }
    else
    {
EnumResNotSupported:

        for ( i = -1, nStringID = iszDraftPrnQ;
              nStringID >= iszHighPrnQ;
              i--, nStringID-- )
        {
            if (!CDLoadString(g_hinst, nStringID, szBuf, 64))
            {
                return;
            }
            SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
            SendMessage(hCmb, CB_SETITEMDATA, 0, MAKELONG(i, 0));
        }

        if ((nQuality >= 0) || (nQuality < -4))
        {
            //
            //  Set to HIGH.
            //
            nQuality = -4;
        }
        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)(nQuality + 4), 0L);
    }

    if (pDM)
    {
        GlobalUnlock(pPD->hDevMode);
    }
    if (pDN)
    {
        GlobalUnlock(pPD->hDevNames);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintChangeProperties
//
//  Puts up the dialog to modify the properties.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    LONG cbNeeded;
    HANDLE hDevMode;
    WORD nCopies, nCollate;
    BOOL bTest;
    HWND hCtl;


    //
    //  There must be a devmode already.
    //
    if (!pPD->hDevMode)
    {
        return;
    }

    //
    //  Get the number of bytes needed for the devmode.
    //
    cbNeeded = DocumentProperties( hDlg,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );

    //
    //  Reallocate the devmode to be sure there is enough room in it, and
    //  then put up the document properties dialog box.
    //
    if ( (cbNeeded > 0) &&
         (hDevMode = GlobalReAlloc(pPD->hDevMode, cbNeeded, GHND)) &&
         (pDM = GlobalLock(hDevMode)) )
    {
        //
        //  This is done here to make sure that the ReAlloc succeeded
        //  before trashing the old hDevMode.
        //
        pPD->hDevMode = hDevMode;

        //
        //  Set the number of copies and collation in the devmode before
        //  calling DocumentProperties, if appropriate.
        //
        nCopies = pDM->dmCopies;
        nCollate = pDM->dmCollate;
        if (Id == ID_PRINT_C_NAME)
        {
            //
            //  Get the number of copies from the edit control.
            //
            pDM->dmCopies = (WORD)GetDlgItemInt( hDlg,
                                                 ID_PRINT_E_COPIES,
                                                 &bTest,
                                                 FALSE );
            if ((!bTest) || (!pDM->dmCopies))
            {
                pDM->dmCopies = nCopies;
            }

            //
            //  Get the collation from the check box.
            //
            if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                 IsWindowEnabled(hCtl) )
            {
                SetField( pDM,
                          dmCollate,
                          (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                              ? DMCOLLATE_TRUE
                              : DMCOLLATE_FALSE );
            }
        }
        else   // ID_SETUP_C_NAME
        {
            if ( (pDM->dmFields & DM_COPIES) &&
                 (pPI->ProcessVersion < 0x40000) &&
                 (!(pPD->Flags & PD_USEDEVMODECOPIES)) &&
                 (pPD->nCopies) )
            {
                pDM->dmCopies = pPD->nCopies;

                if (pDM->dmFields & DM_COLLATE)
                {
                    //
                    //  DM_COLLATE was specified, so dmCollate exists.
                    //
                    pDM->dmCollate = (pPD->Flags & PD_COLLATE)
                                         ? DMCOLLATE_TRUE
                                         : DMCOLLATE_FALSE;
                }
            }
        }

        //
        //  Put up the Document Properties dialog box.
        //
        if (DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                (pPI->pCurPrinter)
                                    ? pPI->pCurPrinter->pPrinterName
                                    : NULL,
                                pDM,
                                pDM,
                                DM_PROMPT | DM_MODIFY | DM_COPY ) == IDOK)
        {
            //
            //  Save the new number of copies and collation, if appropriate.
            //
            if (pDM->dmFields & DM_COPIES)
            {
                pPD->nCopies = pDM->dmCopies;
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                if (pDM->dmCollate == DMCOLLATE_FALSE)
                {
                    pPD->Flags  &= ~PD_COLLATE;
                    pPI->Status &= ~PI_COLLATE_REQUESTED;
                }
                else
                {
                    pPD->Flags  |= PD_COLLATE;
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            //
            //  Update the dialog.
            //
            if (Id == ID_PRINT_C_NAME)
            {
                //
                //  Update the print dialog with the new info.
                //
                PrintInitBannerAndQuality(hDlg, pPI, pPD);
            }
            else   // ID_SETUP_C_NAME
            {
                //
                //  Update the print setup dialog with the new info.
                //
                PrintUpdateSetupDlg(hDlg, pPI, pDM, FALSE);
            }
        }
        else
        {
            //
            //  Operation cancelled.  Restore the number of copies
            //  and the collation in the devmode.
            //
            pDM->dmCopies = nCopies;
            SetField(pDM, dmCollate, nCollate);
        }

        GlobalUnlock(pPD->hDevMode);

        SendMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, IDOK),
                     1L );
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintPrinterChanged
//
////////////////////////////////////////////////////////////////////////////

VOID PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HANDLE hDM = NULL;
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDMOld = NULL;
    HWND hCtl;
    UINT Orientation;
    LONG cbSize;
    DWORD dmSize;


    HourGlass(TRUE);

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Get the current printer from the combo box.
    //
    if (Id && (hCtl = GetDlgItem(hDlg, Id)))
    {
        TCHAR szPrinter[MAX_PRINTERNAME];
        DWORD ctr;

        SendMessage( hCtl,
                     CB_GETLBTEXT,
                     (WPARAM)SendMessage(hCtl, CB_GETCURSEL, 0, 0),
                     (LPARAM)(LPTSTR)szPrinter );

        pPI->pCurPrinter = NULL;
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, szPrinter))
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];
                break;
            }
        }
        if (!pPI->pCurPrinter)
        {
            HourGlass(FALSE);
            return;
        }
    }

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Build the device names.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the devmode information.
    //
    cbSize = DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 NULL,
                                 NULL,
                                 0 );
    if (cbSize > 0)
    {
        hDM = GlobalAlloc(GHND, cbSize);

        //
        //  Get the default DevMode for the new printer.
        //
        if (hDM && (pDM = GlobalLock(hDM)) &&
            (DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 pDM,
                                 NULL,
                                 DM_COPY ) == IDOK))
        {
            //
            //  See if we need to merge in old DevMode settings.
            //
            if (pPD->hDevMode && (pDMOld = GlobalLock(pPD->hDevMode)))
            {
                //
                //  Reset the PaperSource back to the Document Default.
                //
                if (pDM->dmFields & DM_DEFAULTSOURCE)
                {
                    pDMOld->dmFields |= DM_DEFAULTSOURCE;
                    pDMOld->dmDefaultSource = pDM->dmDefaultSource;
                }
                else
                {
                    pDMOld->dmFields &= ~DM_DEFAULTSOURCE;
                }

                //
                //  Copy relevant info from the old devmode to the new
                //  devmode.
                //
                dmSize = min(pDM->dmSize, pDMOld->dmSize);
                if (dmSize > FIELD_OFFSET(DEVMODE, dmFields))
                {
                    CopyMemory( &(pDM->dmFields),
                                &(pDMOld->dmFields),
                                dmSize - FIELD_OFFSET(DEVMODE, dmFields) );
                }

                //
                //  Free the old devmode.
                //
                GlobalUnlock(pPD->hDevMode);
                GlobalFree(pPD->hDevMode);
            }

            //
            //  Save the new DevMode in the pPD structure.
            //
            pPD->hDevMode = hDM;

            //
            //  Get the newly merged DevMode.
            //
            pDM->dmFields = pDM->dmFields & (DM_ORIENTATION | DM_PAPERSIZE  |
                                             DM_PAPERLENGTH | DM_PAPERWIDTH |
                                             DM_SCALE       | DM_COPIES     |
                                             DM_COLLATE     | DM_FORMNAME   |
                                             DM_DEFAULTSOURCE);
            DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                pPI->pCurPrinter->pPrinterName,
                                pDM,
                                pDM,
                                DM_MODIFY | DM_COPY );
            GlobalUnlock(hDM);
        }
        else if (hDM)
        {
            if (pDM)
            {
                GlobalUnlock(hDM);
            }
            GlobalFree(hDM);
        }
    }

    //
    //  Fill in the appropriate information for the rest of the
    //  Print or Print Setup dialog box.
    //
    if (Id == ID_PRINT_C_NAME)
    {
        PrintInitBannerAndQuality(hDlg, pPI, pPD);
    }
    else   // ID_SETUP_C_NAME
    {
        if (pPD->hDevMode && (pDM = GlobalLock(pPD->hDevMode)))
        {
            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_PAPERNAMES,
                                     CCHPAPERNAME,
                                     DC_PAPERS );
            }

            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_BINNAMES,
                                     CCHBINNAME,
                                     DC_BINS );
            }

            PrintInitOrientation(hDlg, pPI, pDM);
            Orientation = (pDM->dmOrientation == DMORIENT_PORTRAIT)
                              ? ID_SETUP_R_PORTRAIT
                              : ID_SETUP_R_LANDSCAPE;
            PrintSetOrientation(hDlg, pPI, pDM, Orientation, Orientation);

            PrintInitDuplex(hDlg, pDM);
            PrintSetDuplex( hDlg,
                            pDM,
                            pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

            GlobalUnlock(pPD->hDevMode);
        }
    }

    //
    //  Update the status information.
    //
    PrintUpdateStatus(hDlg, pPI);

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCancelPrinterChanged
//
//  Opens the old printer since the user hit cancel.  The devmode and
//  devnames structures have already been set back to the old ones.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    LPPRINTDLG pPD = pPI->pPD;
    PPRINTER_INFO_2 pCurPrinter;


    //
    //  Make sure we have a previous printer and a devmode.
    //
    if ((pPrinterName[0] == 0) || (!pPD->hDevMode))
    {
        return;
    }

    //
    //  Turn on the hour glass.
    //
    HourGlass(TRUE);

    //
    //  Find the current printer in the list.
    //
    pCurPrinter = PrintSearchForPrinter(pPI, pPrinterName);
    if (!pCurPrinter)
    {
        HourGlass(FALSE);
        return;
    }

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Save the current printer.
    //
    pPI->pCurPrinter = pCurPrinter;

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Turn off the hour glass.
    //
    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateStatus
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szSeparator[] = TEXT("; ");
    TCHAR szText[256];
    TCHAR szJobs[64];
    LPDEVMODE pDM;
    UINT Length;
    DWORD dwStatus;
    int ctr;
    TCHAR *ps;
    BOOL bFound;


    //
    //  Update the printer status information in the dialog.
    //
    if (!GetDlgItem(hDlg, ID_BOTH_S_STATUS) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  ----------------------  Update Status  ----------------------
    //
    szText[0] = CHAR_NULL;

    if (pPI->pCurPrinter->Attributes & PRINTER_ATTRIBUTE_DEFAULT)
    {
        CDLoadString(g_hinst, iszStatusDefaultPrinter, szText, 32);
    }

    Length = lstrlen(szText);
    dwStatus = pPI->pCurPrinter->Status;
    for (ctr = 0; ctr++ < 32; dwStatus = dwStatus >> 1)
    {
        if (dwStatus & 1)
        {
            CDLoadString( g_hinst,
                        iszStatusReady + ctr,
                        szText + lstrlen(szText),
                        32);
        }
    }

    if (szText[Length])
    {
        if (CDLoadString(g_hinst, iszStatusDocumentsWaiting, szJobs, 64))
        {
            wsprintf( szText + lstrlen(szText),
                      szJobs,
                      pPI->pCurPrinter->cJobs );
        }
    }
    else
    {
        CDLoadString(g_hinst, iszStatusReady, szText + Length, 32);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_STATUS, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_STATUS));

    //
    //  ----------------------  Update Type  ----------------------
    //
    if (pPI->pCurPrinter->pDriverName)
    {
        lstrcpy(szText, pPI->pCurPrinter->pDriverName);
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    if (pPI->pPD->hDevMode && (pDM = GlobalLock(pPI->pPD->hDevMode)))
    {
        if (pDM->dmSpecVersion < 0x0400)
        {
            lstrcat(szText, TEXT(" (3.x)"));  // old driver designation
        }
        GlobalUnlock(pPI->pPD->hDevMode);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_TYPE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_TYPE));

    //
    //  ----------------------  Update Location  ----------------------
    //
    if (pPI->pCurPrinter->pLocation && pPI->pCurPrinter->pLocation[0])
    {
        bFound = FALSE;
        lstrcpy(szText, pPI->pCurPrinter->pLocation);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            goto ShowPortName;
        }
    }
    else
    {
ShowPortName:
        if (pPI->pCurPrinter->pPortName)
        {
            lstrcpy(szText, pPI->pCurPrinter->pPortName);
        }
        else
        {
            szText[0] = CHAR_NULL;
        }
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_WHERE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE));

    //
    //  ----------------------  Update Comment  ----------------------
    //
    if (pPI->pCurPrinter->pComment && pPI->pCurPrinter->pComment[0])
    {
        bFound = FALSE;
        lstrcpy(szText, pPI->pCurPrinter->pComment);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            //
            //  This is needed in case the comment field only has a
            //  carriage return in it.  Without this check, it will
            //  show a ";" in the comment field.  In this case, it
            //  should show "" in the comment field.
            //
            szText[0] = CHAR_NULL;
        }
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_COMMENT, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT));
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetSetupInfo
//
//  Purpose:  Retrieve info from Print Setup dialog elements
//  Assumes:  hDevMode handle to valid DEVMODE structure
//  Returns:  TRUE if hDevMode valid, FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD)
{
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    HWND hCmb;
    int nInd;


    if ( !pPD->hDevMode ||
         !(pDM = GlobalLock(pPD->hDevMode)) )
    {
        return (FALSE);
    }

    // Don't need to do this - this is kept up to date.
    // pDM->dmFields |= DM_ORIENTATION;

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0, 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_PAPERSIZE;
            pDM->dmPaperSize = (SHORT)SendMessage( hCmb,
                                                   CB_GETITEMDATA,
                                                   nInd,
                                                   0 );
#ifndef WINNT
            if (pDM->dmSpecVersion >= 0x0400)
#endif
            {
            //  pDM->dmFields |= DM_FORMNAME;
                SendMessage( hCmb,
                             CB_GETLBTEXT,
                             nInd,
                             (LPARAM)pDM->dmFormName );
            }
        }
    }

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0 , 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_DEFAULTSOURCE;
            pDM->dmDefaultSource = (SHORT)SendMessage( hCmb,
                                                       CB_GETITEMDATA,
                                                       nInd,
                                                       0 );
        }
    }

    if ( (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintReturnICDC(pPD, pDN, pDM);
        GlobalUnlock(pPD->hDevNames);
    }

    GlobalUnlock(pPD->hDevMode);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSearchForPrinter
//
//  Returns the pointer to the PRINTER_INFO_2 structure for the printer
//  with the name pPrinterName.
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName)
{
    DWORD ctr;

    //
    //  Search for the printer.
    //
    for (ctr = 0; ctr < pPI->cPrinters; ctr++)
    {
        if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, lpsPrinterName))
        {
            //
            //  Found it.
            //
            return (&pPI->pPrinters[ctr]);
        }
    }

    //
    //  Did not find the printer.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetExtDeviceMode
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

VOID PrintGetExtDeviceMode(
    HWND hDlg,
    PPRINTINFO pPI)
{
    DWORD ctr;
    LPDEVMODEA pDMA;
    LPDEVMODEW pDMW;
    int iResult;
    CHAR szPrinterNameA[MAX_PRINTERNAME];


    if (!pPI->bUseExtDeviceMode)
    {
        return;
    }

    //
    //  Allocate the array to hold whether or not a new devmode has been
    //  allocated for each of the printers.
    //
    //  This is necessary because if the call to ExtDeviceMode fails, then
    //  nothing was allocated.  The one that is currently in the pPrinters
    //  array is actually part of the big pPrinters array (from the call
    //  to GetPrinter - it wants one giant buffer).
    //
    if (pPI->cPrinters)
    {
        if (pPI->pAllocInfo)
        {
            GlobalFree(pPI->pAllocInfo);
        }
        pPI->pAllocInfo = (LPBOOL)GlobalAlloc( GPTR,
                                               pPI->cPrinters * sizeof(BOOL) );
    }

    if (pPI->pAllocInfo)
    {
        //
        //  If we were called from a WOW app with a NULL devmode,
        //  then call ExtDeviceMode to get a default devmode.
        //
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            //
            //  Convert the printer name from Unicode to ANSI.
            //
            SHUnicodeToAnsi(pPI->pPrinters[ctr].pPrinterName, szPrinterNameA, ARRAYSIZE(szPrinterNameA));

            //
            //  Call ExtDeviceMode with 0 flags to find out the
            //  size of the devmode structure we need.
            //
            iResult = ExtDeviceMode( hDlg,
                                     NULL,
                                     NULL,
                                     szPrinterNameA,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0 );
            if (iResult < 0)
            {
                continue;
            }

            //
            //  Allocate the space.
            //
            pDMA = GlobalAlloc(GPTR, iResult);
            if (!pDMA)
            {
                continue;
            }

            //
            //  Call ExtDeviceMode to get the dummy devmode structure.
            //
            iResult = ExtDeviceMode( hDlg,
                                     NULL,
                                     pDMA,
                                     szPrinterNameA,
                                     NULL,
                                     NULL,
                                     NULL,
                                     DM_COPY );
            if (iResult < 0)
            {
                GlobalFree(pDMA);
                continue;
            }

            //
            //  Call AllocateUnicodeDevMode to allocate and copy the unicode
            //  version of this ANSI dev mode.
            //
            pDMW = AllocateUnicodeDevMode(pDMA);
            if (!pDMW)
            {
                GlobalFree(pDMA);
                continue;
            }

            //
            //  Store the pointer to the new devmode in the old pointer
            //  position.  We don't have to worry about freeing the
            //  current contents of pPrinter[ctr].pDevMode before sticking
            //  in the new pointer because in reality the pPrinter memory
            //  buffer is just one long allocation (the memory pDevmode
            //  points to is part of the pPrinters buffer).  So, when the
            //  buffer is freed at the end, the old devmode will be freed
            //  with it.
            //
            pPI->pPrinters[ctr].pDevMode = pDMW;
            pPI->pAllocInfo[ctr] = TRUE;

            //
            //  Free the ANSI dev mode.
            //
            GlobalFree(pDMA);
        }
    }
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintEnumAndSelect
//
//  This routine enumerates the LOCAL and CONNECTED printers.
//  It is called at initialization and when a new printer is
//  added via the NETWORK... button.
//
//  If the second parameter is set, the first parameter is overridden.
//  When the second parameter is NULL, the first parameter is used.
//  In this case, if the first parameter is greater than the total
//  number of printers enumerated, then the last one in the list is
//  selected.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters)
{
    HWND hCtl = ((hDlg && Id) ? GetDlgItem(hDlg, Id) : 0);
    LPPRINTDLG pPD = pPI->pPD;
    TCHAR szPrinter[MAX_PRINTERNAME];
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD ctr;
    PPRINTER_INFO_2 pPrinters = NULL;


    //
    //  Enumerate the printers, if necessary.
    //
    if (bEnumPrinters)
    {
Print_Enumerate:
        //
        //  Save lpsPrinterToSelect in a local before it gets freed.
        //
        if (lpsPrinterToSelect)
        {
            lstrcpyn(szPrinter, lpsPrinterToSelect, ARRAYSIZE(szPrinter));
            lpsPrinterToSelect = szPrinter;
        }

        //
        //  Close and free any open printers.
        //
        PrintClosePrinters(pPI);

        //
        //  Clear out the error code.
        //
        StoreExtendedError(CDERR_GENERALCODES);

        //
        //  Enumerate the printers.
        //
        if (!EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                           NULL,
                           2,
                           NULL,
                           0,
                           &cbNeeded,
                           &cReturned ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (pPrinters = GlobalAlloc(GPTR, cbNeeded))
                {
                    if (EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                                      NULL,
                                      2,
                                      (LPBYTE)pPrinters,
                                      cbNeeded,
                                      &cbNeeded,
                                      &cReturned ))
                    {
                        pPI->cPrinters = cReturned;
                        pPI->pPrinters =  pPrinters;
                        pPI->Status |= PI_PRINTERS_ENUMERATED;
                    }
                    else
                    {
                        StoreExtendedError(PDERR_NODEFAULTPRN);
                    }
                }
                else
                {
                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                }
            }
            else
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
            }
        }
        else
        {
            StoreExtendedError(PDERR_NODEFAULTPRN);
        }

        if (GetStoredExtendedError())
        {
            if (pPrinters)
            {
                GlobalFree(pPrinters);
            }
            return (FALSE);
        }

        //
        //  Make modifications for a WOW app.
        //
#ifdef UNICODE
        if (pPI->bUseExtDeviceMode)
        {
            PrintGetExtDeviceMode(hDlg, pPI);
        }
#endif

        //
        //  Try the selected printer.
        //
        if (lpsPrinterToSelect)
        {
            pPI->pCurPrinter = PrintSearchForPrinter(pPI, lpsPrinterToSelect);
        }

        //
        //  Open the current printer.
        //
        if (pPI->pCurPrinter)
        {
            //
            //  Open the current printer.
            //
            OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);
        }
        else
        {
            //
            //  If there isn't a current printer, try the printers in
            //  the list until either one is found that can be opened or
            //  until there are no more printers in the list.
            //
            for (ctr = 0; ctr < pPI->cPrinters; ctr++)
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];

                //
                //  Try to open the printer.
                //
                if (OpenPrinter( pPI->pCurPrinter->pPrinterName,
                                 &pPI->hCurPrinter,
                                 NULL ))
                {
                    break;
                }
            }
        }
    }
    else
    {
        //
        //  If there isn't a current printer, then try to enumerate.
        //  This means something isn't setup properly.
        //
        if ((!pPI->pCurPrinter) || (!pPI->pPrinters))
        {
            goto Print_Enumerate;
        }
    }

    if (hCtl)
    {
        //
        //  Reset the contents of the list box.
        //
        SendMessage(hCtl, CB_RESETCONTENT, 0, 0);

        //
        //  Add all of the printer name strings to the list box.
        //
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            SendMessage( hCtl,
                         CB_ADDSTRING,
                         0,
                         (LPARAM)pPI->pPrinters[ctr].pPrinterName );
        }

        //
        //  Set the current selection in the list box.
        //
        SendMessage( hCtl,
                     CB_SETCURSEL,
                     SendMessage( hCtl,
                                  CB_FINDSTRINGEXACT,
                                  (WPARAM)-1,
                                  (LPARAM)pPI->pCurPrinter->pPrinterName ),
                     0L );
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintBuildDevNames
//
////////////////////////////////////////////////////////////////////////////

VOID PrintBuildDevNames(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPTSTR pPrinterName = NULL;
    LPTSTR pPortName = NULL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szPort[MAX_PATH];
    LPTSTR pStr;
    LPDEVNAMES pDN;
    DWORD cbDevNames;
    HANDLE hPrinter ;
    PPRINTER_INFO_2 pPrinter = NULL;


    //
    //  If this is called from PrintReturnDefault, there is no
    //  PrinterInfo (pPI->pCurPrinter) because the printers were not
    //  enumerated.  So, build the DEVNAME from win.ini.
    //
    pStr = szBuffer;
    if (!pPI->pCurPrinter)
    {
        //
        //  Get the default printer from the "Windows" section of win.ini.
        //      (eg. device=\\server\local,winspool,Ne00:)
        //
        if ( (pPD->Flags & PD_RETURNDEFAULT) &&
             GetProfileString( szTextWindows,
                               szTextDevice,
                               szTextNull,
                               szBuffer,
                               MAX_PATH ) )
        {
            //  Examples of szBuffer:
            //    "My Local Printer,winspool,LPT1:"   or
            //    "\\server\local,winspool,Ne00:"

            //
            //  Skip leading space (if any).
            //
            while (*pStr == CHAR_SPACE)
            {
                pStr++;
            }

            //
            //  First token is the printer name.
            //
            pPrinterName = pStr;

            while (*pStr && *pStr != CHAR_COMMA)
            {
                pStr++;
            }

            //
            //  NULL terminate the printer name.
            //
            *pStr++ = CHAR_NULL;

            // For Newer Apps  return the port name from the PRINT_INFO_2 structure.
            // For older apps  return the short port name give in the win.ini
            if (pPI->ProcessVersion >= 0x40000)
            {
                //Newer App
                if (OpenPrinter(pPrinterName, &hPrinter, NULL))
                {
                    if (pPrinter = PrintGetPrinterInfo2(hPrinter))
                    {
                        lstrcpy(szPort, pPrinter->pPortName);
                        pPortName = szPort;
                        GlobalFree(pPrinter);
                    }
                    ClosePrinter(hPrinter);

                 }
                 else
                 {
                     //Unable to Open Printer so return
                     return ;
                 }
            }
            else
            {

                //Old App

                //
                //  Skip the driver name (second token).
                //
                while (*pStr && *pStr++ != CHAR_COMMA)
                {
                    ;
                }

                //
                //  Skip leading space (if any).
                //
                while (*pStr == CHAR_SPACE)
                {
                    pStr++;
                }

                //
                //  Third (and last) token is the port name.
                //
                pPortName = pStr;
            }
        }
        else
        {
            return;
        }
    }
    else
    {
        //
        //  Get the printer name from the PrinterInfo2 structure
        //  for the current printer.
        //
        pPrinterName = pPI->pCurPrinter->pPrinterName;

        //
        //  Newer Apps:
        //    Get the port name from the PrinterInfo2 structure for the
        //    current printer.  Want to use the PrinterInfo2 structure
        //    for newer apps so that we can support multiple ports for
        //    one printer.
        //
        //  Older Apps:
        //    First try to get the port name from the "devices" section
        //    of win.ini.  If that fails, then use the PrinterInfo2
        //    structure for the current printer.
        //
        //    This needs to use the "devices" section first due to a bug
        //    in AutoCAD.  AutoCAD only allows 13 characters for the port
        //    name and it does not check the length when it tries to copy
        //    it to its own buffer.
        //
#ifdef WINNT
        if ( (pPI->ProcessVersion >= 0x40000) ||
             (!GetProfileString( szTextDevices,
                                 pPrinterName,
                                 szTextNull,
                                 szBuffer,
                                 MAX_PATH )) ||
             (!(pPortName = StrChr(szBuffer, CHAR_COMMA))) ||
             (!((++pPortName)[0])) )
#endif
        {
            //
            //  Get the port name from the PrinterInfo2 structure
            //  for the current printer.
            //
            pPortName = pPI->pCurPrinter->pPortName;
        }
    }

    //
    //  Compute the size of the DevNames structure.
    //
    cbDevNames = lstrlen(szDriver) + 1 +
                 lstrlen(pPortName) + 1 +
                 lstrlen(pPrinterName) + 1 +
                 DN_PADDINGCHARS;

    cbDevNames *= sizeof(TCHAR);
    cbDevNames += sizeof(DEVNAMES);

    //
    //  Allocate the new DevNames structure.
    //
    pDN = NULL;
    if (pPD->hDevNames)
    {
        HANDLE handle;

        handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

        //Make sure the Realloc succeeded.
        if (handle)
        {
            pPD->hDevNames = handle;
        }
        else
        {
            //Realloc didn't succeed.  Free the old the memory
            pPD->hDevNames = GlobalFree(pPD->hDevNames);
        }
    }
    else
    {
        pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
    }

    //
    //  Fill in the DevNames structure with the appropriate information.
    //
    if ( (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
        lstrcpy((LPTSTR)pDN + pDN->wDriverOffset, szDriver);

        pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wDeviceOffset, pPrinterName);

        pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pPrinterName) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, pPortName);

        if ( (pPD->Flags & PD_RETURNDEFAULT) ||
             !lstrcmp(pPrinterName, pPI->szDefaultPrinter) )
        {
            pDN->wDefault = DN_DEFAULTPRN;
        }
        else
        {
            pDN->wDefault = 0;
        }

        GlobalUnlock(pPD->hDevNames);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDevMode
//
//  Create and/or fill DEVMODE structure.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode)
{
    LONG cbNeeded;
    LPDEVMODE pDM;


    cbNeeded = DocumentProperties( hDlg,
                                   hPrinter,
                                   lpsDeviceName,
                                   (PDEVMODE)NULL,
                                   (PDEVMODE)NULL,
                                   0 );

    if (cbNeeded > 0)
    {
        if (hDevMode)
        {
            HANDLE h = GlobalReAlloc(hDevMode, cbNeeded, GHND);

            //Make sure realloc succeeded.
            if (h)
            {
                hDevMode  = h;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                GlobalFree(hDevMode);
                hDevMode = NULL;
            }

        }
        else
        {
            hDevMode = GlobalAlloc(GHND, cbNeeded);
        }

        if (hDevMode && (pDM = GlobalLock(hDevMode)))
        {
            if (DocumentProperties( hDlg,
                                    hPrinter,
                                    lpsDeviceName,
                                    pDM,
                                    NULL,
                                    DM_COPY ) != IDOK)
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
                GlobalUnlock(hDevMode);
                GlobalFree(hDevMode);
                return (NULL);
            }

            GlobalUnlock(hDevMode);
        }
        else
        {
            if (hDevMode)
            {
                StoreExtendedError(CDERR_MEMLOCKFAILURE);
                GlobalFree(hDevMode);
            }
            else
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
            }
            return (NULL);
        }
    }
    else
    {
        DWORD dwErrCode;

        hDevMode = NULL;
        dwErrCode = GetLastError();

        if ( (dwErrCode == ERROR_UNKNOWN_PRINTER_DRIVER) ||
             (dwErrCode == ERROR_MOD_NOT_FOUND) )
        {
            if (hDlg)
            {
                PrintEditError(hDlg, 0, iszUnknownDriver, lpsDeviceName);
            }
        }
    }

    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnICDC
//
//  Retrieve either the hDC or the hIC if either flag is set.
//  Assumes the PD_PRINTOFILE flag is appropriately set.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM)
{
    if (pPD->Flags & PD_PRINTTOFILE)
    {
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, szFilePort);
    }

#ifdef UNICODE
    //
    //  The dmCollate field wasn't part of the Win3.1 DevMode struct.  The way
    //  16-bit apps achieved collation was by checking the PD_COLLATE flag in
    //  the PrintDlg struct.  The app would then figure out the page printing
    //  order to achieve collation.  So what we're doing here is making sure
    //  that PD_COLLATE is the only collation mechanism for 16-bit apps.  If we
    //  let DM_COLLATE get into the DC we'd end up with the driver trying to
    //  collate a job that the app is already trying to collate!
    //
    if ((pPD->Flags & CD_WOWAPP) && pDM)
    {
        if (pDM->dmFields & DM_COLLATE)
        {
            pPD->Flags |= PD_COLLATE;
        }

        // these should always be off for WOW apps
        pDM->dmCollate = DMCOLLATE_FALSE;
        pDM->dmFields &= ~DM_COLLATE;
    }
#endif

    switch (pPD->Flags & (PD_RETURNDC | PD_RETURNIC))
    {
        case ( PD_RETURNIC ) :
        {
            pPD->hDC = CreateIC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM);
            if (pPD->hDC)
            {
                break;
            }

            // else fall thru...
        }
        case ( PD_RETURNDC ) :
        case ( PD_RETURNDC | PD_RETURNIC ) :
        {
            //
            //  PD_RETURNDC has priority if they are both set.
            //
            pPD->hDC = CreateDC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM );
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintMeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    HDC hDC;
    TEXTMETRIC TM;
    HANDLE hFont;


    if (hDC = GetDC(hDlg))
    {
        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        mis->itemHeight = (WORD)TM.tmHeight;
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitOrientation
//
//  Enable/Disable Paper Orientation controls
//
//  NOTE: If the driver doesn't support orientation AND is smart
//  enough to tell us about it, disable the appropriate dialog items.
//  "Smart enough" means the driver must support DC_ORIENTATION in its
//  DeviceCapabilities routine.  This was introduced for 3.1, hence the
//  version test.  NotBadDriver() may need to be incorporated if a
//  problem driver is found in testing.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    BOOL bEnable = TRUE;
    HWND hCtl;
    HDC hDC;
    int iHeight;
    PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;


    if (!pPrinter)
    {
        return;
    }

    if (pDM->dmSpecVersion >= 0x030A)
    {
        pPI->dwRotation = DeviceCapabilities( pPrinter->pPrinterName,
                                              pPrinter->pPortName,
                                              DC_ORIENTATION,
                                              NULL,
                                              pDM );
        switch (pPI->dwRotation)
        {
            case ( ROTATE_LEFT ) :
            case ( ROTATE_RIGHT ) :
            {
                bEnable = TRUE;
                break;
            }
            default :
            {
                pPI->dwRotation = 0;
                bEnable = FALSE;
                pDM->dmOrientation = DMORIENT_PORTRAIT;
                CheckRadioButton( hDlg,
                                  ID_SETUP_R_PORTRAIT,
                                  ID_SETUP_R_LANDSCAPE,
                                  ID_SETUP_R_PORTRAIT );
                break;
            }
        }
    }

    if ( (pDM->dmOrientation != DMORIENT_PORTRAIT) &&
         (pDM->dmOrientation != DMORIENT_LANDSCAPE) )
    {
        pDM->dmOrientation  = DMORIENT_PORTRAIT;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE))
    {
        //
        //  Landscape
        //
        if ( !( (pPI->pPSD) &&
                (pPI->pPSD->Flags & PSD_DISABLEORIENTATION) ) )
        {
            EnableWindow(hCtl, bEnable);
        }
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        //
        //  Orientation of icon.
        //
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    if ( (!pPI->RtSampleXYWH.left) &&
         (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) )
    {
        GetWindowRect(hCtl, (LPRECT)&pPI->RtSampleXYWH);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.left);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.right);

        iHeight = pPI->RtSampleXYWH.bottom - pPI->RtSampleXYWH.top;
        pPI->RtSampleXYWH.bottom = iHeight;

        if (hDC = GetDC(0))
        {
            iHeight = iHeight * GetDeviceCaps(hDC, LOGPIXELSX) /
                                GetDeviceCaps(hDC, LOGPIXELSY);
            ReleaseDC(0, hDC);
        }

        pPI->RtSampleXYWH.left =
            (pPI->RtSampleXYWH.left + pPI->RtSampleXYWH.right - iHeight) / 2;
        pPI->RtSampleXYWH.right = iHeight;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetOrientation
//
//  Switch icon, check button, for Portrait or LandScape printing mode.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait;
    HWND hIcn;


    bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);

    pDM->dmOrientation = ( bPortrait
                               ? DMORIENT_PORTRAIT
                               : DMORIENT_LANDSCAPE );

    CheckRadioButton(hDlg, ID_SETUP_R_PORTRAIT, ID_SETUP_R_LANDSCAPE, uiNewId);

    if (hIcn = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        ShowWindow(hIcn, SW_HIDE);
        SendMessage( hIcn,
                     STM_SETICON,
                     bPortrait ? (LONG_PTR)hIconPortrait : (LONG_PTR)hIconLandscape,
                     0L );
        ShowWindow(hIcn, SW_SHOW);
    }

    //
    //  Update the page setup dialog, if necessary.
    //
    if (pPI->pPSD)
    {
        PrintUpdatePageSetup(hDlg, pPI, pDM, uiOldId, uiNewId);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdatePageSetup
//
//  Update the page setup information.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    LPPRINTDLG pPD = pPI->pPD;
    HWND hWndSample;
    HWND hWndShadowRight;
    HWND hWndShadowBottom;
    HWND hWndSize;
    LONG lTemp;


    if (!pPSD)
    {
        return;
    }

    if (uiOldId != uiNewId)
    {
        RECT aRtMinMargin = pPSD->rtMinMargin;
        RECT aRtMargin    = pPSD->rtMargin;
        HWND hWndLeft     = GetDlgItem(hDlg, ID_SETUP_E_LEFT);
        HWND hWndTop      = GetDlgItem(hDlg, ID_SETUP_E_TOP);
        HWND hWndRight    = GetDlgItem(hDlg, ID_SETUP_E_RIGHT);
        HWND hWndBottom   = GetDlgItem(hDlg, ID_SETUP_E_BOTTOM);
        TCHAR szLeft  [8];
        TCHAR szTop   [8];
        TCHAR szRight [8];
        TCHAR szBottom[8];

        GetWindowText(hWndLeft, szLeft, 8);
        GetWindowText(hWndTop, szTop, 8);
        GetWindowText(hWndRight, szRight, 8);
        GetWindowText(hWndBottom, szBottom, 8);

        switch (uiNewId + pPI->dwRotation)
        {
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_RIGHT ) :  // HP PCL
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_LEFT ) :   // dot-matrix
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.top;
                pPSD->rtMinMargin.top    = aRtMinMargin.right;
                pPSD->rtMinMargin.right  = aRtMinMargin.bottom;
                pPSD->rtMinMargin.bottom = aRtMinMargin.left;

                pPSD->rtMargin.left   = aRtMargin.top;
                pPSD->rtMargin.top    = aRtMargin.right;
                pPSD->rtMargin.right  = aRtMargin.bottom;
                pPSD->rtMargin.bottom = aRtMargin.left;

                SetWindowText(hWndLeft, szTop);
                SetWindowText(hWndRight, szBottom);
                SetWindowText(hWndTop, szRight);
                SetWindowText(hWndBottom, szLeft);

                break;
            }
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_LEFT ) :   // dot-matrix
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_RIGHT ) :  // HP PCL
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.bottom;
                pPSD->rtMinMargin.top    = aRtMinMargin.left;
                pPSD->rtMinMargin.right  = aRtMinMargin.top;
                pPSD->rtMinMargin.bottom = aRtMinMargin.right;

                pPSD->rtMargin.left   = aRtMargin.bottom;
                pPSD->rtMargin.top    = aRtMargin.left;
                pPSD->rtMargin.right  = aRtMargin.top;
                pPSD->rtMargin.bottom = aRtMargin.right;

                SetWindowText(hWndLeft, szBottom);
                SetWindowText(hWndRight, szTop);
                SetWindowText(hWndTop, szLeft);
                SetWindowText(hWndBottom, szRight);

                break;
            }
        }
    }
    pPI->uiOrientationID = uiNewId;

    //
    //  Update ptPaperSize.
    //
    pPI->PtPaperSizeMMs.x = 0;
    pPI->PtPaperSizeMMs.y = 0;
    pPD->Flags &= ~PI_WPAPER_ENVELOPE;

    if ((hWndSize = GetDlgItem(hDlg, ID_SETUP_C_SIZE)) && (pPI->pCurPrinter))
    {
        PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;
        DWORD dwNumber;
        LPWORD lpPapers;
        LPPOINT lpPaperSize;
        int nInd;
        DWORD i;

        dwNumber = DeviceCapabilities( pPrinter->pPrinterName,
                                       pPrinter->pPortName,
                                       DC_PAPERS,
                                       NULL,
                                       pDM );
        if ( dwNumber &&
             (dwNumber != (DWORD)-1) &&
             (lpPapers = LocalAlloc( LPTR,
                                     dwNumber *
                                         (sizeof(WORD) + sizeof(POINT)) * 2 )) )
        {
            lpPaperSize = (LPPOINT)(lpPapers + dwNumber * 2);

            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERS,
                                (LPTSTR)lpPapers,
                                pDM );
            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERSIZE,
                                (LPTSTR)lpPaperSize,
                                pDM );

            if ((nInd = (int) SendMessage(hWndSize, CB_GETCURSEL, 0, 0)) != CB_ERR)
            {
                pPI->wPaper = (WORD)SendMessage( hWndSize,
                                                 CB_GETITEMDATA,
                                                 nInd,
                                                 0 );
                pDM->dmPaperSize = pPI->wPaper;
            }
            else
            {
                pPI->wPaper = pDM->dmPaperSize;
            }

#ifndef WINNT
            if (pDM->dmSpecVersion >= 0x0400)
#endif
            {
                SendMessage( hWndSize,
                             CB_GETLBTEXT,
                             nInd,
                             (LPARAM)pDM->dmFormName );
            }

            switch (pPI->wPaper)
            {
                case ( DMPAPER_ENV_9 ) :
                case ( DMPAPER_ENV_10 ) :
                case ( DMPAPER_ENV_11 ) :
                case ( DMPAPER_ENV_12 ) :
                case ( DMPAPER_ENV_14 ) :
                case ( DMPAPER_ENV_DL ) :
                case ( DMPAPER_ENV_C5 ) :
                case ( DMPAPER_ENV_C3 ) :
                case ( DMPAPER_ENV_C4 ) :
                case ( DMPAPER_ENV_C6 ) :
                case ( DMPAPER_ENV_C65 ) :
                case ( DMPAPER_ENV_B4 ) :
                case ( DMPAPER_ENV_B5 ) :
                case ( DMPAPER_ENV_B6 ) :
                case ( DMPAPER_ENV_ITALY ) :
                case ( DMPAPER_ENV_MONARCH ) :
                case ( DMPAPER_ENV_PERSONAL ) :
                case ( DMPAPER_ENV_INVITE ) :
                case ( DMPAPER_JENV_KAKU2 ) :
                case ( DMPAPER_JENV_KAKU3 ) :
                case ( DMPAPER_JENV_CHOU3 ) :
                case ( DMPAPER_JENV_CHOU4 ) :
                case ( DMPAPER_JENV_KAKU2_ROTATED ) :
                case ( DMPAPER_JENV_KAKU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU4_ROTATED ) :
                case ( DMPAPER_JENV_YOU4 ) :
                case ( DMPAPER_JENV_YOU4_ROTATED ) :
                case ( DMPAPER_PENV_1 ) :
                case ( DMPAPER_PENV_2 ) :
                case ( DMPAPER_PENV_3 ) :
                case ( DMPAPER_PENV_4 ) :
                case ( DMPAPER_PENV_5 ) :
                case ( DMPAPER_PENV_6 ) :
                case ( DMPAPER_PENV_7 ) :
                case ( DMPAPER_PENV_8 ) :
                case ( DMPAPER_PENV_9 ) :
                case ( DMPAPER_PENV_10 ) :
                case ( DMPAPER_PENV_1_ROTATED ) :
                case ( DMPAPER_PENV_2_ROTATED ) :
                case ( DMPAPER_PENV_3_ROTATED ) :
                case ( DMPAPER_PENV_4_ROTATED ) :
                case ( DMPAPER_PENV_5_ROTATED ) :
                case ( DMPAPER_PENV_6_ROTATED ) :
                case ( DMPAPER_PENV_7_ROTATED ) :
                case ( DMPAPER_PENV_8_ROTATED ) :
                case ( DMPAPER_PENV_9_ROTATED ) :
                case ( DMPAPER_PENV_10_ROTATED ) :
                {
                    pPD->Flags |= PI_WPAPER_ENVELOPE;
                    break;
                }
            }

            for (i = 0; i < dwNumber; i++)
            {
                if (lpPapers[i] == pPI->wPaper)
                {
                    //
                    //  In tenths of MMs.
                    //
                    *(LPPOINT)&pPI->PtPaperSizeMMs = lpPaperSize[i];
                    break;
                }
            }

            LocalFree(lpPapers);
        }
    }

    //
    //  If the paper size could not be found, use something reasonable
    //  (eg. letter).
    //
    if (!pPI->PtPaperSizeMMs.x)
    {
        pPI->PtPaperSizeMMs.x = 85 * MMS_PER_INCH / 10;
    }
    if (!pPI->PtPaperSizeMMs.y)
    {
        pPI->PtPaperSizeMMs.y = 11 * MMS_PER_INCH;
    }

    //
    //  Rotate envelopes as needed.
    //
    if ( (pPD->Flags & PI_WPAPER_ENVELOPE) &&
         (!pPI->dwRotation) &&
         (pPI->PtPaperSizeMMs.x < pPI->PtPaperSizeMMs.y) )
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Maintain everything in accordance with the orientation
    //  so that apps have to do as little work as possible.
    //
    if (!bPortrait)
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Set up return ptPaperSize value.
    //
    if (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 1000 / MMS_PER_INCH;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 1000 / MMS_PER_INCH;
    }
    else           // PSD_INHUNDREDTHSOFMILLIMETERS
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 10;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 10;
    }

    //
    //  Update RtMinMarginMMs and rtMinMargin for new papersize/orientation.
    //
    PrintSetMinMargins(hDlg, pPI, pDM);

    //
    //  Don't let margins overlap (page might have shrunk).
    //
    if (pPSD->rtMargin.left + pPSD->rtMargin.right > pPSD->ptPaperSize.x)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.left  = (pPSD->ptPaperSize.x - lTemp) / 2;
        pPSD->rtMargin.right = (pPSD->ptPaperSize.x - lTemp) / 2;
    }
    if (pPSD->rtMargin.top + pPSD->rtMargin.bottom > pPSD->ptPaperSize.y)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.top    = (pPSD->ptPaperSize.y - lTemp) / 2;
        pPSD->rtMargin.bottom = (pPSD->ptPaperSize.y - lTemp) / 2;
    }

    //
    //  There are new minimal margins, so adjust rtMargin
    //  (min margins might have grown).
    //
    if (pPSD->rtMargin.left < pPSD->rtMinMargin.left)
        pPSD->rtMargin.left = pPSD->rtMinMargin.left;
    if (pPSD->rtMargin.top < pPSD->rtMinMargin.top)
        pPSD->rtMargin.top = pPSD->rtMinMargin.top;
    if (pPSD->rtMargin.right < pPSD->rtMinMargin.right)
        pPSD->rtMargin.right = pPSD->rtMinMargin.right;
    if (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom)
        pPSD->rtMargin.bottom = pPSD->rtMinMargin.bottom;

    //
    //  The margins were adjusted, so update the ui.
    //
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_LEFT, pPSD->rtMargin.left);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_TOP, pPSD->rtMargin.top);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_RIGHT, pPSD->rtMargin.right);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_BOTTOM, pPSD->rtMargin.bottom);

    //
    //  Update the sample window size & shadow.
    //
    if ( (hWndSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) &&
         (hWndShadowRight = GetDlgItem(hDlg, ID_SETUP_W_SHADOWRIGHT)) &&
         (hWndShadowBottom = GetDlgItem(hDlg, ID_SETUP_W_SHADOWBOTTOM)) )
    {
        int iWidth = pPI->PtPaperSizeMMs.x;
        int iLength = pPI->PtPaperSizeMMs.y;
        int iExtent;
        RECT aRtSampleXYWH = pPI->RtSampleXYWH;
        int iX = aRtSampleXYWH.right  / 16;
        int iY = aRtSampleXYWH.bottom / 16;

        if (iWidth > iLength)
        {
            iExtent = aRtSampleXYWH.bottom * iLength / iWidth;
            aRtSampleXYWH.top += (aRtSampleXYWH.bottom - iExtent) / 2;
            aRtSampleXYWH.bottom = iExtent;
        }
        else
        {
            iExtent = aRtSampleXYWH.right * iWidth / iLength;
            aRtSampleXYWH.left += (aRtSampleXYWH.right - iExtent) / 2;
            aRtSampleXYWH.right = iExtent;
        }

        SetWindowPos( hWndSample,
                      0,
                      aRtSampleXYWH.left,
                      aRtSampleXYWH.top,
                      aRtSampleXYWH.right,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowRight,
                      0,
                      aRtSampleXYWH.left + aRtSampleXYWH.right,
                      aRtSampleXYWH.top + iY,
                      iX,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowBottom,
                      0,
                      aRtSampleXYWH.left + iX,
                      aRtSampleXYWH.top + aRtSampleXYWH.bottom,
                      aRtSampleXYWH.right,
                      iY,
                      SWP_NOZORDER );

        InvalidateRect(hWndSample, NULL, TRUE);
        UpdateWindow(hDlg);
        UpdateWindow(hWndSample);
        UpdateWindow(hWndShadowRight);
        UpdateWindow(hWndShadowBottom);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitDuplex
//
//  Enable/Disable Paper Duplexing controls.
//
//  Returns TRUE iff buttons used to be disabled, now enabled.
//  Returns FALSE otherwise.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM)
{
    BOOL bEnable;
    HWND hCtl;


    bEnable = (pDM->dmFields & DM_DUPLEX);

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_G_DUPLEX))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LONG))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_SHORT))
    {
        EnableWindow(hCtl, bEnable);
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
        if (!bEnable)
        {
            ShowWindow(hCtl, SW_HIDE);
            SendMessage(hCtl, STM_SETICON, (LONG_PTR)hIconPDuplexNone, 0L);
            ShowWindow(hCtl, SW_SHOW);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetDuplex
//
//  This routine will operate on pDocDetails->pDMInput PSDEVMODE structure,
//  making sure that is a structure we know about and can handle.
//
//  If the pd doesn't have DM_DUPLEX caps then just display the appropriate
//  paper icon for DMDUP_SIMPLEX (case where nRad = ID_SETUP_R_NONE).
//
//  If nRad = 0, update icon but don't change radio button.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad)
{
    BOOL bPortrait;
    HANDLE hDuplexIcon;
    HWND hCtl;


    bPortrait = (pDM->dmOrientation == DMORIENT_PORTRAIT);

    if (!(pDM->dmFields & DM_DUPLEX))
    {
        nRad = ID_SETUP_R_NONE;
    }

    //
    //  Boundary checking - default to ID_SETUP_R_NONE.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        if ((nRad < ID_SETUP_R_NONE) || (nRad > ID_SETUP_R_SHORT))
        {
            if (IsDlgButtonChecked(hDlg, ID_SETUP_R_SHORT))
            {
                nRad = ID_SETUP_R_SHORT;
            }
            else if (IsDlgButtonChecked(hDlg, ID_SETUP_R_LONG))
            {
                nRad = ID_SETUP_R_LONG;
            }
            else
            {
                nRad = ID_SETUP_R_NONE;
            }
        }
        else
        {
            CheckRadioButton(hDlg, ID_SETUP_R_NONE, ID_SETUP_R_SHORT, nRad);
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        switch (nRad)
        {
            case ( ID_SETUP_R_LONG ) :      // Long Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_VERTICAL;
                hDuplexIcon = bPortrait ? hIconPDuplexNoTumble : hIconLDuplexTumble;

                break;
            }
            case ( ID_SETUP_R_SHORT ) :     // Short Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_HORIZONTAL;
                hDuplexIcon = bPortrait ? hIconPDuplexTumble : hIconLDuplexNoTumble;

                break;
            }
            default :                       // None - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_SIMPLEX;
                hDuplexIcon = bPortrait ? hIconPDuplexNone : hIconLDuplexNone;

                break;
            }
        }

        //
        //  Set the appropriate icon.
        //
        ShowWindow(hCtl, SW_HIDE);
        SendMessage(hCtl, STM_SETICON, (LONG_PTR)hDuplexIcon, 0L);
        ShowWindow(hCtl, SW_SHOW);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPaperCombo
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2)
{
    DWORD cStr1, cStr2, cRet1, cRet2, i;
    LPTSTR lpsOut1;
    LPWORD lpwOut2;
    BOOL fFill;


    HourGlass(TRUE);

    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    cStr1 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap1,
                                NULL,
                                pDM );

    cStr2 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap2,
                                NULL,
                                pDM );

    //
    //  Check for error from DeviceCapabilities calls.  If either
    //  call failed, simply set cStr1 to be 0 so that the windows will be
    //  disabled and nothing will be initialized.
    //
    if ((cStr1 == (DWORD)(-1)) || (cStr2 == (DWORD)(-1)))
    {
        cStr1 = 0;
    }

    fFill = (cStr1 > 0) && (cStr1 == cStr2);

    if (!((pPI->pPSD) && (pPI->pPSD->Flags & PSD_DISABLEPAPER)))
    {
        //
        //  If no entries, disable hCmb and hStc.
        //
        EnableWindow(hCmb, fFill);
        EnableWindow(hStc, fFill);
    }

    if (fFill)
    {
        lpsOut1 = LocalAlloc(LPTR, cStr1 * cchSize1 * sizeof(TCHAR));

        lpwOut2 = LocalAlloc(LPTR, cStr2 * sizeof(WORD));

        if (lpsOut1 && lpwOut2)
        {
            cRet1 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap1,
                                        (LPTSTR)lpsOut1,
                                        pDM );

            cRet2 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap2,
                                        (LPTSTR)lpwOut2,
                                        pDM );

            if ((pPI->dwRotation =
                    DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        DC_ORIENTATION,
                                        NULL,
                                        pDM )) == (DWORD)(-1))
            {
                pPI->dwRotation = 0;
            }

            if ((cRet1 == cStr1) && (cRet2 == cStr2))
            {
                LPTSTR lpsT1 = lpsOut1;
                LPWORD lpwT2 = lpwOut2;
                int nInd;
                LPTSTR lpFound = NULL;
                LPTSTR lpFirst = NULL;

                for (i = 0; i < cRet1; i++, lpsT1 += cchSize1, lpwT2++)
                {
#ifndef WINNT
                    LPTSTR lpsT3;
                    LPWORD lpwT4;

                    //
                    //  Various checks for HP LaserJet and PostScript
                    //  driver bugs.
                    //
                    //
                    //  Look for duplicate names.
                    //
                    for (lpsT3 = lpsOut1; lpsT3 <= lpsT1; lpsT3 += cchSize1)
                    {
                        if (!lstrcmp(lpsT3, lpsT1))
                        {
                            break;
                        }
                    }
                    if (lpsT3 != lpsT1)
                    {
                        //
                        //  Duplicate found, so ignore.
                        //
                        continue;
                    }

                    //
                    //  Look for duplicate values.
                    //
                    for (lpwT4 = lpwOut2; lpwT4 <= lpwT2; lpwT4++)
                    {
                        if (*lpwT4 == *lpwT2)
                        {
                            break;
                        }
                    }
                    if (lpwT4 != lpwT2)
                    {
                        //
                        //  Duplicate found, so ignore.
                        //
                        continue;
                    }
#endif
                    //
                    //  Look for a blank name entry.
                    //
                    if (!*lpsT1)
                    {
                        //
                        //  Blank entry, so ignore.
                        //
                        continue;
                    }

                    //
                    //  Add the string to the list box.
                    //
                    nInd = (int) SendMessage( hCmb,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM)lpsT1 );
                    if (nInd != CB_ERR)
                    {
                        //
                        //  Set the data associated with the string that
                        //  was just added to the list box.
                        //
                        SendMessage( hCmb,
                                     CB_SETITEMDATA,
                                     nInd,
                                     (LPARAM)*lpwT2 );

                        //
                        //  See if this item should be selected.
                        //
                        if (!lpFound)
                        {
                            if (!lpFirst)
                            {
                                lpFirst = lpsT1;
                            }

                            if ( (fwCap1 == DC_PAPERNAMES) &&
                                 (pDM->dmFields & DM_PAPERSIZE) &&
                                 (pDM->dmPaperSize == (SHORT)*lpwT2) )
                            {
                                lpFound = lpsT1;
                            }
                            else if ( (fwCap1 == DC_BINNAMES) &&
                                      (pDM->dmFields & DM_DEFAULTSOURCE) &&
                                      (pDM->dmDefaultSource == (SHORT)*lpwT2) )
                            {
                               lpFound = lpsT1;
                            }
                        }
                    }
                }

                //
                //  Set the appropriate selection.
                //
                if (lpFound)
                {
                    SendMessage( hCmb,
                                 CB_SETCURSEL,
                                 SendMessage( hCmb,
                                              CB_FINDSTRINGEXACT,
                                              (WPARAM)-1,
                                              (LPARAM)lpFound ),
                                 0 );
                }
                else
                {
                    if (fwCap1 == DC_PAPERNAMES)
                    {
                        //
                        //  Check for a default FORM name.
                        //
                        if (!( (pDM->dmFields & DM_FORMNAME) &&
                               ((nInd = (int)
                                   SendMessage( hCmb,
                                                CB_SELECTSTRING,
                                                (WPARAM)-1,
                                                (LPARAM)pDM->dmFormName )) != CB_ERR) ))
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                        else
                        {
                            //
                            //  Save the paper size since the form name exists
                            //  in the list box.
                            //
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                    }
                    else
                    {
                        //
                        //  Set the SOURCE to the Default if it exists.
                        //
                        nInd = (int) SendMessage( hCmb,
                                                  CB_SELECTSTRING,
                                                  (WPARAM)-1,
                                                  (LPARAM)szDefaultSrc );
                        if (nInd != CB_ERR)
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                        else
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                    }
                }
            }
        }
        if (lpsOut1)
        {
            LocalFree((HLOCAL)lpsOut1);
        }

        if (lpwOut2)
        {
            LocalFree((HLOCAL)lpwOut2);
        }
    }

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditError
//
//  Set focus to an edit control and select the entire contents.
//  This is generally used when an improper value was found at OK time.
//
//  Assumes edit control not disabled.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...)
{
    HWND hEdit;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszFormat[MAX_PATH];
    TCHAR pszMessage[MAX_PATH];


    //
    //  Put up the error message box.
    //
    if ( GetWindowText(hDlg, pszTitle, ARRAYSIZE(pszTitle)) &&
         CDLoadString(g_hinst, MessageId, pszFormat, ARRAYSIZE(pszFormat)) )
    {
        va_list ArgList;

        va_start(ArgList, MessageId);
        wvnsprintf(pszMessage, ARRAYSIZE(pszMessage), pszFormat, ArgList);
        va_end(ArgList);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox(hDlg, pszMessage, pszTitle, MB_ICONEXCLAMATION | MB_OK);
    }

    //
    //  Highlight the invalid value.
    //
    if (hEdit = ((Id == 0) ? NULL : GetDlgItem(hDlg, Id)))
    {
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hEdit, 1L);
        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintOpenPrinter
//
//  If the OpenPrinter call is successful, this sets hPrinter, pPrinter,
//  cPrinters, and pCurPrinter.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    if (OpenPrinter(pPrinterName, &pPI->hCurPrinter, NULL))
    {
        if (pPI->pPrinters = PrintGetPrinterInfo2(pPI->hCurPrinter))
        {
            pPI->cPrinters = 1;

#ifdef UNICODE
            if (pPI->bUseExtDeviceMode)
            {
                PrintGetExtDeviceMode(NULL, pPI);
            }
#endif
        }
        pPI->pCurPrinter = pPI->pPrinters;
    }
    else
    {
        //
        //  Cannot trust the OpenPrinter call.
        //
        pPI->hCurPrinter = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintClosePrinters
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintClosePrinters(
    PPRINTINFO pPI)
{
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }
    pPI->pCurPrinter = NULL;

    FreePrinterArray(pPI);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSpoolerInfo
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

VOID UpdateSpoolerInfo(
    PPRINTINFO pPI)
{
    LPDEVMODEA pDMA;
    CHAR szPrinterNameA[33];
    LPDEVMODEW pDMW;


    //
    //  Get a pointer to the devmode structure.
    //
    pDMW = GlobalLock(pPI->pPD->hDevMode);
    if ((!pDMW) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  Convert the printer name from Unicode to ANSI.
    //
    SHUnicodeToAnsi(pPI->pCurPrinter->pPrinterName, szPrinterNameA, ARRAYSIZE(szPrinterNameA));

    //
    //  Allocate and convert the Unicode devmode to ANSI.
    //
    pDMA = AllocateAnsiDevMode(pDMW);
    if (!pDMA)
    {
        GlobalUnlock(pPI->pPD->hDevMode);
        return;
    }

    //
    //  Update the spooler's information.
    //
    ExtDeviceMode( NULL,
                   NULL,
                   NULL,
                   szPrinterNameA,
                   NULL,
                   pDMA,
                   NULL,
                   DM_UPDATE | DM_MODIFY );

    //
    //  Free the buffer.
    //
    GlobalFree(pDMA);
    GlobalUnlock(pPI->pPD->hDevMode);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetPrinterInfo2
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintGetPrinterInfo2(
    HANDLE hPrinter)
{
    PPRINTER_INFO_2 pPrinter = NULL;
    DWORD cbPrinter = 0;


    StoreExtendedError(CDERR_GENERALCODES);

    if (!GetPrinter(hPrinter, 2, NULL, 0, &cbPrinter) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        if (pPrinter = GlobalAlloc(GPTR, cbPrinter))
        {
            if (!GetPrinter( hPrinter,
                             2,
                             (LPBYTE)pPrinter,
                             cbPrinter,
                             &cbPrinter ))
            {
                GlobalFree(pPrinter);
                pPrinter = NULL;
                StoreExtendedError(PDERR_PRINTERNOTFOUND);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
        }
    }
    else
    {
        StoreExtendedError(PDERR_SETUPFAILURE);
    }

    return (pPrinter);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertStringToInteger
//
//  Converts a string to an integer.  Stops at the first non digit.
//
////////////////////////////////////////////////////////////////////////////

int ConvertStringToInteger(
    LPCTSTR pSrc)
{
    int Number = 0;
    BOOL bNeg = FALSE;


    if (*pSrc == TEXT('-'))
    {
        bNeg = TRUE;
        pSrc++;
    }

    while (ISDIGIT(*pSrc))
    {
        Number *= 10;
        Number += *pSrc - TEXT('0');
        pSrc++;
    }

    return ( bNeg ? -Number : Number );
}


////////////////////////////////////////////////////////////////////////////
//
//  FreePrinterArray
//
//  Purpose:    Frees the buffer allocated to store printers.
//
//  Parameters: PPRINTINFO pPI
//
//  Return:     void
//
////////////////////////////////////////////////////////////////////////////

VOID FreePrinterArray(
    PPRINTINFO pPI)
{
    PPRINTER_INFO_2 pPrinters = pPI->pPrinters;
#ifdef UNICODE
    DWORD dwCount;
#endif
    //
    //  If NULL, we can return now.
    //
    if (!pPrinters)
    {
        return;
    }

#ifdef UNICODE
    //
    //  If we made calls to ExtDeviceMode, then we need to
    //  free the buffers allocated for each devmode.
    //
    if (pPI->bUseExtDeviceMode)
    {
        if (pPI->pAllocInfo)
        {
            //
            //  Loop through each of the printers.
            //
            for (dwCount = 0; dwCount < pPI->cPrinters; dwCount++)
            {
                //
                //  If pDevMode exists, free it.
                //
                if ((pPrinters[dwCount].pDevMode) &&
                    (pPI->pAllocInfo[dwCount]))
                {
                    GlobalFree(pPrinters[dwCount].pDevMode);
                    pPrinters[dwCount].pDevMode = NULL;
                }
            }
            GlobalFree(pPI->pAllocInfo);
            pPI->pAllocInfo = NULL;
        }
    }
#endif

    //
    //  Free the entire block.
    //
    GlobalFree(pPI->pPrinters);
    pPI->pPrinters = NULL;
    pPI->cPrinters = 0;
}


////////////////////////////////////////////////////////////////////////////
//
//  TermPrint
//
////////////////////////////////////////////////////////////////////////////

VOID TermPrint(void)
{
#ifdef WINNT
    Print_UnloadLibraries();           // printnew.cpp
#endif
}





/*========================================================================*/
/*                   Page Setup <-> Print Dialog                          */
/*========================================================================*/


////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPD->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPD->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPD2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPD2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPSD->hDevMode  = pPI->pPD->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPD->hDevNames;
    }
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PDA
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PDA(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPDA->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPDA->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPDA2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPDA2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPSD->hDevMode  = pPI->pPDA->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPDA->hDevNames;
    }
}

#endif





/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPageSetupDlg(
    PPRINTINFO pPI,
    LPPAGESETUPDLGA pPSDA)
{
    LPPRINTDLGA pPDA;


    if (!pPSDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSDA->lStructSize != sizeof(PAGESETUPDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSDA->Flags & PSD_RETURNDEFAULT) &&
        (pPSDA->hDevNames || pPSDA->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Reset the size of the pPSD structure to the UNICODE size and
    //  save it in the pPI structure.
    //
    //  NOTE:  This must be reset back to the ANSI size before
    //         returning to the caller.
    //
    pPSDA->lStructSize = sizeof(PAGESETUPDLGW);
    pPI->pPSD = (LPPAGESETUPDLG)pPSDA;
    pPI->ApiType = COMDLG_ANSI;

    //
    //  Create the ANSI version of the print dialog structure.
    //
    if (pPDA = GlobalAlloc(GPTR, sizeof(PRINTDLGA)))
    {
        pPI->pPDA = pPDA;

        pPDA->lStructSize         = sizeof(PRINTDLGA);
        pPDA->hwndOwner           = pPSDA->hwndOwner;
        pPDA->Flags               = PD_PAGESETUP |
                                      (pPSDA->Flags &
                                        (PSD_NOWARNING |
                                         PSD_SHOWHELP |
                                         PSD_ENABLEPAGESETUPHOOK |
                                         PSD_ENABLEPAGESETUPTEMPLATE |
                                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                         CD_WX86APP |
                                         PSD_NONETWORKBUTTON));
        pPDA->hInstance           = pPSDA->hInstance;
        pPDA->lCustData           = pPSDA->lCustData;
        pPDA->lpfnSetupHook       = pPSDA->lpfnPageSetupHook;
        pPDA->lpSetupTemplateName = pPSDA->lpPageSetupTemplateName;
        pPDA->hSetupTemplate      = pPSDA->hPageSetupTemplate;

        pPDA->hDevMode            = pPSDA->hDevMode;
        pPDA->hDevNames           = pPSDA->hDevNames;
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPageSetupDlg(
    PPRINTINFO pPI)
{
    //
    //  Reset the size of the pPSD structure to the correct value.
    //
    if (pPI->pPSD)
    {
        pPI->pPSD->lStructSize = sizeof(PAGESETUPDLGA);
    }

    //
    //  Free the ANSI print dialog structure.
    //
    if (pPI->pPDA)
    {
        GlobalFree(pPI->pPDA);
        pPI->pPDA = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPrintDlg(
    PPRINTINFO pPI,
    LPPRINTDLGA pPDA)
{
    LPPRINTDLGW pPDW;
    LPDEVMODEA pDMA;
    DWORD cbLen;


    if (!pPDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pPDW = GlobalAlloc(GPTR, sizeof(PRINTDLGW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize    = sizeof(PRINTDLGW);
    pPDW->hwndOwner      = pPDA->hwndOwner;
    pPDW->hInstance      = pPDA->hInstance;
    pPDW->lpfnPrintHook  = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook  = pPDA->lpfnSetupHook;
    pPDW->hPrintTemplate = pPDA->hPrintTemplate;
    pPDW->hSetupTemplate = pPDA->hSetupTemplate;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    //
    //  Thunk Device Names A => W
    //
    pPDW->hDevNames = NULL;
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName =
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpPrintTemplateName,(LPWSTR)pPDW->lpPrintTemplateName, cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpPrintTemplateName = (DWORD_PTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Init Print Setup TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLESETUPTEMPLATE) && (pPDA->lpSetupTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpSetupTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpSetupTemplateName) + 1;
            if (!(pPDW->lpSetupTemplateName =
                      GlobalAlloc( GPTR,
                                   (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fSetupTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpSetupTemplateName,(LPWSTR)pPDW->lpSetupTemplateName,cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpSetupTemplateName = (DWORD_PTR)pPDA->lpSetupTemplateName;
        }
    }
    else
    {
        pPDW->lpSetupTemplateName = NULL;
    }

    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;


    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    if (pPI->fSetupTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpSetupTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgA2W(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;
    LPPRINTDLGA pPDA = pPI->pPDA;


    //
    //  Copy info A => W
    //
    pPDW->hDC           = pPDA->hDC;
    pPDW->Flags         = pPDA->Flags;
    pPDW->nFromPage     = pPDA->nFromPage;
    pPDW->nToPage       = pPDA->nToPage;
    pPDW->nMinPage      = pPDA->nMinPage;
    pPDW->nMaxPage      = pPDA->nMaxPage;
    pPDW->nCopies       = pPDA->nCopies;
    pPDW->lCustData     = pPDA->lCustData;
    pPDW->lpfnPrintHook = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook = pPDA->lpfnSetupHook;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgW2A(
    PPRINTINFO pPI)
{
    LPPRINTDLGA pPDA = pPI->pPDA;
    LPPRINTDLGW pPDW = pPI->pPD;

    //
    //  Copy info W => A
    //
    pPDA->hDC           = pPDW->hDC;
    pPDA->Flags         = pPDW->Flags;
    pPDA->nFromPage     = pPDW->nFromPage;
    pPDA->nToPage       = pPDW->nToPage;
    pPDA->nMinPage      = pPDW->nMinPage;
    pPDA->nMaxPage      = pPDW->nMaxPage;
    pPDA->nCopies       = pPDW->nCopies;
    pPDA->lCustData     = pPDW->lCustData;
    pPDA->lpfnPrintHook = pPDW->lpfnPrintHook;
    pPDA->lpfnSetupHook = pPDW->lpfnSetupHook;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesW2A(pPDW->hDevNames, &pPDA->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Make sure realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                pPDA->hDevMode = GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeA2W(
    LPDEVMODEA pDMA,
    LPDEVMODEW pDMW)
{
    LPDEVMODEA pDevModeA;

    if (!pDMA || !pDMW)
    {
        return;
    }

    //
    //  Make sure the device name in the devmode is not too long such that
    //  it has overwritten the other devmode fields.
    //
    if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
        (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
    {
        return;
    }

    //
    //  We need to create a temporary ANSI that is a known size.
    //  The problem is if we are being called from WOW, the WOW
    //  app could be either a Windows 3.1 or 3.0 app.  The size
    //  of the devmode structure was different for both of these
    //  versions compared to the DEVMODE structure in NT.
    //  By copying the ANSI devmode to one we allocate, then we
    //  can access all of the fields (26 currently) without causing
    //  an access violation.
    //
    pDevModeA = GlobalAlloc(GPTR, sizeof(DEVMODEA) + pDMA->dmDriverExtra);
    if (!pDevModeA)
    {
        return;
    }

    CopyMemory( (LPBYTE)pDevModeA,
                (LPBYTE)pDMA,
                min(sizeof(DEVMODEA), pDMA->dmSize) );

    CopyMemory( (LPBYTE)pDevModeA + sizeof(DEVMODEA),
                (LPBYTE)pDMA + pDMA->dmSize,
                pDMA->dmDriverExtra );

    //
    //  Now we can thunk the contents of the ANSI structure to the
    //  Unicode structure.
    //
    SHAnsiToUnicode((LPSTR)pDevModeA->dmDeviceName,(LPWSTR)pDMW->dmDeviceName,CCHDEVICENAME );

    pDMW->dmSpecVersion   = pDevModeA->dmSpecVersion;
    pDMW->dmDriverVersion = pDevModeA->dmDriverVersion;
    pDMW->dmSize          = sizeof(DEVMODEW);
    pDMW->dmDriverExtra   = pDevModeA->dmDriverExtra;
    pDMW->dmFields        = pDevModeA->dmFields;
    pDMW->dmOrientation   = pDevModeA->dmOrientation;
    pDMW->dmPaperSize     = pDevModeA->dmPaperSize;
    pDMW->dmPaperLength   = pDevModeA->dmPaperLength;
    pDMW->dmPaperWidth    = pDevModeA->dmPaperWidth;
    pDMW->dmScale         = pDevModeA->dmScale;
    pDMW->dmCopies        = pDevModeA->dmCopies;
    pDMW->dmDefaultSource = pDevModeA->dmDefaultSource;
    pDMW->dmPrintQuality  = pDevModeA->dmPrintQuality;
    pDMW->dmColor         = pDevModeA->dmColor;
    pDMW->dmDuplex        = pDevModeA->dmDuplex;
    pDMW->dmYResolution   = pDevModeA->dmYResolution;
    pDMW->dmTTOption      = pDevModeA->dmTTOption;
    pDMW->dmCollate       = pDevModeA->dmCollate;

    SHAnsiToUnicode((LPSTR)pDevModeA->dmFormName,(LPWSTR)pDMW->dmFormName,CCHFORMNAME );

    pDMW->dmLogPixels        = pDevModeA->dmLogPixels;
    pDMW->dmBitsPerPel       = pDevModeA->dmBitsPerPel;
    pDMW->dmPelsWidth        = pDevModeA->dmPelsWidth;
    pDMW->dmPelsHeight       = pDevModeA->dmPelsHeight;
    pDMW->dmDisplayFlags     = pDevModeA->dmDisplayFlags;
    pDMW->dmDisplayFrequency = pDevModeA->dmDisplayFrequency;

    pDMW->dmICMMethod        = pDevModeA->dmICMMethod;
    pDMW->dmICMIntent        = pDevModeA->dmICMIntent;
    pDMW->dmMediaType        = pDevModeA->dmMediaType;
    pDMW->dmDitherType       = pDevModeA->dmDitherType;

    pDMW->dmReserved1        = pDevModeA->dmReserved1;
    pDMW->dmReserved2        = pDevModeA->dmReserved2;

    pDMW->dmPanningWidth     = pDevModeA->dmPanningWidth;
    pDMW->dmPanningHeight    = pDevModeA->dmPanningHeight;

    CopyMemory( (pDMW + 1),
                (pDevModeA + 1),
                pDevModeA->dmDriverExtra );

    //
    //  Free the memory we allocated.
    //
    GlobalFree(pDevModeA);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeW2A(
    LPDEVMODEW pDMW,
    LPDEVMODEA pDMA)
{
    if (!pDMW || !pDMA)
    {
        return;
    }


    SHUnicodeToAnsi((LPWSTR)pDMW->dmDeviceName,(LPSTR)pDMA->dmDeviceName,CCHDEVICENAME);

    pDMA->dmSpecVersion   = pDMW->dmSpecVersion;
    pDMA->dmDriverVersion = pDMW->dmDriverVersion;
    pDMA->dmSize          = sizeof(DEVMODEA);
    pDMA->dmDriverExtra   = pDMW->dmDriverExtra;
    pDMA->dmFields        = pDMW->dmFields;
    pDMA->dmOrientation   = pDMW->dmOrientation;
    pDMA->dmPaperSize     = pDMW->dmPaperSize;
    pDMA->dmPaperLength   = pDMW->dmPaperLength;
    pDMA->dmPaperWidth    = pDMW->dmPaperWidth;
    pDMA->dmScale         = pDMW->dmScale;
    pDMA->dmCopies        = pDMW->dmCopies;
    pDMA->dmDefaultSource = pDMW->dmDefaultSource;
    pDMA->dmPrintQuality  = pDMW->dmPrintQuality;
    pDMA->dmColor         = pDMW->dmColor;
    pDMA->dmDuplex        = pDMW->dmDuplex;
    pDMA->dmYResolution   = pDMW->dmYResolution;
    pDMA->dmTTOption      = pDMW->dmTTOption;
    pDMA->dmCollate       = pDMW->dmCollate;

    SHUnicodeToAnsi((LPWSTR)pDMW->dmFormName,(LPSTR)pDMA->dmFormName,CCHFORMNAME);

    pDMA->dmLogPixels        = pDMW->dmLogPixels;
    pDMA->dmBitsPerPel       = pDMW->dmBitsPerPel;
    pDMA->dmPelsWidth        = pDMW->dmPelsWidth;
    pDMA->dmPelsHeight       = pDMW->dmPelsHeight;
    pDMA->dmDisplayFlags     = pDMW->dmDisplayFlags;
    pDMA->dmDisplayFrequency = pDMW->dmDisplayFrequency;

    pDMA->dmICMMethod        = pDMW->dmICMMethod;
    pDMA->dmICMIntent        = pDMW->dmICMIntent;
    pDMA->dmMediaType        = pDMW->dmMediaType;
    pDMA->dmDitherType       = pDMW->dmDitherType;

    pDMA->dmReserved1        = pDMW->dmReserved1;
    pDMA->dmReserved2        = pDMW->dmReserved2;

    pDMA->dmPanningWidth     = pDMW->dmPanningWidth;
    pDMA->dmPanningHeight    = pDMW->dmPanningHeight;

    CopyMemory( (pDMA + 1),
                (pDMW + 1),
                pDMA->dmDriverExtra );
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateUnicodeDevMode
//
//  Purpose:    Allocates a Unicode devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEA pANSIDevMode
//
//  Return:     LPDEVMODEW - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEW AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode)
{
    int iSize;
    LPDEVMODEW pUnicodeDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEW);

    iSize += pANSIDevMode->dmDriverExtra;

    pUnicodeDevMode = GlobalAlloc(GPTR, iSize);

    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the ANSI devmode to the
    //  Unicode devmode.
    //
    ThunkDevModeA2W(pANSIDevMode, pUnicodeDevMode);

    //
    //  Return the pointer.
    //
    return (pUnicodeDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateAnsiDevMode
//
//  Purpose:    Allocates a Ansi devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEW pUnicodeDevMode
//
//  Return:     LPDEVMODEA - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEA AllocateAnsiDevMode(
    LPDEVMODEW pUnicodeDevMode)
{
    int iSize;
    LPDEVMODEA pANSIDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEA);

    iSize += pUnicodeDevMode->dmDriverExtra;

    pANSIDevMode = GlobalAlloc(GPTR, iSize);

    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the Unicode devmode to the
    //  ANSI devmode.
    //
    ThunkDevModeW2A(pUnicodeDevMode, pANSIDevMode);

    //
    //  Return the pointer.
    //
    return (pANSIDevMode);
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_PD_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_PD_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PPRINTINFO pPI;

    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if (pPI->pPD && pPI->pPDA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkPrintDlgA2W(pPI);
            }
            else
            {
                ThunkPrintDlgW2A(pPI);
            }
        }
    }
}

#endif

#endif

////////////////////////////////////////////////////////////////////////////
//
//  SetCopiesEditWidth
//
// Adjust the width of the copies edit control using the current
// font and the scroll bar width.  This is necessary to handle the
// the up down control from encroching on the space in the edit
// control when we are in High Contrast (extra large) mode.
//
////////////////////////////////////////////////////////////////////////////

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl)
{
    HDC hDC                 = NULL;
    LONG MaxDigitExtant     = 0;
    LONG EditControlWidth   = 0;
    LONG CurrentWidth       = 0;
    UINT i                  = 0;
    INT aDigitWidth[10];
    WINDOWPLACEMENT WndPl;

    //
    // Acquire the edit controls device context.
    //
    hDC = GetDC( hControl );

    if (hDC)
    {
        //
        // Determine max width of the digit group.
        //
        if (GetCharWidth32( hDC, TEXT('0'), TEXT('9'), aDigitWidth))
        {
            for (i = 0; i < ARRAYSIZE(aDigitWidth); i++)
            {
                if (aDigitWidth[i] > MaxDigitExtant)
                {
                    MaxDigitExtant = aDigitWidth[i];
                }
            }

            //
            // Get the edit control placement.
            //
            WndPl.length = sizeof( WndPl );

            if (GetWindowPlacement( hControl, &WndPl ))
            {
                //
                // Calculate the edit control current width.
                //
                EditControlWidth = MaxDigitExtant * COPIES_EDIT_SIZE;

                //
                // Calculate the current width of the edit control.
                //
                CurrentWidth = WndPl.rcNormalPosition.right - WndPl.rcNormalPosition.left;

                //
                // Set the new position of the edit control.
                //
                WndPl.rcNormalPosition.left = WndPl.rcNormalPosition.left - (EditControlWidth - CurrentWidth);

                //
                // Place the control.
                //
                SetWindowPlacement( hControl, &WndPl );
            }
        }

        //
        // Release the device context.
        //
        ReleaseDC( hControl, hDC );
    }
}

////////////////////////////////////////////////////////////////////////////
//
// CountDigits
//
// Count how many digits is needed for a specific number
//
////////////////////////////////////////////////////////////////////////////

WORD
CountDigits(
    DWORD dwNumber)
{
    WORD    cDigits = 0;

    if(dwNumber == 0)
    {
        return 1;
    }

    while(dwNumber > 0)
    {
        cDigits++;
        dwNumber /= 10;
    }

    return cDigits++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\printnew.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.h

Abstract:

    This module contains the header information for the Win32
    property sheet print common dialogs.

Revision History:

    11-04-97    JulieB    Created.
    Feb-2000    LazarI    major redesign (not to use printui anymore)

--*/



#ifdef __cplusplus
extern "C" {
#endif



#ifdef WINNT

//
//  Include Files.
//

#include <dlgs.h>
#include <initguid.h>
#include <winprtp.h>




//
//  Constant Declarations.
//

//
//  Dialog Constants.
//
#define IDD_PRINT_GENERAL          100
#define IDD_PRINT_GENERAL_LARGE    101 

#define IDI_COLLATE               ico1

#define IDC_PRINTER_LIST          1000
#define IDC_PRINTER_LISTVIEW      1001
#define IDC_PRINT_TO_FILE         1002
#define IDC_FIND_PRINTER          1003
#define IDC_STATUS_TEXT           1004
#define IDC_STATUS                1005
#define IDC_LOCATION_TEXT         1006
#define IDC_LOCATION              1007
#define IDC_COMMENT_TEXT          1008
#define IDC_COMMENT               1009
#define IDC_DRIVER                1010
#define IDC_HIDDEN_TEXT           1011

#define IDC_RANGE_ALL             rad1
#define IDC_RANGE_SELECTION       rad2
#define IDC_RANGE_CURRENT         rad3
#define IDC_RANGE_PAGES           rad4
#define IDC_RANGE_EDIT            edt1
#define IDC_RANGE_TEXT1           stc1
#define IDC_RANGE_TEXT2           stc2

#define IDC_COPIES                edt2
#define IDC_COPIES_TEXT           stc3
#define IDC_COLLATE               chx1

#define IDC_STATIC                -1


//
//  Typedef Declarations.
//

typedef struct
{
    UINT           ApiType;
    LPPRINTDLGEX   pPD;
    DWORD          ProcessVersion;
    DWORD          dwFlags;
    UINT           FinalResult;
    HRESULT        hResult;
    BOOL           fApply;
    BOOL           fOld;
    DWORD          dwExtendedError;
    HRESULT        hrOleInit;
#ifdef UNICODE
    LPPRINTDLGEXA  pPDA;
    BOOL           fPrintTemplateAlloc;
#endif
} PRINTINFOEX, *PPRINTINFOEX;


//
//  Registry keys.
//
static const TCHAR c_szSettings[] = TEXT("Printers\\Settings");
static const TCHAR c_szViewMode[] = TEXT("ViewMode");




//
//  CPrintBrowser Class.
//

class CPrintBrowser : public IShellBrowser, 
                      public ICommDlgBrowser2, 
                      public IPrintDialogCallback, 
                      public IPrintDialogServices
{
public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) (THIS);
    STDMETHOD_(ULONG, Release) (THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND *lphwnd);
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode);

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject) (THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream) (THIS_ DWORD grfMode, LPSTREAM *pStrm);
    STDMETHOD(GetControlWindow) (THIS_ UINT id, HWND *lphwnd);
    STDMETHOD(SendControlMsg) (THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView) (THIS_ struct IShellView **ppshv);
    STDMETHOD(OnViewWindowActive) (THIS_ struct IShellView *pshv);
    STDMETHOD(SetToolbarItems) (THIS_ LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView *ppshv);
    STDMETHOD(OnStateChange) (THIS_ struct IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ struct IShellView *ppshv, LPCITEMIDLIST lpItem);
    STDMETHOD(Notify) (THIS_ struct IShellView *ppshv, DWORD dwNotifyType);
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView *ppshv, WCHAR *pszText, INT cchMax);
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS);
    STDMETHOD(SelectionChange) (THIS);
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult);

    // *** IPrintDialogServices methods ***
    STDMETHOD(GetCurrentDevMode) (THIS_ LPDEVMODE pDevMode, UINT *pcbSize);
    STDMETHOD(GetCurrentPrinterName) (THIS_ LPTSTR pPrinterName, UINT *pcchSize);
    STDMETHOD(GetCurrentPortName) (THIS_ LPTSTR pPortName, UINT *pcchSize);

    // *** Our own methods ***
    CPrintBrowser(HWND hDlg);
    ~CPrintBrowser();

    BOOL    OnInitDialog(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
    VOID    OnDestroyMessage();
    BOOL    OnCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnNotifyMessage(WPARAM wParam, LPNMHDR lpnmhdr);
    BOOL    OnSelChange();
    BOOL    OnChangeNotify(LONG lNotification, LPCITEMIDLIST *ppidl);
    BOOL    OnAccelerator(HWND hwndActivePrint, HWND hwndFocus, HACCEL haccPrint, PMSG pMsg);
    VOID    OnNoPrinters(HWND hDlg, UINT uID);
    VOID    OnInitDone();

private:

    HRESULT CreatePrintShellView();
    UINT    GetViewMode();
    VOID    SetViewMode();
    HRESULT CreateHookDialog();
    BOOL    UpdateStatus(LPCITEMIDLIST pidl);
    BOOL    SelectSVItem();
    BOOL    GetCurrentPrinter();
    VOID    InitPrintToFile();
    VOID    InitPageRangeGroup();
    VOID    InitCopiesAndCollate();
    BOOL    SaveCopiesAndCollateInDevMode(LPDEVMODE pDM, LPTSTR pszPrinter);
    BOOL    SetCopiesOnApply();
    VOID    SaveDevMode();
    BOOL    MergeDevMode(LPTSTR pszPrinterName);
    BOOL    IsValidPageRange(LPTSTR pszString, UINT *pErrorId);
    BOOL    ConvertPageRangesToString(LPTSTR pszString, UINT cchLen);
    UINT    IntegerToString(DWORD Value, LPTSTR pszString, UINT cchLen);
    VOID    ShowError(HWND hDlg, UINT uCtrlID, UINT uMsgID, ...);
    int     ShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, ...);
    int     InternalShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, va_list args);
    UINT    InsertDevicePage(LPCWSTR pszName, PDEVMODE pDevMode);
    UINT    RemoveDevicePage();
    UINT    RemoveAndInsertDevicePage(LPCWSTR pszName, PDEVMODE pDevMode);
    BOOL    FitViewModeBest(HWND hwndListView);
    VOID    SelectPrinterItem(LPITEMIDLIST pidlItem);
    BOOL    IsCurrentPrinter(LPCITEMIDLIST pidl);
    BOOL    OnRename(LPCITEMIDLIST *ppidl);

    //
    // The error codes returned by InstallDevMode/UninstallDevMode functions below.
    //
    enum 
    {
        kSuccess,                               // Success no error
        kError,                                 // General error
        kInvalidDevMode,                        // Invalid devmode specified
        kInvalidPrinterName,                    // Invalid printer name specified
        kAccessDenied,                          // User does not have access to printer
    };

    //
    // These functions maintain the internal devmode, driver UI stuff and
    // implement the printui.dll functionality - bPrinterSetup(...).
    //
    BOOL FindPrinter(HWND hwnd, LPTSTR pszBuffer, UINT cchSize);
    BOOL GetInternalPrinterName(LPTSTR pszBuffer, DWORD *pdwSize);
    LPDEVMODE GetCurrentDevMode();
    BOOL GetDefaultDevMode(HANDLE hPrinter, LPCTSTR pszPrinterName, PDEVMODE *ppDevMode, BOOL bFillWithDefault);
    BOOL WrapEnumPrinters(DWORD dwFlags, LPCTSTR pszServer, DWORD dwLevel, PVOID* ppvBuffer, PDWORD pcbBuffer, PDWORD pcPrinters);
    BOOL GetUsablePrinter(LPTSTR szPrinterNameBuf, DWORD *pcchBuf);
    BOOL GetInternalDevMode(PDEVMODE *ppOutDevMode, LPCTSTR pszPrinter, HANDLE hPrinter, PDEVMODE pInDevMode);
    UINT InstallDevMode(LPCTSTR pszPrinterName, PDEVMODE pDevModeToMerge);
    UINT UninstallDevMode();

    //
    // Members start here.
    //
    UINT cRef;                         // compobj refcount
    HWND hwndDlg;                      // handle of this dialog
    HWND hSubDlg;                      // handle of the hook dialog
    HWND hwndView;                     // current view window
    HWND hwndUpDown;                   // UpDown Control Window handle;
    IShellView *psv;                   // shell view object
    IShellFolderView *psfv;            // shell folder view object
    IShellFolder2 *psfRoot;            // print folder shell folder
    LPITEMIDLIST pidlRoot;             // pidl for print folder
    IPrinterFolder *ppf;               // printer folder private interface

    HIMAGELIST himl;                   // system imagelist (small images)

    PPRINTINFOEX pPI;                  // ptr to PRINTINFOEX struct
    LPPRINTDLGEX pPD;                  // caller's PRINTDLGEX struct

    IPrintDialogCallback *pCallback;   // ptr to app's callback interface
    IObjectWithSite *pSite;            // ptr to app's SetSite interface

    LPDEVMODE pDMInit;                 // ptr to the initial DEVMODE struct
    LPDEVMODE pDMCur;                  // ptr to the current DEVMODE struct
    LPDEVMODE pDMSave;                 // ptr to the last good DEVMODE struct

    UINT cchCurPrinter;                // size, in chars, of pszCurPrinter
    LPTSTR pszCurPrinter;              // ptr to name of current printer

    DWORD nCopies;                     // number of copies
    DWORD nMaxCopies;                  // max number for the "number of copies"
    DWORD nPageRanges;                 // number of page ranges in pPageRange
    DWORD nMaxPageRanges;              // max number of page ranges allowed
    LPPRINTPAGERANGE pPageRanges;      // ptr to an array of page range structs

    BOOL fCollateRequested;            // collate is requested
    BOOL fSelChangePending;            // we have a selchange message pending
    BOOL fFirstSel;                    // still need to set first selection
    BOOL fAPWSelected;                 // add printer wizard is selected
    BOOL fNoAccessPrinterSelected;     // a printer we do not have access to is selected
    BOOL fDirtyDevmode;                // Set if we change the devmode while editing.
    BOOL fDevmodeEdit;                 // devmode editor is open
    BOOL fAllowCollate;                // whether collation is allowed by the device

    UINT nInitDone;                    // number of CDM_INITDONE messages

    UINT nListSep;                     // number of characters in szListSep
    TCHAR szListSep[20];               // list separator

    UINT uRegister;                    // change notify register

    TCHAR szScratch[kPrinterBufMax];   // scratch buffer
    UINT uDefViewMode;                 // How the default view mode is mapped

    LPDEVMODE pInternalDevMode;        // ptr to the internal DEVMODE
    TCHAR szPrinter[kPrinterBufMax];   // The internal printer name
    HANDLE hPrinter;                   // The internal printer
};




//
//  Context Help IDs.
//

DWORD aPrintExHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_PRINTER_LISTVIEW,    IDH_PRINT_PRINTER_FOLDER,

    IDC_STATUS_TEXT,         IDH_PRINT_SETUP_DETAILS,
    IDC_STATUS,              IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION_TEXT,       IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION,            IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT_TEXT,        IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT,             IDH_PRINT_SETUP_DETAILS,

    IDC_PRINT_TO_FILE,       IDH_PRINT_TO_FILE,
    IDC_FIND_PRINTER,        IDH_PRINT_FIND_PRINTER,
    IDC_DRIVER,              IDH_PRINT_PREFERENCES,

    grp2,                    NO_HELP,
    IDOK,                    IDH_PRINT_BTN,

    0, 0
};


DWORD aPrintExChildHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_RANGE_ALL,           IDH_PRINT32_RANGE,
    IDC_RANGE_SELECTION,     IDH_PRINT32_RANGE,
    IDC_RANGE_CURRENT,       IDH_PRINT32_RANGE,
    IDC_RANGE_PAGES,         IDH_PRINT32_RANGE,
    IDC_RANGE_EDIT,          IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT1,         IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT2,         IDH_PRINT32_RANGE,

    grp2,                    NO_HELP,
    IDC_COPIES,              IDH_PRINT_COPIES,
    IDC_COPIES_TEXT,         IDH_PRINT_COPIES,
    IDC_COLLATE,             IDH_PRINT_COLLATE,
    IDI_COLLATE,             IDH_PRINT_COLLATE,

    0, 0
};




//
//  Function Prototypes.
//

HRESULT
PrintDlgExX(
    PPRINTINFOEX pPI);

HRESULT
Print_ReturnDefault(
    PPRINTINFOEX pPI);

BOOL
Print_LoadLibraries();

VOID
Print_UnloadLibraries();

BOOL
Print_LoadIcons();

BOOL
Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD);

BOOL_PTR
Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR
Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

BOOL
Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam);

HRESULT
Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID *ppv);

BOOL
Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD);

VOID
Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer);

HANDLE
Print_GetDevModeWrapper(
    LPTSTR pszDeviceName,
    HANDLE hDevMode);

BOOL
Print_NewPrintDlg(
    PPRINTINFO pPI);


#ifdef UNICODE
  HRESULT
  ThunkPrintDlgEx(
      PPRINTINFOEX pPI,
      LPPRINTDLGEXA pPDA);

  VOID
  FreeThunkPrintDlgEx(
      PPRINTINFOEX pPI);

  VOID
  ThunkPrintDlgExA2W(
      PPRINTINFOEX pPI);

  VOID
  ThunkPrintDlgExW2A(
      PPRINTINFOEX pPI);
#endif

#endif   // WINNT

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\prnsetup.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.h

Abstract:

    This module contains the header information for the Win32 print dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

#ifndef WINNT
  #define COMDLG_ANSI     0x0
  #define COMDLG_WIDE     0x1
#endif

#define PI_PRINTERS_ENUMERATED    0x00000001
#define PI_COLLATE_REQUESTED      0x00000002
#define PI_WPAPER_ENVELOPE        0x00000004     // wPaper is DMPAPER_ENV_x
#define PI_PRINTDLGX_RECURSE      0x00000008     // PrintDlgX calls PrintDlgX

#define PRNPROP (LPCTSTR)         0xA000L

#define MMS_PER_INCH              254            // 25.4 mms/inch

#define INCHES_DEFAULT            1000
#define MMS_DEFAULT               2500

#define COPIES_EDIT_SIZE          4
#define PAGE_EDIT_SIZE            5
#define MARGIN_EDIT_SIZE          6

#define CCHPAPERNAME              64
#define CCHBINNAME                24

#define ROTATE_LEFT               270            // dot-matrix
#define ROTATE_RIGHT              90             // HP PCL

#define MAX_DEV_SECT              512
#define BACKSPACE                 0x08
#define CTRL_X_CUT                0x18
#define CTRL_C_COPY               0x03
#define CTRL_V_PASTE              0x16

#define SIZEOF_DEVICE_INFO        32

#define MAX_PRINTERNAME           (MAX_PATH * 2)

#define SCRATCHBUF_SIZE           256

#define MIN_DEVMODE_SIZEA         40             // from spooler\inc\splcom.h

#define MAX_COPIES                9999
#define IDC_COPIES_UDARROW        9999

//
//  Constant Declarations for DLG file.
//

#define ID_BOTH_P_PROPERTIES      psh2
#define ID_BOTH_P_NETWORK         psh14
#define ID_BOTH_P_HELP            pshHelp
#define ID_BOTH_S_PRINTER         stc6
#define ID_BOTH_S_STATUS          stc12
#define ID_BOTH_S_TYPE            stc11
#define ID_BOTH_S_WHERE           stc14
#define ID_BOTH_S_COMMENT         stc13

#define ID_PRINT_X_TOFILE         chx1
#define ID_PRINT_X_COLLATE        chx2
#define ID_PRINT_C_QUALITY        cmb1
#define ID_PRINT_C_NAME           cmb4
#define ID_PRINT_E_FROM           edt1
#define ID_PRINT_E_TO             edt2
#define ID_PRINT_E_COPIES         edt3
#define ID_PRINT_G_RANGE          grp1
#define ID_PRINT_G_COPIES         grp2
#define ID_PRINT_G_PRINTER        grp4
#define ID_PRINT_I_COLLATE        ico3
#define ID_PRINT_P_SETUP          psh1
#define ID_PRINT_R_ALL            rad1
#define ID_PRINT_R_SELECTION      rad2
#define ID_PRINT_R_PAGES          rad3
#define ID_PRINT_S_DEFAULT        stc1
#define ID_PRINT_S_FROM           stc2
#define ID_PRINT_S_TO             stc3
#define ID_PRINT_S_QUALITY        stc4
#define ID_PRINT_S_COPIES         stc5

#define ID_SETUP_C_NAME           cmb1
#define ID_SETUP_C_SIZE           cmb2
#define ID_SETUP_C_SOURCE         cmb3
#define ID_SETUP_E_LEFT           edt4
#define ID_SETUP_E_TOP            edt5
#define ID_SETUP_E_RIGHT          edt6
#define ID_SETUP_E_BOTTOM         edt7
#define ID_SETUP_G_ORIENTATION    grp1
#define ID_SETUP_G_PAPER          grp2
#define ID_SETUP_G_DUPLEX         grp3
#define ID_SETUP_G_MARGINS        grp4
#define ID_SETUP_I_ORIENTATION    ico1
#define ID_SETUP_I_DUPLEX         ico2
#define ID_SETUP_P_MORE           psh1
#define ID_SETUP_P_PRINTER        psh3
#define ID_SETUP_R_PORTRAIT       rad1
#define ID_SETUP_R_LANDSCAPE      rad2
#define ID_SETUP_R_DEFAULT        rad3
#define ID_SETUP_R_SPECIFIC       rad4
#define ID_SETUP_R_NONE           rad5
#define ID_SETUP_R_LONG           rad6
#define ID_SETUP_R_SHORT          rad7
#define ID_SETUP_S_DEFAULT        stc1
#define ID_SETUP_S_SIZE           stc2
#define ID_SETUP_S_SOURCE         stc3
#define ID_SETUP_S_LEFT           stc15
#define ID_SETUP_S_RIGHT          stc16
#define ID_SETUP_S_TOP            stc17
#define ID_SETUP_S_BOTTOM         stc18
#define ID_SETUP_W_SAMPLE         rct1
#define ID_SETUP_W_SHADOWRIGHT    rct2
#define ID_SETUP_W_SHADOWBOTTOM   rct3




//
//  Typedef Declarations.
//

typedef struct {
    UINT            ApiType;
    LPPRINTDLG      pPD;
    LPPAGESETUPDLG  pPSD;
    DWORD           cPrinters;
    PPRINTER_INFO_2 pPrinters;
    PPRINTER_INFO_2 pCurPrinter;
    HANDLE          hCurPrinter;
    DWORD           Status;
    TCHAR           szDefaultPrinter[MAX_PRINTERNAME];
    WORD            wPaper;
    DWORD           dwRotation;
    UINT            uiOrientationID;
    POINT           PtPaperSizeMMs;
    RECT            RtMinMarginMMs;
    RECT            RtMarginMMs;
    POINT           PtMargins;
    RECT            RtSampleXYWH;
    BOOL            bKillFocus;
    DWORD           ProcessVersion;
#ifdef UNICODE
    LPPRINTDLGA     pPDA;
    LPBOOL          pAllocInfo;
    BOOL            bUseExtDeviceMode;
    BOOL            fPrintTemplateAlloc;
    BOOL            fSetupTemplateAlloc;
    UINT            NestCtr;
#endif
} PRINTINFO, *PPRINTINFO;




//
//  Global Variables.
//

#ifndef WINNT
  UINT msgHELPA;
#endif


#ifndef WINNT
  typedef DWORD (WINAPI *LPFNWNETCONNECTIONDIALOG)(HWND, DWORD);
  LPFNWNETCONNECTIONDIALOG MPR_WNetConnectionDialog = NULL;
  CHAR szWNetConnectionDialog[] = "WNetConnectionDialog";
#endif


static TCHAR  szTextWindows[]     = TEXT("Windows");
static TCHAR  szTextDevices[]     = TEXT("devices");
static TCHAR  szTextDevice[]      = TEXT("device");
static TCHAR  szTextNull[]        = TEXT("");
static TCHAR  szFilePort[]        = TEXT("FILE:");
static TCHAR  szDriver[]          = TEXT("winspool");

#ifndef WINNT
  static TCHAR  szCommdlgHelp[]   = HELPMSGSTRING;
#endif


LPPRINTHOOKPROC glpfnPrintHook = NULL;
LPSETUPHOOKPROC glpfnSetupHook = NULL;

#ifdef WINNT
  WNDPROC lpEditNumOnlyProc = NULL;
#endif
WNDPROC lpEditMarginProc = NULL;
WNDPROC lpStaticProc = NULL;

HKEY hPrinterKey;
TCHAR *szRegistryPrinter = TEXT("Printers");
TCHAR *szRegistryDefaultValueName = TEXT("Default");

#ifndef WINNT
  HANDLE hMPR = NULL;
  TCHAR szMprDll[] = TEXT("mpr.dll");
#endif


static BOOL   bAllIconsLoaded = FALSE;         // if all icons/images loaded

static HANDLE hIconCollate = NULL;             // Image
static HANDLE hIconNoCollate = NULL;           // Image

static HICON  hIconPortrait = NULL;            // Icon
static HICON  hIconLandscape = NULL;           // Icon
static HICON  hIconPDuplexNone = NULL;         // Icon
static HICON  hIconLDuplexNone = NULL;         // Icon
static HICON  hIconPDuplexTumble = NULL;       // Icon
static HICON  hIconLDuplexTumble = NULL;       // Icon
static HICON  hIconPDuplexNoTumble = NULL;     // Icon
static HICON  hIconLDuplexNoTumble = NULL;     // Icon
static HICON  hIconPSStampP = NULL;            // Icon
static HICON  hIconPSStampL = NULL;            // Icon


static TCHAR  cIntlDecimal = CHAR_NULL;        // decimal separator (.)
static TCHAR  cIntlMeasure[5] = TEXT("");      // measurement designator ("/mm)
static int    cchIntlMeasure = 0;              // # of chars in cIntlMeasure
static TCHAR  szDefaultSrc[SCRATCHBUF_SIZE] = TEXT("");




//
//  Context Help IDs.
//

const static DWORD aPrintHelpIDs[] =             // Context Help IDs
{
    // for Print dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb4,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    chx1,  IDH_PRINT_TO_FILE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT32_RANGE,
    rad1,  IDH_PRINT32_RANGE,
    rad2,  IDH_PRINT32_RANGE,
    rad3,  IDH_PRINT32_RANGE,
    stc2,  IDH_PRINT32_RANGE,
    edt1,  IDH_PRINT32_RANGE,
    stc3,  IDH_PRINT32_RANGE,
    edt2,  IDH_PRINT32_RANGE,

    grp2,  NO_HELP,
    edt3,  IDH_PRINT_COPIES,
    ico3,  IDH_PRINT_COLLATE,
    chx2,  IDH_PRINT_COLLATE,

    // for win3.1 Print template

    stc1,  IDH_PRINT_SETUP_DETAILS,

    stc4,  IDH_PRINT_QUALITY,
    cmb1,  IDH_PRINT_QUALITY,

    stc5,  IDH_PRINT_COPIES,

    psh1,  IDH_PRINT_PRINTER_SETUP,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0,     0
};

const static DWORD aPrintSetupHelpIDs[] =        // Context Help IDs
{
    // for PrintSetup dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT_SETUP_ORIENT,
    rad1,  IDH_PRINT_SETUP_ORIENT,
    rad2,  IDH_PRINT_SETUP_ORIENT,

    // for win3.1 PrintSetup template

    grp3,  NO_HELP,
    stc1,  IDH_PRINT_CHOOSE_PRINTER,
    rad3,  IDH_PRINT_CHOOSE_PRINTER,
    rad4,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh1,  IDH_PRINT_PROPERTIES,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    // for winNT PrintSetup template

    grp2,  NO_HELP,                              // grp2 used for win31 help
    ico2,  IDH_PRINT_SETUP_DUPLEX,
    rad5,  IDH_PRINT_SETUP_DUPLEX,
    rad6,  IDH_PRINT_SETUP_DUPLEX,
    rad7,  IDH_PRINT_SETUP_DUPLEX,

    0,     0
};

const static DWORD aPageSetupHelpIDs[] =         // Context Help IDs
{
    rct1,  IDH_PAGE_SAMPLE,
    rct2,  IDH_PAGE_SAMPLE,
    rct3,  IDH_PAGE_SAMPLE,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    rad1,  IDH_PAGE_ORIENTATION,
    rad2,  IDH_PAGE_ORIENTATION,

    grp4,  NO_HELP,
    stc15, IDH_PAGE_MARGINS,
    edt4,  IDH_PAGE_MARGINS,
    stc16, IDH_PAGE_MARGINS,
    edt6,  IDH_PAGE_MARGINS,
    stc17, IDH_PAGE_MARGINS,
    edt5,  IDH_PAGE_MARGINS,
    stc18, IDH_PAGE_MARGINS,
    edt7,  IDH_PAGE_MARGINS,

    psh3,  IDH_PAGE_PRINTER,

    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0, 0
};




//
//  Macro Definitions.
//

#define IS_KEY_PRESSED(key)       ( GetKeyState(key) & 0x8000 )

#define ISDIGIT(c)                ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
//  SetField is used to modify new-for-ver-4.0 DEVMODE fields.
//  We don't have to worry about the GET case, because we always check for
//  the existance-of-field bit before looking at the field.
//
#define SetField(_pdm, _fld, _val)     \
        ((_pdm)->dmSpecVersion >= 0x0400 ? (((_pdm)->_fld = (_val)), TRUE) : FALSE)




#ifdef __cplusplus
extern "C" {
#endif



//
//  Function Prototypes.
//

BOOL
PrintDlgX(
    PPRINTINFO pPI);

BOOL
PageSetupDlgX(
    PPRINTINFO pPI);

BOOL
PrintLoadIcons();

int
PrintDisplayPrintDlg(
    PPRINTINFO pPI);

int
PrintDisplaySetupDlg(
    PPRINTINFO pPI);

BOOL_PTR CALLBACK
PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR CALLBACK
PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
PrintEditNumberOnlyProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

HANDLE
PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType);

VOID
PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize);

BOOL
PrintReturnDefault(
    PPRINTINFO pPI);

BOOL
PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

DWORD
PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

DWORD
PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

VOID
PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent);

BOOL
PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id);

VOID
PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI);

VOID
PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue);

VOID
PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample);

BOOL
PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD);

BOOL
PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner);

VOID
PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality);

VOID
PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

VOID
PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI);

BOOL
PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD);

PPRINTER_INFO_2
PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName);

#ifdef UNICODE
  VOID
  PrintGetExtDeviceMode(
      HWND hDlg,
      PPRINTINFO pPI);
#endif

BOOL
PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters);

VOID
PrintBuildDevNames(
    PPRINTINFO pPI);

HANDLE
PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode);

VOID
PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM);

VOID
PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis);

VOID
PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM);

VOID
PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad);

VOID
PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2);

VOID
PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...);

VOID
PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

BOOL
PrintClosePrinters(
    PPRINTINFO pPI);

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl);

#ifdef UNICODE
  VOID
  UpdateSpoolerInfo(
      PPRINTINFO pPI);
#endif

PPRINTER_INFO_2
PrintGetPrinterInfo2(
    HANDLE hPrinter);

int
ConvertStringToInteger(
    LPCTSTR pSrc);

VOID
FreePrinterArray(
    PPRINTINFO pPI);

VOID
TermPrint(void);

VOID
TransferPSD2PD(
    PPRINTINFO pPI);

VOID
TransferPD2PSD(
    PPRINTINFO pPI);

#ifdef UNICODE
  VOID
  TransferPSD2PDA(
      PPRINTINFO pPI);

  VOID
  TransferPDA2PSD(
      PPRINTINFO pPI);

  BOOL
  ThunkPageSetupDlg(
      PPRINTINFO pPI,
      LPPAGESETUPDLGA pPSDA);

  VOID
  FreeThunkPageSetupDlg(
      PPRINTINFO pPI);

  BOOL
  ThunkPrintDlg(
      PPRINTINFO pPI,
      LPPRINTDLGA pPDA);

  VOID
  FreeThunkPrintDlg(
      PPRINTINFO pPI);

  VOID
  ThunkPrintDlgA2W(
      PPRINTINFO pPI);

  VOID
  ThunkPrintDlgW2A(
      PPRINTINFO pPI);

  VOID
  ThunkDevModeA2W(
      LPDEVMODEA pDMA,
      LPDEVMODEW pDMW);

  VOID
  ThunkDevModeW2A(
      LPDEVMODEW pDMW,
      LPDEVMODEA pDMA);

  LPDEVMODEW
  AllocateUnicodeDevMode(
      LPDEVMODEA pANSIDevMode);

  LPDEVMODEA
  AllocateAnsiDevMode(
      LPDEVMODEW pUnicodeDevMode);

  WORD
  CountDigits(
      DWORD dwNumber);
#endif


#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(CCSHELL_DIR)\common.inc

INCLUDES = $(CCSHELL_DIR)\comdlg32;$(INCLUDES);$(PRINTSCAN_INC_PATH);$(NET_INC_PATH)

# need to wait on ..\ntcpp\$O\srccpp.lib
SYNCHRONIZE_DRAIN = 1

TARGETNAME    = comdlg32
TARGETPATH    = obj
TARGETTYPE    = DYNLINK

#VERIFY_LC     = 1
LC_PATH       = $(PROJECT_ROOT)\lcinf

PASS1_PUBLISH={$(O)\comdlg32.lib=$(SDK_LIB_PATH)\comdlg32.lib}

TARGETLIBS = $(SHELL_LIB_PATH)\shlwapip.lib             \
             $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib    \
             $(LIBRARY_PLATFORM_PATH)\*\user32.lib      \
             $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib       \
             $(SDK_LIB_PATH)\advapi32.lib               \
             $(SDK_LIB_PATH)\ole32.lib                  \
             $(SDK_LIB_PATH)\version.lib                \
             $(SDK_LIB_PATH)\imm32.lib                  \
             $(SHELL_LIB_PATH)\comctlp.lib              \
             $(SDK_LIB_PATH)\shell32.lib                \
             $(SHELL_LIB_PATH)\shell32p.lib             \
             $(NET_LIB_PATH)\mprp.lib                   \
             $(SDK_LIB_PATH)\winspool.lib               \
             $(SDK_LIB_PATH)\uuid.lib                   \
             $(SDK_LIB_PATH)\uxtheme.lib                \
             $(CCSHELL_DIR)\lib\$(O)\shguidp.lib        \
             $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib        \
             $(CCSHELL_DIR)\lib\$(O)\stock.lib

DELAYLOAD = winspool.drv;UxTheme.dll;ole32.dll;version.dll;imm32.dll;mpr.dll
DLOAD_ERROR_HANDLER = kernel32

LINKLIBS = ..\ntcpp\$O\srccpp.lib

DLLDEF   = $(O)\comdlg32.def

DLLENTRY = LibMain

SOURCES = ..\comdlg32.rc  \
          ..\color.c      \
          ..\color2.c     \
          ..\data.c       \
          ..\dlgs.c       \
          ..\fileopen.c   \
          ..\find.c       \
          ..\font.c       \
          ..\init.c       \
          ..\parse.c      \
          ..\prnsetup.c   \
          ..\debug.c

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\srccpp.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(CCSHELL_DIR)\common.inc

TARGETNAME = srccpp
TARGETPATH = obj
TARGETTYPE = LIBRARY

SOURCES    = ..\filemru.cpp     \
             ..\filenew.cpp     \
             ..\printnew.cpp    \
             ..\d32tlog.cpp     \
             ..\util.cpp
	
INCLUDES=$(INCLUDES);$(PRINTSCAN_INC_PATH);$(NET_INC_PATH)

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\util.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module implements utility functions for the common dialog.

Revision History:
    02-20-98          arulk                 created

--*/
#ifndef _UTIL_H_
#define _UTIL_H_

#include <shlobjp.h>


////////////////////////////////////////////////////////////////////////////
//  Autocomplete 
//
////////////////////////////////////////////////////////////////////////////
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags);

////////////////////////////////////////////////////////////////////////////
//  Common Dilaog Restrictions
//
////////////////////////////////////////////////////////////////////////////
typedef enum
{
    REST_NULL                       = 0x00000000,
    REST_NOBACKBUTTON               = 0x00000001,
    REST_NOFILEMRU                  = 0x00000002,
    REST_NOPLACESBAR                = 0x00000003,
}COMMDLG_RESTRICTIONS;

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest);
BOOL ILIsFTP(LPCITEMIDLIST pidl);

////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
////////////////////////////////////////////////////////////////////////////

#define CDBindToObject          SHBindToObject
#define CDBindToIDListParent    SHBindToParent
#define CDGetNameAndFlags       SHGetNameAndFlags
#define CDGetAttributesOf       SHGetAttributesOf
#define CDGetUIObjectFromFullPIDL SHGetUIObjectFromFullPIDL

//CDGetAppCompatFlags
#define CDACF_MATHCAD             0x00000001
#define CDACF_NT40TOOLBAR         0x00000002
#define CDACF_FILETITLE           0x00000004

EXTERN_C DWORD CDGetAppCompatFlags();
EXTERN_C HRSRC FindResourceExFallback(HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\util.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.cpp

Abstract:

    This module implements utility functions for the common dialog.

Author:

    Arul Kumaravel              (arulk@microsoft.com)

History:

    Mar-07-2001 - Lazar Ivanov (LazarI) 
        reimplemented ThunkDevNamesW2A & ThunkDevNamesA2W

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "fileopen.h"
#include "filenew.h"
#include "util.h"

// crtfree.h is located in shell\inc and it defines new and delete
// operators to do LocalAlloc and LocalFree, so you don't have to
// link to MSVCRT in order to get those. i tried to remove this code
// and link to MSVCRT, but there are some ugly written code here 
// which relies on the new operator to zero initialize the returned
// memory block so the class don't bother to initialize its members
// in the constructor. as i said this is quite ugly, but nothing i can
// do about this at the moment.
//
// LazarI - 2/21/2001
//
#define DECL_CRTFREE
#include <crtfree.h>

#ifndef ASSERT
#define ASSERT Assert
#endif

#define EVAL(x)     x

#define USE_AUTOCOMPETE_DEFAULT         TRUE
#define SZ_REGKEY_USEAUTOCOMPLETE       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_FILEDLGAUTOCOMPLETE TEXT("AutoComplete In File Dialog")
#define BOOL_NOT_SET                        0x00000005
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")

/****************************************************\
    FUNCTION: AutoComplete

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.
\****************************************************/
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    IUnknown * punkACLISF;
    static BOOL fUseAutoComplete = -10; // Not inited.
    
    if (-10 == fUseAutoComplete)
        fUseAutoComplete = (SHRegGetBoolUSValue(SZ_REGKEY_USEAUTOCOMPLETE, SZ_REGVALUE_FILEDLGAUTOCOMPLETE, FALSE, USE_AUTOCOMPETE_DEFAULT));

    // WARNING: If you want to disable AutoComplete by default, 
    //          turn USE_AUTOCOMPETE_DEFAULT to FALSE
    if (fUseAutoComplete)
    {
        Assert(!dwFlags);	// Not yet used.
        hr = SHCoCreateInstance(NULL, &CLSID_ACListISF, NULL, IID_PPV_ARG(IUnknown, &punkACLISF));
        if (SUCCEEDED(hr))
        {
            IAutoComplete2 * pac;
            // Create the AutoComplete Object
            hr = SHCoCreateInstance(NULL, &CLSID_AutoComplete, NULL, IID_PPV_ARG(IAutoComplete2, &pac));
            if (SUCCEEDED(hr))
            {
                DWORD dwOptions = 0;

                hr = pac->Init(hwndEdit, punkACLISF, NULL, NULL);

                // Set the autocomplete options
                if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
                {
                    dwOptions |= ACO_AUTOAPPEND;
                }

                if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
                {
                    dwOptions |= ACO_AUTOSUGGEST;
                }

                // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
                // operating systems that use AutoComplete have traditionally used the TAB key to
                // iterate thru the AutoComplete possibilities.  We need to default to disable the
                // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
                // turn it on 
                static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
                if (BOOL_NOT_SET == s_fAlwaysUseTab)
                    s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_USEAUTOCOMPLETE, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
                    
                if (s_fAlwaysUseTab)
                    dwOptions |= ACO_USETAB;
                    
                EVAL(SUCCEEDED(pac->SetOptions(dwOptions)));

                pac->Release();
            }

            if (ppcwd)
            {
                punkACLISF->QueryInterface(IID_PPV_ARG(ICurrentWorkingDirectory, ppcwd));
            }

            punkACLISF->Release();
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// 
//  Common Dialog Administrator Restrictions
//
////////////////////////////////////////////////////////////////////////////

const SHRESTRICTIONITEMS c_rgRestItems[] =
{
    {REST_NOBACKBUTTON,            L"Comdlg32", L"NoBackButton"},
    {REST_NOFILEMRU ,              L"Comdlg32", L"NoFileMru"},
    {REST_NOPLACESBAR,             L"Comdlg32", L"NoPlacesBar"},
    {0, NULL, NULL},
};

#define NUMRESTRICTIONS  ARRAYSIZE(c_rgRestItems)


DWORD g_rgRestItemValues[NUMRESTRICTIONS - 1 ] = { -1 };

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest)
{
    static BOOL bFirstTime = TRUE;

    if (bFirstTime)
    {
        memset((LPBYTE)g_rgRestItemValues, (BYTE)-1, sizeof(g_rgRestItemValues));
        bFirstTime = FALSE;
    }
    return SHRestrictionLookup(rest, NULL, c_rgRestItems, g_rgRestItemValues);
}

#define MODULE_NAME_SIZE    128
#define MODULE_VERSION_SIZE  15

typedef struct tagAPPCOMPAT
{
    LPCTSTR pszModule;
    LPCTSTR pszVersion;
    DWORD  dwFlags;
} APPCOMPAT, FAR* LPAPPCOMPAT;
    
DWORD CDGetAppCompatFlags()
{
    static BOOL  bInitialized = FALSE;
    static DWORD dwCachedFlags = 0;
    static const APPCOMPAT aAppCompat[] = 
    {   //Mathcad
        {TEXT("MCAD.EXE"), TEXT("6.00b"), CDACF_MATHCAD},
        //Picture Publisher
        {TEXT("PP70.EXE"),NULL, CDACF_NT40TOOLBAR},
        {TEXT("PP80.EXE"),NULL, CDACF_NT40TOOLBAR},
        //Code Wright
        {TEXT("CW32.exe"),TEXT("5.1"), CDACF_NT40TOOLBAR},
        //Designer.exe
        {TEXT("ds70.exe"),NULL, CDACF_FILETITLE}
    };
    
    if (!bInitialized)
    {    
        TCHAR  szModulePath[MODULE_NAME_SIZE];
        TCHAR* pszModuleName;
        DWORD  dwHandle;
        int i;

        GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath));
        pszModuleName = PathFindFileName(szModulePath);

        if (pszModuleName)
        {
            for (i=0; i < ARRAYSIZE(aAppCompat); i++)
            {
                if (lstrcmpi(aAppCompat[i].pszModule, pszModuleName) == 0)
                {
                    if (aAppCompat[i].pszVersion == NULL)
                    {
                        dwCachedFlags = aAppCompat[i].dwFlags;
                    }
                    else
                    {
                        CHAR  chBuffer[3072]; // hopefully this is enough... lotus smart center needs 3000
                        TCHAR* pszVersion = NULL;
                        UINT  cb;

                        // get module version here!
                        cb = GetFileVersionInfoSize(szModulePath, &dwHandle); 
                        if (cb <= ARRAYSIZE(chBuffer) &&
                            GetFileVersionInfo(szModulePath, dwHandle, ARRAYSIZE(chBuffer), (LPVOID)chBuffer) &&
                            VerQueryValue((LPVOID)chBuffer, TEXT("\\StringFileInfo\\040904E4\\ProductVersion"), (void **) &pszVersion, &cb))
                        {   
                            DebugMsg(0x0004, TEXT("product: %s\n version: %s"), pszModuleName, pszVersion);
                            if (lstrcmpi(pszVersion, aAppCompat[i].pszVersion) == 0)
                            {
                                dwCachedFlags = aAppCompat[i].dwFlags;
                                break;
                            }
                        }
                    }
                }
            }
        }
        bInitialized = TRUE;
    }
    
    return dwCachedFlags; 
}


BOOL ILIsFTP(LPCITEMIDLIST pidl)
{
    IShellFolder * psf;
    BOOL fIsFTPFolder = FALSE;

    if (SUCCEEDED(CDBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf))))
    {
        CLSID clsid;

        if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) &&
            (IsEqualIID(clsid, CLSID_FtpFolder)))
        {
            fIsFTPFolder = TRUE;
        }

        psf->Release();
    }

    return fIsFTPFolder;
}

#ifdef __cplusplus
extern "C" {
#endif

// this is weak.
// a long time ago somebody changed all the FindResources to call FindResourceEx, specifying
// a language.  thatd be cool except FindResource already has logic to get the right language.
// whatever was busted should have probably been fixed some other way.
// not only that but it's broken because MUI needs to fall back to US if it can't get the resource
// from the MUI language-specific files.
// thus force a fallback to US.  really everything should be rewritten to be normal like every other
// DLL but there's a lot of weird TLS stuff that would break and its risky for this late in XP.
HRSRC FindResourceExFallback(HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage)
{
    HRSRC hrsrc = FindResourceEx(hModule, lpType, lpName, wLanguage);
    if (!hrsrc)
    {
        LANGID langid = GetSystemDefaultUILanguage();
        if (langid && (langid != wLanguage))
        {
            hrsrc = FindResourceEx(hModule, lpType, lpName, langid);
        }
    }
    return hrsrc;
}

// Win32Error2HRESULT: converts Win32 error to HRESULT
inline HRESULT Win32Error2HRESULT(DWORD dwError = GetLastError())
{
    return (ERROR_SUCCESS == dwError) ? E_FAIL : HRESULT_FROM_WIN32(dwError);
}

/*++

Routine Name:

    ThunkDevNamesA2W

Routine Description:

    Converts ANSI DEVNAMES structure to UNICODE
    on failure we don't release *phDevNamesW

Arguments:

    hDevNamesA  - [in]   handle to ANSI DEVNAMES
    phDevNamesW - [in, out]  handle to UNICODE DEVNAMES

Return Value:

    S_OK if succeded and OLE error otherwise

History:

    Lazar Ivanov (LazarI), Mar-07-2001 - created.

--*/

HRESULT
ThunkDevNamesA2W(
    IN      HGLOBAL hDevNamesA,
    IN OUT  HGLOBAL *phDevNamesW
    )
{
    HRESULT hr = E_FAIL;
    if (hDevNamesA && phDevNamesW)
    {
        LPDEVNAMES pDNA = (LPDEVNAMES )GlobalLock(hDevNamesA);
        if (pDNA)
        {
            // calculate the input string pointers
            LPSTR pszDriver = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDriverOffset;
            LPSTR pszDevice = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDeviceOffset;
            LPSTR pszOutput = reinterpret_cast<LPSTR>(pDNA) + pDNA->wOutputOffset;

            // calculate the lengths of the ANSI strings
            SIZE_T iDriverLenW = MultiByteToWideChar(CP_ACP, 0, pszDriver, -1, NULL, 0);
            SIZE_T iDeviceLenW = MultiByteToWideChar(CP_ACP, 0, pszDevice, -1, NULL, 0);
            SIZE_T iOutputLenW = MultiByteToWideChar(CP_ACP, 0, pszOutput, -1, NULL, 0);

            // calculate the output buffer length
            SIZE_T iBytesTotal = sizeof(DEVNAMES) + sizeof(WCHAR) * 
                ((iDriverLenW + 1) + (iDeviceLenW + 1) + (iOutputLenW + 1) + DN_PADDINGCHARS);

            HGLOBAL hDevNamesW = (*phDevNamesW) ? 
                                    GlobalReAlloc(*phDevNamesW, iBytesTotal, GHND) :
                                    GlobalAlloc(GHND, iBytesTotal);

            if (hDevNamesW)
            {
                // thunk DEVNAMES...
                LPDEVNAMES pDNW = (LPDEVNAMES )GlobalLock(hDevNamesW);
                if (pDNW)
                {
                    // calculate the offsets 
                    // note: the offsets are in chars not bytes!!
                    pDNW->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
                    pDNW->wDeviceOffset = pDNW->wDriverOffset + iDriverLenW + 1;
                    pDNW->wOutputOffset = pDNW->wDeviceOffset + iDeviceLenW + 1;
                    pDNW->wDefault = pDNA->wDefault;

                    // calculate the output string pointers
                    LPWSTR pwszDriver = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDriverOffset;
                    LPWSTR pwszDevice = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDeviceOffset;
                    LPWSTR pwszOutput = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wOutputOffset;

                    // convert from ansi to uniciode
                    MultiByteToWideChar(CP_ACP, 0, pszDriver, -1, pwszDriver, iDriverLenW + 1);
                    MultiByteToWideChar(CP_ACP, 0, pszDevice, -1, pwszDevice, iDeviceLenW + 1);
                    MultiByteToWideChar(CP_ACP, 0, pszOutput, -1, pwszOutput, iOutputLenW + 1);

                    // unlock hDevNamesW
                    GlobalUnlock(hDevNamesW);

                    // declare success
                    *phDevNamesW = hDevNamesW;
                    hr = S_OK;
                }
                else
                {
                    // GlobalLock failed
                    hr = Win32Error2HRESULT(GetLastError());
                    GlobalFree(hDevNamesW);
                }
            }
            else
            {
                // GlobalAlloc failed
                hr = E_OUTOFMEMORY;
            }

            // unlock hDevNamesA
            GlobalUnlock(hDevNamesA);
        }
        else
        {
            // GlobalLock failed
            hr = Win32Error2HRESULT(GetLastError());
        }
    }
    else
    {
        // some of the arguments are invalid (NULL)
        hr = E_INVALIDARG;
    }
    return hr;
}

/*++

Routine Name:

    ThunkDevNamesW2A

Routine Description:

    Converts UNICODE DEVNAMES structure to ANSI
    on failure we don't release *phDevNamesA

Arguments:

    hDevNamesW  - [in]   handle to UNICODE DEVNAMES
    phDevNamesA - [in, out]  handle to ANSI DEVNAMES

Return Value:

    S_OK if succeded and OLE error otherwise

History:

    Lazar Ivanov (LazarI), Mar-07-2001 - created.

--*/
HRESULT
ThunkDevNamesW2A(
    IN      HGLOBAL hDevNamesW,
    IN OUT  HGLOBAL *phDevNamesA
    )
{
    HRESULT hr = E_FAIL;
    if (hDevNamesW && phDevNamesA)
    {
        LPDEVNAMES pDNW = (LPDEVNAMES)GlobalLock(hDevNamesW);
        if (pDNW)
        {
            // calculate the input string pointers
            LPWSTR pwszDriver = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDriverOffset;
            LPWSTR pwszDevice = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDeviceOffset;
            LPWSTR pwszOutput = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wOutputOffset;

            // calculate the lengths of the ANSI strings
            SIZE_T iDriverLenA = WideCharToMultiByte(CP_ACP, 0, pwszDriver, -1, NULL, 0, NULL, NULL);
            SIZE_T iDeviceLenA = WideCharToMultiByte(CP_ACP, 0, pwszDevice, -1, NULL, 0, NULL, NULL);
            SIZE_T iOutputLenA = WideCharToMultiByte(CP_ACP, 0, pwszOutput, -1, NULL, 0, NULL, NULL);

            // calculate the output buffer length
            SIZE_T iBytesTotal = sizeof(DEVNAMES) + sizeof(CHAR) * 
                ((iDriverLenA + 1) + (iDeviceLenA + 1) + (iOutputLenA + 1) + DN_PADDINGCHARS);

            HGLOBAL hDevNamesA = (*phDevNamesA) ? 
                                    GlobalReAlloc(*phDevNamesA, iBytesTotal, GHND) :
                                    GlobalAlloc(GHND, iBytesTotal);
            if (hDevNamesA)
            {
                // thunk DEVNAMES...
                LPDEVNAMES pDNA = (LPDEVNAMES )GlobalLock(hDevNamesA);
                if (pDNA)
                {
                    // calculate the offsets 
                    // note: the offsets are in chars not bytes!!
                    pDNA->wDriverOffset = sizeof(DEVNAMES) / sizeof(CHAR);
                    pDNA->wDeviceOffset = pDNA->wDriverOffset + iDriverLenA + 1;
                    pDNA->wOutputOffset = pDNA->wDeviceOffset + iDeviceLenA + 1;
                    pDNA->wDefault = pDNW->wDefault;

                    // calculate the output string pointers
                    LPSTR pszDriver = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDriverOffset;
                    LPSTR pszDevice = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDeviceOffset;
                    LPSTR pszOutput = reinterpret_cast<LPSTR>(pDNA) + pDNA->wOutputOffset;

                    // convert from uniciode to ansi
                    WideCharToMultiByte(CP_ACP, 0, pwszDriver, -1, pszDriver, iDriverLenA + 1, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, pwszDevice, -1, pszDevice, iDeviceLenA + 1, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, pwszOutput, -1, pszOutput, iOutputLenA + 1, NULL, NULL);

                    // unlock hDevNamesA
                    GlobalUnlock(hDevNamesA);

                    // declare success
                    *phDevNamesA = hDevNamesA;
                    hr = S_OK;
                }
                else
                {
                    // GlobalLock failed
                    hr = Win32Error2HRESULT(GetLastError());
                    GlobalFree(hDevNamesW);
                }
            }
            else
            {
                // GlobalAlloc failed
                hr = E_OUTOFMEMORY;
            }

            // unlock hDevNamesW
            GlobalUnlock(hDevNamesW);
        }
        else
        {
            // GlobalLock failed
            hr = Win32Error2HRESULT(GetLastError());
        }
    }
    else
    {
        // some of the arguments are invalid (NULL)
        hr = E_INVALIDARG;
    }
    return hr;
}

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comdlg32\win95\i386\dlgthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Aug 29 16:36:45 1996

;Command Line: ..\..\..\dev\tools\binr\thunk.exe -NC THUNK16B -o dlgthk ..\dlgthk.thk 

	TITLE	$dlgthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16 -DIS_32
.err
ENDIF
ENDIF
IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF
	.model FLAT,STDCALL

externDef STDCALL DlgThunkInit@4:near32
externDef STDCALL ThkPathQualify@4:near32
externDef STDCALL ThkParseFile@8:near32
externDef STDCALL GetFileTitleI@16:near32
externDef STDCALL ThkCommDlgExtendedError@0:near32
externDef STDCALL ThkChooseFont@4:near32
externDef STDCALL ThkChooseColor@4:near32
externDef STDCALL ThkGetSaveFileName@4:near32
externDef STDCALL ThkGetOpenFileName@4:near32

externDef C Common32ThkLS:near32

	.data

pfndlgthkCommon	equ	<pfndlgthkTable>
public pfndlgthkTable
pfndlgthkTable	dword	0		; segmented common entry point
dlgthkConnectionNameLS	db	'dlgthkConnectionDataLS',0

public	dlgthkLSChecksum32
dlgthkLSChecksum32	equ	0b53eh

	.code 

;===========================================================================
; Worker routine to pass additional, internal params to the
; init routine in kernel32.
;
; Calling sequence:
;
; dlgthkConnectPeerLS proto near pszDll16:dword, pszDll32:dword
;
; pszDll16	db	'foo16.dll',0
; pszDll32	db	'foo32.dll',0
;
;	invoke	dlgthkConnectPeerLS, ADDR pszDll16, ADDR pszDll32
;	or	eax,eax
;	jz	failed
;	;success
;
public dlgthkConnectPeerLS@8
dlgthkConnectPeerLS@8:
externDef ThunkInitLS@20:near32
	pop	edx				;Shift return address
	push	dword ptr 0b53eh		;Checksum
	push	offset dlgthkConnectionNameLS	;Exported from peer
	push	offset pfndlgthkCommon		;Output param
	push	edx
	jmp	ThunkInitLS@20

;===========================================================================
; This is the table of 32-bit entry points.
DlgThunkInit@4 label near32
	mov	cl,0			; offset in jump table
	mov	edx, (1 SHL 16) + 0
PreEntryCommon32_1:
	mov	ch,0
	jmp	EntryCommon32
ThkPathQualify@4 label near32
	mov	cl,2			; offset in jump table
	mov	edx, (1 SHL 16) + 0
	jmp	PreEntryCommon32_1
ThkParseFile@8 label near32
	mov	cl,4			; offset in jump table
	mov	edx, (2 SHL 16) + 0
	jmp	PreEntryCommon32_1
GetFileTitleI@16 label near32
	mov	cl,6			; offset in jump table
	mov	edx, (4 SHL 16) + 65535
	jmp	PreEntryCommon32_1
ThkCommDlgExtendedError@0 label near32
	mov	cl,8			; offset in jump table
	mov	edx, (0 SHL 16) + 0
	jmp	PreEntryCommon32_1
ThkChooseFont@4 label near32
	mov	cl,10			; offset in jump table
	mov	edx, (1 SHL 16) + 0
	jmp	PreEntryCommon32_1
ThkChooseColor@4 label near32
	mov	cl,12			; offset in jump table
	mov	edx, (1 SHL 16) + 0
	jmp	PreEntryCommon32_1
ThkGetSaveFileName@4 label near32
	mov	cl,14			; offset in jump table
	mov	edx, (1 SHL 16) + 0
	jmp	PreEntryCommon32_1
ThkGetOpenFileName@4 label near32
	mov	cl,16			; offset in jump table
	mov	edx, (1 SHL 16) + 0
	jmp	PreEntryCommon32_1
;===========================================================================
; This is the common setup code for 32=>16 thunks.
; 
; Entry:  cx = offset in thunk table
;         dx = signed error return value
;         edx.hi = # of parameters (4 bytes per parameter)
; 
; Exit:   eax = 16:16 address of target common entry point
;
align
EntryCommon32:
ifdef FSAVEALL
.err	;32->16 thunks require FSAVEALL, else don't use -r
endif

	mov	eax, pfndlgthkCommon
	jmp	Common32ThkLS
THK_CODE32_SIZE label byte
ELSE	; IS_16
	OPTION SEGMENT:USE16
	.model LARGE,PASCAL

include thk.inc
include winerror.inc
include win31err.inc
include dlgthk.inc

externDef DlgThunkInit:far16
externDef PathQualify:far16
externDef ParseFileFrom32:far16
externDef GetFileTitleI:far16
externDef CommDlgExtendedError:far16
externDef ChooseFont:far16
externDef ChooseColor:far16
externDef GetSaveFileName:far16
externDef GetOpenFileName:far16
externDef UnMapStackAndMakeFlat:far16
externDef LinearToSelectorOffset:far16
externDef MapLS:far16
externDef UnmapLS:far16
externDef StackLinearToSegmented:far16
externDef SelectorOffsetToLinear:far16
externDef MapSL:far16
externDef AllocCallback:far16
externDef GetCSAlias:far16
externDef FreeCSAlias:far16
externDef OutputDebugString:far16
externDef SetLastError:far16
externDef THUNK16BCodeData:word
externDef FlatData:word
externDef dlgthkTable:dword
externDef dlgthkCommon:far16
externDef LocalAlloc:far16
externDef LocalLock:far16
externDef LocalUnlock:far16
externDef LocalFree:far16
MYLOCALLOCK macro x
	push ecx
	push ebx
	push x
	call LocalLock
	pop ebx
	pop ecx
	endm

externDef T_DlgThunkInit:near16
externDef T_ThkPathQualify:near16
externDef T_ThkParseFile:near16
externDef T_GetFileTitleI:near16
externDef T_ThkCommDlgExtendedError:near16
externDef T_ThkChooseFont:near16
externDef T_ThkChooseColor:near16
externDef T_ThkGetSaveFileName:near16
externDef T_ThkGetOpenFileName:near16

DATA16 SEGMENT WORD USE16 PUBLIC 'DATA'
DATA16 ENDS

	.code THUNK16B

public dlgthkConnectionDataLS	; export in def file
dlgthkConnectionDataLS	dd	0b53eh	;Checksum
			dw	offset dlgthkCommon
			dw	seg dlgthkCommon

;===========================================================================
; This is a jump table to API-specific 16-bit thunk code.
; Each entry is a word.

align
dlgthkTable16 label word
	dw	offset T_DlgThunkInit
	dw	offset T_ThkPathQualify
	dw	offset T_ThkParseFile
	dw	offset T_GetFileTitleI
	dw	offset T_ThkCommDlgExtendedError
	dw	offset T_ThkChooseFont
	dw	offset T_ThkChooseColor
	dw	offset T_ThkGetSaveFileName
	dw	offset T_ThkGetOpenFileName

;===========================================================================
; This is the common 16-bit entry point for 32=>16 thunks.  It:
;     1. saves sp in bp
;     2. sets ds
;     3. jumps to API-specific thunk code
;
; Entry:  di    == jump table offset
;         ss:sp == 16-bit stack pointer
align
dlgthkCommon label far16

	mov	bp,sp			; save sp in bp
	mov	ax,seg DATA16		; set ds
	mov	ds,ax
	jmp	word ptr cs:dlgthkTable16[di]  ; select specific thunk

;===========================================================================
; Macro sets extended error code if Win16 API returned an
; error value.
;
; Inputs:
;    errret:   32-bit API return value that signals an error
;    errle:    32-bit extended error code to pass to SetLastError()
;    exitlbl:  The Exit_n label to jump to.
;    eax:      The 32-bit API return value.
;
ERRCHK_EXIT	macro	errret,errle,exitlbl
	cmp	eax,&errret&
	jne	&exitlbl&
	push	eax	;Save return value.
	pushd	&errle&	;ARG: SetLastError(errorcode)
	call	SetLastError
	pop	eax	;Restore return value.
	jmp	&exitlbl&
endm ;ERRCHK_EXIT
;===========================================================================
; Common routines to restore the stack and registers
; and return to 32-bit code.  There is one for each
; size of 32-bit parameter list in this script.

align
Exit_0:
;--- No error checking.
	mov	bl,0		; parameter byte count
	mov	sp,bp		; point to ret addr
	retd			; 16:32 ret to dispatcher
align
Exit_4:
;--- No error checking.
	mov	bl,4		; parameter byte count
	mov	sp,bp		; point to ret addr
	retd			; 16:32 ret to dispatcher
align
Exit_8:
;--- No error checking.
	mov	bl,8		; parameter byte count
	mov	sp,bp		; point to ret addr
	retd			; 16:32 ret to dispatcher
align
Exit_16:
;--- No error checking.
	mov	bl,16		; parameter byte count
	mov	sp,bp		; point to ret addr
	retd			; 16:32 ret to dispatcher
;===========================================================================
T_DlgThunkInit label near16

; bp+40   pCB32Tab

	APILOGLS	DlgThunkInit

;-------------------------------------
; create new call frame and make the call

; pCB32Tab  from: unsigned long
	push	dword ptr [bp+40]	; to unsigned long

	call	DlgThunkInit		; call 16-bit version

; return code void --> void
; no conversion needed

;-------------------------------------
;--- No error checking.
	jmp	Exit_4


;===========================================================================
T_ThkPathQualify label near16

; bp+40   lpszFile

	APILOGLS	ThkPathQualify

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax			; ptr param #1   lpszFile
;-------------------------------------
; *** BEGIN parameter packing

; lpszFile
; pointer char --> char
; same pointer types
	mov	eax,[bp+40]		; base address
	push	eax
	call	MapLS
	mov	[bp-4],eax
L0:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpszFile  from: char
	push	dword ptr [bp-4]	; to: char

	call	PathQualify		; call 16-bit version

; return code unsigned long --> unsigned long
	rol	eax,16
	xchg	ax,dx
	rol	eax,16

	push	eax
	push	dword ptr [bp - 4]
	call	UnmapLS
	pop	eax
;-------------------------------------
;--- No error checking.
	jmp	Exit_4


;===========================================================================
T_ThkParseFile label near16

; bp+40   lpszFile
; bp+44   dwFlags

	APILOGLS	ThkParseFile

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax			; ptr param #1   lpszFile
;-------------------------------------
; *** BEGIN parameter packing

; lpszFile
; pointer char --> char
; same pointer types
	mov	eax,[bp+40]		; base address
	push	eax
	call	MapLS
	mov	[bp-4],eax
L1:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpszFile  from: char
	push	dword ptr [bp-4]	; to: char

; dwFlags  from: unsigned long
	push	dword ptr [bp+44]	; to unsigned long

	call	ParseFileFrom32		; call 16-bit version

; return code unsigned long --> unsigned long
	rol	eax,16
	xchg	ax,dx
	rol	eax,16

	push	eax
	push	dword ptr [bp - 4]
	call	UnmapLS
	pop	eax
;-------------------------------------
;--- No error checking.
	jmp	Exit_8


;===========================================================================
T_GetFileTitleI label near16

; bp+40   lpszFile
; bp+44   lpszTitle
; bp+48   wBufSize
; bp+52   dwFlags

	APILOGLS	GetFileTitleI

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax			; ptr param #1   lpszFile
	push	eax			; ptr param #2   lpszTitle
;-------------------------------------
; *** BEGIN parameter packing

; lpszFile
; pointer char --> char
; same pointer types
	mov	eax,[bp+40]		; base address
	push	eax
	call	MapLS
	mov	[bp-4],eax
L2:

; lpszTitle
; pointer char --> char
; same pointer types
	mov	eax,[bp+44]		; base address
	push	eax
	call	MapLS
	mov	[bp-8],eax
L3:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpszFile  from: char
	push	dword ptr [bp-4]	; to: char

; lpszTitle  from: char
	push	dword ptr [bp-8]	; to: char

; wBufSize  from: unsigned short
	push	word ptr [bp+48]	; to unsigned short

; dwFlags  from: unsigned long
	push	dword ptr [bp+52]	; to unsigned long

	call	GetFileTitleI		; call 16-bit version

; return code short --> long
	cwde
	push	eax
	push	dword ptr [bp - 4]
	call	UnmapLS
	push	dword ptr [bp - 8]
	call	UnmapLS
	pop	eax
;-------------------------------------
;--- No error checking.
	jmp	Exit_16


;===========================================================================
T_ThkCommDlgExtendedError label near16


	APILOGLS	ThkCommDlgExtendedError

;-------------------------------------
; create new call frame and make the call

	call	CommDlgExtendedError		; call 16-bit version

; return code unsigned long --> unsigned long
	rol	eax,16
	xchg	ax,dx
	rol	eax,16

;-------------------------------------
;--- No error checking.
	jmp	Exit_0


;===========================================================================
T_ThkChooseFont label near16

; bp+40   lpcf

	APILOGLS	ThkChooseFont

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax	;Storage for lpszStyleTemp
LOCAL__THKCHOOSEFONT_lpszStyleTemp	equ	<[bp-4]>
	push	eax	;Storage for lpTemplateNameTemp
LOCAL__THKCHOOSEFONT_lpTemplateNameTemp	equ	<[bp-8]>
	push	eax	;Storage for Flags
LOCAL__THKCHOOSEFONT_Flags	equ	<[bp-12]>
	push	eax			; ptr param #1   lpcf
;-------------------------------------
; *** BEGIN parameter packing

; lpcf
; pointer struct --> struct
	RAWPACK__THKCHOOSEFONT_lpcf 40, 16
L4:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpcf  from: struct
	push	dword ptr [bp-16]	; to: struct

	call	ChooseFont		; call 16-bit version

; return code short --> long
	cwde
;-------------------------------------
; *** BEGIN parameter unpacking

	push	eax			; save return code

; lpcf
	RAWUNPACK__THKCHOOSEFONT_lpcf 40, 16
L5:
	pop	eax			; restore return code

; *** END   parameter unpacking
;-------------------------------------
;--- No error checking.
	jmp	Exit_4


;===========================================================================
T_ThkChooseColor label near16

; bp+40   lpcc

	APILOGLS	ThkChooseColor

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax	;Storage for lpTemplateNameSeg
LOCAL__THKCHOOSECOLOR_lpTemplateNameSeg	equ	<[bp-4]>
	push	eax	;Storage for lpCustColorsSeg
LOCAL__THKCHOOSECOLOR_lpCustColorsSeg	equ	<[bp-8]>
	push	eax	;Storage for Flags
LOCAL__THKCHOOSECOLOR_Flags	equ	<[bp-12]>
	push	eax			; ptr param #1   lpcc
;-------------------------------------
; *** BEGIN parameter packing

; lpcc
; pointer struct --> struct
	RAWPACK__THKCHOOSECOLOR_lpcc 40, 16
L6:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpcc  from: struct
	push	dword ptr [bp-16]	; to: struct

	call	ChooseColor		; call 16-bit version

; return code short --> long
	cwde
;-------------------------------------
; *** BEGIN parameter unpacking

	push	eax			; save return code

; lpcc
	RAWUNPACK__THKCHOOSECOLOR_lpcc 40, 16
L7:
	pop	eax			; restore return code

; *** END   parameter unpacking
;-------------------------------------
;--- No error checking.
	jmp	Exit_4


;===========================================================================
T_ThkGetSaveFileName label near16

; bp+40   lpOfn

	APILOGLS	ThkGetSaveFileName

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax	;Storage for Flags
LOCAL__THKGETSAVEFILENAME_Flags	equ	<[bp-4]>
	push	eax			; ptr param #1   lpOfn
;-------------------------------------
; *** BEGIN parameter packing

; lpOfn
; pointer struct --> struct
	RAWPACK__THKGETSAVEFILENAME_lpOfn 40, 8
L8:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpOfn  from: struct
	push	dword ptr [bp-8]	; to: struct

	call	GetSaveFileName		; call 16-bit version

; return code short --> long
	cwde
;-------------------------------------
; *** BEGIN parameter unpacking

	push	eax			; save return code

; lpOfn
	RAWUNPACK__THKGETSAVEFILENAME_lpOfn 40, 8
L9:
	pop	eax			; restore return code

; *** END   parameter unpacking
;-------------------------------------
;--- No error checking.
	jmp	Exit_4


;===========================================================================
T_ThkGetOpenFileName label near16

; bp+40   lpOfn

	APILOGLS	ThkGetOpenFileName

;-------------------------------------
; Temp storage

	xor	eax,eax
	push	eax	;Storage for Flags
LOCAL__THKGETOPENFILENAME_Flags	equ	<[bp-4]>
	push	eax			; ptr param #1   lpOfn
;-------------------------------------
; *** BEGIN parameter packing

; lpOfn
; pointer struct --> struct
	RAWPACK__THKGETOPENFILENAME_lpOfn 40, 8
L10:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpOfn  from: struct
	push	dword ptr [bp-8]	; to: struct

	call	GetOpenFileName		; call 16-bit version

; return code short --> long
	cwde
;-------------------------------------
; *** BEGIN parameter unpacking

	push	eax			; save return code

; lpOfn
	RAWUNPACK__THKGETOPENFILENAME_lpOfn 40, 8
L11:
	pop	eax			; restore return code

; *** END   parameter unpacking
;-------------------------------------
;--- No error checking.
	jmp	Exit_4


THK_CODE16_SIZE label byte
ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\adcctl.h ===
// adcctl.h : Declaration of the CADCCtl

#ifndef __ADCCTL_H_
#define __ADCCTL_H_

#include "resource.h"       // main symbols

#include "event.h"          // for CEventBroker
#include "iface.h"          // for IARPSimpleProvider
#include <shdispid.h>       // DISPID_ constants


#define NUM_ARP_SIMPLE_PROVIDERS 4

//------------------------------------------------------------------------
//
//  Class:     CADCCtl
//
//  Synopsis:  This is the AppDataControl COM object.
//             It creates a CADCArr object to manage the control's data.
//
//------------------------------------------------------------------------

// CADCCtl
class ATL_NO_VTABLE CADCCtl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CADCCtl, &CLSID_ADCCtl>,
    public CComControl<CADCCtl>,
    public CStockPropImpl<CADCCtl, IADCCtl, &IID_IADCCtl, &LIBID_SHAPPMGRPLib>,
    public IProvideClassInfo2Impl<&CLSID_ADCCtl, NULL, &LIBID_SHAPPMGRPLib>,
    public IPersistStreamInitImpl<CADCCtl>,
    public IPersistStorageImpl<CADCCtl>,        // new
    public IQuickActivateImpl<CADCCtl>,         // new
    public IOleControlImpl<CADCCtl>,
    public IOleObjectImpl<CADCCtl>,
    public IOleInPlaceActiveObjectImpl<CADCCtl>,
    public IViewObjectExImpl<CADCCtl>,
    public IConnectionPointContainerImpl<CADCCtl>,
    public IOleInPlaceObjectWindowlessImpl<CADCCtl>,
    public IPersistPropertyBagImpl<CADCCtl>,         // missing
    public IRunnableObjectImpl<CADCCtl>,             // missing
    public IPropertyNotifySinkCP<CADCCtl>,           // missing
    public IDataObjectImpl<CADCCtl>,            // new
    public ISpecifyPropertyPagesImpl<CADCCtl>   // new
{
public:
    CADCCtl();
    virtual ~CADCCtl();
    
    DECLARE_REGISTRY_RESOURCEID(IDR_ADCCTL)
    DECLARE_NOT_AGGREGATABLE(CADCCtl)

    BEGIN_COM_MAP(CADCCtl) 
        COM_INTERFACE_ENTRY(IADCCtl)
        COM_INTERFACE_ENTRY(IDispatch)          // does order matter?  TDC has IDispatch first
        COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IQuickActivate)        // new
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)       // new
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages) // new
        COM_INTERFACE_ENTRY_IMPL(IDataObject)           // new
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)   // missing
        COM_INTERFACE_ENTRY_IMPL(IRunnableObject)       // missing
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CADCCtl)
        PROP_ENTRY("Dirty",         DISPID_IADCCTL_DIRTY, CLSID_ADCCtl)
        PROP_ENTRY("Category",      DISPID_IADCCTL_PUBCAT,   CLSID_ADCCtl)
        PROP_ENTRY("ShowPostSetup", DISPID_IADCCTL_SHOWPOSTSETUP, CLSID_ADCCtl)
        PROP_ENTRY("OnDomain",         DISPID_IADCCTL_ONDOMAIN, CLSID_ADCCtl)                
        PROP_ENTRY("DefaultCategory",  DISPID_IADCCTL_DEFAULTCAT, CLSID_ADCCtl)                
    END_PROPERTY_MAP()


    BEGIN_CONNECTION_POINT_MAP(CADCCtl)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP()


    BEGIN_MSG_MAP(CADCCtl)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    END_MSG_MAP()

    // These members and methods expose the IADCCtl interface
    
    // Control methods
    STDMETHOD(IsRestricted) (BSTR bstrPolicy, VARIANT_BOOL * pbRestricted);
    STDMETHOD(Reset)        (BSTR bstrQualifier);
    STDMETHOD(Exec)         (BSTR bstrQualifier, BSTR bstrCmd, LONG nRecord);

    //  Control Properties
    //

    STDMETHOD(get_Dirty)    (VARIANT_BOOL * pbDirty); 
    STDMETHOD(put_Dirty)    (VARIANT_BOOL bDirty);
    STDMETHOD(get_Category) (BSTR * pbstr); 
    STDMETHOD(put_Category) (BSTR bstr);
    STDMETHOD(get_Sort)     (BSTR * pbstr); 
    STDMETHOD(put_Sort)     (BSTR bstr);
    STDMETHOD(get_Forcex86) (VARIANT_BOOL * pbForce); 
    STDMETHOD(put_Forcex86) (VARIANT_BOOL bForce);
    STDMETHOD(get_ShowPostSetup)(VARIANT_BOOL * pbShow);
    STDMETHOD(get_OnDomain) (VARIANT_BOOL * pbOnDomain); 
    STDMETHOD(put_OnDomain) (VARIANT_BOOL bOnDomain);
    STDMETHOD(get_DefaultCategory) (BSTR * pbstr); 

    
    //  Data source notification methods
    STDMETHOD(msDataSourceObject)   (BSTR qualifier, IUnknown **ppUnk);
    STDMETHOD(addDataSourceListener)(IUnknown *pEvent);

    // *** IViewObjectEx ***
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    // *** Overriding ATL functions ***  
    virtual STDMETHODIMP IOleObject_SetClientSite(IOleClientSite *pClientSite);
        
private:

    HRESULT     _CreateMatrixObject(DWORD dwEnum, IARPSimpleProvider ** pparposp);
    HRESULT     _ReleaseMatrixObject(DWORD dwIndex);
    HRESULT     _InitEventBrokers(DataSourceListener * pdsl, BOOL bRecreate);

    // Release all of the matrix objects
    HRESULT     _ReleaseAllMatrixObjects(void);
    HRESULT     _ReleaseAllEventBrokers();
    DWORD       _GetEnumAreaFromQualifier(BSTR bstrQualifier);

    BOOL        _IsMyComputerOnDomain();
    HRESULT     _CheckSecurity(IOleClientSite * pClientSite);
    HRESULT     _KillDatasrcWorkerThread(IARPSimpleProvider * parp);    

    HRESULT     _GetToplevelHWND(void);

    
    IShellAppManager * _psam;               // shell app manager    
    IARPEvent * _rgparpevt[NUM_ARP_SIMPLE_PROVIDERS];
                                            // array of event brokers, each OSP has one cooresponding
    IARPSimpleProvider * _rgparposp[NUM_ARP_SIMPLE_PROVIDERS];
                                            // array of OSP's we carry in this data source object
    
    IOleClientSite * _pclientsite;          // cached client site
    
    CComBSTR    _cbstrCategory;
    CComBSTR    _cbstrSort;
    DWORD       _dwEnum;                    // enumerate which items? (ENUM_*)
    
    BITBOOL     _fInReset: 1;               // TRUE if Reset has already been entered
    BITBOOL     _fDirty : 1;                // TRUE if the recordset is dirty. 
    BITBOOL     _fCategoryChanged: 1;       // TRUE if Category property has changed
    BITBOOL     _fSecure : 1;               // TRUE if we don't have security problem
    BITBOOL     _fOnDomain : 1;             // TRUE if we are running on a machine connected to a domain
    HWND        _hwndTB;                    // Toplevel browser hwnd
};

#endif //__ADCCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shell32 to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "priv.h"       // Don't use precompiled header here
#include "appwiz.h"

#define c_szARPJob  TEXT("ARP Job")


// Return: hIOPort for the CompletionPort
HANDLE _SetJobCompletionPort(HANDLE hJob)
{
    HANDLE hRet = NULL;

    HANDLE hIOPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, (ULONG_PTR)hJob, 1 );
    if ( hIOPort != NULL )
    {
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT CompletionPort;
        CompletionPort.CompletionKey = hJob ;

        CompletionPort.CompletionPort = hIOPort;

        if (SetInformationJobObject( hJob,JobObjectAssociateCompletionPortInformation,
                                     &CompletionPort, sizeof(CompletionPort) ) )
        {   
            hRet = hIOPort;
        }
    }
    return hRet;
}


STDAPI_(DWORD) WaitingThreadProc(void *pv)
{
    HANDLE hIOPort = (HANDLE)pv;

    // RIP(hIOPort);
    
    DWORD dwCompletionCode;
    PVOID pCompletionKey;
    LPOVERLAPPED lpOverlapped;
    
    while (TRUE)
    {
        // Wait for all the processes to finish...
        if (!GetQueuedCompletionStatus( hIOPort, &dwCompletionCode, (PULONG_PTR) &pCompletionKey,
                                        &lpOverlapped, INFINITE ) || (dwCompletionCode == JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO))
        {
            break;
        }
    }
    
    return 0;
}


/*-------------------------------------------------------------------------
Purpose: Creates a process and waits for it to finish
*/
STDAPI_(BOOL) NT5_CreateAndWaitForProcess(LPTSTR pszExeName)
{
    PROCESS_INFORMATION pi = {0};
    STARTUPINFO si = {0};
    BOOL fWorked = FALSE;
#ifdef WX86
    DWORD  cchArch;
    WCHAR  szArchValue[32];
#endif    

    HANDLE hJob = CreateJobObject(NULL, c_szARPJob);
    
    if (hJob)
    {
        HANDLE hIOPort = _SetJobCompletionPort(hJob);
        if (hIOPort)
        {
            DWORD dwCreationFlags = 0;
            // Create the install process
            si.cb = sizeof(si);

#ifdef WX86
            if (bWx86Enabled && bForceX86Env) {
                cchArch = GetEnvironmentVariableW(ProcArchName,
                    szArchValue,
                    sizeof(szArchValue)
                    );

                if (!cchArch || cchArch >= sizeof(szArchValue)) {
                    szArchValue[0]=L'\0';
                }

                SetEnvironmentVariableW(ProcArchName, L"x86");
            }
#endif

            dwCreationFlags = CREATE_SUSPENDED | CREATE_SEPARATE_WOW_VDM;
            
            // Create the process
            fWorked = CreateProcess(NULL, pszExeName, NULL, NULL, FALSE, dwCreationFlags, NULL, NULL,
                                    &si, &pi);
            if (fWorked)
            {
                HANDLE hWait = NULL;
            
                if (AssignProcessToJobObject(hJob, pi.hProcess))
                {   
                    hWait = CreateThread(NULL, 0, WaitingThreadProc, (LPVOID)hIOPort, 0, NULL);
                }

                if (hWait == NULL)
                {
                    // We might get here if the call to AssignProcessToJobObject has failed because
                    // the process already has a job assigned to it, or because we couldn't create the
                    // waiting thread. Try a more direct approach by just watching the process handle.
                    // This method won't catch spawned processes, but it is better than nothing.

                    hWait = pi.hProcess;
                }
                else
                {
                    // we are not waiting on the process handle, so we are done /w it.
                    CloseHandle(pi.hProcess);
                }

                ResumeThread(pi.hThread);
                CloseHandle(pi.hThread);

#ifdef WX86
                if (bWx86Enabled && bForceX86Env)
                {
                    SetEnvironmentVariableW(ProcArchName, szArchValue);
                }
#endif

                // we should have a valid handle at this point for sure
                ASSERT(hWait && (hWait != INVALID_HANDLE_VALUE));

                SHProcessSentMessagesUntilEvent(NULL, hWait, INFINITE);
                CloseHandle(hWait);
            }

            CloseHandle(hIOPort);
        }

        CloseHandle(hJob);
    }

    return fWorked;
}





#define PFN_FIRSTTIME   ((void *)-1)


// GetLongPathName
typedef UINT (WINAPI * PFNGETLONGPATHNAME)(LPCTSTR pszShortPath, LPTSTR pszLongBuf, DWORD cchBuf); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's GetLongPathName
*/
DWORD NT5_GetLongPathName(LPCTSTR pszShortPath, LPTSTR pszLongBuf, DWORD cchBuf)
{
    static PFNGETLONGPATHNAME s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle KERNEL32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("KERNEL32.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNGETLONGPATHNAME)GetProcAddress(hinst, "GetLongPathNameW");
#else
            s_pfn = (PFNGETLONGPATHNAME)GetProcAddress(hinst, "GetLongPathNameA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszShortPath, pszLongBuf, cchBuf);

    if (0 < cchBuf && pszLongBuf)
        *pszLongBuf = 0;
        
    return 0;       // failure
}


// VerSetConditionMask
typedef ULONGLONG (WINAPI * PFNVERSETCONDITIONMASK)(ULONGLONG conditionMask, DWORD dwTypeMask, BYTE condition); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's VerSetConditionMask
*/
ULONGLONG NT5_VerSetConditionMask(ULONGLONG conditionMask, DWORD dwTypeMask, BYTE condition)
{
    static PFNVERSETCONDITIONMASK s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle KERNEL32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("KERNEL32.DLL");

        if (hinst)
            s_pfn = (PFNVERSETCONDITIONMASK)GetProcAddress(hinst, "VerSetConditionMask");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(conditionMask, dwTypeMask, condition);

    return 0;       // failure
}



// MsiReinstallProduct
typedef UINT (WINAPI * PFNMSIREINSTALLPRODUCT) (LPCTSTR szProduct, DWORD dwReinstallMode); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiReinstallProduct
*/
UINT MSI_MsiReinstallProduct(LPCTSTR szProduct, DWORD dwReinstallMode)
{
    static PFNMSIREINSTALLPRODUCT s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIREINSTALLPRODUCT)GetProcAddress(hinst, "MsiReinstallProductW");
#else
            s_pfn = (PFNMSIREINSTALLPRODUCT)GetProcAddress(hinst, "MsiReinstallProductA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProduct, dwReinstallMode);

    return ERROR_CALL_NOT_IMPLEMENTED;
}


// MsiEnumProducts
typedef UINT (WINAPI * PFNMSIENUMPRODUCTS) (DWORD iProductIndex, LPTSTR lpProductBuf);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiEnumProducts
*/
UINT MSI_MsiEnumProducts(DWORD iProductIndex, LPTSTR lpProductBuf)
{
    static PFNMSIENUMPRODUCTS s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");
        
        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIENUMPRODUCTS)GetProcAddress(hinst, "MsiEnumProductsW");
#else
            s_pfn = (PFNMSIENUMPRODUCTS)GetProcAddress(hinst, "MsiEnumProductsA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(iProductIndex, lpProductBuf);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiEnumFeatures
typedef UINT (WINAPI * PFNMSIENUMFEATURES) (LPCTSTR  szProduct, DWORD iFeatureIndex, LPTSTR   lpFeatureBuf, LPTSTR   lpParentBuf);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiEnumFeatures
*/
UINT MSI_MsiEnumFeatures(LPCTSTR szProduct, DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf)
{
    static PFNMSIENUMFEATURES s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIENUMFEATURES)GetProcAddress(hinst, "MsiEnumFeaturesW");
#else
            s_pfn = (PFNMSIENUMFEATURES)GetProcAddress(hinst, "MsiEnumFeaturesA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProduct, iFeatureIndex, lpFeatureBuf, lpParentBuf);

    return ERROR_CALL_NOT_IMPLEMENTED;
}


// MsiGetProductInfo
typedef UINT (WINAPI * PFNMSIGETPRODUCTINFO) (LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiGetProductInfo
*/
UINT MSI_MsiGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf)
{
    static PFNMSIGETPRODUCTINFO s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIGETPRODUCTINFO)GetProcAddress(hinst, "MsiGetProductInfoW");
#else
            s_pfn = (PFNMSIGETPRODUCTINFO)GetProcAddress(hinst, "MsiGetProductInfoA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProduct, szAttribute, lpValueBuf, pcchValueBuf);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiSetInternalUI
typedef INSTALLUILEVEL (WINAPI * PFNMSISETINTERNALUI) (INSTALLUILEVEL dwUILevel, HWND * phwnd);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiSetInternalUI
*/
INSTALLUILEVEL MSI_MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND * phwnd)
{
    static PFNMSISETINTERNALUI s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            s_pfn = (PFNMSISETINTERNALUI)GetProcAddress(hinst, "MsiSetInternalUI");
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(dwUILevel, phwnd);

    return INSTALLUILEVEL_NOCHANGE;
}

// MsiConfigureProduct
typedef UINT (WINAPI * PFNMSICONFIGUREPRODUCT) (LPCTSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState);  

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiConfigureProduct
*/
UINT MSI_MsiConfigureProduct(LPCTSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState)
{
    static PFNMSICONFIGUREPRODUCT s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSICONFIGUREPRODUCT)GetProcAddress(hinst, "MsiConfigureProductW");
#else
            s_pfn = (PFNMSICONFIGUREPRODUCT)GetProcAddress(hinst, "MsiConfigureProductA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProduct, iInstallLevel, eInstallState);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiQueryProductState
typedef INSTALLSTATE (WINAPI * PFNMSIQUERYPRODUCTSTATE) (LPCTSTR szProductID);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiQueryProductState
*/
INSTALLSTATE MSI_MsiQueryProductState(LPCTSTR szProductID)
{
    static PFNMSIQUERYPRODUCTSTATE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIQUERYPRODUCTSTATE)GetProcAddress(hinst, "MsiQueryProductStateW");
#else
            s_pfn = (PFNMSIQUERYPRODUCTSTATE)GetProcAddress(hinst, "MsiQueryProductStateA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProductID);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiQueryFeatureState
typedef INSTALLSTATE (WINAPI * PFNMSIQUERYFEATURESTATE) (LPCTSTR szProductID, LPCTSTR szFeature);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiQueryFeatureState
*/
INSTALLSTATE MSI_MsiQueryFeatureState(LPCTSTR szProductID, LPCTSTR szFeature)
{
    static PFNMSIQUERYFEATURESTATE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIQUERYFEATURESTATE)GetProcAddress(hinst, "MsiQueryFeatureStateW");
#else
            s_pfn = (PFNMSIQUERYFEATURESTATE)GetProcAddress(hinst, "MsiQueryFeatureStateA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szProductID, szFeature);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiOpenPackage
typedef UINT (WINAPI * PFNMSIOPENPACKAGE) (LPCTSTR szPackagePath, MSIHANDLE * hProduct);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiOpenPackage
*/
UINT MSI_MsiOpenPackage(LPCTSTR szPackagePath, MSIHANDLE * hProduct)
{
    static PFNMSIOPENPACKAGE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIOPENPACKAGE)GetProcAddress(hinst, "MsiOpenPackageW");
#else
            s_pfn = (PFNMSIOPENPACKAGE)GetProcAddress(hinst, "MsiOpenPackageA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(szPackagePath, hProduct);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiCloseHandle
typedef UINT (WINAPI * PFNMSICLOSEHANDLE) (MSIHANDLE hAny);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiCloseHandle
*/
UINT MSI_MsiCloseHandle(MSIHANDLE hAny)
{
    static PFNMSICLOSEHANDLE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            s_pfn = (PFNMSICLOSEHANDLE)GetProcAddress(hinst, "MsiCloseHandle");
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(hAny);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiDoAction
typedef UINT (WINAPI * PFNMSIDOACTION) (MSIHANDLE hAny, LPCTSTR szAction);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiDoAction
*/
UINT MSI_MsiDoAction(MSIHANDLE hAny, LPCTSTR szAction)
{
    static PFNMSIDOACTION s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIDOACTION)GetProcAddress(hinst, "MsiDoActionW");
#else
            s_pfn = (PFNMSIDOACTION)GetProcAddress(hinst, "MsiDoActionA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(hAny, szAction);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiGetFeatureCost
typedef UINT (WINAPI * PFNMSIGETFEATURECOST) (MSIHANDLE hInstall, LPCTSTR szFeature, MSICOSTTREE  iCostTree, INSTALLSTATE iState, INT *piCost);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiGetFeatureCost
*/
UINT MSI_MsiGetFeatureCost(MSIHANDLE hInstall, LPCTSTR szFeature, MSICOSTTREE  iCostTree, INSTALLSTATE iState, INT *piCost)
{
    static PFNMSIGETFEATURECOST s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSIGETFEATURECOST)GetProcAddress(hinst, "MsiGetFeatureCostW");
#else
            s_pfn = (PFNMSIGETFEATURECOST)GetProcAddress(hinst, "MsiGetFeatureCostA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(hInstall, szFeature, iCostTree, iState, piCost);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

// MsiSetFeatureState
typedef UINT (WINAPI * PFNMSISETFEATURESTATE) (MSIHANDLE hInstall, LPCTSTR szFeature, INSTALLSTATE iState);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's MsiSetFeatureState
*/
UINT MSI_MsiSetFeatureState(MSIHANDLE hInstall, LPCTSTR szFeature, INSTALLSTATE iState)
{
    static PFNMSISETFEATURESTATE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("MSI.DLL");

        if (hinst)
        {
            // The unicode-decorated MSI APIs translate to ansi internally
            // on Win95, so it should be safe to call them all the time.
#ifdef UNICODE 
            s_pfn = (PFNMSISETFEATURESTATE)GetProcAddress(hinst, "MsiSetFeatureStateW");
#else
            s_pfn = (PFNMSISETFEATURESTATE)GetProcAddress(hinst, "MsiSetFeatureStateA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(hInstall, szFeature, iState);

    return ERROR_CALL_NOT_IMPLEMENTED;
}

typedef HRESULT (__stdcall * PFNRELEASEAPPCATEGORYINFOLIST)(APPCATEGORYINFOLIST *pAppCategoryList);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's ReleaseAppCategoryInfoList
*/
HRESULT NT5_ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryList)
{
    static PFNRELEASEAPPCATEGORYINFOLIST s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("APPMGMTS.DLL");

        if (hinst)
            s_pfn = (PFNRELEASEAPPCATEGORYINFOLIST)GetProcAddress(hinst, "ReleaseAppCategoryInfoList");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pAppCategoryList);

    return E_NOTIMPL;    
}

/*----------------------------------------------------------
Purpose: Thunk for NT 5's AllowSetForegroundWindow
*/
typedef UINT (WINAPI * PFNALLOWSFW) (DWORD dwPRocessID);  

BOOL NT5_AllowSetForegroundWindow(DWORD dwProcessID)
{
    static PFNALLOWSFW s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("USER32.DLL");

        if (hinst)
        {
            s_pfn = (PFNALLOWSFW)GetProcAddress(hinst, "AllowSetForegroundWindow");
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(dwProcessID);

    return FALSE;
}




// InstallApplication
typedef DWORD (WINAPI * PFNINSTALLAPP)(PINSTALLDATA pInstallInfo); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's InstallApplication
*/
DWORD NT5_InstallApplication(PINSTALLDATA pInstallInfo)
{
    static PFNINSTALLAPP s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNINSTALLAPP)GetProcAddress(hinst, "InstallApplication");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pInstallInfo);

    return ERROR_INVALID_FUNCTION;       // failure
}


// UninstallApplication
typedef DWORD (WINAPI * PFNUNINSTALLAPP)(WCHAR * pszProductCode, DWORD dwStatus); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's UninstallApplication
*/
DWORD NT5_UninstallApplication(WCHAR * pszProductCode, DWORD dwStatus)
{
    static PFNUNINSTALLAPP s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNUNINSTALLAPP)GetProcAddress(hinst, "UninstallApplication");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszProductCode, dwStatus);

    return ERROR_INVALID_FUNCTION;       // failure
}


// GetApplicationState
typedef DWORD (WINAPI * PFNGETAPPSTATE)(WCHAR * ProductCode, APPSTATE * pAppState); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's GetApplicationState
*/
DWORD NT5_GetApplicationState(WCHAR * pszProductCode, APPSTATE * pAppState)
{
    static PFNGETAPPSTATE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETAPPSTATE)GetProcAddress(hinst, "GetApplicationState");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszProductCode, pAppState);

    return ERROR_INVALID_FUNCTION;       // failure
}


// CommandLineFromMsiDescriptor
typedef DWORD (WINAPI * PFNCMDLINE)(WCHAR * Descriptor, WCHAR * CommandLine, DWORD * CommandLineLength); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's CommandLineFromMsiDescriptor
*/
DWORD NT5_CommandLineFromMsiDescriptor(WCHAR * pszDescriptor, WCHAR * pszCommandLine, DWORD * pcchCommandLine)
{
    static PFNCMDLINE s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNCMDLINE)GetProcAddress(hinst, "CommandLineFromMsiDescriptor");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszDescriptor, pszCommandLine, pcchCommandLine);

    return ERROR_INVALID_FUNCTION;       // failure
}


// GetManagedApplications
typedef DWORD (WINAPI * PFNGETAPPS)(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's GetManagedApplications
*/
DWORD NT5_GetManagedApplications(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps)
{
    static PFNGETAPPS s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETAPPS)GetProcAddress(hinst, "GetManagedApplications");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pCategory, dwQueryFlags, dwInfoLevel, pdwApps, prgManagedApps);

    return ERROR_INVALID_FUNCTION;       // failure
}


typedef DWORD (__stdcall * PFNGETMANAGEDAPPLICATIONCATEGORIES)(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's CsGetAppCategories
*/
DWORD NT5_GetManagedApplicationCategories(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList)
{
    static PFNGETMANAGEDAPPLICATIONCATEGORIES s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETMANAGEDAPPLICATIONCATEGORIES)GetProcAddress(hinst, "GetManagedApplicationCategories");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(dwReserved, pAppCategoryList);

    return ERROR_INVALID_FUNCTION;
}


// NetGetJoinInformation
typedef NET_API_STATUS (WINAPI * PFNGETJOININFO)(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's NetGetJoinInformation
*/
NET_API_STATUS NT5_NetGetJoinInformation(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType)
{
    static PFNGETJOININFO s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("NETAPI32.DLL");
        GetLastError();

        if (hinst)
            s_pfn = (PFNGETJOININFO)GetProcAddress(hinst, "NetGetJoinInformation");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(lpServer, lpNameBuffer, BufferType);

    return NERR_NetNotStarted;       // failure
}

// NetApiBufferFree
typedef NET_API_STATUS (WINAPI * PFNNETFREEBUFFER)(LPVOID lpBuffer); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's NetApiBufferFree
*/
NET_API_STATUS NT5_NetApiBufferFree(LPVOID lpBuffer)
{
    static PFNNETFREEBUFFER s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("NETAPI32.DLL");

        if (hinst)
            s_pfn = (PFNNETFREEBUFFER)GetProcAddress(hinst, "NetApiBufferFree");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(lpBuffer);

    return NERR_NetNotStarted;       // failure
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

STDAPI_(BOOL) NT5_CreateAndWaitForProcess(LPTSTR pszExeName);


// Darwin API's 
STDAPI_(UINT) MSI_MsiEnumProducts(DWORD iProductIndex, LPTSTR lpProductBuf);
STDAPI_(UINT) MSI_MsiGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf); 
STDAPI_(UINT) MSI_MsiConfigureProduct(LPCTSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState);
STDAPI_(INSTALLUILEVEL) MSI_MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND * phwnd);

STDAPI_(UINT) MSI_MsiReinstallProduct(LPCTSTR szProduct, DWORD szReinstallMode); 
STDAPI_(UINT) MSI_MsiOpenPackage(LPCTSTR szPackagePath, MSIHANDLE *hProduct);
STDAPI_(UINT) MSI_MsiEnumFeatures(LPCTSTR  szProduct, DWORD iFeatureIndex, LPTSTR   lpFeatureBuf, LPTSTR   lpParentBuf);

STDAPI_(INSTALLSTATE) MSI_MsiQueryProductState(LPCTSTR szProductID);
STDAPI_(INSTALLSTATE) MSI_MsiQueryFeatureState(LPCTSTR szProduct, LPCTSTR  szFeature);

// declared in msiquery.h
STDAPI_(UINT) MSI_MsiDoAction(MSIHANDLE hInstall, LPCTSTR szAction);
STDAPI_(UINT) MSI_MsiCloseHandle(MSIHANDLE hAny);
STDAPI_(UINT) MSI_MsiSetFeatureState(MSIHANDLE hInstall, LPCTSTR szFeature, INSTALLSTATE iState);
STDAPI_(UINT) MSI_MsiGetFeatureCost(MSIHANDLE hInstall, LPCTSTR szFeature, MSICOSTTREE  iCostTree, INSTALLSTATE iState, INT *piCost);

// Appmgmts APIs
STDAPI  NT5_ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryList);

// Advapi APIs
STDAPI_(DWORD) NT5_InstallApplication(PINSTALLDATA pInstallInfo);
STDAPI_(DWORD) NT5_UninstallApplication(WCHAR * ProductCode, DWORD dwStatus);
STDAPI_(DWORD) NT5_GetApplicationState(WCHAR * ProductCode, APPSTATE * pAppState);
STDAPI_(DWORD) NT5_CommandLineFromMsiDescriptor(WCHAR * Descriptor, WCHAR * CommandLine, DWORD * CommandLineLength);
STDAPI_(DWORD) NT5_GetManagedApplications(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps);
STDAPI_(DWORD) NT5_GetManagedApplicationCategories(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList);

// Kernel APIs
STDAPI_(DWORD) NT5_GetLongPathName(LPCTSTR pszShortPath, LPTSTR pszLongBuf, DWORD cchBuf);
STDAPI_(ULONGLONG) NT5_VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);

// User32 APIs
STDAPI_(BOOL) NT5_AllowSetForegroundWindow( DWORD dwProcessID );

// NetApi32
STDAPI_(NET_API_STATUS) NT5_NetGetJoinInformation(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType);
STDAPI_(NET_API_STATUS) NT5_NetApiBufferFree(LPVOID lpBuffer);


#define AllowSetForegroundWindow  NT5_AllowSetForegroundWindow

#define ReleaseAppCategoryInfoList  NT5_ReleaseAppCategoryInfoList

#undef  MsiEnumProducts
#define MsiEnumProducts         MSI_MsiEnumProducts

#undef  MsiGetProductInfo
#define MsiGetProductInfo       MSI_MsiGetProductInfo

#undef  MsiSetInternalUI
#define MsiSetInternalUI        MSI_MsiSetInternalUI

#undef  MsiConfigureProduct
#define MsiConfigureProduct     MSI_MsiConfigureProduct

#undef  MsiReinstallProduct
#define MsiReinstallProduct     MSI_MsiReinstallProduct

#undef  MsiQueryProductState
#define MsiQueryProductState    MSI_MsiQueryProductState

#undef  MsiQueryFeatureState
#define MsiQueryFeatureState    MSI_MsiQueryFeatureState

#undef  MsiOpenPackage
#define MsiOpenPackage          MSI_MsiOpenPackage

#undef  MsiEnumFeatures
#define MsiEnumFeatures         MSI_MsiEnumFeatures

#undef  MsiCloseHandle
#define MsiCloseHandle          MSI_MsiCloseHandle

#undef  MsiGetFeatureCost
#define MsiGetFeatureCost       MSI_MsiGetFeatureCost

#undef  MsiDoAction
#define MsiDoAction             MSI_MsiDoAction

#undef  MsiSetFeatureState
#define MsiSetFeatureState      MSI_MsiSetFeatureState

#undef  GetLongPathName
#define GetLongPathName         NT5_GetLongPathName

#define VerSetConditionMask     NT5_VerSetConditionMask

#define InstallApplication              NT5_InstallApplication
#define UninstallApplication            NT5_UninstallApplication
#define GetApplicationState             NT5_GetApplicationState
#define CommandLineFromMsiDescriptor    NT5_CommandLineFromMsiDescriptor
#define GetManagedApplications          NT5_GetManagedApplications
#define GetManagedApplicationCategories NT5_GetManagedApplicationCategories
#define NetGetJoinInformation           NT5_NetGetJoinInformation
#define NetApiBufferFree                NT5_NetApiBufferFree

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\adcctl.cpp ===
// adcctl.cpp : Implementation of CADCCtl
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "adcctl.h"
#include "shdguid.h"
#include "shguidp.h"
#include "util.h"       // for InstallAppFromFloppy...
#include "datasrc.h"    // for CDataSrc_CreateInstance
#include "dump.h"

EXTERN_C BOOL bForceX86Env;

// Declare the private GUIDs
#include "initguid.h"
#include "iface.h"
#include "mshtml.h"


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if the bstr is an empty string.
*/
inline BOOL IsEmptyBSTR(BSTR bstr)
{
    return bstr == NULL || bstr[0] == 0;
}


//---------------------------------------------------------------------------
//   
//---------------------------------------------------------------------------


BOOL CADCCtl::_IsMyComputerOnDomain()
{
    // NOTE: assume it's on the domain 
    BOOL bRet = TRUE;
#if WINNT
    LPWSTR pszDomain;
    NETSETUP_JOIN_STATUS nsjs;
    
    if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
    {
        if (nsjs != NetSetupDomainName)
            bRet = FALSE;
        NetApiBufferFree(pszDomain);
    }
#endif
    return bRet;
}

// constructor
CADCCtl::CADCCtl()
{

    TraceMsg(TF_OBJLIFE, "(Ctl) creating");
    
    // This object cannot be stack-allocated
    ASSERT(NULL == _hwndTB);
    
    ASSERT(FALSE == _fInReset);
    ASSERT(FALSE == _fSecure);

    // We do this so comctl32.dll won't fail to create the DATETIME_PICKER
    // control in case we do "Add Later"
    INITCOMMONCONTROLSEX icex = {0};
    icex.dwSize = sizeof(icex);
    icex.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icex);

    _fOnDomain = _IsMyComputerOnDomain();
        
    // Set default sort values
    _cbstrSort = L"displayname";
}


// destructor
CADCCtl::~CADCCtl()
{
    TraceMsg(TF_OBJLIFE, "(Ctl) destroying");

    ATOMICRELEASE(_psam);
    
    _ReleaseAllMatrixObjects();

    _ReleaseAllEventBrokers();
}



//------------------------------------------------------------------------
//
//  These set/get methods implement the control's properties,
//  copying values to and from class members.  They perform no
//  other processing apart from argument validation.
//
//------------------------------------------------------------------------

STDMETHODIMP CADCCtl::get_Dirty(VARIANT_BOOL * pbDirty)
{
    *pbDirty = _fDirty ? VARIANT_TRUE : VARIANT_FALSE;
    return  S_OK;
}

STDMETHODIMP CADCCtl::put_Dirty(VARIANT_BOOL bDirty)
{
    // to its current value.
    _fDirty = (bDirty == VARIANT_TRUE) ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CADCCtl::get_Category(BSTR* pbstr)
{
    *pbstr = _cbstrCategory.Copy();
    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CADCCtl::put_Category(BSTR bstr)
{
    if (NULL == (LPWSTR)_cbstrCategory || 0 != StrCmpIW(bstr, _cbstrCategory))
    {
        _cbstrCategory = bstr;
        _fCategoryChanged = TRUE;
    }
    return S_OK;
}

STDMETHODIMP CADCCtl::get_DefaultCategory(BSTR* pbstr)
{
    WCHAR sz[64];

    ARPGetPolicyString(L"DefaultCategory", sz, SIZECHARS(sz));

    CComBSTR bstr(sz);
    *pbstr = bstr.Copy();
    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CADCCtl::get_Sort(BSTR* pbstr)
{
    *pbstr = _cbstrSort.Copy();
    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CADCCtl::put_Sort(BSTR bstr)
{
    _cbstrSort = bstr;
    return S_OK;
}

STDMETHODIMP CADCCtl::get_Forcex86(VARIANT_BOOL * pbForce)
{
    *pbForce = VARIANT_FALSE;
#ifdef WX86
    *pbForce = bForceX86Env ? VARIANT_TRUE : VARIANT_FALSE;
#endif
    return S_OK;
}

STDMETHODIMP CADCCtl::put_Forcex86(VARIANT_BOOL bForce)
{
#ifdef WX86
    bForceX86Env = (bForce == VARIANT_TRUE) ? TRUE : FALSE;
#else
    // nobody should be calling this if we are not under WX86
    ASSERT(0);
#endif
    return S_OK;
}

//  Property: ShowPostSetup
//      Returns TRUE if the Post Setup Page should be shown.

STDMETHODIMP CADCCtl::get_ShowPostSetup(VARIANT_BOOL * pbShow)
{
    // Only show the page if it is needed
    if (COCSetupEnum::s_OCSetupNeeded())
        *pbShow = VARIANT_TRUE;
    else
        *pbShow = VARIANT_FALSE;
        
    return S_OK;
}

STDMETHODIMP CADCCtl::get_OnDomain(VARIANT_BOOL * pbOnDomain)
{
    *pbOnDomain = _fOnDomain ? VARIANT_TRUE : VARIANT_FALSE;
    
    return  S_OK;
}

STDMETHODIMP CADCCtl::put_OnDomain(VARIANT_BOOL bOnDomain)
{
    // to its current value.
    _fOnDomain = (bOnDomain == VARIANT_TRUE) ? TRUE : FALSE;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Creates the data source object.  Also initiates the data enumeration.
*/
HRESULT CADCCtl::_CreateMatrixObject(DWORD dwEnum, IARPSimpleProvider ** pparposp)
{
    HRESULT hres;
    IARPSimpleProvider * parposp = NULL;

    TraceMsg(TF_CTL, "(Ctl) creating matrix object");

    // Security check must pass before we can provide a DSO. 
    if (!_fSecure)
    {
        TraceMsg(TF_WARNING, "(Ctl) Security blocked creating DSO");
        hres = E_FAIL;
    }
    else
    {
        hres = THR(CDataSrc_CreateInstance(IID_IARPSimpleProvider, (LPVOID *)&parposp));
        if (SUCCEEDED(hres))
        {
            if (_psam == NULL)
            {
                hres = THR(CoCreateInstance(CLSID_ShellAppManager, NULL, CLSCTX_INPROC_SERVER, 
                                                        IID_IShellAppManager, (LPVOID *)&_psam));
            }
            
            if (_psam)
            {
                ASSERT(_rgparpevt[dwEnum]);
                
                hres = THR(parposp->Initialize(_psam, _rgparpevt[dwEnum], dwEnum));
                if (SUCCEEDED(hres))
                {
                    parposp->SetSortCriteria(_cbstrSort);
                    parposp->SetFilter(_cbstrCategory);
                }
            }

            if (FAILED(hres))
            {
                parposp->Release();
                parposp = NULL;
            }
        }
    }

    *pparposp = parposp;
    
    return hres;
}

/*-------------------------------------------------------------------------
Purpose: Helper method to kill the worker thread
*/
HRESULT CADCCtl::_KillDatasrcWorkerThread(IARPSimpleProvider * parp)
{
    HRESULT hres = S_OK;

    if (parp)
    {
        IARPWorker * pDatasrcWorker;
        
        hres = parp->QueryInterface(IID_IARPWorker, (LPVOID *)&pDatasrcWorker);
        if (SUCCEEDED(hres))
        {
            hres = pDatasrcWorker->KillWT();
            pDatasrcWorker->Release();
        }
    }
    return hres;
}

HRESULT CADCCtl::_ReleaseMatrixObject(DWORD dwIndex)
{
    _fDirty = FALSE;
    _fCategoryChanged = FALSE;

    if (_rgparposp[dwIndex])
    {
        _KillDatasrcWorkerThread(_rgparposp[dwIndex]);
        ATOMICRELEASE(_rgparposp[dwIndex]);

        if (_rgparpevt[dwIndex])
            _rgparpevt[dwIndex]->SetOSPListener(NULL);
    }
    
    return S_OK;
}

/*-------------------------------------------------------------------------
Purpose: Release the control's embedded matrix object.

         Terminates any pending data download.
*/
HRESULT CADCCtl::_ReleaseAllMatrixObjects(void)
{
    int i;
    
    for (i = 0; i < ARRAYSIZE(_rgparposp); i++)
        _ReleaseMatrixObject(i);

    return S_OK;
}


const static struct {
    DWORD dwEnum;
    LPWSTR pszAreaText;
} c_rgEnumAreas[] = {
    {ENUM_INSTALLED,      L"Remove"},
    {ENUM_PUBLISHED,      L"Add"},
    {ENUM_CATEGORIES,     L"Categories"},
    {ENUM_OCSETUP,        L"ocsetup"},
};

/*-------------------------------------------------------------------------
Purpose: Release all the event broker objects.          
*/
HRESULT CADCCtl::_ReleaseAllEventBrokers()
{
    HRESULT hres = S_OK;

    int i;
    for (i = 0; i < NUM_ARP_SIMPLE_PROVIDERS; i++)
    {
        // Release our previous Event Broker.
        ATOMICRELEASE(_rgparpevt[i]);
    }

    return hres;
}

/*-------------------------------------------------------------------------
Purpose: Initialize the event broker object.  This function will create
         if it doesn't exist already.

         bRecreate - if TRUE, the broker object will be released and recreated.
         
*/
HRESULT CADCCtl::_InitEventBrokers(DataSourceListener * pdsl, BOOL bRecreate)
{
    HRESULT hres = S_OK;

    TraceMsg(TF_CTL, "(Ctl) initializing event broker");
    
    int i;
    for (i = 0; i < NUM_ARP_SIMPLE_PROVIDERS; i++)
    {
        if (bRecreate)
        {
            // Release our previous Event Broker.
            ATOMICRELEASE(_rgparpevt[i]);

            //  Create a new event broker for each DSO
            hres = CARPEvent_CreateInstance(IID_IARPEvent, (LPVOID *)&_rgparpevt[i], c_rgEnumAreas[i].pszAreaText);
            if (FAILED(hres))
                break;
        }

        if (_rgparpevt[i])
        {
            // Set the DataSourceListener for the event broker.
            _rgparpevt[i]->SetDataSourceListener(pdsl);
        }

    }

    return hres;
}


/*--------------------------------------------------------------------------
Purpose: Matches the bstrQualifiers passed in to the Enum Areas we have
*/

DWORD CADCCtl::_GetEnumAreaFromQualifier(BSTR bstrQualifier)
{
    DWORD dwEnum = ENUM_UNKNOWN;
    int i;

    for (i = 0; i < ARRAYSIZE(c_rgEnumAreas); i++)
    {
        // (Trident databinding treats qualifiers case-sensitively, so we
        // should too.)
        if (0 == StrCmpW(bstrQualifier, c_rgEnumAreas[i].pszAreaText))
        {
            dwEnum = c_rgEnumAreas[i].dwEnum;
            break;
        }
    }   
    
    return dwEnum; 
}

/*-------------------------------------------------------------------------
Purpose: Creates an object that supports the OLEDBSimpleProvider interface.
         We call this the OSP. This object is the main workhorse that 
         provides data back to the consumer (Trident's databinding agent).

         MSHTML calls this method to obtain the object.  It always passes
         an empty BSTR for bstrQualifier.

         This function can return S_OK and a NULL *ppunk!  It actually is
         required to do this if the OSP doesn't have any data yet.  Then,
         once the OSP has some data, it should fire READYSTATE_COMPLETE and
         dataSetMemberChanged, which will cause this method to be called
         again.

         Our implementation immediately enumerates and fills the OSP before
         returning, so we always hand back an OSP if we return S_OK.
         
*/
STDMETHODIMP CADCCtl::msDataSourceObject(BSTR bstrQualifier, IUnknown **ppunk)
{
    HRESULT hres = E_FAIL;
    *ppunk = NULL;                      // NULL in case of failure

    // Let the event brokers initialize even before we have real data
    if (NULL == _rgparpevt[ENUM_OCSETUP])
        hres = _InitEventBrokers(NULL, TRUE);

    // Check the last event broker to determine if they were created correctly
    if (_rgparpevt[ENUM_OCSETUP])
    {
        DWORD dwEnum = _GetEnumAreaFromQualifier(bstrQualifier);

        TraceMsg(TF_CTL, "(Ctl) msDataSourceObject called for %d", dwEnum);

        if (dwEnum != ENUM_UNKNOWN)
        {
            // Hand back a data source object
            if (NULL == _rgparposp[dwEnum])
            {
                hres = THR(_CreateMatrixObject(dwEnum, &_rgparposp[dwEnum]));
                if (SUCCEEDED(hres))
                {
                    // Tell the OSP to enumerate the items.
                    hres = THR(_rgparposp[dwEnum]->EnumerateItemsAsync());
                    if (FAILED(hres))
                        _ReleaseMatrixObject(dwEnum);
                }
            }
            else
            {
                // Recalculate all the data. 
                hres = _rgparposp[dwEnum]->Recalculate();
                if (SUCCEEDED(hres))
                {
                    // fetch OLEDBSimpleProvider interface pointer and cache it
                    hres = THR(_rgparposp[dwEnum]->QueryInterface(IID_OLEDBSimpleProvider, (void **)ppunk));
                }
            }
        }
    }
    
    if (FAILED(hres))
        TraceMsg(TF_ERROR, "(Ctl) msDataSourceObject failed %s", Dbg_GetHRESULT(hres));
    else
        TraceMsg(TF_CTL, "(Ctl) msDataSourceObject returned %s and %#lx", Dbg_GetHRESULT(hres), *ppunk);

    return hres;
}


const IID IID_IDATASRCListener = {0x3050f380,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
const IID IID_DataSourceListener = {0x7c0ffab2,0xcd84,0x11d0,{0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed}};

//------------------------------------------------------------------------
//
//  Method:    addDataSourceListener()
//
//  Synopsis:  Sets the COM object which should receive notification
//             events.
//
//  Arguments: pEvent        Pointer to COM object to receive notification
//                           events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP CADCCtl::addDataSourceListener(IUnknown *punkListener)
{
    HRESULT hres = E_FAIL;

    TraceMsg(TF_CTL, "(Ctl) addDataSourceListener called.  Listener is %#lx", punkListener);

    ASSERT(IS_VALID_CODE_PTR(punkListener, IUnknown));
    
    DataSourceListener * pdsl;
    
    // Make sure this is the interface we expect
    hres = punkListener->QueryInterface(IID_DataSourceListener, (void **)&pdsl);
    if (SUCCEEDED(hres))
    {
        _InitEventBrokers(pdsl, FALSE);
        pdsl->Release();
    }
    
    return hres;
}

const TCHAR c_szStubWindowClass[] = TEXT("Add/Remove Stub Window");

HWND _CreateTransparentStubWindow(HWND hwndParent)
{
    WNDCLASS wc;
    RECT rc = {0};
    if (hwndParent)
    {
        RECT rcParent = {0};
        GetWindowRect(hwndParent, &rcParent);
        rc.left = (rcParent.left + RECTWIDTH(rcParent)) / 2;
        rc.top = (rcParent.top + RECTHEIGHT(rcParent)) / 2;
    }
    else
    {
        rc.left = CW_USEDEFAULT;
        rc.top = CW_USEDEFAULT;
    }
        
    if (!GetClassInfo(HINST_THISDLL, c_szStubWindowClass, &wc))
    {
        wc.style         = 0;
        wc.lpfnWndProc   = DefWindowProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = SIZEOF(DWORD) * 2;
        wc.hInstance     = HINST_THISDLL;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szStubWindowClass;

        RegisterClass(&wc);
    }

    // WS_EX_APPWINDOW makes this show up in ALT+TAB, but not the tray.
        
    return CreateWindowEx(WS_EX_TRANSPARENT, c_szStubWindowClass, TEXT(""), WS_POPUP | WS_VISIBLE, rc.left,
                          rc.top, 1, 1, hwndParent, NULL, HINST_THISDLL, NULL);
}


/*-------------------------------------------------------------------------
Purpose: Retreive the top level HWND for our HTA host from the clientsite 
         
*/
HRESULT CADCCtl::_GetToplevelHWND()
{
    HRESULT hres = E_FAIL;
    if (_pclientsite)
    {
        IOleInPlaceSite * pops = NULL;

        if (SUCCEEDED(_pclientsite->QueryInterface(IID_IOleInPlaceSite, (void **)&pops)))
        {
            pops->GetWindow(&_hwndTB);
            pops->Release();
            // Do we have a valid window?
            if (_hwndTB)
            {
                // Yes, then go up the hwnd chain to find the top level window
                HWND hwndTmp = NULL;
                while (hwndTmp = ::GetParent(_hwndTB))
                    _hwndTB = hwndTmp;

                hres = S_OK;
            }                
        }
    }

    return hres;
}

/*-------------------------------------------------------------------------
Purpose: Invoke a specific command.  The list of commands are specified
         in the APPCMD enumerated type.

         This method can be called via script.
         
*/
STDMETHODIMP CADCCtl::Exec(BSTR bstrQualifier, BSTR bstrCmd, LONG nRecord)
{
    SetErrorInfo(0, NULL);
    TraceMsg(TF_CTL, "(Ctl) Command (%ls, %d) called", bstrCmd, nRecord);
    
    // security check must pass before we could exec anything. 
    if (!_fSecure)
    {
        TraceMsg(TF_CTL, "(Ctl) Security blocked Exec call");
        return S_OK;        // scripting methods cannot return failure
    }

    // We should always get passed a legal qualifier
    DWORD dwEnum = _GetEnumAreaFromQualifier(bstrQualifier);
    RIP(dwEnum != ENUM_UNKNOWN);
    if (dwEnum == ENUM_UNKNOWN)
        return S_OK;
    
    const static struct {
        LPCWSTR pszCmd;
        APPCMD  appcmd;
    } s_rgCmds[] = {
        { L"install",           APPCMD_INSTALL },
        { L"uninstall",         APPCMD_UNINSTALL },
        { L"modify",            APPCMD_MODIFY },
        { L"upgrade",           APPCMD_UPGRADE },
        { L"repair",            APPCMD_REPAIR },
        { L"generic install",   APPCMD_GENERICINSTALL },
        { L"ntoptions",         APPCMD_NTOPTIONS },
        { L"winupdate",         APPCMD_WINUPDATE },
        { L"addlater",          APPCMD_ADDLATER },
    };

    int i;
    APPCMD appcmd = APPCMD_UNKNOWN;

    for (i = 0; i < ARRAYSIZE(s_rgCmds); i++)
    {
        if (0 == StrCmpIW(bstrCmd, s_rgCmds[i].pszCmd))
        {
            appcmd = s_rgCmds[i].appcmd;
            break;
        }
    }

    HWND hwndStub = NULL;

    if (_hwndTB == NULL)
        _GetToplevelHWND();
    
    if (_hwndTB)
    {
        hwndStub = _CreateTransparentStubWindow(_hwndTB);
        ::EnableWindow(_hwndTB, FALSE);
        ::SetActiveWindow(hwndStub);
    }        

    switch (appcmd)
    {
        case APPCMD_INSTALL:
        case APPCMD_UNINSTALL:
        case APPCMD_MODIFY:
        case APPCMD_UPGRADE:
        case APPCMD_REPAIR:
        case APPCMD_ADDLATER:
            if (_rgparposp[dwEnum])
                _rgparposp[dwEnum]->DoCommand(hwndStub, appcmd, nRecord);
            break;
                    
        case APPCMD_GENERICINSTALL:
            InstallAppFromFloppyOrCDROM(_hwndTB);
            break;

        case APPCMD_NTOPTIONS:
        {
            // command to invoke and OCMgr
            // "sysocmgr /x /i:%systemroot%\system32\sysoc.inf"
            TCHAR szInf[MAX_PATH];
            if (GetSystemDirectory(szInf, ARRAYSIZE(szInf)) && PathCombine(szInf, szInf, TEXT("sysoc.inf")))
            {
                TCHAR szParam[MAX_PATH];
                wsprintf(szParam, TEXT("/i:%s"), szInf);
                ShellExecute(NULL, NULL, TEXT("sysocmgr"), szParam, NULL, SW_SHOWDEFAULT);
            }
        }
        break;

        case APPCMD_WINUPDATE:
        {
            TCHAR szUrl[512];

            if (0 < LoadString(g_hinst, IDS_WINUPD_URL, szUrl, SIZECHARS(szUrl)))
            {
                ShellExecute(NULL, NULL, TEXT("wupdmgr.exe"), szUrl, NULL, SW_SHOWDEFAULT);
            }
        }
            break;

        case APPCMD_UNKNOWN:
            TraceMsg(TF_ERROR, "(Ctl) Received invalid appcmd %ls", bstrCmd);
            break;

        default:
            ASSERTMSG(0, "You forgot to add %d to the command list above", appcmd);
            break;
    }

    if (_hwndTB)
    {
        ::EnableWindow(_hwndTB, TRUE);
        if (hwndStub)
            ::DestroyWindow(hwndStub);
        ::SetForegroundWindow(_hwndTB);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Provide an interface to the policies stored in the registry
         to the poor scripting languages

         This method can be called via script.
         
*/
STDMETHODIMP CADCCtl::IsRestricted(BSTR bstrPolicy, VARIANT_BOOL * pbRestricted)
{
    RIP(pbRestricted);
    
    *pbRestricted = ARPGetRestricted(bstrPolicy) ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

/*-------------------------------------------------------------------------
Purpose: Reset the control's filter and sort criteria

         This method can be called via script.
         
*/
STDMETHODIMP CADCCtl::Reset(BSTR bstrQualifier)
{
    HRESULT hres = E_FAIL;
    DWORD dwEnum = _GetEnumAreaFromQualifier(bstrQualifier);

    // We should always get a legal qualifier
    RIP(dwEnum != ENUM_UNKNOWN);
    if (dwEnum == ENUM_UNKNOWN)
        return S_OK;
    
    // security check must pass before we could exec anything. 
    if (!_fSecure)
    {
        TraceMsg(TF_CTL, "(Ctl) Security blocked Reset call");
        return S_OK;        // scripting methods cannot return failure
    }

    TraceMsg(TF_CTL, "(Ctl) Reset called");

    // Infinite recursive calls to Reset can occur if script code calls reset
    // from within the datasetchanged event.  This isn't a good idea.
    if ( !_fInReset )
    {
        _fInReset = TRUE;   // prevent reentrancy

        // Did the EnumArea change OR
        // did the category change for these published apps?
        if (_fDirty || ((ENUM_PUBLISHED == dwEnum) && _fCategoryChanged))
        {
            // Yes; release the matrix object and recreate the event broker
            _ReleaseMatrixObject(dwEnum);
            
            // Make sure if we call Reset() right away now, we don't re-download
            // the data.
            _fDirty = FALSE;
            _fCategoryChanged = FALSE;

            // Create a new matrix object and read the new data into it
            hres = THR(_CreateMatrixObject(dwEnum, &_rgparposp[dwEnum]));
            if (SUCCEEDED(hres))
            {
                // Tell the OSP to enumerate the items.
                hres = THR(_rgparposp[dwEnum]->EnumerateItemsAsync());
                if (FAILED(hres))
                    ATOMICRELEASE(_rgparposp[dwEnum]);

             }
        }
        else if (_rgparposp[dwEnum])
        {
            // No; simply re-apply the sort and filter criteria
            hres = S_OK;

            // Did the sort criteria change since the last sort?
            if (S_OK == _rgparposp[dwEnum]->SetSortCriteria(_cbstrSort))
            {
                // Yes

                // Create a new matrix object and transfer the contents of the 
                // existing object to that.  We must do this because Trident's
                // databinding expects to get a different object from msDataSourceObject
                // when it queries for another dataset.
                IARPSimpleProvider * parposp;

                hres = THR(_CreateMatrixObject(dwEnum, &parposp));
                if (SUCCEEDED(hres))
                {
                    // Transferring the data is much faster than recreating it...
                    hres = THR(parposp->TransferData(_rgparposp[dwEnum]));
                    if (SUCCEEDED(hres))
                    {
                        // Release the old datasource and remember the new one
                        _ReleaseMatrixObject(dwEnum);
                        _rgparposp[dwEnum] = parposp;

                        // Now apply the sort on the new dataset
                        hres = _rgparposp[dwEnum]->Sort();
                    }
                }
            }

        }

        _fInReset = FALSE;
    }

    // reset should always return S_OK, otherwise we get scrip error.
    return S_OK;
}

HRESULT CADCCtl::_CheckSecurity(IOleClientSite * pClientSite)
{
    IOleContainer * poc;
    if (SUCCEEDED(pClientSite->GetContainer(&poc)))
    {
        IHTMLDocument2 * phd;
        if (SUCCEEDED(poc->QueryInterface(IID_IHTMLDocument2, (void **)&phd)))
        {
            IHTMLWindow2 * phw;
            if (SUCCEEDED(phd->get_parentWindow(&phw)))
            {
                IHTMLWindow2 * phwTop;
                if (SUCCEEDED(phw->get_top(&phwTop)))
                {
                    IHTMLLocation * phl;
                    if (SUCCEEDED(phwTop->get_location(&phl)))
                    {
                        BSTR bstrHref;
                        if (SUCCEEDED(phl->get_href(&bstrHref)))
                        {
                            ASSERT(IS_VALID_STRING_PTRW(bstrHref, -1));
                            WCHAR szResURL[] = L"res://appwiz.cpl/default.hta";
                            DWORD cchUrl = lstrlen(szResURL);
                            if (!StrCmpNIW(bstrHref, szResURL, cchUrl))
                            {
                                _fSecure = TRUE;
                            }

                            SysFreeString(bstrHref);   
                        }
                        phl->Release();
                    }
                    phwTop->Release();
                }
                phw->Release();
            }

            phd->Release();
        }
        poc->Release();
    }

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IOleObject::SetClientSite
   For security reasons, on top of ATL's implementation of this, we need to
   check our top level browser's URL location, it must be our official URL
   namely "res://appwiz.cpl/frm_*.htm"
*/
STDMETHODIMP CADCCtl::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hres = S_OK;
    
    // Has the site already been set?
    if (pClientSite != _pclientsite)
    {
        ATOMICRELEASE(_pclientsite);
        if (pClientSite)
        {
            // No; check some things out and cache them

            _hwndTB = NULL;

            _pclientsite = pClientSite;
            if (_pclientsite)
                _pclientsite->AddRef();

            _fSecure = FALSE;
            if (g_dwPrototype & PF_NOSECURITYCHECK)
            {
                _fSecure = TRUE;
            }
            else
                _CheckSecurity(_pclientsite);
        }

        hres = CComControlBase::IOleObject_SetClientSite(pClientSite);
    }


    return hres;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

INCLUDES = $(INCLUDES);..\winnt\$(O)

NO_BROWSER_FILE = 1

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\applist.c ===
//
//  AppList.C
//
//  Copyright (C) Microsoft, 1994, 1995, All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  ral 9/09/94 - Clean up
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"
#include "regstr.h"

#ifdef DOWNLEVEL

static const DWORD aApplistHelpIDs[] = {
    IDC_BUTTONSETUPFROMLIST, IDH_APPWIZ_NETINTALLL_BUTTON,
    IDC_APPLIST, IDH_APPWIZ_NETINSTALL_LIST,
    0, 0 };

#define INST_SECTION    TEXT("AppInstallList")   // RESOURCE?
#define MAX_KEY_SIZE    45000

//
//  Fills in the name of the INF file in the wiz data structure.  If
//  no INF file is specified then returns FALSE, else TRUE.
//

BOOL AppListGetInfName(LPWIZDATA lpwd)
{
    HKEY    hk;
    LONG    RegResult;
    DWORD   cbFileName = sizeof(lpwd->szIniFile);
    DWORD   dwType;
    BOOL    bFileExists = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &hk) != ERROR_SUCCESS)
    {
        return(FALSE);
    }
    RegResult = RegQueryValueEx(hk, REGSTR_VAL_APPINSTPATH, NULL,
                                &dwType, (LPBYTE) lpwd->szIniFile, &cbFileName);
    RegCloseKey(hk);

    if (RegResult == ERROR_SUCCESS && dwType == REG_SZ)
    {
        bFileExists = PathFileExists(lpwd->szIniFile);
    }

    if (!bFileExists)
    {
        lpwd->szIniFile[0] = 0;
    }

    return(bFileExists);
}


#ifdef DEBUG
void ValidateINIEntry(LPWIZDATA lpwd, LPTSTR lpszKeyName)
{
    TCHAR szFileName[MAX_PATH];

    if (GetPrivateProfileString(INST_SECTION, lpszKeyName, TEXT(""),
                      szFileName, ARRAYSIZE(szFileName),
                      lpwd->szIniFile))
    {
        LPTSTR lpszRealName = szFileName;

        if (*lpszRealName == TEXT('*'))
        {
            lpszRealName++;
        }

        if (!PathFileExists(lpszRealName))
        {
            ShellMessageBox(g_hinst, lpwd->hwnd,
                            TEXT("Entry for %1%s points to non-existant setup program: %2%s"),
                            0, MB_OK | MB_ICONEXCLAMATION, lpszKeyName, szFileName);
        }
    }
    else
    {
        ShellMessageBox(g_hinst, lpwd->hwnd,
                        TEXT("Bad INI file format for entry %1%s."),
                        0, MB_OK | MB_ICONEXCLAMATION, lpszKeyName);
    }
}
#endif // DEBUG


//
//  Initializes the applist property sheet.  This function assumes that
//  someone else (appwiz.c) has already called AppListGetInfName and the
//  inf file name has already been filled in in the wizard data structure.
//  If the string is empty, then this function simply returns.
//

void AppList_InitListBox(HWND hDlg, LPPROPSHEETPAGE lpp)
{
    LPWIZDATA lpwd = (LPWIZDATA)lpp->lParam;

    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpp);

    if (lpwd->szIniFile[0] != 0)
    {
        HWND   hLB = GetDlgItem(hDlg, IDC_APPLIST);
        LPTSTR lpszKeys = (LPTSTR)GlobalAllocPtr(GPTR, MAX_KEY_SIZE*sizeof(TCHAR));

        ListBox_ResetContent(hLB);

        //
        //  If the localalloc failed then we'll just have a
        //  empty list.
        //

        if (lpszKeys)
        {
            HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (GetPrivateProfileString(INST_SECTION, NULL, NULL, lpszKeys,
                              MAX_KEY_SIZE, lpwd->szIniFile))
            {
                LPTSTR lpszCurPos = lpszKeys;
                int    iCurLBPos = 0;

                while (*lpszCurPos)
                {
                    ListBox_InsertString(hLB, iCurLBPos++, lpszCurPos);
#ifdef DEBUG
                    ValidateINIEntry(lpwd, lpszCurPos);
#endif
                    while (*lpszCurPos != 0)
                    {
                        lpszCurPos = CharNext(lpszCurPos);
                    }
                    lpszCurPos++;
                }
            }
            GlobalFreePtr(lpszKeys);
            SetCursor(hcurOld);
        }
        ListBox_SetCurSel(hLB, 0);
    }
}


//
//  Copies the name of the setup program into the wizard data
//

BOOL GetListSel(HWND hLB, int iCurSel, LPWIZDATA lpwd)
{
    TCHAR szKeyName[MAX_PATH];

    if ((iCurSel != LB_ERR) &&
        (ListBox_GetTextLen(hLB, iCurSel) <= ARRAYSIZE(szKeyName)))
    {
        ListBox_GetText(hLB, iCurSel, szKeyName);

        if (GetPrivateProfileString(INST_SECTION, szKeyName, TEXT(""),
                          lpwd->szExeName, ARRAYSIZE(lpwd->szExeName),
                          lpwd->szIniFile))
        {
            lpwd->szParams[0] = 0;  // Make sure this string is empty
            return(TRUE);
        }
    }
    return(FALSE);
}


//
//  Dismisses the property sheet by pressing the "OK" button.
//

void DismissCPL(LPWIZDATA lpwd)
{
    PropSheet_PressButton(GetParent(lpwd->hwnd), PSBTN_OK);
}


//
//  Install property sheet page -- Used only if there is an AppInstallPath
//  specified in the registry.        Otherwise, use NoListInstallDlgProc.
//

BOOL_PTR CALLBACK AppListDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA        lpwd;


    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }
    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    lpwd->hwnd = hDlg;
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            AppList_InitListBox(hDlg, lpPropSheet);
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)aApplistHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)aApplistHelpIDs);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BUTTONSETUPFROMLIST:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        HWND        hLB = GetDlgItem(hDlg, IDC_APPLIST);
                        int iCurSel = ListBox_GetCurSel(hLB);

                        if (iCurSel != LB_ERR &&
                            GetListSel(hLB, iCurSel, lpwd) &&
                            ExecSetupProg(lpwd, FALSE, TRUE))
                        {
                            DismissCPL(lpwd);
                        }
                    }

                case IDC_APPLIST:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                    {
                        SendMessage(hDlg, WM_COMMAND,
                                     GET_WM_COMMAND_MPS(IDC_BUTTONSETUPFROMLIST,
                                       GetDlgItem(hDlg, IDC_BUTTONSETUPFROMLIST),
                                       BN_CLICKED));
                    }
                    break;

            }
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;

}  // AppListdlgProc

#endif // DOWNLEVEL


//
//  Executes the appropriate setup program
//

BOOL ExecSetupProg(LPWIZDATA lpwd, BOOL ForceWx86, BOOL bMinimizeWiz)
{
    SHELLEXECUTEINFO ei;
    BOOL fWorked= FALSE;

#ifdef WX86
    DWORD  Len;
    WCHAR  ProcArchValue[32];
#endif

    HWND hDlgPropSheet = GetParent(lpwd->hwnd);
    LPTSTR lpszTarget = NULL;

    ei.cbSize = sizeof(ei);
    ei.hwnd = lpwd->hwnd;
    ei.lpVerb = NULL;
    ei.fMask = 0;

    lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;
    if (lpszTarget[0] == TEXT('*'))
    {
        ei.lpFile = CharNext(lpszTarget);
        ei.fMask |= SEE_MASK_CONNECTNETDRV;
    }
    else
    {
        ei.lpFile = lpszTarget;
    }

    if (lpwd->szParams[0] == 0)
    {
        ei.lpParameters = NULL;
    }
    else
    {
        ei.lpParameters = lpwd->szParams;
    }

    if (lpwd->szWorkingDir[0] == TEXT('\0'))
    {
        ei.lpDirectory = NULL;
    }
    else
    {
        ei.lpDirectory = lpwd->szWorkingDir;
    }

    ei.lpClass = NULL;
    ei.nShow = SW_SHOWDEFAULT;
    ei.hInstApp = g_hinst;

    if (bMinimizeWiz)
        SetWindowPos(hDlgPropSheet, 0, 0, 0, 0, 0, SWP_HIDEWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);


#ifdef WX86
    if (ForceWx86) {
        Len = GetEnvironmentVariableW(ProcArchName,
                                      ProcArchValue,
                                      sizeof(ProcArchValue)
                                      );

        if (!Len || Len >= sizeof(ProcArchValue)) {
            ProcArchValue[0]=L'\0';
        }

        SetEnvironmentVariableW(ProcArchName, L"x86");
        ei.fMask |= SEE_MASK_FLAG_SEPVDM;

    }
#endif


    fWorked = ShellExecuteEx(&ei);


#ifdef WX86
    if (ForceWx86) {
        SetEnvironmentVariableW(ProcArchName, ProcArchValue);
    }
#endif



    if (!fWorked)
    {
        //
        // Something went wrong. Put the dialog back up.
        //

        SetWindowPos(hDlgPropSheet, 0, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADSETUP),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }

    return(fWorked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appmgr.inc ===
#
# Common makefile include for this project
#

TARGET_BOTH     = 1

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

                  
# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF       
!endif

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

CONDITIONAL_INCLUDES = \
                  macocidl.h \
                  version.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appsize.h ===
#ifndef __APPSIZE_H_
#define __APPSIZE_H_

#include <runtask.h>

// Folder size computation tree walker callback class
class CAppFolderSize : public IShellTreeWalkerCallBack
{
public:
    CAppFolderSize(ULONGLONG * puSize);
    virtual ~CAppFolderSize();

    // *** IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd); 
    STDMETHODIMP LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, HRESULT hrError);

    // *** Initailze the IShellTreeWalker * by CoCreateInstacing it
    HRESULT Initialize();

protected:
    ULONGLONG * _puSize;
    IShellTreeWalker * _pstw;

    UINT    _cRef;
    HRESULT _hrCoInit;
}; 

#endif // _APPSIZE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appmgr.cpp ===
// Appmgr.cpp : Implementation of CShellAppManager
#include "priv.h"

#include "appmgr.h"
#include "instenum.h"
#include "util.h"
#ifndef DOWNLEVEL_PLATFORM
#include "pubenum.h"
#endif //DOWNLEVEL_PLATFORM
#include "sccls.h"

#ifndef DOWNLEVEL_PLATFORM
#pragma message("DOWNLEVEL_PLATFORM is NOT defined")
#endif //DOWNLEVEL_PLATFORM

const TCHAR c_szTSMsiHackKey[] = TEXT("Software\\Policies\\Microsoft\\Windows\\Installer\\Terminal Server");
const TCHAR c_szTSMsiHackValue[] = TEXT("EnableAdminRemote");

/////////////////////////////////////////////////////////////////////////////
// CShellAppManager

// constructor
CShellAppManager::CShellAppManager() : _cRef(1)
{
    DllAddRef();
    TraceAddRef(CShellAppManager, _cRef);
    
    ASSERT(_hdpaPub == NULL);
#ifndef DOWNLEVEL_PLATFORM
    InitializeCriticalSection(&_cs);
    
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        // Enumerate all of the Application Publishers
        DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPUBLISHER);
        if (DCA_GetItemCount(hdca) > 0)
        {
            _Lock();
            // Create our internal list of IAppPublisher *  
            _hdpaPub = DPA_Create(4);

            if(_hdpaPub)
            {
                int idca;
                for (idca = 0; idca < DCA_GetItemCount(hdca); idca++)
                {
                    IAppPublisher * pap;
                    if (FAILED(DCA_CreateInstance(hdca, idca, IID_IAppPublisher, (LPVOID *) &pap)))
                        continue;

                    ASSERT(IS_VALID_CODE_PTR(pap, IAppPublisher));

                    if (DPA_AppendPtr(_hdpaPub, pap) == DPA_ERR)
                    {
                        pap->Release();
                        break;
                    }
                }

                // if we have no pointers in this array, don't bother create one
                if (DPA_GetPtrCount(_hdpaPub) == 0)
                {
                    DPA_Destroy(_hdpaPub);
                    _hdpaPub = NULL;
                }
            }
            _Unlock();
        }

        DCA_Destroy(hdca);
    }

    
    if (IsTerminalServicesRunning())
    {
        // Hack for MSI work on Terminal Server
        HKEY hkeyMsiHack = NULL; 
        DWORD lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyMsiHack);
        if (lRet == ERROR_FILE_NOT_FOUND)
        {
            lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  NULL, &hkeyMsiHack, NULL);
        }

        if (lRet == ERROR_SUCCESS)
        {
            DWORD dwType = 0;
            DWORD dwTSMsiHack = 0;
            DWORD cbSize = SIZEOF(dwTSMsiHack);


            if ((ERROR_SUCCESS != RegQueryValueEx(hkeyMsiHack, c_szTSMsiHackValue, 0, &dwType, (LPBYTE)&dwTSMsiHack, &cbSize))
                || (dwType != REG_DWORD) || (dwTSMsiHack != 1))
            {
                dwTSMsiHack = 1;
                if (RegSetValueEx(hkeyMsiHack, c_szTSMsiHackValue, 0, REG_DWORD, (LPBYTE)&dwTSMsiHack, SIZEOF(dwTSMsiHack)) == ERROR_SUCCESS)
                    _bCreatedTSMsiHack = TRUE;
            }

            RegCloseKey(hkeyMsiHack);
        }
    }
#endif //DOWNLEVEL_PLATFORM
}


// destructor
CShellAppManager::~CShellAppManager()
{
    if (_bCreatedTSMsiHack)
    {
        ASSERT(IsTerminalServicesRunning());
        HKEY hkeyMsiHack;
        DWORD lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, KEY_SET_VALUE, &hkeyMsiHack);
        if (ERROR_SUCCESS == lRet)
        {
            RegDeleteValue(hkeyMsiHack, c_szTSMsiHackValue);
            RegCloseKey(hkeyMsiHack);
        }
    }

    _Lock();
    // The order below is important
    if (_hdsaCategoryList)
        _DestroyInternalCategoryList();

    if (_hdpaPub)
        _DestroyAppPublisherList();

    _Unlock();

    DeleteCriticalSection(&_cs);
    DllRelease();
}


// Recursively destroys a GUIDLIST
void CShellAppManager::_DestroyGuidList(GUIDLIST * pGuidList)
{
    ASSERT(IS_VALID_WRITE_PTR(pGuidList, GUIDLIST));
    if (pGuidList->pNextGuid)
        _DestroyGuidList(pGuidList->pNextGuid);

    LocalFree(pGuidList);
}

void CShellAppManager::_DestroyCategoryItem(CATEGORYITEM * pci)
{
    ASSERT(IS_VALID_WRITE_PTR(pci, CATEGORYITEM));
    if (pci->pszDescription)
        LocalFree(pci->pszDescription);
    if (pci->pGuidList)
        _DestroyGuidList(pci->pGuidList);
}

// Destroys our Category List Table
void CShellAppManager::_DestroyInternalCategoryList()
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    ASSERT(IS_VALID_HANDLE(_hdsaCategoryList, DSA));
    int idsa;
    for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
    {
        CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
        if (pci)
            _DestroyCategoryItem(pci);
    }    
    DSA_Destroy(_hdsaCategoryList);
}

// Destroys our list of IAppPublisher *
void CShellAppManager::_DestroyAppPublisherList()
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);
    ASSERT(IS_VALID_HANDLE(_hdpaPub, DPA));
    int idpa;
    for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
    {
        IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
        if (EVAL(pap))
            pap->Release();
    }

    DPA_Destroy(_hdpaPub);
    _hdpaPub = NULL;
}

// IShellAppManager::QueryInterface
HRESULT CShellAppManager::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CShellAppManager, IShellAppManager),                  // IID_IShellAppManager
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IShellAppManager::AddRef
ULONG CShellAppManager::AddRef()
{
    InterlockedIncrement(&_cRef);
    TraceAddRef(CShellAppManager, _cRef);
    return _cRef;
}

// IShellAppManager::Release
ULONG CShellAppManager::Release()
{
    InterlockedDecrement(&_cRef);
    TraceRelease(CShellAppManager, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

void CShellAppManager::_Lock(void)
{
    EnterCriticalSection(&_cs);
    DEBUG_CODE( _cRefLock++; )
}

void CShellAppManager::_Unlock(void)
{
    DEBUG_CODE( _cRefLock--; )
    LeaveCriticalSection(&_cs);
}


STDMETHODIMP CShellAppManager::GetNumberofInstalledApps(DWORD * pdwResult)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellAppManager::EnumInstalledApps(IEnumInstalledApps ** ppeia)
{
    HRESULT hres = E_FAIL;
    CEnumInstalledApps * peia = new CEnumInstalledApps();
    if (peia)
    {
        *ppeia = SAFECAST(peia, IEnumInstalledApps *);
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}


#ifndef DOWNLEVEL_PLATFORM
HRESULT CShellAppManager::_AddCategoryToList(APPCATEGORYINFO * pai, IAppPublisher * pap)
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    if (pai == NULL || _hdsaCategoryList == NULL)
        return E_FAIL;

    ASSERT(IS_VALID_CODE_PTR(pap, IAppPublisher));
    
    // Allocate a GUIDLIST item first
    GUIDLIST * pgl  = (GUIDLIST *)LocalAlloc(LPTR, SIZEOF(GUIDLIST));
    if (!pgl)
        return E_OUTOFMEMORY;
    
    pgl->CatGuid    = pai->AppCategoryId;
    pgl->papSupport = pap;

    // Search in the CategoryList
    int idsa;
    for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
    {
        CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);

        if (pci)
        {
            // If we find an empty spot, fill it
            if (pci->pszDescription == NULL)
            {
                CATEGORYITEM ci = {0};
                ci.pszDescription = StrDupW(pai->pszDescription);
                ci.pGuidList    = pgl;

                pgl->pNextGuid  = NULL;

                if (DSA_InsertItem(_hdsaCategoryList, idsa, &ci) == -1)
                {
                    LocalFree(ci.pszDescription);
                    break;
                }
            }
            // If we find an entry with the same description text, add our GUID to the GuidList
            else if(!lstrcmpi(pai->pszDescription, pci->pszDescription))
            {
                pgl->pNextGuid  = pci->pGuidList;
                pci->pGuidList  = pgl;
                break;
            }
        }
        else
            ASSERT(0);
    }

    // We ran out of items in the list, and didn't run into an identical category string
    if (idsa == DSA_GetItemCount(_hdsaCategoryList))
    {
        CATEGORYITEM ci = {0};
        ci.pszDescription = StrDupW(pai->pszDescription);
        ci.pGuidList    = pgl;

        pgl->pNextGuid  = NULL;
        if (DSA_AppendItem(_hdsaCategoryList, &ci) == -1)
            LocalFree(ci.pszDescription);
    }
    
    return S_OK;
}
#endif //DOWNLEVEL_PLATFORM

#ifndef DOWNLEVEL_PLATFORM
HRESULT CShellAppManager::_BuildInternalCategoryList()
{
    HRESULT hres = E_OUTOFMEMORY;
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    ASSERT(IsValidHDPA(_hdpaPub));

    // We have just one valid version of _hdsaCategoryList, so we should never call this function
    // again once _hdsaCategoryList is created.
    ASSERT(_hdsaCategoryList == NULL);

    // Is the structure automatically filled with zero?
    _hdsaCategoryList =  DSA_Create(SIZEOF(CATEGORYITEM), CATEGORYLIST_GROW);

    if (_hdsaCategoryList)
    {
        int idpa;
        for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
        {
            IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
            ASSERT(pap);

            if (pap)
            {
                UINT i;
                APPCATEGORYINFOLIST AppCatList;
                if (SUCCEEDED(pap->GetCategories(&AppCatList)))
                {
                    if ((AppCatList.cCategory > 0) && AppCatList.pCategoryInfo)
                    {
                        for (i = 0; i < AppCatList.cCategory; i++)
                            _AddCategoryToList(&AppCatList.pCategoryInfo[i], pap);

                        _DestroyCategoryList(&AppCatList);
                    }
                }
            }

            hres = S_OK;
        }
    }

    return hres;
}
#endif //DOWNLEVEL_PLATFORM

#ifndef DOWNLEVEL_PLATFORM
// Compile a multi string of categories and return it to the caller
HRESULT CShellAppManager::_CompileCategoryList(PSHELLAPPCATEGORYLIST psacl)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(psacl, SHELLAPPCATEGORYLIST));
    
    // Don't do anything if we have an empty list
    if (_hdsaCategoryList && (DSA_GetItemCount(_hdsaCategoryList) > 0))
    {
        psacl->pCategory = (PSHELLAPPCATEGORY) SHAlloc(DSA_GetItemCount(_hdsaCategoryList) * SIZEOF(SHELLAPPCATEGORY));
        if (psacl->pCategory)
        {
            int idsa;
            for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
            {
                CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
                if (pci && pci->pszDescription)
                {
                    if (SUCCEEDED(SHStrDup(pci->pszDescription, &psacl->pCategory[idsa].pszCategory)))
                    {
                        ASSERT(IS_VALID_STRING_PTR(psacl->pCategory[idsa].pszCategory, -1));
                        psacl->cCategories++;
                    }
                    else
                        break;
                }
            }
            hres = S_OK;
        }
        else          
            hres = E_OUTOFMEMORY;
    }

    return hres;
}
#endif //DOWNLEVEL_PLATFORM

// IShellAppManager::GetPublishedAppCategories
STDMETHODIMP CShellAppManager::GetPublishedAppCategories(PSHELLAPPCATEGORYLIST psacl)
{
#ifndef DOWNLEVEL_PLATFORM
    HRESULT hres = E_INVALIDARG;
    if (psacl)
    {
        ASSERT(IS_VALID_READ_PTR(psacl, SHELLAPPCATEGORYLIST));
        ZeroMemory(psacl, SIZEOF(SHELLAPPCATEGORYLIST));

        // NOTE: keep the check inside the lock! So that only one thread
        // is allowed in.
        
        _Lock();
        // Do we have any app publishers in our list at all
        if (_hdpaPub)
        {
            if (_hdsaCategoryList == NULL)
                _BuildInternalCategoryList();

            hres = _CompileCategoryList(psacl);
        }
        _Unlock();
    }
#else
    HRESULT hres = E_NOTIMPL;
#endif //DOWNLEVEL_PLATFORM
    return hres;
}

#ifndef DOWNLEVEL_PLATFORM
GUIDLIST * CShellAppManager::_FindGuidListForCategory(LPCWSTR pszDescription)
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    if (_hdsaCategoryList)
    {
        int idsa;
        for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
        {
            CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
            if (pci && pci->pszDescription && !lstrcmpi(pszDescription, pci->pszDescription))
                return pci->pGuidList;
        }
    }
    return NULL;
}
#endif //DOWNLEVEL_PLATFORM

extern void _DestroyHdpaEnum(HDPA hdpaEnum);

// IShellAppManager::EnumPublishedApps
STDMETHODIMP CShellAppManager::EnumPublishedApps(LPCWSTR pszCategory, IEnumPublishedApps ** ppepa)
{
#ifndef DOWNLEVEL_PLATFORM
    HRESULT hres = E_OUTOFMEMORY;

    ASSERT(pszCategory == NULL || IS_VALID_STRING_PTRW(pszCategory, -1));

    // hdpaEnum is the list of IEnumPublishedApp * we pass to the constructor of CShellEnumPublishedApps
    HDPA hdpaEnum = DPA_Create(4);

    if (hdpaEnum)
    {
        // If no category is required, we enumerate all 
        if (pszCategory == NULL)
        {
            _Lock();
            if (_hdpaPub)
            {
                int idpa;
                for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
                {
                    IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
                    IEnumPublishedApps * pepa; 
                    if (pap && SUCCEEDED(pap->EnumApps(NULL, &pepa)))
                    {
                        ASSERT(IS_VALID_CODE_PTR(pepa, IEnumPublishedApps));
                        if (DPA_AppendPtr(hdpaEnum, pepa) == DPA_ERR)
                        {
                            pepa->Release();
                            break;
                        }
                    }
                }
            }
            _Unlock();
        }
        else
        {
            _Lock();
            // If there is no Category list, let's build one
            if (_hdsaCategoryList == NULL)
                _BuildInternalCategoryList();

            // Otherwise we find the GuidList and enumerate all the guys in the list
            GUIDLIST * pgl = _FindGuidListForCategory(pszCategory);
            
            while (pgl && pgl->papSupport)
            {
                ASSERT(IS_VALID_READ_PTR(pgl, GUIDLIST) && IS_VALID_CODE_PTR(pgl->papSupport, IAppPulisher));
                IEnumPublishedApps * pepa; 
                if (SUCCEEDED(pgl->papSupport->EnumApps(&pgl->CatGuid, &pepa)))
                {
                    ASSERT(IS_VALID_CODE_PTR(pepa, IEnumPublishedApps));
                    if (DPA_AppendPtr(hdpaEnum, pepa) == DPA_ERR)
                    {
                        pepa->Release();
                        break;
                    }
                }
                pgl = pgl->pNextGuid;
            }

            _Unlock();
        }
                
    }

    // Even if we have no enumerators we return success and pass back an empty enumerator
        
    CShellEnumPublishedApps * psepa = new CShellEnumPublishedApps(hdpaEnum);
    if (psepa)
    {
        *ppepa = SAFECAST(psepa, IEnumPublishedApps *);
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
        if (hdpaEnum)
            _DestroyHdpaEnum(hdpaEnum);
    }
#else
    HRESULT hres = E_NOTIMPL;
#endif //DOWNLEVEL_PLATFORM
    return hres;
}

EXTERN_C STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd);
STDMETHODIMP CShellAppManager::InstallFromFloppyOrCDROM(HWND hwndParent)
{
    return InstallAppFromFloppyOrCDROM(hwndParent);
}



/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CShellAppManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CShellAppManager* pObj = new CShellAppManager();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellAppManager *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appmgr.h ===
#ifndef __APPMGR_H_
#define __APPMGR_H_

#define REGSTR_PATH_APPPUBLISHER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\Publishers")

// Structure to contain the list of GUIDs for a category
typedef struct _GuidList
{
    GUID CatGuid;
    IAppPublisher * papSupport;
    struct _GuidList * pNextGuid;
} GUIDLIST;

/////////////////////////////////////////////////////////////////////////////
// CShellAppManager
class CShellAppManager : public IShellAppManager
{
public:
    CShellAppManager();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellAppManager
    STDMETHODIMP GetNumberofInstalledApps(DWORD * pdwResult);
    STDMETHODIMP EnumInstalledApps(IEnumInstalledApps ** ppeia);
    STDMETHODIMP GetPublishedAppCategories(PSHELLAPPCATEGORYLIST psacl);
    STDMETHODIMP EnumPublishedApps(LPCWSTR pszCategory, IEnumPublishedApps ** ppepa);
    STDMETHODIMP InstallFromFloppyOrCDROM(HWND hwndParent);

protected:

    virtual ~CShellAppManager();

    LONG _cRef;

    // App Publisher List
    HDPA _hdpaPub;

    // Item of the Internal Category List 
#define CATEGORYLIST_GROW 16
    typedef struct _CategoryItem
    {
        LPWSTR pszDescription;
        GUIDLIST * pGuidList;
    } CATEGORYITEM;

    // Category List
    HDSA _hdsaCategoryList;

    void    _Lock(void);
    void    _Unlock(void);
    
    CRITICAL_SECTION _cs;
    DEBUG_CODE( LONG _cRefLock; )

    // Internal structure funcitons
    void       _DestroyGuidList(GUIDLIST * pGuidList);
    
#ifndef DOWNLEVEL_PLATFORM
    HRESULT    _AddCategoryToList(APPCATEGORYINFO * pai, IAppPublisher * pap);
    HRESULT    _BuildInternalCategoryList(void);
    HRESULT    _CompileCategoryList(PSHELLAPPCATEGORYLIST pascl);
#endif //DOWNLEVEL_PLATFORM

    void       _DestroyCategoryItem(CATEGORYITEM * pci);
    void       _DestroyInternalCategoryList(void);
    void       _DestroyAppPublisherList(void);

#ifndef DOWNLEVEL_PLATFORM
    GUIDLIST * _FindGuidListForCategory(LPCWSTR pszDescription);
#endif //DOWNLEVEL_PLATFORM

    BOOL       _bCreatedTSMsiHack; // The "EnableAdminRemote" value for MSI to work on TS
};

#endif //__APPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appsize.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: appsize.cpp
//
// Compute the size of an application 
// 
// History:
//         2-17-98  by dli implemented CAppFolderSize
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "appsize.h"

// NOTE: CAppFolderSize and CAppFolderFinder are very similar to C*TreeWalkCB in Shell32.

CAppFolderSize::CAppFolderSize(ULONGLONG * puSize): _cRef(1), _puSize(puSize)
{
    _hrCoInit = CoInitialize(NULL);
}

CAppFolderSize::~CAppFolderSize()
{
    if (_pstw)
        _pstw->Release();

    if (SUCCEEDED(_hrCoInit))
    {
        CoUninitialize();
    }
}

HRESULT CAppFolderSize::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CAppFolderSize, IShellTreeWalkerCallBack),       // IID_IShellTreeWalkerCallBack
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}


ULONG CAppFolderSize::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CAppFolderSize::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAppFolderSize::Initialize()
{
    HRESULT hr = _hrCoInit;
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_IShellTreeWalker, (LPVOID *)&_pstw);
    }
    return hr;
}   

//
// IShellTreeWalkerCallBack::FoundFile 
//
HRESULT CAppFolderSize::FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    if (_puSize)
        *_puSize = ptws->ulActualSize;
    return hres;
}

HRESULT CAppFolderSize::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

//
// IShellTreeWalkerCallBack::LeaveFolder
//
HRESULT CAppFolderSize::LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws)
{
    return E_NOTIMPL;
}

//
// IShellTreeWalkerCallBack::HandleError 
//
HRESULT CAppFolderSize::HandleError(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, HRESULT ErrorCode)
{
    return E_NOTIMPL;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appwiz.c ===
//
//  APPWIZ.C        Application installation wizard CPL
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  ral 8/09/94 - Clean up
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include <cpl.h>
#include "util.h"
#include "resource.h"
#include <tsappcmp.h>       // for TermsrvAppInstallMode

#ifdef WINNT

//
// (tedm) Header files for Setup
//
#include <setupapi.h>
#include <syssetup.h>
#endif
    
TCHAR const c_szPIF[] = TEXT(".pif");
TCHAR const c_szLNK[] = TEXT(".lnk");

#ifdef WX86

BOOL
IsWx86Enabled(
    VOID
    )

//
// Consults the registry to determine if Wx86 is enabled in the system
// NOTE: this should be changed post SUR to call kernel32 which maintanes
//       this information, Instead of reading the registry each time.
//

{
    LONG Error;
    HKEY hKey;
    WCHAR ValueBuffer[MAX_PATH];
    DWORD ValueSize;
    DWORD dwType;

    Error = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\Wx86",
                        &hKey
                        );

    if (Error != ERROR_SUCCESS) {
        return FALSE;
        }

    ValueSize = sizeof(ValueBuffer);
    Error = RegQueryValueExW(hKey,
                             L"cmdline",
                             NULL,
                             &dwType,
                             (LPBYTE)ValueBuffer,
                             &ValueSize
                             );
    RegCloseKey(hKey);

    return (Error == ERROR_SUCCESS &&
            dwType == REG_SZ &&
            ValueSize &&
            *ValueBuffer
            );

}
#endif

const LPCTSTR g_szStartPages[] = { TEXT("remove"), TEXT("install"), TEXT("configurewindows") };
    
int ParseStartParams(LPCTSTR pcszStart)
{
    int iStartPage = 0;
    if (IsInRange(*pcszStart, TEXT('0'), TEXT('9')))
        return StrToInt(pcszStart);

    if (g_bRunOnNT5)
    {
        int i;
        for (i = 0; i < ARRAYSIZE(g_szStartPages); i++)
        {
            if (!StrCmpI(g_szStartPages[i], pcszStart))
            {
                iStartPage = i;
                break;
            }
        }
    }

    return iStartPage;
}

LONG CALLBACK CPlApplet(HWND hwnd, UINT Msg, LPARAM lParam1, LPARAM lParam2 )
{
    UINT nStartPage = MAX_PAGES;
//  not currently used by chicago   LPNEWCPLINFO lpNewCPlInfo;
    LPTSTR lpStartPage;

    switch (Msg)
    {
    case CPL_INIT:
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:
#define lpCPlInfo ((LPCPLINFO)lParam2)
        lpCPlInfo->idIcon = IDI_CPLICON;
        lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->idInfo = IDS_INFO;
        lpCPlInfo->lData  = 0;
#undef lpCPlInfo
        break;

    case CPL_DBLCLK:
#ifndef DOWNLEVEL
        OpenAppMgr(hwnd, 0);
#else
        InstallCPL(hwnd, 0);
#endif
        break;

    case CPL_STARTWPARMS:
        lpStartPage = (LPTSTR)lParam2;

        if (*lpStartPage)
            nStartPage = ParseStartParams(lpStartPage);

        //
        // Make sure that the requested starting page is less than the max page
        //        for the selected applet.

        if (nStartPage >= MAX_PAGES) return FALSE;

#ifndef DOWNLEVEL
        OpenAppMgr(hwnd, nStartPage);
#else
        InstallCPL(hwnd, nStartPage);
#endif

        return TRUE;  // return non-zero to indicate message handled

    default:
        return FALSE;
    }
    return TRUE;
}  // CPlApplet


#ifdef DOWNLEVEL

//
// This is the addpage which gets called back by external components (yay)
//

BOOL CALLBACK _AddExternalPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;

    if( hpage && ( ppsh->nPages < MAX_PAGES ) )
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

#endif // DOWNLEVEL


//
//  Adds a page to a property sheet.
//

void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPWIZDATA lpwd, DWORD dwPageFlags)
{
    if (ppsh->nPages < MAX_PAGES)
    {
       PROPSHEETPAGE psp;

       psp.dwSize = sizeof(psp);
       psp.dwFlags = dwPageFlags;
       psp.hInstance = g_hinst;
       psp.pszTemplate = MAKEINTRESOURCE(id);
       psp.pfnDlgProc = pfn;
       psp.lParam = (LPARAM)lpwd;

       ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);

       if (ppsh->phpage[ppsh->nPages])
           ppsh->nPages++;
    }
}  // AddPage


#ifdef DOWNLEVEL

//
//  Main control panel entry point.  Displays a property sheet with
//

void InstallCPL(HWND hwnd, UINT nStartPage)
{
    WIZDATA wd;
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    int iPrshtResult;

    memset(&wd, 0, sizeof(wd));

    //PROPSHEETHEADER_V1_SIZE: needs to run on downlevel platform (NT4, Win95)

    psh.dwSize = PROPSHEETHEADER_V1_SIZE;
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hwnd;
    psh.hInstance = g_hinst;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
    psh.nPages = 0;
    psh.nStartPage = nStartPage;
    psh.phpage = rPages;

    //
    //       If there's no net install list then we'll decrement the start page
    //       by 1 so that the tab numbers can remain constant.
    //

    if (AppListGetInfName(&wd))
    {
       AddPage(&psh, DLG_APPLIST, AppListDlgProc, &wd, PSP_DEFAULT);
    }
    else
    {
       if (psh.nStartPage > 0)
       {
           psh.nStartPage--;
       }
    }

    AddPage(&psh, DLG_INSTUNINSTALL, InstallUninstallDlgProc, &wd, PSP_DEFAULT);

#ifdef WINNT
    //
    // (tedm)
    //
    // Setup on NT is completely different. No calling into 16-bit DLLs, etc.
    // Just ask the system setup module for its optional components page.
    //
    SetupCreateOptionalComponentsPage(_AddExternalPage,(LPARAM)&psh);
#else
    // Have (16-bit) SETUPX add the Optional Components page
    SHAddPages16( NULL, TEXT("SETUPX.DLL,SUOCPage"), _AddExternalPage,
         (LPARAM)&psh );

    // Have (16-bit) SETUPX add the Emergency Boot Disk page
    SHAddPages16( NULL, TEXT("SETUPX.DLL,SUEBDPage"), _AddExternalPage,
         (LPARAM)&psh );
#endif

    iPrshtResult = (int)PropertySheet(&psh);

    switch(iPrshtResult)
    {
       case ID_PSRESTARTWINDOWS:
       case ID_PSREBOOTSYSTEM:
           RestartDialogEx(hwnd, NULL,
                       iPrshtResult == ID_PSRESTARTWINDOWS ?
                           EW_RESTARTWINDOWS : EW_REBOOTSYSTEM,
                       SHTDN_REASON_FLAG_PLANNED |
                       SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                       SHTDN_REASON_MINOR_RECONFIG);
           break;
    }
}

#endif // DOWNLEVEL


// This function disables auto-run during the add from floppy or CD wizard.
// It is a subclass of the property sheet window.

LRESULT CALLBACK WizParentWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                        UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    static UINT msgQueryCancelAutoPlay = 0;

    if (!msgQueryCancelAutoPlay)
        msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));

    if (uMsg == msgQueryCancelAutoPlay)
    {
        return TRUE; // Yes, cancel auto-play when wizard is running
    }
    else
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);        
    }

}

// The following callback is specified when a wizard wants to disable auto-run.
// The callback subclasses the wizard's window, to catch the QueryCancelAutoRun
// message sent by the shell when it wants to auto-run a CD.

int CALLBACK DisableAutoRunCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        SetWindowSubclass(hwnd, WizParentWindowProc, 0, 0);
    }

    return 0;
}

//
//  Common code used by the Link and Setup wizards to initialize the
//  property sheet header and wizard data.
//

void InitWizHeaders(LPPROPSHEETHEADER ppd,
                          HPROPSHEETPAGE *rPages,
                          LPWIZDATA lpwd, int iBmpID, DWORD dwFlags)
{
    lpwd->hbmpWizard = LoadBitmap(g_hinst, MAKEINTRESOURCE(iBmpID));

    //PROPSHEETHEADER_V1_SIZE: needs to run on downlevel platform (NT4, Win95)

    ppd->dwSize = PROPSHEETHEADER_V1_SIZE;
    ppd->dwFlags = dwFlags;
    ppd->hwndParent = lpwd->hwnd;
    ppd->hInstance = g_hinst;
    ppd->pszCaption = NULL;
    ppd->nPages = 0;
    ppd->nStartPage = 0;
    ppd->phpage = rPages;

    if (lpwd->dwFlags & WDFLAG_NOAUTORUN)
    {
        ppd->dwFlags |= PSH_USECALLBACK;
        ppd->pfnCallback = DisableAutoRunCallback;
    }
}


//
//  Called when a wizard is dismissed.       Cleans up any garbage left behind.
//

void FreeWizData(LPWIZDATA lpwd)
{
    if (lpwd->hbmpWizard)
    {
       DeleteObject(lpwd->hbmpWizard);
       lpwd->hbmpWizard = NULL;
    }
}

typedef struct _WIZPAGE {
    int     id;
    DLGPROC pfn;
} WIZPAGE;


//
//  Common code used by the Link Wizard and App Wizard (PIF
//  wizard).
//

BOOL DoWizard(LPWIZDATA lpwd, int iIDBitmap, const WIZPAGE *wp, int PageCount, 
              DWORD dwWizardFlags, DWORD dwPageFlags)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    int i;
    HWND    hwnd, hwndT;
    BOOL    bResult = FALSE;
    BOOL    bChangedIcon = FALSE;
    HICON   hicoPrev;

    if (SUCCEEDED(CoInitialize(NULL)))
    {
        InitWizHeaders(&psh, rPages, lpwd, iIDBitmap, dwWizardFlags);

        for (i = 0; i < PageCount; i++)
        {
           AddPage(&psh, wp[i].id, wp[i].pfn, lpwd, dwPageFlags);
        }

        // Walk up the parent/owner chain until we find the master owner.
        //
        // We need to walk the parent chain because sometimes we are given
        // a child window as our lpwd->hwnd.  And we need to walk the owner
        // chain in order to find the owner whose icon will be used for
        // Alt+Tab.
        //
        // GetParent() returns either the parent or owner.  Normally this is
        // annoying, but we luck out and it's exactly what we want.

        hwnd = lpwd->hwnd;
        while ((hwndT = GetParent(hwnd)) != NULL)
        {
            hwnd = hwndT;
        }

        // If the master owner isn't visible we can futz his icon without
        // screwing up his appearance.
        if (!IsWindowVisible(hwnd))
        {
            HICON hicoNew = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON));
            hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
            bChangedIcon = TRUE;
        }

        bResult = (BOOL)PropertySheet(&psh);
        FreeWizData(lpwd);

        // Clean up our icon now that we're done
        if (bChangedIcon)
        {
            // Put the old icon back
            HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
            if (hicoNew)
                DestroyIcon(hicoNew);
        }

        CoUninitialize();
    }

    return bResult;
}

//
//The same as DoWizard except that it returns FALSE only in case of an error.
//Used by SetupWizard.
//(DoWizard is buggy. In case of an error it may return either 0 or -1 and it
// returns 0 when user hits "Cancel" button)
//
BOOL DoWizard2(LPWIZDATA lpwd, int iIDBitmap, const WIZPAGE *wp, int PageCount, 
              DWORD dwWizardFlags, DWORD dwPageFlags)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    int i;
    HWND    hwnd, hwndT;
    BOOL    bResult = FALSE;
    BOOL    bChangedIcon = FALSE;
    HICON   hicoPrev;
    
    //
    //No support for modeless dialogs
    //
    ASSERT(!(dwWizardFlags & PSH_MODELESS));

    if(dwWizardFlags & PSH_MODELESS)
    {
        return FALSE;
    }

    if (SUCCEEDED(CoInitialize(NULL)))
    {
        InitWizHeaders(&psh, rPages, lpwd, iIDBitmap, dwWizardFlags);

        for (i = 0; i < PageCount; i++)
        {
           AddPage(&psh, wp[i].id, wp[i].pfn, lpwd, dwPageFlags);
        }

        // Walk up the parent/owner chain until we find the master owner.
        //
        // We need to walk the parent chain because sometimes we are given
        // a child window as our lpwd->hwnd.  And we need to walk the owner
        // chain in order to find the owner whose icon will be used for
        // Alt+Tab.
        //
        // GetParent() returns either the parent or owner.  Normally this is
        // annoying, but we luck out and it's exactly what we want.

        hwnd = lpwd->hwnd;
        while ((hwndT = GetParent(hwnd)) != NULL)
        {
            hwnd = hwndT;
        }

        // If the master owner isn't visible we can futz his icon without
        // screwing up his appearance.
        if (!IsWindowVisible(hwnd))
        {
            HICON hicoNew = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON));
            hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
            bChangedIcon = TRUE;
        }

        bResult = (PropertySheet(&psh) != -1);
        FreeWizData(lpwd);

        // Clean up our icon now that we're done
        if (bChangedIcon)
        {
            // Put the old icon back
            HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
            if (hicoNew)
                DestroyIcon(hicoNew);
        }

        CoUninitialize();
    }

    return bResult;
}

//
//  Link Wizard
//

BOOL LinkWizard(LPWIZDATA lpwd)
{
    BOOL fSuccess;

    static const WIZPAGE wp[] = {
                   {DLG_BROWSE,         BrowseDlgProc},
                   {DLG_PICKFOLDER,     PickFolderDlgProc},
                   {DLG_GETTITLE,       GetTitleDlgProc},
                   {DLG_PICKICON,       PickIconDlgProc},
                   {DLG_WHICHCFG,       PickConfigDlgProc},
                   {DLG_RMOPTIONS,      ConfigOptionsDlgProc} };

    // Don't set lpwd->hwnd to NULL!
    // We must create the link wizard with a parent or you end up with one
    // thread displaying two independent top-level windows and things get
    // really weird really fast.

    fSuccess = DoWizard(lpwd, IDB_SHORTCUTBMP, wp, ARRAYSIZE(wp), 
                        PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD_LITE,
                        PSP_DEFAULT | PSP_HIDEHEADER);
    
    return fSuccess;
}


BOOL SetupWizard(LPWIZDATA lpwd)
{
    // This is what the user normally sees when using the Add/Remove Programs
    // control panel.
    static const WIZPAGE wp_normal[] = {
                   {DLG_SETUP, SetupDlgProc},
                   {DLG_SETUPBROWSE, SetupBrowseDlgProc},
#ifndef DOWNLEVEL
#ifdef WINNT
                   {DLG_CHGUSRFINISH_PREV, ChgusrFinishPrevDlgProc},
                   {DLG_CHGUSRFINISH, ChgusrFinishDlgProc}
#endif // WINNT
#endif // DOWNLEVEL
    };

    // This is the wizard that is used when the user double clicks on a setup
    // program and the shell uses us to enter Install Mode if Terminal Server
    // is installed.
    static const WIZPAGE wp_TSAutoInstall[] = {
#ifndef DOWNLEVEL
#ifdef WINNT
                   {DLG_CHGUSRFINISH_PREV, ChgusrFinishPrevDlgProc},
                   {DLG_CHGUSRFINISH, ChgusrFinishDlgProc}
#endif // WINNT
#endif // DOWNLEVEL
    };

    BOOL fResult;
    static const WIZPAGE * pwpToUse = wp_normal;
    DWORD dwPages = ARRAYSIZE(wp_normal);
    
    if (WDFLAG_AUTOTSINSTALLUI & lpwd->dwFlags)
    {
        pwpToUse = wp_TSAutoInstall;
        dwPages = ARRAYSIZE(wp_TSAutoInstall);
    }

    lpwd->dwFlags |= WDFLAG_SETUPWIZ;

    if (g_bRunOnNT5)
    {
        fResult = DoWizard2(lpwd, IDB_INSTALLBMP, pwpToUse, dwPages, 
                           PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD_LITE,
                           PSP_DEFAULT | PSP_HIDEHEADER);
    }
    else
    {
        fResult = DoWizard2(lpwd, IDB_LEGACYINSTALLBMP, pwpToUse, dwPages, 
                           PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD,
                           PSP_DEFAULT);
    }

    lpwd->dwFlags &= ~WDFLAG_SETUPWIZ;
    return(fResult);
}


STDAPI InstallAppFromFloppyOrCDROMEx(IN HWND hwnd, IN OPTIONAL DWORD dwAdditionalFlags,
  IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN LPVOID lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo, 
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    WIZDATA wd = {0};
    HRESULT hr = S_OK;
    BOOL bModeChanged = FALSE;
    wd.hwnd = hwnd;
    wd.dwFlags |= (WDFLAG_NOAUTORUN | dwAdditionalFlags);

#ifdef WINNT
    if (IsTerminalServicesRunning() && !IsUserAnAdmin()) 
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_RESTRICTION),
           MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
        return S_FALSE;
    }

    if (WDFLAG_AUTOTSINSTALLUI & wd.dwFlags)
    {
        // Remember the previous "InstallMode"
        wd.bPrevMode = TermsrvAppInstallMode();

        // Set the "InstallMode"
        SetTermsrvAppInstallMode(TRUE);
        
        if (!CreateProcessW(lpApplicationName,  (LPWSTR)lpCommandLine, lpProcessAttributes, lpThreadAttributes,
                        bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                        lpProcessInformation))
        {
            SetTermsrvAppInstallMode(wd.bPrevMode);
            hr = E_FAIL;
        }

        bModeChanged = TRUE;
    }
#endif

    if (SUCCEEDED(hr) && !SetupWizard(&wd))
    {
        if(bModeChanged)
        {
            //
            //SetupWizard that suppose to return system to EXECUTE mode failed.
            //make sure that it does not remain in INSTALL mode.
            //
            SetTermsrvAppInstallMode(wd.bPrevMode);
        }

        hr = E_FAIL;
    }

    return hr;
}


STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd)
{
    return InstallAppFromFloppyOrCDROMEx(hwnd, 0, NULL, NULL, NULL, NULL, FALSE, 0, NULL, NULL, NULL, NULL);
}


//
//
//

BOOL MSDOSPropOnlyWizard(LPWIZDATA lpwd)
{
    static const WIZPAGE wp[] = { {DLG_RMOPTIONS, ConfigOptionsDlgProc} };
    lpwd->dwFlags |= WDFLAG_PIFPROP;

    return DoWizard(lpwd, IDB_DOSCONFIG, wp, ARRAYSIZE(wp), PSH_PROPTITLE | PSH_WIZARD,
        PSP_DEFAULT);
}


//
//  RUNDLL entry point to create a new link.  An empty file has already been
//  created and is the only parameter passed in lpszCmdLine.
//
//  hAppInstance is never used.

void WINAPI NewLinkHere_Common(HWND hwnd, HINSTANCE hAppInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    WIZDATA wd;
    TCHAR   szFolder[MAX_PATH];

    memset(&wd, 0, sizeof(wd));

    wd.hwnd = hwnd;
    wd.dwFlags |= WDFLAG_LINKHEREWIZ | WDFLAG_DONTOPENFLDR;
    wd.lpszOriginalName = lpszCmdLine;

    lstrcpyn(szFolder, lpszCmdLine, ARRAYSIZE(szFolder));

    PathRemoveFileSpec(szFolder);

    wd.lpszFolder = szFolder;

    //
    // If the filename passed in is not valid then we'll just silently fail.
    //

    if (PathFileExists(lpszCmdLine))
    {
       if (!LinkWizard(&wd))
       {
           DeleteFile(lpszCmdLine);
       }
    }
    else
    {
       #define lpwd (&wd)
       TraceMsg(TF_ERROR, "%s", "APPWIZ ERORR:  Bogus file name passed to NewLinkHere");
       TraceMsg(TF_ERROR, "%s", lpszCmdLine);
       #undef lpwd
    }
}

void WINAPI NewLinkHere(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*SIZEOF(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        NewLinkHere_Common( hwndStub,
                            hAppInstance,
                            lpwszCmdLine,
                            nCmdShow );
        LocalFree(lpwszCmdLine);
    }
#else
    NewLinkHere_Common( hwndStub,
                             hAppInstance,
                             lpszCmdLine,
                             nCmdShow );
#endif
}

void WINAPI NewLinkHereW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    NewLinkHere_Common( hwndStub,
                             hAppInstance,
                             lpwszCmdLine,
                             nCmdShow );
#else
    UINT iLen = WideCharToMultiByte(CP_ACP, 0,
                                    lpwszCmdLine, -1,
                                    NULL, 0, NULL, NULL)+1;
    LPSTR  lpszCmdLine;

    lpszCmdLine = (LPSTR)LocalAlloc(LPTR,iLen);
    if (lpszCmdLine)
    {
        WideCharToMultiByte(CP_ACP, 0,
                            lpwszCmdLine, -1,
                            lpszCmdLine, iLen,
                            NULL, NULL);
        NewLinkHere_Common( hwndStub,
                            hAppInstance,
                            lpszCmdLine,
                            nCmdShow );
        LocalFree(lpszCmdLine);
    }
#endif
}

//
//  Entry point called from PIFMGR.DLL.  We'll only display the MS-DOS options
//  page for the specified hProps.
//
//  NOTE:  In this instance we want to LocalAlloc the wizard data since
//          we're being called from a 16-bit application (with limited stack).
//          Note that LPTR zero-initializes the block.
//

PIFWIZERR WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT dwAction)
{
    LPWIZDATA lpwd = (LPWIZDATA)LocalAlloc(LPTR, sizeof(WIZDATA));
    PIFWIZERR err = PIFWIZERR_SUCCESS;

    if (!lpwd)
    {
       return(PIFWIZERR_OUTOFMEM);
    }

    lpwd->hProps = hProps;
    lpwd->hwnd = hwnd;

    switch (dwAction)
    {
       case WIZACTION_UICONFIGPROP:
           if (!MSDOSPropOnlyWizard(lpwd))
           {
              err = PIFWIZERR_USERCANCELED;
           }
           break;

       case WIZACTION_SILENTCONFIGPROP:
           err = ConfigRealModeOptions(lpwd, NULL, CRMOACTION_DEFAULT);
           break;

       case WIZACTION_CREATEDEFCLEANCFG:
           err = ConfigRealModeOptions(lpwd, NULL, CRMOACTION_CLEAN);
           break;

       default:
           err = PIFWIZERR_INVALIDPARAM;
    }

    LocalFree((LPVOID)lpwd);
    return(err);
}


//
//  Called directly by Cabinet
//

BOOL ConfigStartMenu(HWND hwnd, BOOL bDelete)
{
    if (bDelete)
    {
       return(RemoveItemsDialog(hwnd));
    }
    else
    {
       WIZDATA wd;

       memset(&wd, 0, sizeof(wd));

       wd.hwnd = hwnd;
       wd.dwFlags |= WDFLAG_DONTOPENFLDR;

       return(LinkWizard(&wd));
    }
}


//
//  This is a generic function that all the app wizard sheets call
//  to do basic initialization.
//

LPWIZDATA InitWizSheet(HWND hDlg, LPARAM lParam, DWORD dwFlags)
{
    LPPROPSHEETPAGE ppd  = (LPPROPSHEETPAGE)lParam;
    LPWIZDATA       lpwd = (LPWIZDATA)ppd->lParam;
    HWND            hBmp = GetDlgItem(hDlg, IDC_WIZBMP);

    lpwd->hwnd = hDlg;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    SendMessage(hBmp, STM_SETIMAGE,
              IMAGE_BITMAP, (LPARAM)lpwd->hbmpWizard);

    return(lpwd);
}

void CleanUpWizData(LPWIZDATA lpwd)
{
    //
    // Release any INewShortcutHook.
    //

    if (lpwd->pnshhk)
    {
        lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
        lpwd->pnshhk = NULL;
    }

    return;
}

HRESULT InstallOnTerminalServerWithUI(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN LPVOID lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo, 
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    return InstallAppFromFloppyOrCDROMEx(hwnd, WDFLAG_AUTOTSINSTALLUI, lpApplicationName, lpCommandLine, lpProcessAttributes, 
                        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, 
                        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appwiz.h ===
//
//  APPWIZ.H -- App install wizard header file
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - Copied from INTL CPL
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//  3/14/98  [scotth] - reworked into shell 5 project
//

#ifndef _APPWIZ_H_
#define _APPWIZ_H_

#include <pif.h>        // for PROPPRG
#include <apwizhlp.h>
#include "appwizid.h"
#include <shsemip.h>    // for RestartDialog

#define CPLMODE_NORMAL            0
#define CPLMODE_AUTOMSDOS   1
#define CPLMODE_PROPWIZ     2

#define MAX_PAGES  15           // limit on number of pages we can have

#define WDFLAG_NOBROWSEPAGE 0x00000001        // Don't let user pick exe name
#define WDFLAG_APPKNOWN     0x00000002        // Finish after selecting folder
#define WDFLAG_DOSAPP       0x00000004        // Exe is a DOS program
#define WDFLAG_SINGLEAPP    0x00000008        // Single MS-DOS app mode
#define WDFLAG_PIFPROP      0x00000010        // Called from PIF property sheet
#define WDFLAG_LINKHEREWIZ  0x00000020        // Create empty link (NOT IMPLEMENTED!)
#define WDFLAG_INEDITMODE   0x00000040        // Editing a folder label
#define WDFLAG_DONTOPENFLDR 0x00000080        // Don't open folder when link made
#define WDFLAG_REALMODEONLY 0x00000100        // Don't use any prot mode drivers
#define WDFLAG_COPYLINK     0x00000200        // Copy link, don't create new one.
#define WDFLAG_SETUPWIZ     0x00000400        // Setup from disk wizard
#define WDFLAG_READOPTFLAGS 0x00000800        // Value in dwDosOptGlobalFlags is valid
#define WDFLAG_NOAUTORUN    0x00001000        // Disable autorun while wizard is running
#define WDFLAG_AUTOTSINSTALLUI 0x00002000        // Automate Install Mode (For people double clicking or calling ShellExecute() on setup programs)
#define WDFLAG_EXPSZ        0x10000000        // WizData contains expanded strings

typedef struct _DOSOPT {
    HKEY        hk;
    DWORD        dwFlags;
    UINT        uOrder;
    DWORD        dwStdOpt;
} DOSOPT, FAR * LPDOSOPT;


//////////////////////////////////////////////////////////////////////////////
//
// UNINSTALL_ITEM -- more info kept in an array paralell to the listbox
//
//////////////////////////////////////////////////////////////////////////////

typedef struct
{
    TCHAR command[ MAX_PATH ];  // command to run which will nuke the app

} UNINSTALL_ITEM, FAR * LPUNINSTALL_ITEM;



typedef struct _WIZDATA {
    HWND        hwnd;
    DWORD       dwFlags;
    HANDLE      hProps;                 // handle to PIFMGR properties, 0 if none
    TCHAR       szExeName[MAX_PATH];
    TCHAR       szExpExeName[MAX_PATH];
    TCHAR       szParams[MAX_PATH];
    TCHAR       szIniFile[MAX_PATH];
    TCHAR       szProgDesc[MAX_PATH];
    TCHAR       szWorkingDir[MAX_PATH];
    HBITMAP     hbmpWizard;
    HIMAGELIST  himl;
    LPTSTR      lpszFolder;
    PROPPRG     PropPrg;
    INT         NumOpts;
    LPDOSOPT    DosOpt;
    LPTSTR      lpszOriginalName;       // if non-null then link exists already
    LPUNINSTALL_ITEM        lpUItem;
    DWORD       dwDosOptGlobalFlags;    // Use function to access this field

#ifndef NO_NEW_SHORTCUT_HOOK
    INewShortcutHook *pnshhk;
    TCHAR     szExt[MAX_PATH];
#ifdef UNICODE
    INewShortcutHookA *pnshhkA;
#endif    
#endif

#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT
    BOOL        bTermSrvAndAdmin;
    BOOL        bPrevMode;
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM

} WIZDATA, FAR * LPWIZDATA;

//
// Private messages
//
#define WMPRIV_POKEFOCUS    WM_APP+0

//
// Wizard entry points.
//
BOOL LinkWizard(LPWIZDATA);
BOOL SetupWizard(LPWIZDATA);
BOOL MSDOSPropOnlyWizard(LPWIZDATA);

//
//  Inserts a single column into the specified ListView.
//
void InitSingleColListView(HWND hLV);


//
// Main appwiz property sheet
//
BOOL_PTR CALLBACK AppListDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK InstallUninstallDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
//  Pushes the "OK" button on a property sheet.
//
void DismissCPL(LPWIZDATA);

//
// Setup wizard pages
//
BOOL_PTR CALLBACK SetupDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrFinishDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrFinishPrevDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
// Shortcut wizard pages
//
BOOL_PTR CALLBACK BrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK SetupBrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK PickFolderDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK GetTitleDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK PickConfigDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ConfigOptionsDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
// Function in Folder.C that is used for removing folders from the task bar
// property sheet.
//
BOOL RemoveItemsDialog(HWND hParent);


//
// Strips "@" characters from a string resource and replaces them with NULLs
// Returns TRUE if succeeded
//
EXTERN_C BOOL LoadAndStrip(int id, LPTSTR lpsz, int cbstr);

//
//  Returns the path to the boot directory.
//
void GetBootDir(LPTSTR lpszBootDir, int cbBootDir);

//
// Exec the program.  Used by Setup and AppList
//
BOOL ExecSetupProg(LPWIZDATA lpwd, BOOL ForceWx86, BOOL bMinWiz);

//
// Skip to next string in doubly null terminated string
//
LPTSTR SkipStr(LPTSTR);

//
// Used by all wizard sheets at WM_INITDIALOG
//
LPWIZDATA InitWizSheet(HWND hDlg, LPARAM lParam, DWORD dwFlags);

//
// Used by all wizard sheets at PSN_RESET
//
void CleanUpWizData(LPWIZDATA lpwd);

//
// Thunked exports for 16-bit apps/dlls
//
void InstallCPL(HWND hwnd, UINT nStartPage);

//
// Functions for links
//
BOOL CreateLink(LPWIZDATA);
BOOL GetLinkName(LPTSTR, LPWIZDATA);


//
// Created by the thunk scripts
//
BOOL WINAPI Pif3216_ThunkConnect32(LPCTSTR pszDll16, LPCTSTR pszDll32, HANDLE hIinst, DWORD dwReason);
BOOL WINAPI Pif1632_ThunkConnect32(LPCTSTR pszDll16, LPCTSTR pszDll32, HANDLE hIinst, DWORD dwReason);


BOOL GetSingleAppInfo(LPWIZDATA);

//
// Gets the INF name for install programs.  Returns false if none.
//
BOOL AppListGetInfName(LPWIZDATA);

//
//  Functions determine info about lpwd->szExeName
//
void DetermineExeType(LPWIZDATA);

//
//  Fills in the szProgDesc field of the wizdata structure.
//
BOOL DetermineDefaultTitle(LPWIZDATA);

//
//  Strip the extension off of a file name.
//
void StripExt(LPTSTR lpsz);


//
//  If hProp == 0 then creates a link, otherwise sets configuration for
//  property handle.  If hwndOptList is NULL then auto-configures based on
//  information in PropPrg.dwRealModeFlags.
//
PIFWIZERR ConfigRealModeOptions(LPWIZDATA lpwd, HWND hwndOptList, UINT uAction);

#define CRMOACTION_DEFAULT      0        // Use appropriate default
#define CRMOACTION_CLEAN        1        // Force it to be a clean config
#define CRMOACTION_CURRENT      2        // Force it to use the current config

//
//  Returns the GlobalFlags setting from the registry for MS-DOS options.
//
DWORD GetMSDOSOptGlobalFlags(LPWIZDATA lpwd);

//
// Global data
//
extern int g_cxIcon;
extern int g_cyIcon;

extern TCHAR const c_szPIF[];
extern TCHAR const c_szLNK[];


#ifdef WX86
//
// from uninstal.c
//
extern BOOL bWx86Enabled;
extern BOOL bForceX86Env;
extern const WCHAR ProcArchName[];
#endif

#endif // _APPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appwiz.inc ===
#
# Common makefile include for this project
#

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

# Use the NT product version numbers
USE_NT_PRODUCT_VER = 1
                  
# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF       
!endif

!ifdef DOWNLEVEL_PLATFORM

C_DEFINES       = $(C_DEFINES) -DDOWNLEVEL_PLATFORM -DDOWNLEVEL

!endif

INCLUDES = $(INCLUDES);$(BASEDIR)\private\inc

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                    dlldata.c       \
                    shappmgr_p.c    \
                    statreg.h       \
                    statreg.cpp     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\appwizid.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by WIZ.RC
//

#define DLG_APPLIST             100
#define DLG_INSTUNINSTALL       101

#define DLG_BROWSE              200
#define DLG_PICKFOLDER          201
#define DLG_GETTITLE            202
#define DLG_PICKICON            203
#define DLG_WHICHCFG            204
#define DLG_RMOPTIONS           205

#define DLG_SETUP               300
#define DLG_SETUPBROWSE         301

#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT       
#define DLG_CHGUSR                      302
#define DLG_CHGUSR_UNINSTALL            303
#define DLG_CHGUSRFINISH                304
#define DLG_CHGUSRFINISH_PREV           305
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM

#define DLG_UNCUNINSTALLBROWSE  306
#define DLG_MULTIUSERWARNING    307


#define DLG_DELITEM             400

#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT       
#define IDC_RADIO1                      1001
#define IDC_RADIO2                      1002
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM

#define IDC_BUTTONSETUPFROMLIST 1000
#define IDC_BUTTONSETUP         1001
#define IDC_CMDSTATIC           1002
#define IDC_COMMAND             1003
#define IDC_BROWSE              1004
#define IDC_SEARCHNAME          1005
#define IDC_SEARCHICON          1006
#define IDC_FROMLIST            1009
#define IDC_FROMDISK            1010
#define IDC_APPLIST             1011
#define IDC_SETUPMSG            1012
#define IDC_ICON_WARNING        1013
#define IDC_SWITCHUSER          1014
#define IDB_CURCFG              1015    // Button group
#define IDB_CLEANCFG            1016    // end button group

#define IDC_WIZBMP              1019
#define IDC_TITLE               1020
#define IDC_ICONLIST            1021
#define IDC_FOLDERTREE          1022
#define IDC_OPTIONLIST          1023
#define IDC_OPTIONTIP           1024

#define IDC_REGISTERED_APPS     1025
#define IDC_MODIFYUNINSTALL     1026

#define IDC_BASEBUTTONS         1060
#define IDC_MODIFY              IDC_BASEBUTTONS
#define IDC_REPAIR              IDC_BASEBUTTONS + 1
#define IDC_UNINSTALL           IDC_BASEBUTTONS + 2

#define IDC_NEWFOLDER           1027
#define IDC_DELFOLDER           1028

#define IDC_DELETEITEM          1030
#define IDC_TEXT                1031

#define IDC_INSTINSTR           1040
#define IDC_INSTICON            1041
#define IDC_UNINSTINSTR         1042
#define IDC_UNINSTICON          1043

#define IDC_FORCEX86ENV         1045

#define IDC_NETINSTINSTR        1050
#define IDC_NETINSTICON         1051

#define IDS_UNINSTINSTR         1065
#define IDS_UNINSTINSTR_NEW     1066
#define IDS_UNINSTINSTR_LEGACY  1067

//#define IDC_

#define IDC_STATIC              -1

//
//  Icons
//
#define IDI_CPLICON             1500
#define IDI_LISTINST            1501
#define IDI_DISKINST            1502
#define IDI_UNINSTALL           1503


#define IDS_NAME                2001
#define IDS_INFO                2002
#define IDS_BADPATHMSG          2003
#define IDS_SETUPPRGNAMES       2004
#define IDS_HAVESETUPPRG        2005
#define IDS_NOSETUPPRG          2006
#define IDS_TSHAVESETUPPRG      2007

#define IDS_INSERTDISK          2008
#define IDS_SEARCHING           2009
#define IDS_EXTENSIONS          2010
#define IDS_BADSETUP            2011
#define IDS_DUPLINK             2012
#define IDS_BROWSEEXT           2014
#define IDS_BROWSEFILTER        2015
#define IDS_BROWSETITLE         2016
#define IDS_NOCOPYENV           2017
#define IDS_SETCMD              2018
#define IDS_SPECIALCASE         2019
#define IDS_BROWSEFILTERMSI     2020

#define IDS_DEFBOOTDIR          2021
#define IDS_VMCLOSED            2022
#define IDS_VMSTILLALIVE        2023
#define IDS_GENERICNAME         2024
#define IDS_CHGPROPCLOSED       2025
#define IDS_CHGPROPSTILLALIVE   2026
#define IDS_NOSHORTCUT          2027

#define IDS_SETUPAPPNAMES       2028

#define IDS_UNINSTALL_ERROR         2030
#define IDS_UNINSTALL_FAILED        2031
#define IDS_OK                      2032
#define IDS_1APPWARNTITLE           2033
#define IDS_CANTDELETE              2035
#define IDS_NEWFOLDERSHORT          2036
#define IDS_NEWFOLDERLONG           2037
#define IDS_NONESEL                 2038
#define IDS_NOSUPPORT1              2040
#define IDS_NOSUPPORT2              2041
#define IDS_UNINSTALL_UNCUNACCESSIBLE 2042
#define IDS_CONFIGURE_FAILED        2043
#define IDS_CANT_REMOVE_FROM_REGISTRY 2044

#define IDS_CSHIGHSTRS              2050
#define IDS_CSLOWSTR                2051
#define IDS_AEHIGHSTRS              2052
#define IDS_MOUSEENV                2053
#define IDS_MOUSETSRS               2054
#define IDS_MOUSEDRVS               2055
#define IDS_LOADHIGH                2056
#define IDS_DEVHIGH                 2057
#define IDS_MODNAME                 2060

#define IDS_FILEFOLDERBROWSE_TITLE  2072

#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT       
#define IDS_CHGUSROPT               2081
#define IDS_CHGUSRINSTALL           2082
#define IDS_CHGUSREXECUTE           2083
#define IDS_CHGUSRTITLE             2084
#define IDS_GETINI_FAILED           2085
#define IDS_SETINI_FAILED           2086
#define IDS_CHGUSRUNINSTALL         2087
#define IDS_CHGUSRUNEXECUTE         2088
#define IDS_CHGUSRUNINSTALLMSG		2089
#define IDS_QUERYVALUE_FAILED       2090
#define IDS_CHGUSRFINISH		    2091
#define IDS_CHGUSRFINISH_PREV		2092
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM


#define IDS_INSTALL_ERROR_GENERIC   2100
#define IDS_INSTALL_TRANSFORMCONFLICTS      2101
#define IDS_UNINSTALL_ERROR_GENERIC   2102
#define IDS_MODIFY_ERROR_GENERIC   2103
#define IDS_REPAIR_ERROR_GENERIC   2104

#define IDB_INSTALLBMP          5000
#define IDB_SHORTCUTBMP         5001
#define IDB_DOSCONFIG           5002
#define IDB_LEGACYINSTALLBMP    5003

#define IDB_CHECKSTATES         5100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\awthunk.h ===
#ifndef _AWTHUNK_H_
#define _AWTHUNK_H_

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

// Define the prototypes for each of these forwarders...

EXTERN_C BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);

#endif // _AWTHUNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\arp.h ===
// ARP.h
//

// Default position and size
#define ARP_DEFAULT_POS_X    35
#define ARP_DEFAULT_POS_Y    10
#define ARP_DEFAULT_WIDTH    730
#define ARP_DEFAULT_HEIGHT   530

// Class definitions

// Frame

// Thread-safe API types
#define ARP_SETINSTALLEDITEMCOUNT             0   // pData is count
#define ARP_DECREMENTINSTALLEDITEMCOUNT       1   
#define ARP_INSERTINSTALLEDITEM               2   // InsertItemData struct
#define ARP_INSERTPUBLISHEDITEM               3
#define ARP_INSERTOCSETUPITEM                 4
#define ARP_SETPUBLISHEDFEEDBACKEMPTY         5
#define ARP_POPULATECATEGORYCOMBO             6
#define ARP_PUBLISHEDLISTCOMPLETE             7
#define ARP_SETPUBLISHEDITEMCOUNT             8
#define ARP_DECREMENTPUBLISHEDITEMCOUNT       9
#define ARP_DONEINSERTINSTALLEDITEM           10

#define WM_ARPWORKERCOMPLETE                  WM_USER + 1024

Element* FindDescendentByName(Element* peRoot, LPCWSTR pszName);
Element* GetNthChild(Element *peRoot, UINT index);

// Thread-safe API structures
struct InsertItemData
{
    IInstalledApp* piia;
    IPublishedApp* pipa;
    PUBAPPINFO* ppai;
    COCSetupApp* pocsa;

    WCHAR pszTitle[MAX_PATH];
    WCHAR pszImage[MAX_PATH];
    int iIconIndex;
    ULONGLONG ullSize;
    FILETIME ftLastUsed;
    int iTimesUsed;    
    DWORD dwActions;
    bool bSupportInfo;
    bool bDuplicateName;
};

enum SortType
{
    SORT_NAME = 0,
    SORT_SIZE,
    SORT_TIMESUSED,
    SORT_LASTUSED,
};

class ARPClientCombo;
class Expando;
class Clipper;
class ClientBlock;

enum CLIENTFILTER {
        CLIENTFILTER_OEM,
    CLIENTFILTER_MS,
    CLIENTFILTER_NONMS,
};

class ARPSelector: public Selector
{
public:
    static HRESULT Create(OUT Element** ppElement);
   
    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // Bypass Selector::OnKeyFocusMoved because Selector will change the
    // selection when focus changes, but we don't want that.
    virtual void OnKeyFocusMoved(Element *peFrom, Element *peTo) {Element::OnKeyFocusMoved(peFrom, peTo);}

    virtual Element *GetAdjacent(Element *peFrom, int iNavDir, NavReference const *pnr, bool bKeyable);
};

class ARPFrame : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, bool bDblBuffer, OUT Element** ppElement);

    // Initialize IDs and hold parser, called after contents are filled
    bool Setup(Parser* pParser, int uiStartPane);

    // Thread-safe APIs (do any additional work on callers thread and then marshal)
    void SetInstalledItemCount(UINT cItems);
    void DecrementInstalledItemCount();
    void SetPublishedItemCount(UINT cItems);
    void DecrementPublishedItemCount();
    void SortItemList();
    void SortList(int iNew, int iOld);
    CompareCallback GetCompareFunction();
    void InsertInstalledItem(IInstalledApp* piia);
    void InsertPublishedItem(IPublishedApp* pipa, bool bDuplicateName);
    void InsertOCSetupItem(COCSetupApp* pocsa);
    void PopulateCategoryCombobox();
    SHELLAPPCATEGORYLIST* GetShellAppCategoryList() {return _psacl;}
    void SetShellAppCategoryList(SHELLAPPCATEGORYLIST* psacl) {_psacl = psacl;}
    LPCWSTR GetCurrentPublishedCategory();
    void FeedbackEmptyPublishedList();
    void DirtyPublishedListFlag();
    void DirtyInstalledListFlag();
    void RePopulateOCSetupItemList();
    bool OnClose();     // return 0 to fail

    // Generic events
    virtual void OnEvent(Event* pEvent);
//
// NTRAID#NTBUG9-314154-2001/3/12-brianau   Handle Refresh
//
//    Need to finish this for Whistler.
//
    virtual void OnInput(InputEvent *pEvent);
//
    virtual void OnKeyFocusMoved(Element* peFrom, Element* peTo);
    void OnPublishedListComplete();
    virtual void RestoreKeyFocus() { if(peLastFocused) peLastFocused->SetKeyFocus();}    
    virtual bool CanSetFocus();
    bool GetPublishedComboFilled() {return _bPublishedComboFilled;}
    void SetPublishedComboFilled(bool bPublishedComboFilled) {_bPublishedComboFilled = bPublishedComboFilled;}
    bool GetPublishedListFilled () {return _bPublishedListFilled;}
    void SetPublishedListFilled (bool bPublishedListFilled) {_bPublishedListFilled = bPublishedListFilled;}
    bool IsChangeRestricted();
    virtual SetModalMode(bool ModalMode) { _bInModalMode = ModalMode;}
    HWND GetHostWindow() {if (_pnhh) return _pnhh->GetHWND(); return NULL;}
    void SelectInstalledApp(IInstalledApp* piia);
    void SelectClosestApp(IInstalledApp* piia);
    void UpdateInstalledItems();    
    void RunOCManager();
    void ChangePane(Element *pePane);
    void PutFocusOnList(Selector* peList);

    // If all else fails, focus goes to the Places pane
    Element* FallbackFocus() { return _peOptionList->GetSelection(); }

    HRESULT InitClientCombos(Expando* pexParent, CLIENTFILTER cf);

    HRESULT CreateStyleParser(Parser** ppParser);

    Parser* GetStyleParser() { return _pParserStyle; }
    HRESULT CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement)
    {
        return _pParser->CreateElement(pszResID, peSubstitute, ppElement);
    }

    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // We allocate zero-initialized so you don't need to set things to 0.
    ARPFrame() {_bInDomain = true; _curCategory = CB_ERR; }
    virtual ~ARPFrame();
    HRESULT Initialize(NativeHWNDHost* pnhh, bool fDlbBuffer);

    // Callee thread-safe invoke sink
    virtual void OnInvoke(UINT nType, void* pData);

    // HACK!  The value of 350ms is hard-coded here and in DirectUI
    void ManageAnimations();
    bool IsFrameAnimationEnabled() { return _bAnimationEnabled; }
    int GetAnimationTime() { return IsFrameAnimationEnabled() ? 350 : 0; }

    ClientBlock* FindClientBlock(LPCWSTR pwszType);
    HRESULT LaunchClientCommandAndWait(UINT ids, LPCTSTR pszName, LPTSTR pszCommand);
    void InitProgressDialog();
    void SetProgressFakeMode(bool bFake) { _bFakeProgress = bFake; }
    void SetProgressDialogText(UINT ids, LPCTSTR pszName);
    void EndProgressDialog();

    // Managing the OK button.
    void BlockOKButton()
    {
        if (++_cBlockOK == 1) {
            _peOK->SetEnabled(false);
        }
    }
    void UnblockOKButton()
    {
        if (--_cBlockOK == 0) {
            _peOK->SetEnabled(true);
        }
    }

private:
    NativeHWNDHost* _pnhh;

    // ARP parser (tree resources)
    Parser* _pParser;
    
    // ARP parser for styles (multiple UI files available for different looks)
    Parser* _pParserStyle;
    BOOL _fThemedStyle;
    HANDLE _arH[LASTHTHEME+1];

    // ARP frame option list (navigation bar)
    ARPSelector* _peOptionList;

    // ARP installed item list
    Selector* _peInstalledItemList;
    HDSA _hdsaInstalledItems;
    int _cMaxInstalledItems;

    // ARP published item list
    Selector* _pePublishedItemList;
    HDSA _hdsaPublishedItems;
    int _cMaxPublishedItems;

    // ARP OC Setup item list
    Selector* _peOCSetupItemList;        

    // ARP Current item list
    Selector* _peCurrentItemList;

    // ARP Sort by Combobox
    Combobox* _peSortCombo;

    SHELLAPPCATEGORYLIST* _psacl;
    
    // ARP Published Category Combobox
    Combobox* _pePublishedCategory;
    Element*  _pePublishedCategoryLabel;
    int _curCategory;
    
    Element* peFloater;
    Element* peLastFocused;

    // ARP "customization block" element
    ARPSelector* _peClientTypeList;         // The outer selector

    Expando*     _peOEMClients;             // The four "big switches"
    Expando*     _peMSClients;
    Expando*     _peNonMSClients;
    Expando*     _peCustomClients;

    Element*     _peOK;                     // How to get out
    Element*     _peCancel;

    // ARP Panes
    Element* _peChangePane;
    Element* _peAddNewPane;
    Element* _peAddRmWinPane;
    Element* _pePickAppPane;

    // Number of items blocking the OK button from being enabled
    // (If this is 0, then OK is enabled)
    int      _cBlockOK;

    // ARP Current Sort Type
    SortType CurrentSortType;

    bool _bTerminalServer;
    bool _bPublishedListFilled;
    bool _bInstalledListFilled;
    bool _bOCSetupListFilled;    
    bool _bPublishedComboFilled;
    bool _bDoubleBuffer;
    bool _bInModalMode;
    bool _bSupportInfoRestricted;
    bool _bOCSetupNeeded;
    bool _bInDomain;
    bool _bAnimationEnabled;
    bool _bPickAppInitialized;
    bool _bFakeProgress;
    UINT _uiStartPane;
    class ARPHelp* _pah;

    IProgressDialog* _ppd;
    DWORD   _dwProgressTotal;
    DWORD   _dwProgressSoFar;

    bool ShowSupportInfo(APPINFODATA *paid);
    void PrepareSupportInfo(Element* peHelp, APPINFODATA *paid);
    void RePopulatePublishedItemList();

    // Check for policies, apply as needed.
    void ApplyPolices();

public:

    // ARPFrame IDs (for identifying targets of events)
    static ATOM _idChange;
    static ATOM _idAddNew;
    static ATOM _idAddRmWin;
    static ATOM _idClose;
    static ATOM _idAddFromDisk;
    static ATOM _idAddFromMsft;
    static ATOM _idComponents;
    static ATOM _idSortCombo;
    static ATOM _idCategoryCombo;
    static ATOM _idAddFromCDPane;
    static ATOM _idAddFromMSPane;
    static ATOM _idAddFromNetworkPane;
    static ATOM _idAddWinComponent;
    static ATOM _idPickApps;
    static ATOM _idOptionList;

    // Helper thread handles
    static HANDLE htPopulateInstalledItemList;
    static HANDLE htPopulateAndRenderOCSetupItemList;    
    static HANDLE htPopulateAndRenderPublishedItemList;

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

// Item
class ARPItem : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    void SortBy(int iNew, int iOld);

    // ARP item IDs
    static ATOM _idTitle;
    static ATOM _idIcon;
    static ATOM _idSize;
    static ATOM _idFreq;
    static ATOM _idLastUsed;
    static ATOM _idExInfo;
    static ATOM _idInstalled;    
    static ATOM _idChgRm;
    static ATOM _idChg;
    static ATOM _idRm;
    static ATOM _idAdd;
    static ATOM _idConfigure;
    static ATOM _idSupInfo;
    static ATOM _idItemAction;
    static ATOM _idRow[3];

    IInstalledApp* _piia;
    IPublishedApp* _pipa;
    PUBAPPINFO* _ppai;

    COCSetupApp* _pocsa;

    ARPFrame*    _paf;
    UINT           _iTimesUsed;
    FILETIME       _ftLastUsed;
    ULONGLONG      _ullSize;
    UINT         _iIdx;

    ARPItem() { _piia = NULL; _pipa = NULL; _ppai =  NULL; _paf = NULL; _pocsa = NULL;}
    virtual ~ARPItem();
    HRESULT Initialize();
    void ShowInstalledString(BOOL bInstalled);

};

// Help box
class ARPHelp : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement);
    
    NativeHWNDHost* GetHost() {return _pnhh;}

    virtual void OnDestroy();

    // Generic events
    virtual void OnEvent(Event* pEvent);
    void ARPHelp::SetDefaultFocus();

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPHelp() {_paf =  NULL;}
    virtual ~ARPHelp();
    HRESULT Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer);

private:
    NativeHWNDHost* _pnhh;
    ARPFrame* _paf;
    HRESULT Initialize();
};

class ARPSupportItem : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // Property definitions
    static PropertyInfo* URLProp;

    // Quick property accessors
    const LPWSTR GetURL(Value** ppv)                   DUIQuickGetterInd(GetString(), URL, Specified)
    HRESULT SetURL(LPCWSTR v)                          DUIQuickSetter(CreateString(v), URL)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPSupportItem() { }
    virtual ~ARPSupportItem() { }
    HRESULT Initialize();    

private:
    Element* GetChild(UINT index);
};

class CLIENTINFO
{
public:
    static CLIENTINFO* Create(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey);
    void Delete() { HDelete(this); }

    static int __cdecl QSortCMP(const void*, const void*);
    bool IsSentinel() { return _pszKey == NULL; }
    bool IsKeepUnchanged() { return IsSentinel() && _pe; }
    bool IsPickFromList() { DUIAssertNoMsg(_pe || IsSentinel()); return !_pe; }

    void SetFriendlyName(LPCWSTR pszName)
    {
        FindDescendentByName(_pe, L"radiotext")->SetContentString(pszName);
        FindDescendentByName(_pe, L"setdefault")->SetAccName(pszName);
    }

    void SetMSName(LPCWSTR pszMSName);

    LPCWSTR GetFilteredName(CLIENTFILTER cf)
    {
        LPCWSTR pszName = _pszName;
        if (cf == CLIENTFILTER_MS && _pvMSName && _pvMSName->GetString())
        {
            pszName = _pvMSName->GetString();
        }
        return pszName;
    }

    Element* GetSetDefault()
    {
        return FindDescendentByName(_pe, L"setdefault");
    }

    Element* GetShowCheckbox()
    {
        return FindDescendentByName(_pe, L"show");
    }

    HRESULT SetShowCheckbox(bool bShow)
    {
        return GetShowCheckbox()->SetSelected(bShow);
    }

    bool IsShowChecked()
    {
        return GetShowCheckbox()->GetSelected();
    }

    bool GetInstallFile(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf, bool fFile);
    bool GetInstallCommand(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf);

public:
    ~CLIENTINFO(); // to be used only by HDelete()

private:
    bool Initialize(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey);

public:
    LPWSTR  _pszKey;
    LPWSTR  _pszName;
    Value * _pvMSName;
    Element*_pe;
    bool    _bShown;            // Actual show/hide state
    bool    _bOEMDefault;       // Is this the OEM default client?
    TRIBIT  _tOEMShown;         // OEM desired show/hide state
};

class StringList
{
public:
    StringList() { DUIAssertNoMsg(_pdaStrings == NULL && _pszBuf == NULL); }
    HRESULT SetStringList(LPCTSTR pszInit); // semicolon-separated list
    void Reset();
    ~StringList() { Reset(); }
    bool IsStringInList(LPCTSTR pszFind);

private:
    DynamicArray<LPTSTR>*   _pdaStrings;
    LPTSTR                  _pszBuf;
};

class ClientPicker: public Element
{
    typedef Element super;         // name for our superclass

public:
    static HRESULT Create(OUT Element** ppElement);

    // overrides
    virtual ~ClientPicker();
    HRESULT Initialize();

    // Property definitions
    static PropertyInfo* ClientTypeProp;
    static PropertyInfo* ParentExpandedProp;

    // Quick property accessors
    const LPWSTR GetClientTypeString(Value** ppv) { return (*ppv = GetValue(ClientTypeProp, PI_Specified))->GetString(); }
    HRESULT SetClientTypeString(LPCWSTR v) DUIQuickSetter(CreateString(v), ClientType)
    bool GetParentExpanded() DUIQuickGetter(bool, GetBool(), ParentExpanded, Specified)
    HRESULT SetParentExpanded(bool v) DUIQuickSetter(CreateBool(v), ParentExpanded)

    // System events
    virtual void OnEvent(Event* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // Customization
    CLIENTFILTER GetFilter() { return _cf; }
    HRESULT SetFilter(CLIENTFILTER cf, ARPFrame* paf);

    HRESULT TransferToCustom();

    // to be used by ClientBlock::InitializeClientPicker
    DynamicArray<CLIENTINFO